[
  {
    "ir": "Write a PLpgSQL stored procedure named `insert_student_record` that is defined without any input parameters and without returning any value. This procedure performs a single data manipulation operation: an `INSERT` statement. The `INSERT` statement targets the table named `\"Student\"`. The columns explicitly specified for insertion are `\"StuID\"`, `\"LName\"`, `\"Fname\"`, `\"Age\"`, `\"Sex\"`, `\"Major\"`, `\"Advisor\"`, and `\"city_code\"`. The values provided for these columns are `2001` for `\"StuID\"`, `'Johnson'` for `\"LName\"`, `'Michael'` for `\"Fname\"`, `20` for `\"Age\"`, `'M'` for `\"Sex\"`, `700` for `\"Major\"`, `8801` for `\"Advisor\"`, and `'PIT'` for `\"city_code\"`. This operation adds a new row to the `\"Student\"` table with these specific attribute values.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_student_record()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n    VALUES (2001, 'Johnson', 'Michael', 20, 'M', 700, 8801, 'PIT');\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL insert_student_record();"
    ],
    "summary": "Create a PLpgSQL stored procedure named `insert_student_record` with no parameters. The procedure inserts a single row into the `\"Student\"` table with the following values: `\"StuID\"`=2001, `\"LName\"`='Johnson', `\"Fname\"`='Michael', `\"Age\"`=20, `\"Sex\"`='M', `\"Major\"`=700, `\"Advisor\"`=8801, `\"city_code\"`='PIT'.",
    "natural_language": "Write a PLpgSQL stored procedure called `insert_student_record` that takes no arguments. It should add a single entry to the `\"Student\"` table. Use values that are roughly like these: `\"StuID\"` around 2001, `\"LName\"` something like 'Johnson', `\"Fname\"` maybe 'Michael', `\"Age\"` about 20, `\"Sex\"` as 'M', `\"Major\"` in the 700s, `\"Advisor\"` close to 8801, and `\"city_code\"` similar to 'PIT'.",
    "id": 1
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Student\" table where there exists a corresponding entry in the \"Direct_distance\" table indicating that the student's city, identified by the city_code column in the \"Student\" table, is more than 5000 units distant from the city with the code 'BAL', as specified by the city1_code and city2_code columns in the \"Direct_distance\" table. The procedure does not take any parameters and operates by executing a DELETE statement on the \"Student\" table, using a subquery to check for the existence of a matching record in the \"Direct_distance\" table where the distance column exceeds 5000 and the city1_code matches the city_code of the student, while the city2_code is fixed as 'BAL'.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_distant_students()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Student\" s\n    WHERE EXISTS (\n        SELECT 1\n        FROM \"Direct_distance\" dd\n        WHERE dd.city1_code = s.city_code\n        AND dd.city2_code = 'BAL'\n        AND dd.distance > 5000\n    );\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL delete_distant_students();"
    ],
    "summary": "Create a PLpgSQL stored procedure with no parameters to delete rows from the `\"Student\"` table. Delete students whose `city_code` has a distance greater than 5000 from the city 'BAL', as determined by a matching record in the `\"Direct_distance\"` table where `city1_code` matches the student's `city_code` and `city2_code` is 'BAL'.",
    "natural_language": "Delete students over 5000 km from BAL using Direct_distance.",
    "id": 2
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `update_club_rankings` that accepts five input parameters: `p_club_id` of type `INTEGER`, `p_new_ranking` of type `INTEGER`, `p_leader_name` of type `TEXT`, `p_min_age` of type `INTEGER`, and `p_year_filter` of type `TEXT`. The purpose of this procedure is to update club-related information based on the provided parameters.\n\nThe procedure begins by declaring two local variables: `v_member_count` of type `INTEGER` and `v_avg_ranking` of type `NUMERIC`.\n\nThe first operation performed is a `SELECT` statement that calculates the count of members associated with a specific club and meeting a minimum age criterion. This count is stored in the `v_member_count` variable. The `SELECT` statement retrieves data from the `\"member\"` table, aliased as `m`, and joins it with the `\"club_leader\"` table, aliased as `cl`. The join condition is `m.\"Member_ID\" = cl.\"Member_ID\"`. The `WHERE` clause filters these joined records based on two conditions: `cl.\"Club_ID\"` must be equal to the value provided in the `p_club_id` parameter, and `m.\"Age\"` must be greater than or equal to the value provided in the `p_min_age` parameter.\n\nThe second operation is another `SELECT` statement that calculates the average of the \"Overall_Ranking\" for clubs led by a specific team leader. This average is stored in the `v_avg_ranking` variable. The `SELECT` statement retrieves data from the `\"club\"` table, aliased as `c`. The `WHERE` clause filters these records based on the condition that `c.\"Team_Leader\"` must be equal to the value provided in the `p_leader_name` parameter.\n\nThe third operation is an `UPDATE` statement that modifies records in the `\"club\"` table. For records where the `\"Club_ID\"` column matches the value provided in the `p_club_id` parameter, the `\"Overall_Ranking\"` column is updated to the value provided in the `p_new_ranking` parameter, and the `\"Team_Leader\"` column is updated to the value provided in the `p_leader_name` parameter.\n\nThe fourth and final operation is another `UPDATE` statement that modifies records in the `\"club_leader\"` table. For records where the `\"Club_ID\"` column matches the value provided in the `p_club_id` parameter, the `\"Year_Join\"` column is updated to the value provided in the `p_year_filter` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_club_rankings(\n    p_club_id INTEGER,\n    p_new_ranking INTEGER,\n    p_leader_name TEXT,\n    p_min_age INTEGER,\n    p_year_filter TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_count INTEGER;\n    v_avg_ranking NUMERIC;\nBEGIN\n    SELECT COUNT(*) INTO v_member_count\n    FROM \"member\" m\n    JOIN \"club_leader\" cl ON m.\"Member_ID\" = cl.\"Member_ID\"\n    WHERE cl.\"Club_ID\" = p_club_id AND m.\"Age\" >= p_min_age;\n    \n    SELECT AVG(\"Overall_Ranking\") INTO v_avg_ranking\n    FROM \"club\" c\n    WHERE c.\"Team_Leader\" = p_leader_name;\n    \n    UPDATE \"club\"\n    SET \"Overall_Ranking\" = p_new_ranking,\n        \"Team_Leader\" = p_leader_name\n    WHERE \"Club_ID\" = p_club_id;\n    \n    UPDATE \"club_leader\"\n    SET \"Year_Join\" = p_year_filter\n    WHERE \"Club_ID\" = p_club_id;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL update_club_rankings(1, 10, 'Mack Mitchell', 20, '2020');",
      "CALL update_club_rankings(3, 15, 'Oscar Roan', 25, '2021');",
      "CALL update_club_rankings(4, 20, 'Tony Peters', 18, '2022');",
      "CALL update_club_rankings(1, 30, 'Mack Mitchell', 23, '2019');",
      "CALL update_club_rankings(3, 40, 'Oscar Roan', 19, '2018');"
    ],
    "summary": "Create a PLpgSQL stored procedure named `update_club_rankings` with parameters `p_club_id` (INTEGER), `p_new_ranking` (INTEGER), `p_leader_name` (TEXT), `p_min_age` (INTEGER), and `p_year_filter` (TEXT). First, count members for the given club who meet the minimum age and store the count. Second, calculate the average ranking for clubs led by the specified leader. Third, update the `\"club\"` table for the given club ID with the new ranking and leader name. Finally, update the `\"club_leader\"` table for the given club ID with the new join year.",
    "natural_language": "How can I create a PLpgSQL stored procedure called `update_club_rankings` that takes parameters for club ID, new ranking, leader name, minimum age, and a year filter, and then performs the following steps: counts the members of the specified club who are above the minimum age, calculates the average ranking for clubs led by the given leader, updates the club's ranking and leader name in the `\"club\"` table, and finally updates the join year for that club in the `\"club_leader\"` table?",
    "id": 3
  },
  {
    "ir": "Write a PLpgSQL stored procedure named analyze_member_distribution that accepts five parameters: p_target_club of type INTEGER, p_nationality_filter of type TEXT, p_age_threshold of type INTEGER, p_ranking_limit of type INTEGER, and p_join_year of type TEXT. The procedure begins by declaring two local variables: v_distribution_rank of type NUMERIC and v_total_members of type INTEGER. It then uses a common table expression (CTE) named ranked_clubs to select the Club_ID and Overall_Ranking columns from the club table, calculating the cumulative distribution of the Overall_Ranking using the cume_dist() window function, and filtering the results to include only rows where Overall_Ranking is less than or equal to the p_ranking_limit parameter. The procedure retrieves the rank_distribution value for the club specified by p_target_club from the ranked_clubs CTE and stores it in the v_distribution_rank variable. Next, it counts the number of members in the member table whose Nationality matches the p_nationality_filter parameter and whose Age is greater than the p_age_threshold parameter, storing the result in the v_total_members variable. The procedure then inserts new rows into the club_leader table, setting the Club_ID column to p_target_club, the Member_ID column to the Member_ID from the member table, and the Year_Join column to p_join_year, for members whose Nationality matches p_nationality_filter and whose Member_ID is not already present in the club_leader table for the specified club. Finally, it deletes rows from the club_leader table where the Club_ID matches p_target_club and the Year_Join is less than p_join_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_member_distribution(\n    p_target_club INTEGER,\n    p_nationality_filter TEXT,\n    p_age_threshold INTEGER,\n    p_ranking_limit INTEGER,\n    p_join_year TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_distribution_rank NUMERIC;\n    v_total_members INTEGER;\nBEGIN\n    WITH ranked_clubs AS (\n        SELECT \"Club_ID\", \"Overall_Ranking\",\n               cume_dist() OVER (ORDER BY \"Overall_Ranking\") as rank_distribution\n        FROM \"club\"\n        WHERE \"Overall_Ranking\" <= p_ranking_limit\n    )\n    SELECT rank_distribution INTO v_distribution_rank\n    FROM ranked_clubs\n    WHERE \"Club_ID\" = p_target_club;\n    \n    SELECT COUNT(*) INTO v_total_members\n    FROM \"member\"\n    WHERE \"Nationality\" = p_nationality_filter AND \"Age\" > p_age_threshold;\n    \n    INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\")\n    SELECT p_target_club, \"Member_ID\", p_join_year\n    FROM \"member\"\n    WHERE \"Nationality\" = p_nationality_filter\n    AND \"Member_ID\" NOT IN (SELECT \"Member_ID\" FROM \"club_leader\" WHERE \"Club_ID\" = p_target_club);\n    \n    DELETE FROM \"club_leader\"\n    WHERE \"Club_ID\" = p_target_club AND \"Year_Join\" < p_join_year;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL analyze_member_distribution(1, 'Australia', 20, 100, '2023');",
      "CALL analyze_member_distribution(3, 'Australia', 25, 50, '2022');",
      "CALL analyze_member_distribution(4, 'Australia', 18, 75, '2024');",
      "CALL analyze_member_distribution(1, 'Australia', 22, 60, '2021');",
      "CALL analyze_member_distribution(3, 'Australia', 30, 90, '2020');"
    ],
    "summary": "Create a PLpgSQL stored procedure named `analyze_member_distribution` with parameters `p_target_club` (INTEGER), `p_nationality_filter` (TEXT), `p_age_threshold` (INTEGER), `p_ranking_limit` (INTEGER), and `p_join_year` (TEXT). First, calculate the distribution rank for the target club among clubs with a ranking under the limit. Second, count total members matching the nationality and age criteria. Then, insert new leaders into `club_leader` for the target club from eligible members not already leaders. Finally, delete from `club_leader` where the club matches and the join year is less than the provided year.",
    "natural_language": "List the distribution rank for the target club among clubs with a ranking under the limit, count total members matching the nationality and age criteria, insert new leaders into `club_leader` for the target club from eligible members not already leaders, and delete from `club_leader` where the club matches and the join year is less than the provided year. Create this as a PLpgSQL stored procedure named `analyze_member_distribution` with parameters `p_target_club` (INTEGER), `p_nationality_filter` (TEXT), `p_age_threshold` (INTEGER), `p_ranking_limit` (INTEGER), and `p_join_year` (TEXT).",
    "id": 4
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_club_leadership that accepts five parameters: p_source_club of type INTEGER representing the ID of the source club, p_target_club of type INTEGER representing the ID of the target club, p_member_age_min of type INTEGER specifying the minimum age of eligible members, p_new_club_name of type TEXT for the new name of the target club, and p_transfer_year of type TEXT indicating the year of transfer. The procedure begins by declaring two local variables: v_eligible_member of type INTEGER to store the ID of an eligible member, and v_club_performance of type NUMERIC to store the performance ranking of the target club. It first executes a SELECT statement to find a member from the member table who is also a leader in the club_leader table, belongs to the source club specified by p_source_club, and meets the minimum age requirement specified by p_member_age_min. The result is stored in v_eligible_member, and only one member is selected due to the LIMIT 1 clause. Next, it calculates the cumulative distribution of the target club's overall ranking using the cume_dist() window function, ordering by Overall_Ranking in descending order, and stores this value in v_club_performance. If an eligible member is found (v_eligible_member is not null), the procedure inserts a new record into the club_leader table with the target club ID, the eligible member's ID, and the transfer year. It then updates the club table to change the name of the target club to the new name specified by p_new_club_name. If no eligible member is found, the procedure deletes the target club from the club table if its Overall_Ranking is greater than 50. Additionally, it updates the member table to increment the age of all members who are leaders in the source club by 1 year.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_club_leadership(\n    p_source_club INTEGER,\n    p_target_club INTEGER,\n    p_member_age_min INTEGER,\n    p_new_club_name TEXT,\n    p_transfer_year TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_eligible_member INTEGER;\n    v_club_performance NUMERIC;\nBEGIN\n    SELECT m.\"Member_ID\" INTO v_eligible_member\n    FROM \"member\" m\n    JOIN \"club_leader\" cl ON m.\"Member_ID\" = cl.\"Member_ID\"\n    WHERE cl.\"Club_ID\" = p_source_club AND m.\"Age\" >= p_member_age_min\n    LIMIT 1;\n    \n    SELECT cume_dist() OVER (ORDER BY \"Overall_Ranking\" DESC) INTO v_club_performance\n    FROM \"club\"\n    WHERE \"Club_ID\" = p_target_club;\n    \n    IF v_eligible_member IS NOT NULL THEN\n        INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\")\n        VALUES (p_target_club, v_eligible_member, p_transfer_year);\n        \n        UPDATE \"club\"\n        SET \"Club_Name\" = p_new_club_name\n        WHERE \"Club_ID\" = p_target_club;\n    ELSE\n        DELETE FROM \"club\"\n        WHERE \"Club_ID\" = p_target_club AND \"Overall_Ranking\" > 50;\n        \n        UPDATE \"member\"\n        SET \"Age\" = \"Age\" + 1\n        WHERE \"Member_ID\" IN (SELECT \"Member_ID\" FROM \"club_leader\" WHERE \"Club_ID\" = p_source_club);\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL manage_club_leadership(1, 3, 25, 'Texas Elite', '2024');",
      "CALL manage_club_leadership(4, 8, 30, 'New Champions', '2023');",
      "CALL manage_club_leadership(3, 6, 20, 'Renamed Club', '2025');",
      "CALL manage_club_leadership(1, 4, 35, 'Top Performers', '2024');",
      "CALL manage_club_leadership(6, 1, 22, 'Future Stars', '2023');"
    ],
    "summary": "Create a PLpgSQL stored procedure named `manage_club_leadership` with parameters `p_source_club` (INTEGER), `p_target_club` (INTEGER), `p_member_age_min` (INTEGER), `p_new_club_name` (TEXT), and `p_transfer_year` (TEXT). First, select an eligible member leader from the source club meeting the age minimum. Second, calculate the performance rank of the target club. If a member is found, insert them as a leader for the target club and update the target club's name. If no member is found, delete the target club if its ranking is over 50. Finally, increment the age of all members who are leaders in the source club.",
    "natural_language": "Alright, so we need a PLpgSQL procedure called `manage_club_leadership`. It's gotta take in a few things: `p_source_club` (an integer), `p_target_club` (also an integer), `p_member_age_min` (another integer), `p_new_club_name` (some text), and `p_transfer_year` (text too). Here's the deal: first, pick out a member from the source club who's old enough to be a leader. Then, figure out how the target club's been performing, like its rank. If you find a suitable member, make 'em a leader for the target club and give that club its new name. If you can't find anyone, just axe the target club if its ranking's worse than 50. Oh, and before you finish, bump up the age for everyone who's leading in the source club.",
    "id": 5
  },
  {
    "ir": "Write a PLpgSQL stored procedure named restructure_club_data that takes five parameters: p_club_threshold of type INTEGER, p_member_nationality of type TEXT, p_leader_name of type TEXT, p_new_ranking of type INTEGER, and p_year_update of type TEXT. The procedure begins by declaring two local variables: v_max_club_id of type INTEGER to store the maximum Club_ID from the club table, and v_member_stats of type INTEGER to store the count of distinct Club_IDs from the club_leader table joined with the member table where the member's Nationality matches the p_member_nationality parameter. The procedure first executes a SELECT statement to find the maximum Club_ID from the club table and stores it in v_max_club_id. It then performs another SELECT statement to count the distinct Club_IDs from the club_leader table joined with the member table on Member_ID, where the member's Nationality matches the p_member_nationality parameter, storing the result in v_member_stats. Next, the procedure deletes rows from the club_leader table where the Club_ID is in a subquery that selects Club_IDs from the club table with an Overall_Ranking greater than the p_club_threshold parameter. Following the deletion, the procedure attempts to insert a new row into the club table with the following values: Club_ID as the maximum Club_ID found plus one (or 1 if no maximum exists), Overall_Ranking as p_new_ranking, Team_Leader as p_leader_name, and Club_Name as 'New Club ' concatenated with p_year_update. This insertion only occurs if there is no existing row in the club table with a Team_Leader equal to p_leader_name, and if a conflict on Club_ID occurs, the insertion does nothing.",
    "plsql": "CREATE OR REPLACE PROCEDURE restructure_club_data(\n    p_club_threshold INTEGER,\n    p_member_nationality TEXT,\n    p_leader_name TEXT,\n    p_new_ranking INTEGER,\n    p_year_update TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_max_club_id INTEGER;\n    v_member_stats INTEGER;\nBEGIN\n    SELECT MAX(\"Club_ID\") INTO v_max_club_id\n    FROM \"club\";\n    \n    SELECT COUNT(DISTINCT cl.\"Club_ID\") INTO v_member_stats\n    FROM \"club_leader\" cl\n    JOIN \"member\" m ON cl.\"Member_ID\" = m.\"Member_ID\"\n    WHERE m.\"Nationality\" = p_member_nationality;\n    \n    DELETE FROM \"club_leader\"\n    WHERE \"Club_ID\" IN (\n        SELECT c.\"Club_ID\"\n        FROM \"club\" c\n        WHERE c.\"Overall_Ranking\" > p_club_threshold\n    );\n    \n    INSERT INTO \"club\" (\"Club_ID\", \"Overall_Ranking\", \"Team_Leader\", \"Club_Name\")\n    SELECT \n        COALESCE(v_max_club_id, 0) + 1,\n        p_new_ranking,\n        p_leader_name,\n        'New Club ' || p_year_update\n    WHERE NOT EXISTS (\n        SELECT 1 FROM \"club\" WHERE \"Team_Leader\" = p_leader_name\n    )\n    ON CONFLICT (\"Club_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL restructure_club_data(50, 'Australia', 'John Doe', 10, '2023');",
      "CALL restructure_club_data(70, 'USA', 'Jane Smith', 20, '2024');",
      "CALL restructure_club_data(10, 'Australia', 'Mack Mitchell', 5, '2022');",
      "CALL restructure_club_data(90, 'Canada', 'Oscar Roan', 30, '2025');",
      "CALL restructure_club_data(60, 'UK', 'Tony Peters', 15, '2023');"
    ],
    "summary": "Create a stored procedure named restructure_club_data with parameters p_club_threshold (INTEGER), p_member_nationality (TEXT), p_leader_name (TEXT), p_new_ranking (INTEGER), and p_year_update (TEXT). Find the maximum Club_ID and count distinct clubs for a given nationality. Delete club leaders for clubs with a ranking above the threshold. Insert a new club with an incremented ID, the new ranking, the leader name, and a name containing the year, only if no club with that leader exists. On ID conflict, do nothing.",
    "natural_language": "Create procedure restructure_club_data with params p_club_threshold, p_member_nationality, p_leader_name, p_new_ranking, p_year_update. Get max Club_ID and count distinct clubs for given nationality. Delete leaders from clubs ranked above threshold. Insert new club with incremented ID, new ranking, leader name, and year-inclusive name if leader not present. On conflict, skip.",
    "id": 6
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named optimize_member_assignments that accepts five input parameters: an integer p_min_club_ranking, an integer p_max_member_age, a text p_target_nationality, a text p_assignment_year, and an integer p_leader_threshold. The procedure first declares two local variables: an integer v_optimal_club and a numeric v_performance_score. It begins execution by selecting a single Club_ID from the club table, assigning it to v_optimal_club, where the Overall_Ranking column value falls between the p_min_club_ranking parameter and the p_leader_threshold parameter, ordering the results by Overall_Ranking in ascending order and limiting the result to the first row. Next, using a common table expression named performance_analysis, it calculates a cumulative distribution percentile (perf_score) for each club by applying the cume_dist() window function over all clubs ordered by their Overall_Ranking; it then selects the perf_score value from this CTE where the Club_ID matches the previously identified v_optimal_club and stores this value into the v_performance_score variable. The procedure then performs an update on the member table, setting the Age column to the value of p_max_member_age and the Nationality column to the value of p_target_nationality for all members whose Member_ID is found in a subquery; this subquery selects Member_ID from the member table (aliased as m), performing a left join with the club_leader table (aliased as cl) on m.Member_ID = cl.Member_ID, and includes only those members where no matching record exists in club_leader (cl.Member_ID IS NULL) and where the member's current Age is less than the p_max_member_age parameter. Finally, the procedure updates the club_leader table, setting the Year_Join column to the value of the p_assignment_year parameter for all rows where the Club_ID equals the selected v_optimal_club.",
    "plsql": "CREATE OR REPLACE PROCEDURE optimize_member_assignments(\n    p_min_club_ranking INTEGER,\n    p_max_member_age INTEGER,\n    p_target_nationality TEXT,\n    p_assignment_year TEXT,\n    p_leader_threshold INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_optimal_club INTEGER;\n    v_performance_score NUMERIC;\nBEGIN\n    SELECT \"Club_ID\" INTO v_optimal_club\n    FROM \"club\"\n    WHERE \"Overall_Ranking\" BETWEEN p_min_club_ranking AND p_leader_threshold\n    ORDER BY \"Overall_Ranking\"\n    LIMIT 1;\n    \n    WITH performance_analysis AS (\n        SELECT \"Club_ID\", \"Overall_Ranking\",\n               cume_dist() OVER (ORDER BY \"Overall_Ranking\") as perf_score\n        FROM \"club\"\n    )\n    SELECT perf_score INTO v_performance_score\n    FROM performance_analysis\n    WHERE \"Club_ID\" = v_optimal_club;\n    \n    UPDATE \"member\"\n    SET \"Age\" = p_max_member_age,\n        \"Nationality\" = p_target_nationality\n    WHERE \"Member_ID\" IN (\n        SELECT m.\"Member_ID\"\n        FROM \"member\" m\n        LEFT JOIN \"club_leader\" cl ON m.\"Member_ID\" = cl.\"Member_ID\"\n        WHERE cl.\"Member_ID\" IS NULL AND m.\"Age\" < p_max_member_age\n    );\n    \n    UPDATE \"club_leader\"\n    SET \"Year_Join\" = p_assignment_year\n    WHERE \"Club_ID\" = v_optimal_club;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL optimize_member_assignments(10, 25, 'Australia', '2024', 50);",
      "CALL optimize_member_assignments(1, 30, 'USA', '2023', 100);",
      "CALL optimize_member_assignments(20, 35, 'Canada', '2025', 75);",
      "CALL optimize_member_assignments(5, 28, 'UK', '2024', 60);",
      "CALL optimize_member_assignments(15, 40, 'Germany', '2023', 80);"
    ],
    "summary": "Create a stored procedure named optimize_member_assignments with parameters p_min_club_ranking (INTEGER), p_max_member_age (INTEGER), p_target_nationality (TEXT), p_assignment_year (TEXT), and p_leader_threshold (INTEGER). Select the optimal club based on ranking range. Calculate its performance percentile. Update the age and nationality for members not assigned as leaders and below the age threshold. Update the join year for leaders in the optimal club.",
    "natural_language": "Please construct a stored procedure designated as 'optimize_member_assignments'. This procedure shall accept the following parameters: p_min_club_ranking of type INTEGER, p_max_member_age of type INTEGER, p_target_nationality of type TEXT, p_assignment_year of type TEXT, and p_leader_threshold of type INTEGER. The procedure's logic must first identify the optimal club according to the specified ranking range. Subsequently, it is required to compute the performance percentile for said club. Following this, for members who are not designated as leaders and whose age is below the provided threshold, their age and nationality fields should be updated. Finally, for those members who hold leadership positions within the optimal club, their join year must be updated accordingly.",
    "id": 7
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named add_conference_participation that accepts three input parameters: an integer parameter p_conference_id representing a conference identifier, an integer parameter p_staff_id representing a staff member identifier, and a text parameter p_role describing the participation role. The procedure performs a single operation to insert a new record into the conference_participation table, specifically into the columns \"Conference_ID\", \"staff_ID\", and \"role\", using the values from the corresponding input parameters p_conference_id, p_staff_id, and p_role. This insert operation includes an ON CONFLICT clause that specifies a unique constraint or index on the combination of the \"Conference_ID\" and \"staff_ID\" columns; if an attempt to insert a record results in a conflict because a row with the same \"Conference_ID\" and \"staff_ID\" values already exists in the table, the DO NOTHING action is taken, meaning the conflicting insert is silently skipped without raising an error or making any changes to the existing table data.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_conference_participation(\n    p_conference_id INTEGER,\n    p_staff_id INTEGER,\n    p_role TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO conference_participation (\"Conference_ID\", \"staff_ID\", \"role\")\n    VALUES (p_conference_id, p_staff_id, p_role)\n    ON CONFLICT (\"Conference_ID\", \"staff_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL add_conference_participation(1, 6, 'Speaker');",
      "CALL add_conference_participation(2, 5, 'Sponsor');",
      "CALL add_conference_participation(1, 4, 'Attendee');",
      "CALL add_conference_participation(3, 1, 'Organizer');",
      "CALL add_conference_participation(2, 6, 'Presenter');"
    ],
    "summary": "Create a stored procedure named add_conference_participation with parameters p_conference_id (INTEGER), p_staff_id (INTEGER), and p_role (TEXT). Insert these values into the conference_participation table. If a record with the same conference and staff ID already exists, do nothing.",
    "natural_language": "Hey, can you whip up a stored procedure called add_conference_participation? It needs to take in a conference ID (as an INTEGER), a staff ID (also an INTEGER), and a role (as TEXT). Just pop those values into the conference_participation table. But here's the thingâ€”if there's already an entry with that same conference and staff ID combo, just skip it and don't do anything.",
    "id": 8
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_old_conferences that accepts three input parameters: an integer parameter p_year_threshold, a text parameter p_location, and an integer parameter p_institution_id; the procedure performs a DELETE operation on the conference table, specifically removing all rows where the value in the column named \"Year\" is strictly less than the provided p_year_threshold integer value and simultaneously where the value in the column named \"Location\" exactly matches the provided p_location text string; the integer parameter p_institution_id is declared but is not utilized within the procedure's logic for any condition, operation, or validation.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_conferences(\n    p_year_threshold INTEGER,\n    p_location TEXT,\n    p_institution_id INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM conference\n    WHERE \"Year\" < p_year_threshold AND \"Location\" = p_location;\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL delete_old_conferences(2005, 'Philippines', 1);",
      "CALL delete_old_conferences(2000, 'Japan', 2);",
      "CALL delete_old_conferences(2010, 'USA', 3);",
      "CALL delete_old_conferences(1995, 'Germany', 1);",
      "CALL delete_old_conferences(2020, 'Canada', 2);"
    ],
    "summary": "Create a stored procedure named delete_old_conferences with parameters p_year_threshold (INTEGER), p_location (TEXT), and p_institution_id (INTEGER). Delete conferences older than the threshold year and located at the specified location. The institution_id parameter is unused.",
    "natural_language": "Create a stored procedure, which should be named delete_old_conferences, that accepts three distinct parameters: an integer parameter called p_year_threshold, a text parameter designated as p_location, and an additional integer parameter named p_institution_id. This procedure must meticulously delete all conference records that are older than the specified threshold year and are precisely located at the provided location, while explicitly noting that the institution_id parameter remains entirely unused within the procedure's logic.",
    "id": 9
  },
  {
    "ir": "Write a PLpgSQL stored procedure named insert_new_staff that accepts three input parameters: a text parameter p_name representing the staff member's name, an integer parameter p_age representing the staff member's age, and a text parameter p_nationality representing the staff member's nationality, and performs a single INSERT operation into the database table named staff, specifically populating the columns \"name\", \"Age\", and \"Nationality\" with the values provided by the parameters p_name, p_age, and p_nationality respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_staff(\n    p_name TEXT,\n    p_age INTEGER,\n    p_nationality TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO staff (\"name\", \"Age\", \"Nationality\")\n    VALUES (p_name, p_age, p_nationality);\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL insert_new_staff('Bobby Jackson', 24, 'United States');",
      "CALL insert_new_staff('Casey Jacobsen', 23, 'United Kingdom');",
      "CALL insert_new_staff('Alexander Johnson', 42, 'United States');",
      "CALL insert_new_staff('Emily Smith', 30, 'Canada');",
      "CALL insert_new_staff('Michael Brown', 35, 'Australia');"
    ],
    "summary": "Create a stored procedure named insert_new_staff with parameters p_name (TEXT), p_age (INTEGER), and p_nationality (TEXT). Insert a new record into the staff table with these values.",
    "natural_language": "Develop a stored procedure called insert_new_staff that accepts three input parameters: p_name, which is of type TEXT; p_age, which is an INTEGER; and p_nationality, also of type TEXT. This procedure should be designed to meticulously insert a brand new entry into the existing staff table, carefully populating the appropriate columns with the precise values provided through the specified parameters.",
    "id": 10
  },
  {
    "ir": "Write a PLpgSQL stored procedure named transfer_conference_participation that accepts three input parameters: an integer parameter p_old_conference_id representing the source conference identifier, an integer parameter p_new_conference_id representing the target conference identifier, and a text parameter p_role representing the new role to be assigned. The procedure performs two sequential data manipulation operations on the conference_participation table. First, it executes an INSERT statement that selects all staff_ID values from the conference_participation table where the Conference_ID column matches the provided p_old_conference_id parameter; for each selected staff_ID, it inserts a new row into the conference_participation table with the Conference_ID column set to the p_new_conference_id parameter, the staff_ID column set to the selected staff_ID value, and the role column set to the provided p_role parameter value. Second, it executes a DELETE statement that removes all rows from the conference_participation table where the Conference_ID column equals the provided p_old_conference_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_conference_participation(\n    p_old_conference_id INTEGER,\n    p_new_conference_id INTEGER,\n    p_role TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO conference_participation (\"Conference_ID\", \"staff_ID\", \"role\")\n    SELECT p_new_conference_id, \"staff_ID\", p_role\n    FROM conference_participation\n    WHERE \"Conference_ID\" = p_old_conference_id;\n    \n    DELETE FROM conference_participation\n    WHERE \"Conference_ID\" = p_old_conference_id;\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL transfer_conference_participation(1, 3, 'Attendee');",
      "CALL transfer_conference_participation(2, 1, 'Speaker');",
      "CALL transfer_conference_participation(1, 2, 'Sponsor');",
      "CALL transfer_conference_participation(3, 2, 'Organizer');",
      "CALL transfer_conference_participation(2, 3, 'Presenter');"
    ],
    "summary": "Create a stored procedure named transfer_conference_participation that copies all staff participants from an old conference to a new one, assigning them a specified new role, and then deletes their participation records from the old conference.",
    "natural_language": "Create procedure transfer_conference_participation to copy staff from old to new conference with a new role, then delete old records.",
    "id": 11
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named add_institution that accepts three input parameters: p_institution_name of type TEXT to hold the name of the institution, p_location of type TEXT to hold the geographical location of the institution, and p_founded of type INTEGER to hold the year the institution was founded, and performs a single INSERT operation into the database table named institution, specifically populating the columns \"Institution_Name\", \"Location\", and \"Founded\" with the values provided by the parameters p_institution_name, p_location, and p_founded respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_institution(\n    p_institution_name TEXT,\n    p_location TEXT,\n    p_founded INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO institution (\"Institution_Name\", \"Location\", \"Founded\")\n    VALUES (p_institution_name, p_location, p_founded);\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL add_institution('University of California, Berkeley', 'Berkeley, California', 1868);",
      "CALL add_institution('Stanford University', 'Stanford, California', 1885);",
      "CALL add_institution('Massachusetts Institute of Technology', 'Cambridge, Massachusetts', 1861);",
      "CALL add_institution('Harvard University', 'Cambridge, Massachusetts', 1636);",
      "CALL add_institution('University of Oxford', 'Oxford, England', 1096);"
    ],
    "summary": "Create a stored procedure named add_institution that inserts a new institution record with its name, location, and founding year.",
    "natural_language": "Write a stored procedure called add_institution to insert a new institution record, including its name, location, and founding year.",
    "id": 12
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"UpdateCourseStartDate\" that accepts a single input parameter named `new_date` of data type `TEXT`. The purpose of this procedure is to conditionally update the starting date of a specific course record within the `\"course\"` table. The procedure's execution begins by evaluating a conditional statement: it checks if the `new_date` parameter is not `NULL`. If the `new_date` parameter is indeed not `NULL`, the procedure proceeds to perform an `UPDATE` operation on the `\"course\"` table. This `UPDATE` operation sets the value of the `\"Staring_Date\"` column to the value provided in the `new_date` parameter. The `WHERE` clause of this `UPDATE` statement specifies that only the row where the `\"Course_ID\"` column matches the minimum `\"Course_ID\"` found in the entire `\"course\"` table will be affected. This minimum `\"Course_ID\"` is determined by a subquery: `(SELECT MIN(\"Course_ID\") FROM \"course\")`, which retrieves the smallest existing value from the `\"Course_ID\"` column of the `\"course\"` table. If the `new_date` parameter is `NULL`, no `UPDATE` operation is performed, and the procedure concludes without modifying any data.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"UpdateCourseStartDate\"(new_date TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF new_date IS NOT NULL THEN\n        UPDATE \"course\"\n        SET \"Staring_Date\" = new_date\n        WHERE \"Course_ID\" = (SELECT MIN(\"Course_ID\") FROM \"course\");\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"UpdateCourseStartDate\"('10 May');",
      "CALL \"UpdateCourseStartDate\"('11 May');",
      "CALL \"UpdateCourseStartDate\"('12 May');",
      "CALL \"UpdateCourseStartDate\"('13 May');",
      "CALL \"UpdateCourseStartDate\"('14 May');"
    ],
    "summary": "Create a stored procedure named UpdateCourseStartDate that updates the starting date of the course with the smallest ID to a new date, but only if the provided new date is not null.",
    "natural_language": "Update the starting date for the course with the smallest ID to a new date, but only if the new date is not null, using a stored procedure named UpdateCourseStartDate.",
    "id": 13
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"DeleteOldCourses\" that accepts one input parameter called cutoff_date of type TEXT, which is intended to represent a date string used as a boundary for deletion, and performs a conditional delete operation on the \"course\" table: if the provided cutoff_date parameter is not NULL, the procedure executes a DELETE statement that removes all rows from the \"course\" table where the value in the column named \"Staring_Date\", after being converted to a date using the TO_DATE function with the format mask 'DD Mon' (interpreted as day of month followed by a space and an abbreviated month name), is chronologically earlier than the date derived from the cutoff_date input string, which is also converted to a date using the TO_DATE function with the identical 'DD Mon' format mask.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"DeleteOldCourses\"(cutoff_date TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF cutoff_date IS NOT NULL THEN\n        DELETE FROM \"course\"\n        WHERE TO_DATE(\"Staring_Date\", 'DD Mon') < TO_DATE(cutoff_date, 'DD Mon');\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"DeleteOldCourses\"('1 May');",
      "CALL \"DeleteOldCourses\"('10 May');",
      "CALL \"DeleteOldCourses\"('15 Apr');",
      "CALL \"DeleteOldCourses\"('31 Dec');",
      "CALL \"DeleteOldCourses\"(NULL);"
    ],
    "summary": "Create a stored procedure named DeleteOldCourses that deletes all courses whose starting date (in 'DD Mon' format) is earlier than a specified cutoff date, but only if the cutoff date is provided.",
    "natural_language": "Create procedure DeleteOldCourses to remove courses starting before a given cutoff date, if provided.",
    "id": 14
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"InsertNewCourse\" that accepts a single input parameter called course_name of type TEXT, which represents the name of a new course to be inserted into the database, and within the procedure's logic, first checks if the provided course_name parameter is not NULL, and if this condition is true, performs an INSERT operation into a table named \"course\", specifically targeting the columns \"Course_ID\", \"Staring_Date\", and \"Course\", where for the \"Course_ID\" column value, it executes a subquery to calculate the new identifier by selecting the current maximum numeric value from the \"Course_ID\" column in the \"course\" table and then adding 1 to that maximum, for the \"Staring_Date\" column value, it calls the TO_CHAR function to format the current date and time obtained from the CURRENT_TIMESTAMP function into a string using the 'DD Mon' format mask which results in a day of the month and abbreviated month name like '01 Jan', and for the \"Course\" column value, it directly uses the input parameter course_name.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"InsertNewCourse\"(course_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF course_name IS NOT NULL THEN\n        INSERT INTO \"course\" (\"Course_ID\", \"Staring_Date\", \"Course\")\n        VALUES ((SELECT MAX(\"Course_ID\") + 1 FROM \"course\"), TO_CHAR(CURRENT_TIMESTAMP, 'DD Mon'), course_name);\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"InsertNewCourse\"('History');",
      "CALL \"InsertNewCourse\"('Art');",
      "CALL \"InsertNewCourse\"('Music');",
      "CALL \"InsertNewCourse\"('Physical Education');",
      "CALL \"InsertNewCourse\"('Computer Science');"
    ],
    "summary": "Create a stored procedure named InsertNewCourse that inserts a new course record. It generates a new ID by incrementing the current maximum ID, sets the starting date to today's date in 'DD Mon' format, and uses the provided course name, but only if the name is not null.",
    "natural_language": "Create a stored procedure called InsertNewCourse to add a new course. It should figure out a new ID by taking the highest existing one and adding a bit to it, set the start date to roughly around now formatted in a short date style, and use the given course name, but only if that name is provided and isn't empty.",
    "id": 15
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named \"UpdateCourseName\" that accepts a single input parameter called new_name of type TEXT, which is intended to be the new name value, and within its body, first checks if the provided new_name parameter is not NULL, and if this condition is true, performs an UPDATE operation on the table named \"course\", specifically setting the value of the column \"Course\" to the value of the input parameter new_name, but only for the single row where the value in the \"Course_ID\" column matches the result of a subquery that selects the maximum numerical value from the \"Course_ID\" column within the entire \"course\" table, thereby updating the course name for the record with the highest course identifier.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"UpdateCourseName\"(new_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF new_name IS NOT NULL THEN\n        UPDATE \"course\"\n        SET \"Course\" = new_name\n        WHERE \"Course_ID\" = (SELECT MAX(\"Course_ID\") FROM \"course\");\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"UpdateCourseName\"('History');",
      "CALL \"UpdateCourseName\"('Geography');",
      "CALL \"UpdateCourseName\"('Art');",
      "CALL \"UpdateCourseName\"('Music');",
      "CALL \"UpdateCourseName\"('Physical Education');"
    ],
    "summary": "Create a stored procedure named UpdateCourseName that accepts a TEXT parameter new_name. If new_name is not null, update the course table by setting the Course column to new_name for the row where Course_ID equals the maximum Course_ID in the table.",
    "natural_language": "Update course name to provided text for the highest ID.",
    "id": 16
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `manage_product_complaints` that takes no parameters. This procedure is designed to iterate through a specific subset of products and perform various complaint management actions based on product attributes and existing complaint data.\n\nThe procedure begins by declaring several local variables: `v_product_id` of type `BIGINT` to store product identifiers, `v_category_code` of type `TEXT` to store product category codes, `v_discontinued_date` of type `TIMESTAMPTZ` to store product discontinuation dates, `v_complaint_total` of type `INT` to store the count of complaints for a product, `v_price_threshold` of type `NUMERIC` to store a calculated price threshold, and `v_new_complaint_id` of type `BIGINT` to store a newly generated complaint identifier.\n\nThe core logic of the procedure is encapsulated within a `FOR` loop. This loop iterates over `product_id` values retrieved from the `Products` table. The selection criteria for these `product_id` values are that the `parent_product_id` column in the `Products` table must not be `NULL`. For each `v_product_id` obtained from this initial query, the procedure performs the following steps:\n\n1.  It retrieves the `product_category_code` and `date_product_discontinued` columns from the `Products` table for the current `v_product_id`. These values are stored into the `v_category_code` and `v_discontinued_date` variables, respectively.\n\n2.  It then counts the total number of complaints associated with the current `v_product_id` from the `Complaints` table. This count is stored in the `v_complaint_total` variable.\n\n3.  Following these data retrievals, the procedure enters a conditional block (`IF-ELSIF-ELSE`) to determine the specific action to take for the current product:\n\n    a.  **First Condition (Discontinued Products):** It checks if `v_discontinued_date` is not `NULL` AND if `v_discontinued_date` is earlier than the current timestamp (`CURRENT_TIMESTAMP`). This condition identifies products that have been discontinued in the past.\n        If this condition is true, it further checks if `v_complaint_total` is greater than 0. If there are complaints for a discontinued product, the procedure executes a `DELETE` statement. This `DELETE` statement removes rows from the `Complaints` table where the `product_id` matches the current `v_product_id` AND the `complaint_status_code` is 'Closed'.\n\n    b.  **Second Condition (Food Category Products):** If the first condition is false, the procedure checks if `v_category_code` is equal to 'Food'.\n        If this condition is true, it calculates a `v_price_threshold` by multiplying the `product_price` (retrieved from the `Products` table for the current `v_product_id`) by 0.1.\n        Subsequently, it checks if this calculated `v_price_threshold` is less than 5. If this sub-condition is true, the procedure proceeds to insert a new complaint:\n        i.  It first determines a `v_new_complaint_id` by finding the maximum `complaint_id` in the `Complaints` table, using `COALESCE` to default to 0 if no complaints exist, and then adding 1 to that value.\n        ii. It then executes an `INSERT` statement into the `Complaints` table. The columns being inserted into are `complaint_id`, `product_id`, `customer_id`, `complaint_status_code`, `complaint_type_code`, and `date_complaint_raised`.\n        iii. The values provided for these columns are: `v_new_complaint_id` for `complaint_id`, `v_product_id` for `product_id`, a `customer_id` retrieved from the `Customers` table where `customer_type_code` is 'Good Credit Rating' (limiting to one such customer if multiple exist) for `customer_id`, 'New' for `complaint_status_code`, 'Product Unusable' for `complaint_type_code`, and `CURRENT_TIMESTAMP` for `date_complaint_raised`.\n\n    c.  **Third Condition (Other Products):** If neither the first nor the second condition is true, the procedure executes the `ELSE` block.\n        Within this block, it checks if the remainder of `v_complaint_total` divided by 2 is equal to 0 (i.e., `v_complaint_total` is an even number) using the `MOD` function.\n        If this condition is true, the procedure executes an `UPDATE` statement on the `Complaints` table. This `UPDATE` statement sets the `complaint_outcome_code` column to the uppercase version of the first three characters of `v_category_code` (obtained using `UPPER` and `SUBSTR` functions). This update applies to rows where the `product_id` matches the current `v_product_id` AND the `complaint_outcome_code` is `NULL`.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_product_complaints()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_product_id BIGINT;\n    v_category_code TEXT;\n    v_discontinued_date TIMESTAMPTZ;\n    v_complaint_total INT;\n    v_price_threshold NUMERIC;\n    v_new_complaint_id BIGINT;\nBEGIN\n    FOR v_product_id IN\n        SELECT \"product_id\" FROM \"Products\" WHERE \"parent_product_id\" IS NOT NULL\n    LOOP\n        SELECT \"product_category_code\", \"date_product_discontinued\" INTO v_category_code, v_discontinued_date\n        FROM \"Products\" WHERE \"product_id\" = v_product_id;\n        \n        SELECT COUNT(*) INTO v_complaint_total\n        FROM \"Complaints\"\n        WHERE \"product_id\" = v_product_id;\n        \n        IF v_discontinued_date IS NOT NULL AND v_discontinued_date < CURRENT_TIMESTAMP THEN\n            IF v_complaint_total > 0 THEN\n                DELETE FROM \"Complaints\"\n                WHERE \"product_id\" = v_product_id\n                AND \"complaint_status_code\" = 'Closed';\n            END IF;\n        ELSIF v_category_code = 'Food' THEN\n            SELECT \"product_price\" * 0.1 INTO v_price_threshold\n            FROM \"Products\" WHERE \"product_id\" = v_product_id;\n            \n            IF v_price_threshold < 5 THEN\n                SELECT COALESCE(MAX(\"complaint_id\"), 0) + 1 INTO v_new_complaint_id\n                FROM \"Complaints\";\n                \n                INSERT INTO \"Complaints\" (\"complaint_id\", \"product_id\", \"customer_id\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\")\n                VALUES (\n                    v_new_complaint_id,\n                    v_product_id,\n                    (SELECT \"customer_id\" FROM \"Customers\" WHERE \"customer_type_code\" = 'Good Credit Rating' LIMIT 1),\n                    'New',\n                    'Product Unusable',\n                    CURRENT_TIMESTAMP\n                );\n            END IF;\n        ELSE\n            IF MOD(v_complaint_total, 2) = 0 THEN\n                UPDATE \"Complaints\"\n                SET \"complaint_outcome_code\" = UPPER(SUBSTR(v_category_code, 1, 3))\n                WHERE \"product_id\" = v_product_id\n                AND \"complaint_outcome_code\" IS NULL;\n            END IF;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products"
    ],
    "call_sqls": [
      "CALL manage_product_complaints();"
    ],
    "summary": "Create a stored procedure named manage_product_complaints with no parameters. For each product where parent_product_id is not null, retrieve its category and discontinuation date, and count its complaints. If the product is discontinued, delete its closed complaints. If the category is 'Food' and 10% of its price is less than 5, insert a new 'Product Unusable' complaint for a customer with a 'Good Credit Rating'. Otherwise, if the complaint count is even, update open complaints by setting the outcome code to the uppercase first three characters of the product category.",
    "natural_language": "Alright, so we need a stored procedure called 'manage_product_complaints' that doesn't take any parameters. Here's the deal: for every product that's got a parent product (so its parent_product_id isn't empty), we gotta grab its category and when it got discontinued, and also count up how many complaints it has. If the product's been discontinued, just go ahead and delete any complaints for it that are already closed. Now, if the product's category is 'Food' and ten percent of its price comes to less than five bucks, we need to log a new 'Product Unusable' complaint for a customer who's got a 'Good Credit Rating'. If that's not the case, but the total complaint count is an even number, then we should update all the open complaints for that product. For those, set the outcome code to just the first three letters of the product category, but in all caps.",
    "id": 17
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `reconcile_customer_complaint_data` that takes no parameters. This procedure is designed to iterate through each customer record in the `\"Customers\"` table and, for each customer, perform a series of data reconciliation operations on their associated complaints based on specific criteria derived from their email address, phone number, and complaint history.\n\nThe procedure begins by declaring several local variables: `v_customer` of type `RECORD` to hold the current customer's data, `v_email_domain` of type `TEXT` to store the extracted email domain, `v_phone_prefix` of type `TEXT` to store the extracted phone number prefix, `v_complaint_years` of type `INT` to count distinct years in which a customer raised complaints, `v_product_categories` of type `INT` to count distinct product categories associated with a customer's complaints, and `v_total_complaints` of type `INT` to count the total number of complaints for a customer.\n\nThe core logic is encapsulated within a `FOR` loop that iterates over the result set of a `SELECT` statement. This `SELECT` statement retrieves the `customer_id`, `email_address`, and `phone_number` columns from all rows in the `\"Customers\"` table. For each `v_customer` record obtained from this loop:\n\n1.  The `v_email_domain` variable is assigned the substring of `v_customer.email_address` starting from the character immediately after the '@' symbol. This is achieved using the `SUBSTR` function in conjunction with `POSITION('@' IN v_customer.email_address) + 1`.\n2.  The `v_phone_prefix` variable is assigned the first three characters of `v_customer.phone_number` using the `SUBSTR` function with a starting position of 1 and a length of 3.\n3.  A `SELECT COUNT(DISTINCT EXTRACT(YEAR FROM date_complaint_raised))` statement is executed to count the number of unique years in which the current `v_customer.customer_id` has raised complaints. The result is stored in `v_complaint_years`. This query targets the `\"Complaints\"` table and filters by `customer_id`.\n4.  A `SELECT COUNT(DISTINCT p.product_category_code)` statement is executed to count the number of unique product categories associated with the current `v_customer.customer_id`'s complaints. This query joins the `\"Complaints\"` table (aliased as `c`) with the `\"Products\"` table (aliased as `p`) on `c.product_id = p.product_id`, and filters by `c.customer_id`. The result is stored in `v_product_categories`.\n5.  A `SELECT COUNT(*)` statement is executed to count the total number of complaints for the current `v_customer.customer_id` from the `\"Complaints\"` table. The result is stored in `v_total_complaints`.\n\nFollowing these data retrievals, a conditional logic block (`IF...ELSIF...ELSE`) is executed:\n\n*   **First Condition (`IF v_email_domain LIKE '%.org'`):** If the extracted `v_email_domain` ends with '.org', then a nested `IF` condition is evaluated:\n    *   If `v_complaint_years` is greater than 2, a `DELETE` statement is executed. This statement removes rows from the `\"Complaints\"` table where the `customer_id` matches `v_customer.customer_id`, the `complaint_type_code` is 'Product Failure', and the `date_complaint_closed` column is not `NULL`.\n*   **Second Condition (`ELSIF v_phone_prefix LIKE '470%' OR v_phone_prefix LIKE '069%'`):** If the first condition is false, and the extracted `v_phone_prefix` starts with '470' or starts with '069', then a nested `IF` condition is evaluated:\n    *   If `v_product_categories` is greater than 1, an `INSERT` statement is executed. This statement adds a new row to the `\"Complaints\"` table with the following values:\n        *   `complaint_id`: Calculated as `COALESCE(MAX(complaint_id), 0) + 1` from the `\"Complaints\"` table, effectively generating a new `complaint_id` by taking the maximum existing `complaint_id` (or 0 if no complaints exist) and adding 1.\n        *   `product_id`: Obtained by a subquery `(SELECT product_id FROM \"Products\" WHERE product_category_code = 'Hardware' LIMIT 1)`, which selects the `product_id` of the first product found with a `product_category_code` of 'Hardware'.\n        *   `customer_id`: Set to the current `v_customer.customer_id`.\n        *   `complaint_status_code`: Set to the literal string 'New'.\n        *   `complaint_type_code`: Set to the literal string 'Product Unusable'.\n        *   `date_complaint_raised`: Set to the current timestamp using `CURRENT_TIMESTAMP`.\n*   **Else Condition (`ELSE`):** If neither of the above conditions is met, a final nested `IF` condition is evaluated:\n    *   If `v_total_complaints` is greater than 0 AND the remainder of `v_total_complaints` divided by 3 is 0 (i.e., `v_total_complaints` is a positive multiple of 3), then an `UPDATE` statement is executed. This statement modifies rows in the `\"Complaints\"` table by setting `complaint_status_code` to 'Closed' and `date_complaint_closed` to `CURRENT_TIMESTAMP`. The update is applied to complaints where the `customer_id` matches `v_customer.customer_id`, the `complaint_status_code` is 'New', and the `date_complaint_raised` is older than 6 months from the `CURRENT_TIMESTAMP` (calculated as `CURRENT_TIMESTAMP - INTERVAL '6 months'`).\n\nThe loop continues until all customers from the `\"Customers\"` table have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE reconcile_customer_complaint_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_customer RECORD;\n    v_email_domain TEXT;\n    v_phone_prefix TEXT;\n    v_complaint_years INT;\n    v_product_categories INT;\n    v_total_complaints INT;\nBEGIN\n    FOR v_customer IN\n        SELECT customer_id, email_address, phone_number FROM \"Customers\"\n    LOOP\n        v_email_domain := SUBSTR(v_customer.email_address, POSITION('@' IN v_customer.email_address) + 1);\n        v_phone_prefix := SUBSTR(v_customer.phone_number, 1, 3);\n        \n        SELECT COUNT(DISTINCT EXTRACT(YEAR FROM date_complaint_raised)) INTO v_complaint_years\n        FROM \"Complaints\" WHERE customer_id = v_customer.customer_id;\n        \n        SELECT COUNT(DISTINCT p.product_category_code) INTO v_product_categories\n        FROM \"Complaints\" c\n        JOIN \"Products\" p ON c.product_id = p.product_id\n        WHERE c.customer_id = v_customer.customer_id;\n        \n        SELECT COUNT(*) INTO v_total_complaints\n        FROM \"Complaints\" WHERE customer_id = v_customer.customer_id;\n        \n        IF v_email_domain LIKE '%.org' THEN\n            IF v_complaint_years > 2 THEN\n                DELETE FROM \"Complaints\"\n                WHERE customer_id = v_customer.customer_id\n                AND complaint_type_code = 'Product Failure'\n                AND date_complaint_closed IS NOT NULL;\n            END IF;\n        ELSIF v_phone_prefix LIKE '470%' OR v_phone_prefix LIKE '069%' THEN\n            IF v_product_categories > 1 THEN\n                INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_status_code, complaint_type_code, date_complaint_raised)\n                SELECT \n                    COALESCE(MAX(complaint_id), 0) + 1,\n                    (SELECT product_id FROM \"Products\" WHERE product_category_code = 'Hardware' LIMIT 1),\n                    v_customer.customer_id,\n                    'New',\n                    'Product Unusable',\n                    CURRENT_TIMESTAMP\n                FROM \"Complaints\";\n            END IF;\n        ELSE\n            IF v_total_complaints > 0 AND MOD(v_total_complaints, 3) = 0 THEN\n                UPDATE \"Complaints\"\n                SET complaint_status_code = 'Closed',\n                    date_complaint_closed = CURRENT_TIMESTAMP\n                WHERE customer_id = v_customer.customer_id\n                AND complaint_status_code = 'New'\n                AND date_complaint_raised < CURRENT_TIMESTAMP - INTERVAL '6 months';\n            END IF;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products"
    ],
    "call_sqls": [
      "CALL reconcile_customer_complaint_data();"
    ],
    "summary": "Create a stored procedure named reconcile_customer_complaint_data with no parameters. For each customer, extract their email domain and phone prefix. Count their distinct complaint years, distinct product categories from complaints, and total complaints. If the email domain ends with '.org' and complaint years exceed 2, delete their closed 'Product Failure' complaints. Else if the phone prefix starts with '470' or '069' and product categories exceed 1, insert a new 'Product Unusable' complaint for a 'Hardware' product. Else if total complaints are a positive multiple of 3, update their 'New' complaints older than 6 months to 'Closed' status.",
    "natural_language": "Alright, so we need a stored procedure, call it reconcile_customer_complaint_data, and it doesn't need any parameters. Here's the deal: for every customer, grab the part of their email after the '@' and the first few digits of their phone number. Then, figure out how many different years they've filed complaints, how many different types of products they've complained about, and their total number of complaints. Now, the rules: if the email ends with '.org' and they've complained in more than 2 different years, go ahead and delete any of their old complaints that are marked 'Closed' and are about 'Product Failure'. If that's not the case, but their phone number starts with '470' or '069' and they've complained about more than one type of product, then add a new complaint for them for a 'Hardware' product, calling it 'Product Unusable'. Last one: if none of those fit, but their total complaint count is a positive number you can evenly divide by 3, then find any of their complaints that are still 'New' and are older than six months, and change their status to 'Closed'.",
    "id": 18
  },
  {
    "ir": "Write a PLpgSQL stored procedure named update_member_ranks_based_on_college that iterates over records from a query joining the member, college, and round tables, selecting columns Member_ID, College_ID, College_Location, and Rank_in_Round where Round_ID is not null. For each record, calculate the length of the trimmed College_Location string and determine a rank adjustment by taking the modulus of this length with 5. If the rank adjustment is 0, increase Rank_in_Round by 2 for the corresponding Member_ID in the round table. If the rank adjustment is 1, decrease Rank_in_Round by 1 for the Member_ID in the round table, ensuring Rank_in_Round remains greater than 1. If the rank adjustment is 2, convert the Decoration_Theme to uppercase for the Member_ID in the round table using the UPPER() function. If the rank adjustment is 3, delete rows from the round table for the Member_ID where Rank_in_Round is greater than 3. If the rank adjustment is 4, insert a new row into the round table with the Member_ID, a Decoration_Theme of 'Generated Theme', and a Rank_in_Round of 5.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_member_ranks_based_on_college()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_record RECORD;\n    v_rank_adjustment INTEGER;\n    v_college_location_length INTEGER;\nBEGIN\n    FOR v_member_record IN\n        SELECT m.\"Member_ID\", m.\"College_ID\", c.\"College_Location\", r.\"Rank_in_Round\"\n        FROM member m\n        LEFT JOIN college c ON m.\"College_ID\" = c.\"College_ID\"\n        LEFT JOIN round r ON m.\"Member_ID\" = r.\"Member_ID\"\n        WHERE r.\"Round_ID\" IS NOT NULL\n    LOOP\n        v_college_location_length := LENGTH(TRIM(v_member_record.\"College_Location\"));\n        v_rank_adjustment := MOD(v_college_location_length, 5);\n        IF v_rank_adjustment = 0 THEN\n            UPDATE round SET \"Rank_in_Round\" = \"Rank_in_Round\" + 2 WHERE \"Member_ID\" = v_member_record.\"Member_ID\";\n        ELSIF v_rank_adjustment = 1 THEN\n            UPDATE round SET \"Rank_in_Round\" = \"Rank_in_Round\" - 1 WHERE \"Member_ID\" = v_member_record.\"Member_ID\" AND \"Rank_in_Round\" > 1;\n        ELSIF v_rank_adjustment = 2 THEN\n            UPDATE round SET \"Decoration_Theme\" = UPPER(\"Decoration_Theme\") WHERE \"Member_ID\" = v_member_record.\"Member_ID\";\n        ELSIF v_rank_adjustment = 3 THEN\n            DELETE FROM round WHERE \"Member_ID\" = v_member_record.\"Member_ID\" AND \"Rank_in_Round\" > 3;\n        ELSE\n            INSERT INTO round (\"Member_ID\", \"Decoration_Theme\", \"Rank_in_Round\")\n            VALUES (v_member_record.\"Member_ID\", 'Generated Theme', 5);\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "CALL update_member_ranks_based_on_college();"
    ],
    "summary": "Create a stored procedure named update_member_ranks_based_on_college with no parameters. For each member with a round record, join member, college, and round tables to get Member_ID, College_ID, College_Location, and Rank_in_Round. Calculate a rank adjustment as the length of the trimmed College_Location modulo 5. If adjustment is 0, increase Rank_in_Round by 2. If 1, decrease Rank_in_Round by 1 (minimum 1). If 2, uppercase the Decoration_Theme. If 3, delete round records for that member where Rank_in_Round > 3. If 4, insert a new round record with 'Generated Theme' and Rank_in_Round 5.",
    "natural_language": "How can I create a stored procedure called update_member_ranks_based_on_college with no parameters that, for each member with a round record, joins the member, college, and round tables to get Member_ID, College_ID, College_Location, and Rank_in_Round, calculates a rank adjustment as the length of the trimmed College_Location modulo 5, and then performs specific updates: increasing Rank_in_Round by 2 if the adjustment is 0, decreasing it by 1 (to a minimum of 1) if it's 1, uppercasing the Decoration_Theme if it's 2, deleting round records for that member where Rank_in_Round is greater than 3 if it's 3, or inserting a new round record with 'Generated Theme' and Rank_in_Round 5 if it's 4?",
    "id": 19
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_college_leader_analysis that takes no parameters and processes each college record sequentially in ascending order of its College_ID column from the college table. For each college ID value, it first calculates the total number of associated members by counting rows in the member table where the College_ID matches the current college ID, storing the result in variable v_member_count. It then calculates the number of distinct members from that college who have participated in any round by performing a count of distinct Member_ID values from the round table after joining it with the member table on Member_ID where the member's College_ID matches the current college ID, storing this result in variable v_round_count. It retrieves the Leader_Name for the current college from the college table into variable v_leader_name_text and computes the length of this name after trimming any leading or trailing spaces, storing the length in variable v_name_length. The procedure then executes a series of conditional operations: if both v_member_count and v_round_count are exactly zero, it deletes the current college's record from the college table; else if v_member_count is greater than two and v_round_count is greater than zero, it updates the current college's Leader_Name in the college table by concatenating the string ' (Active)' to the existing name; else if v_member_count is two or fewer and the trimmed leader name length is exactly divisible by three (i.e., MOD(v_name_length, 3) = 0), it updates the Country column to 'International' for all members in the member table belonging to the current college; else if v_round_count is greater than v_member_count, it updates the Decoration_Theme column in the round table for all rounds associated with any member from the current college by concatenating an asterisk '*' to the existing theme, using a subquery to identify the relevant Member_ID values from the member table; else if the trimmed leader name length is even (i.e., MOD(v_name_length, 2) = 0), it inserts a new record into the member table with the Name column set to the current college's leader name, the Country column set to 'Unknown', and the College_ID set to the current college ID; otherwise, as a final default action, it updates the College_Location column for the current college in the college table by reversing the order of characters in the existing location string using the REVERSE function.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_college_leader_analysis()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_college_id_val INTEGER;\n    v_leader_name_text TEXT;\n    v_member_count INTEGER;\n    v_round_count INTEGER;\n    v_name_length INTEGER;\nBEGIN\n    FOR v_college_id_val IN SELECT \"College_ID\" FROM college ORDER BY \"College_ID\"\n    LOOP\n        SELECT COUNT(*) INTO v_member_count FROM member WHERE \"College_ID\" = v_college_id_val;\n        SELECT COUNT(DISTINCT r.\"Member_ID\") INTO v_round_count\n        FROM round r\n        JOIN member m ON r.\"Member_ID\" = m.\"Member_ID\"\n        WHERE m.\"College_ID\" = v_college_id_val;\n        SELECT \"Leader_Name\" INTO v_leader_name_text FROM college WHERE \"College_ID\" = v_college_id_val;\n        v_name_length := LENGTH(TRIM(v_leader_name_text));\n        IF v_member_count = 0 AND v_round_count = 0 THEN\n            DELETE FROM college WHERE \"College_ID\" = v_college_id_val;\n        ELSIF v_member_count > 2 AND v_round_count > 0 THEN\n            UPDATE college SET \"Leader_Name\" = CONCAT(\"Leader_Name\", ' (Active)') WHERE \"College_ID\" = v_college_id_val;\n        ELSIF v_member_count <= 2 AND MOD(v_name_length, 3) = 0 THEN\n            UPDATE member SET \"Country\" = 'International' WHERE \"College_ID\" = v_college_id_val;\n        ELSIF v_round_count > v_member_count THEN\n            UPDATE round SET \"Decoration_Theme\" = CONCAT(\"Decoration_Theme\", '*') WHERE \"Member_ID\" IN (SELECT \"Member_ID\" FROM member WHERE \"College_ID\" = v_college_id_val);\n        ELSIF MOD(v_name_length, 2) = 0 THEN\n            INSERT INTO member (\"Name\", \"Country\", \"College_ID\") VALUES (v_leader_name_text, 'Unknown', v_college_id_val);\n        ELSE\n            UPDATE college SET \"College_Location\" = REVERSE(\"College_Location\") WHERE \"College_ID\" = v_college_id_val;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "CALL process_college_leader_analysis();"
    ],
    "summary": "Create a stored procedure named process_college_leader_analysis with no parameters. For each college in ascending College_ID order, count its total members and distinct members who participated in rounds. Get the leader's name and its trimmed length. If both counts are zero, delete the college. Else if member count > 2 and round count > 0, append ' (Active)' to the leader's name. Else if member count <= 2 and name length is divisible by 3, update all its members' Country to 'International'. Else if round count > member count, append '*' to the Decoration_Theme for all rounds of its members. Else if name length is even, insert a new member with the leader's name and Country 'Unknown'. Otherwise, reverse the College_Location string.",
    "natural_language": "Can you create a stored procedure called 'process_college_leader_analysis' that takes no parameters? For each college, ordered by College_ID ascending, it should count the total members and the distinct members who joined rounds, and also get the leader's name and its trimmed length. What actions should be taken if both counts are zero? What if the member count is greater than 2 and the round count is greater than 0? What should happen when the member count is 2 or less and the name length is divisible by 3? How about when the round count exceeds the member count? What if the leader's name length is even? And what is the default action if none of these conditions are met?",
    "id": 20
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `transform_round_data_with_conditions` that takes no parameters. This procedure is designed to iterate through each record in the `\"round\"` table, ordered by the `\"Round_ID\"` column, and apply conditional data transformations based on related information from the `\"member\"` and `\"college\"` tables.\n\nThe procedure begins by declaring six local variables: `v_round_id_val` of type `INTEGER`, `v_member_id_val` of type `INTEGER`, `v_theme_text` of type `TEXT`, `v_rank_val` of type `INTEGER`, `v_country_text` of type `TEXT`, and `v_college_name_text` of type `TEXT`.\n\nIt then enters a `FOR` loop that iterates over each `\"Round_ID\"` from the `\"round\"` table, processing them in ascending order of `\"Round_ID\"`. Inside this loop, for each `v_round_id_val`:\n\n1.  A `SELECT` statement is executed to retrieve specific data for the current round. It selects `\"Member_ID\"`, `\"Decoration_Theme\"`, and `\"Rank_in_Round\"` from the `\"round\"` table (aliased as `r`). It also performs a `LEFT JOIN` with the `\"member\"` table (aliased as `m`) on `r.\"Member_ID\" = m.\"Member_ID\"` to retrieve the `\"Country\"` from the `\"member\"` table. Furthermore, it performs another `LEFT JOIN` with the `\"college\"` table (aliased as `c`) on `m.\"College_ID\" = c.\"College_ID\"` to retrieve the `\"Name\"` from the `\"college\"` table. The results of this `SELECT` statement are then assigned to the declared variables: `v_member_id_val`, `v_theme_text`, `v_rank_val`, `v_country_text`, and `v_college_name_text` respectively. The `WHERE` clause `r.\"Round_ID\" = v_round_id_val` ensures that data for the current round being processed is fetched.\n\n2.  Following the data retrieval, a series of `IF-ELSIF-ELSE` conditional statements are evaluated to determine which action to perform on the current round's data:\n\n    *   **Condition 1:** If `v_country_text` is exactly 'United States' AND `v_rank_val` is less than 3, then an `UPDATE` statement is executed on the `\"round\"` table. This `UPDATE` prepends the string 'US_' to the existing value of the `\"Decoration_Theme\"` column for the row where `\"Round_ID\"` matches `v_round_id_val`. The `CONCAT` function is used for string concatenation.\n\n    *   **Condition 2:** Else if `v_country_text` is exactly 'Canada' AND `v_college_name_text` is NOT NULL, then an `UPDATE` statement is executed on the `\"round\"` table. This `UPDATE` modifies the `\"Rank_in_Round\"` column by adding the length of the trimmed `v_college_name_text` to its current value for the row where `\"Round_ID\"` matches `v_round_id_val`. The `LENGTH` function calculates the length of the string, and `TRIM` removes leading/trailing spaces.\n\n    *   **Condition 3:** Else if `v_theme_text` contains the substring 'Moon' (case-sensitive) OR `v_theme_text` contains the substring 'Dream' (case-sensitive), then a `DELETE` statement is executed on the `\"round\"` table. This `DELETE` removes the row where `\"Round_ID\"` matches `v_round_id_val` AND the `v_rank_val` is an even number (checked using the `MOD` function, where `MOD(v_rank_val, 2) = 0`).\n\n    *   **Condition 4:** Else if `v_college_name_text` is NULL AND `v_country_text` is NOT NULL, then an `INSERT` statement is executed into the `\"college\"` table. This `INSERT` creates a new college record with `\"Name\"` set to 'Auto_' concatenated with `v_country_text`, `\"Leader_Name\"` set to 'System', and `\"College_Location\"` set to 'Unknown'.\n\n    *   **Condition 5:** Else if the `LENGTH` of `v_theme_text` is greater than 15, then an `UPDATE` statement is executed on the `\"round\"` table. This `UPDATE` truncates the `\"Decoration_Theme\"` column to its first 15 characters for the row where `\"Round_ID\"` matches `v_round_id_val`. The `SUBSTRING` function is used for this purpose, extracting characters from position 1 for a length of 15.\n\n    *   **Condition 6:** Else if `v_rank_val` is equal to 1, then an `UPDATE` statement is executed on the `\"member\"` table. This `UPDATE` appends the string ' (Champion)' to the existing value of the `\"Name\"` column for the member whose `\"Member_ID\"` matches `v_member_id_val`. The `CONCAT` function is used for string concatenation.\n\n    *   **Condition 7 (ELSE):** If none of the above conditions are met, then an `UPDATE` statement is executed on the `\"round\"` table. This `UPDATE` doubles the value of the `\"Rank_in_Round\"` column for the row where `\"Round_ID\"` matches `v_round_id_val`.\n\nThe loop continues until all `\"Round_ID\"` values from the `\"round\"` table have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_round_data_with_conditions()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_round_id_val INTEGER;\n    v_member_id_val INTEGER;\n    v_theme_text TEXT;\n    v_rank_val INTEGER;\n    v_country_text TEXT;\n    v_college_name_text TEXT;\nBEGIN\n    FOR v_round_id_val IN SELECT \"Round_ID\" FROM \"round\" ORDER BY \"Round_ID\"\n    LOOP\n        SELECT r.\"Member_ID\", r.\"Decoration_Theme\", r.\"Rank_in_Round\", m.\"Country\", c.\"Name\"\n        INTO v_member_id_val, v_theme_text, v_rank_val, v_country_text, v_college_name_text\n        FROM \"round\" r\n        LEFT JOIN \"member\" m ON r.\"Member_ID\" = m.\"Member_ID\"\n        LEFT JOIN \"college\" c ON m.\"College_ID\" = c.\"College_ID\"\n        WHERE r.\"Round_ID\" = v_round_id_val;\n        IF v_country_text = 'United States' AND v_rank_val < 3 THEN\n            UPDATE \"round\" SET \"Decoration_Theme\" = CONCAT('US_', \"Decoration_Theme\") WHERE \"Round_ID\" = v_round_id_val;\n        ELSIF v_country_text = 'Canada' AND v_college_name_text IS NOT NULL THEN\n            UPDATE \"round\" SET \"Rank_in_Round\" = \"Rank_in_Round\" + LENGTH(TRIM(v_college_name_text)) WHERE \"Round_ID\" = v_round_id_val;\n        ELSIF v_theme_text LIKE '%Moon%' OR v_theme_text LIKE '%Dream%' THEN\n            DELETE FROM \"round\" WHERE \"Round_ID\" = v_round_id_val AND MOD(v_rank_val, 2) = 0;\n        ELSIF v_college_name_text IS NULL AND v_country_text IS NOT NULL THEN\n            INSERT INTO \"college\" (\"Name\", \"Leader_Name\", \"College_Location\") VALUES (CONCAT('Auto_', v_country_text), 'System', 'Unknown');\n        ELSIF LENGTH(v_theme_text) > 15 THEN\n            UPDATE \"round\" SET \"Decoration_Theme\" = SUBSTRING(v_theme_text FROM 1 FOR 15) WHERE \"Round_ID\" = v_round_id_val;\n        ELSIF v_rank_val = 1 THEN\n            UPDATE \"member\" SET \"Name\" = CONCAT(\"Name\", ' (Champion)') WHERE \"Member_ID\" = v_member_id_val;\n        ELSE\n            UPDATE \"round\" SET \"Rank_in_Round\" = \"Rank_in_Round\" * 2 WHERE \"Round_ID\" = v_round_id_val;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "CALL transform_round_data_with_conditions();"
    ],
    "summary": "Create a stored procedure named `transform_round_data_with_conditions` with no parameters. For each record in the `round` table, ordered by `Round_ID`, retrieve related data from the `member` and `college` tables. Then, apply conditional updates, deletes, or inserts based on the retrieved values: prepend 'US_' to the theme for US members with rank < 3; add the length of the college name to the rank for Canadian members with a college; delete rows where the theme contains 'Moon' or 'Dream' and the rank is even; insert a new college record if the country is known but the college name is null; truncate the theme to 15 characters if it's too long; append ' (Champion)' to the member's name for rank 1; otherwise, double the rank value.",
    "natural_language": "Create a stored procedure called `transform_round_data_with_conditions` that takes no parameters. For every record in the `round` table, in order of `Round_ID`, fetch the associated data from the `member` and `college` tables. Then, execute these conditional operations: prepend 'US_' to the theme for US members whose rank is below 3; for Canadian members with a college, add the length of the college name to their rank; delete any rows where the theme includes 'Moon' or 'Dream' and the rank is an even number; if the country is known but the college name is null, insert a new college record; shorten the theme to 15 characters if it exceeds that length; append ' (Champion)' to the member's name for a rank of 1; for all other cases, double the rank value.",
    "id": 21
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the management table where the department_ID column matches the provided department_id parameter, the head_ID column matches the provided head_id parameter, and the temporary_acting column matches the provided acting_status parameter. The procedure takes three input parameters: department_id of type integer, which specifies the department identifier; head_id of type integer, which specifies the head identifier; and acting_status of type text, which specifies the acting status. The DELETE operation is performed based on the conjunction of these three conditions, ensuring that only rows meeting all specified criteria are removed from the management table.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_head_from_department(IN department_id integer, IN head_id integer, IN acting_status text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM management\n    WHERE department_ID = department_id AND head_ID = head_id AND temporary_acting = acting_status;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL remove_head_from_department(1, 5, 'Yes');",
      "CALL remove_head_from_department(2, 4, 'Yes');",
      "CALL remove_head_from_department(3, 6, 'Yes');",
      "CALL remove_head_from_department(15, 4, 'Yes');",
      "CALL remove_head_from_department(2, 5, 'No');"
    ],
    "summary": "Create a stored procedure that deletes rows from the `management` table where the `department_ID` equals the input `department_id`, the `head_ID` equals the input `head_id`, and the `temporary_acting` column equals the input `acting_status`.",
    "natural_language": "Write a procedure to remove some records from the management table for a given department and head, when the temporary acting status is roughly around a certain value.",
    "id": 22
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `count_heads_in_department` that accepts three input parameters: `p_department_id` of type `integer`, `min_age` of type `real`, and `max_age` of type `real`. The purpose of this procedure is to insert new records into the `management` table. Specifically, it inserts the value of the `p_department_id` parameter into the `\"department_ID\"` column, the `\"head_ID\"` from the `head` table into the `\"head_ID\"` column, and the literal string `'No'` into the `\"temporary_acting\"` column. The selection of `head_ID` values from the `head` table is based on two conditions: first, the `\"age\"` column of the `head` table must be inclusively between the `min_age` and `max_age` parameters; and second, the `\"head_ID\"` from the `head` table must not already exist in the `management` table for the specific `department_ID` provided by the `p_department_id` parameter. This second condition is checked by a subquery that selects `\"head_ID\"` from the `management` table where the `\"department_ID\"` column matches the `p_department_id` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE count_heads_in_department(IN p_department_id integer, IN min_age real, IN max_age real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n    SELECT p_department_id, h.\"head_ID\", 'No'\n    FROM head h\n    WHERE h.\"age\" BETWEEN min_age AND max_age\n    AND h.\"head_ID\" NOT IN (\n        SELECT m.\"head_ID\" \n        FROM management m \n        WHERE m.\"department_ID\" = p_department_id\n    );\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL count_heads_in_department(1, 65.0, 70.0);",
      "CALL count_heads_in_department(2, 60.0, 75.0);",
      "CALL count_heads_in_department(3, 68.0, 69.0);",
      "CALL count_heads_in_department(1, 67.0, 68.0);",
      "CALL count_heads_in_department(2, 66.0, 70.0);"
    ],
    "summary": "Create a stored procedure named `count_heads_in_department` that takes a department ID, a minimum age, and a maximum age as parameters. Insert records into the `management` table for the given department ID, using 'No' for the `temporary_acting` column. The `head_ID` values are selected from the `head` table where the head's age is between the provided min and max age, and the head is not already associated with the given department in the `management` table.",
    "natural_language": "Construct a stored procedure designated as `count_heads_in_department`. This procedure shall accept three input parameters: a department identifier, a minimum age threshold, and a maximum age threshold. Its function is to insert records into the `management` table corresponding to the specified department. The `temporary_acting` column for these new entries must be populated with the value 'No'. The `head_ID` values for insertion are to be derived from the `head` table, selecting those heads whose age falls within the stipulated minimum and maximum range. Furthermore, a head is only eligible if a pre-existing association between that head and the given department does not already reside within the `management` table.",
    "id": 23
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `update_department_ranking` that accepts three input parameters: `p_department_id` of type `integer`, `new_ranking` of type `integer`, and `min_employees` of type `real`. The purpose of this procedure is to conditionally update the ranking of a specific department and ensure that all relevant heads are associated with that department in the `management` table. The procedure begins by evaluating a conditional statement. This condition checks for the existence of at least one record in the `department` table where the `Department_ID` column matches the value provided in the `p_department_id` input parameter AND the `Num_Employees` column has a value strictly greater than the `min_employees` input parameter. If this condition evaluates to true (i.e., such a department exists and meets the employee count criterion), then the following two operations are executed sequentially. First, an `UPDATE` statement is performed on the `department` table. This `UPDATE` statement sets the value of the `Ranking` column to the value provided in the `new_ranking` input parameter. This update is applied only to the rows in the `department` table where the `Department_ID` column matches the value of the `p_department_id` input parameter. Second, an `INSERT` statement is executed to add new records into the `management` table. The columns being populated in the `management` table are `\"department_ID\"`, `\"head_ID\"`, and `\"temporary_acting\"`. The values for these columns are derived from a `SELECT` subquery. For the `\"department_ID\"` column, the value is directly taken from the `p_department_id` input parameter. For the `\"head_ID\"` column, the values are selected from the `\"head_ID\"` column of the `head` table, aliased as `h`. For the `\"temporary_acting\"` column, a static string literal 'No' is used. The `SELECT` subquery includes a `WHERE` clause that filters the records from the `head` table. This `WHERE` clause ensures that only those `head_ID` values from the `head` table are considered that are NOT present in a nested subquery. The nested subquery selects the `\"head_ID\"` column from the `management` table, aliased as `m`, where the `\"department_ID\"` column in the `management` table matches the `p_department_id` input parameter. This effectively inserts only those heads into the `management` table for the specified department that are not already associated with it. If the initial `IF EXISTS` condition evaluates to false, no operations are performed, and the procedure concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_department_ranking(IN p_department_id integer, IN new_ranking integer, IN min_employees real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM department d WHERE d.\"Department_ID\" = p_department_id AND d.\"Num_Employees\" > min_employees) THEN\n        UPDATE department \n        SET \"Ranking\" = new_ranking \n        WHERE \"Department_ID\" = p_department_id;\n        \n        INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n        SELECT p_department_id, h.\"head_ID\", 'No'\n        FROM head h\n        WHERE h.\"head_ID\" NOT IN (SELECT m.\"head_ID\" FROM management m WHERE m.\"department_ID\" = p_department_id);\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL update_department_ranking(1, 5, 10000.0);",
      "CALL update_department_ranking(2, 10, 50000.0);",
      "CALL update_department_ranking(3, 1, 1000000.0);",
      "CALL update_department_ranking(1, 2, 5000.0);",
      "CALL update_department_ranking(2, 7, 20000.0);"
    ],
    "summary": "Create a stored procedure named `update_department_ranking` that takes a department ID, a new ranking, and a minimum employee count as parameters. If a department with the given ID exists and has more employees than the minimum, update its ranking to the new value. Then, insert into the `management` table for that department all heads from the `head` table that are not already assigned to it, using 'No' for the `temporary_acting` column.",
    "natural_language": "Create procedure `update_department_ranking`. If department exists and meets employee minimum, update its rank. Then add unassigned heads to its management with 'No' for temporary_acting.",
    "id": 24
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_student_status that accepts a single mandatory input parameter named registration_id_input of type bigint, which represents a unique course registration identifier, and performs a series of conditional operations to manage student test records and logon timestamps based on the existence of enrollment and the status of a test result. The procedure first declares three local variables: test_result_status of type text to store the test outcome, enrollment_exists of type boolean to indicate if the provided registration_id exists in the Student_Course_Enrolment table, and student_id_val of type bigint to temporarily hold a student identifier. The procedure begins by checking for the existence of a record in the Student_Course_Enrolment table where the registration_id column matches the input parameter registration_id_input, storing the boolean result into the enrollment_exists variable. It then attempts to retrieve the test_result column value from the Student_Tests_Taken table for the same registration_id_input, storing it into test_result_status. If a record is found in Student_Tests_Taken (indicated by the PL/pgSQL FOUND variable being true), the procedure evaluates the test_result_status: if the status is exactly the string 'Pass', it checks if enrollment_exists is true, and if so, it retrieves the corresponding student_id from the Student_Course_Enrolment table for the given registration_id_input into student_id_val and subsequently updates the Students table, setting the date_of_latest_logon column to the current timestamp (using the NOW() function) for the row where the student_id matches the retrieved student_id_val. If the test_result_status is exactly the string 'Fail', it updates the Student_Tests_Taken table, setting the date_test_taken column to the current timestamp for the row where the registration_id equals registration_id_input. If a test record exists but the test_result_status is neither 'Pass' nor 'Fail', it deletes from the Student_Tests_Taken table any row for the given registration_id_input where the date_test_taken column value is older than 30 days from the current timestamp (calculated as NOW() - INTERVAL '30 days'). If no test record is found in Student_Tests_Taken for the registration_id_input (indicated by FOUND being false), the procedure checks if enrollment_exists is true, and if so, it inserts a new record into the Student_Tests_Taken table with the provided registration_id_input, the current timestamp for date_test_taken, and the string 'Pending' for the test_result column.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_student_status(registration_id_input bigint)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    test_result_status text;\n    enrollment_exists boolean;\n    student_id_val bigint;\nBEGIN\n    -- Check if the registration_id exists in Student_Course_Enrolment\n    SELECT EXISTS (SELECT 1 FROM \"Student_Course_Enrolment\" WHERE \"registration_id\" = registration_id_input)\n    INTO enrollment_exists;\n\n    -- Now, proceed with checking and updating test status\n    SELECT \"test_result\" INTO test_result_status\n    FROM \"Student_Tests_Taken\"\n    WHERE \"registration_id\" = registration_id_input;\n    \n    IF FOUND THEN -- A test record exists for this registration_id\n        IF test_result_status = 'Pass' THEN\n            -- Only update student logon if enrollment exists\n            IF enrollment_exists THEN\n                SELECT \"student_id\" INTO student_id_val\n                FROM \"Student_Course_Enrolment\"\n                WHERE \"registration_id\" = registration_id_input;\n                \n                UPDATE \"Students\"\n                SET \"date_of_latest_logon\" = NOW()\n                WHERE \"student_id\" = student_id_val;\n            END IF;\n        ELSIF test_result_status = 'Fail' THEN\n            UPDATE \"Student_Tests_Taken\"\n            SET \"date_test_taken\" = NOW()\n            WHERE \"registration_id\" = registration_id_input;\n        ELSE -- Covers cases where test_result_status is not 'Pass' or 'Fail' but a record exists\n            DELETE FROM \"Student_Tests_Taken\"\n            WHERE \"registration_id\" = registration_id_input\n            AND \"date_test_taken\" < NOW() - INTERVAL '30 days';\n        END IF;\n    ELSE -- No test record exists for this registration_id\n        -- Only insert a 'Pending' test result if enrollment exists\n        IF enrollment_exists THEN\n            INSERT INTO \"Student_Tests_Taken\" (\"registration_id\", \"date_test_taken\", \"test_result\")\n            VALUES (registration_id_input, NOW(), 'Pending');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "CALL update_student_status(1);",
      "CALL update_student_status(2);",
      "CALL update_student_status(3);",
      "CALL update_student_status(10);",
      "CALL update_student_status(12);"
    ],
    "summary": "Create a stored procedure named `update_student_status` that takes a `registration_id` as input. Check if the registration exists in the `Student_Course_Enrolment` table. Retrieve the test result from `Student_Tests_Taken`. If a test result is found and is 'Pass', and the enrollment exists, update the student's latest logon timestamp. If the result is 'Fail', update the test's taken date. If the result is neither 'Pass' nor 'Fail', delete old test records (older than 30 days) for that registration. If no test record is found but the enrollment exists, insert a new 'Pending' test record.",
    "natural_language": "Develop a comprehensive stored procedure, which should be designated as `update_student_status`, that accepts a specific `registration_id` as its input parameter. Initially, the procedure must meticulously verify whether the provided registration identifier actually exists within the `Student_Course_Enrolment` table. Subsequently, it should attempt to retrieve the associated test result from the `Student_Tests_Taken` table. In the detailed scenario where a test result is successfully located and its value is precisely 'Pass', and provided that the corresponding enrollment record is confirmed to exist, the procedure must then proceed to update the student's most recent logon timestamp. Conversely, if the retrieved test result is explicitly 'Fail', the procedure is required to update the specific date when that test was taken. However, if the encountered test result is determined to be neither 'Pass' nor 'Fail', the logic must execute a deletion of any obsolete test records for that registration which are older than a thirty-day period. Finally, in the distinct circumstance where no test record whatsoever is discovered for the registration, but the enrollment itself is validated as existing, the procedure must thoughtfully insert a brand new test record with a status of 'Pending'.",
    "id": 25
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `manage_manufacturer_revenue` that takes no parameters. This procedure first declares a local variable named `total_revenue` of type `REAL`. It then proceeds to calculate the sum of all values in the \"Revenue\" column from the \"Manufacturers\" table and stores this aggregated value into the `total_revenue` variable. Following this, it enters a conditional block. If the `total_revenue` is strictly greater than 1000, the procedure inserts a new row into the \"Manufacturers\" table with the following column values: \"Code\" set to 4, \"Name\" set to 'New Manufacturer', \"Headquarter\" set to 'New York', \"Founder\" set to 'John Doe', and \"Revenue\" set to 200.0. If the `total_revenue` is not greater than 1000 but is strictly greater than 500, the procedure updates the \"Manufacturers\" table by adding 50 to the current value of the \"Revenue\" column for the row where the \"Code\" column is equal to 1. If neither of the previous conditions is met (i.e., `total_revenue` is less than or equal to 500), the procedure deletes a row from the \"Manufacturers\" table where the \"Code\" column is equal to 3. After this first conditional block, the procedure enters a second, independent conditional block. It checks if there exists at least one row in the \"Manufacturers\" table where the \"Revenue\" column is strictly greater than 300. If such a row exists, the procedure updates the \"Manufacturers\" table by multiplying the current value of the \"Revenue\" column by 1.05 for the row where the \"Code\" column is equal to 2. If no such row exists (i.e., no manufacturer has a revenue greater than 300), the procedure inserts a new row into the \"Manufacturers\" table with the following column values: \"Code\" set to 5, \"Name\" set to 'Another Manufacturer', \"Headquarter\" set to 'San Francisco', \"Founder\" set to 'Jane Doe', and \"Revenue\" set to 150.0.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_manufacturer_revenue()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_revenue REAL;\nBEGIN\n    SELECT SUM(\"Revenue\") INTO total_revenue FROM \"Manufacturers\";\n    IF total_revenue > 1000 THEN\n        INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\")\n        VALUES (4, 'New Manufacturer', 'New York', 'John Doe', 200.0);\n    ELSIF total_revenue > 500 THEN\n        UPDATE \"Manufacturers\" SET \"Revenue\" = \"Revenue\" + 50 WHERE \"Code\" = 1;\n    ELSE\n        DELETE FROM \"Manufacturers\" WHERE \"Code\" = 3;\n    END IF;\n    IF EXISTS (SELECT 1 FROM \"Manufacturers\" WHERE \"Revenue\" > 300) THEN\n        UPDATE \"Manufacturers\" SET \"Revenue\" = \"Revenue\" * 1.05 WHERE \"Code\" = 2;\n    ELSE\n        INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\")\n        VALUES (5, 'Another Manufacturer', 'San Francisco', 'Jane Doe', 150.0);\n    END IF;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL manage_manufacturer_revenue();"
    ],
    "summary": "Create a stored procedure named `manage_manufacturer_revenue` with no parameters. Calculate the total revenue from the Manufacturers table. If total revenue > 1000, insert a new manufacturer (Code: 4, Name: 'New Manufacturer', Headquarter: 'New York', Founder: 'John Doe', Revenue: 200.0). Else if total revenue > 500, add 50 to the Revenue for the manufacturer with Code 1. Otherwise, delete the manufacturer with Code 3. Then, check if any manufacturer has revenue > 300. If true, multiply the Revenue by 1.05 for the manufacturer with Code 2. If false, insert a new manufacturer (Code: 5, Name: 'Another Manufacturer', Headquarter: 'San Francisco', Founder: 'Jane Doe', Revenue: 150.0).",
    "natural_language": "Hey, can you whip up a stored procedure called `manage_manufacturer_revenue` that doesn't take any parameters? First, figure out the total dough from the Manufacturers table. If that total's over 1000 bucks, slap in a new manufacturer (Code: 4, Name: 'New Manufacturer', Headquarter: 'New York', Founder: 'John Doe', Revenue: 200.0). But if the total's just over 500, then bump up the Revenue by 50 for the guy with Code 1. If neither of those are true, just axe the manufacturer with Code 3. After that, check if any manufacturer is pulling in more than 300. If yes, give the one with Code 2 a 5% raise (multiply its Revenue by 1.05). If not, add another new entry (Code: 5, Name: 'Another Manufacturer', Headquarter: 'San Francisco', Founder: 'Jane Doe', Revenue: 150.0).",
    "id": 26
  },
  {
    "ir": "Write a PLpgSQL stored procedure that adjusts product prices in the Products table based on specific conditions. First, update the Price column by increasing it by 10% for products whose Manufacturer code is found in the Manufacturers table with a Revenue greater than 100. Then, check if any product has a Price greater than 300; if such products exist, delete them from the Products table. If no products have a Price greater than 300, insert a new product with Code 4, Name 'New Product', Price 250, and Manufacturer 2 into the Products table. Next, check if any product has a Price less than 100; if such products exist, update the Price of the product with Code 1 by adding 20 to its current Price. If no products have a Price less than 100, delete the product with Code 2 from the Products table.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_product_prices()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"Products\" SET \"Price\" = \"Price\" * 1.1 WHERE \"Manufacturer\" IN (\n        SELECT \"Code\" FROM \"Manufacturers\" WHERE \"Revenue\" > 100\n    );\n    IF EXISTS (SELECT 1 FROM \"Products\" WHERE \"Price\" > 300) THEN\n        DELETE FROM \"Products\" WHERE \"Price\" > 300;\n    ELSE\n        INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\")\n        VALUES (4, 'New Product', 250, 2);\n    END IF;\n    IF EXISTS (SELECT 1 FROM \"Products\" WHERE \"Price\" < 100) THEN\n        UPDATE \"Products\" SET \"Price\" = \"Price\" + 20 WHERE \"Code\" = 1;\n    ELSE\n        DELETE FROM \"Products\" WHERE \"Code\" = 2;\n    END IF;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL adjust_product_prices();"
    ],
    "summary": "Create a stored procedure to adjust product prices. First, increase the Price by 10% for products whose Manufacturer has Revenue > 100 in the Manufacturers table. Then, if any product has Price > 300, delete those products. If no such products exist, insert a new product (Code: 4, Name: 'New Product', Price: 250, Manufacturer: 2). Next, if any product has Price < 100, add 20 to the Price of the product with Code 1. If no such products exist, delete the product with Code 2.",
    "natural_language": "Adjust product prices: increase by 10% if manufacturer revenue > 100. Delete products with price > 300. If none, insert product (4, 'New Product', 250, 2). If any price < 100, add 20 to product code 1. If none, delete product code 2.",
    "id": 27
  },
  {
    "ir": "Write a PLpgSQL stored procedure that first checks if there are any entries in the \"Products\" table where the \"Price\" column has a value greater than 200. If such entries exist, it updates the \"Price\" column by multiplying it by 0.9 for all rows where the \"Manufacturer\" column equals 1. If no such entries exist, it inserts a new row into the \"Products\" table with the \"Code\" set to 5, the \"Name\" set to 'Discounted Product', the \"Price\" set to 180, and the \"Manufacturer\" set to 3. Next, the procedure checks if there are any entries in the \"Manufacturers\" table where the \"Revenue\" column has a value less than 50. If such entries exist, it deletes the row from the \"Manufacturers\" table where the \"Code\" column equals 3. If no such entries exist, it updates the \"Revenue\" column by adding 100 to its current value for the row where the \"Code\" column equals 2.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_inventory()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Products\" WHERE \"Price\" > 200) THEN\n        UPDATE \"Products\" SET \"Price\" = \"Price\" * 0.9 WHERE \"Manufacturer\" = 1;\n    ELSE\n        INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\")\n        VALUES (5, 'Discounted Product', 180, 3);\n    END IF;\n    IF EXISTS (SELECT 1 FROM \"Manufacturers\" WHERE \"Revenue\" < 50) THEN\n        DELETE FROM \"Manufacturers\" WHERE \"Code\" = 3;\n    ELSE\n        UPDATE \"Manufacturers\" SET \"Revenue\" = \"Revenue\" + 100 WHERE \"Code\" = 2;\n    END IF;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL manage_inventory();"
    ],
    "summary": "Create a stored procedure that first checks for products with Price > 200. If found, apply a 10% discount (multiply by 0.9) to prices for products from Manufacturer 1. If not found, insert a new product (Code: 5, Name: 'Discounted Product', Price: 180, Manufacturer: 3). Then, check for manufacturers with Revenue < 50. If found, delete the manufacturer with Code 3. If not found, add 100 to the Revenue of the manufacturer with Code 2.",
    "natural_language": "Please construct a stored procedure that executes the following operations in sequence. First, ascertain whether any product records exist with a Price exceeding 200. Should such products be identified, apply a ten percent discount, calculated by multiplying the price by 0.9, but restrict this adjustment solely to products associated with Manufacturer 1. Conversely, if no such products are found, insert a new product record with the following attributes: Code 5, Name 'Discounted Product', Price 180, and Manufacturer 3. Subsequently, evaluate whether any manufacturers possess a Revenue value below 50. If manufacturers meeting this criterion are located, delete the manufacturer record where the Code is 3. If no such manufacturers are found, increase the Revenue value by 100 for the manufacturer whose Code is 2.",
    "id": 28
  },
  {
    "ir": "Write a PLpgSQL stored procedure that checks if there exists any row in the \"Manufacturers\" table where the \"Revenue\" column has a value greater than 500. If such a row exists, it updates the \"Headquarter\" column to 'New York' for the row where the \"Code\" column equals 1. If no such row exists, it inserts a new row into the \"Manufacturers\" table with the following values: \"Code\" set to 6, \"Name\" set to 'Tech Corp', \"Headquarter\" set to 'Boston', \"Founder\" set to 'Alice', and \"Revenue\" set to 300.0. Subsequently, the procedure checks if there exists any row in the \"Manufacturers\" table where the \"Revenue\" column has a value less than 100. If such a row exists, it deletes the row where the \"Code\" column equals 2. If no such row exists, it updates the \"Founder\" column to 'Updated Founder' for the row where the \"Code\" column equals 3.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_manufacturer_info()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Manufacturers\" WHERE \"Revenue\" > 500) THEN\n        UPDATE \"Manufacturers\" SET \"Headquarter\" = 'New York' WHERE \"Code\" = 1;\n    ELSE\n        INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\")\n        VALUES (6, 'Tech Corp', 'Boston', 'Alice', 300.0);\n    END IF;\n    IF EXISTS (SELECT 1 FROM \"Manufacturers\" WHERE \"Revenue\" < 100) THEN\n        DELETE FROM \"Manufacturers\" WHERE \"Code\" = 2;\n    ELSE\n        UPDATE \"Manufacturers\" SET \"Founder\" = 'Updated Founder' WHERE \"Code\" = 3;\n    END IF;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL update_manufacturer_info();"
    ],
    "summary": "Create a stored procedure that checks for any manufacturer with Revenue > 500. If found, set the Headquarter to 'New York' for the manufacturer with Code 1. If not found, insert a new manufacturer (Code: 6, Name: 'Tech Corp', Headquarter: 'Boston', Founder: 'Alice', Revenue: 300.0). Then, check for any manufacturer with Revenue < 100. If found, delete the manufacturer with Code 2. If not found, update the Founder to 'Updated Founder' for the manufacturer with Code 3.",
    "natural_language": "Check for revenue > 500. If found, set HQ to 'New York' for code 1. Else, insert manufacturer (6, 'Tech Corp', 'Boston', 'Alice', 300.0). Then, check for revenue < 100. If found, delete code 2. Else, update founder to 'Updated Founder' for code 3.",
    "id": 29
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named product_management that takes no parameters and begins by checking if any row exists in the \"Products\" table where the value in the \"Price\" column is greater than 250; if such a row exists, the procedure updates the \"Products\" table by setting the \"Price\" column to 95% of its current value (multiplying by 0.95) for all rows where the \"Manufacturer\" column equals 2; if no such row exists (i.e., no product has a price over 250), the procedure instead inserts a new row into the \"Products\" table, providing values for the columns \"Code\" (6), \"Name\" ('Premium Product'), \"Price\" (300), and \"Manufacturer\" (1); subsequently, the procedure performs a second conditional check to see if any row exists in the \"Products\" table where the \"Price\" column value is less than 150; if such a row exists, the procedure deletes from the \"Products\" table the single row where the \"Code\" column equals 3; if no such row exists (i.e., no product has a price under 150), the procedure instead updates the \"Products\" table by setting the \"Name\" column to the string 'Updated Product' for the row where the \"Code\" column equals 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE product_management()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Products\" WHERE \"Price\" > 250) THEN\n        UPDATE \"Products\" SET \"Price\" = \"Price\" * 0.95 WHERE \"Manufacturer\" = 2;\n    ELSE\n        INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\")\n        VALUES (6, 'Premium Product', 300, 1);\n    END IF;\n    IF EXISTS (SELECT 1 FROM \"Products\" WHERE \"Price\" < 150) THEN\n        DELETE FROM \"Products\" WHERE \"Code\" = 3;\n    ELSE\n        UPDATE \"Products\" SET \"Name\" = 'Updated Product' WHERE \"Code\" = 1;\n    END IF;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL product_management();"
    ],
    "summary": "Create a stored procedure named `product_management` with no parameters. First, check for any product with Price > 250. If found, reduce the Price by 5% (multiply by 0.95) for all products from Manufacturer 2. If not found, insert a new product (Code: 6, Name: 'Premium Product', Price: 300, Manufacturer: 1). Then, check for any product with Price < 150. If found, delete the product with Code 3. If not found, update the Name to 'Updated Product' for the product with Code 1.",
    "natural_language": "What steps should be taken to create a stored procedure called `product_management` that has no parameters? The procedure should first check if any product has a Price greater than 250. If such a product exists, should it reduce the Price by 5% for all products from Manufacturer 2? If no such product is found, should it instead insert a new product with Code 6, Name 'Premium Product', Price 300, and Manufacturer 1? Then, should it check for any product with a Price less than 150? If found, should it delete the product with Code 3? If not found, should it update the Name to 'Updated Product' for the product with Code 1?",
    "id": 30
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named analyze_mountain_photos that accepts three input parameters: p_mountain_range of type text to specify a mountain range, p_min_height of type real to specify a minimum height threshold, and p_color_filter of type text to specify a photo color filter. The procedure first declares three local variables: v_mountain_count as integer, v_avg_prominence as real, and v_lens_brand as text. It begins by querying the mountain table to count the number of mountains and calculate the average value of the \"Prominence\" column for all mountains where the \"Range\" column equals the p_mountain_range parameter and the \"Height\" column is greater than the p_min_height parameter, storing the results into v_mountain_count and v_avg_prominence respectively. Next, it queries to find the most frequently used camera lens brand for photos of mountains in the specified range with the specified color filter: it selects from the camera_lens table, joining with the photos table on camera_lens.id equals photos.camera_lens_id, and joining with the mountain table on photos.mountain_id equals mountain.id, filtering for rows where mountain.\"Range\" equals p_mountain_range and photos.color equals p_color_filter, groups the results by camera_lens.brand, orders the groups in descending order by the count of rows per brand, and takes the top result, storing the brand name into v_lens_brand. If v_mountain_count is greater than zero, the procedure performs an insert into the photos table, selecting columns camera_lens_id, mountain_id, color, and name: it inserts a constant value of 1 for camera_lens_id, the mountain.id, the p_color_filter parameter for color, and a concatenated string formed by 'Analysis_' and the mountain.name column as the photo name; the source for this insert is the mountain table, filtered for mountains where \"Range\" equals p_mountain_range and \"Height\" is greater than p_min_height, and only for those mountains where a corresponding photo with the same mountain_id and the exact p_color_filter color does not already exist in the photos table, as enforced by a NOT EXISTS subquery. If the v_lens_brand variable is not null, the procedure then performs a delete operation on the photos table, removing rows where the mountain_id is in the set of mountain ids from the mountain table for the specified p_mountain_range, and where the photos.color is not equal to the p_color_filter parameter, and where the photos.camera_lens_id is in the set of ids from the camera_lens table where the brand column equals the identified v_lens_brand.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_mountain_photos(p_mountain_range text, p_min_height real, p_color_filter text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_mountain_count integer;\n    v_avg_prominence real;\n    v_lens_brand text;\nBEGIN\n    SELECT COUNT(*), AVG(\"Prominence\") INTO v_mountain_count, v_avg_prominence\n    FROM mountain\n    WHERE \"Range\" = p_mountain_range AND \"Height\" > p_min_height;\n    \n    SELECT brand INTO v_lens_brand\n    FROM camera_lens cl\n    JOIN photos p ON cl.id = p.camera_lens_id\n    JOIN mountain m ON p.mountain_id = m.id\n    WHERE m.\"Range\" = p_mountain_range AND p.color = p_color_filter\n    GROUP BY cl.brand\n    ORDER BY COUNT(*) DESC\n    LIMIT 1;\n    \n    IF v_mountain_count > 0 THEN\n        INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n        SELECT 1, id, p_color_filter, CONCAT('Analysis_', name)\n        FROM mountain\n        WHERE \"Range\" = p_mountain_range AND \"Height\" > p_min_height\n        AND NOT EXISTS (SELECT 1 FROM photos WHERE mountain_id = mountain.id AND color = p_color_filter);\n    END IF;\n    \n    IF v_lens_brand IS NOT NULL THEN\n        DELETE FROM photos\n        WHERE mountain_id IN (SELECT id FROM mountain WHERE \"Range\" = p_mountain_range)\n        AND color != p_color_filter\n        AND camera_lens_id IN (SELECT id FROM camera_lens WHERE brand = v_lens_brand);\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL analyze_mountain_photos('Lasta Massif', 4200.0, 'RBG');",
      "CALL analyze_mountain_photos('Kollo Massif', 4100.0, 'Black/White');",
      "CALL analyze_mountain_photos('Arsi Mountains', 4150.0, 'RBG');",
      "CALL analyze_mountain_photos('Lasta Massif', 4250.0, 'Black/White');",
      "CALL analyze_mountain_photos('Kollo Massif', 4200.0, 'RBG');"
    ],
    "summary": "Create a stored procedure named analyze_mountain_photos that takes a mountain range, a minimum height, and a color filter as input. It counts mountains and calculates their average prominence for the given range above the height threshold. It finds the most used camera lens brand for photos in that range with the specified color. If mountains were found, it inserts new photos for those mountains (using a default lens, the mountain's ID, the given color, and a prefixed name) only if a photo with that exact color doesn't already exist for the mountain. If a top lens brand was identified, it deletes photos in that range that are not of the specified color and were taken with that brand of lens.",
    "natural_language": "Please construct a stored procedure designated as 'analyze_mountain_photos'. This procedure shall accept the following input parameters: a mountain range, a minimum height threshold, and a color filter. Its operations are to proceed as follows: first, it must count the number of mountains and compute their average prominence, considering only those within the specified range that exceed the provided height threshold. Subsequently, it must identify the camera lens brand most frequently employed for photographs taken within that range that also match the specified color filter. Should any mountains be identified, the procedure is to insert new photographic records for those mountains. Each new record shall utilize a default lens, the respective mountain's identifier, the provided color, and a name with a standard prefix. This insertion is conditional and must only occur if a photograph of the exact specified color does not already exist for the mountain in question. Furthermore, if a predominant lens brand was successfully identified, the procedure must then delete any photographs within the specified range that do not match the specified color and were captured using that particular brand of lens.",
    "id": 31
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_lens_mountains that accepts three parameters: p_brand_name of type text, p_focal_length of type real, and p_country_name of type text. The procedure begins by declaring three local variables: v_lens_id of type integer, v_total_photos of type integer, and v_max_prominence of type real. It then attempts to find the id of a camera lens from the camera_lens table where the brand matches p_brand_name and the focal_length_mm matches p_focal_length, storing the result in v_lens_id. If a matching lens is found (v_lens_id is not null), the procedure proceeds to count the number of photos and determine the maximum prominence of mountains associated with this lens in the photos table, where the mountain's country matches p_country_name. These results are stored in v_total_photos and v_max_prominence, respectively. If no photos are found (v_total_photos equals 0), the procedure inserts up to three new rows into the photos table for mountains in the specified country with prominence greater than 1000, using the lens id and setting the color to 'RBG' and the name to 'Default_' concatenated with the mountain's name. If photos exist but the maximum prominence is less than 2000, the procedure deletes photos from the photos table where the associated mountain's prominence is less than 1000. Otherwise, if the maximum prominence is 2000 or more, the procedure inserts new rows into the photos table for mountains in the specified country with prominence greater than 80% of the maximum prominence, using the lens id and setting the color to 'Black/White' and the name to 'BW_' concatenated with the first ten characters of the mountain's name.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_lens_mountains(p_brand_name text, p_focal_length real, p_country_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lens_id integer;\n    v_total_photos integer;\n    v_max_prominence real;\nBEGIN\n    SELECT id INTO v_lens_id FROM camera_lens WHERE brand = p_brand_name AND focal_length_mm = p_focal_length;\n    \n    IF v_lens_id IS NOT NULL THEN\n        SELECT COUNT(*), MAX(m.\"Prominence\") INTO v_total_photos, v_max_prominence\n        FROM photos p\n        JOIN mountain m ON p.mountain_id = m.id\n        WHERE p.camera_lens_id = v_lens_id AND m.\"Country\" = p_country_name;\n        \n        IF v_total_photos = 0 THEN\n            INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n            SELECT v_lens_id, m.id, 'RBG', CONCAT('Default_', m.name)\n            FROM mountain m\n            WHERE m.\"Country\" = p_country_name AND m.\"Prominence\" > 1000\n            LIMIT 3;\n        ELSIF v_max_prominence < 2000 THEN\n            DELETE FROM photos\n            WHERE camera_lens_id = v_lens_id\n            AND mountain_id IN (SELECT id FROM mountain WHERE \"Prominence\" < 1000);\n        ELSE\n            INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n            SELECT v_lens_id, m.id, 'Black/White', CONCAT('BW_', SUBSTR(m.name, 1, 10))\n            FROM mountain m\n            WHERE m.\"Country\" = p_country_name AND m.\"Prominence\" > v_max_prominence * 0.8;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL process_lens_mountains('Olympus', 15.0, 'Ethiopia');",
      "CALL process_lens_mountains('Olympus', 45.0, 'Ethiopia');",
      "CALL process_lens_mountains('Olympus', 75.0, 'Ethiopia');",
      "CALL process_lens_mountains('Olympus', 15.0, 'United States');",
      "CALL process_lens_mountains('Canon', 50.0, 'Canada');"
    ],
    "summary": "Create a stored procedure named process_lens_mountains that accepts a lens brand, a focal length, and a country name. It finds the lens ID matching the brand and focal length. If found, it counts photos and finds the maximum mountain prominence for that lens in the given country. If no photos exist, it inserts up to three new photos for mountains in that country with prominence > 1000, using the lens, a default color, and a prefixed name. If photos exist but max prominence is below 2000, it deletes photos where the associated mountain's prominence is less than 1000. If max prominence is 2000 or more, it inserts new photos for mountains in that country with prominence greater than 80% of the max, using the lens, a black/white color, and a name prefixed with 'BW_' and the first 10 characters of the mountain name.",
    "natural_language": "Write a stored procedure called process_lens_mountains that takes a lens brand, a focal length, and a country name. First, find the lens ID for the given brand and focal length. If the lens is found, count the photos and determine the maximum mountain prominence for that lens in the specified country. If no photos exist, insert up to three new photos for mountains in that country with prominence over 1000, using the lens, a default color, and a name with a prefix. If photos exist but the maximum prominence is under 2000, delete any photos where the linked mountain's prominence is less than 1000. If the maximum prominence is 2000 or higher, insert new photos for mountains in that country whose prominence exceeds 80% of that maximum, using the lens, a black and white color, and a name starting with 'BW_' followed by the first ten characters of the mountain's name.",
    "id": 32
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `reorganize_photo_data` that accepts three input parameters: `p_old_color` of type `text`, representing the color to be replaced; `p_new_color` of type `text`, representing the new color to be assigned; and `p_range_filter` of type `text`, representing a specific mountain range to filter by. The procedure begins by declaring a local variable `v_mountain_ids` as an array of integers, which will store unique mountain identifiers, and another local variable `v_processed_count` as an integer, initialized to 0, to track the number of mountains processed. A third local variable `v_current_mountain` is declared as an integer to hold the mountain ID during iteration. The procedure then executes a `SELECT` statement to populate the `v_mountain_ids` array. This `SELECT` statement aggregates distinct `mountain_id` values from the `photos` table, aliased as `p`, by joining it with the `mountain` table, aliased as `m`, on the condition `p.mountain_id = m.id`. The selection is further filtered by two conditions: `p.color` must be equal to the `p_old_color` parameter, and the `Range` column in the `mountain` table (accessed as `m.\"Range\"`) must be equal to the `p_range_filter` parameter. After attempting to populate `v_mountain_ids`, the procedure checks if `v_mountain_ids` is not `NULL`. If it is not `NULL`, indicating that at least one mountain ID was found matching the criteria, the procedure enters a `FOREACH` loop. This loop iterates through each `v_current_mountain` integer value present in the `v_mountain_ids` array. Inside the loop, for each `v_current_mountain`, a `DELETE` statement is executed on the `photos` table. This `DELETE` statement removes all rows where `mountain_id` matches the `v_current_mountain` and `color` is equal to `p_old_color`. Immediately following the `DELETE`, an `INSERT` statement is executed to add new rows into the `photos` table. This `INSERT` statement populates the `camera_lens_id`, `mountain_id`, `color`, and `name` columns. The values for these columns are selected from the `photos` table itself. Specifically, `camera_lens_id` is selected directly, `mountain_id` is set to the `v_current_mountain`, `color` is set to `p_new_color`, and `name` is constructed by concatenating the string 'Migrated_' with the original `name` column value. The `SELECT` statement for the `INSERT` is filtered by `mountain_id` being equal to `v_current_mountain` and `color` being equal to `p_old_color`. A `LIMIT 1` clause is applied to this `SELECT` statement, meaning only one row matching these criteria will be selected and inserted for each `v_current_mountain`. After the `INSERT` operation, the `v_processed_count` variable is incremented by 1. Once the `FOREACH` loop completes, the procedure checks if `v_processed_count` is greater than 0. If it is, indicating that at least one mountain's photos were processed, a final `DELETE` statement is executed. This `DELETE` statement targets the `photos` table, aliased as `p`, and uses the `mountain` table, aliased as `m`, in a `USING` clause for joining. The join condition is `p.mountain_id = m.id`. The `DELETE` operation is further constrained by three `AND` conditions: `m.\"Range\"` must be equal to `p_range_filter`, `p.color` must not be equal to `p_old_color` AND `p.color` must not be equal to `p_new_color`, and `p.mountain_id` must not be present in the result of a subquery. This subquery selects `mountain_id` from the `photos` table where `color` is equal to `p_new_color`. This final `DELETE` effectively removes photos associated with the specified range that have colors other than the old or new color, and for which no photo with the `p_new_color` exists for that mountain.",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_photo_data(p_old_color text, p_new_color text, p_range_filter text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_mountain_ids integer[];\n    v_processed_count integer := 0;\n    v_current_mountain integer;\nBEGIN\n    SELECT ARRAY_AGG(DISTINCT mountain_id) INTO v_mountain_ids\n    FROM photos p\n    JOIN mountain m ON p.mountain_id = m.id\n    WHERE p.color = p_old_color AND m.\"Range\" = p_range_filter;\n    \n    IF v_mountain_ids IS NOT NULL THEN\n        FOREACH v_current_mountain IN ARRAY v_mountain_ids\n        LOOP\n            DELETE FROM photos\n            WHERE mountain_id = v_current_mountain AND color = p_old_color;\n            \n            INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n            SELECT camera_lens_id, v_current_mountain, p_new_color, CONCAT('Migrated_', name)\n            FROM photos\n            WHERE mountain_id = v_current_mountain AND color = p_old_color\n            LIMIT 1;\n            \n            v_processed_count := v_processed_count + 1;\n        END LOOP;\n        \n        IF v_processed_count > 0 THEN\n            DELETE FROM photos p\n            USING mountain m\n            WHERE p.mountain_id = m.id\n            AND m.\"Range\" = p_range_filter\n            AND p.color NOT IN (p_old_color, p_new_color)\n            AND p.mountain_id NOT IN (SELECT mountain_id FROM photos WHERE color = p_new_color);\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL reorganize_photo_data('RBG', 'Color', 'Lasta Massif');",
      "CALL reorganize_photo_data('Black/White', 'Monochrome', 'Arsi Mountains');",
      "CALL reorganize_photo_data('RBG', 'RGB', 'Kollo Massif');",
      "CALL reorganize_photo_data('Black/White', 'Grayscale', 'Lasta Massif');",
      "CALL reorganize_photo_data('RBG', 'Full Color', 'Arsi Mountains');"
    ],
    "summary": "Create a stored procedure named reorganize_photo_data that accepts an old color, a new color, and a mountain range. It gets an array of mountain IDs from the specified range that have photos of the old color. For each mountain ID, it deletes all photos of the old color for that mountain and then inserts one new photo (based on the first deleted record) with the new color and a 'Migrated_' prefix on the name. After processing all mountains, if any were processed, it deletes all photos in the specified range that have a color other than the old or new color, but only for mountains that do not have any photo with the new color.",
    "natural_language": "Can you create a stored procedure called reorganize_photo_data that takes an old color, a new color, and a mountain range as inputs? For the specified range, it should obtain an array of mountain IDs with photos of the old color. For each of these mountain IDs, could it delete all old-color photos for that mountain and then insert a single new photo? This new photo should be based on the first deleted record, use the new color, and have a 'Migrated_' prefix added to its name. After processing all mountains, if any mountains were processed, should it then delete all photos in the specified range that have a color other than the old or new color, but only for those mountains that do not have any photo with the new color?",
    "id": 33
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `sync_camera_mountains` that accepts three input parameters: `p_brand_pattern` of type `text`, `p_height_threshold` of type `real`, and `p_color_type` of type `text`. The procedure's primary purpose is to synchronize photo records in the `photos` table based on camera lens brands, mountain heights, and a specified color type.\n\nThe procedure begins by declaring three local variables: `v_lens_record` of type `RECORD` to hold data from the `camera_lens` table, `v_mountain_record` of type `RECORD` to hold data from the `mountain` table, and `v_photo_exists` of type `boolean` to track the existence of a photo record.\n\nThe core logic involves nested loops. The outer loop iterates through each record in the `camera_lens` table. For each `v_lens_record`, it selects the `id`, `brand`, and `name` columns from `camera_lens` where the `brand` column matches the `p_brand_pattern` using a `LIKE` operator with wildcards (`%` before and after the pattern).\n\nInside this outer loop, an inner loop iterates through each record in the `mountain` table. For each `v_mountain_record`, it selects the `id`, `name`, and `\"Height\"` columns from `mountain` where the `\"Height\"` column is strictly greater than the `p_height_threshold` parameter.\n\nWithin the inner loop, for each combination of `v_lens_record` and `v_mountain_record`, the procedure checks if a corresponding photo record already exists in the `photos` table. This is done by executing a `SELECT EXISTS` query that counts rows in `photos` where `camera_lens_id` equals `v_lens_record.id` and `mountain_id` equals `v_mountain_record.id`. The result of this existence check is stored in the `v_photo_exists` boolean variable.\n\nFollowing this check, a conditional statement (`IF NOT v_photo_exists THEN`) determines the next action:\nIf `v_photo_exists` is `FALSE` (meaning no such photo record exists), a new record is inserted into the `photos` table. The `camera_lens_id` is set to `v_lens_record.id`, `mountain_id` is set to `v_mountain_record.id`, `color` is set to the `p_color_type` parameter, and the `name` column is generated by concatenating (`CONCAT`) the `brand` from `v_lens_record` with an underscore (`_`) and the first five characters of the `name` from `v_mountain_record` (obtained using `SUBSTR(v_mountain_record.name, 1, 5)`).\nIf `v_photo_exists` is `TRUE` (meaning a photo record already exists), the `ELSE` block is executed. In this case, existing photo records are deleted from the `photos` table where `camera_lens_id` equals `v_lens_record.id`, `mountain_id` equals `v_mountain_record.id`, and the `color` column is not equal to the `p_color_type` parameter. This effectively updates the color of existing photos if it doesn't match the desired `p_color_type`.\n\nAfter both nested loops have completed, a final `DELETE` statement is executed. This statement removes records from the `photos` table (aliased as `p`) where the `color` column matches the `p_color_type` parameter AND there is no corresponding record in the `camera_lens` table (aliased as `cl`) such that `cl.id` equals `p.camera_lens_id` and `cl.brand` matches the `p_brand_pattern` using a `LIKE` operator with wildcards. This final deletion step cleans up photos that were associated with the specified color type but are no longer linked to a camera lens matching the brand pattern.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_camera_mountains(p_brand_pattern text, p_height_threshold real, p_color_type text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lens_record RECORD;\n    v_mountain_record RECORD;\n    v_photo_exists boolean;\nBEGIN\n    FOR v_lens_record IN SELECT id, brand, name FROM camera_lens WHERE brand LIKE '%' || p_brand_pattern || '%'\n    LOOP\n        FOR v_mountain_record IN SELECT id, name, \"Height\" FROM mountain WHERE \"Height\" > p_height_threshold\n        LOOP\n            SELECT EXISTS (\n                SELECT 1 FROM photos\n                WHERE camera_lens_id = v_lens_record.id AND mountain_id = v_mountain_record.id\n            ) INTO v_photo_exists;\n\n            IF NOT v_photo_exists THEN\n                INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n                VALUES (\n                    v_lens_record.id,\n                    v_mountain_record.id,\n                    p_color_type,\n                    CONCAT(v_lens_record.brand, '_', SUBSTR(v_mountain_record.name, 1, 5))\n                );\n            ELSE\n                DELETE FROM photos\n                WHERE camera_lens_id = v_lens_record.id\n                AND mountain_id = v_mountain_record.id\n                AND color != p_color_type;\n            END IF;\n        END LOOP;\n    END LOOP;\n\n    DELETE FROM photos p\n    WHERE p.color = p_color_type\n    AND NOT EXISTS (\n        SELECT 1 FROM camera_lens cl\n        WHERE cl.id = p.camera_lens_id AND cl.brand LIKE '%' || p_brand_pattern || '%'\n    );\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL sync_camera_mountains('Olympus', 4000.0, 'RBG');",
      "CALL sync_camera_mountains('Canon', 3500.0, 'Black/White');",
      "CALL sync_camera_mountains('Sony', 4100.0, 'Sepia');",
      "CALL sync_camera_mountains('Nikon', 3000.0, 'Vivid');",
      "CALL sync_camera_mountains('Fuji', 4500.0, 'Monochrome');"
    ],
    "summary": "Create a stored procedure named sync_camera_mountains that accepts a lens brand pattern, a height threshold, and a color type. For each camera lens matching the brand pattern and each mountain taller than the threshold, check if a photo for that lens and mountain exists. If not, insert a new photo with the given color and a name combining the lens brand and the first 5 characters of the mountain name. If a photo does exist, delete any existing photos for that lens and mountain where the color is not the specified type. Finally, delete all photos of the specified color that are not linked to a lens matching the brand pattern.",
    "natural_language": "Create a stored procedure called sync_camera_mountains that takes a lens brand pattern, a sort of high elevation number, and a color type. For camera lenses that kind of match the brand pattern and mountains that are pretty tall, see if there's already a photo for that pair. If there isn't one, add a new photo using the given color and a name made from the lens brand and a bit of the mountain's name. If a photo does exist, get rid of any existing photos for that lens and mountain that aren't the right color type. Also, clean up any photos of that color that aren't connected to a lens from roughly the right brand.",
    "id": 34
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `insert_new_ratings` that does not accept any parameters. This procedure performs an `INSERT` operation into the `\"Rating\"` table. The `INSERT` statement populates the columns `\"rID\"`, `\"mID\"`, `stars`, and `\"ratingDate\"`. The values for these columns are derived from a `SELECT` statement. The `SELECT` statement retrieves `\"rID\"` from the `\"Reviewer\"` table (aliased as `rv`), `\"mID\"` from the `\"Movie\"` table (aliased as `m`), a literal integer value `3` for the `stars` column, and the current date using the `CURRENT_DATE` function for the `\"ratingDate\"` column. The `FROM` clause of the `SELECT` statement joins the `\"Reviewer\"` table (`rv`) and the `\"Movie\"` table (`m`) implicitly using a cross join, which is then filtered by the `WHERE` clause. The `WHERE` clause applies a condition: `m.\"mID\"` must `NOT IN` a subquery's result set. The subquery selects `\"mID\"` from the `\"Rating\"` table (aliased as `r`) where `r.\"rID\"` is equal to `rv.\"rID\"` from the outer query's `\"Reviewer\"` table. This condition effectively identifies movies that a specific reviewer (`rv.\"rID\"`) has not yet rated. Finally, the entire `SELECT` statement is limited to return only `1` row, meaning the `INSERT` operation will only add a single new rating based on the first matching combination of a reviewer and an unrated movie found by the query.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_ratings()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Rating\" (\"rID\", \"mID\", stars, \"ratingDate\")\n    SELECT rv.\"rID\", m.\"mID\", 3, CURRENT_DATE\n    FROM \"Reviewer\" rv, \"Movie\" m\n    WHERE m.\"mID\" NOT IN (\n        SELECT r.\"mID\" FROM \"Rating\" r WHERE r.\"rID\" = rv.\"rID\"\n    )\n    LIMIT 1;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL insert_new_ratings();"
    ],
    "summary": "Create a parameterless stored procedure named insert_new_ratings. It inserts a single row into the Rating table. The row consists of a reviewer ID, a movie ID, a fixed rating of 3 stars, and the current date. The reviewer and movie are selected such that the reviewer has not previously rated that movie. The selection is limited to the first matching reviewer-movie pair.",
    "natural_language": "Create a stored procedure called insert_new_ratings that doesn't need any parameters. It should add a record to the Rating table. The record should have a reviewer ID and a movie ID, give it a decent rating like 3 stars, and use today's date. Pick a reviewer and a movie where that person hasn't given their opinion on that film before. Just grab the first suitable pair you find.",
    "id": 35
  },
  {
    "ir": "Write a PLpgSQL stored procedure that calculates the average of the stars column from the Rating table for rows where the mID column equals 101, stores this average in a variable named avg_rating of type double precision, and then inserts a new row into the Rating table with the rID column set to 201, the mID column set to 101, the stars column set to the rounded integer value of avg_rating, and the ratingDate column set to the current date.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_rating()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_rating double precision;\nBEGIN\n    SELECT AVG(r.stars) INTO avg_rating\n    FROM \"Rating\" r\n    WHERE r.\"mID\" = 101;\n    \n    INSERT INTO \"Rating\" (\"rID\", \"mID\", stars, \"ratingDate\")\n    VALUES (201, 101, ROUND(avg_rating)::integer, CURRENT_DATE);\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL calculate_average_rating();"
    ],
    "summary": "Create a stored procedure that calculates the average stars from the Rating table for mID 101, stores it in a double precision variable, and inserts a new rating with rID 201, mID 101, stars as the rounded average, and the current date.",
    "natural_language": "What stored procedure can be written to calculate the average stars for movie ID 101 from the Rating table, store that average in a double precision variable, and then insert a new rating with reviewer ID 201, movie ID 101, stars as the rounded average, and the current date?",
    "id": 36
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `update_reviewer_ratings` that takes no parameters. This procedure performs a single `UPDATE` operation on the `\"Rating\"` table. The `UPDATE` statement modifies the `stars` column for specific rows in the `\"Rating\"` table. The new value for the `stars` column is determined by applying the `GREATEST` function. The `GREATEST` function compares two values and returns the larger of the two. In this case, it compares `r.stars - 1` (the current value of the `stars` column decremented by 1) with the literal integer value `1`. This ensures that the `stars` column will never be set to a value less than `1`. The `WHERE` clause of the `UPDATE` statement specifies which rows in the `\"Rating\"` table are affected. It uses a subquery to identify the `rID` values. The subquery selects the `rID` column from the `\"Reviewer\"` table. The condition for this subquery is `rv.name LIKE 'Sarah%'`, which means it selects `rID`s from the `\"Reviewer\"` table where the `name` column starts with the string 'Sarah'. The `UPDATE` statement then applies the `stars` column modification to all rows in the `\"Rating\"` table where the `rID` column matches any of the `rID`s returned by this subquery.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_reviewer_ratings()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"Rating\" r\n    SET stars = GREATEST(r.stars - 1, 1)\n    WHERE r.\"rID\" IN (\n        SELECT rv.\"rID\" FROM \"Reviewer\" rv WHERE rv.name LIKE 'Sarah%'\n    );\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL update_reviewer_ratings();"
    ],
    "summary": "Create a stored procedure named update_reviewer_ratings that updates the Rating table. For all ratings by reviewers whose names start with 'Sarah', set the stars to the greater of (current stars - 1) or 1.",
    "natural_language": "Please construct a stored procedure designated as 'update_reviewer_ratings' to modify the Rating table. The procedure shall adjust the 'stars' value for every rating submitted by a reviewer with a name commencing with 'Sarah'. The new value must be set to the maximum of either the current star count reduced by one, or the value one.",
    "id": 37
  },
  {
    "ir": "Write a PLpgSQL stored procedure named calculate_hyperbolic_ratings that performs operations on the \"Rating\" table. The procedure does not take any parameters and is designed to calculate a hyperbolic factor based on the number of ratings associated with a specific movie ID, which is 102. It begins by declaring a variable named hyperbolic_factor of type double precision to store the result of the hyperbolic cosine calculation. The procedure executes a SELECT statement to count the number of rows in the \"Rating\" table where the column \"mID\" equals 102, converting this count to a double precision value and dividing it by 10.0. The result is then passed to the cosh function, which computes the hyperbolic cosine of the given value. The computed hyperbolic factor is stored in the hyperbolic_factor variable. Subsequently, the procedure performs an INSERT operation into the \"Rating\" table, adding a new row with the following values: \"rID\" set to 202, \"mID\" set to 102, stars set to the result of applying the LEAST and GREATEST functions to ensure the rounded hyperbolic_factor is constrained between 1 and 5, and \"ratingDate\" set to the current date using the CURRENT_DATE function. The LEAST function ensures the value does not exceed 5, while the GREATEST function ensures it is at least 1, and the ROUND function converts the hyperbolic_factor to an integer before these constraints are applied.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_hyperbolic_ratings()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    hyperbolic_factor double precision;\nBEGIN\n    SELECT cosh(COUNT(*)::double precision / 10.0) INTO hyperbolic_factor\n    FROM \"Rating\" r\n    WHERE r.\"mID\" = 102;\n    \n    INSERT INTO \"Rating\" (\"rID\", \"mID\", stars, \"ratingDate\")\n    VALUES (202, 102, LEAST(GREATEST(ROUND(hyperbolic_factor)::integer, 1), 5), CURRENT_DATE);\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL calculate_hyperbolic_ratings();"
    ],
    "summary": "Create a stored procedure named calculate_hyperbolic_ratings. Calculate the hyperbolic cosine of (the count of ratings for mID 102 / 10.0). Insert a new rating with rID 202, mID 102, stars as the rounded hyperbolic value constrained between 1 and 5, and the current date.",
    "natural_language": "Create a stored procedure to figure out some hyperbolic ratings. Work out the hyperbolic cosine for a number that's kind of like the total ratings for movie 102 divided by ten. Then, put in a new rating record using rID 202 and mID 102, with the stars set to a rounded version of that hyperbolic resultâ€”make sure it's a reasonable star score between one and fiveâ€”and use today's date.",
    "id": 38
  },
  {
    "ir": "Write a PLpgSQL stored procedure named update_festival_result that accepts two input parameters: festival_id of type integer and new_result of type text. The procedure performs an update operation on the music_festival table, specifically targeting the Result column. It sets the Result column to the value provided by the new_result parameter for the row where the ID column matches the value of the festival_id parameter. The procedure does not include any conditional logic beyond the WHERE clause used to identify the specific row to update based on the festival_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_festival_result(IN festival_id integer, IN new_result text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"music_festival\"\n    SET \"Result\" = new_result\n    WHERE \"ID\" = festival_id;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL update_festival_result(1, 'Winner');",
      "CALL update_festival_result(2, 'Runner-up');",
      "CALL update_festival_result(3, 'Disqualified');",
      "CALL update_festival_result(1, 'Cancelled');",
      "CALL update_festival_result(2, 'Postponed');"
    ],
    "summary": "Create a stored procedure named update_festival_result that takes an integer festival_id and a text new_result. Update the music_festival table, setting the Result column to new_result where the ID matches festival_id.",
    "natural_language": "Create a stored procedure, which should be named update_festival_result, that accepts two distinct input parameters: an integer specifically designated as festival_id and a text string referred to as new_result. This procedure must perform an update operation on the music_festival table, meticulously setting the value within the Result column to the provided new_result string, but only for those precise rows where the existing ID column value perfectly corresponds to the supplied festival_id parameter.",
    "id": 39
  },
  {
    "ir": "Write a PLpgSQL stored procedure that inserts a new record into the artist table by taking two input parameters: artist_name of type text and artist_age of type integer. The procedure performs an insert operation on the artist table, specifically targeting the columns named Artist and Age. It assigns the value of the artist_name parameter to the Artist column and the value of the artist_age parameter to the Age column, thereby adding a new artist entry with the specified name and age into the table.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_artist(IN artist_name text, IN artist_age integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"artist\" (\"Artist\", \"Age\") VALUES (artist_name, artist_age);\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL insert_new_artist('New Artist 1', 30);",
      "CALL insert_new_artist('New Artist 2', 25);",
      "CALL insert_new_artist('New Artist 3', 40);",
      "CALL insert_new_artist('New Artist 4', 35);",
      "CALL insert_new_artist('New Artist 5', 28);"
    ],
    "summary": "Create a stored procedure that takes a text artist_name and an integer artist_age. Insert a new record into the artist table, setting the Artist column to artist_name and the Age column to artist_age.",
    "natural_language": "Make a stored procedure that accepts an artist's name as text and an age number. Use it to add a new entry to the artist table, putting the given name in the Artist field and the provided number in the Age column.",
    "id": 40
  },
  {
    "ir": "Write a PLpgSQL stored procedure named \"InsertMissingAttributes\" that does not take any parameters and is designed to insert missing attribute records into the \"Catalog_Contents_Additional_Attributes\" table. The procedure begins by declaring a variable v_attribute_id of type bigint, which is used to store the identifier of a specific attribute. It then performs a SELECT operation on the \"Attribute_Definitions\" table to retrieve the \"attribute_id\" where the \"attribute_name\" matches 'GREEN', converting the name to uppercase using the UPPER() function to ensure case-insensitive comparison. The retrieved \"attribute_id\" is stored in the v_attribute_id variable. Next, the procedure executes an INSERT operation into the \"Catalog_Contents_Additional_Attributes\" table, specifying the columns \"catalog_entry_id\", \"catalog_level_number\", \"attribute_id\", and \"attribute_value\". The values for \"catalog_entry_id\" and \"catalog_level_number\" are selected from the \"Catalog_Contents\" table, while \"attribute_id\" is set to the value stored in v_attribute_id, and \"attribute_value\" is set to '0'. The INSERT operation is conditioned by a WHERE clause that ensures only those entries from \"Catalog_Contents\" are considered where there is no existing record in \"Catalog_Contents_Additional_Attributes\" with the same \"catalog_entry_id\" and \"attribute_id\" as v_attribute_id, using a NOT EXISTS subquery to perform this check.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"InsertMissingAttributes\"()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_attribute_id bigint;\nBEGIN\n    SELECT \"attribute_id\" INTO v_attribute_id FROM \"Attribute_Definitions\" WHERE UPPER(\"attribute_name\") = 'GREEN';\n    \n    INSERT INTO \"Catalog_Contents_Additional_Attributes\" (\"catalog_entry_id\", \"catalog_level_number\", \"attribute_id\", \"attribute_value\")\n    SELECT cc.\"catalog_entry_id\", cc.\"catalog_level_number\", v_attribute_id, '0'\n    FROM \"Catalog_Contents\" cc\n    WHERE NOT EXISTS (\n        SELECT 1 FROM \"Catalog_Contents_Additional_Attributes\" ccaa \n        WHERE ccaa.\"catalog_entry_id\" = cc.\"catalog_entry_id\" \n        AND ccaa.\"attribute_id\" = v_attribute_id\n    );\nEND;\n$$;",
    "database_name": "product_catalog",
    "tables": [
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Attribute_Definitions"
    ],
    "call_sqls": [
      "CALL \"InsertMissingAttributes\"();"
    ],
    "summary": "Create a stored procedure named \"InsertMissingAttributes\" with no parameters. Find the attribute_id for the attribute named 'GREEN' from the Attribute_Definitions table. Then, insert into Catalog_Contents_Additional_Attributes for all catalog entries where a record with that specific attribute_id does not already exist. Set the attribute_value to '0'.",
    "natural_language": "Hey, can you whip up a stored procedure called \"InsertMissingAttributes\" that doesn't need any parameters? First, grab the attribute_id for 'GREEN' from the Attribute_Definitions table. Then, for every catalog entry that doesn't already have this attribute attached, go ahead and add a row into Catalog_Contents_Additional_Attributes. Just set the attribute_value to '0' for those new entries.",
    "id": 41
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"CalculatePriceStatistics\" that takes no input parameters. This procedure is designed to calculate aggregate price statistics from the \"Catalog_Contents\" table and then store these statistics as an additional attribute in the \"Catalog_Contents_Additional_Attributes\" table.\n\nThe procedure begins by declaring five local variables:\n1. `v_avg_dollars` of type `double precision`, intended to store the average price in dollars.\n2. `v_max_euros` of type `double precision`, intended to store the maximum price in euros.\n3. `v_min_pounds` of type `double precision`, intended to store the minimum price in pounds.\n4. `v_valid_attribute_id` of type `bigint`, intended to store the identifier for the 'Price Statistics' attribute.\n5. `v_existing_catalog_entry_id` of type `bigint`, intended to store an existing catalog entry identifier.\n\nThe first operation is a `SELECT` statement that calculates three aggregate statistics from the \"Catalog_Contents\" table. It computes the average of the \"price_in_dollars\" column, the maximum of the \"price_in_euros\" column, and the minimum of the \"price_in_pounds\" column. These calculated values are then assigned respectively to the `v_avg_dollars`, `v_max_euros`, and `v_min_pounds` variables. This aggregation is performed only for rows where the \"catalog_level_number\" column has a value between 1 and 3, inclusive.\n\nNext, another `SELECT` statement is executed to retrieve a single \"catalog_entry_id\" from the \"Catalog_Contents\" table. This `SELECT` statement also filters rows based on the condition that the \"catalog_level_number\" column has a value between 1 and 3, inclusive. The `LIMIT 1` clause ensures that only one such `catalog_entry_id` is fetched. The retrieved `catalog_entry_id` is then assigned to the `v_existing_catalog_entry_id` variable. This value is intended to satisfy a foreign key constraint in a subsequent `INSERT` operation.\n\nFollowing this, a `SELECT` statement attempts to retrieve the \"attribute_id\" from the \"Attribute_Definitions\" table. It searches for an attribute where the \"attribute_name\" column is exactly 'Price Statistics'. The `LIMIT 1` clause ensures that at most one `attribute_id` is retrieved. The result is assigned to the `v_valid_attribute_id` variable.\n\nA conditional block (`IF v_valid_attribute_id IS NULL THEN ... END IF;`) then checks if `v_valid_attribute_id` is `NULL`. If it is `NULL`, it means that an attribute named 'Price Statistics' does not exist in the \"Attribute_Definitions\" table. In this case, an `INSERT` statement is executed to add a new record into the \"Attribute_Definitions\" table. The new record is inserted with an \"attribute_id\" of 999, an \"attribute_name\" of 'Price Statistics', and an \"attribute_data_type\" of 'Text'. The `RETURNING \"attribute_id\" INTO v_valid_attribute_id` clause captures the \"attribute_id\" of the newly inserted row and assigns it to the `v_valid_attribute_id` variable, ensuring that `v_valid_attribute_id` always holds a valid attribute identifier for 'Price Statistics'.\n\nFinally, an `INSERT` statement is executed to add a new record into the \"Catalog_Contents_Additional_Attributes\" table. This `INSERT` statement populates four columns:\n1. \"catalog_entry_id\" is set to the value stored in `v_existing_catalog_entry_id`.\n2. \"catalog_level_number\" is set to the literal value 1.\n3. \"attribute_id\" is set to the value stored in `v_valid_attribute_id`.\n4. \"attribute_value\" is constructed by concatenating the string representations of the calculated statistics. Specifically, it takes the value of `v_avg_dollars`, casts it to `text`, and if `v_avg_dollars` is `NULL`, it defaults to '0' using the `COALESCE` function. This is then concatenated with a pipe symbol ('|'). Next, it takes the value of `v_max_euros`, casts it to `text`, and if `v_max_euros` is `NULL`, it defaults to '0'. This is again concatenated with a pipe symbol ('|'). Finally, it takes the value of `v_min_pounds`, casts it to `text`, and if `v_min_pounds` is `NULL`, it defaults to '0'. The entire concatenated string forms the \"attribute_value\".",
    "plsql": "CREATE OR REPLACE PROCEDURE \"CalculatePriceStatistics\"()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_dollars double precision;\n    v_max_euros double precision;\n    v_min_pounds double precision;\n    v_valid_attribute_id bigint;\n    v_existing_catalog_entry_id bigint;\nBEGIN\n    -- Get price statistics\n    SELECT AVG(\"price_in_dollars\"), MAX(\"price_in_euros\"), MIN(\"price_in_pounds\") \n    INTO v_avg_dollars, v_max_euros, v_min_pounds\n    FROM \"Catalog_Contents\"\n    WHERE \"catalog_level_number\" BETWEEN 1 AND 3;\n    \n    -- Get an existing catalog_entry_id from the data used in statistics\n    SELECT \"catalog_entry_id\" INTO v_existing_catalog_entry_id\n    FROM \"Catalog_Contents\"\n    WHERE \"catalog_level_number\" BETWEEN 1 AND 3\n    LIMIT 1;\n    \n    -- Get or ensure a valid attribute_id exists\n    SELECT \"attribute_id\" INTO v_valid_attribute_id\n    FROM \"Attribute_Definitions\"\n    WHERE \"attribute_name\" = 'Price Statistics'\n    LIMIT 1;\n    \n    -- If attribute doesn't exist, create it\n    IF v_valid_attribute_id IS NULL THEN\n        INSERT INTO \"Attribute_Definitions\" (\"attribute_id\", \"attribute_name\", \"attribute_data_type\")\n        VALUES (999, 'Price Statistics', 'Text')\n        RETURNING \"attribute_id\" INTO v_valid_attribute_id;\n    END IF;\n    \n    -- Insert with existing catalog_entry_id to satisfy foreign key constraint\n    INSERT INTO \"Catalog_Contents_Additional_Attributes\" (\"catalog_entry_id\", \"catalog_level_number\", \"attribute_id\", \"attribute_value\")\n    SELECT v_existing_catalog_entry_id, 1, v_valid_attribute_id, \n           COALESCE(v_avg_dollars::text, '0') || '|' || \n           COALESCE(v_max_euros::text, '0') || '|' || \n           COALESCE(v_min_pounds::text, '0');\nEND;\n$$;",
    "database_name": "product_catalog",
    "tables": [
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Attribute_Definitions"
    ],
    "call_sqls": [
      "CALL \"CalculatePriceStatistics\"();"
    ],
    "summary": "Create a stored procedure named \"CalculatePriceStatistics\" with no parameters. Calculate the average price_in_dollars, maximum price_in_euros, and minimum price_in_pounds from Catalog_Contents where catalog_level_number is between 1 and 3. Get or create an attribute definition named 'Price Statistics'. Insert these three calculated statistics as a single pipe-separated text value (e.g., 'avg|max|min') into the Catalog_Contents_Additional_Attributes table for a single existing catalog entry.",
    "natural_language": "Create a stored procedure called \"CalculatePriceStatistics\" without any parameters. Compute the average price_in_dollars, the maximum price_in_euros, and the minimum price_in_pounds from the Catalog_Contents table where the catalog_level_number falls between 1 and 3. Then, ensure an attribute definition named 'Price Statistics' exists. Finally, insert these three calculated values as one pipe-separated string (like 'avg|max|min') into the Catalog_Contents_Additional_Attributes table for one specific, already existing catalog entry.",
    "id": 42
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"SyncAttributeValues\" that takes no parameters. The procedure begins by defining a Common Table Expression (CTE) named \"AttributeData\". This CTE selects three columns: \"catalog_entry_id\", \"attribute_name\", and \"attribute_value\". These columns are retrieved by joining the \"Catalog_Contents_Additional_Attributes\" table (aliased as `ccaa`) with the \"Attribute_Definitions\" table (aliased as `ad`). The join condition is `ad.\"attribute_id\" = ccaa.\"attribute_id\"`. A filtering condition is applied to this selection: `TO_NUMBER(ccaa.\"attribute_value\", '9') > 0`. This condition attempts to convert the \"attribute_value\" column from the \"Catalog_Contents_Additional_Attributes\" table to a numeric type using the format model '9' (which implies a single digit or a number with a single digit before the decimal point, though in practice it's more flexible for integer conversion) and then checks if the resulting number is greater than zero. After defining this CTE, the procedure performs an `INSERT` operation into the \"Catalog_Contents_Additional_Attributes\" table. The columns being inserted into are \"catalog_entry_id\", \"catalog_level_number\", \"attribute_id\", and \"attribute_value\". The values for these columns are derived from a `SELECT` statement. The `SELECT` statement retrieves data from the \"Catalog_Contents\" table (aliased as `cc`). For the \"catalog_entry_id\" column, it directly uses `cc.\"catalog_entry_id\"`. For the \"catalog_level_number\" column, it uses `cc.\"catalog_level_number\"`. For the \"attribute_id\" column, a subquery is executed: `(SELECT \"attribute_id\" FROM \"Attribute_Definitions\" WHERE UPPER(\"attribute_name\") = 'SYNCED')`. This subquery selects the \"attribute_id\" from the \"Attribute_Definitions\" table where the uppercase version of the \"attribute_name\" column is equal to the string 'SYNCED'. For the \"attribute_value\" column, another subquery is executed: `(SELECT COUNT(*) FROM \"AttributeData\" ad WHERE ad.\"catalog_entry_id\" = cc.\"catalog_entry_id\")::text`. This subquery counts the number of rows in the \"AttributeData\" CTE where the \"catalog_entry_id\" matches the \"catalog_entry_id\" from the current row of the \"Catalog_Contents\" table, and then casts this count to a text type. The entire `INSERT` operation is filtered by a `WHERE` clause on the \"Catalog_Contents\" table: `MOD(cc.\"catalog_entry_id\", 2) = 0`. This condition ensures that only rows from \"Catalog_Contents\" where the \"catalog_entry_id\" is an even number (i.e., the remainder when divided by 2 is 0) are considered for the insertion.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"SyncAttributeValues\"()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    WITH \"AttributeData\" AS (\n        SELECT ccaa.\"catalog_entry_id\", ad.\"attribute_name\", ccaa.\"attribute_value\"\n        FROM \"Catalog_Contents_Additional_Attributes\" ccaa\n        JOIN \"Attribute_Definitions\" ad ON ad.\"attribute_id\" = ccaa.\"attribute_id\"\n        WHERE TO_NUMBER(ccaa.\"attribute_value\", '9') > 0\n    )\n    INSERT INTO \"Catalog_Contents_Additional_Attributes\" (\"catalog_entry_id\", \"catalog_level_number\", \"attribute_id\", \"attribute_value\")\n    SELECT cc.\"catalog_entry_id\", cc.\"catalog_level_number\", \n           (SELECT \"attribute_id\" FROM \"Attribute_Definitions\" WHERE UPPER(\"attribute_name\") = 'SYNCED'),\n           (SELECT COUNT(*) FROM \"AttributeData\" ad WHERE ad.\"catalog_entry_id\" = cc.\"catalog_entry_id\")::text\n    FROM \"Catalog_Contents\" cc\n    WHERE MOD(cc.\"catalog_entry_id\", 2) = 0;\nEND;\n$$;",
    "database_name": "product_catalog",
    "tables": [
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Attribute_Definitions"
    ],
    "call_sqls": [
      "CALL \"SyncAttributeValues\"();"
    ],
    "summary": "Create a stored procedure named \"SyncAttributeValues\" with no parameters. First, create a temporary dataset of catalog entries that have an attribute_value which can be converted to a number greater than 0. Then, for every even-numbered catalog_entry_id, insert a new record into Catalog_Contents_Additional_Attributes. The attribute_id should be for the attribute named 'SYNCED', and the attribute_value should be the count of qualifying attributes from the temporary dataset for that specific catalog entry.",
    "natural_language": "How can I create a stored procedure named \"SyncAttributeValues\" with no parameters that first builds a temporary set of catalog entries where the attribute_value is a number greater than zero, and then, for each even-numbered catalog_entry_id, inserts a new record into Catalog_Contents_Additional_Attributes using the attribute_id for 'SYNCED' and an attribute_value equal to the count of qualifying attributes from that temporary set for the specific entry?",
    "id": 43
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `analyze_ship_mission_stats` that accepts four input parameters: `p_nationality_filter` of type `text`, `p_min_tonnage` of type `integer`, `p_year_threshold` of type `integer`, and `p_fate_pattern` of type `text`. The procedure begins by declaring three local variables: `v_ship_count` of type `integer`, `v_avg_speed` of type `numeric`, and `v_mission_count` of type `integer`. The procedure then executes a `SELECT` statement to count the number of records in the `ship` table. This count is stored in the `v_ship_count` variable. The `ship` records are filtered based on two conditions: the value in the `\"Nationality\"` column must exactly match the `p_nationality_filter` parameter, and the value in the `\"Tonnage\"` column must be strictly greater than the `p_min_tonnage` parameter. Next, the procedure executes another `SELECT` statement to calculate the average of the `\"Speed_knots\"` column from the `mission` table. This average is stored in the `v_avg_speed` variable. This `SELECT` statement involves a `JOIN` operation between the `mission` table (aliased as `m`) and the `ship` table (aliased as `s`) on the condition that `m.\"Ship_ID\"` equals `s.\"Ship_ID\"`. The joined records are filtered based on two conditions: the value in the `s.\"Nationality\"` column must exactly match the `p_nationality_filter` parameter, and the value in the `m.\"Launched_Year\"` column must be strictly greater than the `p_year_threshold` parameter. Subsequently, the procedure executes a third `SELECT` statement to count the number of records in the `mission` table. This count is stored in the `v_mission_count` variable. The `mission` records are filtered based on a single condition: the value in the `\"Fate\"` column must contain the `p_fate_pattern` parameter as a substring, with the `LIKE` operator used for pattern matching, where `p_fate_pattern` is concatenated with wildcard characters (`%`) on both sides. Following these selections, the procedure performs an `INSERT` operation into the `ship` table, populating the columns `\"Ship_ID\"`, `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. The value for `\"Ship_ID\"` is determined by a subquery that selects the maximum existing `\"Ship_ID\"` from the `ship` table, uses `COALESCE` to default to `0` if no `MAX` value is found, and then adds `1` to the result. The `\"Name\"` column is set to the literal string 'Analysis_Record'. The `\"Type\"` column is set to the literal string 'Statistical'. The `\"Nationality\"` column is set to the value of the `p_nationality_filter` parameter. The `\"Tonnage\"` column is set to the product of the `v_ship_count` variable and `1000`. Finally, the procedure executes a `DELETE` statement to remove records from the `mission` table. The records to be deleted are filtered based on two conditions: the value in the `\"Speed_knots\"` column must be strictly less than `10`, and the value in the `\"Launched_Year\"` column must be strictly less than the `p_year_threshold` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_ship_mission_stats(\n    p_nationality_filter text,\n    p_min_tonnage integer,\n    p_year_threshold integer,\n    p_fate_pattern text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_ship_count integer;\n    v_avg_speed numeric;\n    v_mission_count integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_ship_count\n    FROM ship s\n    WHERE s.\"Nationality\" = p_nationality_filter\n    AND s.\"Tonnage\" > p_min_tonnage;\n\n    SELECT AVG(m.\"Speed_knots\")\n    INTO v_avg_speed\n    FROM mission m\n    JOIN ship s ON m.\"Ship_ID\" = s.\"Ship_ID\"\n    WHERE s.\"Nationality\" = p_nationality_filter\n    AND m.\"Launched_Year\" > p_year_threshold;\n\n    SELECT COUNT(*)\n    INTO v_mission_count\n    FROM mission m\n    WHERE m.\"Fate\" LIKE '%' || p_fate_pattern || '%';\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    VALUES (\n        (SELECT COALESCE(MAX(\"Ship_ID\"), 0) + 1 FROM ship),\n        'Analysis_Record',\n        'Statistical',\n        p_nationality_filter,\n        v_ship_count * 1000\n    );\n\n    DELETE FROM mission\n    WHERE \"Speed_knots\" < 10\n    AND \"Launched_Year\" < p_year_threshold;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL analyze_ship_mission_stats('United Kingdom', 3000, 1920, 'Decommissioned');",
      "CALL analyze_ship_mission_stats('United States', 3500, 1935, 'Lost');",
      "CALL analyze_ship_mission_stats('Germany', 2000, 1910, 'burned');",
      "CALL analyze_ship_mission_stats('United Kingdom', 4000, 1940, '1950');",
      "CALL analyze_ship_mission_stats('United States', 2500, 1900, '1931');"
    ],
    "summary": "Create a stored procedure named \"analyze_ship_mission_stats\" that takes nationality, minimum tonnage, year threshold, and fate pattern as input. Count ships matching the nationality and tonnage filter. Calculate the average mission speed for missions launched after the year threshold for ships of that nationality. Count missions where the fate contains the pattern. Insert a new statistical record into the ship table with a name, the input nationality, and tonnage based on the ship count. Delete missions with speed less than 10 and launched before the year threshold.",
    "natural_language": "Develop a comprehensive stored procedure, to be designated as \"analyze_ship_mission_stats\", which must accept four distinct input parameters: a specified nationality, a defined minimum tonnage, a particular year threshold, and a specific fate pattern. This procedure should meticulously count all ships that correspond precisely to the provided nationality and also meet or exceed the stipulated minimum tonnage. Subsequently, it must compute the precise average mission speed exclusively for those missions which were launched after the given year threshold and involve ships belonging to the indicated nationality. Furthermore, it is required to tally all missions where the recorded fate description incorporates the provided pattern. Following these calculations, the procedure must insert a fresh statistical entry into the ship table; this new record should include a generated name, the originally input nationality, and a tonnage value that is directly derived from the total count of ships identified earlier. Finally, the procedure must conclusively delete any and all mission records where the calculated speed is determined to be less than 10 and where the launch date regrettably occurred before the established year threshold.",
    "id": 44
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_ship_mission_data` that accepts four input parameters: `p_location_pattern` of type `text`, `p_ship_type_filter` of type `text`, `p_min_speed` of type `integer`, and `p_max_year` of type `integer`. The procedure first declares two local variables: `v_ship_records` of type `RECORD` to hold rows retrieved from a query, and `v_mission_array` of type `text[]` to store an array of text strings. It initializes `v_mission_array` as an empty text array. The procedure then enters a loop that iterates over the results of a `SELECT` statement. This `SELECT` statement retrieves the `\"Ship_ID\"`, `\"Name\"`, and `\"Type\"` columns from the `ship` table (aliased as `s`), and the `\"Code\"` and `\"Location\"` columns from the `mission` table (aliased as `m`). It performs a `LEFT JOIN` between the `ship` table and the `mission` table on the condition that `s.\"Ship_ID\"` is equal to `m.\"Ship_ID\"`. The `WHERE` clause filters these results based on two conditions: `s.\"Type\"` must be equal to the value provided in the `p_ship_type_filter` parameter, and either `m.\"Location\"` must contain the `p_location_pattern` (case-sensitive substring match using the `LIKE` operator with wildcards) or `m.\"Location\"` must be `NULL`. For each `v_ship_records` row returned by this `SELECT` statement, the procedure appends a new text string to the `v_mission_array`. This string is constructed by concatenating the `\"Name\"` column from `v_ship_records`, a colon (`:`), and then either the `\"Code\"` column from `v_ship_records` if it is not `NULL`, or the literal string `'NO_MISSION'` if `\"Code\"` is `NULL` (using the `COALESCE` function). After the loop completes, the procedure performs an `INSERT` operation into the `ship` table, populating the columns `\"Ship_ID\"`, `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. The values for these columns are derived from a `SELECT` statement. For `\"Ship_ID\"`, it calculates a new ID by finding the maximum existing `\"Ship_ID\"` in the `ship` table (defaulting to `0` if no records exist, using `COALESCE`) and adding the `ROW_NUMBER()` of the current row within the result set of the inner `SELECT` statement. For `\"Name\"`, it concatenates the literal string `'Processed_'` with the value of the `p_ship_type_filter` parameter. For `\"Type\"`, it uses the literal string `'Aggregate'`. For `\"Nationality\"`, it uses the literal string `'International'`. For `\"Tonnage\"`, it calculates the `COUNT(*)` of rows from the inner `SELECT` statement and multiplies it by `500`. The inner `SELECT` statement for the `INSERT` operation retrieves data from the `mission` table, filtering rows where `\"Speed_knots\"` is greater than or equal to the `p_min_speed` parameter and `\"Launched_Year\"` is less than or equal to the `p_max_year` parameter. Finally, the procedure executes a `DELETE` statement on the `mission` table. It removes rows where the `\"Ship_ID\"` is present in a subquery's result. This subquery selects `\"Ship_ID\"` from the `ship` table where `\"Tonnage\"` is less than `3000` and `\"Type\"` is equal to the `p_ship_type_filter` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_ship_mission_data(\n    p_location_pattern text,\n    p_ship_type_filter text,\n    p_min_speed integer,\n    p_max_year integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_ship_records RECORD;\n    v_mission_array text[];\nBEGIN\n    v_mission_array := ARRAY[]::text[];\n\n    FOR v_ship_records IN\n        SELECT s.\"Ship_ID\", s.\"Name\", s.\"Type\", m.\"Code\", m.\"Location\"\n        FROM ship s\n        LEFT JOIN mission m ON s.\"Ship_ID\" = m.\"Ship_ID\"\n        WHERE s.\"Type\" = p_ship_type_filter\n        AND (m.\"Location\" LIKE '%' || p_location_pattern || '%' OR m.\"Location\" IS NULL)\n    LOOP\n        v_mission_array := ARRAY_APPEND(v_mission_array, \n            v_ship_records.\"Name\" || ':' || COALESCE(v_ship_records.\"Code\", 'NO_MISSION'));\n    END LOOP;\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    SELECT \n        (SELECT COALESCE(MAX(\"Ship_ID\"), 0) FROM ship) + ROW_NUMBER() OVER (),\n        'Processed_' || p_ship_type_filter,\n        'Aggregate',\n        'International',\n        COUNT(*) * 500\n    FROM mission\n    WHERE \"Speed_knots\" >= p_min_speed\n    AND \"Launched_Year\" <= p_max_year;\n\n    DELETE FROM mission\n    WHERE \"Ship_ID\" IN (\n        SELECT \"Ship_ID\" FROM ship \n        WHERE \"Tonnage\" < 3000\n        AND \"Type\" = p_ship_type_filter\n    );\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL process_ship_mission_data('Germany', 'Cargo ship', 20, 1945);",
      "CALL process_ship_mission_data('Finland', 'Battle ship', 25, 1950);",
      "CALL process_ship_mission_data('', 'Cargo ship', 15, 1935);",
      "CALL process_ship_mission_data('Helsinki', 'Battle ship', 30, 1960);",
      "CALL process_ship_mission_data('United', 'Cargo ship', 10, 1920);"
    ],
    "summary": "Create a stored procedure named \"process_ship_mission_data\" that takes a location pattern, ship type, minimum speed, and maximum year as input. Loop through ships of the specified type and their missions (including ships with no missions) where the mission location matches the pattern or is null. Build an array of strings combining ship names and mission codes. Insert a new aggregate ship record, with tonnage based on the count of missions meeting the speed and year criteria. Delete missions for ships of the specified type with tonnage less than 3000.",
    "natural_language": "Create a stored procedure called \"process_ship_mission_data\" that takes a location pattern, a kind of ship, a minimum speed, and a not-too-recent year as input. Go through ships of that general type and their missions, including ships that might not have any missions, where the mission location sort of matches the pattern or isn't specified. Put together a list of strings that mix ship names with mission codes. Add a new combined ship record, where the tonnage is figured out from how many missions seem fast enough and from around the right time. Get rid of missions for ships of that type that are on the lighter side, say, less than about 3000 tons.",
    "id": 45
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named transform_mission_records that accepts four input parameters: p_nationality_source of type text to identify the source nationality for filtering, p_nationality_target of type text to specify the target nationality for new records, p_speed_adjustment of type integer to modify speed values, and p_year_offset of type integer to adjust launch years. The procedure begins by declaring two local variables: v_temp_ship_id as an integer to store a newly generated ship identifier, and v_mission_codes as a text array. It initializes v_mission_codes by populating it with an array of all mission \"Code\" values from the mission table, specifically those records where the associated ship (via a join on the \"Ship_ID\" column) has a \"Nationality\" equal to the p_nationality_source parameter and where the mission's \"Speed_knots\" column value is greater than 20. Next, the procedure inserts a new row into the ship table, generating a new \"Ship_ID\" by taking the current maximum value from the \"Ship_ID\" column and adding 1, setting the \"Name\" column to the literal string 'Transformed_Vessel', the \"Type\" column to 'Conversion', the \"Nationality\" column to the p_nationality_target parameter value, and the \"Tonnage\" column to the integer-cast average of the \"Tonnage\" column from all ship records where the \"Nationality\" matches p_nationality_source; the newly generated \"Ship_ID\" value is captured into the v_temp_ship_id variable using a RETURNING clause. Following this, the procedure performs an INSERT into the mission table, selecting data from existing mission records where the mission's \"Ship_ID\" corresponds to any ship whose \"Nationality\" equals p_nationality_source, and limiting the selection to only 3 rows. For each selected row, it constructs new values: a new \"Mission_ID\" calculated by adding a row number sequence to the current maximum \"Mission_ID\" (or 0 if the table is empty, using COALESCE), the \"Ship_ID\" set to the v_temp_ship_id, the \"Code\" prefixed with 'TRN-', the \"Launched_Year\" incremented by the p_year_offset parameter, the \"Location\" set to the p_nationality_target parameter value, the \"Speed_knots\" increased by the p_speed_adjustment parameter, and the \"Fate\" column appended with the string 'Transformed from '. Finally, the procedure executes a DELETE operation on the ship table, removing any ship records where the \"Ship_ID\" does not appear in the distinct set of \"Ship_ID\" values present in the mission table (i.e., ships with no associated missions) and where the ship's \"Nationality\" is exactly equal to the p_nationality_source parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_mission_records(\n    p_nationality_source text,\n    p_nationality_target text,\n    p_speed_adjustment integer,\n    p_year_offset integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_temp_ship_id integer;\n    v_mission_codes text[];\nBEGIN\n    v_mission_codes := ARRAY(\n        SELECT m.\"Code\" \n        FROM mission m\n        JOIN ship s ON m.\"Ship_ID\" = s.\"Ship_ID\"\n        WHERE s.\"Nationality\" = p_nationality_source\n        AND m.\"Speed_knots\" > 20\n    );\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    VALUES (\n        (SELECT MAX(\"Ship_ID\") + 1 FROM ship),\n        'Transformed_Vessel',\n        'Conversion',\n        p_nationality_target,\n        (SELECT AVG(\"Tonnage\") FROM ship WHERE \"Nationality\" = p_nationality_source)::integer\n    )\n    RETURNING \"Ship_ID\" INTO v_temp_ship_id;\n\n    INSERT INTO mission (\"Mission_ID\", \"Ship_ID\", \"Code\", \"Launched_Year\", \"Location\", \"Speed_knots\", \"Fate\")\n    SELECT \n        (SELECT COALESCE(MAX(\"Mission_ID\"), 0) FROM mission) + ROW_NUMBER() OVER (),\n        v_temp_ship_id,\n        'TRN-' || \"Code\",\n        \"Launched_Year\" + p_year_offset,\n        p_nationality_target,\n        \"Speed_knots\" + p_speed_adjustment,\n        'Transformed from ' || \"Fate\"\n    FROM mission\n    WHERE \"Ship_ID\" IN (\n        SELECT \"Ship_ID\" FROM ship \n        WHERE \"Nationality\" = p_nationality_source\n    )\n    LIMIT 3;\n\n    DELETE FROM ship\n    WHERE \"Ship_ID\" NOT IN (\n        SELECT DISTINCT \"Ship_ID\" FROM mission\n    )\n    AND \"Nationality\" = p_nationality_source;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL transform_mission_records('United Kingdom', 'United States', 5, 2);",
      "CALL transform_mission_records('United States', 'Germany', -3, -1);",
      "CALL transform_mission_records('Germany', 'France', 10, 5);",
      "CALL transform_mission_records('France', 'Italy', 0, 0);",
      "CALL transform_mission_records('Italy', 'Japan', 7, 3);"
    ],
    "summary": "Create a stored procedure named transform_mission_records with parameters p_nationality_source (text), p_nationality_target (text), p_speed_adjustment (integer), and p_year_offset (integer). The procedure should: 1) Store mission codes from missions where the associated ship's nationality matches p_nationality_source and mission speed exceeds 20. 2) Insert a new ship with name 'Transformed_Vessel', type 'Conversion', nationality p_nationality_target, and tonnage set to the average tonnage of ships with nationality p_nationality_source; capture the new ship's ID. 3) Insert up to 3 new missions based on missions from ships with nationality p_nationality_source, transforming the data: prefix code with 'TRN-', adjust launch year by p_year_offset, set location to p_nationality_target, adjust speed by p_speed_adjustment, and append 'Transformed from ' to fate. 4) Delete ships with nationality p_nationality_source that have no associated missions.",
    "natural_language": "Create a stored procedure called transform_mission_records. It must take the parameters p_nationality_source (text), p_nationality_target (text), p_speed_adjustment (integer), and p_year_offset (integer). First, store the mission codes from missions where the linked ship's nationality is p_nationality_source and the mission speed is over 20. Next, insert a new ship. Name it 'Transformed_Vessel', set its type to 'Conversion', its nationality to p_nationality_target, and its tonnage to the average tonnage of ships with nationality p_nationality_source; also capture this new ship's ID. Then, insert up to 3 new missions based on missions from ships with nationality p_nationality_source. Transform the data by prefixing the mission code with 'TRN-', adjusting the launch year by p_year_offset, setting the location to p_nationality_target, adjusting the speed by p_speed_adjustment, and appending 'Transformed from ' to the fate. Finally, delete any ships with nationality p_nationality_source that have no associated missions.",
    "id": 46
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `consolidate_ship_operations` that accepts four input parameters: `p_primary_type` of type `text`, representing the primary ship type for consolidation; `p_secondary_type` of type `text`, representing the secondary ship type for consolidation; `p_min_launch_year` of type `integer`, representing the minimum launch year for filtering missions; and `p_location_constraint` of type `text`, representing a substring to constrain mission locations. The procedure begins by declaring two local variables: `v_merged_count` of type `integer` to store a count of merged ships (though this variable is populated, its value is not subsequently used in the procedure's logic), and `v_deleted_missions` of type `integer` to store the number of rows deleted from the `mission` table.\n\nThe first operation is a `SELECT` statement that calculates a count. It selects the count of rows from the `ship` table, aliased as `s1`, joined with another instance of the `ship` table, aliased as `s2`. The join condition requires `s1.\"Type\"` to be equal to the `p_primary_type` parameter and `s2.\"Type\"` to be equal to the `p_secondary_type` parameter. Additionally, a `WHERE` clause filters these joined rows where `s1.\"Tonnage\"` is greater than `s2.\"Tonnage\"`. The result of this count is stored into the `v_merged_count` variable.\n\nNext, an `INSERT` statement adds new rows into the `ship` table, populating the columns `\"Ship_ID\"`, `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. The values for these new rows are derived from a `SELECT` statement that operates on the `ship` table. For `\"Ship_ID\"`, it calculates a new unique ID by taking the maximum existing `\"Ship_ID\"` from the `ship` table (defaulting to 0 if no ships exist) and adding a `ROW_NUMBER()` generated for each row in the subquery, ordered by `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. For `\"Name\"`, it concatenates the string 'Consolidated_' with the `\"Type\"` of the ship from the source rows. The `\"Type\"` for the new ships is set to the literal string 'Merged'. The `\"Nationality\"` is taken directly from the source `ship` table. The `\"Tonnage\"` for the new ships is calculated as the source `\"Tonnage\"` multiplied by 2. The source rows for this `INSERT` are filtered from the `ship` table where the `\"Type\"` is either `p_primary_type` or `p_secondary_type`. Furthermore, these ships must have their `\"Ship_ID\"` present in a subquery that selects `\"Ship_ID\"` from the `mission` table. This subquery filters missions where `\"Launched_Year\"` is greater than or equal to `p_min_launch_year` and where the `\"Location\"` column contains the `p_location_constraint` string (case-insensitive due to the `LIKE` operator with `%` wildcards). Finally, the rows for the `INSERT` are grouped by `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`.\n\nFollowing the `INSERT`, a `DELETE` statement removes rows from the `mission` table. The rows to be deleted are identified by their `\"Mission_ID\"`. A subquery selects `\"Mission_ID\"` from the `mission` table, aliased as `m`, joined with the `ship` table, aliased as `s`, on `m.\"Ship_ID\" = s.\"Ship_ID\"`. This subquery filters for missions where the associated ship's `\"Type\"` (`s.\"Type\"`) is equal to `p_secondary_type` and the mission's `\"Launched_Year\"` (`m.\"Launched_Year\"`) is less than `p_min_launch_year`. After the `DELETE` operation, the number of rows affected (deleted) is retrieved using `GET DIAGNOSTICS ROW_COUNT` and stored in the `v_deleted_missions` variable.\n\nFinally, a conditional block `IF v_deleted_missions > 5 THEN` checks if more than 5 missions were deleted. If this condition is true, an `INSERT` statement is executed to add a new row into the `mission` table, populating the columns `\"Mission_ID\"`, `\"Ship_ID\"`, `\"Code\"`, `\"Launched_Year\"`, `\"Location\"`, `\"Speed_knots\"`, and `\"Fate\"`. For `\"Mission_ID\"`, it calculates a new ID by taking the maximum existing `\"Mission_ID\"` from the `mission` table (defaulting to 0 if no missions exist) and adding 1. For `\"Ship_ID\"`, it selects the minimum `\"Ship_ID\"` from the `ship` table where the `\"Type\"` is equal to `p_primary_type`. For `\"Code\"`, it concatenates the string 'COMP-' with the `p_primary_type` parameter. The `\"Launched_Year\"` is set to the `p_min_launch_year` parameter. The `\"Location\"` is set to the `p_location_constraint` parameter. The `\"Speed_knots\"` is set to the literal integer value 30. The `\"Fate\"` is set to the literal string 'Compensation mission'.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_ship_operations(\n    p_primary_type text,\n    p_secondary_type text,\n    p_min_launch_year integer,\n    p_location_constraint text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_merged_count integer;\n    v_deleted_missions integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_merged_count\n    FROM ship s1\n    JOIN ship s2 ON s1.\"Type\" = p_primary_type AND s2.\"Type\" = p_secondary_type\n    WHERE s1.\"Tonnage\" > s2.\"Tonnage\";\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    SELECT \n        (SELECT COALESCE(MAX(\"Ship_ID\"), 0) FROM ship) + ROW_NUMBER() OVER (ORDER BY \"Type\", \"Nationality\", \"Tonnage\"),\n        'Consolidated_' || \"Type\",\n        'Merged',\n        \"Nationality\",\n        \"Tonnage\" * 2\n    FROM ship\n    WHERE \"Type\" IN (p_primary_type, p_secondary_type)\n    AND \"Ship_ID\" IN (\n        SELECT \"Ship_ID\" FROM mission \n        WHERE \"Launched_Year\" >= p_min_launch_year\n        AND \"Location\" LIKE '%' || p_location_constraint || '%'\n    )\n    GROUP BY \"Type\", \"Nationality\", \"Tonnage\";\n\n    DELETE FROM mission\n    WHERE \"Mission_ID\" IN (\n        SELECT m.\"Mission_ID\"\n        FROM mission m\n        JOIN ship s ON m.\"Ship_ID\" = s.\"Ship_ID\"\n        WHERE s.\"Type\" = p_secondary_type\n        AND m.\"Launched_Year\" < p_min_launch_year\n    );\n    GET DIAGNOSTICS v_deleted_missions = ROW_COUNT;\n\n    IF v_deleted_missions > 5 THEN\n        INSERT INTO mission (\"Mission_ID\", \"Ship_ID\", \"Code\", \"Launched_Year\", \"Location\", \"Speed_knots\", \"Fate\")\n        VALUES (\n            (SELECT COALESCE(MAX(\"Mission_ID\"), 0) + 1 FROM mission),\n            (SELECT MIN(\"Ship_ID\") FROM ship WHERE \"Type\" = p_primary_type),\n            'COMP-' || p_primary_type,\n            p_min_launch_year,\n            p_location_constraint,\n            30,\n            'Compensation mission'\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL consolidate_ship_operations('Cargo ship', 'Battle ship', 1940, 'Germany');",
      "CALL consolidate_ship_operations('Tanker', 'Destroyer', 1955, 'Japan');",
      "CALL consolidate_ship_operations('Submarine', 'Frigate', 1960, 'Atlantic');",
      "CALL consolidate_ship_operations('Yacht', 'Cruiser', 1970, 'Mediterranean');",
      "CALL consolidate_ship_operations('Patrol boat', 'Aircraft carrier', 1985, 'Pacific');"
    ],
    "summary": "Create a stored procedure named consolidate_ship_operations with parameters p_primary_type (text), p_secondary_type (text), p_min_launch_year (integer), and p_location_constraint (text). The procedure should: 1) Count ships where a primary type ship's tonnage exceeds a secondary type ship's tonnage. 2) Insert new 'Merged' type ships based on primary or secondary type ships that have missions launched after p_min_launch_year and with a location containing p_location_constraint; new tonnage is double the original. 3) Delete missions associated with secondary type ships launched before p_min_launch_year. 4) If more than 5 missions were deleted, insert a compensation mission for a primary type ship with code 'COMP-{p_primary_type}', launched in p_min_launch_year, at location p_location_constraint, speed 30, and fate 'Compensation mission'.",
    "natural_language": "Write a stored procedure called consolidate_ship_operations that takes p_primary_type (text), p_secondary_type (text), p_min_launch_year (integer), and p_location_constraint (text) as parameters. First, count the ships where a primary type ship's tonnage is greater than a secondary type ship's tonnage. Then, insert new ships of type 'Merged' based on primary or secondary type ships that have missions launched after p_min_launch_year and whose location contains p_location_constraint; set the new tonnage to double the original. Next, delete missions linked to secondary type ships that were launched before p_min_launch_year. Finally, if more than 5 missions were deleted, insert a compensation mission for a primary type ship with the code 'COMP-{p_primary_type}', launched in p_min_launch_year, at location p_location_constraint, with a speed of 30 and a fate of 'Compensation mission'.",
    "id": 47
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `generate_ship_mission_report` that accepts four input parameters: `p_country_filter` of type `text`, `p_speed_limit` of type `integer`, `p_tonnage_threshold` of type `integer`, and `p_year_cutoff` of type `integer`. The procedure initializes a local variable `v_report_data` as an empty array of `text` and a local variable `v_ship_record` as a `RECORD` type to hold rows from a query. It then populates `v_report_data` with initial string elements: 'Report Start:' and '----------------'. The procedure then enters a `FOR` loop, iterating over the results of a `SELECT` statement. This `SELECT` statement retrieves the \"Name\", \"Type\", and \"Tonnage\" columns from the `ship` table, along with an aggregated array of \"Code\" values from the `mission` table (ordered by \"Launched_Year\") aliased as `mission_codes`, and an aggregated array of \"Speed_knots\" values from the `mission` table aliased as `speeds`. It performs a `LEFT JOIN` between the `ship` table (aliased as `s`) and the `mission` table (aliased as `m`) on the condition `s.\"Ship_ID\" = m.\"Ship_ID\"`. The `WHERE` clause filters these results to include only ships where the \"Nationality\" column in the `ship` table matches the `p_country_filter` parameter, where the \"Tonnage\" column in the `ship` table is greater than the `p_tonnage_threshold` parameter, and where the \"Launched_Year\" column in the `mission` table is either greater than the `p_year_cutoff` parameter or is `NULL`. The results are grouped by `s.\"Ship_ID\"`, `s.\"Name\"`, `s.\"Type\"`, and `s.\"Tonnage\"`. Inside this loop, for each `v_ship_record`, the procedure appends a formatted string to the `v_report_data` array. This string includes the ship's \"Name\", \"Type\", and a comma-separated list of `mission_codes`. If `mission_codes` is `NULL` or empty, 'None' is used instead, achieved by the `COALESCE` function combined with `array_to_string`. Following this, there's a conditional `IF` statement that checks if the `speeds` array for the current `v_ship_record` has a length greater than 0 and if its first element is not `NULL`. If this condition is true, another formatted string is appended to `v_report_data`, indicating 'Max Speed:' followed by the maximum value found within the `speeds` array. This maximum value is determined by unnesting the `speeds` array and then applying the `MAX` aggregate function. After the loop completes, the procedure performs an `INSERT` operation into the `ship` table. It inserts a new row with a \"Ship_ID\" that is calculated as the maximum existing \"Ship_ID\" in the `ship` table plus 1 (or 1 if no ships exist, using `COALESCE`). The \"Name\" column is set to 'Report_Generator', the \"Type\" column to 'Analysis', the \"Nationality\" column to the value of `p_country_filter`, and the \"Tonnage\" column to the count of ships in the `ship` table whose \"Nationality\" matches `p_country_filter`, multiplied by 100. Finally, the procedure executes a `DELETE` statement on the `mission` table. This `DELETE` operation removes rows from the `mission` table where the \"Ship_ID\" is present in a subquery's result set. The subquery selects \"Ship_ID\" from the `ship` table for ships whose \"Tonnage\" is less than `p_tonnage_threshold` and whose \"Nationality\" matches `p_country_filter`. Additionally, the `DELETE` operation further filters these missions to only remove those where \"Speed_knots\" is less than `p_speed_limit`.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_ship_mission_report(\n    p_country_filter text,\n    p_speed_limit integer,\n    p_tonnage_threshold integer,\n    p_year_cutoff integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_report_data text[];\n    v_ship_record RECORD;\nBEGIN\n    v_report_data := ARRAY['Report Start:', '----------------'];\n\n    FOR v_ship_record IN\n        SELECT s.\"Name\", s.\"Type\", s.\"Tonnage\",\n               ARRAY_AGG(m.\"Code\" ORDER BY m.\"Launched_Year\") as mission_codes,\n               ARRAY_AGG(m.\"Speed_knots\") as speeds\n        FROM ship s\n        LEFT JOIN mission m ON s.\"Ship_ID\" = m.\"Ship_ID\"\n        WHERE s.\"Nationality\" = p_country_filter\n        AND s.\"Tonnage\" > p_tonnage_threshold\n        AND (m.\"Launched_Year\" > p_year_cutoff OR m.\"Launched_Year\" IS NULL)\n        GROUP BY s.\"Ship_ID\", s.\"Name\", s.\"Type\", s.\"Tonnage\"\n    LOOP\n        v_report_data := ARRAY_APPEND(v_report_data, \n            'Ship: ' || v_ship_record.\"Name\" || \n            ' | Type: ' || v_ship_record.\"Type\" ||\n            ' | Missions: ' || COALESCE(array_to_string(v_ship_record.mission_codes, ','), 'None'));\n        \n        IF array_length(v_ship_record.speeds, 1) > 0 AND v_ship_record.speeds[1] IS NOT NULL THEN\n            v_report_data := ARRAY_APPEND(v_report_data,\n                'Max Speed: ' || (SELECT MAX(unnest) FROM unnest(v_ship_record.speeds)));\n        END IF;\n    END LOOP;\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    VALUES (\n        (SELECT COALESCE(MAX(\"Ship_ID\"), 0) + 1 FROM ship),\n        'Report_Generator',\n        'Analysis',\n        p_country_filter,\n        (SELECT COUNT(*) FROM ship WHERE \"Nationality\" = p_country_filter) * 100\n    );\n\n    DELETE FROM mission\n    WHERE \"Ship_ID\" IN (\n        SELECT \"Ship_ID\" FROM ship \n        WHERE \"Tonnage\" < p_tonnage_threshold\n        AND \"Nationality\" = p_country_filter\n    )\n    AND \"Speed_knots\" < p_speed_limit;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL generate_ship_mission_report('United Kingdom', 20, 3000, 1900);",
      "CALL generate_ship_mission_report('United States', 25, 3500, 1920);",
      "CALL generate_ship_mission_report('Germany', 15, 2500, 1910);",
      "CALL generate_ship_mission_report('Finland', 30, 4000, 1930);",
      "CALL generate_ship_mission_report('Japan', 18, 2800, 1905);"
    ],
    "summary": "Create a stored procedure named generate_ship_mission_report with parameters p_country_filter (text), p_speed_limit (integer), p_tonnage_threshold (integer), and p_year_cutoff (integer). The procedure should: 1) Build a text report array. 2) For each ship of nationality p_country_filter with tonnage > p_tonnage_threshold and missions launched after p_year_cutoff (or NULL), add a report line with ship name, type, and mission codes. If mission speeds exist, add the maximum speed. 3) Insert a new analysis ship named 'Report_Generator' with nationality p_country_filter and tonnage set to (count of ships from that country * 100). 4) Delete missions from ships of nationality p_country_filter with tonnage < p_tonnage_threshold, where the mission speed is below p_speed_limit.",
    "natural_language": "Make a stored procedure called generate_ship_mission_report that takes a country filter, a speed limit, a tonnage threshold, and a year cutoff. It should put together a text report. For ships from the specified country that are pretty large and have missions from not too long ago, add a line with the ship's details and its mission codes, maybe including the top speed if that data is around. Also, add a new analysis ship called 'Report_Generator' for that country, with its tonnage based roughly on how many ships are from there. Finally, get rid of some missions from smaller ships of that country where the mission speed wasn't really up to par.",
    "id": 48
  },
  {
    "ir": "Write a PLpgSQL stored procedure that iterates over each record in the singer table, and for each singer, calculates the total sales from the song table where the Singer_ID matches the current singer's Singer_ID. If the total sales exceed 1,000,000, it updates the singer's Net_Worth_Millions by adding 10 to the current value for that singer. If the total sales are greater than 500,000 but less than or equal to 1,000,000, it updates the Net_Worth_Millions by adding 5. If the total sales are greater than 100,000 but less than or equal to 500,000, it updates the Net_Worth_Millions by adding 2. If the total sales are 100,000 or less, it deletes from the song table any records where the Singer_ID matches the current singer's Singer_ID and the Sales value is less than 50,000.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_singer_sales()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_singer RECORD;\n    v_total_sales REAL;\nBEGIN\n    FOR v_singer IN SELECT * FROM singer LOOP\n        SELECT COALESCE(SUM(\"Sales\"), 0) INTO v_total_sales FROM song WHERE \"Singer_ID\" = v_singer.\"Singer_ID\";\n        IF v_total_sales > 1000000 THEN\n            UPDATE singer SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + 10 WHERE \"Singer_ID\" = v_singer.\"Singer_ID\";\n        ELSIF v_total_sales > 500000 THEN\n            UPDATE singer SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + 5 WHERE \"Singer_ID\" = v_singer.\"Singer_ID\";\n        ELSIF v_total_sales > 100000 THEN\n            UPDATE singer SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + 2 WHERE \"Singer_ID\" = v_singer.\"Singer_ID\";\n        ELSE\n            DELETE FROM song WHERE \"Singer_ID\" = v_singer.\"Singer_ID\" AND \"Sales\" < 50000;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL update_singer_sales();"
    ],
    "summary": "Create a stored procedure that loops through all singers. For each singer, calculate their total song sales. If total sales > 1,000,000, increase the singer's net worth by 10. If sales > 500,000 and <= 1,000,000, increase net worth by 5. If sales > 100,000 and <= 500,000, increase net worth by 2. If sales <= 100,000, delete the singer's songs with sales < 50,000.",
    "natural_language": "How can I create a stored procedure that iterates over every singer, calculates their total song sales, and then updates their net worth by 10 if sales exceed 1,000,000, by 5 if sales are greater than 500,000 but not more than 1,000,000, by 2 if sales are greater than 100,000 but not more than 500,000, or deletes the singer's songs with sales under 50,000 if total sales are 100,000 or less?",
    "id": 49
  },
  {
    "ir": "Write a PLpgSQL stored procedure that iterates over each record in the singer table where the Birth_Year column is less than 1950, and for each such singer, calculates the average sales from the song table where the Singer_ID matches the current singer's Singer_ID. If the calculated average sales exceed 500,000, the procedure inserts a new record into the song table with a Song_ID that is one greater than the current maximum Song_ID, a Title that concatenates 'Golden Hit for ' with the trimmed Name of the singer, the Singer_ID of the current singer, Sales set to 120% of the average sales, and Highest_Position set to 1.0. If the average sales are greater than 200,000 but not more than 500,000, the procedure updates the song table by decrementing the Highest_Position by 1 for all songs where the Singer_ID matches the current singer's Singer_ID and the Sales are greater than the average sales. If the average sales are 200,000 or less, the procedure deletes records from the song table where the Singer_ID matches the current singer's Singer_ID and the Sales are less than 100,000.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_singer_legacy()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_singer RECORD;\n    v_avg_sales REAL;\nBEGIN\n    FOR v_singer IN SELECT * FROM singer WHERE \"Birth_Year\" < 1950 LOOP\n        SELECT AVG(\"Sales\") INTO v_avg_sales FROM song WHERE \"Singer_ID\" = v_singer.\"Singer_ID\";\n        IF v_avg_sales > 500000 THEN\n            INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n            VALUES (\n                (SELECT COALESCE(MAX(\"Song_ID\"), 0) + 1 FROM song),\n                'Golden Hit for ' || TRIM(v_singer.\"Name\"),\n                v_singer.\"Singer_ID\",\n                v_avg_sales * 1.2,\n                1.0\n            );\n        ELSIF v_avg_sales > 200000 THEN\n            UPDATE song SET \"Highest_Position\" = \"Highest_Position\" - 1 \n            WHERE \"Singer_ID\" = v_singer.\"Singer_ID\" AND \"Sales\" > v_avg_sales;\n        ELSE\n            DELETE FROM song WHERE \"Singer_ID\" = v_singer.\"Singer_ID\" AND \"Sales\" < 100000;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL manage_singer_legacy();"
    ],
    "summary": "Create a stored procedure that loops through singers born before 1950. For each singer, calculate their average song sales. If average sales > 500,000, insert a new 'Golden Hit' song with sales set to 120% of the average and highest position 1.0. If average sales > 200,000 and <= 500,000, decrement the highest position by 1 for the singer's songs with sales above the average. If average sales <= 200,000, delete the singer's songs with sales < 100,000.",
    "natural_language": "Hey, can you whip up a stored procedure that goes through all the singers born before 1950? For each one, figure out their average song sales. If that average is over 500,000, slap in a new 'Golden Hit' song for them, setting the sales to 120% of that average and the highest chart position to 1.0. If the average is more than 200,000 but not over 500,000, then just nudge down the highest position by 1 for any of their songs that sold better than their average. And if the average is 200,000 or less, get rid of any of that singer's songs that sold under 100,000.",
    "id": 50
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `adjust_song_positions` that takes no parameters. This procedure is designed to iterate through every record in the `song` table. For each record, it declares a local variable `v_song` of type `RECORD` to hold the current row's data. The iteration is performed using a `FOR` loop that selects all columns (`*`) from the `song` table. Inside the loop, for each `v_song` record, a series of conditional checks are performed on the value of the `\"Sales\"` column. If the value of `v_song.\"Sales\"` is strictly greater than `1000000`, the procedure executes an `UPDATE` statement on the `song` table, setting the `\"Highest_Position\"` column to `1` for the row where the `\"Song_ID\"` column matches the `v_song.\"Song_ID\"` of the current record. Otherwise, if the previous condition is false, it checks if `v_song.\"Sales\"` is strictly greater than `500000`. If this condition is true, it executes an `UPDATE` statement on the `song` table, setting the `\"Highest_Position\"` column to `5` for the row where the `\"Song_ID\"` column matches the `v_song.\"Song_ID\"`. Otherwise, if both previous conditions are false, it checks if `v_song.\"Sales\"` is strictly greater than `100000`. If this condition is true, it executes an `UPDATE` statement on the `song` table, setting the `\"Highest_Position\"` column to `10` for the row where the `\"Song_ID\"` column matches the `v_song.\"Song_ID\"`. Finally, if none of the preceding conditions are met (i.e., `v_song.\"Sales\"` is less than or equal to `100000`), the procedure executes a `DELETE` statement, removing the row from the `song` table where the `\"Song_ID\"` column matches the `v_song.\"Song_ID\"`. This process continues until all records in the `song` table have been processed by the loop.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_song_positions()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_song RECORD;\nBEGIN\n    FOR v_song IN SELECT * FROM song LOOP\n        IF v_song.\"Sales\" > 1000000 THEN\n            UPDATE song SET \"Highest_Position\" = 1 WHERE \"Song_ID\" = v_song.\"Song_ID\";\n        ELSIF v_song.\"Sales\" > 500000 THEN\n            UPDATE song SET \"Highest_Position\" = 5 WHERE \"Song_ID\" = v_song.\"Song_ID\";\n        ELSIF v_song.\"Sales\" > 100000 THEN\n            UPDATE song SET \"Highest_Position\" = 10 WHERE \"Song_ID\" = v_song.\"Song_ID\";\n        ELSE\n            DELETE FROM song WHERE \"Song_ID\" = v_song.\"Song_ID\";\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL adjust_song_positions();"
    ],
    "summary": "Create a stored procedure named adjust_song_positions with no parameters. For each song, update its Highest_Position based on Sales: set to 1 if Sales > 1,000,000; set to 5 if Sales > 500,000; set to 10 if Sales > 100,000. If Sales <= 100,000, delete the song record.",
    "natural_language": "Hey, can you whip up a stored procedure called adjust_song_positions that doesn't need any parameters? Here's the deal: for every song, we gotta tweak its Highest_Position depending on how many copies it sold. If it sold over a million, bump it right up to number 1. If it sold more than half a million, put it at number 5. For sales over a hundred thousand, set it to 10. And if a song sold a hundred thousand or less, just go ahead and delete it from the records.",
    "id": 51
  },
  {
    "ir": "Write a PLpgSQL stored procedure named promote_singer_hits that iterates over each record in the singer table, represented by the variable v_singer, and performs operations based on the maximum sales of songs associated with each singer. For each singer, it selects the maximum value of the Sales column from the song table where the Singer_ID matches the current singer's Singer_ID, storing this value in the variable v_max_sales. If v_max_sales exceeds 1,000,000, it inserts a new row into the song table with a Song_ID that is one greater than the current maximum Song_ID, a Title that concatenates 'Super Hit for ' with the trimmed Name of the singer, the current Singer_ID, Sales set to 1.5 times v_max_sales, and Highest_Position set to 1.0. If v_max_sales is greater than 500,000 but not more than 1,000,000, it updates the song table by decreasing the Highest_Position by 2 for the song with the current Singer_ID and Sales equal to v_max_sales. If v_max_sales is 500,000 or less, it deletes rows from the song table where the Singer_ID matches the current singer's Singer_ID and Sales is less than 50,000.",
    "plsql": "CREATE OR REPLACE PROCEDURE promote_singer_hits()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_singer RECORD;\n    v_max_sales REAL;\nBEGIN\n    FOR v_singer IN SELECT * FROM singer LOOP\n        SELECT MAX(\"Sales\") INTO v_max_sales FROM song WHERE \"Singer_ID\" = v_singer.\"Singer_ID\";\n        IF v_max_sales > 1000000 THEN\n            INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n            VALUES (\n                (SELECT COALESCE(MAX(\"Song_ID\"), 0) + 1 FROM song),\n                'Super Hit for ' || TRIM(v_singer.\"Name\"),\n                v_singer.\"Singer_ID\",\n                v_max_sales * 1.5,\n                1.0\n            );\n        ELSIF v_max_sales > 500000 THEN\n            UPDATE song SET \"Highest_Position\" = \"Highest_Position\" - 2 \n            WHERE \"Singer_ID\" = v_singer.\"Singer_ID\" AND \"Sales\" = v_max_sales;\n        ELSE\n            DELETE FROM song WHERE \"Singer_ID\" = v_singer.\"Singer_ID\" AND \"Sales\" < 50000;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL promote_singer_hits();"
    ],
    "summary": "Create a stored procedure named promote_singer_hits. For each singer, find their maximum song sales (v_max_sales). If v_max_sales > 1,000,000, insert a new 'Super Hit' song with Sales 1.5 times v_max_sales. If v_max_sales > 500,000 and <= 1,000,000, decrease the Highest_Position by 2 for the song with that maximum sales. If v_max_sales <= 500,000, delete all songs for that singer where Sales < 50,000.",
    "natural_language": "Create procedure promote_singer_hits. For each singer: if max sales > 1M, insert 'Super Hit' with 1.5x sales. If max sales > 500K and <= 1M, decrease that song's Highest_Position by 2. If max sales <= 500K, delete singer's songs with sales < 50K.",
    "id": 52
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_artist_artwork_counts that accepts three input parameters: p_artist_id of type bigint to identify an artist, p_min_year of type bigint to specify the lower bound of a year range, and p_max_year of type bigint to specify the upper bound of a year range. The procedure first declares three local variables: v_painting_count of type bigint, v_sculpture_count of type bigint, and v_artist_exists of type boolean. It then calculates the number of paintings by performing a SELECT COUNT(*) query from the \"Paintings\" table where the \"painterID\" column equals the input p_artist_id and the \"year\" column is between p_min_year and p_max_year inclusive, storing the result in v_painting_count. Next, it calculates the number of sculptures by performing a SELECT COUNT(*) query from the \"Sculptures\" table where the \"sculptorID\" column equals the input p_artist_id and the \"year\" column is between p_min_year and p_max_year inclusive, storing the result in v_sculpture_count. The procedure then checks for the existence of the artist by performing a SELECT EXISTS query on the \"Artists\" table where the \"artistID\" column equals p_artist_id, storing the boolean result in v_artist_exists. If v_artist_exists is FALSE, the procedure inserts a new row into the \"Artists\" table with the provided p_artist_id as \"artistID\", 'Temp' as \"lname\", 'Artist' as \"fname\", 1900 as \"birthYear\", and 2000 as \"deathYear\". Finally, the procedure deletes all rows from the \"Paintings\" table where the \"painterID\" column equals p_artist_id and the \"year\" column is less than the input p_min_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_artist_artwork_counts(\n    p_artist_id bigint,\n    p_min_year bigint,\n    p_max_year bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_painting_count bigint;\n    v_sculpture_count bigint;\n    v_artist_exists boolean;\nBEGIN\n    SELECT COUNT(*) INTO v_painting_count\n    FROM \"Paintings\"\n    WHERE \"painterID\" = p_artist_id AND \"year\" BETWEEN p_min_year AND p_max_year;\n    \n    SELECT COUNT(*) INTO v_sculpture_count\n    FROM \"Sculptures\"\n    WHERE \"sculptorID\" = p_artist_id AND \"year\" BETWEEN p_min_year AND p_max_year;\n    \n    SELECT EXISTS(SELECT 1 FROM \"Artists\" WHERE \"artistID\" = p_artist_id) INTO v_artist_exists;\n    \n    IF NOT v_artist_exists THEN\n        INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\")\n        VALUES (p_artist_id, 'Temp', 'Artist', 1900, 2000);\n    END IF;\n    \n    DELETE FROM \"Paintings\"\n    WHERE \"painterID\" = p_artist_id AND \"year\" < p_min_year;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL calculate_artist_artwork_counts(111, 1880, 1890);",
      "CALL calculate_artist_artwork_counts(222, 1940, 1950);",
      "CALL calculate_artist_artwork_counts(333, 1850, 1860);",
      "CALL calculate_artist_artwork_counts(555, 1880, 1890);",
      "CALL calculate_artist_artwork_counts(999, 1900, 2000);"
    ],
    "summary": "Create a stored procedure named calculate_artist_artwork_counts with parameters p_artist_id, p_min_year, and p_max_year. Count paintings and sculptures for the artist within the year range. If the artist does not exist, insert a temporary artist record. Finally, delete all paintings by the artist created before p_min_year.",
    "natural_language": "Develop a stored procedure, which should be named calculate_artist_artwork_counts, that accepts three distinct parameters: p_artist_id, p_min_year, and p_max_year. This procedure must meticulously count the total number of paintings and sculptures produced by the specified artist within the provided inclusive year range. Importantly, if the artist's record cannot be found in the database, the procedure should gracefully insert a temporary record for that artist. Subsequently, as a final step, it must comprehensively delete every single painting created by that particular artist which dates from before the specified p_min_year threshold.",
    "id": 53
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `relocate_artworks_based_on_artist` that accepts three input parameters: `p_artist_id` of type `bigint`, `p_new_location` of type `text`, and `p_medium_filter` of type `text`. The purpose of this procedure is to manage artwork records by first deleting existing artwork entries based on artist and medium, and then conditionally inserting a new, generic artwork entry. The procedure begins by executing a `DELETE` statement on the `\"Paintings\"` table. This `DELETE` operation targets rows where the `\"painterID\"` column matches the value provided in the `p_artist_id` parameter AND the `\"medium\"` column matches the value provided in the `p_medium_filter` parameter. Following this, another `DELETE` statement is executed, this time on the `\"Sculptures\"` table. This `DELETE` operation targets rows where the `\"sculptorID\"` column matches the value provided in the `p_artist_id` parameter AND the `\"medium\"` column matches the value provided in the `p_medium_filter` parameter. After these deletion operations, an `INSERT` statement is executed on the `\"Paintings\"` table. This `INSERT` statement attempts to add a new row with specific, hardcoded values and values derived from the input parameters. The `\"paintingID\"` column is set to `999`, the `\"title\"` column is set to the literal string `'Relocated Artwork'`, the `\"year\"` column is set to `2024`, the `\"height_mm\"` column is set to `1000`, the `\"width_mm\"` column is set to `1000`, the `\"medium\"` column is set to the value of the `p_medium_filter` parameter, the `\"mediumOn\"` column is set to the literal string `'canvas'`, the `\"location\"` column is set to the value of the `p_new_location` parameter, and the `\"painterID\"` column is set to the value of the `p_artist_id` parameter. This `INSERT` operation is conditional, meaning it will only proceed if a specific condition is met. The condition is evaluated by an `EXISTS` subquery: `SELECT 1 FROM \"Artists\" WHERE \"artistID\" = p_artist_id`. This subquery checks if there is at least one row in the `\"Artists\"` table where the `\"artistID\"` column matches the value provided in the `p_artist_id` parameter. If such an artist exists, the `INSERT` operation is performed; otherwise, it is skipped.",
    "plsql": "CREATE OR REPLACE PROCEDURE relocate_artworks_based_on_artist(\n    p_artist_id bigint,\n    p_new_location text,\n    p_medium_filter text\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Paintings\"\n    WHERE \"painterID\" = p_artist_id AND \"medium\" = p_medium_filter;\n    \n    DELETE FROM \"Sculptures\"\n    WHERE \"sculptorID\" = p_artist_id AND \"medium\" = p_medium_filter;\n    \n    INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\")\n    SELECT 999, 'Relocated Artwork', 2024, 1000, 1000, p_medium_filter, 'canvas', p_new_location, p_artist_id\n    WHERE EXISTS (SELECT 1 FROM \"Artists\" WHERE \"artistID\" = p_artist_id);\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL relocate_artworks_based_on_artist(111, 'New Gallery 101', 'oil');",
      "CALL relocate_artworks_based_on_artist(222, 'New Gallery 202', 'bronze');",
      "CALL relocate_artworks_based_on_artist(333, 'New Gallery 303', 'conte crayon');",
      "CALL relocate_artworks_based_on_artist(111, 'New Gallery 404', 'canvas');",
      "CALL relocate_artworks_based_on_artist(222, 'New Gallery 505', 'panel');"
    ],
    "summary": "Create a stored procedure named relocate_artworks_based_on_artist with parameters p_artist_id, p_new_location, and p_medium_filter. Delete paintings and sculptures by the specified artist with the given medium. Then, if the artist exists, insert a new generic painting titled 'Relocated Artwork' with the provided location and medium.",
    "natural_language": "How can I create a stored procedure called 'relocate_artworks_based_on_artist' that takes parameters for the artist ID, new location, and medium filter, deletes paintings and sculptures by that artist matching the medium, and then, if the artist exists, inserts a new generic painting titled 'Relocated Artwork' with the provided location and medium?",
    "id": 54
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `analyze_artist_productivity` that accepts three input parameters: `p_start_year` of type `bigint`, representing the beginning year for analysis; `p_end_year` of type `bigint`, representing the ending year for analysis; and `p_min_height` of type `bigint`, representing the minimum height in millimeters for paintings to be considered. The procedure first declares two local variables: `v_avg_paintings` of type `numeric` to store the calculated average height of paintings, and `v_max_sculptures` of type `bigint` to store the maximum year found in sculptures.\n\nThe procedure then performs a `SELECT` operation to calculate the average height of paintings. It queries the `\"Paintings\"` table, specifically the `\"height_mm\"` column, and stores the result into the `v_avg_paintings` variable. This average is computed only for rows where the `\"year\"` column is inclusively between `p_start_year` and `p_end_year`, and simultaneously, the `\"height_mm\"` column is strictly greater than `p_min_height`.\n\nFollowing this, another `SELECT` operation is executed to find the maximum year among sculptures. It queries the `\"Sculptures\"` table, specifically the `\"year\"` column, and stores the maximum value found into the `v_max_sculptures` variable. This maximum is determined only for rows where the `\"year\"` column is inclusively between `p_start_year` and `p_end_year`.\n\nNext, the procedure performs an `INSERT` operation into the `\"Sculptures\"` table. A new row is added with the following values: `9999` for the `\"sculptureID\"` column, the string literal `'Analysis Marker'` for the `\"title\"` column, the value of `v_max_sculptures` explicitly cast to `bigint` for the `\"year\"` column, the string literal `'analysis'` for the `\"medium\"` column, the string literal `'Archive'` for the `\"location\"` column, and `999` for the `\"sculptorID\"` column.\n\nFinally, the procedure executes a `DELETE` operation on the `\"Artists\"` table. It removes all rows where either the `\"birthYear\"` column is strictly greater than `p_end_year` or the `\"deathYear\"` column is strictly less than `p_start_year`.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_artist_productivity(\n    p_start_year bigint,\n    p_end_year bigint,\n    p_min_height bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_paintings numeric;\n    v_max_sculptures bigint;\nBEGIN\n    SELECT AVG(\"height_mm\") INTO v_avg_paintings\n    FROM \"Paintings\"\n    WHERE \"year\" BETWEEN p_start_year AND p_end_year AND \"height_mm\" > p_min_height;\n    \n    SELECT MAX(\"year\") INTO v_max_sculptures\n    FROM \"Sculptures\"\n    WHERE \"year\" BETWEEN p_start_year AND p_end_year;\n    \n    INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"year\", \"medium\", \"location\", \"sculptorID\")\n    VALUES (9999, 'Analysis Marker', CAST(v_max_sculptures AS bigint), 'analysis', 'Archive', 999);\n    \n    DELETE FROM \"Artists\"\n    WHERE \"birthYear\" > p_end_year OR \"deathYear\" < p_start_year;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL analyze_artist_productivity(1800, 1900, 100);",
      "CALL analyze_artist_productivity(1850, 1950, 500);",
      "CALL analyze_artist_productivity(1900, 2000, 1000);",
      "CALL analyze_artist_productivity(1880, 1890, 150);",
      "CALL analyze_artist_productivity(1920, 1980, 200);"
    ],
    "summary": "Create a stored procedure named analyze_artist_productivity with parameters p_start_year, p_end_year, and p_min_height. Calculate the average painting height for paintings within the year range and above the minimum height. Find the maximum sculpture year within the range. Insert a marker sculpture using the maximum year. Delete artists whose lifespans do not overlap with the analysis period.",
    "natural_language": "Develop a stored procedure, which should be named analyze_artist_productivity, incorporating the parameters p_start_year, p_end_year, and p_min_height. This procedure must meticulously compute the average height of all paintings that were created within the specified year range and which also exceed the provided minimum height threshold. Subsequently, it should identify the most recent year, specifically the maximum year, from among the sculptures created within that same temporal range. Using this determined maximum year, the procedure is then to insert a new marker sculpture record. Finally, it must comprehensively delete any and all artists whose complete lifespans, from birth to death, show no overlap whatsoever with the defined analysis period bounded by the start and end years.",
    "id": 55
  },
  {
    "ir": "Write a PLpgSQL stored procedure named consolidate_artist_records that accepts three input parameters: a bigint parameter p_source_id representing the source artist's unique identifier, a bigint parameter p_target_id representing the target artist's unique identifier to which records will be consolidated, and a bigint parameter p_year_threshold representing a cutoff year for deletion operations. The procedure first performs an INSERT operation into the \"Artists\" table, selecting the columns \"artistID\", \"lname\", \"fname\", \"birthYear\", and \"deathYear\". The values inserted are: for \"artistID\", the provided p_target_id; for \"lname\", the literal string 'Consolidated'; for \"fname\", the literal string 'Artist'; for \"birthYear\", the minimum \"birthYear\" value; and for \"deathYear\", the maximum \"deathYear\" value. These aggregate values are calculated from the \"Artists\" table, specifically from rows where the \"artistID\" column matches either the p_source_id or the p_target_id parameter. Following this insertion, the procedure executes a DELETE operation on the \"Paintings\" table, removing all rows where the \"painterID\" column equals the p_source_id parameter and the \"year\" column is less than the p_year_threshold parameter. Subsequently, the procedure executes another DELETE operation on the \"Sculptures\" table, removing all rows where the \"sculptorID\" column equals the p_source_id parameter and the \"year\" column is less than the p_year_threshold parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_artist_records(\n    p_source_id bigint,\n    p_target_id bigint,\n    p_year_threshold bigint\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\")\n    SELECT p_target_id, 'Consolidated', 'Artist', MIN(\"birthYear\"), MAX(\"deathYear\")\n    FROM \"Artists\"\n    WHERE \"artistID\" IN (p_source_id, p_target_id);\n    \n    DELETE FROM \"Paintings\"\n    WHERE \"painterID\" = p_source_id AND \"year\" < p_year_threshold;\n    \n    DELETE FROM \"Sculptures\"\n    WHERE \"sculptorID\" = p_source_id AND \"year\" < p_year_threshold;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL consolidate_artist_records(111, 222, 1900);",
      "CALL consolidate_artist_records(333, 222, 1880);",
      "CALL consolidate_artist_records(555, 222, 1890);",
      "CALL consolidate_artist_records(111, 333, 1875);",
      "CALL consolidate_artist_records(222, 333, 1920);"
    ],
    "summary": "Create a stored procedure named consolidate_artist_records that takes a source artist ID, a target artist ID, and a year threshold. Insert a new 'Consolidated Artist' record into the Artists table using the target ID, with birth and death years aggregated from both source and target artists. Then delete paintings and sculptures by the source artist created before the year threshold.",
    "natural_language": "Create a stored procedure, which should be named consolidate_artist_records, that accepts three distinct parameters: a source artist ID, a target artist ID, and a specific year threshold. This procedure must first meticulously insert a brand new record, designated as 'Consolidated Artist', into the comprehensive Artists table, utilizing the provided target ID as its identifier, while carefully calculating the aggregated birth and death years derived from both the original source artist and the intended target artist. Subsequently, it should thoroughly delete all existing paintings and sculptures that were originally created by the source artist, but only those artworks which were definitively produced prior to the established year threshold.",
    "id": 56
  },
  {
    "ir": "Write a PLpgSQL stored procedure named generate_artwork_summary_report that accepts three parameters: p_artist_lname of type text, p_medium_type of type text, and p_location_filter of type text. The procedure begins by declaring three local variables: v_total_count, v_earliest_year, and v_latest_year, all of type bigint. It then performs a SELECT operation to count the total number of rows in the \"Paintings\" table where the \"painterID\" from the \"Paintings\" table matches the \"artistID\" from the \"Artists\" table, and the \"lname\" column in the \"Artists\" table matches the value of p_artist_lname, and the \"medium\" column in the \"Paintings\" table matches the value of p_medium_type. The result of this count is stored in the variable v_total_count. Next, the procedure executes another SELECT operation to find the minimum value of the \"year\" column from the \"Sculptures\" table where the \"medium\" column matches p_medium_type and the \"location\" column either matches p_location_filter or is NULL. This minimum year value is stored in the variable v_earliest_year. Following this, a similar SELECT operation is performed to find the maximum value of the \"year\" column from the \"Sculptures\" table under the same conditions, and this maximum year value is stored in the variable v_latest_year. Finally, the procedure performs an INSERT operation into the \"Paintings\" table, adding a new row with the following values: 8888 for \"paintingID\", 'Summary Report' for \"title\", the value of v_latest_year for \"year\", 500 for \"height_mm\", 800 for \"width_mm\", the value of p_medium_type for \"medium\", 'report' for \"mediumOn\", the value of p_location_filter for \"location\", and 888 for \"painterID\".",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_artwork_summary_report(\n    p_artist_lname text,\n    p_medium_type text,\n    p_location_filter text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_count bigint;\n    v_earliest_year bigint;\n    v_latest_year bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_total_count\n    FROM \"Paintings\" p\n    JOIN \"Artists\" a ON p.\"painterID\" = a.\"artistID\"\n    WHERE a.\"lname\" = p_artist_lname AND p.\"medium\" = p_medium_type;\n    \n    SELECT MIN(\"year\") INTO v_earliest_year\n    FROM \"Sculptures\"\n    WHERE \"medium\" = p_medium_type AND (\"location\" = p_location_filter OR \"location\" IS NULL);\n    \n    SELECT MAX(\"year\") INTO v_latest_year\n    FROM \"Sculptures\"\n    WHERE \"medium\" = p_medium_type AND (\"location\" = p_location_filter OR \"location\" IS NULL);\n    \n    INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\")\n    VALUES (8888, 'Summary Report', v_latest_year, 500, 800, p_medium_type, 'report', p_location_filter, 888);\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL generate_artwork_summary_report('Seurat', 'oil', 'Gallery 240');",
      "CALL generate_artwork_summary_report('Picasso', 'bronze', 'Gallery 226');",
      "CALL generate_artwork_summary_report('van Gogh', 'conte crayon', NULL);",
      "CALL generate_artwork_summary_report('Seurat', 'bronze', NULL);",
      "CALL generate_artwork_summary_report('Picasso', 'oil', 'Gallery 240');"
    ],
    "summary": "Create a stored procedure named generate_artwork_summary_report that takes an artist's last name, a medium type, and a location filter. Count paintings by that artist with the specified medium. Find the earliest and latest year for sculptures with that medium and location (including NULL). Insert a summary report painting with ID 8888 using the calculated values.",
    "natural_language": "Create a stored procedure called generate_artwork_summary_report that uses an artist's last name, a kind of medium, and a location filter. Get a rough count of paintings by that artist for the given medium. Figure out the earliest and latest years for some sculptures matching that medium and general location (including cases where it's missing). Insert a summary report painting with ID 8888 using those computed figures.",
    "id": 57
  },
  {
    "ir": "Write a PLpgSQL stored procedure named delete_country_data that accepts three parameters: p_country_id of type bigint, p_min_score of type real, and p_language_count of type integer. The procedure begins by declaring a local variable v_lang_count of type integer. It then performs a SELECT operation to count the number of rows in the official_languages table where the country_id column matches the value of p_country_id, storing the result in v_lang_count. The procedure includes an IF conditional statement that checks if v_lang_count is greater than or equal to the value of p_language_count. If this condition is true, the procedure executes a DELETE operation on the official_languages table, removing all rows where the country_id column equals p_country_id. Subsequently, it performs another DELETE operation on the countries table, removing rows where the id column matches p_country_id and the overall_score column is less than p_min_score.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_country_data(p_country_id bigint, p_min_score real, p_language_count integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lang_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_lang_count FROM official_languages WHERE country_id = p_country_id;\n    \n    IF v_lang_count >= p_language_count THEN\n        DELETE FROM official_languages WHERE country_id = p_country_id;\n        DELETE FROM countries WHERE id = p_country_id AND overall_score < p_min_score;\n    END IF;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL delete_country_data(1, 95.0, 2);",
      "CALL delete_country_data(2, 98.0, 1);",
      "CALL delete_country_data(3, 90.0, 3);",
      "CALL delete_country_data(4, 85.5, 0);",
      "CALL delete_country_data(5, 99.9, 5);"
    ],
    "summary": "Create a stored procedure named delete_country_data that takes a country ID, a minimum score, and a language count threshold. Count the country's official languages. If the count meets or exceeds the threshold, delete all its official language records, then delete the country record if its overall score is below the minimum.",
    "natural_language": "Please construct a stored procedure designated as 'delete_country_data'. This procedure must accept three parameters: a country identifier, a minimum acceptable score, and a threshold for language count. The procedure should first ascertain the number of official languages associated with the specified country. Should this count meet or exceed the provided threshold, the procedure must proceed to delete all records pertaining to those official languages. Subsequently, provided the country's overall score is inferior to the stipulated minimum, the procedure should then delete the corresponding country record.",
    "id": 58
  },
  {
    "ir": "Write a PLpgSQL stored procedure named bulk_insert_countries that accepts three input parameters: p_base_name of type text, which serves as a base string for generating country names; p_count of type integer, which specifies the total number of new country records to create; and p_base_score of type real, which provides a base numerical score. The procedure begins by declaring local variables i, v_country_name, v_score, and v_max_id. It first executes a SELECT query on the countries table to retrieve the current maximum value from the id column, storing the result in v_max_id; if the id column contains no values, the COALESCE function returns 0. The procedure then enters a FOR loop that iterates from 1 to the value of p_count. In each iteration, it constructs v_country_name by concatenating the p_base_name parameter, an underscore character, and the string representation of the current loop index i. It calculates v_score by adding the p_base_score parameter to the remainder of dividing the current index i by 10, using the MOD function. Finally, for each iteration, it performs an INSERT operation into the countries table, specifying values for the id, name, and overall_score columns: the id is set to the sum of v_max_id and the current index i, the name is set to v_country_name, and the overall_score is set to v_score.",
    "plsql": "CREATE OR REPLACE PROCEDURE bulk_insert_countries(p_base_name text, p_count integer, p_base_score real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    i integer;\n    v_country_name text;\n    v_score real;\n    v_max_id bigint;\nBEGIN\n    -- Get the current maximum ID to ensure unique IDs\n    SELECT COALESCE(MAX(id), 0) INTO v_max_id FROM countries;\n    \n    FOR i IN 1..p_count LOOP\n        v_country_name := p_base_name || '_' || i::text;\n        v_score := p_base_score + MOD(i, 10);\n        INSERT INTO countries (id, name, overall_score) \n        VALUES (v_max_id + i, v_country_name, v_score);\n    END LOOP;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL bulk_insert_countries('TestCountryA', 5, 85.5);",
      "CALL bulk_insert_countries('NewRegion', 10, 70.0);",
      "CALL bulk_insert_countries('ContinentX', 3, 92.1);",
      "CALL bulk_insert_countries('IslandNation', 1, 99.9);",
      "CALL bulk_insert_countries('Developing', 7, 60.0);"
    ],
    "summary": "Create a stored procedure named bulk_insert_countries that takes a base name, a count, and a base score. Generate and insert the specified number of country records with sequential IDs (starting after the current maximum), names formed by appending \"_index\" to the base name, and scores calculated as base score plus (index modulo 10).",
    "natural_language": "Develop a stored procedure, which should be named bulk_insert_countries, designed to accept three distinct input parameters: a foundational name string, a numerical count, and a base score value. This procedure must meticulously generate and then insert a precise quantity of country records, as specified by the count parameter. Each new record should receive a sequentially assigned ID, beginning immediately after the currently highest existing ID in the table. The country names are to be constructed by systematically appending an underscore followed by the sequential index number to the provided base name. Furthermore, the score for each entry must be dynamically calculated by taking the supplied base score and adding to it the result of the current index number modulo ten.",
    "id": 59
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `update_management_status` that accepts two input parameters: `p_dept_id`, an integer representing a department identifier, and `p_head_id`, an integer representing a head identifier. The procedure's primary function is to manage the presence of a specific department-head association within the `management` table. It begins by executing a `SELECT` statement to check for the existence of a record in the `management` table. This `SELECT` statement attempts to retrieve `1` (a constant value, indicating existence rather than actual data) from the `management` table where the column `\"department_ID\"` is equal to the value provided by the `p_dept_id` parameter AND the column `\"head_ID\"` is equal to the value provided by the `p_head_id` parameter. Based on the outcome of this existence check, a conditional logic path is followed. If the `SELECT` statement finds at least one matching record (i.e., `IF EXISTS` evaluates to TRUE), the procedure then executes a `DELETE` operation. This `DELETE` statement removes all rows from the `management` table where the `\"department_ID\"` column matches the `p_dept_id` parameter AND the `\"head_ID\"` column matches the `p_head_id` parameter. Conversely, if the `SELECT` statement does not find any matching records (i.e., `IF EXISTS` evaluates to FALSE), the procedure executes an `INSERT` operation. This `INSERT` statement adds a new row into the `management` table. The values inserted are: the `p_dept_id` parameter into the `\"department_ID\"` column, the `p_head_id` parameter into the `\"head_ID\"` column, and the literal string value `'Yes'` into the `\"temporary_acting\"` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_management_status(p_dept_id integer, p_head_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM management WHERE \"department_ID\" = p_dept_id AND \"head_ID\" = p_head_id) THEN\n        DELETE FROM management WHERE \"department_ID\" = p_dept_id AND \"head_ID\" = p_head_id;\n    ELSE\n        INSERT INTO management(\"department_ID\", \"head_ID\", \"temporary_acting\")\n        VALUES (p_dept_id, p_head_id, 'Yes');\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL update_management_status(1, 1);",
      "CALL update_management_status(2, 3);",
      "CALL update_management_status(3, 2);",
      "CALL update_management_status(15, 5);",
      "CALL update_management_status(2, 5);"
    ],
    "summary": "Create a stored procedure named update_management_status that takes a department ID and a head ID. Check if this department-head combination exists in the management table. If it exists, delete the record. If it doesn't exist, insert a new record with 'Yes' in the temporary_acting column.",
    "natural_language": "Hey, can you whip up a stored procedure called update_management_status? It needs a department ID and a head ID. Basically, check if that department and head are already paired up in the management table. If they are, just get rid of that entry. If they're not, go ahead and add a new one, and make sure to put 'Yes' in the temporary_acting column.",
    "id": 60
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_department_head that accepts two integer input parameters: p_dept_id, which represents a department identifier, and p_head_id, which represents a head identifier. The procedure first checks for the existence of a record in the department table where the Department_ID column exactly matches the provided p_dept_id parameter. If such a department record exists, the procedure performs an INSERT operation into the management table, specifying values for three columns: it sets the department_ID column to the p_dept_id parameter value, sets the head_ID column to the p_head_id parameter value, and sets the temporary_acting column to the literal string 'No'. If the conditional check fails, meaning no department record with the specified Department_ID is found, the procedure executes a DELETE operation on the management table, removing all rows where the head_ID column is equal to the provided p_head_id parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_department_head(p_dept_id integer, p_head_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM department WHERE \"Department_ID\" = p_dept_id) THEN\n        INSERT INTO management(\"department_ID\", \"head_ID\", temporary_acting)\n        VALUES (p_dept_id, p_head_id, 'No');\n    ELSE\n        DELETE FROM management WHERE \"head_ID\" = p_head_id;\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL manage_department_head(1, 5);",
      "CALL manage_department_head(2, 4);",
      "CALL manage_department_head(3, 6);",
      "CALL manage_department_head(99, 1);",
      "CALL manage_department_head(15, 2);"
    ],
    "summary": "Create a stored procedure named manage_department_head that accepts two integer parameters: p_dept_id and p_head_id. If a department with the given ID exists, insert a new record into the management table with the provided IDs and set temporary_acting to 'No'. If the department does not exist, delete all records from the management table where the head_ID matches the provided p_head_id.",
    "natural_language": "Create a stored procedure called manage_department_head that takes two integer inputs: p_dept_id and p_head_id. If the specified department exists, insert a new management record with these IDs and set temporary_acting to 'No'. If the department does not exist, remove all management records where the head_ID equals the provided p_head_id.",
    "id": 61
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named migrate_institution_data that accepts three input parameters: a text parameter p_province to filter by a specific province, a real number parameter p_capacity_threshold to define a capacity limit, and a real number parameter p_enrollment_factor used as a divisor for enrollment calculations. The procedure first declares a local real variable v_max_founded and a record variable v_record. It begins execution by querying the \"institution\" table to find the maximum value from its \"Founded\" column, but only for those rows where the \"Province\" column matches the input p_province and the \"Capacity\" column is strictly greater than the input p_capacity_threshold, storing this maximum value into v_max_founded. Next, the procedure enters a FOR loop that iterates over a result set from the \"institution\" table, selecting the \"Institution_ID\" and \"Enrollment\" columns for every row where the \"Province\" column equals p_province and the \"Capacity\" column is less than or equal to p_capacity_threshold. For each record fetched into v_record, the procedure performs an INSERT operation on the \"Championship\" table, targeting the columns \"Institution_ID\", \"Nickname\", \"Joined\", and \"Number_of_Championships\". The inserted values are: v_record.\"Institution_ID\", the literal string 'Migrated', the result of the COALESCE function applied to v_max_founded with a fallback default of 2000 (which is used if v_max_founded is null), and the result of the FLOOR function applied to the division of v_record.\"Enrollment\" by the input parameter p_enrollment_factor. This INSERT command includes an ON CONFLICT clause that specifies a conflict action on the \"Institution_ID\" column (implying it is a primary key or has a unique constraint); if a conflict occurs because an entry with the same \"Institution_ID\" already exists, it performs an UPDATE instead, setting the \"Nickname\" column to 'Migrated', the \"Joined\" column to the same COALESCE(v_max_founded, 2000) value, and the \"Number_of_Championships\" column to the same FLOOR(v_record.\"Enrollment\" / p_enrollment_factor) calculation.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_institution_data(p_province text, p_capacity_threshold real, p_enrollment_factor real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_max_founded real;\n    v_record RECORD;\nBEGIN\n    SELECT MAX(\"Founded\") INTO v_max_founded\n    FROM \"institution\"\n    WHERE \"Province\" = p_province AND \"Capacity\" > p_capacity_threshold;\n\n    FOR v_record IN \n        SELECT \"Institution_ID\", \"Enrollment\"\n        FROM \"institution\"\n        WHERE \"Province\" = p_province AND \"Capacity\" <= p_capacity_threshold\n    LOOP\n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        VALUES (v_record.\"Institution_ID\", 'Migrated', COALESCE(v_max_founded, 2000), \n                FLOOR(v_record.\"Enrollment\" / p_enrollment_factor))\n        ON CONFLICT (\"Institution_ID\") DO UPDATE\n        SET \"Nickname\" = 'Migrated',\n            \"Joined\" = COALESCE(v_max_founded, 2000),\n            \"Number_of_Championships\" = FLOOR(v_record.\"Enrollment\" / p_enrollment_factor);\n    END LOOP;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL migrate_institution_data('BC', 10000.0, 100.0);",
      "CALL migrate_institution_data('AB', 5000.0, 50.0);",
      "CALL migrate_institution_data('BC', 50000.0, 200.0);",
      "CALL migrate_institution_data('AB', 1000.0, 10.0);",
      "CALL migrate_institution_data('BC', 20000.0, 75.0);"
    ],
    "summary": "Create a stored procedure named migrate_institution_data that accepts three parameters: p_province (text), p_capacity_threshold (real), and p_enrollment_factor (real). Find the maximum Founded year for institutions in the given province with Capacity above the threshold. Then, for institutions in the same province with Capacity at or below the threshold, insert or update records in the Championship table. Set Nickname to 'Migrated', Joined to the maximum founded year (or 2000 if null), and Number_of_Championships to the floor of Enrollment divided by the enrollment factor.",
    "natural_language": "Please construct a stored procedure designated as 'migrate_institution_data'. This procedure shall accept three input parameters: 'p_province' of text type, 'p_capacity_threshold' of real type, and 'p_enrollment_factor' of real type. The procedure's logic must first ascertain the maximum value within the 'Founded' year column for those institutions located in the specified province whose 'Capacity' exceeds the provided threshold. Subsequently, for institutions within the same province whose 'Capacity' is less than or equal to the stated threshold, it is required to perform an upsert operation on the 'Championship' table. The operation should assign the 'Nickname' field the value 'Migrated', set the 'Joined' field to the previously determined maximum founded year (substituting the year 2000 should the maximum be null), and calculate the 'Number_of_Championships' field as the floor of the institution's 'Enrollment' divided by the provided enrollment factor.",
    "id": 62
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named remove_underperforming_teams that accepts three input parameters: a real number parameter p_min_championships representing a minimum championship count threshold, a real number parameter p_max_joined_year representing a maximum year threshold for joining, and a real number parameter p_min_capacity representing a minimum capacity threshold. The procedure first executes a DELETE operation on the \"Championship\" table, targeting rows where the \"Number_of_Championships\" column value is less than the p_min_championships parameter, and the \"Joined\" column value is less than or equal to the p_max_joined_year parameter, and where a correlated subquery using the EXISTS clause finds at least one matching row in the \"institution\" table for which the \"Institution_ID\" column matches the \"Championship\".\"Institution_ID\" and the \"Capacity\" column value is less than the p_min_capacity parameter. Following this deletion, the procedure performs a SELECT query using the EXISTS clause to check if any rows remain in the \"institution\" table where the \"Capacity\" column value is greater than or equal to the p_min_capacity parameter, storing the boolean result of this existence check into a local variable v_institution_exists. The procedure then uses an IF conditional statement to evaluate if v_institution_exists is FALSE; if this condition is true, it executes a second DELETE operation that removes all remaining rows from the \"Championship\" table without any filtering conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_underperforming_teams(p_min_championships real, p_max_joined_year real, p_min_capacity real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_institution_exists boolean;\nBEGIN\n    DELETE FROM \"Championship\" c\n    WHERE c.\"Number_of_Championships\" < p_min_championships \n    AND c.\"Joined\" <= p_max_joined_year\n    AND EXISTS (\n        SELECT 1 FROM \"institution\" i \n        WHERE i.\"Institution_ID\" = c.\"Institution_ID\" \n        AND i.\"Capacity\" < p_min_capacity\n    );\n\n    SELECT EXISTS(\n        SELECT 1 FROM \"institution\" WHERE \"Capacity\" >= p_min_capacity\n    ) INTO v_institution_exists;\n\n    IF NOT v_institution_exists THEN\n        DELETE FROM \"Championship\";\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL remove_underperforming_teams(1.0, 1994.0, 4000.0);",
      "CALL remove_underperforming_teams(0.5, 1995.0, 3500.0);",
      "CALL remove_underperforming_teams(2.0, 1993.0, 5000.0);",
      "CALL remove_underperforming_teams(1.5, 1994.0, 3000.0);",
      "CALL remove_underperforming_teams(0.0, 1995.0, 4500.0);"
    ],
    "summary": "Create a stored procedure named remove_underperforming_teams that accepts three real parameters: p_min_championships, p_max_joined_year, and p_min_capacity. First, delete championship records where the number of championships is below the minimum, the joined year is at or below the maximum, and the associated institution has a capacity below the minimum. Then, if no institutions remain with capacity at or above the minimum, delete all remaining records from the Championship table.",
    "natural_language": "Alright, so we need a stored procedure called remove_underperforming_teams. It's gotta take in three real number inputs: p_min_championships, p_max_joined_year, and p_min_capacity. Here's the deal: first, wipe out any championship records where the team's championship count is less than the minimum, the year they joined is that max year or earlier, and their home institution's capacity doesn't meet the minimum. After that cleanup, if there aren't any institutions left that have a capacity meeting or beating the minimum, just go ahead and delete whatever's left in the Championship table.",
    "id": 63
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `populate_championship_gaps` that accepts three input parameters: `p_target_nickname` of type `text`, `p_base_year` of type `real`, and `p_championship_multiplier` of type `real`. This procedure is designed to populate or update records in the `\"Championship\"` table for institutions that currently do not have any entries in the `\"Championship\"` table.\n\nThe procedure begins by declaring a local cursor named `v_institution_cursor`. This cursor is defined to select specific columns from the `\"institution\"` table. Specifically, it selects `\"Institution_ID\"`, `\"Founded\"`, and `\"Enrollment\"` from the `\"institution\"` table, aliased as `i`. The selection is filtered by a `WHERE NOT EXISTS` clause. This clause ensures that only institutions (`i`) are considered for which there is no corresponding record in the `\"Championship\"` table (`c`) where the `\"Institution_ID\"` in `\"Championship\"` matches the `\"Institution_ID\"` from the current institution record (`i.\"Institution_ID\" = c.\"Institution_ID\"`). In essence, this cursor identifies institutions that are missing from the `\"Championship\"` table.\n\nA local record variable named `v_rec` is also declared to hold the fetched rows from the cursor.\n\nThe main execution block of the procedure starts by opening the `v_institution_cursor`.\n\nIt then enters a `LOOP` construct. Inside this loop, it attempts to `FETCH` the next row from `v_institution_cursor` into the `v_rec` record variable.\n\nImmediately after the fetch, an `EXIT WHEN NOT FOUND` condition is checked. If no more rows are found by the cursor, the loop terminates.\n\nFor each row successfully fetched into `v_rec`, an `INSERT` statement is executed against the `\"Championship\"` table. The `INSERT` statement attempts to populate the columns `\"Institution_ID\"`, `\"Nickname\"`, `\"Joined\"`, and `\"Number_of_Championships\"`.\n\nThe values for these columns are derived as follows:\n- `\"Institution_ID\"` is set to the value of `v_rec.\"Institution_ID\"`.\n- `\"Nickname\"` is set to the value of the input parameter `p_target_nickname`.\n- `\"Joined\"` is calculated using the `GREATEST` function. It takes the maximum value between `v_rec.\"Founded\"` (the founding year of the institution) and the input parameter `p_base_year`. This ensures that the \"Joined\" date is never earlier than `p_base_year`.\n- `\"Number_of_Championships\"` is calculated by first dividing `v_rec.\"Enrollment\"` by `10000.0` (a floating-point division), then multiplying the result by the input parameter `p_championship_multiplier`, and finally applying the `CEIL` function to round the result up to the nearest whole number.\n\nThe `INSERT` statement includes an `ON CONFLICT (\"Institution_ID\") DO UPDATE SET` clause. This clause specifies that if an attempt to insert a new row into `\"Championship\"` results in a unique constraint violation on the `\"Institution_ID\"` column (meaning a record for that institution already exists), then instead of failing, the existing row should be updated. The update operation sets the `\"Nickname\"`, `\"Joined\"`, and `\"Number_of_Championships\"` columns of the existing row to the values that would have been inserted by the `INSERT` statement (referred to as `EXCLUDED.\"Nickname\"`, `EXCLUDED.\"Joined\"`, and `EXCLUDED.\"Number_of_Championships\"` respectively).\n\nAfter the loop completes (i.e., all relevant institutions have been processed), the `v_institution_cursor` is explicitly `CLOSE`d.",
    "plsql": "CREATE OR REPLACE PROCEDURE populate_championship_gaps(p_target_nickname text, p_base_year real, p_championship_multiplier real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_institution_cursor CURSOR FOR \n        SELECT i.\"Institution_ID\", i.\"Founded\", i.\"Enrollment\"\n        FROM \"institution\" i\n        WHERE NOT EXISTS (\n            SELECT 1 FROM \"Championship\" c \n            WHERE c.\"Institution_ID\" = i.\"Institution_ID\"\n        );\n    v_rec RECORD;\nBEGIN\n    OPEN v_institution_cursor;\n    \n    LOOP\n        FETCH v_institution_cursor INTO v_rec;\n        EXIT WHEN NOT FOUND;\n        \n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        VALUES (\n            v_rec.\"Institution_ID\", \n            p_target_nickname, \n            GREATEST(v_rec.\"Founded\", p_base_year),\n            CEIL(v_rec.\"Enrollment\" / 10000.0 * p_championship_multiplier)\n        )\n        ON CONFLICT (\"Institution_ID\") \n        DO UPDATE SET\n            \"Nickname\" = EXCLUDED.\"Nickname\",\n            \"Joined\" = EXCLUDED.\"Joined\",\n            \"Number_of_Championships\" = EXCLUDED.\"Number_of_Championships\";\n    END LOOP;\n    \n    CLOSE v_institution_cursor;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL populate_championship_gaps('Colonials', 1990.0, 1.5);",
      "CALL populate_championship_gaps('Terrapins', 1985.0, 2.0);",
      "CALL populate_championship_gaps('Wildcats', 2000.0, 1.2);",
      "CALL populate_championship_gaps('Thunderbirds', 1975.0, 1.8);",
      "CALL populate_championship_gaps('Dinos', 1995.0, 2.5);"
    ],
    "summary": "Create a stored procedure named populate_championship_gaps that accepts three parameters: p_target_nickname (text), p_base_year (real), and p_championship_multiplier (real). For each institution not currently in the Championship table, insert a new record. Set the Nickname to the provided target, Joined to the greater of the institution's founded year or the base year, and Number_of_Championships to the ceiling of (Enrollment / 10000.0) multiplied by the multiplier. If a record for the institution already exists, update its Nickname, Joined, and Number_of_Championships with these new values.",
    "natural_language": "Create a stored procedure, which should be named populate_championship_gaps, that is designed to accept three distinct input parameters: a textual parameter called p_target_nickname, a real number parameter named p_base_year, and another real number parameter designated as p_championship_multiplier. This procedure will meticulously process every single academic institution that does not presently have an entry within the Championship table. For each such institution, it will carefully insert a brand new record. Specifically, it will set the Nickname field to the provided target nickname, the Joined date to the later value between the institution's own founded year and the supplied base year, and the Number_of_Championships to the mathematically calculated ceiling value derived from the institution's Enrollment divided by 10000.0 and then subsequently multiplied by the given multiplier. Furthermore, if a record for a particular institution already exists within the table, the procedure will comprehensively update that existing record's Nickname, Joined, and Number_of_Championships fields using these newly computed values.",
    "id": 64
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_lens_focal_ranges` that accepts four input parameters: `p_threshold1` of type `real`, `p_threshold2` of type `real`, `p_brand_pattern` of type `text`, and `p_mountain_limit` of type `integer`. The procedure first declares two local variables: `v_lens_count` of type `integer` and `v_total_photos` of type `integer`. It then executes a `SELECT` statement to calculate two values: the total count of distinct `camera_lens` records that match a specified brand pattern, and the sum of photo counts associated with those lenses. This `SELECT` statement involves a subquery named `lens_stats`. The subquery selects the `id` from the `\"camera_lens\"` table and counts the number of associated photos from the `\"photos\"` table for each lens. It performs a `LEFT JOIN` between `\"camera_lens\"` (aliased as `cl`) and `\"photos\"` (aliased as `p`) on the condition `cl.\"id\" = p.\"camera_lens_id\"`. The subquery filters `camera_lens` records where the `brand` column matches the `p_brand_pattern` using the `LIKE` operator. The results of the subquery are grouped by `cl.\"id\"`. The outer `SELECT` statement then counts the number of rows returned by the `lens_stats` subquery, storing this count into `v_lens_count`. It also calculates the sum of the `photo_count` column from the `lens_stats` subquery, using `COALESCE` to default to `0` if the sum is `NULL`, and stores this sum into `v_total_photos`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block.\n\nIf `v_lens_count` is greater than `p_mountain_limit`, the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `\"photos\"` table where the `mountain_id` column is greater than `p_mountain_limit` AND the `camera_lens_id` is present in a subquery's result set. The subquery selects the `id` from the `\"camera_lens\"` table where the `focal_length_mm` column is less than `p_threshold1`.\n\nOtherwise, if the previous condition is false and `v_total_photos` is less than `100`, the procedure executes an `INSERT` statement. This `INSERT` statement adds up to 5 new records into the `\"photos\"` table, populating the `id`, `camera_lens_id`, `mountain_id`, `color`, and `name` columns. The values for these columns are derived from a `SELECT` statement that retrieves data from the `\"camera_lens\"` table (aliased as `cl`) where `cl.\"focal_length_mm\"` is between `p_threshold1` and `p_threshold2` (inclusive).\n    - For the `id` column, a random integer is generated by `FLOOR(RANDOM() * 1000000)` and cast to `integer`, then `row_number() OVER ()` is added to it, and the final result is cast to `integer`.\n    - For the `camera_lens_id` column, `cl.\"id\"` is used.\n    - For the `mountain_id` column, a subquery is used to select a random `mountain_id` from existing photos. This subquery first selects a `mountain_id` from the `\"photos\"` table where `mountain_id` is not `NULL`, then uses `LIMIT 1` and `OFFSET` with a randomly generated offset. The offset is calculated by `FLOOR(RANDOM() * (SELECT COUNT(*) FROM (SELECT DISTINCT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL) AS valid_mountains))`, ensuring a valid random offset within the distinct non-null `mountain_id` count.\n    - For the `color` column, a `CASE` statement is used: if `cl.\"id\"` is even (i.e., `MOD(cl.\"id\", 2) = 0`), the value is 'RGB'; otherwise, it's 'Black/White'.\n    - For the `name` column, a concatenated string 'Auto-generated ' followed by `cl.\"brand\"` is used.\nThe `SELECT` statement is limited to `5` rows.\n\nOtherwise (if neither of the previous conditions is met), the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `\"photos\"` table where the `id` is present in a subquery's result set. The subquery selects the `id` from the `\"photos\"` table (aliased as `p`) by performing an `INNER JOIN` with the `\"camera_lens\"` table (aliased as `cl`) on the condition `p.\"camera_lens_id\" = cl.\"id\"`. This subquery filters records where `cl.\"focal_length_mm\"` is greater than `p_threshold2` AND `p.\"mountain_id\"` is less than `p_mountain_limit`. The results are ordered by `p.\"id\"` and limited to `10` records.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_lens_focal_ranges(p_threshold1 real, p_threshold2 real, p_brand_pattern text, p_mountain_limit integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lens_count integer;\n    v_total_photos integer;\nBEGIN\n    SELECT COUNT(*), COALESCE(SUM(photo_count), 0)\n    INTO v_lens_count, v_total_photos\n    FROM (\n        SELECT cl.\"id\", COUNT(p.\"id\") as photo_count\n        FROM \"camera_lens\" cl\n        LEFT JOIN \"photos\" p ON cl.\"id\" = p.\"camera_lens_id\"\n        WHERE cl.\"brand\" LIKE p_brand_pattern\n        GROUP BY cl.\"id\"\n    ) lens_stats;\n    \n    IF v_lens_count > p_mountain_limit THEN\n        DELETE FROM \"photos\"\n        WHERE \"mountain_id\" > p_mountain_limit\n        AND \"camera_lens_id\" IN (\n            SELECT \"id\" FROM \"camera_lens\" \n            WHERE \"focal_length_mm\" < p_threshold1\n        );\n    ELSIF v_total_photos < 100 THEN\n        INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n        SELECT \n            (FLOOR(RANDOM() * 1000000)::integer + row_number() OVER ())::integer,\n            cl.\"id\",\n            (SELECT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL LIMIT 1 OFFSET FLOOR(RANDOM() * (SELECT COUNT(*) FROM (SELECT DISTINCT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL) AS valid_mountains))),\n            CASE WHEN MOD(cl.\"id\", 2) = 0 THEN 'RGB' ELSE 'Black/White' END,\n            'Auto-generated ' || cl.\"brand\"\n        FROM \"camera_lens\" cl\n        WHERE cl.\"focal_length_mm\" BETWEEN p_threshold1 AND p_threshold2\n        LIMIT 5;\n    ELSE\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p.\"id\"\n            FROM \"photos\" p\n            INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n            WHERE cl.\"focal_length_mm\" > p_threshold2\n            AND p.\"mountain_id\" < p_mountain_limit\n            ORDER BY p.\"id\"\n            LIMIT 10\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL process_lens_focal_ranges(35.0, 200.0, 'Olympus%', 50);",
      "CALL process_lens_focal_ranges(20.0, 100.0, 'Nikon%', 30);",
      "CALL process_lens_focal_ranges(10.0, 300.0, 'Canon%', 100);",
      "CALL process_lens_focal_ranges(50.0, 150.0, 'Sony%', 25);",
      "CALL process_lens_focal_ranges(24.0, 70.0, 'Sigma%', 75);"
    ],
    "summary": "Create a stored procedure named process_lens_focal_ranges that accepts four parameters: p_threshold1 (real), p_threshold2 (real), p_brand_pattern (text), and p_mountain_limit (integer). Count the distinct lenses matching the brand pattern and sum their associated photo counts. If the lens count exceeds the mountain limit, delete photos where mountain_id is greater than the limit and the lens's focal length is below threshold1. Else, if the total photo count is below 100, insert up to 5 new photo records for lenses with focal lengths between the two thresholds, generating random IDs, random existing mountain_ids, and color based on lens ID parity. Otherwise, delete the first 10 photos where the lens's focal length exceeds threshold2 and the mountain_id is below the mountain limit.",
    "natural_language": "Alright, so we need a stored procedure called process_lens_focal_ranges. It's gotta take four inputs: p_threshold1 (a real number), p_threshold2 (another real number), p_brand_pattern (some text), and p_mountain_limit (an integer). Here's the deal: first, count how many different lenses fit that brand pattern and add up all their photo counts. If that lens count is bigger than the mountain limit, then get rid of any photos where the mountain_id is over the limit and the lens's focal length is less than threshold1. If that's not the case, but the total photo count is under 100, then we need to add up to 5 new photo entries for lenses whose focal lengths are between those two thresholds. For these new ones, just make up random IDs, pick random mountain_ids that already exist, and set the color based on whether the lens ID is even or odd. Otherwise, if none of the above fits, just delete the first 10 photos where the lens's focal length is above threshold2 and the mountain_id is below the mountain limit.",
    "id": 65
  },
  {
    "ir": "Write a PLpgSQL stored procedure named synchronize_lens_photo_data that accepts four parameters: p_aperture_limit of type real, p_mountain_min of type integer, p_brand_select of type text, and p_color_select of type text. The procedure begins by declaring three local variables: v_lens_id of type integer, v_photo_record of type record, and v_counter of type integer initialized to 0. It then enters a loop that iterates over each lens ID from the camera_lens table where the brand matches p_brand_select and the max_aperture is less than or equal to p_aperture_limit. For each lens ID, it counts the number of records in the photos table where the camera_lens_id matches the current lens ID, the mountain_id is greater than or equal to p_mountain_min, and the color matches p_color_select, storing this count in v_counter. If v_counter is zero, it inserts a new record into the photos table with a randomly generated ID based on the lens ID, the current lens ID, a mountain_id calculated as p_mountain_min plus the modulus of the lens ID by 20, the color specified by p_color_select, and a name prefixed with 'Synced ' followed by p_brand_select. If v_counter is greater than 5, it deletes records from the photos table where the camera_lens_id matches the current lens ID, the color matches p_color_select, and the ID is among the lowest mountain_id values, limiting the deletion to v_counter minus 3 records. If v_counter is between 1 and 5, it inserts additional records into the photos table, generating IDs based on the lens ID and row number, setting the camera_lens_id to the current lens ID, calculating mountain_id as p_mountain_min plus the modulus of the lens ID plus row number by 30, setting the color to p_color_select if the modulus of the lens ID by 3 is zero, otherwise setting it to 'RBG', and assigning a name prefixed with 'Additional ' followed by p_brand_select, iterating from 1 to 5 minus v_counter using generate_series.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_lens_photo_data(p_aperture_limit real, p_mountain_min integer, p_brand_select text, p_color_select text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lens_id integer;\n    v_photo_record record;\n    v_counter integer := 0;\nBEGIN\n    FOR v_lens_id IN \n        SELECT \"id\" FROM \"camera_lens\" \n        WHERE \"brand\" = p_brand_select \n        AND \"max_aperture\" <= p_aperture_limit\n    LOOP\n        SELECT COUNT(*) INTO v_counter\n        FROM \"photos\"\n        WHERE \"camera_lens_id\" = v_lens_id\n        AND \"mountain_id\" >= p_mountain_min\n        AND \"color\" = p_color_select;\n        \n        IF v_counter = 0 THEN\n            INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n            VALUES (\n                FLOOR(RANDOM() * 1000000) + v_lens_id,\n                v_lens_id,\n                p_mountain_min + MOD(v_lens_id, 20),\n                p_color_select,\n                'Synced ' || p_brand_select\n            );\n        ELSIF v_counter > 5 THEN\n            DELETE FROM \"photos\"\n            WHERE \"camera_lens_id\" = v_lens_id\n            AND \"color\" = p_color_select\n            AND \"id\" IN (\n                SELECT \"id\" FROM \"photos\"\n                WHERE \"camera_lens_id\" = v_lens_id\n                AND \"color\" = p_color_select\n                ORDER BY \"mountain_id\" ASC\n                LIMIT v_counter - 3\n            );\n        ELSE\n            INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n            SELECT \n                FLOOR(RANDOM() * 1000000) + v_lens_id + row_number() OVER (),\n                v_lens_id,\n                p_mountain_min + MOD(v_lens_id + row_number() OVER (), 30),\n                CASE WHEN MOD(v_lens_id, 3) = 0 THEN p_color_select ELSE 'RBG' END,\n                'Additional ' || p_brand_select\n            FROM generate_series(1, 5 - v_counter);\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL synchronize_lens_photo_data(8.0, 1, 'Olympus', 'RBG');",
      "CALL synchronize_lens_photo_data(1.8, 5, 'Olympus', 'Black/White');",
      "CALL synchronize_lens_photo_data(4.0, 10, 'Olympus', 'Blue');",
      "CALL synchronize_lens_photo_data(2.8, 2, 'Olympus', 'Green');",
      "CALL synchronize_lens_photo_data(16.0, 15, 'Olympus', 'Red');"
    ],
    "summary": "Create a stored procedure named synchronize_lens_photo_data with parameters p_aperture_limit (real), p_mountain_min (integer), p_brand_select (text), and p_color_select (text). For each lens from camera_lens where brand matches p_brand_select and max_aperture <= p_aperture_limit, count matching photos (mountain_id >= p_mountain_min, color matches p_color_select). If count is 0, insert a new photo with a generated ID, the lens ID, a calculated mountain_id (p_mountain_min + lens_id % 20), the specified color, and a name prefixed 'Synced '. If count > 5, delete the oldest (lowest mountain_id) records, keeping only 3. If count is between 1 and 5, insert additional photos (up to 5 total) with generated IDs, the lens ID, a calculated mountain_id (p_mountain_min + (lens_id + row_num) % 30), a color based on lens_id % 3, and a name prefixed 'Additional '.",
    "natural_language": "Write a stored procedure called synchronize_lens_photo_data that takes p_aperture_limit (real), p_mountain_min (integer), p_brand_select (text), and p_color_select (text) as parameters. For each lens in camera_lens where the brand equals p_brand_select and the max_aperture is less than or equal to p_aperture_limit, count the photos that match (mountain_id is at least p_mountain_min and color equals p_color_select). If the count is zero, insert a new photo with a generated ID, the lens ID, a mountain_id calculated as p_mountain_min plus lens_id modulo 20, the specified color, and a name starting with 'Synced '. If the count exceeds 5, delete the oldest records (those with the lowest mountain_id), leaving only 3. If the count is between 1 and 5, insert extra photos to bring the total to 5. For these extra photos, use generated IDs, the lens ID, a mountain_id calculated as p_mountain_min plus (lens_id plus a row number) modulo 30, a color determined by lens_id modulo 3, and a name starting with 'Additional '.",
    "id": 66
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named aggregate_focal_length_metrics that accepts four input parameters: a real number parameter p_focal_group1, a real number parameter p_focal_group2, an integer parameter p_mountain_threshold, and a text parameter p_brand_input. The procedure first calculates the average mountain_id from the photos table for two distinct groups of photos, where the grouping is based on the focal length of the camera lens used. For the first group, it joins the photos table with the camera_lens table on the camera_lens_id foreign key and filters for rows where the camera_lens brand equals p_brand_input and the camera_lens focal_length_mm is less than or equal to p_focal_group1, then computes the average mountain_id for these rows and stores it in a local variable v_group1_avg. For the second group, it performs a similar join and filter operation, but selects rows where the camera_lens focal_length_mm is greater than p_focal_group1 and less than or equal to p_focal_group2, and the brand matches p_brand_input, computing the average mountain_id into a second local variable v_group2_avg. The procedure then computes the absolute difference between these two average values, using COALESCE to treat NULL averages as 0, and stores this result in variable v_total_diff. Next, a conditional block executes one of three possible actions based on the computed values: if v_total_diff is greater than the input parameter p_mountain_threshold, it inserts new rows into the photos table, generating a new id by adding a random integer between 1 and 999,999 to the camera_lens id, using the camera_lens id itself, setting the mountain_id to the integer average of the two group averages (again using COALESCE with a default of 10 for NULLs), setting the color column to the literal string 'Balanced', and setting the name column to the string 'Diff: ' concatenated with the integer floor of v_total_diff, where the source for this insert is a select from the camera_lens table filtered for the specified p_brand_input and where focal_length_mm is between p_focal_group1 and p_focal_group2, ordered by camera_lens id and limited to 4 rows. If the first condition is not met, the procedure checks if the first group's average (or 0 if NULL) is greater than the second group's average (or 0 if NULL); if true, it deletes rows from the photos table where the photo id is in a subquery that selects the id of photos whose mountain_id is greater than v_group1_avg and whose camera_lens_id corresponds to a lens from the camera_lens table with a brand matching p_brand_input and a focal_length_mm less than or equal to p_focal_group1, ordering the subquery by photo id and limiting the result to 2 rows. If neither of the previous conditions is true, the procedure executes an alternative delete operation, removing rows from the photos table where the photo id is in a subquery that selects the id of photos whose mountain_id is less than the COALESCE value of v_group2_avg or p_mountain_threshold if v_group2_avg is NULL, whose camera_lens_id corresponds to a lens with a brand matching p_brand_input and a focal_length_mm greater than p_focal_group2, and whose color column value is either 'RBG' or 'Black/White', ordering the subquery by photo id and limiting the result to 3 rows.",
    "plsql": "CREATE OR REPLACE PROCEDURE aggregate_focal_length_metrics(p_focal_group1 real, p_focal_group2 real, p_mountain_threshold integer, p_brand_input text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_group1_avg real;\n    v_group2_avg real;\n    v_total_diff real;\nBEGIN\n    SELECT AVG(p.\"mountain_id\") INTO v_group1_avg\n    FROM \"photos\" p\n    INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n    WHERE cl.\"focal_length_mm\" <= p_focal_group1\n    AND cl.\"brand\" = p_brand_input;\n    \n    SELECT AVG(p.\"mountain_id\") INTO v_group2_avg\n    FROM \"photos\" p\n    INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n    WHERE cl.\"focal_length_mm\" > p_focal_group1 AND cl.\"focal_length_mm\" <= p_focal_group2\n    AND cl.\"brand\" = p_brand_input;\n    \n    v_total_diff := ABS(COALESCE(v_group1_avg, 0) - COALESCE(v_group2_avg, 0));\n    \n    IF v_total_diff > p_mountain_threshold THEN\n        INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n        SELECT \n            FLOOR(RANDOM() * 1000000) + cl.\"id\",\n            cl.\"id\",\n            FLOOR(COALESCE(v_group1_avg, 10) + COALESCE(v_group2_avg, 10)) / 2,\n            'Balanced',\n            'Diff: ' || FLOOR(v_total_diff)\n        FROM \"camera_lens\" cl\n        WHERE cl.\"brand\" = p_brand_input\n        AND cl.\"focal_length_mm\" BETWEEN p_focal_group1 AND p_focal_group2\n        ORDER BY cl.\"id\" -- Added ORDER BY for deterministic LIMIT\n        LIMIT 4;\n    ELSIF COALESCE(v_group1_avg, 0) > COALESCE(v_group2_avg, 0) THEN\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p_inner.\"id\"\n            FROM \"photos\" p_inner\n            WHERE p_inner.\"mountain_id\" > v_group1_avg\n            AND p_inner.\"camera_lens_id\" IN (\n                SELECT \"id\" FROM \"camera_lens\"\n                WHERE \"focal_length_mm\" <= p_focal_group1\n                AND \"brand\" = p_brand_input\n            )\n            ORDER BY p_inner.\"id\" -- Added ORDER BY for deterministic LIMIT\n            LIMIT 2\n        );\n    ELSE\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p_inner.\"id\"\n            FROM \"photos\" p_inner\n            WHERE p_inner.\"mountain_id\" < COALESCE(v_group2_avg, p_mountain_threshold)\n            AND p_inner.\"camera_lens_id\" IN (\n                SELECT \"id\" FROM \"camera_lens\"\n                WHERE \"focal_length_mm\" > p_focal_group2\n                AND \"brand\" = p_brand_input\n            )\n            AND p_inner.\"color\" IN ('RBG', 'Black/White')\n            ORDER BY p_inner.\"id\" -- Added ORDER BY for deterministic LIMIT\n            LIMIT 3\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL aggregate_focal_length_metrics(35.0, 85.0, 15, 'Olympus');",
      "CALL aggregate_focal_length_metrics(24.0, 70.0, 10, 'Canon');",
      "CALL aggregate_focal_length_metrics(50.0, 135.0, 20, 'Nikon');",
      "CALL aggregate_focal_length_metrics(16.0, 35.0, 5, 'Sony');",
      "CALL aggregate_focal_length_metrics(70.0, 200.0, 25, 'Sigma');"
    ],
    "summary": "Create a stored procedure named aggregate_focal_length_metrics with parameters p_focal_group1 (real), p_focal_group2 (real), p_mountain_threshold (integer), and p_brand_input (text). Calculate the average mountain_id for photos using lenses with brand p_brand_input in two focal length groups: <= p_focal_group1 and between p_focal_group1 and p_focal_group2. Compute the absolute difference between these averages. If the difference > p_mountain_threshold, insert up to 4 new 'Balanced' photos for lenses in the focal range, using the integer average of the group averages for mountain_id. If the first group's average > second group's average, delete up to 2 photos from the first group where mountain_id > its average. Otherwise, delete up to 3 photos from lenses with focal_length > p_focal_group2 where color is 'RBG' or 'Black/White' and mountain_id is less than the second group's average or the threshold.",
    "natural_language": "Please construct a stored procedure entitled 'aggregate_focal_length_metrics'. This procedure shall accept the following parameters: 'p_focal_group1' of type REAL, 'p_focal_group2' of type REAL, 'p_mountain_threshold' of type INTEGER, and 'p_brand_input' of type TEXT. The procedure is to compute the average 'mountain_id' for photographs that utilize lenses from the brand specified by 'p_brand_input', segmented into two focal length categories: those less than or equal to 'p_focal_group1', and those greater than 'p_focal_group1' but less than or equal to 'p_focal_group2'. Subsequently, determine the absolute difference between these two computed averages.\n\nShould this absolute difference exceed the value of 'p_mountain_threshold', insert a maximum of four new photographic records with the designation 'Balanced'. These records are to be associated with lenses within the specified focal range, employing the integer average of the two group averages for the 'mountain_id' value.\n\nAlternatively, if the first group's average exceeds that of the second group, delete up to two photographic records from the first group where the 'mountain_id' is greater than its group average. If the contrary is true, delete up to three photographic records from lenses with a 'focal_length' exceeding 'p_focal_group2', provided the 'color' attribute is either 'RBG' or 'Black/White' and the 'mountain_id' is less than either the second group's average or the provided threshold value.",
    "id": 67
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `migrate_actors_by_duration` that accepts three input parameters: `p_source_musical_id` of type `integer`, representing the unique identifier of the musical from which actors are to be migrated; `p_target_musical_id` of type `integer`, representing the unique identifier of the musical to which actors will be migrated; and `p_duration_pattern` of type `text`, representing a substring pattern to match against the \"Duration\" column of actors. The procedure begins by declaring a local variable `v_migrated_count` of type `integer` to store the number of rows affected by the initial update operation. The first operation performed is an `UPDATE` statement on the `actor` table. This `UPDATE` statement sets the value of the `\"Musical_ID\"` column to the value provided in the `p_target_musical_id` parameter. This update is applied to rows in the `actor` table where two conditions are met: first, the `\"Musical_ID\"` column of the `actor` table must be equal to the value provided in the `p_source_musical_id` parameter; and second, the `\"Duration\"` column of the `actor` table must contain the substring specified by the `p_duration_pattern` parameter. The `LIKE` operator is used for this pattern matching, with the `p_duration_pattern` enclosed by wildcard characters (`%`) to match any sequence of zero or more characters before and after the pattern. Immediately following this `UPDATE` statement, the `GET DIAGNOSTICS` command is used to retrieve the number of rows affected by the preceding `UPDATE` statement, and this count is assigned to the `v_migrated_count` variable. After the update, the procedure executes a `DELETE` statement on the `musical` table. This `DELETE` statement removes rows from the `musical` table where two conditions are met: first, the `\"Musical_ID\"` column of the `musical` table must be equal to the value provided in the `p_source_musical_id` parameter; and second, a subquery using `NOT EXISTS` confirms that there are no remaining rows in the `actor` table where the `\"Musical_ID\"` column is equal to the `p_source_musical_id` parameter. This `NOT EXISTS` condition ensures that a musical is only deleted if all associated actors (those originally linked to `p_source_musical_id`) have either been migrated or were never present.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_actors_by_duration(p_source_musical_id integer, p_target_musical_id integer, p_duration_pattern text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_migrated_count integer;\nBEGIN\n    UPDATE actor \n    SET \"Musical_ID\" = p_target_musical_id \n    WHERE actor.\"Musical_ID\" = p_source_musical_id AND \"Duration\" LIKE '%' || p_duration_pattern || '%';\n    \n    GET DIAGNOSTICS v_migrated_count = ROW_COUNT;\n    \n    DELETE FROM musical \n    WHERE \"Musical_ID\" = p_source_musical_id AND NOT EXISTS (\n        SELECT 1 FROM actor WHERE actor.\"Musical_ID\" = p_source_musical_id\n    );\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL migrate_actors_by_duration(1, 3, '1988');",
      "CALL migrate_actors_by_duration(2, 1, '1992');",
      "CALL migrate_actors_by_duration(1, 2, '1993');",
      "CALL migrate_actors_by_duration(3, 1, 'â€”');",
      "CALL migrate_actors_by_duration(2, 3, '');"
    ],
    "summary": "Create a stored procedure named migrate_actors_by_duration with parameters p_source_musical_id (integer), p_target_musical_id (integer), and p_duration_pattern (text). Update the actor table, changing the Musical_ID to the target ID for all actors linked to the source musical whose Duration contains the specified pattern. Store the number of updated rows. Then, delete the source musical record only if no actors remain linked to it.",
    "natural_language": "Construct a stored procedure designated as 'migrate_actors_by_duration'. This procedure shall accept the following parameters: an integer parameter 'p_source_musical_id', an integer parameter 'p_target_musical_id', and a text parameter 'p_duration_pattern'. The procedure's operations are to update the 'actor' table by setting the 'Musical_ID' to the target identifier for all actors associated with the source musical, contingent upon the actor's 'Duration' field containing the specified pattern. Subsequently, the count of rows modified by this update must be stored. Following this, the procedure must delete the source musical record from its respective table, but only under the condition that no actor records continue to reference it.",
    "id": 68
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `create_character_summary` that accepts three input parameters: `p_character_name` of type `text`, `p_year_threshold` of type `integer`, and `p_result_status` of type `text`. The purpose of this procedure is to analyze character data from the `actor` table and then insert a summary record into the `musical` table.\n\nUpon execution, the procedure first declares three local variables: `v_total_actors` of type `integer`, `v_min_age` of type `integer`, and `v_max_musical_id` of type `integer`.\n\nThe procedure then performs its first operation, which is a `SELECT` statement. This statement queries the `actor` table to calculate two aggregate values: the total count of rows and the minimum value of the `age` column. These calculated values are then assigned to the `v_total_actors` and `v_min_age` variables, respectively. The selection is filtered by a `WHERE` clause that compares the lowercase version of the `Character` column in the `actor` table with the lowercase version of the input parameter `p_character_name`. This ensures a case-insensitive comparison for character names.\n\nNext, the procedure executes a second `SELECT` statement. This statement queries the `musical` table to find the maximum value of the `Musical_ID` column. The `COALESCE` function is used to handle cases where `MAX(\"Musical_ID\")` might return `NULL` (e.g., if the `musical` table is empty), in which case it defaults to `0`. One is then added to this result, and the final value is assigned to the `v_max_musical_id` variable. This effectively generates a new, unique `Musical_ID` for the upcoming insertion.\n\nFinally, the procedure performs an `INSERT` operation into the `musical` table. A new row is inserted with values for the following columns:\n- `Musical_ID`: The value from the `v_max_musical_id` variable.\n- `Name`: A concatenated string formed by 'Character Analysis: ' followed by the value of the `p_character_name` input parameter.\n- `Year`: The value of the `p_year_threshold` input parameter.\n- `Award`: The literal string 'Character Study'.\n- `Category`: The literal string 'Performance Analysis'.\n- `Nominee`: A concatenated string formed by 'Min Age: ' followed by the value of the `v_min_age` variable.\n- `Result`: The value of the `p_result_status` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_character_summary(p_character_name text, p_year_threshold integer, p_result_status text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_actors integer;\n    v_min_age integer;\n    v_max_musical_id integer;\nBEGIN\n    SELECT COUNT(*), MIN(age) INTO v_total_actors, v_min_age \n    FROM actor \n    WHERE LOWER(actor.\"Character\") = LOWER(p_character_name);\n    \n    SELECT COALESCE(MAX(\"Musical_ID\"), 0) + 1 INTO v_max_musical_id FROM musical;\n    \n    INSERT INTO musical (\"Musical_ID\", \"Name\", \"Year\", \"Award\", \"Category\", \"Nominee\", \"Result\")\n    VALUES (v_max_musical_id, 'Character Analysis: ' || p_character_name, p_year_threshold, 'Character Study', 'Performance Analysis', 'Min Age: ' || v_min_age, p_result_status);\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL create_character_summary('Alf Stewart', 2000, 'Analyzed');",
      "CALL create_character_summary('Lou Carpenter', 1995, 'Completed');",
      "CALL create_character_summary('Irene Roberts', 2010, 'Pending');",
      "CALL create_character_summary('Harold Bishop', 1985, 'Nominated');",
      "CALL create_character_summary('Susan Kennedy', 2005, 'Won');"
    ],
    "summary": "Create a stored procedure named create_character_summary with parameters p_character_name (text), p_year_threshold (integer), and p_result_status (text). Count the total actors and find the minimum age for the specified character (case-insensitive). Determine the next available Musical_ID. Insert a summary record into the musical table with the calculated ID, a name prefixed 'Character Analysis: ', the provided year threshold, fixed awards/category, a nominee field showing the minimum age, and the provided result status.",
    "natural_language": "Develop a stored procedure, to be named create_character_summary, which must accept three distinct parameters: a text parameter for the character's name, an integer parameter to serve as a year threshold, and a final text parameter for the result status. This procedure should comprehensively calculate the total number of actors and meticulously identify the very minimum age associated with the specified character, ensuring the character name matching is handled in a case-insensitive manner. Furthermore, it must intelligently determine the next sequentially available Musical_ID. Finally, it is to insert a detailed summary record into the musical table, utilizing the newly calculated ID, a descriptive name that is prefixed with 'Character Analysis: ', the provided year threshold, a fixed and predetermined set of awards and category details, a nominee field that explicitly displays the discovered minimum age, and the result status that was originally supplied.",
    "id": 69
  },
  {
    "ir": "Write a PLpgSQL stored procedure that first deletes rows from the school_details table where the Nickname column has a length of less than 5 characters, then inserts new rows into the school_details table for each school in the school table that does not already have a corresponding entry in the school_details table, using the School_ID from the school table, a Nickname derived by converting the first four characters of the School column to lowercase, and fixed values 'Blue' for Colors, 'DSHA' for League, 'Flight A' for Class, and 'Division 1' for Division.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_school_nicknames()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM school_details\n    WHERE LENGTH(\"Nickname\") < 5;\n    \n    INSERT INTO school_details (\"School_ID\", \"Nickname\", \"Colors\", \"League\", \"Class\", \"Division\")\n    SELECT s.\"School_ID\", LOWER(SUBSTRING(s.\"School\" FROM 1 FOR 4)), 'Blue', 'DSHA', 'Flight A', 'Division 1'\n    FROM school s\n    WHERE s.\"School_ID\" NOT IN (SELECT \"School_ID\" FROM school_details);\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL update_school_nicknames();"
    ],
    "summary": "Create a stored procedure that first deletes from school_details where Nickname length < 5. Then, for each school in the school table without a matching entry in school_details, insert a new row using the School_ID, a Nickname derived from the first four lowercase characters of the School name, and fixed values: 'Blue' for Colors, 'DSHA' for League, 'Flight A' for Class, and 'Division 1' for Division.",
    "natural_language": "Alright, so first, write a stored procedure that kicks out any school_details entries where the Nickname is shorter than 5 characters. After that cleanup, look at all the schools in the school table that don't have a matching record in school_details. For each of those, you gotta add a new row. Use the School_ID, and for the Nickname, just take the first four letters of the School name and make 'em lowercase. For the other fields, just plug in these set values: 'Blue' for Colors, 'DSHA' for League, 'Flight A' for Class, and 'Division 1' for Division.",
    "id": 70
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named archive_old_schools that takes no input parameters and begins by declaring a local integer variable called old_school_count, then executes a SELECT statement to query the school table, counting all rows where the value in the Founded column is less than 1900, and stores the resulting count into the old_school_count variable, after which it evaluates a conditional IF statement checking if old_school_count is greater than zero, and if this condition is true, performs a DELETE operation on the school_performance table where the School_Id column value matches any School_ID value from a subquery that selects the School_ID column from the school table for rows where the Founded column value is less than 1900.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_schools()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    old_school_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO old_school_count\n    FROM school\n    WHERE \"Founded\" < 1900;\n    IF old_school_count > 0 THEN\n        DELETE FROM school_performance\n        WHERE \"School_Id\" IN (SELECT \"School_ID\" FROM school WHERE \"Founded\" < 1900);\n    END IF;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL archive_old_schools();"
    ],
    "summary": "Create a stored procedure named archive_old_schools with no parameters. Count schools founded before 1900. If the count is greater than zero, delete records from the school_performance table for those schools.",
    "natural_language": "Develop a stored procedure, to be named archive_old_schools, which accepts no input parameters. This procedure should first determine the total number of educational institutions that were established prior to the year 1900. Subsequently, if this calculated count is found to be greater than zero, it must proceed to permanently remove all associated records from the school_performance table specifically for those historically old schools.",
    "id": 71
  },
  {
    "ir": "Write a PostgreSQL stored procedure named `normalize_school_colors` that takes no parameters. This procedure performs two distinct data manipulation operations. First, it updates records within the `school` table. Specifically, it sets the value of the `\"School_Colors\"` column to the string literal 'Standard' for all rows where the existing value in the `\"School_Colors\"` column contains the substring 'Blue', irrespective of case, due to the use of the `LIKE` operator with the wildcard character '%'. Second, following this update, the procedure deletes records from the `school_details` table. It removes all rows where the value in the `\"Colors\"` column is explicitly `NULL`.",
    "plsql": "CREATE OR REPLACE PROCEDURE normalize_school_colors()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE school\n    SET \"School_Colors\" = 'Standard'\n    WHERE \"School_Colors\" LIKE '%Blue%';\n    DELETE FROM school_details\n    WHERE \"Colors\" IS NULL;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL normalize_school_colors();"
    ],
    "summary": "Create a stored procedure named normalize_school_colors with no parameters. Update the school table by setting the School_Colors column to 'Standard' for any row where the existing colors contain 'Blue' (case-insensitive). Then, delete all rows from the school_details table where the Colors column is NULL.",
    "natural_language": "Create procedure normalize_school_colors. Set School_Colors to 'Standard' if colors contain 'Blue'. Delete school_details rows with NULL Colors.",
    "id": 72
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named procedure_two that accepts five input parameters: p_threshold of type real, p_factor of type real, p_location_pattern of type text, p_new_contents of type text, and p_min_value of type real. The procedure processes warehouses by first selecting all warehouse codes from the \"Warehouses\" table where the \"Location\" column matches the provided p_location_pattern pattern using a LIKE operator. For each retrieved v_warehouse_code, it calculates the total value of boxes by summing the \"Value\" column from the \"Boxes\" table for all rows where the \"Warehouse\" column equals the current warehouse code, storing the result in v_total_value. If this v_total_value exceeds the p_threshold parameter, it updates all boxes in that warehouse by multiplying their \"Value\" column by the p_factor parameter. Otherwise, if the total value is less than or equal to the threshold, it updates the \"Contents\" column to p_new_contents for boxes in that warehouse where the individual box's \"Value\" is greater than or equal to the p_min_value parameter. Following this conditional update, the procedure deletes from the \"Boxes\" table any rows belonging to the current warehouse where the \"Value\" column is less than the p_min_value parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE procedure_two(p_threshold real, p_factor real, p_location_pattern text, p_new_contents text, p_min_value real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_warehouse_code bigint;\n    v_total_value real;\nBEGIN\n    FOR v_warehouse_code IN SELECT \"Code\" FROM \"Warehouses\" WHERE \"Location\" LIKE p_location_pattern LOOP\n        SELECT SUM(\"Value\") INTO v_total_value FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_code;\n        IF v_total_value > p_threshold THEN\n            UPDATE \"Boxes\" SET \"Value\" = \"Value\" * p_factor WHERE \"Warehouse\" = v_warehouse_code;\n        ELSE\n            UPDATE \"Boxes\" SET \"Contents\" = p_new_contents WHERE \"Warehouse\" = v_warehouse_code AND \"Value\" >= p_min_value;\n        END IF;\n        DELETE FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_code AND \"Value\" < p_min_value;\n    END LOOP;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL procedure_two(200.0, 1.1, '%Chicago%', 'Updated Contents', 150.0);",
      "CALL procedure_two(250.0, 1.2, '%New York%', 'New Contents', 180.0);",
      "CALL procedure_two(300.0, 1.3, '%York%', 'Contents Updated', 170.0);",
      "CALL procedure_two(150.0, 1.05, '%Chic%', 'Changed Contents', 160.0);",
      "CALL procedure_two(100.0, 1.15, '%New%', 'Modified Contents', 140.0);"
    ],
    "summary": "Create a stored procedure named procedure_two with parameters: p_threshold (real), p_factor (real), p_location_pattern (text), p_new_contents (text), p_min_value (real). For each warehouse whose location matches the pattern, calculate the total value of its boxes. If the total exceeds p_threshold, multiply the value of all boxes in that warehouse by p_factor. Otherwise, update the contents to p_new_contents for boxes in that warehouse where the individual box value is >= p_min_value. Finally, delete boxes from that warehouse where the value is < p_min_value.",
    "natural_language": "Develop a stored procedure and name it 'procedure_two', which must accept the following five input parameters: a real number parameter called p_threshold, another real number parameter named p_factor, a text parameter for the location pattern designated as p_location_pattern, a text parameter for new box contents defined as p_new_contents, and a final real number parameter labeled p_min_value. For every single warehouse whose physical location description corresponds to the specified textual pattern, you must first compute the aggregate total monetary value of all boxes currently stored within that facility. Should this calculated total value surpass the provided p_threshold limit, then it is necessary to adjust the value of each and every box in that particular warehouse by multiplying it by the supplied p_factor. Conversely, if the total value does not exceed the threshold, then you need to perform an update operation on the contents field, setting it to the provided p_new_contents, but only for those boxes within the same warehouse whose individual value is greater than or equal to the p_min_value parameter. As a final step in the process, regardless of the earlier conditional branch, you must proceed to delete all boxes from that warehouse where the individual box's value is strictly less than the specified p_min_value.",
    "id": 73
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five parameters: p_prefix (text), p_suffix (text), p_location (text), p_capacity_change (bigint), and p_value_limit (real). The procedure first retrieves the \"Code\" of a warehouse from the \"Warehouses\" table where the \"Location\" matches the provided p_location and stores it in the variable v_warehouse_code. If a warehouse code is found (i.e., v_warehouse_code is not null), it updates the \"Capacity\" of the warehouse by adding the value of p_capacity_change to the current \"Capacity\" where the \"Code\" matches v_warehouse_code. Next, it checks if there exists any box in the \"Boxes\" table associated with this warehouse (i.e., where \"Warehouse\" equals v_warehouse_code) that has a \"Value\" greater than p_value_limit. This existence check result is stored in the boolean variable v_box_exists. If such a box exists (i.e., v_box_exists is true), the procedure initializes a counter v_counter to 1 and enters a loop that iterates three times. During each iteration, it inserts a new row into the \"Boxes\" table with the \"Code\" constructed by concatenating p_prefix, the current value of v_counter formatted as a string without leading spaces, and p_suffix. The \"Contents\" column is set to 'Generated', the \"Value\" is set to p_value_limit multiplied by the current v_counter, and the \"Warehouse\" is set to v_warehouse_code. After each insertion, the counter v_counter is incremented by 1. The loop continues until v_counter exceeds 3, at which point the procedure ends.",
    "plsql": "CREATE OR REPLACE PROCEDURE procedure_four(p_prefix text, p_suffix text, p_location text, p_capacity_change bigint, p_value_limit real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_counter bigint;\n    v_warehouse_code bigint;\n    v_box_exists boolean;\nBEGIN\n    SELECT \"Code\" INTO v_warehouse_code FROM \"Warehouses\" WHERE \"Location\" = p_location;\n    IF v_warehouse_code IS NOT NULL THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + p_capacity_change WHERE \"Code\" = v_warehouse_code;\n        SELECT EXISTS(SELECT 1 FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_code AND \"Value\" > p_value_limit) INTO v_box_exists;\n        IF v_box_exists THEN\n            v_counter := 1;\n            WHILE v_counter <= 3 LOOP\n                INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") \n                VALUES (p_prefix || TO_CHAR(v_counter, 'FM999') || p_suffix, 'Generated', p_value_limit * v_counter, v_warehouse_code);\n                v_counter := v_counter + 1;\n            END LOOP;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL procedure_four('BOX', '_GEN', 'Chicago', 10, 200.0);",
      "CALL procedure_four('GEN', '_A', 'New York', -5, 150.0);",
      "CALL procedure_four('A', 'Z', 'Chicago', 20, 300.0);",
      "CALL procedure_four('TEST', '_END', 'New York', 0, 100.0);",
      "CALL procedure_four('X', 'Y', 'Chicago', 15, 250.0);"
    ],
    "summary": "Create a stored procedure with parameters: p_prefix (text), p_suffix (text), p_location (text), p_capacity_change (bigint), p_value_limit (real). Find a warehouse at the specified location. If found, increase its capacity by p_capacity_change. Then, check if any box in that warehouse has a value > p_value_limit. If such a box exists, insert three new boxes into that warehouse. The box codes should be constructed by concatenating p_prefix, the iteration number (1,2,3), and p_suffix. Set contents to 'Generated' and value to p_value_limit multiplied by the iteration number.",
    "natural_language": "Find a warehouse at the given location. If you find one, increase its capacity by the specified amount. Then, check if any box in that warehouse has a value exceeding the provided limit. If such a box exists, insert three new boxes into that warehouse. Construct the box codes by combining the given prefix, the iteration number (1, 2, or 3), and the given suffix. Set the contents to 'Generated' and set the value to the limit multiplied by the iteration number. Create a stored procedure with parameters for the prefix, suffix, location, capacity change, and value limit to perform these actions.",
    "id": 74
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named procedure_five that accepts five parameters: a text parameter p_code_pattern for matching box codes, a text parameter p_contents_match for matching box contents, a text parameter p_location_start for filtering warehouse locations by a starting prefix, a text parameter p_new_location for specifying the location of newly created warehouses, and a real parameter p_divisor for dividing box values. The procedure begins by validating that the p_divisor parameter is not zero, raising an exception if it is. It then enters a loop that iterates over each record from the Warehouses table where the Location column starts with the string provided in p_location_start, selecting the Code, Location, and Capacity columns for each such warehouse. For each warehouse record fetched, the procedure counts the number of rows in the Boxes table where the Warehouse column equals the current warehouse's Code and the Contents column exactly matches the p_contents_match parameter, storing this count in variable v_total_boxes. If this count is greater than zero, the procedure calculates a new warehouse code by finding the maximum value in the Code column of the Warehouses table, adding one to it, and using zero plus one if the maximum is null, storing the result in variable v_new_code. It then inserts a new row into the Warehouses table using this v_new_code as the Code, the p_new_location parameter as the Location, and the v_total_boxes count as the Capacity. Following this insertion, the procedure performs an insert into the Boxes table, selecting rows from the Boxes table where the Warehouse column equals the current warehouse's Code, the Code column matches the pattern specified in p_code_pattern using the LIKE operator, and the Contents column equals p_contents_match. For each selected box row, it inserts a new box record with a Code formed by concatenating the original box Code with the string '_M', the original Contents, a Value calculated by dividing the original Value by the p_divisor parameter, and the newly created v_new_code as the Warehouse.",
    "plsql": "CREATE OR REPLACE PROCEDURE procedure_five(p_code_pattern text, p_contents_match text, p_location_start text, p_new_location text, p_divisor real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_warehouse_record RECORD;\n    v_new_code bigint;\n    v_total_boxes bigint;\nBEGIN\n    IF p_divisor = 0 THEN\n        RAISE EXCEPTION 'Divisor cannot be zero';\n    END IF;\n    \n    FOR v_warehouse_record IN SELECT \"Code\", \"Location\", \"Capacity\" FROM \"Warehouses\" WHERE \"Location\" LIKE p_location_start || '%' LOOP\n        SELECT COUNT(*) INTO v_total_boxes FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_record.\"Code\" AND \"Contents\" = p_contents_match;\n        IF v_total_boxes > 0 THEN\n            SELECT COALESCE(MAX(\"Code\"),0)+1 INTO v_new_code FROM \"Warehouses\";\n            INSERT INTO \"Warehouses\" (\"Code\", \"Location\", \"Capacity\") VALUES (v_new_code, p_new_location, v_total_boxes);\n            INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\")\n            SELECT \"Code\" || '_M', \"Contents\", \"Value\" / p_divisor, v_new_code\n            FROM \"Boxes\" \n            WHERE \"Warehouse\" = v_warehouse_record.\"Code\" \n              AND \"Code\" LIKE p_code_pattern \n              AND \"Contents\" = p_contents_match;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL procedure_five('0%', 'Rocks', 'Chicago', 'New_Warehouse_A', 2.0);",
      "CALL procedure_five('4%', 'Scissors', 'New York', 'New_Warehouse_B', 1.5);",
      "CALL procedure_five('%', 'Rocks', 'Chicago', 'New_Warehouse_C', 3.0);",
      "CALL procedure_five('0MN7', 'Rocks', 'Chicago', 'New_Warehouse_D', 1.0);",
      "CALL procedure_five('4H8P', 'Scissors', 'New York', 'New_Warehouse_E', 2.5);"
    ],
    "summary": "Create a stored procedure named procedure_five with parameters: p_code_pattern (text), p_contents_match (text), p_location_start (text), p_new_location (text), p_divisor (real). Validate that p_divisor is not zero. For each warehouse whose location starts with p_location_start, count its boxes that have contents matching p_contents_match. If the count > 0, create a new warehouse at p_new_location with a capacity equal to that count. Then, for each box in the original warehouse that matches the p_code_pattern and p_contents_match, insert a copy into the new warehouse. The new box code should append '_M' to the original, and its value should be the original value divided by p_divisor.",
    "natural_language": "Hey, so I need you to whip up a stored procedure called 'procedure_five'. It's gotta take a few inputs: p_code_pattern (that's text), p_contents_match (also text), p_location_start (text again), p_new_location (text), and p_divisor (a real number). First things first, make sure p_divisor isn't zero, 'cause we can't be dividing by that. Here's the plan: for every warehouse where the location kicks off with p_location_start, count up how many boxes it has where the contents line up with p_contents_match. If that count is more than zero, we'll set up a brand new warehouse at p_new_location. Its capacity should just be that box count we just got. Then, for each box in the original warehouse that matches both the p_code_pattern and the p_contents_match, we're gonna make a copy and plop it into the new warehouse. For the new box's code, just slap '_M' onto the end of the original code. And for its value, take the original box's value and divide it by p_divisor.",
    "id": 75
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_country_name of type text, p_new_status of type text, and p_population_threshold of type integer. The procedure first declares a local variable v_country_id of type integer. It then performs a SELECT query on the country table to retrieve the Country_ID where the Name column matches the value of p_country_name, storing the result in the v_country_id variable. If v_country_id is not NULL, indicating that a matching country was found, the procedure proceeds to update the roller_coaster table. It sets the Status column to the value of p_new_status for all rows where the Country_ID matches v_country_id and where there exists at least one row in the country table with the same Country_ID and a Population greater than p_population_threshold.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_coaster_status_by_population(p_country_name text, p_new_status text, p_population_threshold integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_country_id integer;\nBEGIN\n    SELECT \"Country_ID\" INTO v_country_id FROM country WHERE \"Name\" = p_country_name;\n    \n    IF v_country_id IS NOT NULL THEN\n        UPDATE roller_coaster\n        SET \"Status\" = p_new_status\n        WHERE \"Country_ID\" = v_country_id\n        AND EXISTS (\n            SELECT 1 FROM country c \n            WHERE c.\"Country_ID\" = roller_coaster.\"Country_ID\" \n            AND c.\"Population\" > p_population_threshold\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "CALL update_coaster_status_by_population('Austria', 'Closed for Maintenance', 8000000);",
      "CALL update_coaster_status_by_population('Finland', 'Under Renovation', 5000000);",
      "CALL update_coaster_status_by_population('Sweden', 'Operating', 9000000);",
      "CALL update_coaster_status_by_population('Austria', 'Operating', 9000000);",
      "CALL update_coaster_status_by_population('Finland', 'Closed', 6000000);"
    ],
    "summary": "Create a stored procedure that updates roller coaster statuses for a specified country. It finds the country's ID, then updates the status for all roller coasters in that country, but only if the country's population exceeds a given threshold.",
    "natural_language": "Make a stored procedure that adjusts the status for roller coasters in a certain country. It should look up the country's identifier and then update the status for all coasters there, but only do this if the country has a pretty large population.",
    "id": 76
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `proc_transform_student_data` that accepts two input parameters: `p_base_classroom` of type `bigint` representing a classroom identifier, and `p_name_filter` of type `text` representing a text string used for filtering student names.\n\nThe procedure begins by declaring several local variables: `v_student_count` of type `integer` to store the count of students, `v_teacher_exists` of type `boolean` to indicate the existence of a teacher, `v_name_length` of type `integer` to store the length of a student's last name, `v_loop_index` of type `integer` initialized to 1 for loop control, `v_target_classroom` of type `bigint` to store a target classroom identifier, `v_temp_lastname` of type `text` to temporarily hold a student's last name, and `v_temp_firstname` of type `text` to temporarily hold a student's first name.\n\nFirst, the procedure queries the `list` table to count the number of students whose `LastName` column contains the `p_name_filter` string (case-insensitive due to `LIKE` operator behavior with default collation) and stores this count in `v_student_count`. The condition for this count is `WHERE \"LastName\" LIKE '%' || p_name_filter || '%'`.\n\nNext, it checks for the existence of a teacher in the `teachers` table where the `Classroom` column matches the `p_base_classroom` parameter. The result (true or false) is stored in the `v_teacher_exists` boolean variable.\n\nThe procedure then proceeds with a series of conditional operations based on the value of `v_student_count`:\n\n1.  **If `v_student_count` is 0:**\n    The procedure inserts new records into the `list` table. It selects `LastName` and `FirstName` from the `teachers` table where the `Classroom` column matches `p_base_classroom`. For these new records, the `Grade` column is set to 1, and the `Classroom` column is set to `p_base_classroom`. This insertion only occurs if no records already exist in the `list` table for the `p_base_classroom`, as checked by the `NOT EXISTS (SELECT 1 FROM list WHERE \"Classroom\" = p_base_classroom)` subquery.\n\n2.  **Else if `v_student_count` is 1:**\n    The procedure updates the `list` table. For the single student whose `LastName` matches the `p_name_filter` (using `LIKE '%' || p_name_filter || '%'`), their `Grade` column is updated to be its current value multiplied by 2.\n\n3.  **Else if `v_student_count` is between 2 and 5 (inclusive):**\n    The procedure enters a `WHILE` loop that iterates `v_student_count` times, controlled by `v_loop_index`.\n    Inside the loop:\n    *   It selects the `LastName` of a student from the `list` table whose `LastName` matches `p_name_filter`. The selection is ordered by `LastName` and limited to one record, with an offset determined by `v_loop_index - 1`, effectively processing one matching student per iteration. The selected `LastName` is stored in `v_temp_lastname`.\n    *   The length of `v_temp_lastname` is calculated using the `LENGTH()` function and stored in `v_name_length`.\n    *   Another conditional block is executed based on `v_name_length`:\n        *   **If `v_name_length` is greater than 5:** The `LastName` of the student identified by `v_temp_lastname` is updated in the `list` table. The new `LastName` is formed by taking the first 3 characters of the original `LastName` using `SUBSTR(\"LastName\", 1, 3)` and concatenating it with the string 'TR'.\n        *   **Else if `v_name_length` is between 3 and 5 (inclusive):** The `LastName` of the student identified by `v_temp_lastname` is updated in the `list` table to its uppercase version using the `UPPER()` function.\n        *   **Else (if `v_name_length` is less than 3):** The record for the student identified by `v_temp_lastname` is deleted from the `list` table.\n    *   The `v_loop_index` is incremented by 1 for the next iteration.\n\n4.  **Else if `v_student_count` is greater than 5:**\n    The procedure attempts to find a `Classroom` in the `teachers` table that is greater than `p_base_classroom`. It orders the results by `Classroom` in ascending order and selects the first one, storing it in `v_target_classroom`.\n    *   If a `v_target_classroom` is found (checked by `IF FOUND THEN`), the procedure updates the `list` table. For students whose `LastName` matches `p_name_filter` and whose `Grade` is greater than the average `Grade` of all students in the `list` table (calculated by `(SELECT AVG(\"Grade\") FROM list)`), their `Classroom` is updated to `v_target_classroom`.\n\n5.  **Else (if none of the above conditions for `v_student_count` are met, which implies `v_student_count` is negative or null, though `COUNT(*)` typically returns non-negative):**\n    The procedure inserts new records into the `teachers` table. It selects distinct `LastName` (truncated to the first 4 characters using `SUBSTR(\"LastName\", 1, 4)`) and a fixed `FirstName` of 'ASSIGNED' from the `list` table where `LastName` matches `p_name_filter`. The `Classroom` for these new teachers is set to `p_base_classroom + 100`. This insertion only occurs if no teacher already exists in the `teachers` table for the classroom `p_base_classroom + 100`, as checked by the `NOT EXISTS (SELECT 1 FROM teachers WHERE \"Classroom\" = p_base_classroom + 100)` subquery.\n\nFinally, after the conditional block based on `v_student_count`, the procedure checks the `v_teacher_exists` variable.\n*   **If `v_teacher_exists` is true:**\n    The procedure deletes records from the `list` table where the `Classroom` column matches `p_base_classroom` and the `Grade` column is less than 3.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_transform_student_data(p_base_classroom bigint, p_name_filter text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_count integer;\n    v_teacher_exists boolean;\n    v_name_length integer;\n    v_loop_index integer := 1;\n    v_target_classroom bigint;\n    v_temp_lastname text;\n    v_temp_firstname text;\nBEGIN\n    SELECT COUNT(*) INTO v_student_count FROM list \n    WHERE \"LastName\" LIKE '%' || p_name_filter || '%';\n    \n    SELECT EXISTS(SELECT 1 FROM teachers WHERE \"Classroom\" = p_base_classroom) \n    INTO v_teacher_exists;\n    \n    IF v_student_count = 0 THEN\n        INSERT INTO list (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\")\n        SELECT \"LastName\", \"FirstName\", 1, p_base_classroom\n        FROM teachers WHERE \"Classroom\" = p_base_classroom\n        AND NOT EXISTS (\n            SELECT 1 FROM list WHERE \"Classroom\" = p_base_classroom\n        );\n    ELSIF v_student_count = 1 THEN\n        UPDATE list SET \"Grade\" = \"Grade\" * 2\n        WHERE \"LastName\" LIKE '%' || p_name_filter || '%';\n    ELSIF v_student_count BETWEEN 2 AND 5 THEN\n        WHILE v_loop_index <= v_student_count LOOP\n            SELECT \"LastName\" INTO v_temp_lastname FROM list \n            WHERE \"LastName\" LIKE '%' || p_name_filter || '%'\n            ORDER BY \"LastName\" LIMIT 1 OFFSET v_loop_index - 1;\n            \n            v_name_length := LENGTH(v_temp_lastname);\n            \n            IF v_name_length > 5 THEN\n                UPDATE list SET \"LastName\" = SUBSTR(\"LastName\", 1, 3) || 'TR'\n                WHERE \"LastName\" = v_temp_lastname;\n            ELSIF v_name_length BETWEEN 3 AND 5 THEN\n                UPDATE list SET \"LastName\" = UPPER(\"LastName\")\n                WHERE \"LastName\" = v_temp_lastname;\n            ELSE\n                DELETE FROM list WHERE \"LastName\" = v_temp_lastname;\n            END IF;\n            \n            v_loop_index := v_loop_index + 1;\n        END LOOP;\n    ELSIF v_student_count > 5 THEN\n        SELECT \"Classroom\" INTO v_target_classroom FROM teachers \n        WHERE \"Classroom\" > p_base_classroom ORDER BY \"Classroom\" LIMIT 1;\n        \n        IF FOUND THEN\n            UPDATE list SET \"Classroom\" = v_target_classroom\n            WHERE \"LastName\" LIKE '%' || p_name_filter || '%'\n            AND \"Grade\" > (SELECT AVG(\"Grade\") FROM list);\n        END IF;\n    ELSE\n        INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\")\n        SELECT DISTINCT SUBSTR(\"LastName\", 1, 4), 'ASSIGNED', p_base_classroom + 100\n        FROM list WHERE \"LastName\" LIKE '%' || p_name_filter || '%'\n        AND NOT EXISTS (\n            SELECT 1 FROM teachers WHERE \"Classroom\" = p_base_classroom + 100\n        );\n    END IF;\n    \n    IF v_teacher_exists THEN\n        DELETE FROM list WHERE \"Classroom\" = p_base_classroom AND \"Grade\" < 3;\n    END IF;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "CALL proc_transform_student_data(101, 'CAR');",
      "CALL proc_transform_student_data(102, 'KRISTENSEN');",
      "CALL proc_transform_student_data(103, 'VANDERWOUDE');",
      "CALL proc_transform_student_data(104, 'MAUDE');",
      "CALL proc_transform_student_data(105, 'STORMY');"
    ],
    "summary": "Create a stored procedure named `proc_transform_student_data` that processes student data based on a name filter and base classroom. It counts matching students and checks for a teacher. Based on the count, it performs different operations: inserts new students if count is zero; doubles a single student's grade; processes multiple students (2-5) by modifying or deleting their records based on name length; moves high-performing students to a new classroom if count exceeds five; or inserts new teachers for other cases. Finally, if a teacher existed initially, it deletes low-grade students from the base classroom.",
    "natural_language": "Develop a comprehensive stored procedure, to be designated as `proc_transform_student_data`, which meticulously handles the transformation of student records. This procedure operates by first accepting a specific name filter and a foundational classroom identifier. It proceeds to calculate the total number of students whose details correspond to the provided filter. Concurrently, it verifies the existence of an associated teacher record. Depending on the precise count of matching students uncovered, the procedure then executes distinct, detailed operations: if the count is precisely zero, it orchestrates the insertion of entirely new student entries; for a solitary matching student, it systematically doubles that individual's academic grade; when encountering a modest cohort of between two and five students, it engages in a nuanced process of either modifying or entirely purging their records, a decision contingent upon the length of each student's name; in scenarios where the student count surpasses five, it relocates all high-achieving students to a newly assigned classroom; for all other resultant counts, it facilitates the insertion of new teacher records. To conclude its intricate workflow, if a teacher was confirmed to be present at the procedure's inception, it performs a final cleansing action by deleting all students with subpar grades from the original base classroom.",
    "id": 77
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Boxes\" table based on specific criteria provided through its parameters. The procedure is named delete_boxes_by_criteria and accepts three parameters: p_warehouse_code of type bigint, p_min_value of type real, and p_contents_filter of type text. The procedure performs a DELETE operation on the \"Boxes\" table, targeting rows where the \"Warehouse\" column matches the value of p_warehouse_code, the \"Value\" column is greater than or equal to p_min_value, and the \"Contents\" column, when converted to lowercase using the LOWER() function, matches the lowercase version of p_contents_filter. The LOWER() function is used to ensure case-insensitive comparison of the \"Contents\" column with the p_contents_filter parameter. The procedure does not include any conditional branching or iteration, and its sole operation is the deletion of rows that meet all specified conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_boxes_by_criteria(p_warehouse_code bigint, p_min_value real, p_contents_filter text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\" \n    WHERE \"Warehouse\" = p_warehouse_code \n    AND \"Value\" >= p_min_value \n    AND LOWER(\"Contents\") = LOWER(p_contents_filter);\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL delete_boxes_by_criteria(1, 200.0, 'Rocks');",
      "CALL delete_boxes_by_criteria(3, 180.0, 'Scissors');",
      "CALL delete_boxes_by_criteria(4, 190.0, 'Rocks');",
      "CALL delete_boxes_by_criteria(1, 250.0, 'Scissors');",
      "CALL delete_boxes_by_criteria(3, 180.0, 'Rocks');"
    ],
    "summary": "Create a stored procedure named `delete_boxes_by_criteria` that deletes boxes from a specified warehouse where the box value meets a minimum and its contents match a given filter (case-insensitive).",
    "natural_language": "Write a stored procedure called `delete_boxes_by_criteria` to remove boxes from a given warehouse if the box value is at least a specified minimum and its contents match a provided filter, ignoring case.",
    "id": 78
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `insert_new_warehouse` that accepts three input parameters: `p_code` of type `bigint`, intended to represent a unique identifier for the warehouse; `p_location` of type `text`, intended to represent the geographical location of the warehouse; and `p_capacity` of type `bigint`, intended to represent the storage capacity of the warehouse. The procedure's sole operation is to perform an `INSERT` statement into the table named `\"Warehouses\"`. This `INSERT` statement populates three specific columns within the `\"Warehouses\"` table: the `\"Code\"` column is assigned the value provided by the `p_code` parameter, the `\"Location\"` column is assigned the value provided by the `p_location` parameter, and the `\"Capacity\"` column is assigned the value provided by the `p_capacity` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_warehouse(p_code bigint, p_location text, p_capacity bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Warehouses\" (\"Code\", \"Location\", \"Capacity\")\n    VALUES (p_code, p_location, p_capacity);\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL insert_new_warehouse(4, 'Los Angeles', 5);",
      "CALL insert_new_warehouse(5, 'San Francisco', 6);",
      "CALL insert_new_warehouse(6, 'Houston', 8);",
      "CALL insert_new_warehouse(7, 'Miami', 10);",
      "CALL insert_new_warehouse(8, 'Seattle', 9);"
    ],
    "summary": "Create a stored procedure named `insert_new_warehouse` that inserts a new warehouse record using provided code, location, and capacity values.",
    "natural_language": "Write a stored procedure called `insert_new_warehouse` to insert a new warehouse record with the given code, location, and capacity.",
    "id": 79
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_warehouse_code of type bigint, p_min_box_value of type real, and p_contents_type of type text. The procedure first deletes rows from the \"Boxes\" table where the \"Warehouse\" column matches the value of p_warehouse_code, the \"Value\" column is less than p_min_box_value, and the \"Contents\" column equals p_contents_type. After executing this deletion, the procedure proceeds to delete rows from the \"Warehouses\" table where the \"Code\" column matches the value of p_warehouse_code.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_warehouse_and_boxes(p_warehouse_code bigint, p_min_box_value real, p_contents_type text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\" \n    WHERE \"Warehouse\" = p_warehouse_code \n    AND \"Value\" < p_min_box_value \n    AND \"Contents\" = p_contents_type;\n    \n    DELETE FROM \"Warehouses\" \n    WHERE \"Code\" = p_warehouse_code;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL remove_warehouse_and_boxes(1, 200.0, 'Rocks');",
      "CALL remove_warehouse_and_boxes(3, 150.0, 'Scissors');",
      "CALL remove_warehouse_and_boxes(2, 100.0, 'Rocks');",
      "CALL remove_warehouse_and_boxes(4, 300.0, 'Scissors');",
      "CALL remove_warehouse_and_boxes(1, 50.0, 'Papers');"
    ],
    "summary": "Create a stored procedure that first deletes boxes from a specified warehouse where the value is below a minimum and the contents match a specific type. Then, it deletes the warehouse record itself.",
    "natural_language": "Compose a stored procedure to perform the following operations in sequence: first, delete all boxes from a designated warehouse where the recorded value is less than a specified minimum threshold and the contents correspond to a particular type; subsequently, delete the record for the warehouse itself.",
    "id": 80
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_institution_championships that accepts a single mandatory input parameter named institution_id of type INTEGER, which is used to identify a specific institution, and performs a DELETE operation on the database table named \"Championship\", specifically targeting and removing all rows from that table where the value in the column named \"Institution_ID\" is exactly equal to the integer value provided for the institution_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_institution_championships(institution_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Championship\"\n    WHERE \"Institution_ID\" = institution_id;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL delete_institution_championships(1);",
      "CALL delete_institution_championships(2);",
      "CALL delete_institution_championships(3);"
    ],
    "summary": "Create a stored procedure named delete_institution_championships that deletes all rows from the Championship table where the Institution_ID column matches the provided integer institution_id parameter.",
    "natural_language": "Create a stored procedure to get rid of a bunch of championship records for an institution. It should remove entries from the Championship table when the institution ID is kind of like the one you give it.",
    "id": 81
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named update_institution_enrollment that accepts a single mandatory input parameter called institution_id of type INTEGER, which is used to identify a specific institution record, and executes an UPDATE operation on the table named institution, specifically modifying the column \"Enrollment\" by increasing its existing numeric value by exactly 1000 for the single row where the value in the column \"Institution_ID\" is equal to the provided institution_id parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_institution_enrollment(institution_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE institution\n    SET \"Enrollment\" = \"Enrollment\" + 1000\n    WHERE \"Institution_ID\" = institution_id;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL update_institution_enrollment(1);",
      "CALL update_institution_enrollment(2);",
      "CALL update_institution_enrollment(3);"
    ],
    "summary": "Create a stored procedure named update_institution_enrollment that increases the Enrollment column by 1000 in the institution table for the row where Institution_ID matches the provided integer institution_id parameter.",
    "natural_language": "How can I create a stored procedure called update_institution_enrollment that will add 1000 to the Enrollment column in the institution table for the specific row whose Institution_ID equals the given integer parameter institution_id?",
    "id": 82
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named insert_new_school that accepts two mandatory input parameters: a TEXT parameter called school_name to hold the name of the new school and a TEXT parameter called school_location to hold the location of the new school, then declares a local INTEGER variable named new_school_id, then executes a SELECT query on the school table to calculate a new identifier by taking the maximum existing value from the School_ID column, using the COALESCE function to substitute a value of 0 if the maximum is NULL, and adding 1 to that result, storing the computed value into the new_school_id variable, and finally performs an INSERT operation into the school table, specifying values for the columns School_ID (using the new_school_id variable), School (using the school_name input parameter), Location (using the school_location input parameter), Enrollment (using a hard-coded numeric literal 500.0), and Founded (using the EXTRACT function to obtain the current year component from the result of the CURRENT_DATE function).",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_school(IN school_name TEXT, IN school_location TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    new_school_id INTEGER;\nBEGIN\n    SELECT COALESCE(MAX(\"School_ID\"), 0) + 1 INTO new_school_id FROM school;\n    \n    INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\")\n    VALUES (new_school_id, school_name, school_location, 500.0, EXTRACT(YEAR FROM CURRENT_DATE));\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL insert_new_school('Newtown High School', 'Newtown');",
      "CALL insert_new_school('Springfield Elementary', 'Springfield');",
      "CALL insert_new_school('Oceanview Academy', 'Coastal City');",
      "CALL insert_new_school('Mountain Peak College', 'Mountain Valley');",
      "CALL insert_new_school('Riverside School', 'Rivertown');"
    ],
    "summary": "Create a stored procedure named insert_new_school that inserts a new school. It generates a new School_ID by taking the maximum existing ID plus one (defaulting to 1 if none exist), uses the provided school_name and school_location parameters for the School and Location columns, sets Enrollment to 500.0, and sets Founded to the current year.",
    "natural_language": "Create procedure insert_new_school to add a school. Use max ID + 1 (or 1) for School_ID, provided name and location, set Enrollment to 500.0, Founded to current year.",
    "id": 83
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_old_players` that accepts two input parameters: `cutoff_age`, which is an `INTEGER` representing the age threshold, and `target_school_id`, which is also an `INTEGER` representing the identifier of a specific school. The procedure's sole operation is to perform a `DELETE` statement on the `player` table. This `DELETE` operation targets and removes all rows from the `player` table where two conditions are simultaneously met: first, the value in the `\"Age\"` column is strictly greater than the value provided by the `cutoff_age` parameter, and second, the value in the `\"School_ID\"` column is exactly equal to the value provided by the `target_school_id` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_players(IN cutoff_age INTEGER, IN target_school_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM player \n    WHERE \"Age\" > cutoff_age AND \"School_ID\" = target_school_id;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL delete_old_players(15, 1);",
      "CALL delete_old_players(14, 2);",
      "CALL delete_old_players(16, 1);",
      "CALL delete_old_players(13, 2);",
      "CALL delete_old_players(17, 1);"
    ],
    "summary": "Create a stored procedure named delete_old_players that deletes all rows from the player table where the Age column is greater than the provided cutoff_age parameter and the School_ID column equals the provided target_school_id parameter.",
    "natural_language": "Make a stored procedure called delete_old_players that removes players who are kind of older than a certain age you provide and who are from a specific school you also specify.",
    "id": 84
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named transfer_players_by_position that accepts two input parameters: an integer parameter named source_school_id and a text parameter named target_position. The procedure first declares a local integer variable named destination_school_id. It begins execution by performing a SELECT query on the school table, aliased as s, to retrieve a single school ID. The query selects the School_ID column, filtering out any row where the School_ID equals the provided source_school_id, then orders the remaining results by the Enrollment column in descending order, and finally uses LIMIT 1 to select only the top result, storing this value into the destination_school_id variable. Following this, the procedure performs an INSERT operation into the player table, specifying the columns Player_ID, Player, Team, Age, Position, and School_ID. The data to insert is sourced from a SELECT statement that queries the player table, aliased as p. This SELECT statement includes a scalar subquery to generate new Player_ID values: it calculates the maximum existing value from the Player_ID column in the player table using the MAX function, applies the COALESCE function to return 0 if the maximum is NULL, then adds to this result the row number generated by the ROW_NUMBER() window function, which numbers rows in the order of the source player's Player_ID. For the Player column, it concatenates the original value from p.Player with the literal string ' (Transferred)' using the concatenation operator (||). It directly selects the Team, Age, and Position columns from the source player row p. For the School_ID column, it uses the destination_school_id value retrieved earlier. The rows selected for this insertion are filtered by a WHERE clause that requires the player's School_ID (p.School_ID) to equal the input source_school_id and the player's Position (p.Position) to equal the input target_position.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_players_by_position(IN source_school_id INTEGER, IN target_position TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    destination_school_id INTEGER;\nBEGIN\n    SELECT s.\"School_ID\" INTO destination_school_id \n    FROM school s\n    WHERE s.\"School_ID\" != source_school_id \n    ORDER BY s.\"Enrollment\" DESC \n    LIMIT 1;\n    \n    INSERT INTO player (\"Player_ID\", \"Player\", \"Team\", \"Age\", \"Position\", \"School_ID\")\n    SELECT \n        (SELECT COALESCE(MAX(\"Player_ID\"), 0) FROM player) + ROW_NUMBER() OVER (ORDER BY p.\"Player_ID\"),\n        p.\"Player\" || ' (Transferred)',\n        p.\"Team\",\n        p.\"Age\",\n        p.\"Position\",\n        destination_school_id\n    FROM player p\n    WHERE p.\"School_ID\" = source_school_id AND p.\"Position\" = target_position;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL transfer_players_by_position(1, 'Shortstop');",
      "CALL transfer_players_by_position(2, 'Third baseman');",
      "CALL transfer_players_by_position(1, 'First Baseman');",
      "CALL transfer_players_by_position(3, 'Pitcher');",
      "CALL transfer_players_by_position(2, 'Catcher');"
    ],
    "summary": "Create a stored procedure named transfer_players_by_position that transfers players from a source school to the school with the highest enrollment (excluding the source). It finds the destination school ID, then inserts new records into the player table for all players from the source school who match a specified target_position. New Player_IDs are generated, the player's name is appended with ' (Transferred)', and the School_ID is updated to the destination school.",
    "natural_language": "Write a stored procedure called transfer_players_by_position to move players from a source school to the school that has the highest enrollment, not counting the source school. First, determine the destination school ID. Then, for every player from the source school who plays a specified target position, insert a new record into the player table. Generate new Player_IDs, add ' (Transferred)' to the player's name, and set the School_ID to the destination school.",
    "id": 85
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_company_stats that accepts three input parameters: an integer p_year, an integer p_min_rank, and a real number p_max_assets. The procedure first calculates two statistics: it computes the average Sales_billion from the company table for companies whose Rank is between the parameter p_min_rank and 10 inclusive and whose Assets_billion is less than or equal to p_max_assets, storing the result in a local variable v_avg_sales; it also calculates the total count of distinct Station_ID values from the station_company table, joined with the gas_station table on Station_ID, for gas stations opened in the specified p_year and where the associated Company_ID belongs to a company with a Rank less than or equal to p_min_rank, storing this count in a local variable v_total_stations. Based on these computed values, the procedure executes one of three conditional branches: if v_avg_sales is greater than 300, it deletes rows from the station_company table where the Rank_of_the_Year column is greater than 5 and the Company_ID belongs to any company in the company table with a Sales_billion value less than the calculated v_avg_sales; else, if v_total_stations is greater than 10, it inserts up to three new rows into the station_company table, specifically into the Station_ID, Company_ID, and Rank_of_the_Year columns, by performing a cross join between the gas_station table (filtered for stations opened in p_year) and the company table (filtered for companies with a Rank equal to p_min_rank), generating a random integer between 1 and 5 (inclusive) using the expression FLOOR(RANDOM() * 5 + 1) for the Rank_of_the_Year, and only for station-company pairs that do not already exist in the station_company table, as enforced by a NOT EXISTS subquery; otherwise, if neither previous condition is met, it deletes rows from the station_company table where the Company_ID belongs to any company in the company table with an Assets_billion value greater than the input parameter p_max_assets.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_company_stats(p_year INTEGER, p_min_rank INTEGER, p_max_assets REAL)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_sales REAL;\n    v_total_stations INTEGER;\nBEGIN\n    SELECT AVG(\"Sales_billion\") INTO v_avg_sales\n    FROM company\n    WHERE \"Rank\" BETWEEN p_min_rank AND 10\n    AND \"Assets_billion\" <= p_max_assets;\n    \n    SELECT COUNT(DISTINCT sc.\"Station_ID\") INTO v_total_stations\n    FROM station_company sc\n    JOIN gas_station gs ON sc.\"Station_ID\" = gs.\"Station_ID\"\n    WHERE gs.\"Open_Year\" = p_year\n    AND sc.\"Company_ID\" IN (SELECT \"Company_ID\" FROM company WHERE \"Rank\" <= p_min_rank);\n    \n    IF v_avg_sales > 300 THEN\n        DELETE FROM station_company\n        WHERE \"Rank_of_the_Year\" > 5\n        AND \"Company_ID\" IN (SELECT \"Company_ID\" FROM company WHERE \"Sales_billion\" < v_avg_sales);\n    ELSIF v_total_stations > 10 THEN\n        INSERT INTO station_company (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\n        SELECT gs.\"Station_ID\", c.\"Company_ID\", FLOOR(RANDOM() * 5 + 1)\n        FROM gas_station gs\n        CROSS JOIN company c\n        WHERE gs.\"Open_Year\" = p_year\n        AND c.\"Rank\" = p_min_rank\n        AND NOT EXISTS (\n            SELECT 1 FROM station_company sc \n            WHERE sc.\"Station_ID\" = gs.\"Station_ID\" \n            AND sc.\"Company_ID\" = c.\"Company_ID\"\n        )\n        LIMIT 3;\n    ELSE\n        DELETE FROM station_company\n        WHERE \"Company_ID\" IN (\n            SELECT \"Company_ID\" FROM company \n            WHERE \"Assets_billion\" > p_max_assets\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "CALL calculate_company_stats(2020, 5, 500.0);",
      "CALL calculate_company_stats(2019, 3, 1000.0);",
      "CALL calculate_company_stats(2021, 8, 300.0);",
      "CALL calculate_company_stats(2018, 1, 200.0);",
      "CALL calculate_company_stats(2022, 6, 750.0);"
    ],
    "summary": "Create a stored procedure named calculate_company_stats with parameters p_year (INTEGER), p_min_rank (INTEGER), and p_max_assets (REAL). Calculate the average Sales_billion for companies with Rank between p_min_rank and 10 and Assets_billion <= p_max_assets, storing it in v_avg_sales. Count distinct Station_ID from station_company joined with gas_station for stations opened in p_year where the associated Company_ID belongs to a company with Rank <= p_min_rank, storing it in v_total_stations. If v_avg_sales > 300, delete from station_company where Rank_of_the_Year > 5 and Company_ID belongs to a company with Sales_billion < v_avg_sales. Else if v_total_stations > 10, insert up to three new rows into station_company (Station_ID, Company_ID, Rank_of_the_Year) from a cross join of gas_station (opened in p_year) and company (Rank = p_min_rank), with Rank_of_the_Year as a random integer 1-5, only for non-existing pairs. Else, delete from station_company where Company_ID belongs to a company with Assets_billion > p_max_assets.",
    "natural_language": "Create a stored procedure called calculate_company_stats that takes p_year (INTEGER), p_min_rank (INTEGER), and p_max_assets (REAL) as parameters. First, compute the average Sales_billion for companies whose Rank is between p_min_rank and 10 and whose Assets_billion is less than or equal to p_max_assets, and store this result in v_avg_sales. Next, count the distinct Station_ID from the join of station_company and gas_station for stations opened in the year p_year, but only where the associated Company_ID belongs to a company with a Rank less than or equal to p_min_rank, and store this count in v_total_stations. Then, check the following conditions: if v_avg_sales is greater than 300, delete records from station_company where the Rank_of_the_Year is greater than 5 and the Company_ID belongs to a company with Sales_billion less than v_avg_sales. Otherwise, if v_total_stations is greater than 10, insert up to three new rows into station_company for columns Station_ID, Company_ID, and Rank_of_the_Year. These rows should come from a cross join of gas_station (filtered for stations opened in p_year) and company (filtered for Rank equal to p_min_rank), assigning a random integer between 1 and 5 as Rank_of_the_Year, but only insert pairs that do not already exist. If neither condition is met, delete from station_company where the Company_ID belongs to a company with Assets_billion greater than p_max_assets.",
    "id": 86
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_company_relations that accepts three parameters: p_industry_filter of type TEXT, p_min_sales of type REAL, and p_year_cutoff of type INTEGER. The procedure begins by declaring two local variables: v_top_company_id of type INTEGER and v_station_records of type INTEGER. It then executes a SELECT statement to find the Company_ID of the top-ranked company from the company table where the Main_Industry column contains the string specified by p_industry_filter and the Sales_billion column is greater than or equal to p_min_sales. The result is ordered by the Rank column in ascending order, and only the first result is selected into v_top_company_id. Next, the procedure counts the number of records in the station_company table that are associated with the company identified by v_top_company_id and have a corresponding gas_station record with an Open_Year less than p_year_cutoff. This count is stored in v_station_records. The procedure then evaluates a series of conditional statements: if v_top_company_id is NULL, indicating no matching company was found, it inserts a new record into the company table with a new Company_ID, a Rank of 99, a Company name prefixed with 'New ' and the value of p_industry_filter, Headquarters set to 'Unknown', Main_Industry set to p_industry_filter, and calculated values for Sales_billion, Profits_billion, Assets_billion, and Market_Value based on p_min_sales. If v_station_records is greater than 0, it deletes records from the station_company table where the Company_ID matches v_top_company_id and the Station_ID corresponds to a gas_station record with an Open_Year less than p_year_cutoff. If neither of the previous conditions is met, the procedure inserts up to four new records into the station_company table for each gas_station record with an Open_Year greater than or equal to p_year_cutoff, provided no existing station_company record links the same Station_ID and v_top_company_id. The Rank_of_the_Year is set to 2 if the Open_Year is 2000 or later, otherwise it is set to 3.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_company_relations(p_industry_filter TEXT, p_min_sales REAL, p_year_cutoff INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_top_company_id INTEGER;\n    v_station_records INTEGER;\nBEGIN\n    SELECT \"Company_ID\" INTO v_top_company_id\n    FROM company\n    WHERE \"Main_Industry\" LIKE '%' || p_industry_filter || '%'\n    AND \"Sales_billion\" >= p_min_sales\n    ORDER BY \"Rank\" ASC\n    LIMIT 1;\n    \n    SELECT COUNT(*) INTO v_station_records\n    FROM station_company sc\n    JOIN gas_station gs ON sc.\"Station_ID\" = gs.\"Station_ID\"\n    WHERE sc.\"Company_ID\" = v_top_company_id\n    AND gs.\"Open_Year\" < p_year_cutoff;\n    \n    IF v_top_company_id IS NULL THEN\n        INSERT INTO company (\"Company_ID\", \"Rank\", \"Company\", \"Headquarters\", \"Main_Industry\", \"Sales_billion\", \"Profits_billion\", \"Assets_billion\", \"Market_Value\")\n        VALUES (\n            (SELECT COALESCE(MAX(\"Company_ID\"), 0) + 1 FROM company),\n            99,\n            'New ' || p_industry_filter || ' Company',\n            'Unknown',\n            p_industry_filter,\n            p_min_sales * 0.8,\n            p_min_sales * 0.1,\n            p_min_sales * 2,\n            p_min_sales * 1.5\n        );\n    ELSIF v_station_records > 0 THEN\n        DELETE FROM station_company\n        WHERE \"Company_ID\" = v_top_company_id\n        AND \"Station_ID\" IN (\n            SELECT \"Station_ID\" FROM gas_station \n            WHERE \"Open_Year\" < p_year_cutoff\n        );\n    ELSE\n        INSERT INTO station_company (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\n        SELECT gs.\"Station_ID\", v_top_company_id, \n               CASE WHEN gs.\"Open_Year\" >= 2000 THEN 2 ELSE 3 END\n        FROM gas_station gs\n        WHERE gs.\"Open_Year\" >= p_year_cutoff\n        AND NOT EXISTS (\n            SELECT 1 FROM station_company sc \n            WHERE sc.\"Station_ID\" = gs.\"Station_ID\" \n            AND sc.\"Company_ID\" = v_top_company_id\n        )\n        LIMIT 4;\n    END IF;\nEND;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "CALL manage_company_relations('Oil and gas', 400.0, 2000);",
      "CALL manage_company_relations('Conglomerate', 100.0, 1995);",
      "CALL manage_company_relations('Technology', 50.0, 2010);",
      "CALL manage_company_relations('Retail', 200.0, 1990);",
      "CALL manage_company_relations('Automotive', 150.0, 2005);"
    ],
    "summary": "Create a stored procedure named manage_company_relations with parameters p_industry_filter (TEXT), p_min_sales (REAL), and p_year_cutoff (INTEGER). Find the top-ranked Company_ID from company where Main_Industry contains p_industry_filter and Sales_billion >= p_min_sales, store in v_top_company_id. Count station_company records for that company where the associated gas_station has Open_Year < p_year_cutoff, store in v_station_records. If v_top_company_id is NULL, insert a new company with calculated values. If v_station_records > 0, delete those station_company records. Otherwise, insert up to four new station_company records for each gas_station with Open_Year >= p_year_cutoff where no link exists, setting Rank_of_the_Year to 2 if Open_Year >= 2000, else 3.",
    "natural_language": "Create procedure manage_company_relations with p_industry_filter TEXT, p_min_sales REAL, p_year_cutoff INTEGER. Get top Company_ID from company where Main_Industry has p_industry_filter and Sales_billion >= p_min_sales into v_top_company_id. Count station_company records for that company where linked gas_station Open_Year < p_year_cutoff into v_station_records. If v_top_company_id is NULL, insert new company. If v_station_records > 0, delete those records. Else, insert up to four new station_company records per gas_station with Open_Year >= p_year_cutoff and no existing link, setting Rank_of_the_Year to 2 if Open_Year >= 2000, else 3.",
    "id": 87
  },
  {
    "ir": "Write a PostgreSQL stored procedure named synchronize_station_info that accepts three input parameters: a text parameter p_manager_name, an integer parameter p_year_offset, and an integer parameter p_min_rank. The procedure first calculates a target year v_target_year by subtracting the p_year_offset from the current calendar year. It then queries the database to count distinct company IDs, storing the result in v_high_value_count, by joining the company table (aliased as c) with the station_company table (aliased as sc) on the Company_ID column, where the company's Market_Value exceeds 300 and the associated station_company record's Rank_of_the_Year is less than or equal to p_min_rank.\n\nBased on the value of v_high_value_count, the procedure executes one of three conditional branches. If the count is 3 or greater, it inserts up to two new records into the gas_station table. The data for these inserts is selected from existing gas_station rows where the Open_Year equals the calculated v_target_year and the Manager_Name contains the first word of the p_manager_name parameter (using a case-insensitive ILIKE match with wildcards). For each selected row, the new Station_ID is generated by taking the current maximum Station_ID from the gas_station table (or 0 if none exist) and adding a row number, the Open_Year is set to v_target_year, the Location is prefixed with 'Legacy-', the Manager_Name is set to the input p_manager_name, and the Vice_Manager_Name and Representative_Name are copied from the source row.\n\nIf v_high_value_count is between 1 and 2 inclusive, the procedure deletes records from the station_company table where the Rank_of_the_Year is greater than p_min_rank and the Station_ID belongs to a gas_station that was opened before the v_target_year and has a Manager_Name containing the first word of p_manager_name (again using ILIKE).\n\nIf v_high_value_count is 0, the procedure inserts up to five new records into the station_company table. The data is selected from a cross join between the gas_station table (aliased as gs) and the company table (aliased as c), where the gas station's Open_Year equals v_target_year and the company's Rank is less than or equal to p_min_rank plus 2. It only selects pairs where a corresponding record does not already exist in the station_company table (checked via a NOT EXISTS subquery linking Station_ID and Company_ID). For each selected pair, it inserts the Station_ID, Company_ID, and a calculated Rank_of_the_Year which is the absolute difference between the company's Rank and p_min_rank, plus 1. The final selection is limited to five rows chosen randomly via ORDER BY RANDOM().",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_station_info(p_manager_name TEXT, p_year_offset INTEGER, p_min_rank INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_target_year INTEGER;\n    v_high_value_count INTEGER;\nBEGIN\n    v_target_year := EXTRACT(YEAR FROM CURRENT_DATE) - p_year_offset;\n    \n    SELECT COUNT(DISTINCT c.\"Company_ID\") INTO v_high_value_count\n    FROM company c\n    JOIN station_company sc ON c.\"Company_ID\" = sc.\"Company_ID\"\n    WHERE c.\"Market_Value\" > 300\n    AND sc.\"Rank_of_the_Year\" <= p_min_rank;\n    \n    IF v_high_value_count >= 3 THEN\n        INSERT INTO gas_station (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\")\n        SELECT \n            (SELECT COALESCE(MAX(\"Station_ID\"), 0) + ROW_NUMBER() OVER () FROM gas_station),\n            v_target_year,\n            'Legacy-' || \"Location\",\n            p_manager_name,\n            \"Vice_Manager_Name\",\n            \"Representative_Name\"\n        FROM gas_station\n        WHERE \"Open_Year\" = v_target_year\n        AND \"Manager_Name\" ILIKE '%' || SPLIT_PART(p_manager_name, ' ', 1) || '%'\n        LIMIT 2;\n    ELSIF v_high_value_count BETWEEN 1 AND 2 THEN\n        DELETE FROM station_company\n        WHERE \"Station_ID\" IN (\n            SELECT \"Station_ID\" FROM gas_station\n            WHERE \"Open_Year\" < v_target_year\n            AND \"Manager_Name\" ILIKE '%' || SPLIT_PART(p_manager_name, ' ', 1) || '%'\n        )\n        AND \"Rank_of_the_Year\" > p_min_rank;\n    ELSE\n        INSERT INTO station_company (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\n        SELECT gs.\"Station_ID\", c.\"Company_ID\", \n               ABS(c.\"Rank\" - p_min_rank) + 1\n        FROM gas_station gs\n        CROSS JOIN company c\n        WHERE gs.\"Open_Year\" = v_target_year\n        AND c.\"Rank\" <= p_min_rank + 2\n        AND NOT EXISTS (\n            SELECT 1 FROM station_company sc \n            WHERE sc.\"Station_ID\" = gs.\"Station_ID\" \n            AND sc.\"Company_ID\" = c.\"Company_ID\"\n        )\n        ORDER BY RANDOM()\n        LIMIT 5;\n    END IF;\nEND;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "CALL synchronize_station_info('BrianWingrave', 2, 1);",
      "CALL synchronize_station_info('SimonMarloe', 1, 3);",
      "CALL synchronize_station_info('Derek Marloe', 0, 5);",
      "CALL synchronize_station_info('Russell Denman', 3, 2);",
      "CALL synchronize_station_info('James Colin', 1, 4);"
    ],
    "summary": "Create a stored procedure named synchronize_station_info with parameters p_manager_name (TEXT), p_year_offset (INTEGER), and p_min_rank (INTEGER). Calculate v_target_year as current year minus p_year_offset. Count distinct company IDs from company joined with station_company where Market_Value > 300 and Rank_of_the_Year <= p_min_rank, store in v_high_value_count. If count >= 3, insert up to two new gas_station records from stations opened in v_target_year where Manager_Name ILIKE the first word of p_manager_name, with new Station_IDs, 'Legacy-' prefixed Location, and p_manager_name as Manager_Name. If count is 1 or 2, delete from station_company where Rank_of_the_Year > p_min_rank and Station_ID belongs to a gas_station opened before v_target_year with Manager_Name ILIKE the first word of p_manager_name. If count = 0, insert up to five new station_company records from a cross join of gas_station (opened in v_target_year) and company (Rank <= p_min_rank + 2) for non-existing pairs, with Rank_of_the_Year as absolute difference between company Rank and p_min_rank plus 1.",
    "natural_language": "Create procedure synchronize_station_info(p_manager_name TEXT, p_year_offset INTEGER, p_min_rank INTEGER). Set target year as current year minus offset. Count distinct high-value companies (Market_Value>300, Rank<=p_min_rank). If count>=3, insert up to two new gas stations from target year where manager matches first word of input. If count=1 or 2, delete old station_company records for matching stations opened before target year where rank>p_min_rank. If count=0, insert up to five new station_company records for non-existing pairs from target year stations and companies with rank<=p_min_rank+2, setting rank as absolute difference plus one.",
    "id": 88
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_singer_portfolio that accepts three parameters: p_singer_id of type INTEGER, p_action of type TEXT, and p_threshold of type REAL. The procedure begins by declaring three local variables: v_net_worth of type REAL, v_song_count of type INTEGER, and v_total_sales of type REAL. It retrieves the net worth of the singer with the specified Singer_ID from the singer table and stores it in v_net_worth. It then counts the number of songs and sums the sales for the specified Singer_ID from the song table, storing these values in v_song_count and v_total_sales, respectively. The procedure checks the value of p_action to determine the operation to perform. If p_action is 'promote', it evaluates several conditions: if v_net_worth exceeds p_threshold, it increases the singer's net worth by 10%; if v_song_count is greater than 2, it increases the net worth by 5%; if v_total_sales exceeds 1,000,000, it increases the net worth by 3%; otherwise, it increases the net worth by 1%. If p_action is 'demote', it checks if v_net_worth is less than p_threshold; if true, it decreases the net worth by 10%, otherwise by 5%. If p_action is neither 'promote' nor 'demote', it deletes all songs associated with the specified Singer_ID from the song table.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_singer_portfolio(\n    p_singer_id INTEGER,\n    p_action TEXT,\n    p_threshold REAL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_net_worth REAL;\n    v_song_count INTEGER;\n    v_total_sales REAL;\nBEGIN\n    SELECT \"Net_Worth_Millions\" INTO v_net_worth \n    FROM \"singer\" WHERE \"Singer_ID\" = p_singer_id;\n    \n    SELECT COUNT(*), COALESCE(SUM(\"Sales\"), 0) INTO v_song_count, v_total_sales\n    FROM \"song\" WHERE \"Singer_ID\" = p_singer_id;\n    \n    IF p_action = 'promote' THEN\n        IF v_net_worth > p_threshold THEN\n            UPDATE \"singer\" \n            SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * 1.1 \n            WHERE \"Singer_ID\" = p_singer_id;\n        ELSIF v_song_count > 2 THEN\n            UPDATE \"singer\" \n            SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * 1.05 \n            WHERE \"Singer_ID\" = p_singer_id;\n        ELSIF v_total_sales > 1000000 THEN\n            UPDATE \"singer\" \n            SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * 1.03 \n            WHERE \"Singer_ID\" = p_singer_id;\n        ELSE\n            UPDATE \"singer\" \n            SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * 1.01 \n            WHERE \"Singer_ID\" = p_singer_id;\n        END IF;\n    ELSIF p_action = 'demote' THEN\n        IF v_net_worth < p_threshold THEN\n            UPDATE \"singer\" \n            SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * 0.9 \n            WHERE \"Singer_ID\" = p_singer_id;\n        ELSE\n            UPDATE \"singer\" \n            SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * 0.95 \n            WHERE \"Singer_ID\" = p_singer_id;\n        END IF;\n    ELSE\n        DELETE FROM \"song\" WHERE \"Singer_ID\" = p_singer_id;\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL manage_singer_portfolio(1, 'promote', 25.0);",
      "CALL manage_singer_portfolio(2, 'demote', 30.0);",
      "CALL manage_singer_portfolio(3, 'promote', 20.0);",
      "CALL manage_singer_portfolio(1, 'demote', 40.0);",
      "CALL manage_singer_portfolio(2, 'delete', 0);"
    ],
    "summary": "Create a stored procedure named manage_singer_portfolio with parameters p_singer_id (INTEGER), p_action (TEXT), and p_threshold (REAL). Retrieve the singer's net worth into v_net_worth, count of songs into v_song_count, and total sales into v_total_sales. If p_action is 'promote', increase net worth: by 10% if v_net_worth > p_threshold, by 5% if v_song_count > 2, by 3% if v_total_sales > 1,000,000, else by 1%. If p_action is 'demote', decrease net worth by 10% if v_net_worth < p_threshold, else by 5%. For any other p_action, delete all songs for the singer.",
    "natural_language": "Construct a stored procedure designated as 'manage_singer_portfolio' that accepts the parameters p_singer_id of type INTEGER, p_action of type TEXT, and p_threshold of type REAL. The procedure shall retrieve the singer's net worth into variable v_net_worth, the count of songs into v_song_count, and the total sales into v_total_sales. In the event that the p_action parameter is 'promote', the net worth shall be increased according to the following conditions: by ten percent if v_net_worth exceeds p_threshold, by five percent if v_song_count is greater than two, by three percent if v_total_sales exceeds one million, or by one percent otherwise. Should the p_action parameter be 'demote', the net worth is to be decreased by ten percent if v_net_worth is less than p_threshold, or by five percent otherwise. For any other value provided for p_action, all songs associated with the specified singer are to be deleted.",
    "id": 89
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_song_catalog that accepts three input parameters: a real number parameter p_min_sales representing a minimum sales threshold, a real number parameter p_max_position representing a maximum chart position threshold, and a text parameter p_operation specifying the action to perform. The procedure begins by declaring a local integer variable v_current_year and a record variable v_song_rec, then extracts the current year from the system date and assigns it to v_current_year. It then enters a loop that iterates over each row returned by a SELECT query on the song table, fetching the Song_ID, Title, Singer_ID, Sales, and Highest_Position columns for every song where the Sales column value is strictly greater than the p_min_sales parameter. For each fetched song record, the procedure first checks if the song's Highest_Position is less than or equal to the p_max_position parameter. If true, it evaluates the p_operation parameter: if p_operation is exactly the string 'boost', it executes an UPDATE on the song table, multiplying the Sales value by 1.2 for the specific row matching the current song's Song_ID; if p_operation is exactly 'archive', it performs an INSERT into the song table, creating a new record with a Song_ID equal to the current song's Song_ID plus 1000, a Title formed by trimming whitespace from the current song's Title and appending the string ' Archive', the same Singer_ID, a Sales value equal to half (0.5 times) the current song's Sales, and a Highest_Position value equal to the current song's Highest_Position plus 10; if p_operation is exactly 'premium', it executes an UPDATE on the song table, multiplying the Sales value by 1.5 for the row matching the current song's Song_ID; for any other value of p_operation, it executes a DELETE operation on the song table, removing the row where Song_ID matches the current song's Song_ID. If the initial condition on Highest_Position is false, the procedure then checks if the current song's Sales value is greater than twice (2 times) the p_min_sales parameter; if true, it executes an UPDATE on the song table, multiplying the Sales value by 1.1 for the row matching the current song's Song_ID. If neither of the previous conditions is met, it executes an UPDATE on the song table, incrementing the Highest_Position value by 1 for the row matching the current song's Song_ID. The loop continues until all songs meeting the initial Sales > p_min_sales condition have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_song_catalog(\n    p_min_sales REAL,\n    p_max_position REAL,\n    p_operation TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_year INTEGER;\n    v_song_rec RECORD;\nBEGIN\n    v_current_year := EXTRACT(YEAR FROM CURRENT_DATE);\n    \n    FOR v_song_rec IN \n        SELECT \"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\"\n        FROM song\n        WHERE \"Sales\" > p_min_sales\n    LOOP\n        IF v_song_rec.\"Highest_Position\" <= p_max_position THEN\n            IF p_operation = 'boost' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.2 \n                WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n            ELSIF p_operation = 'archive' THEN\n                INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n                VALUES (v_song_rec.\"Song_ID\" + 1000, TRIM(v_song_rec.\"Title\") || ' Archive', \n                       v_song_rec.\"Singer_ID\", v_song_rec.\"Sales\" * 0.5, v_song_rec.\"Highest_Position\" + 10);\n            ELSIF p_operation = 'premium' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.5 \n                WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n            ELSE\n                DELETE FROM song WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n            END IF;\n        ELSIF v_song_rec.\"Sales\" > p_min_sales * 2 THEN\n            UPDATE song \n            SET \"Sales\" = \"Sales\" * 1.1 \n            WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n        ELSE\n            UPDATE song \n            SET \"Highest_Position\" = \"Highest_Position\" + 1 \n            WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL process_song_catalog(500000.0, 5.0, 'boost');",
      "CALL process_song_catalog(300000.0, 10.0, 'archive');",
      "CALL process_song_catalog(1000000.0, 3.0, 'premium');",
      "CALL process_song_catalog(200000.0, 15.0, 'delete');",
      "CALL process_song_catalog(750000.0, 8.0, 'boost');"
    ],
    "summary": "Create a stored procedure named process_song_catalog with parameters p_min_sales (REAL), p_max_position (REAL), and p_operation (TEXT). Loop through songs where Sales > p_min_sales. For each song, if Highest_Position <= p_max_position: if p_operation is 'boost', update Sales by multiplying by 1.2; if 'archive', insert a new song with ID+1000, title + ' Archive', same singer, Sales halved, and Highest_Position+10; if 'premium', update Sales by multiplying by 1.5; else delete the song. Else if Sales > 2 * p_min_sales, update Sales by multiplying by 1.1. Else, increment Highest_Position by 1.",
    "natural_language": "Write a stored procedure called process_song_catalog that takes p_min_sales (REAL), p_max_position (REAL), and p_operation (TEXT) as parameters. Iterate through all songs where Sales exceed p_min_sales. For each song, check if its Highest_Position is less than or equal to p_max_position. If true, then: when p_operation is 'boost', increase Sales by 20%; when it's 'archive', insert a new archived record with the original ID plus 1000, append ' Archive' to the title, keep the singer, halve the Sales, and add 10 to the Highest_Position; when it's 'premium', increase Sales by 50%; for any other operation value, delete the song. If the first condition is false but Sales are greater than twice p_min_sales, then increase Sales by 10%. If neither condition is met, add 1 to the song's Highest_Position.",
    "id": 90
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named redistribute_wealth that accepts three input parameters: a TEXT parameter p_citizenship, an INTEGER parameter p_birth_decade, and a REAL parameter p_redistribution_factor. The procedure operates on a table named singer, which contains columns including Singer_ID, Name, Birth_Year, Net_Worth_Millions, and Citizenship. It begins by calculating the total sum of the Net_Worth_Millions column and the count of rows from the singer table where the Citizenship column exactly matches the p_citizenship parameter and where the decade of the Birth_Year, derived by applying the FLOOR function to Birth_Year divided by 10 and then multiplying the result by 10, equals the p_birth_decade parameter; these aggregate results are stored into local variables v_total_worth and v_singer_count respectively. If the v_singer_count is greater than zero, it computes an average worth v_avg_worth by dividing v_total_worth by v_singer_count, then enters a loop that iterates over each singer record, identified by Singer_ID and Net_Worth_Millions, that satisfies the same citizenship and birth decade filter condition. For each singer record in this loop, it performs a conditional update to the singer table based on the singer's current Net_Worth_Millions relative to the calculated v_avg_worth: if the singer's net worth is greater than v_avg_worth, it reduces their Net_Worth_Millions by subtracting the product of the difference between their current worth and the average and the p_redistribution_factor; if the singer's net worth is less than 80% of the average (v_avg_worth * 0.8), it increases their Net_Worth_Millions by adding the product of the difference between the average and their current worth, the p_redistribution_factor, and a factor of 0.5; if the singer's net worth is less than 90% of the average (v_avg_worth * 0.9) but not less than 80%, it increases their Net_Worth_Millions by adding the product of the difference between the average and their current worth, the p_redistribution_factor, and a factor of 0.3; for all other cases (where the net worth is between 90% and 100% of the average, or exactly equal to the average), it sets the singer's Net_Worth_Millions directly to the v_avg_worth value. Each update is applied specifically to the row where the Singer_ID matches the v_singer_rec.Singer_ID from the current loop iteration. If the initial singer count v_singer_count is zero, indicating no singers match the provided citizenship and birth decade criteria, the procedure performs an INSERT into the singer table, attempting to add a new row with a Singer_ID of 999, a Name of 'Default Singer', a Birth_Year calculated as p_birth_decade plus 5, a Net_Worth_Millions of 10.0, and the Citizenship from the p_citizenship parameter, using an ON CONFLICT clause on the Singer_ID column to do nothing if a row with Singer_ID 999 already exists.",
    "plsql": "CREATE OR REPLACE PROCEDURE redistribute_wealth(\n    p_citizenship TEXT,\n    p_birth_decade INTEGER,\n    p_redistribution_factor REAL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_worth REAL;\n    v_singer_count INTEGER;\n    v_avg_worth REAL;\n    v_singer_rec RECORD;\nBEGIN\n    SELECT SUM(\"Net_Worth_Millions\"), COUNT(*) INTO v_total_worth, v_singer_count\n    FROM singer \n    WHERE \"Citizenship\" = p_citizenship \n    AND FLOOR(\"Birth_Year\" / 10) * 10 = p_birth_decade;\n    \n    IF v_singer_count > 0 THEN\n        v_avg_worth := v_total_worth / v_singer_count;\n        \n        FOR v_singer_rec IN \n            SELECT \"Singer_ID\", \"Net_Worth_Millions\"\n            FROM singer \n            WHERE \"Citizenship\" = p_citizenship \n            AND FLOOR(\"Birth_Year\" / 10) * 10 = p_birth_decade\n        LOOP\n            IF v_singer_rec.\"Net_Worth_Millions\" > v_avg_worth THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" - \n                    (\"Net_Worth_Millions\" - v_avg_worth) * p_redistribution_factor\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            ELSIF v_singer_rec.\"Net_Worth_Millions\" < v_avg_worth * 0.8 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + \n                    (v_avg_worth - \"Net_Worth_Millions\") * p_redistribution_factor * 0.5\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            ELSIF v_singer_rec.\"Net_Worth_Millions\" < v_avg_worth * 0.9 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + \n                    (v_avg_worth - \"Net_Worth_Millions\") * p_redistribution_factor * 0.3\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            ELSE\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = v_avg_worth\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            END IF;\n        END LOOP;\n    ELSE\n        INSERT INTO singer (\"Singer_ID\", \"Name\", \"Birth_Year\", \"Net_Worth_Millions\", \"Citizenship\")\n        VALUES (999, 'Default Singer', p_birth_decade + 5, 10.0, p_citizenship)\n        ON CONFLICT (\"Singer_ID\") DO NOTHING;\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL redistribute_wealth('France', 1940, 0.5);",
      "CALL redistribute_wealth('United States', 1940, 0.3);",
      "CALL redistribute_wealth('France', 1950, 0.7);",
      "CALL redistribute_wealth('United States', 1950, 0.4);",
      "CALL redistribute_wealth('France', 1960, 0.6);"
    ],
    "summary": "Create a stored procedure named redistribute_wealth that accepts parameters p_citizenship (TEXT), p_birth_decade (INTEGER), and p_redistribution_factor (REAL). For singers matching the given citizenship and birth decade, calculate their total and average net worth. If singers exist, adjust each singer's net worth based on how it compares to the average: reduce it if above average, increase it if below 80% or 90% of the average using specific formulas and the redistribution factor, or set it to the average otherwise. If no singers match, insert a default singer record with ID 999, handling conflicts.",
    "natural_language": "Alright, so we need a stored procedure called redistribute_wealth. It's gotta take three things: p_citizenship (that's TEXT), p_birth_decade (an INTEGER), and p_redistribution_factor (a REAL number). Here's the deal: look up all the singers who match that citizenship and were born in that decade. Figure out their total and average net worth. If we find any singers, we're gonna tweak each one's net worth. If a singer's worth is above the average, we'll bring it down a bit. If it's below 80% or 90% of the average, we'll bump it up using these specific formulas and that redistribution factor. Otherwise, just set their worth to the average. Oh, and if we don't find any singers at all, just pop in a default singer record with ID 999, but make sure you handle it if that ID already exists.",
    "id": 91
  },
  {
    "ir": "Write a PLpgSQL stored procedure named optimize_song_performance that accepts three input parameters: an integer p_target_singer_id to identify a specific singer, a real number p_performance_threshold to set a baseline performance score, and a text p_optimization_mode to determine the update strategy. The procedure begins by declaring a cursor v_song_cursor that selects the columns \"Song_ID\", \"Sales\", and \"Highest_Position\" from the song table for all rows where the \"Singer_ID\" column matches the provided p_target_singer_id. It also declares local variables v_song_id, v_sales, and v_position to hold fetched cursor values, and v_performance_score to store a calculated metric. The procedure opens the cursor and enters a loop, fetching each row from the cursor into the local variables. For each fetched song record, it calculates a performance score v_performance_score by dividing the sales value v_sales by the sum of the highest position v_position and 1. If this calculated score is greater than the input threshold p_performance_threshold, the procedure executes a conditional block based on the p_optimization_mode: if the mode is 'aggressive', it updates the current song's row in the song table by multiplying the \"Sales\" column by 1.3 and subtracting 1 from the \"Highest_Position\" column; if the mode is 'conservative', it updates only the \"Sales\" column by multiplying it by 1.1; if the mode is 'balanced', it updates the \"Sales\" column by multiplying it by 1.2 and subtracts 0.5 from the \"Highest_Position\" column; for any other optimization mode value, it deletes the current song's row from the song table entirely. If the performance score is not greater than the threshold but is greater than half of the threshold (p_performance_threshold * 0.5), the procedure performs a minor update, multiplying the song's \"Sales\" column by 1.05. If the performance score is less than or equal to half of the threshold, the procedure inserts a new row into the song table with a \"Song_ID\" value equal to the original v_song_id plus 2000, a \"Title\" of 'Remix Version', the original p_target_singer_id as the \"Singer_ID\", sales set to 80% of the original v_sales (v_sales * 0.8), and a highest position set to the original v_position plus 2. The loop continues until all rows from the cursor are processed, after which the cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE optimize_song_performance(\n    p_target_singer_id INTEGER,\n    p_performance_threshold REAL,\n    p_optimization_mode TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_song_cursor CURSOR FOR \n        SELECT \"Song_ID\", \"Sales\", \"Highest_Position\" \n        FROM song \n        WHERE \"Singer_ID\" = p_target_singer_id;\n    v_song_id INTEGER;\n    v_sales REAL;\n    v_position REAL;\n    v_performance_score REAL;\nBEGIN\n    OPEN v_song_cursor;\n    \n    LOOP\n        FETCH v_song_cursor INTO v_song_id, v_sales, v_position;\n        EXIT WHEN NOT FOUND;\n        \n        v_performance_score := v_sales / (v_position + 1);\n        \n        IF v_performance_score > p_performance_threshold THEN\n            IF p_optimization_mode = 'aggressive' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.3, \"Highest_Position\" = \"Highest_Position\" - 1\n                WHERE \"Song_ID\" = v_song_id;\n            ELSIF p_optimization_mode = 'conservative' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.1\n                WHERE \"Song_ID\" = v_song_id;\n            ELSIF p_optimization_mode = 'balanced' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.2, \"Highest_Position\" = \"Highest_Position\" - 0.5\n                WHERE \"Song_ID\" = v_song_id;\n            ELSE\n                DELETE FROM song WHERE \"Song_ID\" = v_song_id;\n            END IF;\n        ELSIF v_performance_score > p_performance_threshold * 0.5 THEN\n            UPDATE song \n            SET \"Sales\" = \"Sales\" * 1.05\n            WHERE \"Song_ID\" = v_song_id;\n        ELSE\n            INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n            VALUES (v_song_id + 2000, 'Remix Version', p_target_singer_id, v_sales * 0.8, v_position + 2);\n        END IF;\n    END LOOP;\n    \n    CLOSE v_song_cursor;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL optimize_song_performance(1, 500000.0, 'aggressive');",
      "CALL optimize_song_performance(2, 200000.0, 'conservative');",
      "CALL optimize_song_performance(1, 700000.0, 'balanced');",
      "CALL optimize_song_performance(3, 100000.0, 'aggressive');",
      "CALL optimize_song_performance(2, 600000.0, 'delete_unpopular');"
    ],
    "summary": "Create a stored procedure named optimize_song_performance with parameters p_target_singer_id (INTEGER), p_performance_threshold (REAL), and p_optimization_mode (TEXT). For each song by the target singer, calculate a performance score (sales divided by highest position + 1). If the score exceeds the threshold, update the song based on the mode: aggressive (increase sales, decrease position), conservative (increase sales), or balanced (increase sales, slightly decrease position); otherwise, delete it. If the score is above half the threshold, slightly increase sales. If the score is at or below half the threshold, insert a new 'Remix Version' song record with adjusted sales and position.",
    "natural_language": "Create a stored procedure called optimize_song_performance. It must take the parameters p_target_singer_id as INTEGER, p_performance_threshold as REAL, and p_optimization_mode as TEXT. For every song by the specified singer, compute its performance score by dividing sales by (highest position + 1). If the score is greater than the threshold, update the song according to the mode: use 'aggressive' to increase sales and decrease position, 'conservative' to increase sales only, or 'balanced' to increase sales and slightly decrease position. If the score does not exceed the threshold, delete the song. For scores above half the threshold, slightly increase the song's sales. For scores at or below half the threshold, insert a new record for a 'Remix Version' of the song with adjusted sales and position.",
    "id": 92
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named analyze_market_segments that accepts three input parameters: a text parameter p_wealth_tier to specify a wealth classification, a text parameter p_market_action to specify a market operation, and a real number parameter p_adjustment_rate to specify a rate for financial adjustments. The procedure first declares local variables v_tier_boundary of type REAL, v_singer_id of type INTEGER, v_net_worth of type REAL, and v_total_song_sales of type REAL. If the p_wealth_tier parameter is equal to the string 'premium', the procedure sets v_tier_boundary to 25.0, then enters a loop that iterates over each row from the singer table where the Net_Worth_Millions column is greater than or equal to v_tier_boundary, fetching the Singer_ID and Net_Worth_Millions values into the v_singer_id and v_net_worth variables. For each singer in this loop, it calculates the total song sales by selecting the sum of the Sales column from the song table for rows where the Singer_ID matches the current v_singer_id, storing the result in v_total_song_sales and using the COALESCE function to return 0 if the sum is null. If v_total_song_sales is greater than 1,500,000, it updates the singer table by multiplying the Net_Worth_Millions column by (1 + p_adjustment_rate) for the current v_singer_id. If v_total_song_sales is greater than 800,000 but not greater than 1,500,000, it updates the Net_Worth_Millions column by multiplying it by (1 + p_adjustment_rate * 0.7). If v_total_song_sales is 800,000 or less, it updates the Net_Worth_Millions column by multiplying it by (1 + p_adjustment_rate * 0.4). If the p_wealth_tier parameter is equal to the string 'standard', the procedure sets v_tier_boundary to 25.0, then enters a loop that iterates over each row from the singer table where the Net_Worth_Millions column is less than v_tier_boundary, fetching the Singer_ID and Net_Worth_Millions values. For each singer in this loop, if the p_market_action parameter is equal to the string 'expand', it inserts a new row into the song table with Song_ID set to v_singer_id + 3000, Title set to 'Market Expansion Hit', Singer_ID set to v_singer_id, Sales set to 500000, and Highest_Position set to 5. If p_market_action is not 'expand', it updates the song table by multiplying the Sales column by (1 - p_adjustment_rate * 0.2) for all rows where the Singer_ID matches the current v_singer_id. If the p_wealth_tier parameter is neither 'premium' nor 'standard', the procedure deletes rows from the song table where the Singer_ID is found in the result of a subquery that selects the Singer_ID from the singer table where the Net_Worth_Millions column is less than 20.0.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_market_segments(\n    p_wealth_tier TEXT,\n    p_market_action TEXT,\n    p_adjustment_rate REAL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_tier_boundary REAL;\n    v_singer_id INTEGER;\n    v_net_worth REAL;\n    v_total_song_sales REAL;\nBEGIN\n    IF p_wealth_tier = 'premium' THEN\n        v_tier_boundary := 25.0;\n        \n        FOR v_singer_id, v_net_worth IN \n            SELECT \"Singer_ID\", \"Net_Worth_Millions\" \n            FROM singer \n            WHERE \"Net_Worth_Millions\" >= v_tier_boundary\n        LOOP\n            SELECT COALESCE(SUM(\"Sales\"), 0) INTO v_total_song_sales\n            FROM song WHERE \"Singer_ID\" = v_singer_id;\n            \n            IF v_total_song_sales > 1500000 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * (1 + p_adjustment_rate)\n                WHERE \"Singer_ID\" = v_singer_id;\n            ELSIF v_total_song_sales > 800000 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * (1 + p_adjustment_rate * 0.7)\n                WHERE \"Singer_ID\" = v_singer_id;\n            ELSE\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * (1 + p_adjustment_rate * 0.4)\n                WHERE \"Singer_ID\" = v_singer_id;\n            END IF;\n        END LOOP;\n    ELSIF p_wealth_tier = 'standard' THEN\n        v_tier_boundary := 25.0;\n        \n        FOR v_singer_id, v_net_worth IN \n            SELECT \"Singer_ID\", \"Net_Worth_Millions\" \n            FROM singer \n            WHERE \"Net_Worth_Millions\" < v_tier_boundary\n        LOOP\n            IF p_market_action = 'expand' THEN\n                INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n                VALUES (v_singer_id + 3000, 'Market Expansion Hit', v_singer_id, 500000, 5);\n            ELSE\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * (1 - p_adjustment_rate * 0.2)\n                WHERE \"Singer_ID\" = v_singer_id;\n            END IF;\n        END LOOP;\n    ELSE\n        DELETE FROM song \n        WHERE \"Singer_ID\" IN (\n            SELECT \"Singer_ID\" \n            FROM singer \n            WHERE \"Net_Worth_Millions\" < 20.0\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL analyze_market_segments('premium', 'adjust', 0.05);",
      "CALL analyze_market_segments('standard', 'expand', 0.02);",
      "CALL analyze_market_segments('premium', 'rebalance', -0.03);",
      "CALL analyze_market_segments('standard', 'contract', 0.01);",
      "CALL analyze_market_segments('unknown', 'cleanup', 0.0);"
    ],
    "summary": "Create a stored procedure named analyze_market_segments with parameters p_wealth_tier (TEXT), p_market_action (TEXT), and p_adjustment_rate (REAL). For 'premium' tier singers (net worth >= 25.0), adjust their net worth based on their total song sales using the adjustment rate. For 'standard' tier singers (net worth < 25.0), if the action is 'expand', insert a new market expansion song; otherwise, decrease their song sales. For any other tier, delete songs for singers with net worth below 20.0.",
    "natural_language": "Alright, so we need a stored procedure called analyze_market_segments. It's gonna take three things: p_wealth_tier (that's TEXT), p_market_action (also TEXT), and p_adjustment_rate (a REAL number). Here's the deal: for the big-shot 'premium' tier singersâ€”you know, the ones rolling in dough with a net worth of 25.0 or moreâ€”we're gonna tweak their net worth. How? We'll use that adjustment rate on their total song sales. Now, for the 'standard' tier folks (net worth under 25.0), if the action is 'expand', we gotta add a brand new market expansion song for them. If it's not 'expand', then we're cutting their song sales down a bit. And for any other tier that doesn't fit those two? Well, if a singer's net worth is below 20.0, we're just gonna delete their songs.",
    "id": 93
  },
  {
    "ir": "Write a PostgreSQL stored procedure named `delete_old_service_records` that accepts five input parameters: `p_cutoff_date` of type `TIMESTAMP WITH TIME ZONE`, `p_min_property_id` of type `BIGINT`, `p_max_property_id` of type `BIGINT`, `p_resident_threshold` of type `BIGINT`, and `p_service_pattern` of type `TEXT`. The purpose of this procedure is to remove records from the `\"Residents_Services\"` table. The deletion operation targets rows where the value in the `\"date_provided\"` column is strictly earlier than the `p_cutoff_date` parameter. Additionally, the deletion is constrained by the `\"property_id\"` column, which must have a value inclusively between `p_min_property_id` and `p_max_property_id`. A further condition for deletion is that the `\"resident_id\"` column must contain a value strictly greater than `p_resident_threshold`. Finally, the deletion applies only to rows where the `\"other_details\"` column contains the `p_service_pattern` string as a substring, with the search being case-insensitive due to the use of the `ILIKE` operator, which is constructed by concatenating a '%' wildcard character before and after the `p_service_pattern` to match any occurrence of the pattern within the column's text.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_service_records(\n    IN p_cutoff_date TIMESTAMP WITH TIME ZONE,\n    IN p_min_property_id BIGINT,\n    IN p_max_property_id BIGINT,\n    IN p_resident_threshold BIGINT,\n    IN p_service_pattern TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Residents_Services\"\n    WHERE \"date_provided\" < p_cutoff_date\n    AND \"property_id\" BETWEEN p_min_property_id AND p_max_property_id\n    AND \"resident_id\" > p_resident_threshold\n    AND \"other_details\" ILIKE '%' || p_service_pattern || '%';\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Residents_Services"
    ],
    "call_sqls": [
      "CALL delete_old_service_records('2017-01-01 00:00:00+08:00', 1, 1000, 0, 'Satisfied');",
      "CALL delete_old_service_records('2018-01-01 00:00:00+08:00', 500, 900, 10, 'Unsatisfied');",
      "CALL delete_old_service_records('2017-06-01 00:00:00+08:00', 600, 700, 20, 'repair');",
      "CALL delete_old_service_records('2016-01-01 00:00:00+08:00', 100, 500, 5, 'cleaning');",
      "CALL delete_old_service_records('2019-01-01 00:00:00+08:00', 800, 999, 30, 'maintenance');"
    ],
    "summary": "Create a stored procedure named delete_old_service_records with parameters p_cutoff_date (TIMESTAMPTZ), p_min_property_id (BIGINT), p_max_property_id (BIGINT), p_resident_threshold (BIGINT), and p_service_pattern (TEXT). Delete records from the Residents_Services table where the service date is before the cutoff, the property ID is within the specified range, the resident ID is above the threshold, and the other details contain the given pattern (case-insensitive).",
    "natural_language": "Create procedure delete_old_service_records with parameters p_cutoff_date TIMESTAMPTZ, p_min_property_id BIGINT, p_max_property_id BIGINT, p_resident_threshold BIGINT, p_service_pattern TEXT. Delete from Residents_Services where service date < cutoff, property ID between min and max, resident ID > threshold, and other details contain pattern case-insensitively.",
    "id": 94
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `update_university_ranking` that does not accept any parameters. This procedure is designed to iterate through each university recorded in the `university` table and update its ranking information in the `overall_ranking` table based on a calculated total score.\n\nThe procedure begins by declaring several local variables:\n- `v_university_id` of type `integer`, intended to store the ID of the university currently being processed.\n- `v_total_points` of type `integer`, intended to store the calculated total points for a university.\n- `v_reputation` of type `integer`, intended to store the reputation points for a university.\n- `v_research` of type `integer`, intended to store the research points for a university.\n- `v_citation` of type `integer`, intended to store the citation points for a university.\n\nIt also declares a cursor named `cur_university` which is defined to select the `University_ID` column from the `university` table.\n\nThe procedure then opens the `cur_university` cursor. It enters a loop to process each university. Inside the loop, it fetches the `University_ID` from the `cur_university` cursor into the `v_university_id` variable. The loop terminates if no more rows are found by the cursor (i.e., `NOT FOUND` is true).\n\nFor each `v_university_id` fetched, the procedure executes a `SELECT` statement to retrieve the `Reputation_point`, `Research_point`, and `Citation_point` columns from the `overall_ranking` table where the `University_ID` column matches the current `v_university_id`. These retrieved values are stored into the `v_reputation`, `v_research`, and `v_citation` variables, respectively.\n\nNext, it calculates `v_total_points` by summing the values of `v_reputation`, `v_research`, and `v_citation`. The `COALESCE` function is used for each point type (`v_reputation`, `v_research`, `v_citation`) to treat any `NULL` values as `0` before summation, ensuring that the total points calculation is not affected by missing point values.\n\nFollowing the calculation, a series of conditional statements (`IF`, `ELSIF`, `ELSE`) are executed based on the `v_total_points`:\n- If `v_total_points` is greater than `15`, an `UPDATE` statement is executed on the `overall_ranking` table. It sets the `Total` column to `v_total_points + 10` for the row where the `University_ID` matches the current `v_university_id`.\n- Else if `v_total_points` is greater than `10`, an `UPDATE` statement is executed on the `overall_ranking` table. It sets the `Total` column to `v_total_points + 5` for the row where the `University_ID` matches the current `v_university_id`.\n- Else if `v_total_points` is greater than `5`, an `UPDATE` statement is executed on the `overall_ranking` table. It sets the `Total` column to `v_total_points + 2` for the row where the `University_ID` matches the current `v_university_id`.\n- Otherwise (if `v_total_points` is `5` or less), a `DELETE` statement is executed on the `overall_ranking` table. It removes the row where the `University_ID` matches the current `v_university_id`.\n\nAfter the loop finishes processing all universities, the procedure closes the `cur_university` cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_university_ranking()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_university_id integer;\n    v_total_points integer;\n    v_reputation integer;\n    v_research integer;\n    v_citation integer;\n    cur_university CURSOR FOR SELECT \"University_ID\" FROM university;\nBEGIN\n    OPEN cur_university;\n    LOOP\n        FETCH cur_university INTO v_university_id;\n        EXIT WHEN NOT FOUND;\n        SELECT \"Reputation_point\", \"Research_point\", \"Citation_point\" INTO v_reputation, v_research, v_citation FROM overall_ranking WHERE \"University_ID\" = v_university_id;\n        v_total_points := COALESCE(v_reputation, 0) + COALESCE(v_research, 0) + COALESCE(v_citation, 0);\n        IF v_total_points > 15 THEN\n            UPDATE overall_ranking SET \"Total\" = v_total_points + 10 WHERE \"University_ID\" = v_university_id;\n        ELSIF v_total_points > 10 THEN\n            UPDATE overall_ranking SET \"Total\" = v_total_points + 5 WHERE \"University_ID\" = v_university_id;\n        ELSIF v_total_points > 5 THEN\n            UPDATE overall_ranking SET \"Total\" = v_total_points + 2 WHERE \"University_ID\" = v_university_id;\n        ELSE\n            DELETE FROM overall_ranking WHERE \"University_ID\" = v_university_id;\n        END IF;\n    END LOOP;\n    CLOSE cur_university;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL update_university_ranking();"
    ],
    "summary": "Create a parameterless stored procedure named update_university_ranking. For each university, calculate its total points by summing reputation, research, and citation points from the overall_ranking table (treating NULL as 0). Update the total in the overall_ranking table by adding a bonus based on the total points: +10 if >15, +5 if >10, +2 if >5. If the total is 5 or less, delete the university's ranking record.",
    "natural_language": "Create a stored procedure called update_university_ranking that doesn't need any parameters. For every university, figure out its overall score by adding up its reputation, research, and citation numbers from the overall_ranking table, counting any missing values as zero. Then, adjust the total in that table by giving it a little extra based on how high that overall score is: add a decent bonus if it's quite high, a smaller bump if it's pretty good, and a tiny boost if it's just okay. If the total ends up being not very much at all, just remove that university's ranking entry.",
    "id": 95
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `adjust_major_ranking` that takes no parameters. This procedure is designed to iterate through each unique major identified in the `major` table and, for each major, perform conditional updates or deletions on the `major_ranking` table based on specific criteria.\n\nThe procedure begins by declaring three local variables: `v_major_id` of type `integer` to store the ID of the current major being processed, `v_university_count` of type `integer` to store the count of distinct universities associated with a major, and `v_avg_rank` of type `numeric` to store the average rank for a major. It also declares a cursor named `cur_major` which is defined to select all values from the `\"Major_ID\"` column of the `major` table.\n\nThe execution flow starts by opening the `cur_major` cursor. It then enters a loop that continuously fetches the next `\"Major_ID\"` from `cur_major` into the `v_major_id` variable. The loop will `EXIT` when no more rows are found by the `FETCH` operation.\n\nInside the loop, for each `v_major_id` fetched:\n1. It first executes a `SELECT` statement to count the number of distinct `\"University_ID\"` values from the `major_ranking` table where the `\"Major_ID\"` column matches the current `v_major_id`. The result of this count is stored in the `v_university_count` variable.\n2. Immediately after, it executes another `SELECT` statement to calculate the average of the `\"Rank\"` column from the `major_ranking` table where the `\"Major_ID\"` column matches the current `v_major_id`. The result of this average is stored in the `v_avg_rank` variable.\n3. Following these calculations, a conditional block (`IF...ELSIF...ELSE`) is executed:\n    a. If the `v_university_count` is greater than 5, an `UPDATE` statement is performed on the `major_ranking` table. This `UPDATE` decrements the value in the `\"Rank\"` column by 1 for all rows where the `\"Major_ID\"` matches the current `v_major_id` AND the `\"Rank\"` column's value is greater than 1.\n    b. If the first condition is false (i.e., `v_university_count` is not greater than 5) AND the `v_avg_rank` is less than 3, an `UPDATE` statement is performed on the `major_ranking` table. This `UPDATE` increments the value in the `\"Rank\"` column by 1 for all rows where the `\"Major_ID\"` matches the current `v_major_id`.\n    c. If neither of the above conditions is met, a `DELETE` statement is executed on the `major_ranking` table. This `DELETE` removes all rows where the `\"Major_ID\"` matches the current `v_major_id` AND the `\"Rank\"` column's value is greater than 5.\n\nThe loop continues until all major IDs from the `major` table have been processed. After the loop finishes, the `cur_major` cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_major_ranking()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_major_id integer;\n    v_university_count integer;\n    v_avg_rank numeric;\n    cur_major CURSOR FOR SELECT \"Major_ID\" FROM major;\nBEGIN\n    OPEN cur_major;\n    LOOP\n        FETCH cur_major INTO v_major_id;\n        EXIT WHEN NOT FOUND;\n        SELECT COUNT(DISTINCT \"University_ID\") INTO v_university_count FROM major_ranking WHERE \"Major_ID\" = v_major_id;\n        SELECT AVG(\"Rank\") INTO v_avg_rank FROM major_ranking WHERE \"Major_ID\" = v_major_id;\n        IF v_university_count > 5 THEN\n            UPDATE major_ranking SET \"Rank\" = \"Rank\" - 1 WHERE \"Major_ID\" = v_major_id AND \"Rank\" > 1;\n        ELSIF v_avg_rank < 3 THEN\n            UPDATE major_ranking SET \"Rank\" = \"Rank\" + 1 WHERE \"Major_ID\" = v_major_id;\n        ELSE\n            DELETE FROM major_ranking WHERE \"Major_ID\" = v_major_id AND \"Rank\" > 5;\n        END IF;\n    END LOOP;\n    CLOSE cur_major;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL adjust_major_ranking();"
    ],
    "summary": "Create a stored procedure named `adjust_major_ranking` with no parameters. For each major in the `major` table, count its distinct universities and calculate its average rank from the `major_ranking` table. If the university count is greater than 5, decrement the rank by 1 for entries where rank > 1. Else, if the average rank is less than 3, increment the rank by 1. Otherwise, delete entries where the rank is greater than 5.",
    "natural_language": "Create procedure `adjust_major_ranking`. For each major: count its distinct universities and find its average rank. If count > 5 and rank > 1, decrement rank by 1. Else if average rank < 3, increment rank by 1. Else delete entries where rank > 5.",
    "id": 96
  },
  {
    "ir": "Write a PLpgSQL stored procedure that iterates over each row in the university table using a cursor, fetching the University_ID and Enrollment columns into variables v_university_id and v_enrollment, respectively. For each row, if the Enrollment value is greater than 5000, it updates the university table by decreasing the Enrollment value by 500 for the corresponding University_ID. If the Enrollment value is between 2000 and 5000 inclusive, it updates the university table by increasing the Enrollment value by 200 for the corresponding University_ID. If the Enrollment value is less than 1000, it deletes the row from the university table where the University_ID matches v_university_id. The procedure continues this process until all rows have been processed, closing the cursor at the end.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_university_enrollment()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_university_id integer;\n    v_enrollment integer;\n    cur_university CURSOR FOR SELECT \"University_ID\", \"Enrollment\" FROM university;\nBEGIN\n    OPEN cur_university;\n    LOOP\n        FETCH cur_university INTO v_university_id, v_enrollment;\n        EXIT WHEN NOT FOUND;\n        IF v_enrollment > 5000 THEN\n            UPDATE university SET \"Enrollment\" = \"Enrollment\" - 500 WHERE \"University_ID\" = v_university_id;\n        ELSIF v_enrollment BETWEEN 2000 AND 5000 THEN\n            UPDATE university SET \"Enrollment\" = \"Enrollment\" + 200 WHERE \"University_ID\" = v_university_id;\n        ELSE\n            DELETE FROM university WHERE \"University_ID\" = v_university_id AND \"Enrollment\" < 1000;\n        END IF;\n    END LOOP;\n    CLOSE cur_university;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL manage_university_enrollment();"
    ],
    "summary": "Create a stored procedure that processes each university. For each record, if enrollment is greater than 5000, decrease it by 500. If enrollment is between 2000 and 5000 inclusive, increase it by 200. If enrollment is less than 1000, delete the university record.",
    "natural_language": "Hey, can you whip up a stored procedure that goes through all the universities? For each one, if they've got more than 5000 students enrolled, knock it down by 500. If they're sitting between 2000 and 5000 students (including those numbers), bump it up by 200. And if a university has less than 1000 students, just go ahead and delete that record.",
    "id": 97
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named delete_artworks_by_artist_criteria that takes no parameters and processes each artist record from the Artists table by first calculating the artist's age, then counting their associated paintings and sculptures, and finally performing conditional deletions based on the artist's age and artwork counts. The procedure begins by declaring variables v_artist_record of type RECORD to hold artist rows, v_artist_age of type BIGINT for the computed age, and v_painting_count and v_sculpture_count of type BIGINT for the artwork tallies. It then opens a loop that iterates over every row in the Artists table, selecting the artistID, birthYear, and deathYear columns for each artist. For each artist record, if the deathYear is not null, the artist's age is calculated by subtracting birthYear from deathYear; otherwise, the age is computed by subtracting the birthYear from the current year extracted via EXTRACT(YEAR FROM CURRENT_DATE). Next, it executes two separate SELECT COUNT(*) queries: one into v_painting_count from the Paintings table where the painterID equals the current artist's artistID, and another into v_sculpture_count from the Sculptures table where the sculptorID equals the current artist's artistID. The procedure then evaluates a series of conditional IF-ELSIF-ELSE statements: if the artist's age is less than 30 and both v_painting_count and v_sculpture_count are zero, it deletes the artist's record from the Artists table where artistID matches; else if the age is between 30 and 50 inclusive and both painting count and sculpture count are less than 2, it deletes all records from the Paintings table where painterID matches the artist and all records from the Sculptures table where sculptorID matches the artist; else if the age is between 51 and 70 inclusive and the sum of painting and sculpture counts is less than 3, it deletes records from the Paintings table where painterID matches and the year column is less than 1900; else if the age is greater than 70 and the painting count exceeds 10, it deletes records from the Paintings table where painterID matches and the location column is null; else if the artist's birthYear is earlier than 1800 and the sculpture count is zero, it deletes records from the Paintings table where painterID matches and the medium column equals the string 'watercolor'; otherwise, in the final ELSE block, it deletes records from the Sculptures table where sculptorID matches and the location column is null. The loop continues until all artist records have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_artworks_by_artist_criteria()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_artist_record RECORD;\n    v_artist_age BIGINT;\n    v_painting_count BIGINT;\n    v_sculpture_count BIGINT;\nBEGIN\n    FOR v_artist_record IN SELECT \"artistID\", \"birthYear\", \"deathYear\" FROM \"Artists\"\n    LOOP\n        IF v_artist_record.\"deathYear\" IS NOT NULL THEN\n            v_artist_age := v_artist_record.\"deathYear\" - v_artist_record.\"birthYear\";\n        ELSE\n            v_artist_age := EXTRACT(YEAR FROM CURRENT_DATE) - v_artist_record.\"birthYear\";\n        END IF;\n        SELECT COUNT(*) INTO v_painting_count FROM \"Paintings\" WHERE \"painterID\" = v_artist_record.\"artistID\";\n        SELECT COUNT(*) INTO v_sculpture_count FROM \"Sculptures\" WHERE \"sculptorID\" = v_artist_record.\"artistID\";\n        IF v_artist_age < 30 AND v_painting_count = 0 AND v_sculpture_count = 0 THEN\n            DELETE FROM \"Artists\" WHERE \"artistID\" = v_artist_record.\"artistID\";\n        ELSIF v_artist_age BETWEEN 30 AND 50 AND v_painting_count < 2 AND v_sculpture_count < 2 THEN\n            DELETE FROM \"Paintings\" WHERE \"painterID\" = v_artist_record.\"artistID\";\n            DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = v_artist_record.\"artistID\";\n        ELSIF v_artist_age BETWEEN 51 AND 70 AND (v_painting_count + v_sculpture_count) < 3 THEN\n            DELETE FROM \"Paintings\" WHERE \"painterID\" = v_artist_record.\"artistID\" AND \"year\" < 1900;\n        ELSIF v_artist_age > 70 AND v_painting_count > 10 THEN\n            DELETE FROM \"Paintings\" WHERE \"painterID\" = v_artist_record.\"artistID\" AND \"location\" IS NULL;\n        ELSIF v_artist_record.\"birthYear\" < 1800 AND v_sculpture_count = 0 THEN\n            DELETE FROM \"Paintings\" WHERE \"painterID\" = v_artist_record.\"artistID\" AND \"medium\" = 'watercolor';\n        ELSE\n            DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = v_artist_record.\"artistID\" AND \"location\" IS NULL;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL delete_artworks_by_artist_criteria();"
    ],
    "summary": "Create a stored procedure named `delete_artworks_by_artist_criteria` with no parameters. For each artist, calculate their age. Count their associated paintings and sculptures. Based on age and counts, perform conditional deletions: delete the artist if age < 30 and both counts are zero; delete all their paintings and sculptures if age is 30-50 and both counts < 2; delete their pre-1900 paintings if age is 51-70 and total works < 3; delete their paintings with null location if age > 70 and painting count > 10; delete their watercolor paintings if born before 1800 and sculpture count is zero; otherwise, delete their sculptures with null location.",
    "natural_language": "Hey, can you whip up a stored procedure called `delete_artworks_by_artist_criteria` that doesn't need any parameters? Here's the deal: for every artist, figure out how old they are. Then, count up how many paintings and sculptures they've got. Depending on that age and those counts, do some conditional clean-up: if the artist is under 30 and has zero paintings and zero sculptures, just get rid of the artist. If they're between 30 and 50 and have less than 2 of each, delete all their paintings and sculptures. If they're 51 to 70 and have fewer than 3 works total, ditch any of their paintings made before 1900. If they're over 70 and have more than 10 paintings, delete any of their paintings where the location is missing. If they were born before 1800 and have no sculptures, get rid of their watercolor paintings. And if none of that fits, just delete any of their sculptures that don't have a location listed.",
    "id": 98
  },
  {
    "ir": "Write a PLpgSQL stored procedure named redistribute_people_by_age that accepts a single integer parameter p_age_limit. This procedure performs several operations on the people, wedding, and church tables based on the distribution of ages in the people table. First, it calculates the proportion of people with an age less than or equal to p_age_limit, storing this value in the variable v_young_dist. It does this by counting the number of people with an age less than or equal to p_age_limit and dividing by the total number of people with a non-null age. It also calculates the total number of people and stores it in v_total_people. Next, it calculates the proportion of people with an age greater than or equal to p_age_limit, storing this value in v_old_dist, using a similar method. The procedure then evaluates these proportions: if v_young_dist is less than 0.3, it deletes rows from the wedding table where either the Male_ID or Female_ID corresponds to a person younger than p_age_limit. If v_old_dist is greater than 0.7, it inserts new rows into the wedding table by selecting combinations of male and female people both older than p_age_limit, ensuring they are not the same person, and associating them with churches opened after 1950. The number of inserted rows is limited to one-tenth of the total number of people. If neither condition is met, the procedure deletes rows from the church table where the Church_ID does not appear in the wedding table and the church's Open_Date is before 1850.",
    "plsql": "CREATE OR REPLACE PROCEDURE redistribute_people_by_age(p_age_limit integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_young_dist double precision;\n    v_old_dist double precision;\n    v_total_people integer;\nBEGIN\n    SELECT \n        CASE \n            WHEN COUNT(*) = 0 THEN 0\n            ELSE COUNT(CASE WHEN \"Age\" <= p_age_limit THEN 1 END)::double precision / COUNT(*)::double precision\n        END\n    INTO v_young_dist\n    FROM people \n    WHERE \"Age\" IS NOT NULL;\n    \n    SELECT COUNT(*) INTO v_total_people FROM people;\n    \n    SELECT \n        CASE \n            WHEN COUNT(*) = 0 THEN 0\n            ELSE COUNT(CASE WHEN \"Age\" >= p_age_limit THEN 1 END)::double precision / COUNT(*)::double precision\n        END\n    INTO v_old_dist\n    FROM people \n    WHERE \"Age\" IS NOT NULL;\n    \n    IF v_young_dist < 0.3 THEN\n        DELETE FROM wedding\n        WHERE \"Male_ID\" IN (\n            SELECT \"People_ID\" FROM people \n            WHERE \"Age\" < p_age_limit\n        )\n        OR \"Female_ID\" IN (\n            SELECT \"People_ID\" FROM people \n            WHERE \"Age\" < p_age_limit\n        );\n    ELSIF v_old_dist > 0.7 THEN\n        INSERT INTO wedding (\"Church_ID\", \"Male_ID\", \"Female_ID\", \"Year\")\n        SELECT \n            c.\"Church_ID\",\n            p1.\"People_ID\",\n            p2.\"People_ID\",\n            EXTRACT(YEAR FROM CURRENT_DATE)::integer\n        FROM church c\n        CROSS JOIN people p1\n        CROSS JOIN people p2\n        WHERE p1.\"Age\" > p_age_limit\n        AND p2.\"Age\" > p_age_limit\n        AND p1.\"Is_Male\" = 'T'\n        AND p2.\"Is_Male\" = 'F'\n        AND p1.\"People_ID\" <> p2.\"People_ID\"\n        AND c.\"Open_Date\" > 1950\n        LIMIT v_total_people / 10;\n    ELSE\n        DELETE FROM church\n        WHERE \"Church_ID\" NOT IN (\n            SELECT DISTINCT \"Church_ID\" FROM wedding\n        )\n        AND \"Open_Date\" < 1850;\n    END IF;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL redistribute_people_by_age(30);",
      "CALL redistribute_people_by_age(40);",
      "CALL redistribute_people_by_age(25);",
      "CALL redistribute_people_by_age(50);",
      "CALL redistribute_people_by_age(18);"
    ],
    "summary": "Create a stored procedure named `redistribute_people_by_age` that takes an integer parameter `p_age_limit`. Calculate the proportion of people younger/older than or equal to the limit. If the young proportion is less than 0.3, delete weddings involving younger people. If the old proportion is greater than 0.7, insert new weddings for older people using churches opened after 1950 (limit rows to 10% of total people). If neither, delete churches opened before 1850 that are not referenced in any wedding.",
    "natural_language": "What stored procedure logic should be implemented for `redistribute_people_by_age` with an integer parameter `p_age_limit`? Specifically, how should it calculate the proportion of people younger or older than or equal to the limit, and what actions should it take: deleting weddings for younger people if the young proportion is under 0.3, inserting new weddings for older people using churches opened after 1950 (limiting rows to 10% of total people) if the old proportion exceeds 0.7, or deleting churches opened before 1850 that are not in any wedding if neither condition is met?",
    "id": 99
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_country_scores that accepts six input parameters: a bigint parameter p_country_id to identify a specific country record, and five real number parameters p_justice_adjustment, p_health_adjustment, p_education_adjustment, p_economics_adjustment, and p_politics_adjustment, each representing a proposed change to a corresponding score category for that country. The procedure begins by declaring seven local real variables: v_current_overall, v_new_justice, v_new_health, v_new_education, v_new_economics, v_new_politics, and v_new_overall. It first executes a SELECT statement to retrieve the current overall_score from the countries table for the row where the id column matches the provided p_country_id, storing this value into the v_current_overall variable. Based on the value of v_current_overall, the procedure applies a different multiplicative factor to each of the input adjustment parameters before calculating new category scores. If v_current_overall is greater than 95.0, each adjustment is multiplied by 0.5. If it is greater than 90.0 but less than or equal to 95.0, adjustments are multiplied by 0.75. If it is greater than 80.0 but less than or equal to 90.0, adjustments are used directly (multiplied by 1.0). If it is greater than 70.0 but less than or equal to 80.0, adjustments are multiplied by 1.25. For all other cases (v_current_overall less than or equal to 70.0), adjustments are multiplied by 1.5. For each of the five score categoriesâ€”justice_score, health_score, education_score, economics_score, and politics_scoreâ€”the procedure calculates a new value by selecting the current score from the countries table for the specified p_country_id, adding the corresponding adjusted parameter (original adjustment multiplied by the determined factor), and then constraining the result to a range between 0 and 100 inclusive using the expression GREATEST(0, LEAST(100, calculated_value)). The calculated values are stored in the variables v_new_justice, v_new_health, v_new_education, v_new_economics, and v_new_politics, respectively. After computing all five new category scores, the procedure calculates a new overall score v_new_overall by taking the arithmetic mean (sum divided by 5.0) of these five new category scores. Finally, the procedure executes a single UPDATE statement on the countries table, setting the justice_score column to v_new_justice, health_score to v_new_health, education_score to v_new_education, economics_score to v_new_economics, politics_score to v_new_politics, and overall_score to v_new_overall, specifically for the row where the id column equals the input p_country_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_country_scores(\n    p_country_id bigint,\n    p_justice_adjustment real,\n    p_health_adjustment real,\n    p_education_adjustment real,\n    p_economics_adjustment real,\n    p_politics_adjustment real\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_overall real;\n    v_new_justice real;\n    v_new_health real;\n    v_new_education real;\n    v_new_economics real;\n    v_new_politics real;\n    v_new_overall real;\nBEGIN\n    SELECT overall_score INTO v_current_overall FROM countries WHERE id = p_country_id;\n    \n    IF v_current_overall > 95.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 0.5));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 0.5));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 0.5));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 0.5));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 0.5));\n    ELSIF v_current_overall > 90.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 0.75));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 0.75));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 0.75));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 0.75));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 0.75));\n    ELSIF v_current_overall > 80.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment));\n    ELSIF v_current_overall > 70.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 1.25));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 1.25));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 1.25));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 1.25));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 1.25));\n    ELSE\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 1.5));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 1.5));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 1.5));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 1.5));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 1.5));\n    END IF;\n    \n    v_new_overall := (v_new_justice + v_new_health + v_new_education + v_new_economics + v_new_politics) / 5.0;\n    \n    UPDATE countries \n    SET justice_score = v_new_justice,\n        health_score = v_new_health,\n        education_score = v_new_education,\n        economics_score = v_new_economics,\n        politics_score = v_new_politics,\n        overall_score = v_new_overall\n    WHERE id = p_country_id;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL update_country_scores(1, 2.5, -1.0, 0.5, 3.0, -2.0);",
      "CALL update_country_scores(2, -1.5, 2.0, 1.5, 0.0, 1.0);",
      "CALL update_country_scores(3, 5.0, 3.0, -2.0, 4.0, 0.5);",
      "CALL update_country_scores(1, 0.0, 0.0, 0.0, 0.0, 0.0);",
      "CALL update_country_scores(2, -10.0, 15.0, -8.0, 20.0, -5.0);"
    ],
    "summary": "Create a stored procedure named `update_country_scores` that takes a country ID and five adjustment values (justice, health, education, economics, politics). Retrieve the country's current overall score. Apply a multiplier to each adjustment based on the overall score (e.g., 0.5 if >95, 1.5 if <=70). Calculate each new category score by adding the adjusted value to the current score, then clamping the result between 0 and 100. Compute a new overall score as the average of the five new scores. Update the country record with all new scores.",
    "natural_language": "Create procedure `update_country_scores` with country ID and five adjustment values. Get current overall score. Use it to scale each adjustment. Add scaled adjustments to current category scores, limit results to 0-100. Average new scores for new overall. Update country record.",
    "id": 100
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_language_assignments that accepts three parameters: p_operation_type of type text, p_country_name of type text, and p_language_name of type text. The procedure begins by declaring several local variables: v_country_id of type bigint, v_language_id of type bigint, v_country_score of type real, v_language_count of type integer, and v_exists of type boolean. It then retrieves the id and overall_score of the country specified by p_country_name from the countries table and stores them in v_country_id and v_country_score, respectively. Next, it retrieves the id of the language specified by p_language_name from the languages table and stores it in v_language_id. The procedure counts the number of official languages associated with the country identified by v_country_id in the official_languages table and stores this count in v_language_count. It also checks if there is an existing entry in the official_languages table for the combination of v_country_id and v_language_id, storing the result in v_exists. The procedure then evaluates the value of p_operation_type. If p_operation_type is 'ADD', it checks if the language does not already exist for the country and if the country's overall score is greater than 85.0, in which case it inserts a new record into the official_languages table with the country_id set to v_country_id and language_id set to v_language_id. If the country's score is greater than 70.0 and the language count is less than 3, it performs the same insertion. If the score is less than or equal to 70.0 and the language count is less than 2, it also performs the insertion. If p_operation_type is 'REMOVE', the procedure checks if the language exists for the country and if the language count is greater than 1, or if the country's score is less than 60.0, and deletes the corresponding record from the official_languages table. If p_operation_type is 'VALIDATE', the procedure checks if the language count is zero and inserts English as an official language for the country if true. If the language count exceeds 5 and the country's score is less than 80.0, it deletes languages from the official_languages table for the country, retaining only the top 3 languages based on language_id in descending order.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_language_assignments(\n    p_operation_type text,\n    p_country_name text,\n    p_language_name text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_country_id bigint;\n    v_language_id bigint;\n    v_country_score real;\n    v_language_count integer;\n    v_exists boolean;\nBEGIN\n    SELECT id, overall_score INTO v_country_id, v_country_score FROM countries WHERE name = p_country_name;\n    SELECT id INTO v_language_id FROM languages WHERE name = p_language_name;\n    SELECT COUNT(*) INTO v_language_count FROM official_languages WHERE country_id = v_country_id;\n    SELECT EXISTS(SELECT 1 FROM official_languages WHERE country_id = v_country_id AND language_id = v_language_id) INTO v_exists;\n    \n    IF p_operation_type = 'ADD' THEN\n        IF NOT v_exists AND v_country_score > 85.0 THEN\n            INSERT INTO official_languages (country_id, language_id) VALUES (v_country_id, v_language_id);\n        ELSIF NOT v_exists AND v_country_score > 70.0 THEN\n            IF v_language_count < 3 THEN\n                INSERT INTO official_languages (country_id, language_id) VALUES (v_country_id, v_language_id);\n            END IF;\n        ELSIF NOT v_exists THEN\n            IF v_language_count < 2 THEN\n                INSERT INTO official_languages (country_id, language_id) VALUES (v_country_id, v_language_id);\n            END IF;\n        END IF;\n    ELSIF p_operation_type = 'REMOVE' THEN\n        IF v_exists AND v_language_count > 1 THEN\n            DELETE FROM official_languages WHERE country_id = v_country_id AND language_id = v_language_id;\n        ELSIF v_exists AND v_country_score < 60.0 THEN\n            DELETE FROM official_languages WHERE country_id = v_country_id AND language_id = v_language_id;\n        END IF;\n    ELSIF p_operation_type = 'VALIDATE' THEN\n        IF v_language_count = 0 THEN\n            INSERT INTO official_languages (country_id, language_id) \n            SELECT v_country_id, id FROM languages WHERE name = 'English' LIMIT 1;\n        ELSIF v_language_count > 5 AND v_country_score < 80.0 THEN\n            DELETE FROM official_languages \n            WHERE country_id = v_country_id \n            AND language_id IN (\n                SELECT language_id FROM official_languages \n                WHERE country_id = v_country_id \n                ORDER BY language_id DESC \n                LIMIT (v_language_count - 3)\n            );\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL manage_language_assignments('ADD', 'Canada', 'English');",
      "CALL manage_language_assignments('ADD', 'Sweden', 'Swedish');",
      "CALL manage_language_assignments('REMOVE', 'Iceland', 'Icelandic');",
      "CALL manage_language_assignments('VALIDATE', 'Canada', 'French');",
      "CALL manage_language_assignments('ADD', 'Canada', 'French');"
    ],
    "summary": "Create a stored procedure named manage_language_assignments that adds, removes, or validates official language assignments for a country. It checks the country's score and current language count to enforce business rules: adding a language requires specific score and count thresholds, removing a language requires the language to exist and either multiple languages or a low score, and validating ensures at least one language exists and removes excess languages if the score is low.",
    "natural_language": "Hey, can you whip up a stored procedure called manage_language_assignments? It's gotta handle adding, removing, or checking the official languages for a country. Basically, it needs to look at the country's score and how many languages it's already got to follow the rules. For adding a new one, the score and language count gotta be right. To drop a language, it's gotta actually be on the list and the country either has a bunch of languages or a pretty low score. And the validation part just makes sure there's at least one language, and if the score's too low, it'll cut out any extras.",
    "id": 101
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_country_rankings that accepts three parameters: p_min_score and p_max_score of type real, and p_score_type of type text. This procedure processes country rankings based on scores stored in the countries table. It begins by declaring several variables: v_country_record to hold each row from the countries table, v_score_value to store the score of the current country based on the specified score type, v_rank_position to track the rank of each country, v_total_countries to store the total number of countries, and v_percentile to calculate the percentile rank of each country. The procedure first counts the total number of countries and stores this count in v_total_countries. It initializes v_rank_position to zero. It then iterates over each country record, selecting columns id, name, overall_score, justice_score, health_score, education_score, economics_score, and politics_score from the countries table, ordered by the score type specified in p_score_type in descending order. The score type can be 'OVERALL', 'JUSTICE', 'HEALTH', 'EDUCATION', 'ECONOMICS', or 'POLITICS', defaulting to overall_score if an unrecognized type is provided. For each country, the procedure increments v_rank_position by one and assigns the appropriate score to v_score_value based on p_score_type. It calculates v_percentile as the percentile rank of the country using the formula (v_total_countries - v_rank_position + 1) * 100.0 / v_total_countries. If v_score_value is between p_min_score and p_max_score, the procedure updates the overall_score of the country based on its percentile: increasing it by 2.0 if the percentile is 90 or above, by 1.5 if between 75 and 90, by 1.0 if between 50 and 75, decreasing it by 0.5 if between 25 and 50, and decreasing it by 1.0 if below 25. The overall_score is constrained to a maximum of 100 and a minimum of 0 using the LEAST and GREATEST functions, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_country_rankings(\n    p_min_score real,\n    p_max_score real,\n    p_score_type text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_country_record RECORD;\n    v_score_value real;\n    v_rank_position integer;\n    v_total_countries integer;\n    v_percentile real;\nBEGIN\n    SELECT COUNT(*) INTO v_total_countries FROM countries;\n    v_rank_position := 0;\n    \n    FOR v_country_record IN \n        SELECT id, name, overall_score, justice_score, health_score, education_score, economics_score, politics_score\n        FROM countries \n        ORDER BY \n            CASE \n                WHEN p_score_type = 'OVERALL' THEN overall_score\n                WHEN p_score_type = 'JUSTICE' THEN justice_score\n                WHEN p_score_type = 'HEALTH' THEN health_score\n                WHEN p_score_type = 'EDUCATION' THEN education_score\n                WHEN p_score_type = 'ECONOMICS' THEN economics_score\n                WHEN p_score_type = 'POLITICS' THEN politics_score\n                ELSE overall_score\n            END DESC\n    LOOP\n        v_rank_position := v_rank_position + 1;\n        \n        v_score_value := CASE \n            WHEN p_score_type = 'OVERALL' THEN v_country_record.overall_score\n            WHEN p_score_type = 'JUSTICE' THEN v_country_record.justice_score\n            WHEN p_score_type = 'HEALTH' THEN v_country_record.health_score\n            WHEN p_score_type = 'EDUCATION' THEN v_country_record.education_score\n            WHEN p_score_type = 'ECONOMICS' THEN v_country_record.economics_score\n            WHEN p_score_type = 'POLITICS' THEN v_country_record.politics_score\n            ELSE v_country_record.overall_score\n        END;\n        \n        v_percentile := (v_total_countries - v_rank_position + 1) * 100.0 / v_total_countries;\n        \n        IF v_score_value >= p_min_score AND v_score_value <= p_max_score THEN\n            IF v_percentile >= 90.0 THEN\n                UPDATE countries \n                SET overall_score = LEAST(100, overall_score + 2.0)\n                WHERE id = v_country_record.id;\n            ELSIF v_percentile >= 75.0 THEN\n                UPDATE countries \n                SET overall_score = LEAST(100, overall_score + 1.5)\n                WHERE id = v_country_record.id;\n            ELSIF v_percentile >= 50.0 THEN\n                UPDATE countries \n                SET overall_score = LEAST(100, overall_score + 1.0)\n                WHERE id = v_country_record.id;\n            ELSIF v_percentile >= 25.0 THEN\n                UPDATE countries \n                SET overall_score = GREATEST(0, overall_score - 0.5)\n                WHERE id = v_country_record.id;\n            ELSE\n                UPDATE countries \n                SET overall_score = GREATEST(0, overall_score - 1.0)\n                WHERE id = v_country_record.id;\n            END IF;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL process_country_rankings(80.0, 100.0, 'OVERALL');",
      "CALL process_country_rankings(70.0, 95.0, 'HEALTH');",
      "CALL process_country_rankings(85.0, 100.0, 'EDUCATION');",
      "CALL process_country_rankings(60.0, 90.0, 'JUSTICE');",
      "CALL process_country_rankings(75.0, 100.0, 'ECONOMICS');"
    ],
    "summary": "Create a stored procedure named process_country_rankings that updates country overall scores based on their percentile rank for a specified score type (e.g., JUSTICE, HEALTH). It ranks countries by the chosen score, calculates their percentile, and adjusts the overall score up or down based on the percentile bracket, clamping the final score between 0 and 100. Only countries with scores within a provided minimum and maximum range are updated.",
    "natural_language": "Create a stored procedure, which should be named process_country_rankings, that meticulously updates the overall scores for countries by first carefully ranking them according to a user-specified score type, such as JUSTICE or HEALTH. Subsequently, it must calculate the precise percentile rank for each country based on this ordering. Following this, the procedure will thoughtfully adjust each country's overall score either upward or downward, depending on which specific percentile bracket it falls into, while also ensuring that the final computed score is always securely clamped within the acceptable range of 0 to 100. Importantly, this comprehensive update process should only be applied to those countries whose scores for the chosen metric fall gracefully within a provided minimum and maximum threshold.",
    "id": 102
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_customer_resident_data` that accepts two input parameters: `p_customer_id` of type `bigint` and `p_property_id` of type `bigint`. The procedure begins by declaring two local integer variables: `v_resident_count` and `v_thing_count`. It then proceeds to calculate the count of residents for a specific property within the current year. This is achieved by executing a `SELECT COUNT(*)` statement on the `\"Residents\"` table, filtering rows where the `\"property_id\"` column matches the input parameter `p_property_id` and the year extracted from the `\"date_moved_in\"` column is equal to the year extracted from the current timestamp (`CURRENT_TIMESTAMP`). The resulting count is stored in the `v_resident_count` variable. Subsequently, the procedure calculates the count of \"things\" associated with a specific customer. This is done by executing another `SELECT COUNT(*)` statement on the `\"Things\"` table, filtering rows where the `\"thing_id\"` column is present in a subquery. The subquery selects `\"thing_id\"` from the `\"Customer_Events\"` table where the `\"customer_id\"` column matches the input parameter `p_customer_id`. The count obtained from this operation is stored in the `v_thing_count` variable. Following these calculations, the procedure evaluates conditional logic based on the values of `v_resident_count` and `v_thing_count`. If both `v_resident_count` is greater than 0 AND `v_thing_count` is greater than 0, the procedure executes an `INSERT` statement. This statement inserts a new row into the `\"Customer_Events\"` table, setting the `\"customer_id\"` column to `p_customer_id`, the `\"property_id\"` column to `p_property_id`, and the `\"date_moved_in\"` column to the current timestamp (`CURRENT_TIMESTAMP`). Alternatively, if `v_resident_count` is equal to 0 AND `v_thing_count` is greater than 0, the procedure executes a `DELETE` statement. This statement removes rows from the `\"Customer_Events\"` table where the `\"customer_id\"` column matches `p_customer_id` AND the `\"property_id\"` column matches `p_property_id`. In all other cases (i.e., if neither of the above conditions is met), the procedure executes an `UPDATE` statement. This statement modifies the `\"Customers\"` table by setting the `\"customer_details\"` column to an uppercase substring of its current value. Specifically, it takes the first 10 characters of the existing `\"customer_details\"` value using `SUBSTR(\"customer_details\", 1, 10)` and then converts this substring to uppercase using the `UPPER()` function. This update is applied only to the row where the `\"customer_id\"` column matches the input parameter `p_customer_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_customer_resident_data(IN p_customer_id bigint, IN p_property_id bigint)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_resident_count integer;\n    v_thing_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_resident_count\n    FROM \"Residents\"\n    WHERE \"property_id\" = p_property_id\n    AND EXTRACT(YEAR FROM \"date_moved_in\") = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);\n    \n    SELECT COUNT(*) INTO v_thing_count\n    FROM \"Things\"\n    WHERE \"thing_id\" IN (\n        SELECT \"thing_id\" FROM \"Customer_Events\" \n        WHERE \"customer_id\" = p_customer_id\n    );\n    \n    IF v_resident_count > 0 AND v_thing_count > 0 THEN\n        INSERT INTO \"Customer_Events\" (\"customer_id\", \"property_id\", \"date_moved_in\")\n        VALUES (p_customer_id, p_property_id, CURRENT_TIMESTAMP);\n    ELSIF v_resident_count = 0 AND v_thing_count > 0 THEN\n        DELETE FROM \"Customer_Events\"\n        WHERE \"customer_id\" = p_customer_id\n        AND \"property_id\" = p_property_id;\n    ELSE\n        UPDATE \"Customers\"\n        SET \"customer_details\" = UPPER(SUBSTR(\"customer_details\", 1, 10))\n        WHERE \"customer_id\" = p_customer_id;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Things"
    ],
    "call_sqls": [
      "CALL process_customer_resident_data(19, 605);",
      "CALL process_customer_resident_data(5, 879);",
      "CALL process_customer_resident_data(16, 629);",
      "CALL process_customer_resident_data(4, 954);",
      "CALL process_customer_resident_data(10, 500);"
    ],
    "summary": "Create a stored procedure named process_customer_resident_data that processes data based on resident and thing counts. It counts current-year residents for a property and counts things associated with a customer's events. If both counts are positive, it inserts a new customer event. If there are zero residents but positive things, it deletes matching customer events. Otherwise, it updates the customer's details to an uppercase substring.",
    "natural_language": "Create a stored procedure called process_customer_resident_data that handles data depending on some resident numbers and thing totals. It should figure out roughly how many residents for a property there are from this year and get a count of things linked to a customer's various events. If both these amounts are decently high, it adds a new customer event. If there are basically no residents but a fair number of things, it removes any matching customer events. Otherwise, it just adjusts the customer's information to a shorter, uppercase version.",
    "id": 103
  },
  {
    "ir": "Write a PLpgSQL stored procedure named cleanup_expired_policies that accepts four parameters: p_cutoff_date of type date, p_policy_type of type text, p_customer_pattern of type text, and p_days_buffer of type integer. The procedure begins by declaring two integer variables, v_policy_count and v_affected_customers, to store the count of distinct policies and customers affected by the cleanup operation. It then performs a SELECT query on the Customer_Policies table, joining it with the Customers table using the Customer_ID column to count distinct Policy_IDs and Customer_IDs where the End_Date of the policy is earlier than the date calculated by subtracting p_days_buffer from p_cutoff_date, the Policy_Type_Code matches p_policy_type, and the Customer_Details column in the Customers table matches the pattern specified by p_customer_pattern using the LIKE operator. The results of this query are stored in v_policy_count and v_affected_customers. Next, the procedure deletes records from the Claims table where the Policy_ID matches any Policy_ID from the previously described SELECT query. Following this, it deletes records from the Customer_Policies table where the Policy_ID matches any Policy_ID from the same SELECT query. Finally, the procedure raises a notice displaying the number of policies cleaned up and the number of customers affected, using the values stored in v_policy_count and v_affected_customers.",
    "plsql": "CREATE OR REPLACE PROCEDURE cleanup_expired_policies(p_cutoff_date date, p_policy_type text, p_customer_pattern text, p_days_buffer integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_policy_count integer;\n    v_affected_customers integer;\nBEGIN\n    SELECT COUNT(DISTINCT cp.\"Policy_ID\"), COUNT(DISTINCT cp.\"Customer_ID\")\n    INTO v_policy_count, v_affected_customers\n    FROM \"Customer_Policies\" cp\n    JOIN \"Customers\" c ON cp.\"Customer_ID\" = c.\"Customer_ID\"\n    WHERE cp.\"End_Date\" < p_cutoff_date - p_days_buffer\n    AND cp.\"Policy_Type_Code\" = p_policy_type\n    AND c.\"Customer_Details\" LIKE p_customer_pattern;\n    \n    DELETE FROM \"Claims\"\n    WHERE \"Policy_ID\" IN (\n        SELECT cp.\"Policy_ID\"\n        FROM \"Customer_Policies\" cp\n        JOIN \"Customers\" c ON cp.\"Customer_ID\" = c.\"Customer_ID\"\n        WHERE cp.\"End_Date\" < p_cutoff_date - p_days_buffer\n        AND cp.\"Policy_Type_Code\" = p_policy_type\n        AND c.\"Customer_Details\" LIKE p_customer_pattern\n    );\n    \n    DELETE FROM \"Customer_Policies\"\n    WHERE \"Policy_ID\" IN (\n        SELECT cp.\"Policy_ID\"\n        FROM \"Customer_Policies\" cp\n        JOIN \"Customers\" c ON cp.\"Customer_ID\" = c.\"Customer_ID\"\n        WHERE cp.\"End_Date\" < p_cutoff_date - p_days_buffer\n        AND cp.\"Policy_Type_Code\" = p_policy_type\n        AND c.\"Customer_Details\" LIKE p_customer_pattern\n    );\n    \n    RAISE NOTICE 'Cleaned up % policies affecting % customers', v_policy_count, v_affected_customers;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "CALL cleanup_expired_policies('2024-01-01', 'Car', '%America%', 30);",
      "CALL cleanup_expired_policies('2023-12-31', 'Life', '%Willms%', 60);",
      "CALL cleanup_expired_policies('2024-03-15', 'Car', '%Jaskolski%', 0);",
      "CALL cleanup_expired_policies('2022-06-30', 'Life', '%Paucek%', 90);",
      "CALL cleanup_expired_policies('2024-02-01', 'Car', '%%', 7);"
    ],
    "summary": "Create a stored procedure named cleanup_expired_policies that deletes expired policies and their associated claims. It identifies policies ending before a cutoff date (minus a buffer), matching a specific type and customer name pattern. It counts the distinct policies and customers affected, deletes the related claims, then deletes the policies, and finally outputs a notice with the cleanup counts.",
    "natural_language": "Construct a stored procedure, to be named cleanup_expired_policies, which meticulously performs the deletion of all insurance policies that have expired, along with any and all associated claim records. This procedure must first intelligently identify those policies whose termination date occurs prior to a specified cutoff date, which itself is adjusted by subtracting a predefined buffer period for added flexibility. The selection criteria must further ensure that each policy matches a designated type and that the related customer's name aligns with a particular textual pattern. It should then proceed to calculate and record the distinct number of policies and unique customers impacted by this operation. Following this, it must systematically delete all claims linked to these identified policies, and subsequently remove the policies themselves. Finally, the procedure must generate and output a comprehensive notification message that clearly details the counts from the cleanup process.",
    "id": 104
  },
  {
    "ir": "Write a PLpgSQL stored procedure named migrate_customer_data that takes four parameters: p_source_customer_id of type bigint, p_target_customer_id of type bigint, p_policy_type of type text, and p_transfer_date of type date. The procedure is designed to migrate customer policy data from one customer to another within a PostgreSQL database. It begins by declaring two record variables, v_policy_rec and v_claim_rec, and a bigint variable v_new_policy_id. The procedure iterates over each policy record in the Customer_Policies table where the Customer_ID matches p_source_customer_id, the Policy_Type_Code matches p_policy_type, and the Start_Date is greater than or equal to p_transfer_date. For each policy record, it calculates a new Policy_ID by selecting the maximum Policy_ID from the Customer_Policies table, adding one to it, and storing the result in v_new_policy_id. It then inserts a new record into the Customer_Policies table with the new Policy_ID, the target customer ID from p_target_customer_id, the policy type from p_policy_type, and the start and end dates from the current policy record. Subsequently, the procedure iterates over each claim record in the Claims table where the Policy_ID matches the current policy's Policy_ID. For each claim record, it inserts a new record into the Claims table with a new Claim_ID, calculated by selecting the maximum Claim_ID from the Claims table and adding one to it, the new Policy_ID from v_new_policy_id, and the date and amount details from the current claim record. This process effectively transfers all relevant policy and claim data from the source customer to the target customer, ensuring that the new records are uniquely identified by incremented IDs.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_customer_data(p_source_customer_id bigint, p_target_customer_id bigint, p_policy_type text, p_transfer_date date)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_policy_rec RECORD;\n    v_new_policy_id bigint;\n    v_claim_rec RECORD;\nBEGIN\n    FOR v_policy_rec IN\n        SELECT \"Policy_ID\", \"Start_Date\", \"End_Date\"\n        FROM \"Customer_Policies\"\n        WHERE \"Customer_ID\" = p_source_customer_id\n        AND \"Policy_Type_Code\" = p_policy_type\n        AND \"Start_Date\" >= p_transfer_date\n    LOOP\n        SELECT COALESCE(MAX(\"Policy_ID\"), 0) + 1 INTO v_new_policy_id FROM \"Customer_Policies\";\n        \n        INSERT INTO \"Customer_Policies\" (\"Policy_ID\", \"Customer_ID\", \"Policy_Type_Code\", \"Start_Date\", \"End_Date\")\n        VALUES (v_new_policy_id, p_target_customer_id, p_policy_type, v_policy_rec.\"Start_Date\", v_policy_rec.\"End_Date\");\n        \n        FOR v_claim_rec IN\n            SELECT \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\"\n            FROM \"Claims\"\n            WHERE \"Policy_ID\" = v_policy_rec.\"Policy_ID\"\n        LOOP\n            INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\")\n            VALUES ((SELECT COALESCE(MAX(\"Claim_ID\"), 0) + 1 FROM \"Claims\"), v_new_policy_id, v_claim_rec.\"Date_Claim_Made\", v_claim_rec.\"Date_Claim_Settled\", v_claim_rec.\"Amount_Claimed\", v_claim_rec.\"Amount_Settled\");\n        END LOOP;\n    END LOOP;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "CALL migrate_customer_data(1, 2, 'Car', '2017-01-01');",
      "CALL migrate_customer_data(3, 4, 'Life', '2018-01-01');",
      "CALL migrate_customer_data(5, 6, 'Car', '2016-06-15');",
      "CALL migrate_customer_data(7, 8, 'Life', '2017-03-20');",
      "CALL migrate_customer_data(9, 10, 'Car', '2019-01-01');"
    ],
    "summary": "Create a stored procedure named migrate_customer_data that transfers policies and their claims from a source customer to a target customer. It copies policies of a specified type starting on or after a transfer date, generating new IDs for the policies and their associated claims to attach them to the target customer.",
    "natural_language": "Please construct a stored procedure designated as 'migrate_customer_data'. Its function is to transfer policies, along with their associated claims, from a source customer to a target customer. The procedure should duplicate policies of a specified type that commence on or after a designated transfer date. It must generate new identifiers for both the policies and the corresponding claims to facilitate their association with the target customer.",
    "id": 105
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `cleanup_old_test_records` that is designed to remove outdated test records from a database table. This procedure does not accept any input parameters. It declares two local variables: `v_cutoff_date`, which is of type `timestamp with time zone` and will store a specific date and time used as a threshold for record deletion, and `v_test_record`, which is of type `RECORD` and will temporarily hold individual rows retrieved from the `Student_Tests_Taken` table during an iteration. The procedure begins by calculating the `v_cutoff_date`. This calculation involves taking the `CURRENT_TIMESTAMP` (the current date and time with time zone information) and subtracting an `INTERVAL` of '2 years' from it. This effectively sets the cutoff date to two years prior to the moment the procedure is executed. Following this, the procedure enters a `FOR` loop that iterates over a result set. The result set is generated by selecting the `registration_id` and `date_test_taken` columns from the table named `\"Student_Tests_Taken\"`, aliased as `stt`. The `WHERE` clause for this `SELECT` statement filters the records, including only those where the `date_test_taken` column (from the `stt` alias) is strictly less than the previously calculated `v_cutoff_date`. For each `v_test_record` (each row) retrieved by this `SELECT` statement, the procedure executes a `DELETE` statement. This `DELETE` statement targets the `\"Student_Tests_Taken\"` table. The `WHERE` clause for the `DELETE` operation specifies two conditions that must both be met for a row to be deleted: the `registration_id` column must be equal to the `registration_id` value stored in the current `v_test_record`, and the `date_test_taken` column must be equal to the `date_test_taken` value stored in the current `v_test_record`. This ensures that only the specific old test record identified in the loop iteration is removed. The loop continues until all records satisfying the `WHERE` clause of the `SELECT` statement have been processed, and then the procedure concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE cleanup_old_test_records()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cutoff_date timestamp with time zone;\n    v_test_record RECORD;\nBEGIN\n    v_cutoff_date := CURRENT_TIMESTAMP - INTERVAL '2 years';\n    \n    FOR v_test_record IN\n        SELECT stt.\"registration_id\", stt.\"date_test_taken\"\n        FROM \"Student_Tests_Taken\" stt\n        WHERE stt.\"date_test_taken\" < v_cutoff_date\n    LOOP\n        DELETE FROM \"Student_Tests_Taken\"\n        WHERE \"registration_id\" = v_test_record.\"registration_id\"\n        AND \"date_test_taken\" = v_test_record.\"date_test_taken\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "CALL cleanup_old_test_records();"
    ],
    "summary": "Create a stored procedure named cleanup_old_test_records with no parameters. It should delete records from the Student_Tests_Taken table where the date_test_taken is older than two years from the current timestamp.",
    "natural_language": "Hey, can you whip up a stored procedure called cleanup_old_test_records? It doesn't need any parameters. Basically, it should just get rid of any records in the Student_Tests_Taken table where the test was taken more than two years ago from right now.",
    "id": 106
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_actor_duration that performs a conditional update on the actor table. The procedure checks for the existence of a specific row in the actor table by executing a SELECT statement that returns a constant value of 1 from the actor table where the Name column exactly matches the string literal 'Ray Meagher'. If this existence check returns true, indicating a row with the name 'Ray Meagher' is present, the procedure then executes an UPDATE statement on the actor table. This UPDATE statement sets the value of the Duration column to the string literal '1988-2024' exclusively for the row or rows where the Name column is equal to 'Ray Meagher'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_actor_duration()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"actor\" WHERE \"Name\" = 'Ray Meagher') THEN\n        UPDATE \"actor\" SET \"Duration\" = '1988-2024' WHERE \"Name\" = 'Ray Meagher';\n    END IF;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL update_actor_duration();"
    ],
    "summary": "Create a stored procedure named update_actor_duration. If an actor named 'Ray Meagher' exists in the actor table, update that row's Duration column to '1988-2024'.",
    "natural_language": "Please construct a stored procedure designated as 'update_actor_duration'. The procedure's logic must verify the existence of a record for the actor 'Ray Meagher' within the actor table. Should such a record be present, the procedure is to update the value in the Duration column for that specific row to '1988-2024'.",
    "id": 107
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `delete_old_actor` that takes no parameters. This procedure first declares a local variable named `v_min_age` of type `INTEGER`. It then assigns a value to `v_min_age` by calculating the floor of the floating-point number `25.7`, which results in the integer `25`. Subsequently, the procedure executes a conditional block. This conditional block checks if any rows exist in the table named `\"actor\"` where the value in the column named `\"age\"` is strictly less than the value stored in the `v_min_age` variable (which is `25`). If at least one such row exists, the procedure proceeds to delete all rows from the table named `\"actor\"` where the value in the column named `\"age\"` is strictly less than the value stored in the `v_min_age` variable (which is `25`). If no such rows are found, no deletion operation is performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_actor()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_min_age INTEGER;\nBEGIN\n    v_min_age := floor(25.7);\n    IF EXISTS (SELECT 1 FROM \"actor\" WHERE \"age\" < v_min_age) THEN\n        DELETE FROM \"actor\" WHERE \"age\" < v_min_age;\n    END IF;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL delete_old_actor();"
    ],
    "summary": "Create a stored procedure named delete_old_actor with no parameters. It should delete all rows from the actor table where the age is less than 25, but only if at least one such row exists.",
    "natural_language": "Develop a stored procedure called delete_old_actor that accepts no parameters. This procedure must carefully remove every single record from the actor table specifically where the actor's age is confirmed to be below 25 years, but it should only execute this deletion provided that there is at least one existing row satisfying this condition.",
    "id": 108
  },
  {
    "ir": "Write a PLpgSQL stored procedure that updates the Year column in the musical table to the integer value obtained by applying the floor function to the number 1987.9, specifically for the row where the Name column matches 'The Phantom of the Opera', but only if such a row exists in the table. The procedure begins by declaring a local variable v_new_year of type INTEGER, which is then assigned the result of the floor function applied to 1987.9, effectively truncating the decimal part and setting v_new_year to 1987. The procedure then checks for the existence of a row in the musical table where the Name column is equal to 'The Phantom of the Opera' using a conditional statement with the EXISTS function. If such a row is found, the procedure proceeds to update the Year column of that row to the value stored in v_new_year, which is 1987. The update operation is performed using the SQL UPDATE statement, specifying the condition WHERE \"Name\" = 'The Phantom of the Opera' to ensure that only the relevant row is modified.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_musical_year()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_year INTEGER;\nBEGIN\n    v_new_year := floor(1987.9);\n    IF EXISTS (SELECT 1 FROM \"musical\" WHERE \"Name\" = 'The Phantom of the Opera') THEN\n        UPDATE \"musical\" SET \"Year\" = v_new_year WHERE \"Name\" = 'The Phantom of the Opera';\n    END IF;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL update_musical_year();"
    ],
    "summary": "Create a stored procedure with no parameters. If a row exists in the musical table where the Name is 'The Phantom of the Opera', update that row's Year column to 1987.",
    "natural_language": "Hey, can you whip up a stored procedure that doesn't need any inputs? It should check if there's already an entry in the musical table for 'The Phantom of the Opera'. If you find one, just go ahead and set its Year to 1987.",
    "id": 109
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_old_customer_events that declares a local variable v_cutoff_date of type timestamp with time zone, then calculates the value for this variable by subtracting an interval of one year from the current system timestamp obtained via the CURRENT_TIMESTAMP function. The procedure then checks for the existence of at least one record in the \"Customer_Events\" table where the value in the \"date_moved_in\" column is earlier than the calculated v_cutoff_date timestamp. If such a record exists, the procedure executes a DELETE operation on the \"Customer_Events\" table, removing all rows where the \"date_moved_in\" column value is less than the v_cutoff_date timestamp.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_customer_events()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cutoff_date timestamp with time zone;\nBEGIN\n    v_cutoff_date := CURRENT_TIMESTAMP - INTERVAL '1 year';\n\n    IF EXISTS (SELECT 1 FROM \"Customer_Events\" WHERE \"date_moved_in\" < v_cutoff_date) THEN\n        DELETE FROM \"Customer_Events\"\n        WHERE \"date_moved_in\" < v_cutoff_date;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Event_Notes",
      "Customer_Events",
      "Customers",
      "Residents",
      "Residents_Services",
      "Services",
      "Properties",
      "Things",
      "Timed_Locations_of_Things",
      "Timed_Status_of_Things"
    ],
    "call_sqls": [
      "CALL delete_old_customer_events();"
    ],
    "summary": "Create a stored procedure named delete_old_customer_events. It should delete all records from the Customer_Events table where the date_moved_in is older than one year from the current timestamp, but only if at least one such record exists.",
    "natural_language": "Delete customer events older than one year if any exist.",
    "id": 110
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `remove_inactive_residents` that takes no parameters. This procedure is designed to identify and remove records of residents who have been inactive for a significant period, along with their associated dependent records, to maintain data hygiene. The procedure begins by declaring a local variable `v_cutoff_date` of type `timestamp with time zone`. It then calculates the value for `v_cutoff_date` by subtracting an interval of '2 years' from the `CURRENT_TIMESTAMP`, which represents the current date and time with time zone information. Following this, the procedure executes a conditional block. The condition checks if there exists at least one record in the table named `\"Residents\"` where the column `\"date_moved_out\"` has a value strictly less than the calculated `v_cutoff_date`. If this condition evaluates to true, indicating the presence of inactive residents, the procedure proceeds with a series of deletion operations. First, it deletes records from the table named `\"Customer_Events\"`. The deletion criteria for `\"Customer_Events\"` are based on a subquery that selects the `resident_id`, `property_id`, and `date_moved_in` columns from the `\"Residents\"` table where the `\"date_moved_out\"` column is strictly less than `v_cutoff_date`. Specifically, it deletes rows from `\"Customer_Events\"` where the composite key `(resident_id, property_id, date_moved_in)` matches any of the composite keys returned by this subquery. Second, it deletes records from the table named `\"Residents_Services\"`. Similar to the previous deletion, the criteria for `\"Residents_Services\"` are based on a subquery that selects the `resident_id`, `property_id`, and `date_moved_in` columns from the `\"Residents\"` table where the `\"date_moved_out\"` column is strictly less than `v_cutoff_date`. It deletes rows from `\"Residents_Services\"` where the composite key `(resident_id, property_id, date_moved_in)` matches any of the composite keys returned by this subquery. Finally, after deleting the dependent records, the procedure deletes records directly from the table named `\"Residents\"`. This final deletion targets rows in `\"Residents\"` where the `\"date_moved_out\"` column is strictly less than `v_cutoff_date`. If the initial `EXISTS` condition evaluates to false, meaning no inactive residents are found, the procedure concludes without performing any deletion operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_inactive_residents()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cutoff_date timestamp with time zone;\nBEGIN\n    v_cutoff_date := CURRENT_TIMESTAMP - INTERVAL '2 years';\n\n    IF EXISTS (SELECT 1 FROM \"Residents\" WHERE \"date_moved_out\" < v_cutoff_date) THEN\n        -- First delete dependent records from Customer_Events\n        DELETE FROM \"Customer_Events\"\n        WHERE (resident_id, property_id, date_moved_in) IN (\n            SELECT resident_id, property_id, date_moved_in\n            FROM \"Residents\"\n            WHERE \"date_moved_out\" < v_cutoff_date\n        );\n\n        -- Then delete dependent records from Residents_Services\n        DELETE FROM \"Residents_Services\"\n        WHERE (resident_id, property_id, date_moved_in) IN (\n            SELECT resident_id, property_id, date_moved_in\n            FROM \"Residents\"\n            WHERE \"date_moved_out\" < v_cutoff_date\n        );\n        \n        -- Finally delete from Residents\n        DELETE FROM \"Residents\"\n        WHERE \"date_moved_out\" < v_cutoff_date;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Event_Notes",
      "Customer_Events",
      "Customers",
      "Residents",
      "Residents_Services",
      "Services",
      "Properties",
      "Things",
      "Timed_Locations_of_Things",
      "Timed_Status_of_Things"
    ],
    "call_sqls": [
      "CALL remove_inactive_residents();"
    ],
    "summary": "Create a stored procedure named remove_inactive_residents with no parameters. Declare a cutoff date variable as two years before the current timestamp. If residents exist who moved out before this cutoff, first delete their related records from Customer_Events and Residents_Services tables using a composite key match (resident_id, property_id, date_moved_in). Then delete those resident records from the Residents table.",
    "natural_language": "How can I create a stored procedure called 'remove_inactive_residents' that takes no parameters, declares a cutoff date variable set to two years before the current timestamp, and then, if there are residents who moved out before this cutoff, deletes their related records from the Customer_Events and Residents_Services tables using a composite key match on (resident_id, property_id, date_moved_in) before finally deleting those resident records from the Residents table?",
    "id": 111
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named archive_old_service_records that takes no input parameters and begins by declaring a local variable v_cutoff_date of type timestamp with time zone, then calculates a value for this variable by subtracting an interval of three years from the result of the CURRENT_TIMESTAMP function call, which provides the current date and time including time zone, and then checks for the existence of any records in the Residents_Services table where the value in the date_provided column is earlier than the calculated v_cutoff_date value, and if such records exist, performs a delete operation on the Residents_Services table, removing all rows where the date_provided column value is less than the v_cutoff_date timestamp.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_service_records()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cutoff_date timestamp with time zone;\nBEGIN\n    v_cutoff_date := CURRENT_TIMESTAMP - INTERVAL '3 years';\n\n    IF EXISTS (SELECT 1 FROM \"Residents_Services\" WHERE \"date_provided\" < v_cutoff_date) THEN\n        DELETE FROM \"Residents_Services\"\n        WHERE \"date_provided\" < v_cutoff_date;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Event_Notes",
      "Customer_Events",
      "Customers",
      "Residents",
      "Residents_Services",
      "Services",
      "Properties",
      "Things",
      "Timed_Locations_of_Things",
      "Timed_Status_of_Things"
    ],
    "call_sqls": [
      "CALL archive_old_service_records();"
    ],
    "summary": "Create a stored procedure named archive_old_service_records with no parameters. Declare a cutoff date variable as three years before the current timestamp. If records exist in the Residents_Services table where date_provided is earlier than the cutoff, delete all such records.",
    "natural_language": "Please construct a stored procedure designated as 'archive_old_service_records' that accepts no parameters. Within the procedure, initialize a variable to represent a cutoff date, calculated as three years prior to the current system timestamp. Subsequently, verify the existence of any entries in the Residents_Services table with a 'date_provided' value antecedent to the established cutoff. If such records are found, proceed to delete all qualifying rows.",
    "id": 112
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named clean_up_old_thing_status that takes no input parameters and begins by declaring a local variable v_cutoff_date of type timestamp with time zone, then calculates the value for this variable by subtracting an interval of five years from the current system timestamp obtained via the CURRENT_TIMESTAMP function, subsequently checks for the existence of at least one record in the table named \"Timed_Status_of_Things\" where the value in the column \"Date_and_Date\" is earlier than the calculated cutoff date, and if such a record exists, performs a delete operation on the same \"Timed_Status_of_Things\" table to remove all rows where the \"Date_and_Date\" column value is less than the v_cutoff_date value.",
    "plsql": "CREATE OR REPLACE PROCEDURE clean_up_old_thing_status()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cutoff_date timestamp with time zone;\nBEGIN\n    v_cutoff_date := CURRENT_TIMESTAMP - INTERVAL '5 years';\n\n    IF EXISTS (SELECT 1 FROM \"Timed_Status_of_Things\" WHERE \"Date_and_Date\" < v_cutoff_date) THEN\n        DELETE FROM \"Timed_Status_of_Things\"\n        WHERE \"Date_and_Date\" < v_cutoff_date;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Event_Notes",
      "Customer_Events",
      "Customers",
      "Residents",
      "Residents_Services",
      "Services",
      "Properties",
      "Things",
      "Timed_Locations_of_Things",
      "Timed_Status_of_Things"
    ],
    "call_sqls": [
      "CALL clean_up_old_thing_status();"
    ],
    "summary": "Create a stored procedure named clean_up_old_thing_status with no parameters. Declare a cutoff date variable as five years before the current timestamp. If records exist in the Timed_Status_of_Things table where Date_and_Date is earlier than the cutoff, delete all such records.",
    "natural_language": "Delete all records from the Timed_Status_of_Things table where the Date_and_Date is older than five years from the current timestamp. First, create a stored procedure named clean_up_old_thing_status with no parameters to perform this task.",
    "id": 113
  },
  {
    "ir": "Write a PLpgSQL stored procedure named calculate_average_age_by_country that accepts two parameters: p_country_filter of type TEXT, which specifies the country to filter the records by, and p_min_age of type INTEGER, which sets the minimum age threshold for the records to be considered. The procedure begins by declaring two local variables: v_avg_age of type NUMERIC to store the calculated average age, and v_country_name of type TEXT to store the name of the country. It then performs a SELECT operation on the people table, retrieving the Country and the average Age of individuals whose Country matches the value of p_country_filter and whose Age is greater than or equal to p_min_age. The results of this query are stored into the v_country_name and v_avg_age variables. The query groups the results by the Country column to ensure the average is calculated per country. Following the SELECT operation, the procedure checks if v_avg_age is not NULL, indicating that there are records meeting the criteria. If this condition is true, it executes an INSERT operation into the people table, adding a new row with the Name column set to 'Average Age Record', the Country column set to the value of v_country_name, the Is_Male column set to 'T', and the Age column set to the integer value of v_avg_age. This operation effectively records the calculated average age as a new entry in the people table.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_age_by_country(p_country_filter TEXT, p_min_age INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_age NUMERIC;\n    v_country_name TEXT;\nBEGIN\n    SELECT \"Country\", AVG(\"Age\") INTO v_country_name, v_avg_age\n    FROM \"people\"\n    WHERE \"Country\" = p_country_filter AND \"Age\" >= p_min_age\n    GROUP BY \"Country\";\n    \n    IF v_avg_age IS NOT NULL THEN\n        INSERT INTO \"people\" (\"Name\", \"Country\", \"Is_Male\", \"Age\")\n        VALUES ('Average Age Record', v_country_name, 'T', v_avg_age::INTEGER);\n    END IF;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL calculate_average_age_by_country('Canada', 25);",
      "CALL calculate_average_age_by_country('United States', 30);",
      "CALL calculate_average_age_by_country('Sweden', 20);",
      "CALL calculate_average_age_by_country('Canada', 35);",
      "CALL calculate_average_age_by_country('United States', 18);"
    ],
    "summary": "Create a stored procedure named calculate_average_age_by_country that accepts a country filter (TEXT) and a minimum age (INTEGER). Calculate the average age from the people table for the specified country where age meets the minimum threshold. If an average is found, insert a new record into the people table with Name 'Average Age Record', the country, Is_Male 'T', and the calculated average age as an integer.",
    "natural_language": "How can I create a stored procedure called calculate_average_age_by_country that takes a country filter as TEXT and a minimum age as INTEGER, calculates the average age from the people table for that country where age is at least the given minimum, and if an average is found, inserts a new record into the people table with the Name 'Average Age Record', the specified country, Is_Male set to 'T', and the calculated average age as an integer?",
    "id": 114
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two integer parameters, p_start_year and p_end_year, and iterates over records in the wedding table where the Year column is between these two parameters, inclusive. For each record, it selects the Church_ID, Male_ID, Female_ID, and Year from the wedding table and the Name from the church table by joining on Church_ID. It then deletes from the wedding table any row that matches the Church_ID, Male_ID, and Female_ID of the current record in the loop.",
    "plsql": "CREATE OR REPLACE PROCEDURE find_weddings_in_year_range(p_start_year INTEGER, p_end_year INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_wedding_record RECORD;\nBEGIN\n    FOR v_wedding_record IN \n        SELECT w.\"Church_ID\", w.\"Male_ID\", w.\"Female_ID\", w.\"Year\",\n               c.\"Name\" as church_name\n        FROM \"wedding\" w\n        JOIN \"church\" c ON w.\"Church_ID\" = c.\"Church_ID\"\n        WHERE w.\"Year\" BETWEEN p_start_year AND p_end_year\n    LOOP\n        DELETE FROM \"wedding\" \n        WHERE \"Church_ID\" = v_wedding_record.\"Church_ID\" \n        AND \"Male_ID\" = v_wedding_record.\"Male_ID\"\n        AND \"Female_ID\" = v_wedding_record.\"Female_ID\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL find_weddings_in_year_range(2010, 2015);",
      "CALL find_weddings_in_year_range(2000, 2005);",
      "CALL find_weddings_in_year_range(2015, 2020);",
      "CALL find_weddings_in_year_range(1990, 1995);",
      "CALL find_weddings_in_year_range(2020, 2023);"
    ],
    "summary": "Create a stored procedure that accepts a start year and end year (INTEGER). For each wedding record where the Year is between the provided years, get the Church_ID, Male_ID, Female_ID, Year, and the church Name via a join. Delete the current wedding record from the wedding table based on its Church_ID, Male_ID, and Female_ID.",
    "natural_language": "Please construct a stored procedure that receives two integer parameters, designated as the start year and the end year. For each entry in the wedding records where the Year falls within the specified inclusive range, retrieve the Church_ID, Male_ID, Female_ID, Year, and the corresponding church Name by performing a join with the relevant table. Subsequently, delete the identified wedding record from the wedding table, using its composite key of Church_ID, Male_ID, and Female_ID as the deletion criteria.",
    "id": 115
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_people_names that accepts two parameters: p_name_pattern of type TEXT, which specifies a pattern to match against the Name column in the people table, and p_gender_filter of type TEXT, which is used to filter rows based on the Is_Male column in the same table. The procedure begins by declaring three local variables: v_name_array of type TEXT[] to store an array of names, v_person_id of type INTEGER to hold the People_ID of a person, and v_person_name of type TEXT to iterate over names. It then performs a SELECT operation to aggregate all names from the people table into v_name_array where the Name matches the pattern specified by p_name_pattern and the Is_Male column equals the value of p_gender_filter. If the length of v_name_array is greater than zero, indicating that there are matching names, the procedure enters a loop to iterate over each name in v_name_array using the unnest function. Within the loop, it performs another SELECT operation to retrieve the People_ID from the people table for the current name stored in v_person_name, limiting the result to one row. Subsequently, it executes an INSERT operation into the wedding table, inserting a new row with Church_ID set to 1, both Male_ID and Female_ID set to the retrieved v_person_id, and Year set to the current year extracted from the system date using the EXTRACT function. The loop continues until all names in v_name_array have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_people_names(p_name_pattern TEXT, p_gender_filter TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_name_array TEXT[];\n    v_person_id INTEGER;\n    v_person_name TEXT;\nBEGIN\n    SELECT array_agg(\"Name\") INTO v_name_array\n    FROM \"people\"\n    WHERE \"Name\" LIKE p_name_pattern AND \"Is_Male\" = p_gender_filter;\n    \n    IF array_length(v_name_array, 1) > 0 THEN\n        FOR v_person_name IN SELECT unnest(v_name_array)\n        LOOP\n            SELECT \"People_ID\" INTO v_person_id\n            FROM \"people\"\n            WHERE \"Name\" = v_person_name\n            LIMIT 1;\n            \n            INSERT INTO \"wedding\" (\"Church_ID\", \"Male_ID\", \"Female_ID\", \"Year\")\n            VALUES (1, v_person_id, v_person_id, EXTRACT(YEAR FROM CURRENT_DATE));\n        END LOOP;\n    END IF;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL process_people_names('J%', 'T');",
      "CALL process_people_names('A%', 'F');",
      "CALL process_people_names('%son', 'T');",
      "CALL process_people_names('Ricky%', 'T');",
      "CALL process_people_names('M%', 'F');"
    ],
    "summary": "Create a stored procedure named process_people_names that accepts a name pattern and a gender filter. It finds matching names from the people table, then for each name, inserts a record into the wedding table with Church_ID as 1, both Male_ID and Female_ID set to the person's ID, and Year as the current year.",
    "natural_language": "Create a stored procedure called process_people_names that takes a name pattern and a gender filter. It should find matching names in the people table and, for each one, insert a record into the wedding table. Set Church_ID to 1, both Male_ID and Female_ID to the person's ID, and Year to the current year.",
    "id": 116
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `analyze_church_continuations` that accepts two integer input parameters: `p_min_year` and `p_max_year`. The purpose of this procedure is to identify and potentially remove duplicate or erroneous entries in the `\"church\"` table based on continuation relationships. The procedure begins by declaring three local variables: `v_church_id` of type `INTEGER`, `v_church_name` of type `TEXT`, and `v_continuation_name` of type `TEXT`. It then initiates a loop that iterates over a result set obtained by selecting the `\"Church_ID\"`, `\"Name\"`, and `\"Continuation_of\"` columns from the `\"church\"` table. The rows included in this result set are filtered by two conditions: first, the `\"Open_Date\"` column must be between the values provided by the `p_min_year` and `p_max_year` parameters (inclusive); and second, the `\"Continuation_of\"` column must not be `NULL`. For each row retrieved by this `SELECT` statement, the values are assigned to the corresponding local variables `v_church_id`, `v_church_name`, and `v_continuation_name`. Inside this loop, a conditional statement checks if the `v_continuation_name` variable is not `NULL`. If this condition is true, the procedure executes a `DELETE` statement. This `DELETE` statement targets rows in the `\"church\"` table where the `\"Name\"` column matches the value stored in `v_continuation_name` AND the `\"Church_ID\"` column is not equal to the value stored in `v_church_id`. This effectively attempts to remove entries from the `\"church\"` table that are identified as continuations of another church, ensuring that the original church (identified by `v_church_id`) is not deleted. The loop continues until all qualifying rows from the initial `SELECT` statement have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_church_continuations(p_min_year INTEGER, p_max_year INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_church_id INTEGER;\n    v_church_name TEXT;\n    v_continuation_name TEXT;\nBEGIN\n    FOR v_church_id, v_church_name, v_continuation_name IN \n        SELECT \"Church_ID\", \"Name\", \"Continuation_of\"\n        FROM \"church\"\n        WHERE \"Open_Date\" BETWEEN p_min_year AND p_max_year\n          AND \"Continuation_of\" IS NOT NULL\n    LOOP\n        IF v_continuation_name IS NOT NULL THEN\n            DELETE FROM \"church\"\n            WHERE \"Name\" = v_continuation_name\n            AND \"Church_ID\" != v_church_id;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL analyze_church_continuations(1800, 1850);",
      "CALL analyze_church_continuations(1830, 1840);",
      "CALL analyze_church_continuations(1820, 1835);",
      "CALL analyze_church_continuations(1810, 1860);",
      "CALL analyze_church_continuations(1836, 1836);"
    ],
    "summary": "Create a stored procedure named analyze_church_continuations that accepts a minimum and maximum year. For churches opened within that period that have a continuation reference, delete any other church record with a matching continuation name, excluding the original church itself.",
    "natural_language": "Create procedure analyze_church_continuations with min and max year params. For churches opened in that range that have a continuation reference, delete other churches with the same continuation name, but not the original.",
    "id": 117
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `delete_institution_records` that accepts a single input parameter. This parameter, named `p_institution_id`, is of the `integer` data type and represents the unique identifier of an institution whose records are to be removed from the database. The procedure's sole operation is to perform a `DELETE` statement on the `institution` table. This `DELETE` operation targets rows within the `institution` table where the value in the column named `\"Institution_ID\"` exactly matches the value provided by the `p_institution_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_institution_records(p_institution_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM institution\n    WHERE \"Institution_ID\" = p_institution_id;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL delete_institution_records(1);",
      "CALL delete_institution_records(2);",
      "CALL delete_institution_records(3);",
      "CALL delete_institution_records(99);",
      "CALL delete_institution_records(100);"
    ],
    "summary": "Create a stored procedure named delete_institution_records that accepts an institution ID and deletes the corresponding record from the institution table.",
    "natural_language": "Construct a stored procedure, which we shall name delete_institution_records, that is designed to meticulously accept a specific institution identifier as its input parameter and subsequently performs the precise and complete deletion of the corresponding, singular record from the comprehensive institution table.",
    "id": 118
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_championship_records that accepts a single mandatory input parameter named p_institution_id of integer data type, which is used to identify a specific institution, and performs a delete operation on the database table named \"Championship\" where the procedure deletes all rows from the \"Championship\" table for which the value in the column named \"Institution_ID\" is exactly equal to the integer value provided in the p_institution_id input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_championship_records(p_institution_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Championship\"\n    WHERE \"Institution_ID\" = p_institution_id;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL delete_championship_records(1);",
      "CALL delete_championship_records(2);",
      "CALL delete_championship_records(3);",
      "CALL delete_championship_records(10);",
      "CALL delete_championship_records(99);"
    ],
    "summary": "Create a stored procedure named delete_championship_records that accepts an institution ID and deletes all records for that institution from the Championship table.",
    "natural_language": "How can I create a stored procedure called delete_championship_records that takes an institution ID and removes all records for that institution from the Championship table?",
    "id": 119
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_owner_demographics that accepts three text parameters: p_state_param to filter by state, p_age_threshold to compare against dog ages, and p_zip_pattern to match the beginning of zip codes. The procedure declares a cursor named v_cursor that selects owner_id, first_name, and last_name from the public.\"Owners\" table, along with a count of associated dog records from the public.\"Dogs\" table via a left join on owner_id, where the owner's state equals p_state_param and the owner's zip_code starts with the string in p_zip_pattern, grouping the results by owner_id, first_name, and last_name. It then opens this cursor and enters a loop, fetching each row into local variables v_owner_id, v_first_name, v_last_name, and v_dog_count, exiting the loop when no more rows are found. For each fetched row, if the dog_count is zero, it inserts a new record into the public.\"Dogs\" table using the next value from the sequence dogs_seq for dog_id, setting the owner_id to the current v_owner_id, abandoned_yn to '0', breed_code to 'BUL', size_code to 'MED', name to 'Default', age to the p_age_threshold parameter value, date_of_birth to the current date, gender to '1', weight to '10.0', and date_arrived to the current timestamp. If the dog_count is greater than two, it deletes records from the public.\"Dogs\" table where the owner_id matches v_owner_id, the abandoned_yn column equals '1', and the age column (cast to integer) is greater than the p_age_threshold parameter (cast to integer). Otherwise, for cases where dog_count is one or two, it updates the public.\"Owners\" table by setting the email_address column to its uppercase equivalent using the UPPER function for the row where owner_id equals v_owner_id. After processing all cursor rows, the procedure closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_owner_demographics(p_state_param text, p_age_threshold text, p_zip_pattern text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cursor CURSOR FOR SELECT o.owner_id, o.first_name, o.last_name, COUNT(d.dog_id) as dog_count\n                       FROM public.\"Owners\" o\n                       LEFT JOIN public.\"Dogs\" d ON o.owner_id = d.owner_id\n                       WHERE o.state = p_state_param\n                       AND o.zip_code LIKE p_zip_pattern || '%'\n                       GROUP BY o.owner_id, o.first_name, o.last_name;\n    v_owner_id bigint;\n    v_first_name text;\n    v_last_name text;\n    v_dog_count integer;\nBEGIN\n    OPEN v_cursor;\n    LOOP\n        FETCH v_cursor INTO v_owner_id, v_first_name, v_last_name, v_dog_count;\n        EXIT WHEN NOT FOUND;\n        \n        IF v_dog_count = 0 THEN\n            INSERT INTO public.\"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived)\n            VALUES (nextval('dogs_seq'), v_owner_id, '0', 'BUL', 'MED', 'Default', p_age_threshold, CURRENT_DATE, '1', '10.0', CURRENT_TIMESTAMP);\n        ELSIF v_dog_count > 2 THEN\n            DELETE FROM public.\"Dogs\"\n            WHERE owner_id = v_owner_id\n            AND abandoned_yn = '1'\n            AND age::integer > p_age_threshold::integer;\n        ELSE\n            UPDATE public.\"Owners\" SET email_address = UPPER(email_address) WHERE owner_id = v_owner_id;\n        END IF;\n    END LOOP;\n    CLOSE v_cursor;\nEND;\n$$;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Breeds",
      "Sizes",
      "Treatments"
    ],
    "call_sqls": [
      "CALL process_owner_demographics('Wisconsin', '5', '931');",
      "CALL process_owner_demographics('Virginia', '10', '452');",
      "CALL process_owner_demographics('Vermont', '3', '026');",
      "CALL process_owner_demographics('California', '7', '902');",
      "CALL process_owner_demographics('Texas', '12', '750');"
    ],
    "summary": "Create a stored procedure named process_owner_demographics that filters owners by state and zip code pattern. For each owner, if they have no dogs, insert a default dog record. If they have more than two dogs, delete abandoned dogs older than a specified age threshold. Otherwise, update the owner's email to uppercase.",
    "natural_language": "Create a stored procedure called process_owner_demographics that picks out owners based on a general area and a zip code that looks a certain way. For each of those owners, if they don't seem to have any dogs, put in a standard dog entry. If they have quite a few dogs, get rid of the ones that seem neglected and are older than a certain number of years. Otherwise, just change the owner's email to all capital letters.",
    "id": 120
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `reconcile_dog_treatments` that accepts three input parameters: `p_start_date` of type `timestamp`, `p_end_date` of type `timestamp`, and `p_treatment_type` of type `text`. The purpose of this procedure is to iterate through a specific subset of dogs and, for each dog, perform conditional operations on their treatments based on the count and cost of treatments of a specified type.\n\nThe procedure begins by declaring three local variables: `v_dog_record` of type `RECORD` to hold dog-related data during iteration, `v_treatment_count` of type `integer` to store the number of treatments, and `v_total_cost` of type `numeric` to accumulate the total cost of treatments. Another local variable, `v_avg_cost` of type `numeric`, is declared to store the calculated average cost of treatments.\n\nThe core logic involves a `FOR` loop that iterates over a result set obtained by selecting `dog_id`, `name`, and `breed_code` from the `\"Dogs\"` table. The selection is filtered by a `WHERE` clause, ensuring that only dogs whose `date_arrived` falls inclusively between the `p_start_date` and `p_end_date` parameters are considered. For each `v_dog_record` retrieved in this loop, the procedure executes a `SELECT` statement. This `SELECT` statement counts the number of treatments and calculates the sum of `cost_of_treatment` from the `\"Treatments\"` table. The `COALESCE` function is used to ensure that if `SUM(cost_of_treatment)` returns `NULL` (meaning no treatments are found), `0` is used instead. These aggregated values are then assigned to `v_treatment_count` and `v_total_cost`, respectively. The `SELECT` statement is filtered by a `WHERE` clause that matches the `dog_id` with `v_dog_record.dog_id` and the `treatment_type_code` with the `p_treatment_type` parameter.\n\nFollowing this aggregation, a conditional `IF-ELSIF-ELSE` block determines the subsequent action:\n\n1.  **`IF v_treatment_count > 3 THEN`**: If the `v_treatment_count` for the current dog and specified treatment type is greater than 3, the procedure calculates `v_avg_cost`. This calculation uses a `CASE` statement: if `v_treatment_count` is greater than 0, `v_avg_cost` is computed as `v_total_cost` divided by `v_treatment_count`; otherwise, it is set to `0`. After calculating `v_avg_cost`, an `INSERT` statement is executed into the `\"Treatments\"` table. A new `treatment_id` is generated using `nextval('treatments_treatment_id_seq')`. The `dog_id` is set to `v_dog_record.dog_id`, `professional_id` is set to `100`, `treatment_type_code` is set to the literal string `'EXAM'`, `date_of_treatment` is set to `CURRENT_TIMESTAMP`, and `cost_of_treatment` is set to the calculated `v_avg_cost`.\n\n2.  **`ELSIF v_treatment_count = 0 THEN`**: If the `v_treatment_count` for the current dog and specified treatment type is exactly 0, the procedure performs two `DELETE` operations. First, it deletes all records from the `\"Treatments\"` table where the `dog_id` matches `v_dog_record.dog_id`. Second, it deletes records from the `\"Dogs\"` table where the `dog_id` matches `v_dog_record.dog_id` AND the `abandoned_yn` column has a value of `'1'`.\n\n3.  **`ELSE`**: If neither of the above conditions is met (meaning `v_treatment_count` is between 1 and 3, inclusive), an `UPDATE` statement is executed on the `\"Treatments\"` table. This `UPDATE` increases the `cost_of_treatment` by 10% (multiplying it by `1.1`). The `UPDATE` is applied to records where the `dog_id` matches `v_dog_record.dog_id`, the `treatment_type_code` matches `p_treatment_type`, AND the `date_of_treatment` is older than 30 days from the `CURRENT_TIMESTAMP` (specifically, `CURRENT_TIMESTAMP - INTERVAL '30 days'`).\n\nThe loop continues until all dogs matching the initial `date_arrived` criteria have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE reconcile_dog_treatments(p_start_date timestamp, p_end_date timestamp, p_treatment_type text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dog_record RECORD;\n    v_treatment_count integer;\n    v_total_cost numeric;\n    v_avg_cost numeric;\nBEGIN\n    FOR v_dog_record IN SELECT d.dog_id, d.name, d.breed_code FROM \"Dogs\" d WHERE d.date_arrived BETWEEN p_start_date AND p_end_date\n    LOOP\n        SELECT COUNT(*), COALESCE(SUM(cost_of_treatment), 0) INTO v_treatment_count, v_total_cost\n        FROM \"Treatments\"\n        WHERE dog_id = v_dog_record.dog_id\n        AND treatment_type_code = p_treatment_type;\n        \n        IF v_treatment_count > 3 THEN\n            v_avg_cost := CASE WHEN v_treatment_count > 0 THEN v_total_cost / v_treatment_count ELSE 0 END;\n            INSERT INTO \"Treatments\" (treatment_id, dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment)\n            VALUES (nextval('treatments_treatment_id_seq'), v_dog_record.dog_id, 100, 'EXAM', CURRENT_TIMESTAMP, v_avg_cost);\n        ELSIF v_treatment_count = 0 THEN\n            DELETE FROM \"Treatments\" WHERE dog_id = v_dog_record.dog_id;\n            DELETE FROM \"Dogs\" WHERE dog_id = v_dog_record.dog_id AND abandoned_yn = '1';\n        ELSE\n            UPDATE \"Treatments\" SET cost_of_treatment = cost_of_treatment * 1.1\n            WHERE dog_id = v_dog_record.dog_id\n            AND treatment_type_code = p_treatment_type\n            AND date_of_treatment < CURRENT_TIMESTAMP - INTERVAL '30 days';\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Breeds",
      "Sizes",
      "Treatments"
    ],
    "call_sqls": [
      "CALL reconcile_dog_treatments('2017-01-01 00:00:00', '2017-12-31 23:59:59', 'EXAM');",
      "CALL reconcile_dog_treatments('2018-01-01 00:00:00', '2018-03-31 23:59:59', 'VAC');",
      "CALL reconcile_dog_treatments('2017-06-01 00:00:00', '2017-08-31 23:59:59', 'WALK');",
      "CALL reconcile_dog_treatments('2016-01-01 00:00:00', '2016-12-31 23:59:59', 'GROOM');",
      "CALL reconcile_dog_treatments('2017-09-01 00:00:00', '2017-11-30 23:59:59', 'MEDS');"
    ],
    "summary": "Create a stored procedure named `reconcile_dog_treatments` that takes a start date, end date, and treatment type. For each dog that arrived within the date range, count its treatments of that type and sum their cost. If the count is greater than 3, insert a new 'EXAM' treatment with a cost equal to the average cost. If the count is zero, delete all treatments for that dog and also delete the dog if it is marked as abandoned. Otherwise (count 1-3), increase the cost of matching treatments older than 30 days by 10%.",
    "natural_language": "Alright, so we need a stored procedure called `reconcile_dog_treatments`. It's gotta take a start date, an end date, and a treatment type. For every pooch that showed up between those dates, we'll tally up how many treatments of that type it got and add up what they cost. If the count's more than 3, we gotta slip in a new 'EXAM' treatment, and its cost should be the average of the others. If the count's a big fat zero, we need to wipe out all treatments for that dog, and if the dog's marked as abandoned, boot it from the records too. For the restâ€”you know, if the count's between 1 and 3â€”just bump up the cost by 10% for any matching treatments that are older than a month.",
    "id": 121
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_customer_account_type` that accepts four input parameters: `p_customer_name` of type `text`, representing the full name of a customer; `p_new_account_type` of type `text`, representing the new account type to be assigned; `p_state_filter` of type `text`, representing the state, county, or province to filter customers by; and `p_min_accounts` of type `integer`, representing the minimum number of accounts a customer must have for their accounts to be updated. The procedure declares two local variables: `v_customer_id` of type `bigint` to store the identified customer's ID, and `v_account_count` of type `integer` to store the number of accounts associated with the identified customer.\n\nThe procedure begins by attempting to retrieve the `customer_id` from the `\"Customers\"` table. It selects the `customer_id` from the alias `c` of the `\"Customers\"` table and stores it into the `v_customer_id` variable. This selection is performed based on two conditions: first, the concatenation of the `customer_first_name` and `customer_last_name` columns from the `\"Customers\"` table, converted to lowercase using the `lower()` function, must exactly match the `p_customer_name` parameter, also converted to lowercase using the `lower()` function; second, the `state_county_province` column from the `\"Customers\"` table must exactly match the `p_state_filter` parameter.\n\nFollowing this initial selection, the procedure checks if a `v_customer_id` was successfully found (i.e., `v_customer_id` is not `NULL`). If a customer ID was found, the procedure proceeds to count the number of accounts associated with this customer. It selects the count of all rows from the `\"Accounts\"` table, aliased as `a`, and stores this count into the `v_account_count` variable. This count is filtered by ensuring that the `customer_id` column in the `\"Accounts\"` table matches the `v_customer_id` that was previously identified.\n\nAfter determining the account count, the procedure then evaluates a conditional statement: if the `v_account_count` is greater than or equal to the `p_min_accounts` parameter, it proceeds to update the customer's accounts. In this case, it performs an `UPDATE` operation on the `\"Accounts\"` table. For all rows in the `\"Accounts\"` table where the `customer_id` column matches the `v_customer_id`, the `other_account_details` column is set to the value provided by the `p_new_account_type` parameter. If `v_customer_id` is `NULL` or `v_account_count` is less than `p_min_accounts`, no update operation is performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_customer_account_type(\n    p_customer_name text,\n    p_new_account_type text,\n    p_state_filter text,\n    p_min_accounts integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_customer_id bigint;\n    v_account_count integer;\nBEGIN\n    SELECT c.customer_id INTO v_customer_id\n    FROM \"Customers\" c\n    WHERE lower(c.customer_first_name || ' ' || c.customer_last_name) = lower(p_customer_name)\n    AND c.state_county_province = p_state_filter;\n\n    IF v_customer_id IS NOT NULL THEN\n        SELECT COUNT(*) INTO v_account_count\n        FROM \"Accounts\" a\n        WHERE a.customer_id = v_customer_id;\n\n        IF v_account_count >= p_min_accounts THEN\n            UPDATE \"Accounts\"\n            SET other_account_details = p_new_account_type\n            WHERE customer_id = v_customer_id;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoice_Line_Items",
      "Invoices",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "CALL update_customer_account_type('Dee Larkin', 'Premium', 'WestVirginia', 1);",
      "CALL update_customer_account_type('Brennon Weimann', 'Gold', 'Oklahoma', 2);",
      "CALL update_customer_account_type('Joesph Schaefer', 'Silver', 'Arkansas', 1);",
      "CALL update_customer_account_type('Dee Larkin', 'VIP', 'WestVirginia', 3);",
      "CALL update_customer_account_type('Brennon Weimann', 'Regular', 'Oklahoma', 1);"
    ],
    "summary": "Create a stored procedure named `update_customer_account_type` that takes a customer name, new account type, state filter, and minimum account count. Find the customer ID by matching the full name (case-insensitive) and state. If found, count the customer's accounts. If the account count meets or exceeds the minimum, update the `other_account_details` for all of that customer's accounts to the new account type.",
    "natural_language": "Hey, can you whip up a stored procedure called `update_customer_account_type`? It needs to take a customer's name, a new type of account, a state to filter by, and a minimum number of accounts. First, look up the customer's ID by matching their full name (don't worry about capitalization) and their state. If you find 'em, count up how many accounts they have. If that count is at least the minimum you got, then go ahead and update the `other_account_details` for every single one of that customer's accounts to the new account type.",
    "id": 122
  },
  {
    "ir": "Write a PLpgSQL stored procedure named generate_invoice_summary that accepts four parameters: p_start_date and p_end_date, both of type timestamp with time zone, which define the date range for filtering invoices; p_min_invoice_amount of type numeric, which specifies the minimum total amount for invoices to be considered; and p_country_filter of type text, which is used to filter customers based on their country. The procedure begins by declaring an integer variable v_invoice_count to store the count of invoices that meet the specified criteria. It then executes a SELECT statement to count the number of invoices from the \"Invoices\" table, joining with the \"Orders\" table on the order_id column and the \"Customers\" table on the customer_id column. The WHERE clause filters invoices by checking if the invoice_date falls between p_start_date and p_end_date, if the customer's country matches p_country_filter, and if the total amount of the invoice, calculated by summing the product of product_price and product_quantity from the \"Invoice_Line_Items\" table for each invoice_number, is greater than or equal to p_min_invoice_amount. The result of this count is stored in v_invoice_count. Finally, the procedure inserts a new record into the \"Financial_Transactions\" table with NULL for account_id, 'Invoice Summary' as the transaction_type, the current timestamp as transaction_date, and the value of v_invoice_count as transaction_amount.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_invoice_summary(\n    p_start_date timestamp with time zone,\n    p_end_date timestamp with time zone,\n    p_min_invoice_amount numeric,\n    p_country_filter text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_invoice_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_invoice_count\n    FROM \"Invoices\" i\n    JOIN \"Orders\" o ON i.order_id = o.order_id\n    JOIN \"Customers\" c ON o.customer_id = c.customer_id\n    WHERE i.invoice_date BETWEEN p_start_date AND p_end_date\n    AND c.country = p_country_filter\n    AND (SELECT SUM(ili.product_price * ili.product_quantity::numeric)\n         FROM \"Invoice_Line_Items\" ili\n         WHERE ili.invoice_number = i.invoice_number) >= p_min_invoice_amount;\n\n    INSERT INTO \"Financial_Transactions\" (account_id, transaction_type, transaction_date, transaction_amount)\n    VALUES (NULL, 'Invoice Summary', CURRENT_TIMESTAMP, v_invoice_count);\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoice_Line_Items",
      "Invoices",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "CALL generate_invoice_summary('2018-01-01 00:00:00+00', '2018-03-31 23:59:59+00', 500.00, 'USA');",
      "CALL generate_invoice_summary('2017-01-01 00:00:00+00', '2017-12-31 23:59:59+00', 1000.00, 'USA');",
      "CALL generate_invoice_summary('2018-03-01 00:00:00+00', '2018-03-15 23:59:59+00', 200.00, 'USA');",
      "CALL generate_invoice_summary('2012-01-01 00:00:00+00', '2018-12-31 23:59:59+00', 0.00, 'USA');",
      "CALL generate_invoice_summary('2018-03-01 00:00:00+00', '2018-03-01 23:59:59+00', 100.00, 'USA');"
    ],
    "summary": "Create a stored procedure named `generate_invoice_summary` that takes a start date, end date, minimum invoice amount, and country filter. Count the invoices within the date range where the customer's country matches the filter and the invoice's total amount (sum of line item price * quantity) meets or exceeds the minimum. Insert a record into the `Financial_Transactions` table with the count as the transaction amount, 'Invoice Summary' as the type, and the current timestamp.",
    "natural_language": "Create a stored procedure called `generate_invoice_summary` that uses a start date, an end date, a not-too-small invoice amount, and a country. It should figure out roughly how many invoices fall within that general time period for customers sort of from that country, where the total money from the invoice seems decently high. Then, it needs to put an entry into the `Financial_Transactions` table with that approximate count as the amount, labeled as 'Invoice Summary', and stamped with the current time.",
    "id": 123
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `adjust_account_balances` that accepts four input parameters: `p_customer_id` of type `bigint`, `p_adjustment_factor` of type `numeric`, `p_min_balance` of type `numeric`, and `p_max_balance` of type `numeric`. The purpose of this procedure is to modify existing records within the `Accounts` table. Specifically, it performs an `UPDATE` operation on the `Accounts` table. For each row that satisfies the specified conditions, the `account_name` column is updated. The new value for `account_name` is derived by first casting the current `account_name` value, which is stored as `text`, to a `numeric` data type. This numeric representation of `account_name` is then multiplied by the `p_adjustment_factor` parameter. The result of this multiplication, which is a `numeric` value, is then cast back to a `text` data type before being assigned as the new value for the `account_name` column. The `UPDATE` operation is conditionally applied only to those rows where two conditions are met simultaneously: first, the `customer_id` column in the `Accounts` table must exactly match the value provided by the `p_customer_id` input parameter; and second, the `account_name` column, after being cast to a `numeric` data type, must fall within the inclusive range defined by the `p_min_balance` and `p_max_balance` input parameters. That is, the numeric representation of `account_name` must be greater than or equal to `p_min_balance` AND less than or equal to `p_max_balance`.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_account_balances(\n    p_customer_id bigint,\n    p_adjustment_factor numeric,\n    p_min_balance numeric,\n    p_max_balance numeric\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"Accounts\"\n    SET account_name = (account_name::numeric * p_adjustment_factor)::text\n    WHERE customer_id = p_customer_id\n    AND account_name::numeric BETWEEN p_min_balance AND p_max_balance;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoice_Line_Items",
      "Invoices",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "CALL adjust_account_balances(8, 1.10, 100, 1000);",
      "CALL adjust_account_balances(3, 0.95, 200, 800);",
      "CALL adjust_account_balances(1, 1.05, 50, 500);",
      "CALL adjust_account_balances(12, 1.15, 0, 10000);",
      "CALL adjust_account_balances(5, 0.90, 10, 2000);"
    ],
    "summary": "Create a stored procedure named `adjust_account_balances` that takes a customer ID, adjustment factor, minimum balance, and maximum balance. Update the `Accounts` table for the specified customer. For each account where the `account_name` (when cast to numeric) is between the minimum and maximum balance (inclusive), set the new `account_name` to the result of multiplying its numeric value by the adjustment factor and casting back to text.",
    "natural_language": "Please construct a stored procedure designated as `adjust_account_balances`. This procedure shall accept the following parameters: a customer identifier, an adjustment factor, a minimum balance threshold, and a maximum balance threshold. The procedure is to execute an update on the `Accounts` table, specifically for records associated with the provided customer. For each qualifying account, where the numeric interpretation of the `account_name` field falls within the inclusive range defined by the minimum and maximum balance parameters, the `account_name` value must be recalculated. The new value shall be derived by multiplying the numeric interpretation of the original `account_name` by the supplied adjustment factor, subsequently casting the resultant product back to a textual data type.",
    "id": 124
  },
  {
    "ir": "Write a PLpgSQL stored procedure named delete_artist_works that accepts a single parameter artist_name of type text, which represents the last name of an artist. The procedure begins by declaring a variable target_artist_id of type bigint to store the artist's ID. It then performs a SELECT operation on the \"Artists\" table to retrieve the \"artistID\" of the artist whose \"lname\" matches the provided artist_name, storing the result in the target_artist_id variable. If the target_artist_id is not NULL, indicating that an artist with the given last name exists, the procedure proceeds to delete records from two tables: \"Sculptures\" and \"Paintings\". Specifically, it deletes all rows from the \"Sculptures\" table where the \"sculptorID\" column matches the target_artist_id, and similarly, deletes all rows from the \"Paintings\" table where the \"painterID\" column matches the target_artist_id. The procedure does not perform any operations if no artist with the specified last name is found.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_artist_works(artist_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    target_artist_id bigint;\nBEGIN\n    SELECT \"artistID\" INTO target_artist_id FROM \"Artists\" WHERE \"lname\" = artist_name;\n    \n    IF target_artist_id IS NOT NULL THEN\n        DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = target_artist_id;\n        DELETE FROM \"Paintings\" WHERE \"painterID\" = target_artist_id;\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL delete_artist_works('Picasso');",
      "CALL delete_artist_works('Seurat');",
      "CALL delete_artist_works('van Gogh');",
      "CALL delete_artist_works('Monet');",
      "CALL delete_artist_works('Rembrandt');"
    ],
    "summary": "Create a stored procedure named `delete_artist_works` that takes an artist's last name. Find the artist's ID from the `Artists` table using the last name. If the artist is found, delete all records for that artist from both the `Sculptures` table (using sculptorID) and the `Paintings` table (using painterID).",
    "natural_language": "Delete all works by an artist. First, find the artist's ID from the `Artists` table using their last name. Then, if the artist exists, remove all their records from the `Sculptures` table via sculptorID and from the `Paintings` table via painterID. Name this stored procedure `delete_artist_works`.",
    "id": 125
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named insert_artist_if_dead that accepts a single input parameter called artist_name of type text, which represents the last name of an artist to be processed. The procedure first declares a local variable artist_record of type ROWTYPE for the \"Artists\" table to hold a complete row from that table. It then executes a SELECT statement to query the \"Artists\" table, retrieving all columns for the row where the \"lname\" column exactly matches the provided artist_name parameter, and stores the result into the artist_record variable. If no such row is found (indicated by the NOT FOUND condition), the procedure performs an INSERT operation into the \"Artists\" table, creating a new record with the \"lname\" column set to the provided artist_name, the \"fname\" column set to the literal string 'Unknown', the \"birthYear\" column set to the integer 1900, and the \"deathYear\" column set to the integer 1950. If a row was found (the ELSIF branch), the procedure checks a compound condition on that retrieved record: it verifies that the artist_record.\"deathYear\" column is not NULL and that its integer value is less than the current year obtained by calling the EXTRACT(YEAR FROM CURRENT_DATE) function. If this condition is true, the procedure executes an INSERT operation into the \"Sculptures\" table, creating a new record with the \"title\" column set to the literal string 'Memorial Piece', the \"year\" column set to the current year from EXTRACT(YEAR FROM CURRENT_DATE), the \"medium\" column set to the literal string 'bronze', and the \"sculptorID\" column set to the value of the artist_record.\"artistID\" column from the previously retrieved artist record.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_artist_if_dead(artist_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    artist_record \"Artists\"%ROWTYPE;\nBEGIN\n    SELECT * INTO artist_record FROM \"Artists\" WHERE \"lname\" = artist_name;\n    \n    IF NOT FOUND THEN\n        INSERT INTO \"Artists\" (\"lname\", \"fname\", \"birthYear\", \"deathYear\") \n        VALUES (artist_name, 'Unknown', 1900, 1950);\n    ELSIF artist_record.\"deathYear\" IS NOT NULL AND artist_record.\"deathYear\" < EXTRACT(YEAR FROM CURRENT_DATE) THEN\n        INSERT INTO \"Sculptures\" (\"title\", \"year\", \"medium\", \"sculptorID\") \n        VALUES ('Memorial Piece', EXTRACT(YEAR FROM CURRENT_DATE), 'bronze', artist_record.\"artistID\");\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL insert_artist_if_dead('Seurat');",
      "CALL insert_artist_if_dead('Picasso');",
      "CALL insert_artist_if_dead('van Gogh');",
      "CALL insert_artist_if_dead('Monet');",
      "CALL insert_artist_if_dead('Dali');"
    ],
    "summary": "Create a stored procedure named insert_artist_if_dead that takes an artist's last name as input. If the artist does not exist in the Artists table, insert a new artist record with default values. If the artist exists and has a death year in the past, insert a memorial sculpture record into the Sculptures table.",
    "natural_language": "Create a stored procedure called insert_artist_if_dead that uses an artist's last name. If that artist isn't already in the Artists table, just add them with some standard details. If they are there and it looks like they passed away a while back, then put in a memorial sculpture entry into the Sculptures table.",
    "id": 126
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `count_artist_works` that accepts a single input parameter, `artist_name`, of type `text`. The procedure begins by declaring three local variables: `artist_id` of type `bigint`, `painting_count` of type `integer`, and `sculpture_count` of type `integer`. The first operation performed is a `SELECT` statement that attempts to retrieve the `artistID` column from the `Artists` table and assign its value to the `artist_id` variable. This selection is conditioned on the `lname` column in the `Artists` table being equal to the value provided in the `artist_name` input parameter. Following this, a conditional block is executed: `IF artist_id IS NOT NULL THEN`. If the `artist_id` variable contains a non-null value (meaning an artist with the given `artist_name` was found), two subsequent `SELECT COUNT(*)` operations are performed. The first counts the total number of rows in the `Paintings` table where the `painterID` column matches the retrieved `artist_id` and assigns this count to the `painting_count` variable. The second counts the total number of rows in the `Sculptures` table where the `sculptorID` column matches the retrieved `artist_id` and assigns this count to the `sculpture_count` variable. After these counts are obtained, another nested conditional block is executed: `IF painting_count > 0 AND sculpture_count > 0 THEN`. If both `painting_count` and `sculpture_count` are greater than zero (meaning the artist has both paintings and sculptures), an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `Paintings` table. The `title` column of this new row is set to the literal string 'Combined Works Collection', the `year` column is set to the year extracted from the current date using `EXTRACT(YEAR FROM CURRENT_DATE)`, and the `painterID` column is set to the `artist_id` variable. The procedure concludes after these conditional operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE count_artist_works(artist_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    artist_id bigint;\n    painting_count integer;\n    sculpture_count integer;\nBEGIN\n    SELECT \"artistID\" INTO artist_id FROM \"Artists\" WHERE \"lname\" = artist_name;\n    \n    IF artist_id IS NOT NULL THEN\n        SELECT COUNT(*) INTO painting_count FROM \"Paintings\" WHERE \"painterID\" = artist_id;\n        SELECT COUNT(*) INTO sculpture_count FROM \"Sculptures\" WHERE \"sculptorID\" = artist_id;\n        \n        IF painting_count > 0 AND sculpture_count > 0 THEN\n            INSERT INTO \"Paintings\" (\"title\", \"year\", \"painterID\") \n            VALUES ('Combined Works Collection', EXTRACT(YEAR FROM CURRENT_DATE), artist_id);\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL count_artist_works('Seurat');",
      "CALL count_artist_works('Picasso');",
      "CALL count_artist_works('van Gogh');",
      "CALL count_artist_works('Monet');",
      "CALL count_artist_works('Rembrandt');"
    ],
    "summary": "Create a stored procedure named count_artist_works that takes an artist's last name as input. Find the artist's ID. If found, count their paintings and sculptures. If the artist has at least one painting and one sculpture, insert a new painting titled 'Combined Works Collection'.",
    "natural_language": "Create a comprehensive stored procedure, which should be named count_artist_works, designed to accept the last name of a specific artist as its input parameter. The procedure must first locate the unique identifier for the specified artist. Upon successfully finding the artist's ID, it should then meticulously calculate the total number of paintings and the total number of sculptures individually associated with that artist. If, and only if, the artist is verified to possess at least one painting and also at least one sculpture, the procedure must subsequently execute an insertion of a brand new painting, which should be distinctly titled 'Combined Works Collection', into the relevant database table.",
    "id": 127
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `process_artist_range` that accepts a single input parameter, `artist_name`, of type `text`. This procedure is designed to process information related to an artist based on their last name.\n\nUpon execution, the procedure first declares three local variables: `birth_year_val` of type `bigint`, `death_year_val` of type `bigint`, and `life_range` of type `numrange`.\n\nThe procedure then attempts to retrieve the `birthYear` and `deathYear` columns from the `Artists` table. These values are stored into the `birth_year_val` and `death_year_val` local variables, respectively. The selection is filtered by matching the `lname` column in the `Artists` table with the value provided in the `artist_name` input parameter.\n\nFollowing this data retrieval, the procedure enters a conditional block. This block executes only if both `birth_year_val` and `death_year_val` are not `NULL`.\n\nInside this conditional block, a numeric range is constructed. The `life_range` variable is assigned a `numrange` value, created by casting `birth_year_val` to `numeric` as the lower bound and `death_year_val` to `numeric` as the upper bound.\n\nImmediately after constructing the `numrange`, another nested conditional block is entered. This inner block executes only if the `life_range` is not empty, as determined by the `isempty()` function.\n\nIf the `life_range` is not empty, the procedure proceeds to insert a new record into the `Sculptures` table. The `title` column of the new record is set to the literal string 'Range Verified Sculpture'. The `year` column is populated with the current year, extracted from the current date using `EXTRACT(YEAR FROM CURRENT_DATE)`. The `medium` column is set to the literal string 'verified bronze'. Finally, the `sculptorID` column is populated by performing a subquery: it selects the `artistID` from the `Artists` table where the `lname` column matches the `artist_name` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_artist_range(artist_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    birth_year_val bigint;\n    death_year_val bigint;\n    life_range numrange;\nBEGIN\n    SELECT \"birthYear\", \"deathYear\" INTO birth_year_val, death_year_val \n    FROM \"Artists\" WHERE \"lname\" = artist_name;\n    \n    IF birth_year_val IS NOT NULL AND death_year_val IS NOT NULL THEN\n        life_range := numrange(birth_year_val::numeric, death_year_val::numeric);\n        \n        IF NOT isempty(life_range) THEN\n            INSERT INTO \"Sculptures\" (\"title\", \"year\", \"medium\", \"sculptorID\") \n            VALUES ('Range Verified Sculpture', EXTRACT(YEAR FROM CURRENT_DATE), 'verified bronze', \n                   (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name));\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL process_artist_range('Picasso');",
      "CALL process_artist_range('van Gogh');",
      "CALL process_artist_range('Seurat');",
      "CALL process_artist_range('Monet');",
      "CALL process_artist_range('Rembrandt');"
    ],
    "summary": "Create a stored procedure named process_artist_range that takes an artist's last name as input. Retrieve the artist's birth and death years. If both are present, create a numeric range from them. If the range is not empty, insert a new sculpture titled 'Range Verified Sculpture' for that artist.",
    "natural_language": "Write a stored procedure called process_artist_range that accepts an artist's last name. Fetch the artist's birth year and death year. If both years exist, form a numeric range from them. Provided this range is not empty, insert a new sculpture with the title 'Range Verified Sculpture' for that artist.",
    "id": 128
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named handle_empty_range_artist that accepts a single input parameter called artist_name of type text, which is used to identify an artist by their last name. The procedure begins by declaring two local variables, artist_birth and artist_death, both of type bigint, and a third variable named test_range of type numrange. It then executes a SELECT query on the \"Artists\" table to retrieve the \"birthYear\" and \"deathYear\" columns for the specific row where the \"lname\" column matches the provided artist_name parameter, storing the retrieved values into the artist_birth and artist_death variables. If both retrieved values are not null, the procedure constructs a numeric range named test_range by casting artist_birth and artist_death to numeric and passing them to the numrange constructor. It then checks if this constructed range is empty using the isempty function. If the range is empty, the procedure performs two DELETE operations: first, it deletes rows from the \"Paintings\" table where the \"painterID\" column equals the \"artistID\" value from the \"Artists\" table for the specified artist_name; second, it deletes rows from the \"Sculptures\" table where the \"sculptorID\" column equals that same \"artistID\". If the constructed range is not empty, the procedure executes an INSERT operation into the \"Paintings\" table, adding a new row with the \"title\" column set to the string 'Valid Range Painting', the \"year\" column set to the current year extracted from the system date using EXTRACT(YEAR FROM CURRENT_DATE), and the \"painterID\" column set to the \"artistID\" value from the \"Artists\" table for the specified artist_name. The procedure performs no action if either the artist_birth or artist_death value retrieved from the initial SELECT is null.",
    "plsql": "CREATE OR REPLACE PROCEDURE handle_empty_range_artist(artist_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    artist_birth bigint;\n    artist_death bigint;\n    test_range numrange;\nBEGIN\n    SELECT \"birthYear\", \"deathYear\" INTO artist_birth, artist_death \n    FROM \"Artists\" WHERE \"lname\" = artist_name;\n    \n    IF artist_birth IS NOT NULL AND artist_death IS NOT NULL THEN\n        test_range := numrange(artist_birth::numeric, artist_death::numeric);\n        \n        IF isempty(test_range) THEN\n            DELETE FROM \"Paintings\" WHERE \"painterID\" = (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name);\n            DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name);\n        ELSE\n            INSERT INTO \"Paintings\" (\"title\", \"year\", \"painterID\") \n            VALUES ('Valid Range Painting', EXTRACT(YEAR FROM CURRENT_DATE), \n                   (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name));\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL handle_empty_range_artist('Seurat');",
      "CALL handle_empty_range_artist('Picasso');",
      "CALL handle_empty_range_artist('van Gogh');",
      "CALL handle_empty_range_artist('Monet');",
      "CALL handle_empty_range_artist('Dali');"
    ],
    "summary": "Create a stored procedure named handle_empty_range_artist that takes an artist's last name as input. Retrieve the artist's birth and death years. If both are present, create a numeric range. If the range is empty, delete all paintings and sculptures by that artist. If the range is valid, insert a new painting titled 'Valid Range Painting' for the artist.",
    "natural_language": "Develop a stored procedure, which should be named handle_empty_range_artist, designed to accept the last name of a specific artist as its input parameter. The procedure must first retrieve the detailed birth year and death year for that particular artist. Subsequently, if both of these crucial dates are definitively present, a numeric range should be constructed from them. In the event that this calculated range is found to be completely empty, the procedure must then proceed to meticulously delete every single painting and sculpture associated with that artist. Conversely, if the range is confirmed to be valid and non-empty, the procedure should insert a brand new painting, explicitly titled 'Valid Range Painting', and correctly assign it to the artist in question.",
    "id": 129
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two parameters: school_id_input of type INTEGER and nickname_input of type TEXT. This procedure performs an operation on the school_details table, which contains columns \"School_ID\" and \"Nickname\". The procedure attempts to insert a new row into the school_details table with the \"School_ID\" column set to the value of school_id_input and the \"Nickname\" column set to the value of nickname_input. If a row with the same \"School_ID\" already exists in the table, the procedure does not insert a new row but instead updates the existing row by setting its \"Nickname\" column to the value of nickname_input. This is achieved using the ON CONFLICT clause, which specifies that if a conflict occurs on the \"School_ID\" column, the procedure should execute an UPDATE operation to set the \"Nickname\" column of the conflicting row to the value of EXCLUDED.\"Nickname\", which refers to the nickname_input value that was intended for insertion.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_school_details(school_id_input INTEGER, nickname_input TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO school_details (\"School_ID\", \"Nickname\")\n    VALUES (school_id_input, nickname_input)\n    ON CONFLICT (\"School_ID\") \n    DO UPDATE SET \"Nickname\" = EXCLUDED.\"Nickname\";\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "school",
      "school_details"
    ],
    "call_sqls": [
      "CALL insert_school_details(1, 'Tigers');",
      "CALL insert_school_details(2, 'Auks');",
      "CALL insert_school_details(3, 'Buccaneers');",
      "CALL insert_school_details(4, 'Lions');",
      "CALL insert_school_details(1, 'Wildcats');"
    ],
    "summary": "Create a stored procedure that takes a school ID and a nickname as input. Insert a new row into the school_details table with these values. If a row with the same School_ID already exists, update its Nickname column instead.",
    "natural_language": "Please construct a stored procedure that accepts a school identifier and a nickname as input parameters. This procedure should insert a new record into the school_details table utilizing the provided values. In the event that a record possessing the identical School_ID already exists within the table, the procedure must instead update the existing record's Nickname column with the new value.",
    "id": 130
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the school table where the School_ID column matches the provided school_id_input parameter of type INTEGER and the Location column matches the provided location_input parameter of type TEXT.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_school_by_location(school_id_input INTEGER, location_input TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM school\n    WHERE \"School_ID\" = school_id_input AND \"Location\" = location_input;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "school",
      "school_details"
    ],
    "call_sqls": [
      "CALL delete_school_by_location(1, 'Milsons Point');",
      "CALL delete_school_by_location(2, 'Hornsby');",
      "CALL delete_school_by_location(3, 'Bellevue Hill');",
      "CALL delete_school_by_location(1, 'Hornsby');",
      "CALL delete_school_by_location(2, 'Bellevue Hill');"
    ],
    "summary": "Create a stored procedure to delete rows from the school table where the School_ID matches a given integer and the Location matches a given text.",
    "natural_language": "Delete school rows by ID and location.",
    "id": 131
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_school_colors` that accepts two input parameters: `school_id_input`, which is an integer representing the unique identifier of a school, and `new_colors`, which is a text string representing the new color information to be assigned to the school. The procedure's sole operation is to perform an `UPDATE` statement on the `school_details` table. This `UPDATE` statement modifies the value in the column named `\"Colors\"` within the `school_details` table, setting it to the value provided by the `new_colors` input parameter. The `UPDATE` operation is conditionally applied, affecting only those rows in the `school_details` table where the value in the column named `\"School_ID\"` precisely matches the integer value provided by the `school_id_input` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_school_colors(school_id_input INTEGER, new_colors TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE school_details\n    SET \"Colors\" = new_colors\n    WHERE \"School_ID\" = school_id_input;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "school",
      "school_details"
    ],
    "call_sqls": [
      "CALL update_school_colors(1, 'Scarlet and Gray');",
      "CALL update_school_colors(2, 'Navy and White');",
      "CALL update_school_colors(3, 'Green and Gold');",
      "CALL update_school_colors(1, 'Blue and Silver');",
      "CALL update_school_colors(2, 'Maroon and Gold');"
    ],
    "summary": "Create a stored procedure named update_school_colors that updates the Colors column in the school_details table for a row where the School_ID matches a given integer, setting it to a given text value.",
    "natural_language": "Please construct a stored procedure designated as 'update_school_colors'. This procedure shall modify the 'Colors' column within the 'school_details' table. The update operation is to be performed on the row where the 'School_ID' corresponds to a specified integer parameter, assigning the column's value to a provided text parameter.",
    "id": 132
  },
  {
    "ir": "Write a PLpgSQL stored procedure that accepts three parameters: book_id of type INTEGER, rating of type REAL, and min_rating of type REAL. The procedure evaluates whether the provided rating is greater than the specified min_rating. If this condition is met, it performs an insertion operation into the review table. Specifically, it inserts a new row with the following values: book_id into the Book_ID column, rating into the Rating column, and sets both Readers_in_Million and Rank columns to 0. The procedure does not perform any operations if the rating does not exceed min_rating.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_review_if_high_rating(book_id INTEGER, rating REAL, min_rating REAL)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF rating > min_rating THEN\n        INSERT INTO \"review\" (\"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\")\n        VALUES (book_id, rating, 0, 0);\n    END IF;\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL insert_review_if_high_rating(1, 7.0, 6.5);",
      "CALL insert_review_if_high_rating(2, 8.0, 7.5);",
      "CALL insert_review_if_high_rating(3, 9.0, 8.5);",
      "CALL insert_review_if_high_rating(1, 6.6, 6.0);",
      "CALL insert_review_if_high_rating(2, 7.5, 7.0);"
    ],
    "summary": "Create a stored procedure that inserts a row into the review table with a given book_id and rating, and sets Readers_in_Million and Rank to 0, but only if the rating is greater than a given minimum rating.",
    "natural_language": "How can I create a stored procedure to insert a row into the review table for a given book_id and rating, setting Readers_in_Million and Rank to 0, but only if the provided rating exceeds a specified minimum?",
    "id": 133
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_book_audio_length that accepts three input parameters: an integer parameter named book_id to identify a specific book record, a text parameter named new_audio_length to provide the new audio duration value, and an integer parameter named max_pages to serve as a maximum page count threshold. The procedure begins by checking for the existence of a row in the book table where the Book_ID column matches the provided book_id parameter and simultaneously the Pages column value is less than or equal to the max_pages parameter. If such a row exists, the procedure executes an update operation on the book table, setting the Audio column to the value of the new_audio_length parameter specifically for the row where the Book_ID column equals the input book_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_book_audio_length(book_id INTEGER, new_audio_length TEXT, max_pages INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"book\" WHERE \"Book_ID\" = book_id AND \"Pages\" <= max_pages) THEN\n        UPDATE \"book\"\n        SET \"Audio\" = new_audio_length\n        WHERE \"Book_ID\" = book_id;\n    END IF;\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL update_book_audio_length(1, '34h 15m', 800);",
      "CALL update_book_audio_length(2, '38h 05m', 1000);",
      "CALL update_book_audio_length(3, '48h 20m', 1200);",
      "CALL update_book_audio_length(1, '35h 00m', 500);",
      "CALL update_book_audio_length(2, '37h 30m', 770);"
    ],
    "summary": "Create a stored procedure named update_book_audio_length that updates the Audio column in the book table for a specific book_id, but only if that book's Pages are less than or equal to a given maximum page threshold.",
    "natural_language": "Please construct a stored procedure designated as 'update_book_audio_length'. Its function is to modify the value within the Audio column of the book table for a specified book identifier. This modification shall be executed conditionally, proceeding only if the number of Pages for the identified book does not exceed a provided maximum page threshold.",
    "id": 134
  },
  {
    "ir": "Write a PLpgSQL stored procedure named reorganize_management_structure that accepts five parameters: p_budget_cutoff of type real, p_employee_limit of type real, p_target_state of type text, p_age_limit of type real, and p_new_status of type text. The procedure begins by declaring three local variables: v_dept_id, v_head_id, and v_ranking_val, all of type integer. It first selects the Department_ID from the department table where the Budget_in_Billions is greater than p_budget_cutoff and the Num_Employees is less than p_employee_limit, ordering the results by the Ranking column in ascending order, and limits the selection to one row, storing the result in v_dept_id. Next, it selects the head_ID from the head table where the born_state matches p_target_state and the age is less than p_age_limit, ordering the results by head_ID in descending order, and limits the selection to one row, storing the result in v_head_id. Then, it retrieves the Ranking value from the department table for the department with the Department_ID equal to v_dept_id and stores it in v_ranking_val. The procedure then evaluates the value of v_ranking_val: if it is less than 5, it deletes rows from the management table where the department_ID matches v_dept_id, and inserts a new row into the management table with department_ID set to v_dept_id, head_ID set to v_head_id, and temporary_acting set to p_new_status. If v_ranking_val is not less than 5 but v_head_id is not null, it inserts rows into the management table with department_ID from the department table where Budget_in_Billions is less than p_budget_cutoff, head_ID set to v_head_id, and temporary_acting set to 'Yes'. If neither condition is met, it deletes rows from the management table where temporary_acting is 'Yes' and department_ID is in the set of Department_IDs from the department table where Num_Employees is greater than p_employee_limit.",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_management_structure(\n    p_budget_cutoff real,\n    p_employee_limit real,\n    p_target_state text,\n    p_age_limit real,\n    p_new_status text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dept_id integer;\n    v_head_id integer;\n    v_ranking_val integer;\nBEGIN\n    SELECT \"Department_ID\" INTO v_dept_id\n    FROM department\n    WHERE \"Budget_in_Billions\" > p_budget_cutoff\n    AND \"Num_Employees\" < p_employee_limit\n    ORDER BY \"Ranking\" ASC\n    LIMIT 1;\n    \n    SELECT \"head_ID\" INTO v_head_id\n    FROM head\n    WHERE born_state = p_target_state\n    AND age < p_age_limit\n    ORDER BY \"head_ID\" DESC\n    LIMIT 1;\n    \n    SELECT \"Ranking\" INTO v_ranking_val\n    FROM department\n    WHERE \"Department_ID\" = v_dept_id;\n    \n    IF v_ranking_val < 5 THEN\n        DELETE FROM management\n        WHERE \"department_ID\" = v_dept_id;\n        \n        INSERT INTO management (\"department_ID\", \"head_ID\", temporary_acting)\n        VALUES (v_dept_id, v_head_id, p_new_status);\n    ELSIF v_head_id IS NOT NULL THEN\n        INSERT INTO management (\"department_ID\", \"head_ID\", temporary_acting)\n        SELECT \"Department_ID\", v_head_id, 'Yes'\n        FROM department\n        WHERE \"Budget_in_Billions\" < p_budget_cutoff;\n    ELSE\n        DELETE FROM management\n        WHERE temporary_acting = 'Yes'\n        AND \"department_ID\" IN (SELECT \"Department_ID\" FROM department WHERE \"Num_Employees\" > p_employee_limit);\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL reorganize_management_structure(10.0, 50000.0, 'California', 65.0, 'Yes');",
      "CALL reorganize_management_structure(5.5, 100000.0, 'Texas', 60.0, 'Interim');",
      "CALL reorganize_management_structure(50.0, 200000.0, 'New York', 70.0, 'Temporary');",
      "CALL reorganize_management_structure(1.0, 10000.0, 'Florida', 55.0, 'Acting');",
      "CALL reorganize_management_structure(100.0, 500000.0, 'Illinois', 75.0, 'Provisional');"
    ],
    "summary": "Create a stored procedure named reorganize_management_structure that uses several input parameters to: 1) Find a department ID based on budget and employee thresholds. 2) Find a head ID based on state and age. 3) Based on the found department's ranking, perform one of three actions: a) Delete and insert a new management record if ranking is low. b) Insert management records for low-budget departments if a head was found. c) Delete management records for 'Yes' status in high-employee departments if no other condition is met.",
    "natural_language": "Develop a comprehensive stored procedure, to be named reorganize_management_structure, which will utilize a series of specific input parameters to meticulously execute the following multi-step process: Firstly, it must intelligently locate a department's unique identifier by carefully evaluating predefined budgetary constraints and specific thresholds related to employee count. Subsequently, it should identify a suitable head personnel ID by thoroughly filtering candidates based on their geographical state and precise age criteria. Finally, depending critically on the ascertained ranking tier of the located department, the procedure must decisively initiate one of three distinct managerial actions: a) In scenarios where the department's ranking is determined to be unacceptably low, it will completely delete the existing management entry and seamlessly insert a brand-new management record. b) If, however, a qualified head was successfully identified, it will proceed to insert new management records specifically for those departments operating with notably constrained budgets. c) Should none of the preceding conditions be satisfied, it will then systematically delete all management records marked with a 'Yes' status, but only for those departments characterized by an exceptionally high volume of employees.",
    "id": 135
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named sync_department_heads that accepts five input parameters: a text parameter p_creation_year to filter departments by their creation year, a real parameter p_min_budget to specify a minimum budget threshold, a text parameter p_state_required to filter heads by their birth state, a real parameter p_age_minimum to set a minimum age for heads, and a text parameter p_acting_indicator to flag management records as temporary or acting. The procedure begins by declaring a cursor named v_dept_cursor that selects the Department_ID, Name, and Ranking columns from the department table for rows where the Creation column equals p_creation_year and the Budget_in_Billions column is greater than or equal to p_min_budget. It then initializes two variables: an integer v_head_count and a real v_avg_age. The procedure first calculates v_head_count by counting all rows in the head table where the born_state column matches p_state_required. Next, it calculates v_avg_age by computing the average of the age column from the head table for rows where age is greater than or equal to p_age_minimum. The procedure then enters a loop that iterates through each record fetched by the v_dept_cursor, referred to as dept_rec. For each department record, it evaluates a conditional block: if v_head_count is greater than the department's Ranking value from dept_rec, it performs an INSERT into the management table, selecting the department's Department_ID from dept_rec, the head_ID from the head table, and the p_acting_indicator parameter for the temporary_acting column; this INSERT is limited to one row from the head table where the head's born_state equals p_state_required and the head's age is at least p_age_minimum. Alternatively, if the first condition is false and v_avg_age is greater than 65, it executes a DELETE operation on the management table, removing rows where the department_ID column matches dept_rec's Department_ID and the temporary_acting column equals p_acting_indicator. If neither of the previous conditions is true, it performs a third INSERT into the management table, directly inserting dept_rec's Department_ID, a hardcoded head_ID value of 1, and a literal string 'Yes' for the temporary_acting column. The loop continues until all records from the cursor are processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_department_heads(\n    p_creation_year text,\n    p_min_budget real,\n    p_state_required text,\n    p_age_minimum real,\n    p_acting_indicator text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dept_cursor CURSOR FOR\n        SELECT d.\"Department_ID\", d.\"Name\", d.\"Ranking\"\n        FROM department d\n        WHERE d.\"Creation\" = p_creation_year\n        AND d.\"Budget_in_Billions\" >= p_min_budget;\n    \n    v_head_count integer;\n    v_avg_age real;\nBEGIN\n    SELECT COUNT(*) INTO v_head_count\n    FROM head\n    WHERE born_state = p_state_required;\n    \n    SELECT AVG(age) INTO v_avg_age\n    FROM head\n    WHERE age >= p_age_minimum;\n    \n    FOR dept_rec IN v_dept_cursor LOOP\n        IF v_head_count > dept_rec.\"Ranking\" THEN\n            INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n            SELECT dept_rec.\"Department_ID\", h.\"head_ID\", p_acting_indicator\n            FROM head h\n            WHERE h.born_state = p_state_required\n            AND h.age >= p_age_minimum\n            LIMIT 1;\n        ELSIF v_avg_age > 65 THEN\n            DELETE FROM management\n            WHERE \"department_ID\" = dept_rec.\"Department_ID\"\n            AND \"temporary_acting\" = p_acting_indicator;\n        ELSE\n            INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n            VALUES (dept_rec.\"Department_ID\", 1, 'Yes');\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL sync_department_heads('1789', 10.0, 'Alabama', 65.0, 'Yes');",
      "CALL sync_department_heads('1947', 50.0, 'California', 70.0, 'No');",
      "CALL sync_department_heads('1789', 5.0, 'Alabama', 60.0, 'Maybe');",
      "CALL sync_department_heads('1947', 100.0, 'California', 75.0, 'Yes');",
      "CALL sync_department_heads('1789', 20.0, 'Alabama', 68.0, 'No');"
    ],
    "summary": "Create a stored procedure named sync_department_heads that filters departments by creation year and minimum budget, then loops through them. For each department, if the count of heads from a specified state exceeds the department's ranking, insert a management record with a matching head. If not, but the average head age is over 65, delete management records for that department with a specific acting indicator. Otherwise, insert a default management record with head_ID 1 and 'Yes' for acting.",
    "natural_language": "How can I create a stored procedure named sync_department_heads that will filter departments by their creation year and a minimum budget, then loop through them? For each department, if the number of heads from a given state is greater than the department's ranking, it should insert a management record with a matching head. If that condition is not met, but the average age of the heads is over 65, should it delete management records for that department where a specific acting indicator is set? Otherwise, should it insert a default management record using head_ID 1 and 'Yes' for acting?",
    "id": 136
  },
  {
    "ir": "Write a PLpgSQL stored procedure named balance_department_resources that accepts five input parameters: an integer p_ranking_filter, a real number p_employee_target, a text p_state_exclusion, a real number p_age_exclusion, and a text p_status_target. The procedure begins by declaring three local variables: v_total_departments as integer, v_eligible_heads as integer, and v_max_budget as real. It first calculates v_total_departments by counting all rows from the department table where the Ranking column is less than or equal to the p_ranking_filter parameter. It then calculates v_eligible_heads by counting all rows from the head table where the born_state column is not equal to p_state_exclusion and the age column is not equal to p_age_exclusion. Next, it determines v_max_budget by selecting the maximum value from the Budget_in_Billions column in the department table, but only for rows where the Num_Employees column is greater than the p_employee_target parameter. The procedure then executes a conditional IF-ELSIF-ELSE block. If v_total_departments is greater than v_eligible_heads, it performs two operations: first, it deletes rows from the management table by joining it with the head table on head_ID, specifically deleting any management record where the associated head's born_state column equals the p_state_exclusion parameter; second, it inserts up to three new rows into the management table, specifying columns department_ID, head_ID, and temporary_acting, by performing a cross join between the department and head tables, selecting department_ID from department where its Ranking is less than or equal to p_ranking_filter, and head_ID from head where its born_state is not equal to p_state_exclusion, and setting the temporary_acting column to the value of p_status_target, limiting the total inserted rows to three. Otherwise, if the first condition is false and v_max_budget is less than 1000, it deletes rows from the management table where the department_ID matches any Department_ID from the department table where the Budget_in_Billions column is less than the calculated v_max_budget. If neither of the previous conditions is true, the procedure executes the ELSE branch, which inserts three specific rows into the management table with hardcoded values: (2, 2, p_status_target), (3, 3, p_status_target), and (4, 4, p_status_target).",
    "plsql": "CREATE OR REPLACE PROCEDURE balance_department_resources(\n    p_ranking_filter integer,\n    p_employee_target real,\n    p_state_exclusion text,\n    p_age_exclusion real,\n    p_status_target text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_departments integer;\n    v_eligible_heads integer;\n    v_max_budget real;\nBEGIN\n    SELECT COUNT(*) INTO v_total_departments\n    FROM department\n    WHERE \"Ranking\" <= p_ranking_filter;\n    \n    SELECT COUNT(*) INTO v_eligible_heads\n    FROM head\n    WHERE born_state != p_state_exclusion\n    AND age != p_age_exclusion;\n    \n    SELECT MAX(\"Budget_in_Billions\") INTO v_max_budget\n    FROM department\n    WHERE \"Num_Employees\" > p_employee_target;\n    \n    IF v_total_departments > v_eligible_heads THEN\n        DELETE FROM management m\n        USING head h\n        WHERE m.head_ID = h.head_ID\n        AND h.born_state = p_state_exclusion;\n        \n        INSERT INTO management (department_ID, head_ID, temporary_acting)\n        SELECT d.\"Department_ID\", h.head_ID, p_status_target\n        FROM department d\n        CROSS JOIN head h\n        WHERE d.\"Ranking\" <= p_ranking_filter\n        AND h.born_state != p_state_exclusion\n        LIMIT 3;\n    ELSIF v_max_budget < 1000 THEN\n        DELETE FROM management\n        WHERE management.\"department_ID\" IN (\n            SELECT \"Department_ID\"\n            FROM department\n            WHERE \"Budget_in_Billions\" < v_max_budget\n        );\n    ELSE\n        INSERT INTO management (department_ID, head_ID, temporary_acting)\n        VALUES (2, 2, p_status_target),\n               (3, 3, p_status_target),\n               (4, 4, p_status_target);\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL balance_department_resources(2, 100000.0, 'California', 67.0, 'Yes');",
      "CALL balance_department_resources(3, 200000.0, 'Alabama', 68.0, 'No');",
      "CALL balance_department_resources(1, 50000.0, 'Texas', 69.0, 'Yes');",
      "CALL balance_department_resources(2, 150000.0, 'New York', 67.0, 'No');",
      "CALL balance_department_resources(3, 250000.0, 'Florida', 68.0, 'Yes');"
    ],
    "summary": "Create a stored procedure named balance_department_resources that calculates department, head, and budget metrics. If the department count exceeds eligible heads, delete management records for heads from an excluded state and insert up to three new management records from a cross-join of filtered departments and heads. If not, but the maximum budget is below 1000, delete management records for departments with budgets below that maximum. Otherwise, insert three hardcoded management records.",
    "natural_language": "Alright, so we need a stored procedure called balance_department_resources. Here's the deal: it's gotta figure out some numbers for departments, their heads, and budgets. If there are more departments than there are eligible heads, then we gotta clean house a bitâ€”delete the management records for any heads from that one state we're not including. After that, we can add up to three new management entries by mixing and matching the filtered departments and heads. If that first situation isn't true, but the biggest budget we've got is less than 1000, then we need to delete management records for any departments whose budgets are below that top number. And if neither of those things pan out? Just plug in three set-in-stone management records.",
    "id": 137
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named process_claim_payment that accepts three input parameters: a bigint parameter p_claim_id representing the unique identifier of a claim, a text parameter p_payment_method specifying the method of payment, and a date parameter p_payment_date indicating the date the payment was made. The procedure begins by declaring two local bigint variables, v_settlement_amount and v_settlement_id. It then executes a SELECT query on the \"Settlements\" table, retrieving the values from the \"Amount_Settled\" and \"Settlement_ID\" columns for the single row where the \"Claim_ID\" column matches the provided p_claim_id parameter, and stores these retrieved values into the v_settlement_amount and v_settlement_id variables respectively. Following this retrieval, the procedure uses an IF conditional statement to check if the v_settlement_id variable is not NULL. If this condition evaluates to true, the procedure performs an INSERT operation into the \"Payments\" table, creating a new row with the following column values: the \"Settlement_ID\" column is set to the value of v_settlement_id, the \"Payment_Method_Code\" column is set to the value of the p_payment_method input parameter, the \"Date_Payment_Made\" column is set to the value of the p_payment_date input parameter, and the \"Amount_Payment\" column is set to the value of the v_settlement_amount variable.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_claim_payment(p_claim_id bigint, p_payment_method text, p_payment_date date)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_settlement_amount bigint;\n    v_settlement_id bigint;\nBEGIN\n    SELECT s.\"Amount_Settled\", s.\"Settlement_ID\"\n    INTO v_settlement_amount, v_settlement_id\n    FROM \"Settlements\" s\n    WHERE s.\"Claim_ID\" = p_claim_id;\n\n    IF v_settlement_id IS NOT NULL THEN\n        INSERT INTO \"Payments\" (\"Settlement_ID\", \"Payment_Method_Code\", \"Date_Payment_Made\", \"Amount_Payment\")\n        VALUES (v_settlement_id, p_payment_method, p_payment_date, v_settlement_amount);\n    END IF;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "CALL process_claim_payment(143, 'Credit Card', '2023-10-15');",
      "CALL process_claim_payment(423, 'Bank Transfer', '2023-10-16');",
      "CALL process_claim_payment(442, 'Check', '2023-10-17');",
      "CALL process_claim_payment(486, 'MasterCard', '2023-10-18');",
      "CALL process_claim_payment(621, 'Cash', '2023-10-19');"
    ],
    "summary": "Create a stored procedure named process_claim_payment that retrieves settlement details for a given claim ID. If a settlement exists, insert a payment record with the settlement amount, ID, provided payment method, and date.",
    "natural_language": "Please construct a stored procedure designated as 'process_claim_payment' to fetch the settlement particulars associated with a specified claim identifier. Should a settlement record be present, proceed to insert a new payment entry, incorporating the settlement amount, its identifier, the supplied payment method, and the relevant date.",
    "id": 138
  },
  {
    "ir": "Write a PLpgSQL stored procedure that iterates over each record in the Customer_Policies table where the Customer_ID matches the provided parameter p_customer_id and the Policy_Type_Code matches the provided parameter p_policy_type, retrieves the Policy_ID and End_Date for each matching record, and updates the End_Date by adding the number of days specified in the parameter p_extension_days to the current End_Date for each policy, ensuring that the update is applied to the correct policy by matching the Policy_ID in the update statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_customer_policy_dates(p_customer_id bigint, p_policy_type text, p_extension_days integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_policy_record RECORD;\nBEGIN\n    FOR v_policy_record IN \n        SELECT \"Policy_ID\", \"End_Date\" \n        FROM \"Customer_Policies\" \n        WHERE \"Customer_ID\" = p_customer_id \n        AND \"Policy_Type_Code\" = p_policy_type\n    LOOP\n        UPDATE \"Customer_Policies\" \n        SET \"End_Date\" = v_policy_record.\"End_Date\" + p_extension_days\n        WHERE \"Policy_ID\" = v_policy_record.\"Policy_ID\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "CALL update_customer_policy_dates(1, 'Car', 30);",
      "CALL update_customer_policy_dates(2, 'Life', 15);",
      "CALL update_customer_policy_dates(3, 'Car', 45);",
      "CALL update_customer_policy_dates(1, 'Life', 10);",
      "CALL update_customer_policy_dates(2, 'Car', 20);"
    ],
    "summary": "Create a stored procedure that extends the end date of all policies for a specific customer and policy type by a given number of days.",
    "natural_language": "Make a stored procedure to push back the expiration for a bunch of policies belonging to a certain customer and a particular kind of policy, adding a handful of days to their end dates.",
    "id": 139
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `archive_old_claims` that accepts three input parameters: `p_cutoff_date` of type `date`, `p_policy_id_filter` of type `bigint`, and `p_status_flag` of type `boolean`. The purpose of this procedure is to conditionally delete records from the table named `\"Claims\"`. The procedure's logic is controlled by the `p_status_flag` parameter. If `p_status_flag` evaluates to `TRUE`, the procedure executes a `DELETE` operation on the `\"Claims\"` table. This deletion targets rows where the value in the `\"Date_Claim_Made\"` column is strictly less than the value provided in the `p_cutoff_date` parameter, AND the value in the `\"Policy_ID\"` column is exactly equal to the value provided in the `p_policy_id_filter` parameter, AND the value in the `\"Date_Claim_Settled\"` column is explicitly `NOT NULL`. If `p_status_flag` evaluates to `FALSE`, the procedure executes an alternative `DELETE` operation on the `\"Claims\"` table. This deletion targets rows where the value in the `\"Date_Claim_Made\"` column is strictly less than the value provided in the `p_cutoff_date` parameter, AND the value in the `\"Policy_ID\"` column is exactly equal to the value provided in the `p_policy_id_filter` parameter, AND the value in the `\"Date_Claim_Settled\"` column is explicitly `NULL`.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_claims(p_cutoff_date date, p_policy_id_filter bigint, p_status_flag boolean)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF p_status_flag THEN\n        DELETE FROM \"Claims\" \n        WHERE \"Date_Claim_Made\" < p_cutoff_date \n        AND \"Policy_ID\" = p_policy_id_filter\n        AND \"Date_Claim_Settled\" IS NOT NULL;\n    ELSE\n        DELETE FROM \"Claims\" \n        WHERE \"Date_Claim_Made\" < p_cutoff_date \n        AND \"Policy_ID\" = p_policy_id_filter\n        AND \"Date_Claim_Settled\" IS NULL;\n    END IF;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "CALL archive_old_claims('2017-01-01', 744, TRUE);",
      "CALL archive_old_claims('2018-03-15', 552, FALSE);",
      "CALL archive_old_claims('2016-06-30', 473, TRUE);",
      "CALL archive_old_claims('2017-12-31', 744, FALSE);",
      "CALL archive_old_claims('2015-01-01', 552, TRUE);"
    ],
    "summary": "Create a stored procedure named archive_old_claims that deletes claims older than a cutoff date for a specific policy. If a status flag is true, delete settled claims. If false, delete unsettled claims.",
    "natural_language": "Hey, can you whip up a stored procedure called archive_old_claims? It needs to get rid of claims for a particular policy that are older than a certain date. Oh, and here's the kicker: if a status flag is set to true, only ditch the settled ones. If it's false, then only boot out the unsettled claims.",
    "id": 140
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `manage_classroom_assignments` that does not accept any input parameters. This procedure is designed to iterate through aggregated data from the `list` table, grouped by the `\"Classroom\"` column, and perform conditional operations based on the student count and average grade within each classroom.\n\nThe procedure begins by declaring several local variables:\n- `v_classroom`: A `RECORD` type variable intended to hold a single row of aggregated data fetched from the cursor.\n- `v_classroom_count`: A `bigint` type variable to store the count of students for the current classroom.\n- `v_classroom_avg_grade`: A `numeric` type variable to store the average grade for the current classroom.\n- `v_classroom_cursor`: A `CURSOR` defined to select aggregated data from the `list` table. This cursor selects the `\"Classroom\"` column, the count of all rows as `student_count`, and the average of the `\"Grade\"` column as `avg_grade`. The results are grouped by the `\"Classroom\"` column.\n\nThe execution flow starts by opening the `v_classroom_cursor`.\nIt then enters a `LOOP` block to process each aggregated classroom record.\nInside the loop, it attempts to `FETCH` the next row from `v_classroom_cursor` into the `v_classroom` record variable.\nAn `EXIT WHEN NOT FOUND` condition immediately follows, which terminates the loop if no more rows are available in the cursor.\nAfter a successful fetch, the `student_count` from the fetched `v_classroom` record is assigned to `v_classroom_count`.\nSimilarly, the `avg_grade` from the fetched `v_classroom` record is assigned to `v_classroom_avg_grade`.\n\nFollowing these assignments, a conditional `IF-ELSIF-ELSE` block determines the action to be taken for the current classroom:\n- **IF** `v_classroom_count` (the number of students in the current classroom) is greater than `10`:\n    An `UPDATE` operation is performed on the `list` table. It sets the `\"Grade\"` column to the value of `v_classroom_avg_grade` for all rows where the `\"Classroom\"` column matches the `\"Classroom\"` value from the current `v_classroom` record AND the existing `\"Grade\"` column is less than `v_classroom_avg_grade`. This effectively raises the grades of underperforming students in large classrooms to the classroom average.\n- **ELSIF** `v_classroom_count` (the number of students in the current classroom) is less than `5`:\n    A `DELETE` operation is performed on the `list` table. It removes rows where the `\"Classroom\"` column matches the `\"Classroom\"` value from the current `v_classroom` record AND the `\"Grade\"` column is equal to the minimum `\"Grade\"` found within that specific classroom. The minimum grade is determined by a subquery `(SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\")`. This action removes the lowest-graded student from small classrooms.\n- **ELSE** (if `v_classroom_count` is neither greater than 10 nor less than 5, implying it is between 5 and 10, inclusive):\n    An `INSERT` operation is performed into the `teachers` table. It inserts a new record with `\"LastName\"` set to 'AUTO', `\"FirstName\"` set to 'GEN', and `\"Classroom\"` set to the `\"Classroom\"` value from the current `v_classroom` record. This `INSERT` statement includes an `ON CONFLICT (\"LastName\", \"FirstName\") DO NOTHING` clause, which means if a teacher with the last name 'AUTO' and first name 'GEN' already exists, no action is taken, preventing duplicate entries for this specific teacher. This action assigns a generic teacher to classrooms of moderate size.\n\nThe loop continues until all aggregated classroom records have been processed.\nFinally, after the loop completes, the `v_classroom_cursor` is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_classroom_assignments()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_classroom RECORD;\n    v_classroom_count bigint;\n    v_classroom_avg_grade numeric;\n    v_classroom_cursor CURSOR FOR SELECT \"Classroom\", COUNT(*) as student_count, AVG(\"Grade\") as avg_grade FROM list GROUP BY \"Classroom\";\nBEGIN\n    OPEN v_classroom_cursor;\n    LOOP\n        FETCH v_classroom_cursor INTO v_classroom;\n        EXIT WHEN NOT FOUND;\n        v_classroom_count := v_classroom.student_count;\n        v_classroom_avg_grade := v_classroom.avg_grade;\n        IF v_classroom_count > 10 THEN\n            UPDATE list SET \"Grade\" = v_classroom_avg_grade WHERE \"Classroom\" = v_classroom.\"Classroom\" AND \"Grade\" < v_classroom_avg_grade;\n        ELSIF v_classroom_count < 5 THEN\n            DELETE FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\" AND \"Grade\" = (SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\");\n        ELSE\n            INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") \n            VALUES ('AUTO', 'GEN', v_classroom.\"Classroom\")\n            ON CONFLICT (\"LastName\", \"FirstName\") DO NOTHING;\n        END IF;\n    END LOOP;\n    CLOSE v_classroom_cursor;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "CALL manage_classroom_assignments();"
    ],
    "summary": "Create a stored procedure named manage_classroom_assignments with no parameters. For each classroom in the list table, calculate the student count and average grade. If a classroom has more than 10 students, update grades below the classroom average to that average. If a classroom has fewer than 5 students, delete the student(s) with the minimum grade in that classroom. For classrooms with 5 to 10 students, insert a generic teacher ('AUTO', 'GEN') for that classroom into the teachers table, preventing duplicates.",
    "natural_language": "Alright, so we need a stored procedure, call it 'manage_classroom_assignments', and it doesn't need any parameters. Here's the deal: go through every classroom we've got. For each one, figure out how many students are in there and what the average grade is. If a classroom is packed with more than 10 students, then bump up any grades that are below the room's average to that average. If a classroom is kinda empty, with fewer than 5 kids, then kick out the student (or students) who have the absolute lowest grade in that room. For the classrooms that are just right, with between 5 and 10 students, we need to add a generic teacher ('AUTO', 'GEN') for that classroom into the teachers list, but only if they aren't already in thereâ€”we don't want duplicates.",
    "id": 141
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `adjust_student_grades` that takes no parameters. This procedure is designed to iterate through distinct classrooms, calculate the average grade for each classroom, and then apply specific grade adjustments or record deletions based on these average grades.\n\nThe procedure begins by declaring a local variable `v_classroom` of type `RECORD` to hold the results fetched from a cursor. It also declares a cursor named `v_classroom_cursor`. This cursor is defined to select two columns: `\"Classroom\"` and the average of the `\"Grade\"` column, aliased as `avg_grade`, from a table named `list`. The results are grouped by the `\"Classroom\"` column, meaning the average grade is calculated independently for each unique classroom.\n\nThe execution flow starts by opening the `v_classroom_cursor`. Following this, an unconditional `LOOP` is initiated. Inside this loop, the procedure attempts to `FETCH` the next row from `v_classroom_cursor` into the `v_classroom` record variable. Immediately after the fetch, a conditional `EXIT WHEN NOT FOUND` statement checks if the `FETCH` operation failed to retrieve a row (indicating the end of the cursor's result set). If no row is found, the loop terminates.\n\nIf a row is successfully fetched, the procedure proceeds with a series of conditional checks on the `avg_grade` value of the current `v_classroom` record.\n\nFirst, an `IF` condition checks if `v_classroom.avg_grade` is greater than `5`. If this condition is true, an `UPDATE` operation is performed on the `list` table. This update sets the `\"Grade\"` column to its current value minus `1` (`\"Grade\" = \"Grade\" - 1`). This modification is applied only to rows where the `\"Classroom\"` column matches the `\"Classroom\"` value from the current `v_classroom` record (`\"Classroom\" = v_classroom.\"Classroom\"`).\n\nIf the first `IF` condition is false, an `ELSIF` condition is evaluated, checking if `v_classroom.avg_grade` is less than `3`. If this condition is true, another `UPDATE` operation is executed on the `list` table. This update sets the `\"Grade\"` column to its current value plus `1` (`\"Grade\" = \"Grade\" + 1`). Similar to the previous update, this modification is applied only to rows where the `\"Classroom\"` column matches the `\"Classroom\"` value from the current `v_classroom` record (`\"Classroom\" = v_classroom.\"Classroom\"`).\n\nIf both the `IF` and `ELSIF` conditions are false (meaning `v_classroom.avg_grade` is between `3` and `5`, inclusive), the `ELSE` block is executed. Within this block, a `DELETE` operation is performed on the `list` table. This deletion targets rows where two conditions are met: first, the `\"Classroom\"` column must match the `\"Classroom\"` value from the current `v_classroom` record (`\"Classroom\" = v_classroom.\"Classroom\"`), and second, the `\"Grade\"` column must be equal to the minimum `\"Grade\"` found within that specific classroom. The minimum grade is determined by a subquery: `(SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\")`. This means that for the current classroom, any student record having the lowest grade in that classroom will be deleted.\n\nAfter the conditional statements are processed for the current `v_classroom` record, the loop continues to the next iteration, attempting to fetch the subsequent row from the cursor.\n\nOnce the `LOOP` terminates (when `NOT FOUND` is true), the `v_classroom_cursor` is explicitly `CLOSE`d, releasing its resources. The procedure then concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_student_grades()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_classroom RECORD;\n    v_classroom_cursor CURSOR FOR SELECT \"Classroom\", AVG(\"Grade\") as avg_grade FROM list GROUP BY \"Classroom\";\nBEGIN\n    OPEN v_classroom_cursor;\n    LOOP\n        FETCH v_classroom_cursor INTO v_classroom;\n        EXIT WHEN NOT FOUND;\n        IF v_classroom.avg_grade > 5 THEN\n            UPDATE list SET \"Grade\" = \"Grade\" - 1 WHERE \"Classroom\" = v_classroom.\"Classroom\";\n        ELSIF v_classroom.avg_grade < 3 THEN\n            UPDATE list SET \"Grade\" = \"Grade\" + 1 WHERE \"Classroom\" = v_classroom.\"Classroom\";\n        ELSE\n            DELETE FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\" AND \"Grade\" = (SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\");\n        END IF;\n    END LOOP;\n    CLOSE v_classroom_cursor;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "CALL adjust_student_grades();"
    ],
    "summary": "Create a stored procedure named adjust_student_grades with no parameters. For each classroom in the list table, calculate the average grade. If the classroom average is greater than 5, decrease every student's grade in that classroom by 1. If the average is less than 3, increase every student's grade by 1. If the average is between 3 and 5 (inclusive), delete the student(s) with the minimum grade in that classroom.",
    "natural_language": "Write a stored procedure called adjust_student_grades that takes no parameters. For every classroom in the list table, compute the average grade. Decrease each student's grade in that classroom by 1 if the classroom average is above 5. Increase each student's grade by 1 if the average is below 3. If the average is between 3 and 5, inclusive, remove the student or students who have the lowest grade in that classroom.",
    "id": 142
  },
  {
    "ir": "Write a PLpgSQL stored procedure that iterates over each unique classroom in the list table, counting the number of students in each classroom. For each classroom, if the student count exceeds 15, it deletes the student with the lowest grade from that classroom. If the student count is less than 5, it increments the grade of all students in that classroom by 1. If the student count is between 5 and 15 inclusive, it attempts to insert a new teacher with the last name 'NEW' and first name 'TEACHER' into the teachers table for that classroom, ensuring no duplicate entries for the same teacher name. The procedure uses a cursor to fetch each classroom record, processes each classroom based on the student count, and closes the cursor after processing all classrooms.",
    "plsql": "CREATE OR REPLACE PROCEDURE balance_classroom_load()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_classroom RECORD;\n    v_classroom_cursor CURSOR FOR SELECT \"Classroom\", COUNT(*) as student_count FROM list GROUP BY \"Classroom\";\nBEGIN\n    OPEN v_classroom_cursor;\n    LOOP\n        FETCH v_classroom_cursor INTO v_classroom;\n        EXIT WHEN NOT FOUND;\n        IF v_classroom.student_count > 15 THEN\n            DELETE FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\" AND \"Grade\" = (SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = v_classroom.\"Classroom\");\n        ELSIF v_classroom.student_count < 5 THEN\n            UPDATE list SET \"Grade\" = \"Grade\" + 1 WHERE \"Classroom\" = v_classroom.\"Classroom\";\n        ELSE\n            INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") \n            VALUES ('NEW', 'TEACHER', v_classroom.\"Classroom\")\n            ON CONFLICT (\"LastName\", \"FirstName\") DO NOTHING;\n        END IF;\n    END LOOP;\n    CLOSE v_classroom_cursor;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "CALL balance_classroom_load();"
    ],
    "summary": "Create a stored procedure with no parameters. For each classroom in the list table, count the students. If a classroom has more than 15 students, delete the student(s) with the lowest grade. If it has fewer than 5 students, increase every student's grade by 1. If it has 5 to 15 students, insert a new teacher ('NEW', 'TEACHER') for that classroom into the teachers table, preventing duplicate teacher names.",
    "natural_language": "How can I create a stored procedure that, for each classroom in the list table, counts its students and then, if the count is greater than 15, deletes the student(s) with the lowest grade; if the count is fewer than 5, increases every student's grade by 1; and if the count is between 5 and 15 inclusive, inserts a new teacher with the names 'NEW' and 'TEACHER' for that classroom into the teachers table while preventing duplicate teacher names?",
    "id": 143
  },
  {
    "ir": "Write a PLpgSQL stored procedure named insert_course_assignment that accepts two integer parameters: p_course_id and p_teacher_id. The procedure performs an insertion operation into the course_arrange table, specifically targeting the columns Course_ID, Teacher_ID, and Grade. The insertion involves selecting the values of p_course_id and p_teacher_id, along with a constant value of 1 for the Grade column. This operation is conditional, executed only if there is no existing record in the course_arrange table where the Course_ID matches p_course_id and the Teacher_ID matches p_teacher_id. The procedure uses a WHERE NOT EXISTS clause to ensure that the insertion occurs only when the specified combination of Course_ID and Teacher_ID is not already present in the table, thereby preventing duplicate entries for the same course-teacher assignment.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_course_assignment(p_course_id integer, p_teacher_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"course_arrange\" (\"Course_ID\", \"Teacher_ID\", \"Grade\")\n    SELECT p_course_id, p_teacher_id, 1\n    WHERE NOT EXISTS (\n        SELECT 1 FROM \"course_arrange\" \n        WHERE \"Course_ID\" = p_course_id AND \"Teacher_ID\" = p_teacher_id\n    );\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL insert_course_assignment(1, 1);",
      "CALL insert_course_assignment(2, 2);",
      "CALL insert_course_assignment(3, 3);",
      "CALL insert_course_assignment(1, 3);",
      "CALL insert_course_assignment(2, 1);"
    ],
    "summary": "Create a stored procedure named insert_course_assignment that accepts parameters p_course_id and p_teacher_id. Insert a record into the course_arrange table with the provided IDs and a Grade of 1, but only if a record with that exact course and teacher combination does not already exist.",
    "natural_language": "Develop a stored procedure called insert_course_assignment that takes two input parameters, specifically p_course_id and p_teacher_id. This procedure should carefully insert a new entry into the course_arrange table, using the supplied IDs and setting the Grade to 1, but it must first perform a crucial check to ensure that an identical record, which matches both the course and the teacher precisely, does not already exist in the database.",
    "id": 144
  },
  {
    "ir": "Write a PLpgSQL stored procedure named remove_teacher_assignments that accepts two integer parameters: p_teacher_id and p_grade. The procedure performs a delete operation on the course_arrange table, specifically targeting rows where the Teacher_ID column matches the value of p_teacher_id and the Grade column matches the value of p_grade. The procedure does not include any conditional logic beyond the specified matching criteria for the deletion operation, nor does it perform any other operations such as updates, inserts, or selects. The procedure is designed to remove all records from the course_arrange table that are associated with a particular teacher and grade level, as identified by the provided parameter values.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_teacher_assignments(p_teacher_id integer, p_grade integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"course_arrange\"\n    WHERE \"Teacher_ID\" = p_teacher_id AND \"Grade\" = p_grade;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL remove_teacher_assignments(5, 1);",
      "CALL remove_teacher_assignments(3, 3);",
      "CALL remove_teacher_assignments(2, 5);",
      "CALL remove_teacher_assignments(1, 1);",
      "CALL remove_teacher_assignments(5, 3);"
    ],
    "summary": "Create a stored procedure named remove_teacher_assignments that accepts parameters p_teacher_id and p_grade. Delete all records from the course_arrange table where the Teacher_ID matches the provided teacher ID and the Grade matches the provided grade.",
    "natural_language": "Hey, can you whip up a stored procedure called remove_teacher_assignments? It needs to take a teacher's ID and a grade as input. Basically, just scrub all the entries from the course_arrange table where the Teacher_ID is the one we gave you and the Grade matches too.",
    "id": 145
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `validate_teacher_workload` that accepts two input parameters: `p_teacher_id` of type `integer`, representing the unique identifier for a teacher, and `p_max_courses` of type `integer`, intended to represent the maximum number of courses a teacher can handle (though this parameter is not utilized within the current procedure's logic). The procedure begins by declaring two local variables: `v_current_workload` of type `integer`, which will store the count of courses assigned to a teacher, and `v_teacher_exists` of type `boolean`, which will indicate whether a teacher with the given `p_teacher_id` already exists in the database. The procedure then executes a `SELECT` statement to determine if a teacher with the `Teacher_ID` matching the `p_teacher_id` parameter exists in the table named `\"teacher\"`. This `SELECT` statement uses `EXISTS(SELECT 1 FROM \"teacher\" WHERE \"Teacher_ID\" = p_teacher_id)` to efficiently check for the presence of such a record, and the result of this existence check is stored in the `v_teacher_exists` boolean variable. Following this, a conditional `IF` statement evaluates the value of `v_teacher_exists`. If `v_teacher_exists` is `TRUE`, indicating that a teacher with the specified `p_teacher_id` already exists, the procedure proceeds to execute another `SELECT` statement. This `SELECT` statement counts the number of rows in the table named `\"course_arrange\"` where the `Teacher_ID` column matches the `p_teacher_id` parameter. The result of this count, representing the current workload of the existing teacher, is then stored in the `v_current_workload` integer variable. Conversely, if `v_teacher_exists` is `FALSE`, meaning no teacher with the provided `p_teacher_id` was found in the `\"teacher\"` table, the procedure executes an `INSERT` statement. This `INSERT` statement adds a new row into the `\"teacher\"` table. The `Teacher_ID` column of this new row is populated with the value from the `p_teacher_id` parameter, the `Name` column is set to the literal string `'New Teacher'`, the `Age` column is set to the literal string `'30'`, and the `Hometown` column is set to the literal string `'Unknown'`. The procedure concludes after the execution of either the `SELECT` statement for workload calculation or the `INSERT` statement for a new teacher, depending on the existence check.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_teacher_workload(p_teacher_id integer, p_max_courses integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_workload integer;\n    v_teacher_exists boolean;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM \"teacher\" WHERE \"Teacher_ID\" = p_teacher_id) INTO v_teacher_exists;\n    \n    IF v_teacher_exists THEN\n        SELECT COUNT(*) INTO v_current_workload\n        FROM \"course_arrange\"\n        WHERE \"Teacher_ID\" = p_teacher_id;\n    ELSE\n        INSERT INTO \"teacher\" (\"Teacher_ID\", \"Name\", \"Age\", \"Hometown\")\n        VALUES (p_teacher_id, 'New Teacher', '30', 'Unknown');\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL validate_teacher_workload(1, 5);",
      "CALL validate_teacher_workload(2, 3);",
      "CALL validate_teacher_workload(10, 4);",
      "CALL validate_teacher_workload(3, 6);",
      "CALL validate_teacher_workload(99, 2);"
    ],
    "summary": "Create a stored procedure named validate_teacher_workload that accepts a teacher ID and a maximum courses parameter. Check if the teacher exists. If they exist, count their assigned courses from the course_arrange table. If they do not exist, insert a new teacher record with default values.",
    "natural_language": "Create procedure validate_teacher_workload. Takes teacher ID and max courses. Check teacher exists. If yes, count their courses from course_arrange. If no, insert teacher with defaults.",
    "id": 146
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes an integer parameter p_artist_id and retrieves the Age of the artist from the artist table where the Artist_ID matches the provided p_artist_id. It stores this Age value in a local variable v_age. The procedure then evaluates the value of v_age using conditional logic: if v_age is less than 25, it assigns the text 'Young' to another local variable v_category; if v_age is between 25 and 35 inclusive, it assigns 'Mid' to v_category; otherwise, it assigns 'Veteran' to v_category. Finally, the procedure updates the artist table by setting the Famous_Title column to the value of v_category for the row where the Artist_ID matches the provided p_artist_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_artist_age_category(p_artist_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_age integer;\n    v_category text;\nBEGIN\n    SELECT \"Age\" INTO v_age\n    FROM artist\n    WHERE \"Artist_ID\" = p_artist_id;\n\n    IF v_age < 25 THEN\n        v_category := 'Young';\n    ELSIF v_age BETWEEN 25 AND 35 THEN\n        v_category := 'Mid';\n    ELSE\n        v_category := 'Veteran';\n    END IF;\n\n    UPDATE artist\n    SET \"Famous_Title\" = v_category\n    WHERE \"Artist_ID\" = p_artist_id;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL update_artist_age_category(1);",
      "CALL update_artist_age_category(2);",
      "CALL update_artist_age_category(3);",
      "CALL update_artist_age_category(10);",
      "CALL update_artist_age_category(15);"
    ],
    "summary": "Create a stored procedure that accepts an artist ID. Retrieve the artist's age and categorize them as 'Young' (age < 25), 'Mid' (age between 25 and 35), or 'Veteran' (age > 35). Update the artist's Famous_Title column with this category.",
    "natural_language": "Hey, can you whip up a stored procedure that takes an artist's ID? It should figure out how old the artist is and slap a label on 'em: 'Young' if they're under 25, 'Mid' if they're 25 to 35, or 'Veteran' if they're over 35. Then, just update that artist's Famous_Title column with whatever category you got.",
    "id": 147
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `calculate_festival_statistics` that accepts one input parameter, `p_year`, which is of type `text` and represents the year for which statistics are to be calculated. The procedure declares three local variables: `v_festival_count` of type `integer` to store the count of music festivals, `v_total_weeks` of type `real` to accumulate the total weeks on top, and `v_avg_weeks` of type `real` to store the calculated average weeks on top. The procedure begins by executing a `SELECT` statement to count the number of records in the `music_festival` table. This count is stored in the `v_festival_count` variable. The `WHERE` clause for this `SELECT` statement filters records where the `Date_of_ceremony` column contains the `p_year` string as a substring, using the `LIKE` operator with wildcard characters (`%`). Next, another `SELECT` statement is executed to calculate the sum of values from the `Weeks_on_Top` column in the `volume` table. This sum is stored in the `v_total_weeks` variable. The `WHERE` clause for this `SELECT` statement filters records where the `Issue_Date` column contains the `p_year` string as a substring, again using the `LIKE` operator with wildcard characters. Following these data retrievals, a conditional `IF` statement checks if the `v_festival_count` is greater than 0. If `v_festival_count` is positive, the `v_avg_weeks` variable is calculated by dividing `v_total_weeks` by `v_festival_count`. Otherwise, if `v_festival_count` is 0 or less, `v_avg_weeks` is set to 0. Finally, an `INSERT` statement is executed to add a new record into the `volume` table. The values for the columns are determined as follows: `Volume_ID` is set to one greater than the maximum existing `Volume_ID` in the `volume` table, using a subquery with `COALESCE` to handle cases where no `Volume_ID` exists (defaulting to 0 before adding 1); `Volume_Issue` is set to the concatenated string 'Statistics:' followed by the `p_year` parameter; `Issue_Date` is set to the current date converted to `text` using `CURRENT_DATE::text`; `Weeks_on_Top` is set to the calculated `v_avg_weeks`; `Song` is set to the literal string 'Festival Stats'; and `Artist_ID` is set to `NULL`.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_festival_statistics(p_year text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_festival_count integer;\n    v_total_weeks real;\n    v_avg_weeks real;\nBEGIN\n    SELECT COUNT(*) INTO v_festival_count\n    FROM music_festival\n    WHERE \"Date_of_ceremony\" LIKE '%' || p_year || '%';\n\n    SELECT SUM(\"Weeks_on_Top\") INTO v_total_weeks\n    FROM volume\n    WHERE \"Issue_Date\" LIKE '%' || p_year || '%';\n\n    IF v_festival_count > 0 THEN\n        v_avg_weeks := v_total_weeks / v_festival_count;\n    ELSE\n        v_avg_weeks := 0;\n    END IF;\n\n    INSERT INTO volume (\"Volume_ID\", \"Volume_Issue\", \"Issue_Date\", \"Weeks_on_Top\", \"Song\", \"Artist_ID\")\n    VALUES (\n        (SELECT COALESCE(MAX(\"Volume_ID\"), 0) + 1 FROM volume),\n        'Statistics:' || p_year,\n        CURRENT_DATE::text,\n        v_avg_weeks,\n        'Festival Stats',\n        NULL\n    );\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL calculate_festival_statistics('2011');",
      "CALL calculate_festival_statistics('1986');",
      "CALL calculate_festival_statistics('2007');",
      "CALL calculate_festival_statistics('2008');",
      "CALL calculate_festival_statistics('2009');"
    ],
    "summary": "Create a stored procedure named calculate_festival_statistics that accepts a year as text. Count music festivals for that year and sum the total weeks on top from the volume table. Calculate the average weeks per festival. Insert a new record into the volume table with the statistics, including the calculated average, a descriptive issue, the current date, and a default song title.",
    "natural_language": "Please construct a stored procedure designated as 'calculate_festival_statistics' that receives a year parameter in text format. The procedure should ascertain the count of music festivals for the specified year and compute the summation of total weeks on top from the volume table. Subsequently, calculate the average weeks per festival. Finally, insert a new entry into the volume table containing these statistics, the computed average, a descriptive issue, the current date, and a default song title.",
    "id": 148
  },
  {
    "ir": "Write a PLpgSQL stored procedure named insert_artist_summary that accepts a single integer parameter p_cutoff_age, which is used to categorize artists based on their age. The procedure begins by declaring three integer variables: v_young_count, v_mid_count, and v_veteran_count, which will store the count of artists in different age groups. It performs three SELECT COUNT(*) operations on the artist table to determine the number of artists in each age category: those younger than p_cutoff_age, those whose age is between p_cutoff_age and p_cutoff_age + 10, and those older than p_cutoff_age + 10. The results are stored in the respective variables. The procedure then uses an IF-ELSIF-ELSE conditional structure to compare these counts. If the count of young artists (v_young_count) is greater than both mid-aged (v_mid_count) and veteran artists (v_veteran_count), it inserts a new record into the volume table with the Volume_Issue set to 'Young Dominance', the current date as Issue_Date, the count of young artists as Weeks_on_Top, and 'Young Artists' as Song. If the count of mid-aged artists is the highest, it inserts a record with Volume_Issue set to 'Mid Dominance', the count of mid-aged artists as Weeks_on_Top, and 'Mid Artists' as Song. Otherwise, it inserts a record with Volume_Issue set to 'Veteran Dominance', the count of veteran artists as Weeks_on_Top, and 'Veteran Artists' as Song. In each case, the Volume_ID is determined by selecting the maximum existing Volume_ID from the volume table, incremented by one, and Artist_ID is set to NULL.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_artist_summary(p_cutoff_age integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_young_count integer;\n    v_mid_count integer;\n    v_veteran_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_young_count\n    FROM artist\n    WHERE \"Age\" < p_cutoff_age;\n\n    SELECT COUNT(*) INTO v_mid_count\n    FROM artist\n    WHERE \"Age\" BETWEEN p_cutoff_age AND p_cutoff_age + 10;\n\n    SELECT COUNT(*) INTO v_veteran_count\n    FROM artist\n    WHERE \"Age\" > p_cutoff_age + 10;\n\n    IF v_young_count > v_mid_count AND v_young_count > v_veteran_count THEN\n        INSERT INTO volume (\"Volume_ID\", \"Volume_Issue\", \"Issue_Date\", \"Weeks_on_Top\", \"Song\", \"Artist_ID\")\n        VALUES (\n            (SELECT COALESCE(MAX(\"Volume_ID\"), 0) + 1 FROM volume),\n            'Young Dominance',\n            CURRENT_DATE::text,\n            v_young_count,\n            'Young Artists',\n            NULL\n        );\n    ELSIF v_mid_count > v_young_count AND v_mid_count > v_veteran_count THEN\n        INSERT INTO volume (\"Volume_ID\", \"Volume_Issue\", \"Issue_Date\", \"Weeks_on_Top\", \"Song\", \"Artist_ID\")\n        VALUES (\n            (SELECT COALESCE(MAX(\"Volume_ID\"), 0) + 1 FROM volume),\n            'Mid Dominance',\n            CURRENT_DATE::text,\n            v_mid_count,\n            'Mid Artists',\n            NULL\n        );\n    ELSE\n        INSERT INTO volume (\"Volume_ID\", \"Volume_Issue\", \"Issue_Date\", \"Weeks_on_Top\", \"Song\", \"Artist_ID\")\n        VALUES (\n            (SELECT COALESCE(MAX(\"Volume_ID\"), 0) + 1 FROM volume),\n            'Veteran Dominance',\n            CURRENT_DATE::text,\n            v_veteran_count,\n            'Veteran Artists',\n            NULL\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL insert_artist_summary(25);",
      "CALL insert_artist_summary(30);",
      "CALL insert_artist_summary(20);",
      "CALL insert_artist_summary(35);",
      "CALL insert_artist_summary(40);"
    ],
    "summary": "Create a stored procedure named insert_artist_summary that accepts a cutoff age. Count artists in three age groups: younger than the cutoff, between cutoff and cutoff+10, and older than cutoff+10. Determine which group has the highest count. Insert a record into the volume table indicating the dominant group (Young, Mid, or Veteran Dominance), using the group's count as the Weeks_on_Top value.",
    "natural_language": "What stored procedure can be created to insert an artist summary, where it takes a cutoff age, counts artists in three age groups (younger than the cutoff, between the cutoff and cutoff+10, and older than cutoff+10), determines which group has the highest count, and then inserts a record into the volume table to indicate if the dominant group is Young, Mid, or Veteran Dominance, using that group's count as the Weeks_on_Top value?",
    "id": 149
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_volume_issue` that accepts a single input parameter, `p_volume_id`, which is of type `integer`. This procedure is designed to categorize and update the \"Volume_Issue\" status for a specific volume record based on its \"Weeks_on_Top\" value. The procedure begins by declaring two local variables: `v_weeks_on_top` of type `real` to store the retrieved \"Weeks_on_Top\" value, and `v_new_issue` of type `text` to hold the calculated issue category. The first operation performed is a `SELECT` statement that retrieves the value from the column named `\"Weeks_on_Top\"` from the table named `volume`. This retrieval is conditional, specifically targeting the row where the column named `\"Volume_ID\"` matches the value provided by the input parameter `p_volume_id`. The retrieved `\"Weeks_on_Top\"` value is then assigned to the local variable `v_weeks_on_top`. Following this data retrieval, a conditional logic block (`IF...ELSIF...ELSE...END IF`) is executed to determine the appropriate \"Volume_Issue\" category. If the value of `v_weeks_on_top` is strictly less than `2`, the local variable `v_new_issue` is assigned the string literal `'Low Impact'`. If the previous condition is false, and the value of `v_weeks_on_top` is between `2` (inclusive) and `5` (inclusive), then `v_new_issue` is assigned the string literal `'Moderate Impact'`. If neither of the preceding conditions is met (meaning `v_weeks_on_top` is greater than `5`), then `v_new_issue` is assigned the string literal `'High Impact'`. Finally, an `UPDATE` statement is executed on the table named `volume`. This `UPDATE` statement sets the value of the column named `\"Volume_Issue\"` to the value stored in the local variable `v_new_issue`. This update is also conditional, applying only to the row where the column named `\"Volume_ID\"` matches the value provided by the input parameter `p_volume_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_volume_issue(p_volume_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_weeks_on_top real;\n    v_new_issue text;\nBEGIN\n    SELECT \"Weeks_on_Top\" INTO v_weeks_on_top\n    FROM volume\n    WHERE \"Volume_ID\" = p_volume_id;\n\n    IF v_weeks_on_top < 2 THEN\n        v_new_issue := 'Low Impact';\n    ELSIF v_weeks_on_top BETWEEN 2 AND 5 THEN\n        v_new_issue := 'Moderate Impact';\n    ELSE\n        v_new_issue := 'High Impact';\n    END IF;\n\n    UPDATE volume\n    SET \"Volume_Issue\" = v_new_issue\n    WHERE \"Volume_ID\" = p_volume_id;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL update_volume_issue(1);",
      "CALL update_volume_issue(2);",
      "CALL update_volume_issue(3);",
      "CALL update_volume_issue(10);",
      "CALL update_volume_issue(15);"
    ],
    "summary": "Create a stored procedure named update_volume_issue that accepts a volume ID. Retrieve its Weeks_on_Top value. Categorize it as 'Low Impact' (value < 2), 'Moderate Impact' (value between 2 and 5), or 'High Impact' (value > 5). Update the volume record's Volume_Issue column with this new category.",
    "natural_language": "Please construct a stored procedure designated as 'update_volume_issue'. This procedure shall accept a volume ID as an input parameter. It must then retrieve the associated 'Weeks_on_Top' value for the specified volume. Subsequently, the procedure is to categorize the volume based on the retrieved value according to the following criteria: if the value is less than 2, assign the category 'Low Impact'; if the value falls between 2 and 5 inclusive, assign 'Moderate Impact'; and if the value exceeds 5, assign 'High Impact'. Finally, the procedure must update the 'Volume_Issue' column within the corresponding volume record with the newly determined category.",
    "id": 150
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named register_wedding_ceremony that accepts three integer input parameters: p_church_id representing a church identifier, p_male_id representing a male participant identifier, and p_female_id representing a female participant identifier, and performs a single INSERT operation into the table named wedding, specifically populating the columns \"Church_ID\" with the value of p_church_id, \"Male_ID\" with the value of p_male_id, \"Female_ID\" with the value of p_female_id, and the \"Year\" column with the four-digit year component extracted from the current system date via the EXTRACT(YEAR FROM CURRENT_DATE) function call, and includes an ON CONFLICT clause that specifies to take no action and silently skip the insertion if a row already exists in the wedding table with an identical combination of values for the columns \"Church_ID\", \"Male_ID\", and \"Female_ID\".",
    "plsql": "CREATE OR REPLACE PROCEDURE register_wedding_ceremony(p_church_id integer, p_male_id integer, p_female_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO wedding (\"Church_ID\", \"Male_ID\", \"Female_ID\", \"Year\")\n    VALUES (p_church_id, p_male_id, p_female_id, EXTRACT(YEAR FROM CURRENT_DATE))\n    ON CONFLICT (\"Church_ID\", \"Male_ID\", \"Female_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL register_wedding_ceremony(1, 1, 2);",
      "CALL register_wedding_ceremony(2, 3, 4);",
      "CALL register_wedding_ceremony(3, 5, 6);",
      "CALL register_wedding_ceremony(1, 7, 8);",
      "CALL register_wedding_ceremony(2, 9, 10);"
    ],
    "summary": "Create a stored procedure named register_wedding_ceremony that inserts a record into the wedding table. It takes three integer parameters: church ID, male ID, and female ID. The procedure sets the Year column to the current year. If a record with the same church, male, and female IDs already exists, the insert is skipped.",
    "natural_language": "Please construct a stored procedure designated as 'register_wedding_ceremony' for the purpose of inserting a new entry into the wedding table. This procedure is to accept three integer parameters: the church identifier, the male participant identifier, and the female participant identifier. The procedure shall assign the current year to the 'Year' column. It is imperative that the insertion operation is omitted should a record already exist with identical values for the specified church, male, and female identifiers.",
    "id": 151
  },
  {
    "ir": "Write a PLpgSQL stored procedure named remove_wedding_record that accepts three integer parameters: p_church_id, p_male_id, and p_female_id. This procedure performs a delete operation on the wedding table, specifically targeting rows where the Church_ID column matches the value of p_church_id, the Male_ID column matches the value of p_male_id, and the Female_ID column matches the value of p_female_id. The procedure does not include any conditional statements or function calls beyond the delete operation, and it directly removes records from the wedding table based on the specified criteria.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_wedding_record(p_church_id integer, p_male_id integer, p_female_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM wedding \n    WHERE \"Church_ID\" = p_church_id \n    AND \"Male_ID\" = p_male_id \n    AND \"Female_ID\" = p_female_id;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL remove_wedding_record(1, 1, 2);",
      "CALL remove_wedding_record(3, 3, 4);",
      "CALL remove_wedding_record(5, 5, 6);",
      "CALL remove_wedding_record(2, 10, 12);",
      "CALL remove_wedding_record(4, 15, 18);"
    ],
    "summary": "Create a stored procedure named remove_wedding_record that deletes a record from the wedding table. It uses three integer parameters (church ID, male ID, female ID) to identify the exact row to delete.",
    "natural_language": "Hey, can you whip up a stored procedure called remove_wedding_record that'll wipe a wedding from the records? You gotta use three numbers to pinpoint the exact one: the church ID, the guy's ID, and the lady's ID.",
    "id": 152
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `establish_new_church` that accepts three input parameters: `p_name` of type `text`, representing the name of the new church; `p_organizer` of type `text`, representing the entity or individual who organized the church; and `p_open_year` of type `integer`, representing the year the church was opened. The procedure first declares a local variable `v_church_id` of type `integer`. It then calculates the value for `v_church_id` by executing a `SELECT` statement on the `church` table. This `SELECT` statement retrieves the maximum value from the `\"Church_ID\"` column. The `COALESCE` function is applied to this maximum value, ensuring that if no rows exist in the `church` table or if `\"Church_ID\"` is `NULL` for all rows, `0` is used instead of `NULL`. This result is then incremented by `1` to generate a new, unique identifier for the church. Following this, the procedure performs an `INSERT` operation into the `church` table. The `INSERT` statement populates the columns `\"Church_ID\"`, `\"Name\"`, `\"Organized_by\"`, and `\"Open_Date\"`. The value for `\"Church_ID\"` is taken from the previously calculated `v_church_id`. The value for `\"Name\"` is taken from the input parameter `p_name`. The value for `\"Organized_by\"` is taken from the input parameter `p_organizer`. The value for `\"Open_Date\"` is taken from the input parameter `p_open_year`.",
    "plsql": "CREATE OR REPLACE PROCEDURE establish_new_church(p_name text, p_organizer text, p_open_year integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_church_id integer;\nBEGIN\n    v_church_id := (SELECT COALESCE(MAX(\"Church_ID\"), 0) + 1 FROM church);\n    \n    INSERT INTO church (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\")\n    VALUES (v_church_id, p_name, p_organizer, p_open_year);\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL establish_new_church('New Hope Church', 'John Doe', 2023);",
      "CALL establish_new_church('Unity Church', 'Jane Smith', 2024);",
      "CALL establish_new_church('Grace Church', 'Emily Johnson', 2025);",
      "CALL establish_new_church('Faith Church', 'Michael Brown', 2026);",
      "CALL establish_new_church('Peace Church', 'Sarah Davis', 2027);"
    ],
    "summary": "Create a stored procedure named establish_new_church that inserts a new church. It takes parameters for name, organizer, and opening year. The procedure generates a new unique Church_ID by finding the maximum existing ID, defaulting to 0 if none exist, and adding 1.",
    "natural_language": "Write a stored procedure called establish_new_church to insert a new church. The procedure must accept the church's name, organizer, and opening year as parameters. It should generate a unique Church_ID by calculating the maximum existing ID (starting from 0 if no records exist) and then incrementing it by one.",
    "id": 153
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named remove_person_data that accepts three input parameters: an integer parameter p_people_id to specify a person identifier, an integer parameter p_min_age to specify a minimum age threshold, and a text parameter p_country to specify a country name, and performs a single delete operation on the table named people, specifically removing all rows from the people table where the value in the column named People_ID is exactly equal to the provided p_people_id parameter, and simultaneously, the value in the column named Age is greater than or equal to the provided p_min_age parameter, and simultaneously, the value in the column named Country is exactly equal to the provided p_country parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_person_data(p_people_id integer, p_min_age integer, p_country text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM people \n    WHERE \"People_ID\" = p_people_id \n    AND \"Age\" >= p_min_age \n    AND \"Country\" = p_country;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL remove_person_data(1, 30, 'Canada');",
      "CALL remove_person_data(2, 35, 'Sweden');",
      "CALL remove_person_data(3, 25, 'United States');",
      "CALL remove_person_data(1, 40, 'Canada');",
      "CALL remove_person_data(2, 32, 'Sweden');"
    ],
    "summary": "Create a stored procedure named remove_person_data that deletes records from the people table. It uses three parameters: a specific People_ID, a minimum Age, and a Country. All conditions must be met for a row to be deleted.",
    "natural_language": "Delete from people where People_ID, Age, and Country match given parameters.",
    "id": 154
  },
  {
    "ir": "Write a PLpgSQL stored procedure named enroll_student_in_course that accepts four parameters: p_student_id of type bigint representing the unique identifier of a student, p_course_id of type bigint representing the unique identifier of a course, p_enrolment_date of type timestamp with time zone indicating the date and time when the student is enrolled in the course, and p_completion_date of type timestamp with time zone indicating the expected date and time of course completion. The procedure begins by declaring a local variable v_registration_id of type bigint to store the new registration identifier. It then executes a SELECT statement to retrieve the maximum value of registration_id from the Student_Course_Enrolment table, using the COALESCE function to ensure that if no records exist, the result defaults to 0, and increments this value by 1 to generate a new registration_id. This new registration_id is stored in the v_registration_id variable. Subsequently, the procedure performs an INSERT operation into the Student_Course_Enrolment table, populating the registration_id column with the value of v_registration_id, the student_id column with the value of p_student_id, the course_id column with the value of p_course_id, the date_of_enrolment column with the value of p_enrolment_date, and the date_of_completion column with the value of p_completion_date, effectively enrolling the student in the specified course with the provided enrolment and completion dates.",
    "plsql": "CREATE OR REPLACE PROCEDURE enroll_student_in_course(\n    p_student_id bigint,\n    p_course_id bigint,\n    p_enrolment_date timestamp with time zone,\n    p_completion_date timestamp with time zone\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_registration_id bigint;\nBEGIN\n    SELECT COALESCE(MAX(registration_id), 0) + 1 INTO v_registration_id FROM \"Student_Course_Enrolment\";\n    \n    INSERT INTO \"Student_Course_Enrolment\" (registration_id, student_id, course_id, date_of_enrolment, date_of_completion)\n    VALUES (v_registration_id, p_student_id, p_course_id, p_enrolment_date, p_completion_date);\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Students",
      "Student_Course_Enrolment",
      "Courses"
    ],
    "call_sqls": [
      "CALL enroll_student_in_course(1, 1, '2023-01-01 10:00:00+00', '2023-06-30 10:00:00+00');",
      "CALL enroll_student_in_course(2, 1, '2023-02-15 11:30:00+00', '2023-07-15 11:30:00+00');",
      "CALL enroll_student_in_course(3, 2, '2023-03-01 09:00:00+00', '2023-08-31 09:00:00+00');",
      "CALL enroll_student_in_course(1, 3, '2023-04-10 14:00:00+00', '2023-09-10 14:00:00+00');",
      "CALL enroll_student_in_course(2, 3, '2023-05-20 16:00:00+00', '2023-10-20 16:00:00+00');"
    ],
    "summary": "Create a stored procedure named enroll_student_in_course that inserts a student's course enrollment. It takes parameters for student ID, course ID, enrollment timestamp, and expected completion timestamp. The procedure generates a new registration_id by finding the maximum existing one (defaulting to 0) and adding 1.",
    "natural_language": "How can I create a stored procedure called enroll_student_in_course to insert a student's course enrollment, using parameters for student ID, course ID, enrollment timestamp, and expected completion timestamp, where the procedure generates a new registration_id by incrementing the maximum existing one by 1 (starting from 0 if none exist)?",
    "id": 155
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named process_student_registration that accepts four input parameters: a text parameter p_login_name representing the new student's login identifier, a text parameter p_password representing the new student's password, a text parameter p_personal_name representing the new student's given name, and a text parameter p_family_name representing the new student's surname. The procedure begins by declaring two local variables: a bigint variable v_student_id to hold the generated student identifier and a timestamp with time zone variable v_registration_date to store the registration timestamp. It then assigns the current date and time from the system clock, obtained via the CURRENT_TIMESTAMP function, to the v_registration_date variable. Next, it queries the \"Students\" table to calculate the next sequential student identifier by selecting the maximum existing value from the student_id column, using the COALESCE function to substitute a value of 0 if the table is empty and no maximum exists, and then adding 1 to that result, storing the final value into the v_student_id variable. Finally, the procedure performs a single INSERT operation into the \"Students\" table, creating a new row with the following column values: the generated v_student_id for the student_id column, the v_registration_date for both the date_of_registration and date_of_latest_logon columns, the input parameter p_login_name for the login_name column, the input parameter p_password for the password column, the input parameter p_personal_name for the personal_name column, an empty string literal '' for the middle_name column, and the input parameter p_family_name for the family_name column.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_student_registration(\n    p_login_name text,\n    p_password text,\n    p_personal_name text,\n    p_family_name text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_id bigint;\n    v_registration_date timestamp with time zone;\nBEGIN\n    v_registration_date := CURRENT_TIMESTAMP;\n    \n    SELECT COALESCE(MAX(student_id), 0) + 1 INTO v_student_id FROM \"Students\";\n    \n    INSERT INTO \"Students\" (student_id, date_of_registration, date_of_latest_logon, login_name, password, personal_name, middle_name, family_name)\n    VALUES (v_student_id, v_registration_date, v_registration_date, p_login_name, p_password, p_personal_name, '', p_family_name);\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Students",
      "Student_Course_Enrolment",
      "Courses"
    ],
    "call_sqls": [
      "CALL process_student_registration('john.doe', 'securepass123', 'John', 'Doe');",
      "CALL process_student_registration('jane.smith', 'myp@ssw0rd', 'Jane', 'Smith');",
      "CALL process_student_registration('bob.jones', 'b0bpass!', 'Bob', 'Jones');",
      "CALL process_student_registration('alice.wonder', 'alice123', 'Alice', 'Wonder');",
      "CALL process_student_registration('charlie.brown', 'chuck99', 'Charlie', 'Brown');"
    ],
    "summary": "Create a stored procedure named process_student_registration that inserts a new student record. It takes four text inputs: login name, password, personal name, and family name. The procedure generates a new student ID by incrementing the maximum existing ID (starting at 0 if none exist) and uses the current timestamp for registration and latest logon dates. It inserts the new data into the Students table, setting the middle name to an empty string.",
    "natural_language": "Compose a stored procedure designated as 'process_student_registration' to insert a new entry into the student registry. This procedure shall accept four textual parameters: a login name, a password, a personal name, and a family name. It must generate a unique student identifier by incrementing the highest existing ID value, commencing from 0 should no records be present. The current system timestamp is to be utilized for both the registration date and the most recent logon date. The procedure will then insert the assembled data into the Students table, explicitly assigning an empty string to the middle name field.",
    "id": 156
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_architect_projects` that accepts a single input parameter, `p_architect_id`, of type `INTEGER`. This procedure is designed to perform various operations on architect-related data based on the provided architect's ID.\n\nUpon execution, the procedure first declares several local variables: `v_architect_name` of type `TEXT` to store the architect's name, `v_bridge_count` of type `INTEGER` to store the count of bridges, `v_mill_count` of type `INTEGER` to store the count of mills, `v_total_length` of type `REAL` to store the sum of bridge lengths, `v_avg_year` of type `INTEGER` to store the average built year of mills, and `v_action_code` of type `INTEGER` to store a numerical code representing the action taken.\n\nThe procedure then attempts to retrieve the `name` from the `architect` table into the `v_architect_name` variable, specifically for the row where the `id` column, explicitly cast to an `INTEGER`, matches the input parameter `p_architect_id`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block to determine the subsequent actions:\n\n1.  **If `v_architect_name` is `NULL`**: This condition implies that no architect with the given `p_architect_id` was found in the `architect` table. In this scenario, the procedure inserts a new record into the `bridge` table. The `id` for this new bridge is determined by selecting the maximum existing `id` from the `bridge` table, using `COALESCE` to default to `0` if no `id` exists, and then adding `1` to it. The `architect_id` for this new bridge is set to the input `p_architect_id`. The `name` is set to the literal string 'Default Bridge', the `location` to 'Unknown', the `length_meters` to `50.0`, and the `length_feet` to `164.0`.\n\n2.  **Else if `p_architect_id` is less than `10`**: If an architect was found and their `id` is less than `10`, the procedure proceeds to count the number of bridges and mills associated with this architect. It selects the count of all rows from the `bridge` table where the `architect_id` matches `p_architect_id` and stores this count in `v_bridge_count`. Concurrently, it selects the count of all rows from the `mill` table where the `architect_id` matches `p_architect_id` and stores this count in `v_mill_count`. Finally, it calculates `v_action_code` by summing `v_bridge_count` and `v_mill_count`.\n\n3.  **Else if `p_architect_id` is between `10` and `20` (inclusive)**: If the architect's `id` falls within this range, the procedure calculates the total length of bridges and the average built year of mills for this architect. It selects the sum of the `length_meters` column from the `bridge` table where the `architect_id` matches `p_architect_id` and stores this sum in `v_total_length`. Simultaneously, it selects the average of the `built_year` column from the `mill` table where the `architect_id` matches `p_architect_id` and stores this average in `v_avg_year`. The `v_action_code` is then calculated by summing the `v_total_length` (coalesced to `0` if `NULL` and then cast to `INTEGER`) and `v_avg_year` (coalesced to `0` if `NULL`).\n\n4.  **Else if `p_architect_id` is greater than `20` AND `p_architect_id` is less than `50`**: For architects whose `id` is in this specific range, the procedure performs deletion operations. It deletes rows from the `bridge` table where the `architect_id` matches `p_architect_id` AND the `length_meters` is less than `100`. Concurrently, it deletes rows from the `mill` table where the `architect_id` matches `p_architect_id` AND the `built_year` is less than `1900`. After these deletions, `v_action_code` is set to `1`.\n\n5.  **Else (for any other `p_architect_id` value)**: If none of the above conditions are met, the procedure updates the `architect` table. It sets the `name` column to the ASCII representation of its current value (using the `to_ascii` function) for the row where the `id` column, explicitly cast to an `INTEGER`, matches `p_architect_id`. After this update, `v_action_code` is set to `2`.\n\nFinally, regardless of the conditional path taken, the procedure raises a notice message using `RAISE NOTICE`. This message displays the text 'Processed architect % with code %', substituting the first `%` with the value of `v_architect_name` and the second `%` with the value of `v_action_code`.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_architect_projects(p_architect_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_architect_name TEXT;\n    v_bridge_count INTEGER;\n    v_mill_count INTEGER;\n    v_total_length REAL;\n    v_avg_year INTEGER;\n    v_action_code INTEGER;\nBEGIN\n    SELECT \"name\" INTO v_architect_name FROM \"architect\" WHERE \"id\"::INTEGER = p_architect_id;\n    \n    IF v_architect_name IS NULL THEN\n        INSERT INTO \"bridge\" (\"id\", \"architect_id\", \"name\", \"location\", \"length_meters\", \"length_feet\")\n        VALUES ((SELECT COALESCE(MAX(\"id\"), 0) + 1 FROM \"bridge\"), p_architect_id, 'Default Bridge', 'Unknown', 50.0, 164.0);\n    ELSIF p_architect_id < 10 THEN\n        SELECT COUNT(*) INTO v_bridge_count FROM \"bridge\" WHERE \"architect_id\" = p_architect_id;\n        SELECT COUNT(*) INTO v_mill_count FROM \"mill\" WHERE \"architect_id\" = p_architect_id;\n        v_action_code := v_bridge_count + v_mill_count;\n    ELSIF p_architect_id BETWEEN 10 AND 20 THEN\n        SELECT SUM(\"length_meters\") INTO v_total_length FROM \"bridge\" WHERE \"architect_id\" = p_architect_id;\n        SELECT AVG(\"built_year\") INTO v_avg_year FROM \"mill\" WHERE \"architect_id\" = p_architect_id;\n        v_action_code := COALESCE(v_total_length, 0)::INTEGER + COALESCE(v_avg_year, 0);\n    ELSIF p_architect_id > 20 AND p_architect_id < 50 THEN\n        DELETE FROM \"bridge\" WHERE \"architect_id\" = p_architect_id AND \"length_meters\" < 100;\n        DELETE FROM \"mill\" WHERE \"architect_id\" = p_architect_id AND \"built_year\" < 1900;\n        v_action_code := 1;\n    ELSE\n        UPDATE \"architect\" SET \"name\" = to_ascii(\"name\") WHERE \"id\"::INTEGER = p_architect_id;\n        v_action_code := 2;\n    END IF;\n    \n    RAISE NOTICE 'Processed architect % with code %', v_architect_name, v_action_code;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL process_architect_projects(1);",
      "CALL process_architect_projects(5);",
      "CALL process_architect_projects(15);",
      "CALL process_architect_projects(30);",
      "CALL process_architect_projects(60);"
    ],
    "summary": "Create a stored procedure named process_architect_projects that takes an architect ID as input. It retrieves the architect's name. Based on the ID value, it performs different actions: if the architect is not found, it inserts a default bridge; if ID < 10, it counts the architect's bridges and mills; if ID is between 10 and 20 inclusive, it calculates total bridge length and average mill built year; if ID is between 21 and 49, it deletes short bridges and old mills for that architect; otherwise, it updates the architect's name to its ASCII representation. Finally, it outputs a notice with the architect name and an action code.",
    "natural_language": "Hey, can you whip up a stored procedure called process_architect_projects that needs an architect's ID? First, grab the architect's name. Then, depending on the ID, do this stuff: if you can't find the architect at all, just plop in a default bridge. If the ID's less than 10, count up how many bridges and mills they've got. If the ID's from 10 to 20 (including those), figure out the total length of all their bridges and the average year their mills were built. If it's between 21 and 49, get rid of any short bridges and old mills belonging to that architect. For any other ID, just update the architect's name to its ASCII code version. At the end, shoot out a notice with the architect's name and a code saying what you did.",
    "id": 157
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `transform_architect_data` that accepts one input parameter, `p_nationality_filter`, which is of type `TEXT`. This procedure is designed to process and transform data related to architects and their associated structures (bridges and mills) based on various conditions.\n\nThe procedure begins by declaring several local variables: `v_architect_record` of type `RECORD` to hold individual architect data during iteration, `v_new_bridge_id` of type `INTEGER` to store the next available ID for new bridge records, `v_new_mill_id` of type `INTEGER` to store the next available ID for new mill records, `v_gender_counter` of type `INTEGER` initialized to `0` to count operations related to gender-based conditions, `v_nationality_counter` of type `INTEGER` initialized to `0` to count operations related to nationality-based conditions, and `v_total_counter` of type `INTEGER` initialized to `0` to count the total number of processed architect records.\n\nThe core logic of the procedure involves iterating through a result set obtained by selecting the `id`, `name`, `nationality`, and `gender` columns from the `architect` table. The selection is filtered by a `WHERE` clause where the `nationality` column matches a pattern formed by concatenating a wildcard character (`%`), the input parameter `p_nationality_filter`, and another wildcard character (`%`), effectively performing a case-insensitive substring search for the specified nationality filter.\n\nInside this loop, for each `v_architect_record` retrieved:\n1.  An `IF` condition checks if the `gender` column of the current `v_architect_record` is exactly equal to the string `'male'`.\n    *   If true, the procedure calculates `v_new_bridge_id` by querying the `bridge` table to find the maximum existing `id`, using `COALESCE` to default to `0` if no records exist, and then adding `1` to it.\n    *   It then inserts a new record into the `bridge` table with the calculated `v_new_bridge_id` for the `id` column, the `id` from `v_architect_record` cast to `INTEGER` for the `architect_id` column, the `name` from `v_architect_record` concatenated with `' Bridge'` for the `name` column, the literal string `'Transformed Location'` for the `location` column, the numeric value `75.0` for the `length_meters` column, and the numeric value `246.0` for the `length_feet` column.\n    *   Finally, `v_gender_counter` is incremented by `1`.\n2.  An `ELSIF` condition checks if the `gender` column of the current `v_architect_record` is exactly equal to the string `'female'`.\n    *   If true, the procedure calculates `v_new_mill_id` by querying the `mill` table to find the maximum existing `id`, using `COALESCE` to default to `0` if no records exist, and then adding `1` to it.\n    *   It then inserts a new record into the `mill` table with the calculated `v_new_mill_id` for the `id` column, the `id` from `v_architect_record` cast to `INTEGER` for the `architect_id` column, the literal string `'New Location'` for the `location` column, the `name` from `v_architect_record` concatenated with `' Mill'` for the `name` column, the literal string `'Transformed'` for the `type` column, the integer `1950` for the `built_year` column, and the literal string `'Generated by procedure'` for the `notes` column.\n    *   Finally, `v_gender_counter` is incremented by `1`.\n3.  Another `ELSIF` condition checks if the `nationality` column of the current `v_architect_record` matches the pattern `'%American%'`.\n    *   If true, the procedure deletes records from the `bridge` table where the `architect_id` column matches the `id` from `v_architect_record` (cast to `INTEGER`) AND the `length_feet` column is less than `300`.\n    *   Finally, `v_nationality_counter` is incremented by `1`.\n4.  A further `ELSIF` condition checks if the `nationality` column of the current `v_architect_record` matches the pattern `'%British%'`.\n    *   If true, the procedure updates records in the `mill` table by setting the `built_year` column to its current value plus `10`, specifically for records where the `architect_id` column matches the `id` from `v_architect_record` (cast to `INTEGER`).\n    *   Finally, `v_nationality_counter` is incremented by `1`.\n5.  An `ELSE` block is executed if none of the preceding `IF` or `ELSIF` conditions are met for the current `v_architect_record`.\n    *   In this block, the procedure inserts a new record into the `architect` table.\n    *   The `id` column for the new record is determined by querying the `architect` table for the maximum existing `id` (cast to `INTEGER`), using `COALESCE` to default to `0` if no records exist, adding `1`, and then casting the result back to `TEXT`.\n    *   The `name` column is set to the string `'Derived from '` concatenated with the `name` from `v_architect_record`.\n    *   The `nationality` column is set to the `nationality` from `v_architect_record`.\n    *   The `gender` column is set to the `gender` from `v_architect_record`.\n    *   Finally, `v_total_counter` is incremented by `1`.\n\nAfter the conditional block, but still within the loop, `v_total_counter` is unconditionally incremented by `1` for each architect record processed.\n\nAfter the loop completes, the procedure raises a `NOTICE` message using `RAISE NOTICE` to display the final counts of `v_gender_counter`, `v_nationality_counter`, and `v_total_counter` in the format 'Processed: gender=% nationality=% total=%'.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_architect_data(p_nationality_filter TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_architect_record RECORD;\n    v_new_bridge_id INTEGER;\n    v_new_mill_id INTEGER;\n    v_gender_counter INTEGER := 0;\n    v_nationality_counter INTEGER := 0;\n    v_total_counter INTEGER := 0;\nBEGIN\n    FOR v_architect_record IN \n        SELECT \"id\", \"name\", \"nationality\", \"gender\" \n        FROM \"architect\" \n        WHERE \"nationality\" LIKE '%' || p_nationality_filter || '%'\n    LOOP\n        IF v_architect_record.\"gender\" = 'male' THEN\n            v_new_bridge_id := (SELECT COALESCE(MAX(\"id\"), 0) + 1 FROM \"bridge\");\n            INSERT INTO \"bridge\" (\"id\", \"architect_id\", \"name\", \"location\", \"length_meters\", \"length_feet\")\n            VALUES (v_new_bridge_id, v_architect_record.\"id\"::INTEGER, \n                   v_architect_record.\"name\" || ' Bridge', \n                   'Transformed Location', 75.0, 246.0);\n            v_gender_counter := v_gender_counter + 1;\n        ELSIF v_architect_record.\"gender\" = 'female' THEN\n            v_new_mill_id := (SELECT COALESCE(MAX(\"id\"), 0) + 1 FROM \"mill\");\n            INSERT INTO \"mill\" (\"id\", \"architect_id\", \"location\", \"name\", \"type\", \"built_year\", \"notes\")\n            VALUES (v_new_mill_id, v_architect_record.\"id\"::INTEGER,\n                   'New Location', v_architect_record.\"name\" || ' Mill',\n                   'Transformed', 1950, 'Generated by procedure');\n            v_gender_counter := v_gender_counter + 1;\n        ELSIF v_architect_record.\"nationality\" LIKE '%American%' THEN\n            DELETE FROM \"bridge\" WHERE \"architect_id\" = v_architect_record.\"id\"::INTEGER AND \"length_feet\" < 300;\n            v_nationality_counter := v_nationality_counter + 1;\n        ELSIF v_architect_record.\"nationality\" LIKE '%British%' THEN\n            UPDATE \"mill\" SET \"built_year\" = \"built_year\" + 10 WHERE \"architect_id\" = v_architect_record.\"id\"::INTEGER;\n            v_nationality_counter := v_nationality_counter + 1;\n        ELSE\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES ((SELECT (COALESCE(MAX((\"id\")::INTEGER), 0) + 1)::TEXT FROM \"architect\"),\n                   'Derived from ' || v_architect_record.\"name\",\n                   v_architect_record.\"nationality\",\n                   v_architect_record.\"gender\");\n            v_total_counter := v_total_counter + 1;\n        END IF;\n        \n        v_total_counter := v_total_counter + 1;\n    END LOOP;\n    \n    RAISE NOTICE 'Processed: gender=% nationality=% total=%', v_gender_counter, v_nationality_counter, v_total_counter;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL transform_architect_data('American');",
      "CALL transform_architect_data('British');",
      "CALL transform_architect_data('Canadian');",
      "CALL transform_architect_data('Iraqi');",
      "CALL transform_architect_data('German');"
    ],
    "summary": "Create a stored procedure named transform_architect_data that takes a nationality filter text. It loops through architects whose nationality contains the filter. For each architect: if gender is 'male', insert a new bridge; if gender is 'female', insert a new mill; if nationality contains 'American', delete their short bridges; if nationality contains 'British', update their mills' built year by adding 10; otherwise, insert a new derived architect record. Count operations for gender, nationality, and total processed records. Output these counts in a final notice.",
    "natural_language": "Alright, so we need a stored procedure called transform_architect_data that takes in a bit of text to filter by nationality. Here's the deal: it's gonna go through all the architects whose nationality includes that filter text. For each architect it finds, here's what goes down: if the architect's gender is 'male', pop a new bridge into the database. If it's 'female', then add a new mill instead. Now, if their nationality's got 'American' in it, we gotta get rid of any short bridges they've got. If it's got 'British' in it, then we need to bump up the built year of their mills by 10. For any other nationality, just insert a brand new derived architect record. Oh, and we gotta keep a running tallyâ€”count up how many we did for each gender, how many for each nationality action, and the total number of architects we messed with. At the very end, spit out all those counts in a final notice.",
    "id": 158
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `migrate_architect_legacy` that accepts two text parameters: `p_source_gender` and `p_target_gender`. This procedure is designed to migrate records from the \"architect\" table based on their gender, creating new architect records with a modified gender and potentially updating or deleting related records in the \"bridge\" and \"mill\" tables.\n\nThe procedure begins by declaring several local variables:\n- `v_cursor`: A cursor that will iterate over records from the \"architect\" table. This cursor is defined to select the \"id\", \"name\", \"nationality\", and \"gender\" columns from the \"architect\" table for all rows where the \"gender\" column matches the `p_source_gender` input parameter.\n- `v_record`: A `RECORD` type variable to hold the data fetched from `v_cursor` during each iteration.\n- `v_new_id`: A `TEXT` type variable to store the newly generated \"id\" for architect records.\n- `v_migration_count`: An `INTEGER` type variable initialized to `0`, used to count the total number of architect records processed and migrated.\n- `v_bridge_moved`: An `INTEGER` type variable initialized to `0`, used to count the number of \"bridge\" records that were associated with architects whose \"nationality\" contained '%American%'.\n- `v_mill_moved`: An `INTEGER` type variable initialized to `0`, used to count the number of \"mill\" records that were associated with architects whose \"nationality\" contained '%British%'.\n- `v_condition_check`: An `INTEGER` type variable initialized to `0`, used to track which conditional branch was executed for the last processed architect record.\n- `v_temp_count`: An `INTEGER` type variable used as a temporary storage for counts during conditional processing.\n\nThe procedure then opens the `v_cursor`.\n\nIt enters a `LOOP` that continues until no more rows are found by the cursor. Inside the loop:\n1. It fetches the next row from `v_cursor` into `v_record`.\n2. If no more rows are found (`NOT FOUND`), the loop exits.\n3. A new \"id\" for the architect record is generated and assigned to `v_new_id`. This new \"id\" is calculated by finding the maximum \"id\" (cast to `INTEGER`) in the \"architect\" table, adding `1` to it, and then casting the result back to `TEXT`. If no \"id\" exists, `0` is used as the starting point.\n\nNext, a series of conditional checks are performed on the `v_record`'s attributes:\n\n- **Condition 1: `v_record.\"nationality\" LIKE '%American%'`**\n    - If the \"nationality\" of the current architect record contains the substring 'American', a new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"` concatenated with ' (Migrated)'.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - The procedure then counts the number of records in the \"bridge\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) and stores this count in `v_temp_count`.\n    - `v_bridge_moved` is incremented by `v_temp_count`.\n    - `v_condition_check` is set to `1`.\n\n- **Condition 2: `v_record.\"nationality\" LIKE '%British%'` (executed if Condition 1 is false)**\n    - If the \"nationality\" of the current architect record contains the substring 'British', a new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"` concatenated with ' [Relocated]'.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - The procedure then counts the number of records in the \"mill\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) and stores this count in `v_temp_count`.\n    - `v_mill_moved` is incremented by `v_temp_count`.\n    - `v_condition_check` is set to `2`.\n\n- **Condition 3: `v_record.\"name\" LIKE '%Frank%'` (executed if Conditions 1 and 2 are false)**\n    - If the \"name\" of the current architect record contains the substring 'Frank', the \"architect_id\" in the \"bridge\" table is updated to `v_new_id` (cast to `INTEGER`) for all records where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`).\n    - Similarly, the \"architect_id\" in the \"mill\" table is updated to `v_new_id` (cast to `INTEGER`) for all records where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`).\n    - A new record is then inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"`.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `3`.\n\n- **Condition 4: `LENGTH(v_record.\"name\") > 15` (executed if Conditions 1, 2, and 3 are false)**\n    - If the length of the \"name\" of the current architect record is greater than `15`, all records in the \"bridge\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) are deleted.\n    - All records in the \"mill\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) are also deleted.\n    - A new record is then inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is a substring of the original `v_record.\"name\"`, taking the first `15` characters.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `4`.\n\n- **Else (executed if none of the above conditions are met)**\n    - A new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"`.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `5`.\n\nAfter the conditional block, regardless of which condition was met, the original architect record from which `v_record` was derived is deleted from the \"architect\" table where its \"id\" matches `v_record.\"id\"`.\n`v_migration_count` is incremented by `1`.\n\nAfter the loop finishes, the `v_cursor` is closed.\n\nFinally, a notice message is raised, indicating the completion of the migration. This message includes the total number of architects migrated (`v_migration_count`), the number of bridge records moved (`v_bridge_moved`), the number of mill records moved (`v_mill_moved`), and the `v_condition_check` value from the last processed record.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_architect_legacy(p_source_gender TEXT, p_target_gender TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cursor CURSOR FOR \n        SELECT \"id\", \"name\", \"nationality\", \"gender\"\n        FROM \"architect\"\n        WHERE \"gender\" = p_source_gender;\n    v_record RECORD;\n    v_new_id TEXT;\n    v_migration_count INTEGER := 0;\n    v_bridge_moved INTEGER := 0;\n    v_mill_moved INTEGER := 0;\n    v_condition_check INTEGER := 0;\n    v_temp_count INTEGER;\nBEGIN\n    OPEN v_cursor;\n    \n    LOOP\n        FETCH v_cursor INTO v_record;\n        EXIT WHEN NOT FOUND;\n        \n        v_new_id := (SELECT COALESCE(MAX(\"id\"::INTEGER), 0) + 1 FROM \"architect\")::TEXT;\n        \n        IF v_record.\"nationality\" LIKE '%American%' THEN\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\" || ' (Migrated)', v_record.\"nationality\", p_target_gender);\n            \n            SELECT COUNT(*) INTO v_temp_count FROM \"bridge\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            v_bridge_moved := v_bridge_moved + v_temp_count;\n            \n            v_condition_check := 1;\n        ELSIF v_record.\"nationality\" LIKE '%British%' THEN\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\" || ' [Relocated]', v_record.\"nationality\", p_target_gender);\n            \n            SELECT COUNT(*) INTO v_temp_count FROM \"mill\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            v_mill_moved := v_mill_moved + v_temp_count;\n            \n            v_condition_check := 2;\n        ELSIF v_record.\"name\" LIKE '%Frank%' THEN\n            UPDATE \"bridge\" SET \"architect_id\" = v_new_id::INTEGER WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            UPDATE \"mill\" SET \"architect_id\" = v_new_id::INTEGER WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            \n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\", v_record.\"nationality\", p_target_gender);\n            \n            v_condition_check := 3;\n        ELSIF LENGTH(v_record.\"name\") > 15 THEN\n            DELETE FROM \"bridge\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            DELETE FROM \"mill\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            \n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, SUBSTRING(v_record.\"name\", 1, 15), v_record.\"nationality\", p_target_gender);\n            \n            v_condition_check := 4;\n        ELSE\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\", v_record.\"nationality\", p_target_gender);\n            \n            v_condition_check := 5;\n        END IF;\n        \n        DELETE FROM \"architect\" WHERE \"id\" = v_record.\"id\";\n        v_migration_count := v_migration_count + 1;\n    END LOOP;\n    \n    CLOSE v_cursor;\n    \n    RAISE NOTICE 'Migration complete: % architects, % bridges, % mills, condition %', \n                 v_migration_count, v_bridge_moved, v_mill_moved, v_condition_check;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL migrate_architect_legacy('male', 'non-binary');",
      "CALL migrate_architect_legacy('female', 'non-binary');",
      "CALL migrate_architect_legacy('male', 'female');",
      "CALL migrate_architect_legacy('female', 'male');",
      "CALL migrate_architect_legacy('non-binary', 'male');"
    ],
    "summary": "Create a stored procedure named migrate_architect_legacy that migrates architects from a source gender to a target gender. It loops through source architects. For each, it generates a new ID. Based on the architect's attributes: if nationality contains 'American', insert a migrated architect and count their bridges; if nationality contains 'British', insert a relocated architect and count their mills; if name contains 'Frank', update bridge and mill records to the new ID and insert the architect; if name length > 15, delete their bridges and mills and insert an architect with a truncated name; otherwise, just insert the architect. Delete the original architect record. Finally, output counts of migrated architects, moved bridges, moved mills, and the last condition code.",
    "natural_language": "Create a comprehensive stored procedure, meticulously named migrate_architect_legacy, which orchestrates the detailed migration of architects from a specified source gender to a designated target gender. The procedure thoughtfully iterates through each architect record from the source. For every individual architect, it first carefully generates a brand new, unique identifier. Subsequently, based on a thorough examination of the architect's specific attributes, it executes distinct logic: if the architect's nationality descriptively includes the term 'American', it inserts a migrated architect record and then diligently counts all associated bridges; if the nationality richly contains the word 'British', it inserts a relocated architect and meticulously tallies their related mills; if the architect's name prominently features 'Frank', it updates all existing bridge and mill records to reflect the new identifier and then inserts the architect; if the length of the name is determined to be impressively greater than fifteen characters, it permanently deletes all their bridges and mills and inserts an architect record with a neatly truncated name; otherwise, it simply inserts the architect. Following these conditional operations, it conscientiously deletes the original architect record. Finally, the procedure elegantly outputs the cumulative counts of migrated architects, moved bridges, moved mills, and the very last condition code that was processed.",
    "id": 159
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named redistribute_championship_data that takes no parameters and begins by declaring seven local variables: sum_championships of type REAL to hold the total number of championships, count_institutions of type INTEGER to hold the count of distinct institutions, oldest_year and newest_year of type REAL to hold the minimum and maximum founding years, high_capacity_count and low_capacity_count of type INTEGER to hold counts based on a capacity threshold, and public_institutions of type INTEGER to hold the count of public-affiliated institutions. The procedure first populates these variables by executing a series of SELECT queries: it sums the \"Number_of_Championships\" column from the \"Championship\" table, counts distinct \"Institution_ID\" values from the \"institution\" table, finds the minimum and maximum values of the \"Founded\" column from the \"institution\" table, counts rows in the \"institution\" table where the \"Capacity\" column is greater than 15000.0 and where it is less than or equal to 15000.0 respectively, and counts rows where the \"Affiliation\" column equals the string 'Public'. The core logic is a nested conditional structure that first checks if the sum_championships variable is greater than 5.0. If true, it then checks if count_institutions is greater than 8. If this second condition is true, it compares high_capacity_count to low_capacity_count; if high_capacity_count is greater, it executes a DELETE operation on the \"Championship\" table targeting rows where the \"Institution_ID\" matches any \"Institution_ID\" from the \"institution\" table where \"Capacity\" is less than or equal to 5000.0 and the \"Province\" column equals 'AB'; otherwise, it executes a similar DELETE but for institutions in province 'BC'. If the count_institutions condition was false (i.e., 8 or fewer), it checks if oldest_year is less than 1920.0. If true, it performs an INSERT into the \"Championship\" table for columns \"Institution_ID\", \"Nickname\", \"Joined\", and \"Number_of_Championships\", selecting values from the \"institution\" table where \"Founded\" equals the oldest_year variable: the \"Institution_ID\" is taken directly, the \"Nickname\" is set to the result of applying the UPPER function to the output of the TRIM function on the \"Name\" column, the \"Joined\" column is set to the newest_year variable, and \"Number_of_Championships\" is set to 4.0, with an ON CONFLICT clause on the \"Institution_ID\" column that updates the conflicting row's \"Nickname\", \"Joined\", and \"Number_of_Championships\" columns with the EXCLUDED values. If the oldest_year condition was false, it performs a different INSERT, selecting from \"institution\" where \"Founded\" equals newest_year: here, \"Nickname\" is set to the character length of the \"Team\" column cast to text, \"Joined\" is set to \"Founded\" plus 80.0, and \"Number_of_Championships\" is set to 2.0, with the same ON CONFLICT update behavior. If the initial check on sum_championships was false (i.e., 5.0 or less), the procedure enters an alternative branch, again checking if count_institutions is greater than 8. If true, it then checks if high_capacity_count is greater than low_capacity_count. If this is true, it executes an INSERT into \"Championship\" selecting from the \"institution\" table where \"Capacity\" is greater than 20000.0, grouping the results by \"Institution_ID\", \"City\", and \"Founded\": the \"Nickname\" is set to the TRIM of the \"City\" column, \"Joined\" is set to \"Founded\" plus 90.0, and \"Number_of_Championships\" is set to the maximum \"Capacity\" for the group divided by 10000.0, again with an ON CONFLICT update. If the high_capacity_count comparison is false, it executes another INSERT selecting from \"institution\" where \"Enrollment\" is greater than 30000.0, grouping by \"Institution_ID\" and \"Province\": here, \"Nickname\" is set to the UPPER case of the \"Province\" column, \"Joined\" is set to 1985.0, and \"Number_of_Championships\" is set to the count of rows in the group cast to REAL, with the same conflict resolution. Finally, if in this main branch the count_institutions condition was false (8 or fewer), it checks if oldest_year is less than 1920.0. If true, it deletes from \"Championship\" where the \"Institution_ID\" matches any from \"institution\" where \"Founded\" is greater than 1980.0 and \"Affiliation\" equals 'Public'; if false, it deletes where the \"Institution_ID\" matches any from \"institution\" where \"Enrollment\" is less than 25000.0 and \"Province\" equals 'AB'.",
    "plsql": "CREATE OR REPLACE PROCEDURE redistribute_championship_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    sum_championships REAL;\n    count_institutions INTEGER;\n    oldest_year REAL;\n    newest_year REAL;\n    high_capacity_count INTEGER;\n    low_capacity_count INTEGER;\n    public_institutions INTEGER;\nBEGIN\n    SELECT SUM(\"Number_of_Championships\") INTO sum_championships FROM \"Championship\";\n    SELECT COUNT(DISTINCT \"Institution_ID\") INTO count_institutions FROM \"institution\";\n    SELECT MIN(\"Founded\") INTO oldest_year FROM \"institution\";\n    SELECT MAX(\"Founded\") INTO newest_year FROM \"institution\";\n    SELECT COUNT(*) INTO high_capacity_count FROM \"institution\" WHERE \"Capacity\" > 15000.0;\n    SELECT COUNT(*) INTO low_capacity_count FROM \"institution\" WHERE \"Capacity\" <= 15000.0;\n    SELECT COUNT(*) INTO public_institutions FROM \"institution\" WHERE \"Affiliation\" = 'Public';\n    \n    IF sum_championships > 5.0 THEN\n        IF count_institutions > 8 THEN\n            IF high_capacity_count > low_capacity_count THEN\n                DELETE FROM \"Championship\" WHERE \"Institution_ID\" IN (SELECT \"Institution_ID\" FROM \"institution\" WHERE \"Capacity\" <= 5000.0 AND \"Province\" = 'AB');\n            ELSE\n                DELETE FROM \"Championship\" WHERE \"Institution_ID\" IN (SELECT \"Institution_ID\" FROM \"institution\" WHERE \"Capacity\" <= 5000.0 AND \"Province\" = 'BC');\n            END IF;\n        ELSE\n            IF oldest_year < 1920.0 THEN\n                INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") \n                SELECT \"Institution_ID\", UPPER(TRIM(\"Name\")), newest_year, 4.0 FROM \"institution\" WHERE \"Founded\" = oldest_year\n                ON CONFLICT (\"Institution_ID\") DO UPDATE SET\n                    \"Nickname\" = EXCLUDED.\"Nickname\",\n                    \"Joined\" = EXCLUDED.\"Joined\",\n                    \"Number_of_Championships\" = EXCLUDED.\"Number_of_Championships\";\n            ELSE\n                INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") \n                SELECT \"Institution_ID\", LENGTH(\"Team\")::text, \"Founded\" + 80.0, 2.0 FROM \"institution\" WHERE \"Founded\" = newest_year\n                ON CONFLICT (\"Institution_ID\") DO UPDATE SET\n                    \"Nickname\" = EXCLUDED.\"Nickname\",\n                    \"Joined\" = EXCLUDED.\"Joined\",\n                    \"Number_of_Championships\" = EXCLUDED.\"Number_of_Championships\";\n            END IF;\n        END IF;\n    ELSE\n        IF count_institutions > 8 THEN\n            IF high_capacity_count > low_capacity_count THEN\n                INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") \n                SELECT \"Institution_ID\", TRIM(\"City\"), \"Founded\" + 90.0, MAX(\"Capacity\")/10000.0 \n                FROM \"institution\" \n                WHERE \"Capacity\" > 20000.0 \n                GROUP BY \"Institution_ID\", \"City\", \"Founded\"\n                ON CONFLICT (\"Institution_ID\") DO UPDATE SET\n                    \"Nickname\" = EXCLUDED.\"Nickname\",\n                    \"Joined\" = EXCLUDED.\"Joined\",\n                    \"Number_of_Championships\" = EXCLUDED.\"Number_of_Championships\";\n            ELSE\n                INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") \n                SELECT \"Institution_ID\", UPPER(\"Province\"), 1985.0, COUNT(*)::real \n                FROM \"institution\" \n                WHERE \"Enrollment\" > 30000.0 \n                GROUP BY \"Institution_ID\", \"Province\"\n                ON CONFLICT (\"Institution_ID\") DO UPDATE SET\n                    \"Nickname\" = EXCLUDED.\"Nickname\",\n                    \"Joined\" = EXCLUDED.\"Joined\",\n                    \"Number_of_Championships\" = EXCLUDED.\"Number_of_Championships\";\n            END IF;\n        ELSE\n            IF oldest_year < 1920.0 THEN\n                DELETE FROM \"Championship\" WHERE \"Institution_ID\" IN (SELECT \"Institution_ID\" FROM \"institution\" WHERE \"Founded\" > 1980.0 AND \"Affiliation\" = 'Public');\n            ELSE\n                DELETE FROM \"Championship\" WHERE \"Institution_ID\" IN (SELECT \"Institution_ID\" FROM \"institution\" WHERE \"Enrollment\" < 25000.0 AND \"Province\" = 'AB');\n            END IF;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL redistribute_championship_data();"
    ],
    "summary": "Create a stored procedure named redistribute_championship_data with no parameters. First, calculate aggregate values: total championships, institution count, oldest and newest founding years, counts of high/low capacity institutions, and count of public institutions. If total championships > 5: if institution count > 8, delete championships for low-capacity institutions in province 'AB' or 'BC' based on a capacity comparison; otherwise, if oldest year < 1920, insert/update a championship record for the oldest institutions, else insert/update for the newest institutions. If total championships <= 5: if institution count > 8, insert/update championship records for high-capacity or high-enrollment institutions based on a capacity comparison; otherwise, if oldest year < 1920, delete championships for public institutions founded after 1980, else delete championships for low-enrollment institutions in province 'AB'.",
    "natural_language": "What steps should be taken to create a stored procedure named 'redistribute_championship_data' with no parameters? The procedure should first calculate the following aggregate values: total championships, institution count, oldest and newest founding years, counts of high and low capacity institutions, and the count of public institutions. Then, based on these aggregates, what conditional logic should be executed? Specifically, if the total championships are greater than 5, what actions should be taken depending on whether the institution count is greater than 8 or if the oldest founding year is before 1920? Conversely, if the total championships are 5 or fewer, what different actions should be performed based on the same conditions regarding institution count and the oldest founding year?",
    "id": 160
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_photo_color_distribution that accepts four parameters: p_target_color of type text, p_min_focal of type real, p_brand_filter of type text, and p_mountain_range of type integer. The procedure begins by declaring five local variables: v_color_count and v_other_count of type integer, v_ratio and v_mountain_mod of type real, and v_mountain_mod of type integer. It initializes v_mountain_mod to either the value of p_mountain_range or 1, depending on whether p_mountain_range is greater than zero, to prevent division by zero errors in subsequent operations. The procedure then performs a SELECT COUNT operation to determine the number of rows in the photos table where the color column matches p_target_color, the associated camera lens's focal_length_mm is greater than or equal to p_min_focal, and the brand matches p_brand_filter, storing the result in v_color_count. A similar SELECT COUNT operation is executed to count rows where the color does not match p_target_color but meets the same focal length and brand criteria, storing the result in v_other_count. The procedure calculates the ratio of v_color_count to v_other_count, assigning zero to v_ratio if v_other_count is zero to avoid division by zero. Based on the value of v_ratio, the procedure executes different operations: if v_ratio is less than 0.5, it inserts new rows into the photos table, generating random ids and mountain_id values, setting the color to p_target_color, and naming the photos with a prefix 'Balanced' followed by the camera lens name, for camera lenses matching the brand and focal length criteria, limiting the number of inserts to the ceiling of 10 times the difference between 0.5 and v_ratio; if v_ratio exceeds 2.0, it deletes rows from the photos table where the color matches p_target_color, the camera lens brand and focal length meet the criteria, and the mountain_id is greater than p_mountain_range, limiting deletions to the floor of 5 times the difference between v_ratio and 2.0; otherwise, it deletes up to three rows from the photos table where the color matches p_target_color, the camera lens brand matches p_brand_filter, and the focal length is less than p_min_focal, ordering deletions by descending mountain_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_photo_color_distribution(p_target_color text, p_min_focal real, p_brand_filter text, p_mountain_range integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_color_count integer;\n    v_other_count integer;\n    v_ratio real;\n    v_mountain_mod integer;\nBEGIN\n    -- Handle potential division by zero in MOD\n    v_mountain_mod := CASE WHEN p_mountain_range > 0 THEN p_mountain_range ELSE 1 END;\n    \n    SELECT COUNT(*) INTO v_color_count\n    FROM \"photos\" p\n    INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n    WHERE p.\"color\" = p_target_color\n    AND cl.\"focal_length_mm\" >= p_min_focal\n    AND cl.\"brand\" = p_brand_filter;\n    \n    SELECT COUNT(*) INTO v_other_count\n    FROM \"photos\" p\n    INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n    WHERE p.\"color\" != p_target_color\n    AND cl.\"focal_length_mm\" >= p_min_focal\n    AND cl.\"brand\" = p_brand_filter;\n    \n    IF v_other_count > 0 THEN\n        v_ratio := v_color_count::real / v_other_count::real;\n    ELSE\n        v_ratio := 0;\n    END IF;\n    \n    IF v_ratio < 0.5 THEN\n        INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n        SELECT \n            FLOOR(RANDOM() * 1000000) + ROW_NUMBER() OVER (ORDER BY cl.\"id\"),\n            cl.\"id\",\n            MOD(CAST(ABS(FLOOR(RANDOM() * 100)) AS integer), v_mountain_mod),\n            p_target_color,\n            'Balanced ' || cl.\"name\"\n        FROM \"camera_lens\" cl\n        WHERE cl.\"brand\" = p_brand_filter\n        AND cl.\"focal_length_mm\" >= p_min_focal\n        LIMIT CEIL(10 * (0.5 - v_ratio));\n    ELSIF v_ratio > 2.0 THEN\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p.\"id\"\n            FROM \"photos\" p\n            INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n            WHERE p.\"color\" = p_target_color\n            AND cl.\"brand\" = p_brand_filter\n            AND cl.\"focal_length_mm\" >= p_min_focal\n            AND p.\"mountain_id\" > p_mountain_range\n            ORDER BY p.\"id\"\n            LIMIT FLOOR((v_ratio - 2.0) * 5)\n        );\n    ELSE\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p.\"id\"\n            FROM \"photos\" p\n            INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n            WHERE cl.\"brand\" = p_brand_filter\n            AND cl.\"focal_length_mm\" < p_min_focal\n            AND p.\"color\" = p_target_color\n            ORDER BY p.\"mountain_id\" DESC\n            LIMIT 3\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL manage_photo_color_distribution('RBG', 15.0, 'Olympus', 20);",
      "CALL manage_photo_color_distribution('Black/White', 45.0, 'Olympus', 2);",
      "CALL manage_photo_color_distribution('RBG', 75.0, 'Olympus', 1);",
      "CALL manage_photo_color_distribution('Black/White', 15.0, 'Olympus', 10);",
      "CALL manage_photo_color_distribution('RBG', 45.0, 'Olympus', 5);"
    ],
    "summary": "Create a stored procedure named manage_photo_color_distribution that accepts a target color, minimum focal length, brand filter, and mountain range. It counts photos matching and not matching the target color under the given criteria, calculates their ratio, and then conditionally inserts, deletes, or removes photos based on that ratio to balance the color distribution.",
    "natural_language": "How can I create a stored procedure called manage_photo_color_distribution that takes a target color, a minimum focal length, a brand filter, and a mountain range as inputs, counts the photos that match and do not match the target color under those criteria, calculates the ratio between them, and then conditionally inserts, deletes, or removes photos based on that ratio to balance the color distribution?",
    "id": 161
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `analyze_shop_inventory` that accepts two input parameters: `p_shop_id` of type `integer`, representing the unique identifier for a specific shop, and `p_threshold` of type `integer`, representing a minimum quantity threshold. The procedure first declares two local integer variables: `total_stock` to store the sum of quantities and `device_count` to store the count of distinct devices. It then executes a `SELECT` statement to retrieve data from the `stock` table. This `SELECT` statement calculates the sum of the `Quantity` column and the count of distinct values in the `Device_ID` column. These calculations are performed only for rows where the `Shop_ID` column matches the value provided in the `p_shop_id` parameter and the `Quantity` column's value is greater than the value provided in the `p_threshold` parameter. The calculated sum of `Quantity` is stored into the `total_stock` variable, and the calculated count of distinct `Device_ID` values is stored into the `device_count` variable. Following this, the procedure performs an `INSERT` operation into the `stock` table, populating the `Shop_ID`, `Device_ID`, and `Quantity` columns. The `Shop_ID` column is set to the value of the `p_shop_id` parameter. The `Device_ID` column is populated by selecting `Device_ID` values from the `device` table. The `Quantity` column is set to a literal value of `0`. This `INSERT` operation is conditional: it only inserts rows for `Device_ID` values from the `device` table where there is no existing record in the `stock` table that matches both the `p_shop_id` parameter and the `Device_ID` from the `device` table. This check is performed using a `WHERE NOT EXISTS` subquery, which selects `1` from the `stock` table (`s`) where `s.\"Shop_ID\"` equals `p_shop_id` and `s.\"Device_ID\"` equals `d.\"Device_ID\"`.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_shop_inventory(p_shop_id integer, p_threshold integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_stock integer;\n    device_count integer;\nBEGIN\n    SELECT SUM(\"Quantity\"), COUNT(DISTINCT \"Device_ID\")\n    INTO total_stock, device_count\n    FROM stock\n    WHERE \"Shop_ID\" = p_shop_id AND \"Quantity\" > p_threshold;\n    \n    INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n    SELECT p_shop_id, d.\"Device_ID\", 0\n    FROM device d\n    WHERE NOT EXISTS (\n        SELECT 1 FROM stock s \n        WHERE s.\"Shop_ID\" = p_shop_id AND s.\"Device_ID\" = d.\"Device_ID\"\n    );\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL analyze_shop_inventory(1, 50);",
      "CALL analyze_shop_inventory(2, 100);",
      "CALL analyze_shop_inventory(3, 75);",
      "CALL analyze_shop_inventory(1, 25);",
      "CALL analyze_shop_inventory(2, 60);"
    ],
    "summary": "Create a stored procedure named analyze_shop_inventory that accepts a shop ID and a quantity threshold. It calculates the total stock and distinct device count for that shop where quantity exceeds the threshold. Then, it inserts new stock entries with a quantity of zero for any devices from the device table that are not already present in the shop's stock.",
    "natural_language": "List the total stock and distinct device count for a specified shop where quantity exceeds a given threshold, then insert zero-quantity stock entries for any devices from the device table missing from that shop's stock. Name this stored procedure analyze_shop_inventory.",
    "id": 162
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named consolidate_device_stock that accepts two integer input parameters, p_source_shop and p_target_shop, and performs a consolidation of stock records from a source shop to a target shop by first reading all stock entries from the source shop, then attempting to insert those entries into the target shop, and finally deleting the original source shop entries. The procedure begins by declaring a variable named rec of type RECORD to hold rows from a query. It then executes a FOR loop that iterates over each row returned by a SELECT query on the stock table; this query selects the Device_ID column and the Quantity column for every row where the Shop_ID column equals the provided p_source_shop parameter. For each record fetched in the loop, the procedure executes an INSERT statement on the stock table, specifying values for the Shop_ID column (using the p_target_shop parameter), the Device_ID column (using the rec.Device_ID value from the current loop record), and the Quantity column (using the rec.Quantity value from the current loop record). This INSERT statement includes an ON CONFLICT clause that targets the unique constraint or index on the combination of the Shop_ID and Device_ID columns; if a row with the same target shop and device ID already exists, the DO NOTHING action is taken, meaning the insert is silently skipped without error and no update occurs. After the loop completes all iterations, the procedure executes a DELETE statement on the stock table that removes every row where the Shop_ID column equals the p_source_shop parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_device_stock(p_source_shop integer, p_target_shop integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    rec RECORD;\nBEGIN\n    FOR rec IN \n        SELECT \"Device_ID\", \"Quantity\" \n        FROM stock \n        WHERE \"Shop_ID\" = p_source_shop\n    LOOP\n        INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n        VALUES (p_target_shop, rec.\"Device_ID\", rec.\"Quantity\")\n        ON CONFLICT (\"Shop_ID\", \"Device_ID\") \n        DO NOTHING;\n    END LOOP;\n    \n    DELETE FROM stock WHERE \"Shop_ID\" = p_source_shop;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL consolidate_device_stock(1, 2);",
      "CALL consolidate_device_stock(3, 1);",
      "CALL consolidate_device_stock(2, 3);",
      "CALL consolidate_device_stock(5, 10);",
      "CALL consolidate_device_stock(8, 4);"
    ],
    "summary": "Create a stored procedure named consolidate_device_stock that accepts source and target shop IDs. It reads all stock entries from the source shop and inserts them into the target shop. If a device already exists at the target shop, the insert is skipped. Finally, it deletes all stock entries from the source shop.",
    "natural_language": "How can I create a stored procedure named consolidate_device_stock that takes source and target shop IDs, reads all stock entries from the source shop to insert them into the target shop while skipping inserts for devices that already exist there, and then deletes all stock entries from the source shop?",
    "id": 163
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named archive_old_inventory that accepts two integer input parameters: p_cutoff_year, which defines a year threshold for identifying old shops, and p_min_stock, which defines a minimum quantity threshold for stock deletion. The procedure begins by declaring a local integer array variable named archive_shops and a record variable named device_rec. It first populates the archive_shops array by selecting all Shop_ID values from the shop table where the Open_Year column is less than the provided p_cutoff_year parameter. Next, it enters a loop that iterates over each row returned by a query selecting Device_ID and a substring of the first 10 characters from the Device column aliased as short_name from the device table where the Software_Platform column value is either 'Android' or 'iOS'. For each iteration, assigning the row to device_rec, it performs a delete operation on the stock table where the Shop_ID matches any value in the archive_shops array, the Device_ID equals the current device_rec.Device_ID, and the Quantity is greater than or equal to the p_min_stock parameter. After the loop completes, the procedure performs an insert operation into the stock table, specifically into the Shop_ID, Device_ID, and Quantity columns. The data to insert is selected from a Cartesian product (CROSS JOIN) of the shop table (aliased as s) and the device table (aliased as d). The select statement calculates the Quantity for each row as the absolute value of the difference between the current year (extracted from CURRENT_DATE) and the shop's Open_Year, multiplied by 10. Rows are only selected for insertion where the shop's Shop_ID is in the archive_shops array, the device's Software_Platform is exactly 'iOS', and a correlated subquery using NOT EXISTS ensures no corresponding row already exists in the stock table (aliased as st) for the same Shop_ID and Device_ID combination.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_inventory(p_cutoff_year integer, p_min_stock integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    archive_shops integer[];\n    device_rec RECORD;\nBEGIN\n    SELECT ARRAY_AGG(\"Shop_ID\")\n    INTO archive_shops\n    FROM shop\n    WHERE \"Open_Year\" < p_cutoff_year;\n    \n    FOR device_rec IN\n        SELECT \"Device_ID\", SUBSTR(\"Device\", 1, 10) as short_name\n        FROM device\n        WHERE \"Software_Platform\" IN ('Android', 'iOS')\n    LOOP\n        DELETE FROM stock\n        WHERE \"Shop_ID\" = ANY(archive_shops)\n        AND \"Device_ID\" = device_rec.\"Device_ID\"\n        AND \"Quantity\" >= p_min_stock;\n    END LOOP;\n    \n    INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n    SELECT s.\"Shop_ID\", d.\"Device_ID\", ABS(EXTRACT(YEAR FROM CURRENT_DATE) - s.\"Open_Year\") * 10\n    FROM shop s\n    CROSS JOIN device d\n    WHERE s.\"Shop_ID\" = ANY(archive_shops)\n    AND d.\"Software_Platform\" = 'iOS'\n    AND NOT EXISTS (\n        SELECT 1 FROM stock st \n        WHERE st.\"Shop_ID\" = s.\"Shop_ID\" AND st.\"Device_ID\" = d.\"Device_ID\"\n    );\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL archive_old_inventory(2010, 100);",
      "CALL archive_old_inventory(2008, 110);",
      "CALL archive_old_inventory(2006, 120);",
      "CALL archive_old_inventory(2009, 90);",
      "CALL archive_old_inventory(2007, 130);"
    ],
    "summary": "Create a stored procedure named archive_old_inventory that accepts a cutoff year and a minimum stock quantity. It identifies shops opened before the cutoff year, then deletes their stock for Android/iOS devices where quantity meets the minimum. Finally, it inserts new stock entries for those shops and iOS devices, with a calculated quantity, only where no existing entry exists.",
    "natural_language": "Write a stored procedure called archive_old_inventory that takes a cutoff year and a minimum stock quantity. First, find shops opened before the given cutoff year. Then, remove their stock records for Android or iOS devices where the quantity is at least the specified minimum. Finally, for those shops and for iOS devices only, add new stock entries with a calculated quantity, but only if an entry does not already exist.",
    "id": 164
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `add_new_stock_entry` that accepts three input parameters: `new_shop_id` of type `INTEGER`, representing the unique identifier for a shop; `new_device_id` of type `INTEGER`, representing the unique identifier for a device; and `initial_quantity` of type `INTEGER`, representing the quantity of the device to be added or updated in stock. The procedure performs an `INSERT` operation into the `stock` table. Specifically, it attempts to insert a new row with the value of `new_shop_id` into the `\"Shop_ID\"` column, the value of `new_device_id` into the `\"Device_ID\"` column, and the value of `initial_quantity` into the `\"Quantity\"` column. This `INSERT` operation includes an `ON CONFLICT` clause that specifies a conflict target on the combination of the `\"Shop_ID\"` and `\"Device_ID\"` columns. If a conflict occurs (i.e., a row with the same `\"Shop_ID\"` and `\"Device_ID\"` already exists in the `stock` table), the procedure executes an `UPDATE` operation instead of inserting a new row. During this `UPDATE`, the `\"Quantity\"` column of the existing row in the `stock` table is incremented by the value of `EXCLUDED.\"Quantity\"`, which refers to the `initial_quantity` value that was attempted to be inserted. After the `INSERT` or `UPDATE` operation is completed, the procedure issues a `RAISE NOTICE` statement. This notice message, formatted as 'Added/updated stock entry for shop % and device % with quantity %', displays the values of `new_shop_id`, `new_device_id`, and `initial_quantity` to the client, indicating that a stock entry has been successfully added or updated for the specified shop and device with the given quantity.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_stock_entry(IN new_shop_id INTEGER, IN new_device_id INTEGER, IN initial_quantity INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n    VALUES (new_shop_id, new_device_id, initial_quantity)\n    ON CONFLICT (\"Shop_ID\", \"Device_ID\") \n    DO UPDATE SET \"Quantity\" = stock.\"Quantity\" + EXCLUDED.\"Quantity\";\n    \n    RAISE NOTICE 'Added/updated stock entry for shop % and device % with quantity %', new_shop_id, new_device_id, initial_quantity;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL add_new_stock_entry(1, 1, 50);",
      "CALL add_new_stock_entry(2, 2, 75);",
      "CALL add_new_stock_entry(3, 3, 100);",
      "CALL add_new_stock_entry(1, 2, 60);",
      "CALL add_new_stock_entry(2, 3, 80);"
    ],
    "summary": "Create a stored procedure named add_new_stock_entry that accepts a shop ID, device ID, and initial quantity. It inserts a new stock entry. If an entry for that shop and device already exists, it updates the quantity by adding the new value. Upon completion, it outputs a notice confirming the addition or update.",
    "natural_language": "Develop a stored procedure, which should be named 'add_new_stock_entry', that is designed to accept three distinct input parameters: a specific shop identifier, a corresponding device identifier, and an initial quantity value for stock. This procedure will meticulously insert a brand new entry into the stock records. However, if a pre-existing stock entry for that precise combination of shop and device is already found within the database, the procedure will instead intelligently update the current quantity by carefully adding the newly provided value to the existing amount. Upon its successful completion, the procedure must gracefully output a clear and descriptive notice that explicitly confirms whether a new addition or an update to an existing record has been performed.",
    "id": 165
  },
  {
    "ir": "Write a PLpgSQL stored procedure that inserts a new record into the \"director\" table. The procedure is named insert_new_director and accepts four input parameters: director_name of type text, director_gender of type text, director_nationality of type text, and birth_year of type integer. The procedure begins by declaring a local variable new_did of type integer. It then executes a SELECT statement to determine the maximum value of the \"did\" column in the \"director\" table, using the COALESCE function to handle cases where the table might be empty by defaulting to 0. The result of this SELECT statement, incremented by 1, is stored in the new_did variable, effectively generating a new unique identifier for the director. Following this, the procedure performs an INSERT operation into the \"director\" table, populating the \"did\", \"name\", \"gender\", \"nationality\", and \"birth_year\" columns with the values of new_did, director_name, director_gender, director_nationality, and birth_year, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_director(IN director_name text, IN director_gender text, IN director_nationality text, IN birth_year integer) LANGUAGE plpgsql AS $$\nDECLARE\n    new_did integer;\nBEGIN\n    SELECT COALESCE(MAX(\"did\"), 0) + 1 INTO new_did FROM \"director\";\n    \n    INSERT INTO \"director\" (\"did\", \"name\", \"gender\", \"nationality\", \"birth_year\")\n    VALUES (new_did, director_name, director_gender, director_nationality, birth_year);\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "actor",
      "cast",
      "director",
      "directed_by",
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "CALL insert_new_director('Christopher Nolan', 'Male', 'British', 1970);",
      "CALL insert_new_director('Jane Campion', 'Female', 'New Zealander', 1954);",
      "CALL insert_new_director('Bong Joon Ho', 'Male', 'South Korean', 1969);",
      "CALL insert_new_director('Ava DuVernay', 'Female', 'American', 1972);",
      "CALL insert_new_director('Pedro AlmodÃ³var', 'Male', 'Spanish', 1949);"
    ],
    "summary": "Create a stored procedure named insert_new_director that inserts a new record into the director table. It accepts parameters for name, gender, nationality, and birth_year. The procedure generates a new unique did by finding the maximum existing did (defaulting to 0 if the table is empty) and adding 1, then inserts the new record with all column values.",
    "natural_language": "Hey, can you whip up a stored procedure called insert_new_director? It's gotta add a new person to the director table. You'll need to feed it the person's name, gender, where they're from, and their birth year. The trick is, it has to make up a new unique ID (the 'did') by checking the highest one already in there (or just use 0 if the table's totally empty) and then bumping it up by one. After that, just slot the whole new record in with all the info.",
    "id": 166
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_new_song that takes no input parameters and performs the following operations: first, it declares a local variable named max_song_id of type bigint; then, it executes a SELECT query on the \"Songs\" table to retrieve the maximum value from the \"SongId\" column and assigns that value to the max_song_id variable; if the result of this query is NULL, indicating the table is empty, the procedure sets the max_song_id variable to 0; finally, the procedure executes an INSERT statement into the \"Songs\" table, specifying values for the \"SongId\" and \"Title\" columns, where the value for \"SongId\" is calculated as the current max_song_id variable plus one, and the value for \"Title\" is the literal string 'New Song'.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_song()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    max_song_id bigint;\nBEGIN\n    SELECT MAX(\"SongId\") INTO max_song_id FROM \"Songs\";\n    IF max_song_id IS NULL THEN\n        max_song_id := 0; -- Initialize if table is empty\n    END IF;\n    INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (max_song_id + 1, 'New Song');\nEND;\n$$;",
    "database_name": "music_2",
    "tables": [
      "Band",
      "Songs",
      "Instruments",
      "Performance",
      "Vocals"
    ],
    "call_sqls": [
      "CALL insert_new_song();"
    ],
    "summary": "Create a stored procedure named insert_new_song with no parameters. It inserts a new record into the Songs table by generating a new SongId as the maximum existing SongId plus 1 (or starting at 1 if the table is empty) and setting the Title to 'New Song'.",
    "natural_language": "Hey, can you whip up a stored procedure called insert_new_song that doesn't need any inputs? It should just pop a new record into the Songs table. For the SongId, figure out the highest one already there and add 1 to it. If the table's totally empty, just kick things off with 1. Oh, and set the Title to 'New Song'.",
    "id": 167
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_product_with_markup that accepts three input parameters: a text parameter p_product_name representing the name of a new product, a numeric parameter p_base_price representing the product's base cost, and a bigint parameter p_manufacturer_code representing the identifier of the product's manufacturer. The procedure first declares two local variables: v_new_code of type bigint and v_final_price of type numeric. It then performs a SELECT query on the \"Products\" table to calculate a new primary key value by taking the maximum existing value from the \"Code\" column, using the COALESCE function to substitute 0 if the column is null, and adding 1 to this result, storing the computed value into the v_new_code variable. Next, the procedure calculates a final selling price by multiplying the input p_base_price by 1.25 to apply a 25% markup and then rounds the result to two decimal places using the ROUND function, assigning this value to the v_final_price variable. Finally, the procedure executes an INSERT statement on the \"Products\" table, creating a new row with the column \"Code\" set to the generated v_new_code, the column \"Name\" set to the input p_product_name, the column \"Price\" set to the calculated v_final_price, and the column \"Manufacturer\" set to the input p_manufacturer_code.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_product_with_markup(\n    p_product_name text,\n    p_base_price numeric,\n    p_manufacturer_code bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_code bigint;\n    v_final_price numeric;\nBEGIN\n    SELECT COALESCE(MAX(\"Code\"), 0) + 1 INTO v_new_code FROM \"Products\";\n    v_final_price := ROUND(p_base_price * 1.25, 2);\n    INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\")\n    VALUES (v_new_code, p_product_name, v_final_price, p_manufacturer_code);\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL insert_product_with_markup('Laptop', 800, 1);",
      "CALL insert_product_with_markup('Monitor', 200, 2);",
      "CALL insert_product_with_markup('Keyboard', 50, 3);",
      "CALL insert_product_with_markup('Mouse', 25, 1);",
      "CALL insert_product_with_markup('Printer', 150, 2);"
    ],
    "summary": "Create a stored procedure named insert_product_with_markup that inserts a new product. It accepts parameters for product_name, base_price, and manufacturer_code. The procedure generates a new unique Code, calculates a final price by applying a 25% markup to the base_price and rounding to two decimals, then inserts the new record with these values.",
    "natural_language": "Write a stored procedure called insert_product_with_markup to insert a new product. It must take product_name, base_price, and manufacturer_code as parameters. The procedure should generate a unique Code, compute a final price by adding a 25% markup to the base_price and rounding to two decimal places, and then insert the new record using these values.",
    "id": 168
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_products_by_criteria` that accepts three input parameters: `p_manufacturer_code` of type `bigint`, `p_max_price` of type `numeric`, and `p_min_code` of type `bigint`. The purpose of this procedure is to remove records from the table named `\"Products\"`. The deletion operation is conditional, targeting rows where the value in the `\"Manufacturer\"` column exactly matches the value provided in the `p_manufacturer_code` parameter, AND simultaneously, the value in the `\"Price\"` column is less than or equal to the value provided in the `p_max_price` parameter, AND concurrently, the value in the `\"Code\"` column is greater than or equal to the value provided in the `p_min_code` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_products_by_criteria(\n    p_manufacturer_code bigint,\n    p_max_price numeric,\n    p_min_code bigint\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Products\"\n    WHERE \"Manufacturer\" = p_manufacturer_code\n    AND \"Price\" <= p_max_price\n    AND \"Code\" >= p_min_code;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL delete_products_by_criteria(1, 200, 1);",
      "CALL delete_products_by_criteria(2, 150, 2);",
      "CALL delete_products_by_criteria(3, 100, 3);",
      "CALL delete_products_by_criteria(1, 250, 1);",
      "CALL delete_products_by_criteria(2, 180, 2);"
    ],
    "summary": "Create a stored procedure named delete_products_by_criteria that deletes records from the Products table. It accepts parameters for manufacturer_code, max_price, and min_code. It deletes rows where the Manufacturer matches the given code, the Price is less than or equal to the max_price, and the Code is greater than or equal to the min_code.",
    "natural_language": "Write a stored procedure called delete_products_by_criteria to remove records from the Products table. The procedure must take manufacturer_code, max_price, and min_code as parameters and delete all rows where the Manufacturer equals the provided code, the Price is no more than the max_price, and the Code is at least the min_code.",
    "id": 169
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named create_manufacturer_entry that accepts three input parameters: a text parameter p_company_name representing the name of the manufacturing company, a text parameter p_headquarters representing the location of the company's headquarters, and a real parameter p_initial_revenue representing the initial revenue figure. The procedure first declares a local bigint variable v_next_code. It then executes a SELECT statement on the \"Manufacturers\" table to calculate the next available code value by taking the maximum existing value from the \"Code\" column, using the COALESCE function to return 0 if the column contains only NULL values, and adding 1 to that result, storing the computed value into the variable v_next_code. Finally, the procedure performs an INSERT operation into the \"Manufacturers\" table, populating the columns \"Code\" with the value from v_next_code, \"Name\" with the value from p_company_name, \"Headquarter\" with the value from p_headquarters, \"Founder\" with the hardcoded string literal 'Unknown', and \"Revenue\" with the value from p_initial_revenue.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_manufacturer_entry(\n    p_company_name text,\n    p_headquarters text,\n    p_initial_revenue real\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_next_code bigint;\nBEGIN\n    SELECT COALESCE(MAX(\"Code\"), 0) + 1 INTO v_next_code FROM \"Manufacturers\";\n    INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\")\n    VALUES (v_next_code, p_company_name, p_headquarters, 'Unknown', p_initial_revenue);\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL create_manufacturer_entry('Samsung', 'Seoul', 200.0);",
      "CALL create_manufacturer_entry('Apple', 'Cupertino', 300.0);",
      "CALL create_manufacturer_entry('Microsoft', 'Redmond', 250.0);",
      "CALL create_manufacturer_entry('Dell', 'Round Rock', 150.0);",
      "CALL create_manufacturer_entry('Lenovo', 'Beijing', 180.0);"
    ],
    "summary": "Create a stored procedure named create_manufacturer_entry that inserts a new manufacturer. It accepts parameters for company_name, headquarters, and initial_revenue. The procedure generates a new unique Code by finding the maximum existing Code (defaulting to 0) and adding 1, then inserts a record with this code, the provided parameters, and a hardcoded 'Unknown' for the Founder column.",
    "natural_language": "Hey, can you whip up a stored procedure called create_manufacturer_entry that adds a new manufacturer? It needs to take in the company name, where their HQ is, and how much cash they started with. The trick is, it has to cook up a brand new unique Code by grabbing the biggest Code already in there (or just use 0 if there's none) and bumping it up by 1. Then it slaps in a new record with that fresh code, the info we gave it, and just puts 'Unknown' for the Founder bit.",
    "id": 170
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `remove_manufacturer_data` that accepts three input parameters: `p_manufacturer_code` of type `bigint`, `p_revenue_threshold` of type `real`, and `p_min_product_price` of type `numeric`. The procedure first performs a `DELETE` operation on the `\"Products\"` table. This deletion targets rows where the value in the `\"Manufacturer\"` column exactly matches the value provided in the `p_manufacturer_code` parameter AND the value in the `\"Price\"` column is greater than or equal to the value provided in the `p_min_product_price` parameter. Following this, the procedure performs a second `DELETE` operation, this time on the `\"Manufacturers\"` table. This subsequent deletion targets rows where the value in the `\"Code\"` column exactly matches the value provided in the `p_manufacturer_code` parameter AND the value in the `\"Revenue\"` column is less than or equal to the value provided in the `p_revenue_threshold` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_manufacturer_data(\n    p_manufacturer_code bigint,\n    p_revenue_threshold real,\n    p_min_product_price numeric\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Products\" WHERE \"Manufacturer\" = p_manufacturer_code AND \"Price\" >= p_min_product_price;\n    DELETE FROM \"Manufacturers\" WHERE \"Code\" = p_manufacturer_code AND \"Revenue\" <= p_revenue_threshold;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL remove_manufacturer_data(1, 100.0, 200);",
      "CALL remove_manufacturer_data(2, 120.0, 100);",
      "CALL remove_manufacturer_data(3, 50.0, 150);",
      "CALL remove_manufacturer_data(1, 120.0, 240);",
      "CALL remove_manufacturer_data(2, 100.0, 120);"
    ],
    "summary": "Create a stored procedure named `remove_manufacturer_data` that takes a manufacturer code (bigint), a revenue threshold (real), and a minimum product price (numeric). First, delete from the \"Products\" table where the manufacturer matches the code and the price is at least the minimum. Then, delete from the \"Manufacturers\" table where the code matches and the revenue is at most the threshold.",
    "natural_language": "Alright, so I need you to whip up a stored procedure called `remove_manufacturer_data`. It's gotta take three things: a manufacturer code (that's a bigint), a revenue cap (that's a real number), and a minimum price for products (a numeric). Here's the deal: first, go ahead and wipe out any entries in the \"Products\" table where the manufacturer code matches the one given and the product's price is at least that minimum price. After that's done, clean up the \"Manufacturers\" table by deleting any manufacturer whose code matches and whose revenue is at or below that threshold.",
    "id": 171
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `calculate_average_age_by_club` that takes no parameters. The procedure begins by declaring two local variables: `avg_age` of type `NUMERIC` to store the calculated average age, and `club_count` of type `INTEGER` to store the count of records in the \"club\" table. It then executes a `SELECT` statement to count all rows in the \"club\" table and stores this count into the `club_count` variable. Following this, it evaluates a conditional `IF` statement: if the value of `club_count` is greater than 0, the procedure proceeds to execute a `SELECT` statement to calculate the average of all values in the \"Age\" column from the \"member\" table, storing the result into the `avg_age` variable. Subsequently, within the same conditional block, it performs an `INSERT` operation into the \"club\" table. This `INSERT` statement populates the \"Club_ID\" column with the literal integer value `999`, the \"Overall_Ranking\" column with the ceiling value of `avg_age` (obtained by applying the `CEIL` function to the `avg_age` variable), the \"Team_Leader\" column with the literal string `'System Generated'`, and the \"Club_Name\" column with the literal string `'Average Age Club'`. If the initial `club_count` is not greater than 0, the conditional block is skipped, and no further operations are performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_age_by_club()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_age NUMERIC;\n    club_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO club_count FROM \"club\";\n    \n    IF club_count > 0 THEN\n        SELECT AVG(\"Age\") INTO avg_age FROM \"member\";\n        INSERT INTO \"club\" (\"Club_ID\", \"Overall_Ranking\", \"Team_Leader\", \"Club_Name\")\n        VALUES (999, CEIL(avg_age), 'System Generated', 'Average Age Club');\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL calculate_average_age_by_club();"
    ],
    "summary": "Create a stored procedure named `calculate_average_age_by_club` with no parameters. Count the rows in the \"club\" table. If the count is greater than zero, calculate the average age from the \"member\" table. Then, insert a new row into the \"club\" table with Club_ID 999, the ceiling of the average age as the ranking, 'System Generated' as the team leader, and 'Average Age Club' as the name.",
    "natural_language": "Develop a stored procedure, which should be named `calculate_average_age_by_club`, that accepts no parameters. First, determine the total number of entries present within the \"club\" table. Should this count be found to be greater than zero, proceed to compute the precise average age derived from all records in the \"member\" table. Subsequently, insert a meticulously crafted new row into the \"club\" table, specifically assigning the Club_ID as 999, using the ceiling value of the previously calculated average age for the ranking, designating 'System Generated' as the team leader, and finally providing 'Average Age Club' as the official name for this entry.",
    "id": 172
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named process_leader_nationalities that takes no input parameters and begins by declaring a local integer variable called australian_count, then executes a SELECT query to count all rows in the \"member\" table where the \"Nationality\" column exactly equals the string 'Australia', storing the resulting count into the australian_count variable, and subsequently evaluates a conditional IF statement that checks if the value of australian_count is greater than 5, and if this condition is true, performs a DELETE operation on the \"club_leader\" table, targeting all rows where the \"Club_ID\" column value is found within a subquery that selects the \"Club_ID\" from the \"club\" table for rows where the \"Club_Name\" column starts with the capital letter 'O' as determined by the LIKE operator with the pattern 'O%'.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_leader_nationalities()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    australian_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO australian_count FROM \"member\" WHERE \"Nationality\" = 'Australia';\n    \n    IF australian_count > 5 THEN\n        DELETE FROM \"club_leader\" WHERE \"Club_ID\" IN (\n            SELECT \"Club_ID\" FROM \"club\" WHERE \"Club_Name\" LIKE 'O%'\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL process_leader_nationalities();"
    ],
    "summary": "Create a stored procedure named `process_leader_nationalities` with no parameters. Count the members with 'Australia' nationality. If the count exceeds 5, delete from the \"club_leader\" table where the Club_ID is in a subquery selecting Club_ID from the \"club\" table where the Club_Name starts with 'O'.",
    "natural_language": "Hey, can you whip up a stored procedure called `process_leader_nationalities` that doesn't need any inputs? First, figure out how many members are from 'Australia'. If you get more than 5, then go ahead and delete records from the \"club_leader\" table. But only delete the ones where the Club_ID matches clubs from the \"club\" table that have names starting with 'O'.",
    "id": 173
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named reorganize_cluster_structure that takes no input parameters and begins by declaring a local integer variable called total_members, then executes a SELECT statement to count all rows from the table named \"member\" and stores the resulting integer value into the total_members variable, then evaluates a conditional IF statement that checks if the value of total_members is less than 50, and if this condition is true, performs a DELETE operation on the table named \"club\" where rows are removed if their \"Club_ID\" column value is not found in the distinct set of \"Club_ID\" values returned from a subquery that selects the distinct \"Club_ID\" column values from the table named \"club_leader\".",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_club_structure()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_members INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO total_members FROM \"member\";\n    \n    IF total_members < 50 THEN\n        DELETE FROM \"club\" WHERE \"Club_ID\" NOT IN (\n            SELECT DISTINCT \"Club_ID\" FROM \"club_leader\"\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL reorganize_club_structure();"
    ],
    "summary": "Create a stored procedure named `reorganize_cluster_structure` with no parameters. Count all members. If the total is less than 50, delete from the \"club\" table where the Club_ID is not found in the distinct Club_ID values from the \"club_leader\" table.",
    "natural_language": "Construct a stored procedure, which should be named `reorganize_cluster_structure` and defined without any input parameters. First, determine the complete count of all members. In the event that this calculated total is found to be fewer than fifty, proceed to delete those records from the database table labeled \"club\" where the Club_ID value does not correspond to any of the distinct Club_ID entries present within the \"club_leader\" table.",
    "id": 174
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named ProcessOrderItems that accepts four input parameters: p_order_id of type bigint representing the identifier of an order, p_product_id of type bigint representing the identifier of a product, p_order_quantity of type text representing the quantity to be ordered, and p_product_type of type text representing the type code of the product. The procedure first declares two local variables: v_product_price of type double precision to store a product's price and v_order_exists of type boolean to store the existence check result. It begins execution by checking if an order with the specified p_order_id exists in the Customer_Orders table, using a SELECT EXISTS subquery on the Customer_Orders table where the order_id column equals the p_order_id parameter, and stores the boolean result into the v_order_exists variable. If v_order_exists is true, the procedure then queries the Products table to retrieve the product_price column value for a row where the product_id column equals the p_product_id parameter and the product_type_code column equals the p_product_type parameter, storing this value into the v_product_price variable. If the subsequent check determines that v_product_price is not null, the procedure performs an insert operation into the Order_Items table, specifying values for the columns order_item_id, order_id, product_id, and order_quantity. The value for the order_item_id column is generated by a subquery that selects the maximum existing order_item_id from the Order_Items table, applies the COALESCE function to treat a null maximum as 0, and adds 1 to this result; the values for the order_id, product_id, and order_quantity columns are directly taken from the input parameters p_order_id, p_product_id, and p_order_quantity respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"ProcessOrderItems\"(\"p_order_id\" bigint, \"p_product_id\" bigint, \"p_order_quantity\" text, \"p_product_type\" text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"v_product_price\" double precision;\n    \"v_order_exists\" boolean;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM \"Customer_Orders\" WHERE \"order_id\" = \"p_order_id\") INTO \"v_order_exists\";\n    IF \"v_order_exists\" THEN\n        SELECT \"product_price\" INTO \"v_product_price\" FROM \"Products\" WHERE \"product_id\" = \"p_product_id\" AND \"product_type_code\" = \"p_product_type\";\n        IF \"v_product_price\" IS NOT NULL THEN\n            INSERT INTO \"Order_Items\"(\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\")\n            VALUES ((SELECT COALESCE(MAX(\"order_item_id\"), 0) + 1 FROM \"Order_Items\"), \"p_order_id\", \"p_product_id\", \"p_order_quantity\");\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL \"ProcessOrderItems\"(1, 1, '2', 'Hardware');",
      "CALL \"ProcessOrderItems\"(2, 2, '4', 'Clothes');",
      "CALL \"ProcessOrderItems\"(3, 3, '1', 'Hardware');",
      "CALL \"ProcessOrderItems\"(1, 2, '3', 'Clothes');",
      "CALL \"ProcessOrderItems\"(2, 1, '5', 'Hardware');"
    ],
    "summary": "Create a stored procedure named `ProcessOrderItems` that accepts an order ID, product ID, quantity (text), and product type (text). Check if the order exists in Customer_Orders. If it exists, get the product's price from the Products table using the product ID and type. If a price is found, insert a new row into Order_Items. Generate the new order_item_id as one greater than the current maximum, and use the provided parameters for order_id, product_id, and order_quantity.",
    "natural_language": "Create procedure `ProcessOrderItems` with order ID, product ID, quantity text, and product type text. Verify order in Customer_Orders. If valid, fetch product price from Products using ID and type. If price exists, insert into Order_Items. Set new order_item_id to max plus one. Use given order_id, product_id, and order_quantity.",
    "id": 175
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"AnalyzeProductOrders\" that accepts four input parameters: a bigint parameter \"p_customer_id\" to identify a specific customer, a text parameter \"p_status_code\" to filter by order status, a text parameter \"p_product_name\" to match a substring within product names, and an integer parameter \"p_min_length\" to specify a minimum character length for product names. The procedure begins by declaring two local variables: an integer \"v_order_count\" and a double precision \"v_total_price\". It then executes a SELECT query that joins three tables: \"Customer_Orders\" (aliased as co), \"Order_Items\" (aliased as oi), and \"Products\" (aliased as pr). The join condition links \"Customer_Orders\" to \"Order_Items\" on the \"order_id\" column and \"Order_Items\" to \"Products\" on the \"product_id\" column. The query filters the results where the \"customer_id\" in \"Customer_Orders\" equals the input parameter \"p_customer_id\", the \"order_status_code\" in \"Customer_Orders\" equals the input parameter \"p_status_code\", the length of the \"product_name\" column from the \"Products\" table is greater than the input parameter \"p_min_length\", and the \"product_name\" contains the substring specified by \"p_product_name\" using a LIKE pattern with wildcards. From this filtered and joined dataset, the query calculates the count of distinct \"order_id\" values from the \"Customer_Orders\" table and the sum of the \"product_price\" column from the \"Products\" table, storing these results into the local variables \"v_order_count\" and \"v_total_price\" respectively. Following this query, a conditional IF statement checks if the value of \"v_order_count\" is greater than zero. If this condition is true, the procedure performs an INSERT operation into the \"Customer_Orders\" table. The inserted values are: for the \"order_id\" column, a subquery that calculates the next sequential ID by taking the maximum existing \"order_id\" from the \"Customer_Orders\" table, using COALESCE to default to 0 if the table is empty, and adding 1; for the \"customer_id\" column, the input parameter \"p_customer_id\"; for the \"order_date\" column, the current timestamp provided by CURRENT_TIMESTAMP; and for the \"order_status_code\" column, the literal string 'Analyzed'.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"AnalyzeProductOrders\"(\"p_customer_id\" bigint, \"p_status_code\" text, \"p_product_name\" text, \"p_min_length\" integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"v_order_count\" integer;\n    \"v_total_price\" double precision;\nBEGIN\n    SELECT COUNT(DISTINCT co.\"order_id\"), SUM(pr.\"product_price\")\n    INTO \"v_order_count\", \"v_total_price\"\n    FROM \"Customer_Orders\" co\n    JOIN \"Order_Items\" oi ON co.\"order_id\" = oi.\"order_id\"\n    JOIN \"Products\" pr ON oi.\"product_id\" = pr.\"product_id\"\n    WHERE co.\"customer_id\" = \"p_customer_id\"\n    AND co.\"order_status_code\" = \"p_status_code\"\n    AND length(pr.\"product_name\") > \"p_min_length\"\n    AND pr.\"product_name\" LIKE '%' || \"p_product_name\" || '%';\n    \n    IF \"v_order_count\" > 0 THEN\n        INSERT INTO \"Customer_Orders\"(\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n        VALUES ((SELECT COALESCE(MAX(\"order_id\"), 0) + 1 FROM \"Customer_Orders\"), \"p_customer_id\", CURRENT_TIMESTAMP, 'Analyzed');\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL \"AnalyzeProductOrders\"(12, 'Part', 'Monitor', 5);",
      "CALL \"AnalyzeProductOrders\"(3, 'Part', 'Jeans', 3);",
      "CALL \"AnalyzeProductOrders\"(12, 'Part', 'Topping', 2);",
      "CALL \"AnalyzeProductOrders\"(1, 'Completed', 'Laptop', 4);",
      "CALL \"AnalyzeProductOrders\"(5, 'Pending', 'Mouse', 3);"
    ],
    "summary": "Create a stored procedure named AnalyzeProductOrders that takes a customer ID, status code, product name substring, and minimum product name length. It counts distinct orders and sums product prices for the matching customer, status, and products where the name length exceeds the threshold and contains the substring. If the order count is greater than zero, insert a new 'Analyzed' status order for that customer with a new order ID.",
    "natural_language": "Create a stored procedure called AnalyzeProductOrders that works with a customer ID, a status code, a bit of text that might be in a product name, and a sort of minimum length for that name. It should figure out roughly how many different orders there are and add up the product prices for the relevant customer and status, but only for products where the name is long enough and kind of includes that text snippet. If it turns out there are some orders, then add a new order with an 'Analyzed' status for that customer, using a fresh order ID.",
    "id": 176
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named TransformOrderData that accepts four input parameters: p_old_status of type text, p_new_status of type text, p_product_type of type text, and p_date_threshold of type timestamp with time zone. The procedure begins by declaring a record variable named v_order_record to hold rows from a query. It then executes a loop over the distinct set of order_id and customer_id values retrieved from a query that joins the Customer_Orders table (aliased as co) with the Order_Items table (aliased as oi) on the order_id column, and further joins the result with the Products table (aliased as pr) on the product_id column. The join query selects only those rows where the order_status_code column in the Customer_Orders table equals the p_old_status parameter, the order_date column in the Customer_Orders table is earlier than the p_date_threshold parameter, and the product_type_code column in the Products table equals the p_product_type parameter. For each distinct order_id and customer_id pair fetched into the v_order_record variable, the procedure performs an insert operation into the Customer_Orders table. The values inserted are: for the order_id column, a subquery that calculates the maximum existing order_id value from the Customer_Orders table, uses the COALESCE function to substitute 0 if the maximum is null, and adds 1000 to the result; for the customer_id column, the customer_id value from the current v_order_record; for the order_date column, the current timestamp provided by the CURRENT_TIMESTAMP function; and for the order_status_code column, the value of the p_new_status input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"TransformOrderData\"(\"p_old_status\" text, \"p_new_status\" text, \"p_product_type\" text, \"p_date_threshold\" timestamp with time zone)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"v_order_record\" RECORD;\nBEGIN\n    FOR \"v_order_record\" IN \n        SELECT DISTINCT co.\"order_id\", co.\"customer_id\"\n        FROM \"Customer_Orders\" co\n        JOIN \"Order_Items\" oi ON co.\"order_id\" = oi.\"order_id\"\n        JOIN \"Products\" pr ON oi.\"product_id\" = pr.\"product_id\"\n        WHERE co.\"order_status_code\" = \"p_old_status\"\n        AND co.\"order_date\" < \"p_date_threshold\"\n        AND pr.\"product_type_code\" = \"p_product_type\"\n    LOOP\n        INSERT INTO \"Customer_Orders\"(\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n        VALUES ((SELECT COALESCE(MAX(\"order_id\"), 0) + 1000 FROM \"Customer_Orders\"), \n                \"v_order_record\".\"customer_id\", \n                CURRENT_TIMESTAMP, \n                \"p_new_status\");\n    END LOOP;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL \"TransformOrderData\"('Part', 'Completed', 'Hardware', '2023-01-01 00:00:00+00:00');",
      "CALL \"TransformOrderData\"('Pending', 'Shipped', 'Clothes', '2022-12-31 23:59:59+00:00');",
      "CALL \"TransformOrderData\"('Processing', 'Cancelled', 'Hardware', '2023-06-01 12:00:00+00:00');",
      "CALL \"TransformOrderData\"('On Hold', 'Returned', 'Clothes', '2023-03-15 08:00:00+00:00');",
      "CALL \"TransformOrderData\"('Backordered', 'Delivered', 'Hardware', '2023-09-30 18:30:00+00:00');"
    ],
    "summary": "Create a stored procedure named TransformOrderData that takes an old status, a new status, a product type, and a date threshold. For each distinct order and customer where the order has the old status, is older than the threshold date, and contains the specified product type, insert a new order for that customer with the new status and a new order ID (max ID + 1000).",
    "natural_language": "Alright, so we need a stored procedure called TransformOrderData. Here's the deal: it's gotta take in an old order status, a new status, a specific kind of product, and a cutoff date. For every unique order and customer combo where the order's still stuck with the old status, is older than that cutoff date, and has that product type in it, we gotta make a brand new order for that same customer. This new order gets the new status and a fresh order IDâ€”just take the highest existing ID and bump it up by 1000.",
    "id": 177
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"AggregateCustomerStats\" that accepts four input parameters: \"p_customer_id\" of type `bigint`, \"p_status_filter\" of type `text`, \"p_name_pattern\" of type `text`, and \"p_quantity_threshold\" of type `integer`. The procedure first declares two local variables: \"v_product_count\" of type `integer` and \"v_avg_name_length\" of type `numeric`. It then executes a `SELECT` statement to calculate two aggregate values. The first aggregate value is the count of distinct \"product_id\" values from the \"Products\" table, aliased as `pr`. The second aggregate value is the average length of the \"product_name\" column from the \"Products\" table. These calculated values are stored into the local variables \"v_product_count\" and \"v_avg_name_length\" respectively. The `SELECT` statement retrieves data by joining three tables: \"Customer_Orders\" (aliased as `co`), \"Order_Items\" (aliased as `oi`), and \"Products\" (aliased as `pr`). The join conditions are `co.\"order_id\" = oi.\"order_id\"` to link customer orders to their items, and `oi.\"product_id\" = pr.\"product_id\"` to link order items to product details. The `WHERE` clause filters the results based on several conditions: `co.\"customer_id\"` must be equal to the input parameter \"p_customer_id\"; `co.\"order_status_code\"` must match the pattern formed by concatenating '%' with the input parameter \"p_status_filter\" and then with '%' again, effectively checking for \"p_status_filter\" as a substring within the status code; `pr.\"product_name\"` must match the pattern specified by the input parameter \"p_name_pattern\"; and the integer cast of `oi.\"order_quantity\"` must be greater than the input parameter \"p_quantity_threshold\".\n\nFollowing this data retrieval, the procedure enters a conditional block. It checks if the value of \"v_product_count\" is greater than 0.\n\nIf \"v_product_count\" is greater than 0, the procedure executes an `INSERT` statement into the \"Customer_Orders\" table. The `INSERT` statement populates the columns \"order_id\", \"customer_id\", \"order_date\", and \"order_status_code\". The \"order_id\" is determined by selecting the maximum \"order_id\" from the \"Customer_Orders\" table, using `COALESCE` to default to 0 if no orders exist, and then adding 2000 to that value. The \"customer_id\" is set to the input parameter \"p_customer_id\". The \"order_date\" is set to the current timestamp using `CURRENT_TIMESTAMP`. The \"order_status_code\" is constructed by concatenating the literal string 'Stats_' with the text representation of \"v_product_count\".\n\nIf \"v_product_count\" is not greater than 0 (i.e., it is 0 or less), the procedure executes an `INSERT` statement into the \"Customer_Orders\" table. This `INSERT` statement also populates the columns \"order_id\", \"customer_id\", \"order_date\", and \"order_status_code\". Similar to the previous `INSERT`, the \"order_id\" is determined by selecting the maximum \"order_id\" from the \"Customer_Orders\" table, using `COALESCE` to default to 0 if no orders exist, and then adding 2000. The \"customer_id\" is set to the input parameter \"p_customer_id\". The \"order_date\" is set to the current timestamp using `CURRENT_TIMESTAMP`. The \"order_status_code\" is set to the literal string 'No_Stats'.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"AggregateCustomerStats\"(\"p_customer_id\" bigint, \"p_status_filter\" text, \"p_name_pattern\" text, \"p_quantity_threshold\" integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"v_product_count\" integer;\n    \"v_avg_name_length\" numeric;\nBEGIN\n    SELECT COUNT(DISTINCT pr.\"product_id\"), AVG(length(pr.\"product_name\"))\n    INTO \"v_product_count\", \"v_avg_name_length\"\n    FROM \"Customer_Orders\" co\n    JOIN \"Order_Items\" oi ON co.\"order_id\" = oi.\"order_id\"\n    JOIN \"Products\" pr ON oi.\"product_id\" = pr.\"product_id\"\n    WHERE co.\"customer_id\" = \"p_customer_id\"\n    AND co.\"order_status_code\" LIKE '%' || \"p_status_filter\" || '%'\n    AND pr.\"product_name\" LIKE \"p_name_pattern\"\n    AND CAST(oi.\"order_quantity\" AS integer) > \"p_quantity_threshold\";\n    \n    IF \"v_product_count\" > 0 THEN\n        INSERT INTO \"Customer_Orders\"(\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n        VALUES ((SELECT COALESCE(MAX(\"order_id\"), 0) + 2000 FROM \"Customer_Orders\"), \n                \"p_customer_id\", \n                CURRENT_TIMESTAMP, \n                'Stats_' || CAST(\"v_product_count\" AS text));\n    ELSE\n        INSERT INTO \"Customer_Orders\"(\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n        VALUES ((SELECT COALESCE(MAX(\"order_id\"), 0) + 2000 FROM \"Customer_Orders\"), \n                \"p_customer_id\", \n                CURRENT_TIMESTAMP, \n                'No_Stats');\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL \"AggregateCustomerStats\"(12, 'Part', '%Monitor%', 1);",
      "CALL \"AggregateCustomerStats\"(3, 'Part', '%Jeans%', 3);",
      "CALL \"AggregateCustomerStats\"(1, 'Complete', '%Topping%', 0);",
      "CALL \"AggregateCustomerStats\"(12, 'Pending', '%Keyboard%', 5);",
      "CALL \"AggregateCustomerStats\"(3, 'Shipped', '%Shirt%', 2);"
    ],
    "summary": "Create a stored procedure named AggregateCustomerStats that takes a customer ID, a status filter substring, a product name pattern, and a quantity threshold. It calculates the count of distinct products and the average product name length for the customer's orders matching the filters. If the product count is greater than zero, insert a new order with a status of 'Stats_' concatenated with the product count. Otherwise, insert a new order with a status of 'No_Stats'.",
    "natural_language": "Create a stored procedure called AggregateCustomerStats that accepts a customer ID, a status filter substring, a product name pattern, and a quantity threshold. It must compute the number of distinct products and the average length of product names for the customer's orders that meet the filter criteria. If the product count exceeds zero, insert a new order with a status formed by concatenating 'Stats_' with the product count. If not, insert a new order with a status of 'No_Stats'.",
    "id": 178
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_party_address that accepts two mandatory input parameters: party_id_input of type BIGINT, which represents the unique identifier for a party, and address_id_input of type BIGINT, which represents the unique identifier for an address. The procedure begins by declaring a local variable address_type_val of type TEXT. It then calculates the value for this variable using a conditional CASE expression: it checks if the input party_id_input is an even number by evaluating the modulo operation MOD(party_id_input, 2) = 0; if this condition is true, the variable is assigned the string literal 'Billing', otherwise it is assigned the string literal 'Residence'. Following this logic, the procedure performs a single INSERT operation into the table named \"Party_Addresses\". It inserts a new row with values for four columns: the \"party_id\" column is set to the input parameter party_id_input, the \"address_id\" column is set to the input parameter address_id_input, the \"date_address_from\" column is populated with the current date and time using the function call CURRENT_TIMESTAMP, and the \"address_type_code\" column is set to the derived value stored in the local variable address_type_val.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_party_address(party_id_input BIGINT, address_id_input BIGINT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    address_type_val TEXT;\nBEGIN\n    address_type_val := CASE WHEN MOD(party_id_input, 2) = 0 THEN 'Billing' ELSE 'Residence' END;\n    INSERT INTO \"Party_Addresses\" (\"party_id\", \"address_id\", \"date_address_from\", \"address_type_code\")\n    VALUES (party_id_input, address_id_input, CURRENT_TIMESTAMP, address_type_val);\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Addresses",
      "Forms",
      "Individuals",
      "Organizations",
      "Parties",
      "Party_Addresses",
      "Party_Forms",
      "Party_Services",
      "Services"
    ],
    "call_sqls": [
      "CALL insert_party_address(1, 1);",
      "CALL insert_party_address(2, 2);",
      "CALL insert_party_address(3, 3);",
      "CALL insert_party_address(4, 1);",
      "CALL insert_party_address(5, 2);"
    ],
    "summary": "Create a stored procedure named insert_party_address that takes a party ID and an address ID. Determine the address type as 'Billing' if the party ID is even, otherwise 'Residence'. Insert a new record into Party_Addresses with these IDs, the current timestamp, and the determined address type.",
    "natural_language": "How can I create a stored procedure called 'insert_party_address' that accepts a party ID and an address ID, determines the address type as 'Billing' for even party IDs and 'Residence' for odd ones, and then inserts a new record into the Party_Addresses table with these values and the current timestamp?",
    "id": 179
  },
  {
    "ir": "Write a PostgreSQL stored procedure named `delete_old_party_forms` that accepts two input parameters: `party_id_input` of type `BIGINT` and `days_threshold` of type `INTEGER`. The purpose of `party_id_input` is to specify the unique identifier of a party whose forms are to be considered for deletion. The purpose of `days_threshold` is to define the number of days in the past, relative to the current timestamp, beyond which forms are considered \"old\" and eligible for deletion. The procedure performs a `DELETE` operation on the table named `\"Party_Forms\"`. The rows to be deleted are determined by two conditions combined with a logical `AND` operator. The first condition specifies that the value in the `\"party_id\"` column of a row must be equal to the value provided by the `party_id_input` parameter. The second condition specifies that the value in the `\"date_completion_started\"` column of a row must be strictly less than a calculated timestamp. This calculated timestamp is derived by taking the `CURRENT_TIMESTAMP` (which represents the current date and time when the statement is executed) and subtracting an `INTERVAL`. This `INTERVAL` is constructed dynamically by concatenating the `days_threshold` integer value with the string literal ' days' and then explicitly casting the resulting string (e.g., '30 days') to the `INTERVAL` data type. Therefore, any form associated with the specified `party_id_input` whose completion start date is older than the current timestamp minus the specified number of days will be removed from the `\"Party_Forms\"` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_party_forms(party_id_input BIGINT, days_threshold INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Party_Forms\"\n    WHERE \"party_id\" = party_id_input\n    AND \"date_completion_started\" < CURRENT_TIMESTAMP - (days_threshold || ' days')::INTERVAL;\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Addresses",
      "Forms",
      "Individuals",
      "Organizations",
      "Parties",
      "Party_Addresses",
      "Party_Forms",
      "Party_Services",
      "Services"
    ],
    "call_sqls": [
      "CALL delete_old_party_forms(2, 30);",
      "CALL delete_old_party_forms(15, 60);",
      "CALL delete_old_party_forms(8, 90);",
      "CALL delete_old_party_forms(1, 180);",
      "CALL delete_old_party_forms(10, 7);"
    ],
    "summary": "Create a stored procedure named delete_old_party_forms that takes a party ID and a days threshold. Delete records from the Party_Forms table for the specified party where the completion start date is older than the current timestamp minus the given number of days.",
    "natural_language": "Create procedure delete_old_party_forms to remove Party_Forms records for a given party where the start date is older than now minus specified days.",
    "id": 180
  },
  {
    "ir": "Write a PLpgSQL stored procedure named insert_individual_from_party that accepts two parameters: party_id_input of type BIGINT, which represents the unique identifier of a party, and last_name_input of type TEXT, which represents the last name of an individual. The procedure begins by declaring two local variables, party_email_val and party_phone_val, both of type TEXT, to store the email and phone number associated with the specified party. It then performs a SELECT operation on the Parties table to retrieve the party_email and party_phone columns for the row where the party_id matches the provided party_id_input, storing these values into the declared variables. Next, the procedure attempts to INSERT a new row into the Individuals table with the following values: individual_id set to party_id_input, individual_last_name set to the uppercase version of last_name_input using the UPPER() function, individual_email set to the lowercase version of party_email_val using the LOWER() function, and inidividual_phone set to party_phone_val. If a conflict occurs on the individual_id column, indicating that a row with the same individual_id already exists, the procedure performs an UPDATE operation on the conflicting row, setting individual_last_name, individual_email, and inidividual_phone to the values from the EXCLUDED pseudo-table, which represents the values that would have been inserted.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_individual_from_party(party_id_input BIGINT, last_name_input TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    party_email_val TEXT;\n    party_phone_val TEXT;\nBEGIN\n    SELECT \"party_email\", \"party_phone\" INTO party_email_val, party_phone_val\n    FROM \"Parties\"\n    WHERE \"party_id\" = party_id_input;\n    \n    INSERT INTO \"Individuals\" (\"individual_id\", \"individual_last_name\", \"individual_email\", \"inidividual_phone\")\n    VALUES (party_id_input, UPPER(last_name_input), LOWER(party_email_val), party_phone_val)\n    ON CONFLICT (individual_id) DO UPDATE\n    SET\n        \"individual_last_name\" = EXCLUDED.\"individual_last_name\",\n        \"individual_email\" = EXCLUDED.\"individual_email\",\n        \"inidividual_phone\" = EXCLUDED.\"inidividual_phone\";\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Addresses",
      "Forms",
      "Individuals",
      "Organizations",
      "Parties",
      "Party_Addresses",
      "Party_Forms",
      "Party_Services",
      "Services"
    ],
    "call_sqls": [
      "CALL insert_individual_from_party(1, 'Smith');",
      "CALL insert_individual_from_party(2, 'Johnson');",
      "CALL insert_individual_from_party(3, 'Williams');",
      "CALL insert_individual_from_party(1, 'Brown');",
      "CALL insert_individual_from_party(2, 'Jones');"
    ],
    "summary": "Create a stored procedure named insert_individual_from_party that accepts a party_id (BIGINT) and a last_name (TEXT). Retrieve the party's email and phone from the Parties table. Insert a new individual using the party_id, the uppercase last_name, the lowercase email, and the phone. If the individual_id already exists, update the existing record with the new values instead.",
    "natural_language": "Construct a stored procedure, which we shall name 'insert_individual_from_party', that is designed to receive two distinct input parameters: a party identifier of type BIGINT and a last name provided as TEXT. The procedure must first perform a lookup in the comprehensive Parties table to meticulously retrieve the associated email address and contact phone number for the specified party. Subsequently, it should proceed to insert a brand new individual record, utilizing the supplied party_id, transforming the last_name to its uppercase representation, converting the email to a consistent lowercase format, and incorporating the phone number as retrieved. Importantly, if an individual record with that specific individual_id is already present within the system, the procedure must gracefully handle this by updating the pre-existing record with all the newly provided and transformed values, thereby ensuring data integrity and avoiding duplication.",
    "id": 181
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `redistribute_inventory_by_platform` that aims to manage and redistribute device inventory across shops based on their software platform. The procedure declares several local variables: `platform_rec` of type `RECORD` to hold platform-related data, `shop_rec` of type `RECORD` to hold shop-related data, `device_rec` of type `RECORD` to hold device-related data, `v_total_quantity` of type `INTEGER` to store the total quantity of a specific device, `v_shop_count` of type `INTEGER` to store the count of shops stocking devices for a given platform, `v_avg_per_shop` of type `INTEGER` to store the calculated average quantity per shop, and `v_current_quantity` of type `INTEGER` to store the current quantity of a specific device in a specific shop.\n\nThe procedure begins by iterating through each distinct `Software_Platform` found in the `device` table, excluding any records where `Software_Platform` is `NULL`. For each `platform_rec` representing a distinct `Software_Platform`:\n  First, it calculates `v_shop_count` by counting the distinct `Shop_ID` values from the `stock` table, joined with the `device` table on `Device_ID`, where the `Software_Platform` in the `device` table matches the current `platform_rec.\"Software_Platform\"`.\n  If `v_shop_count` is greater than 0 (meaning there are shops stocking devices for this platform), the procedure then enters a nested loop. This inner loop iterates through each `Device_ID` from the `device` table where the `Software_Platform` matches the current `platform_rec.\"Software_Platform\"`. For each `device_rec` representing a specific `Device_ID`:\n    It calculates `v_total_quantity` by summing the `Quantity` from the `stock` table for the current `device_rec.\"Device_ID\"`. If no records are found, `COALESCE` ensures `v_total_quantity` defaults to 0.\n    If `v_total_quantity` is greater than 0, it calculates `v_avg_per_shop` by dividing `v_total_quantity` by `v_shop_count`.\n    Then, it enters another nested loop, iterating through each `Shop_ID` from the `shop` table. For each `shop_rec` representing a specific `Shop_ID`:\n      It retrieves `v_current_quantity` by selecting the `Quantity` from the `stock` table for the current `shop_rec.\"Shop_ID\"` and `device_rec.\"Device_ID\"`. If no record is found, `COALESCE` ensures `v_current_quantity` defaults to 0.\n      A conditional block then evaluates `v_current_quantity`:\n        If `v_current_quantity` is 0 (meaning the shop does not currently stock this device):\n          If `v_avg_per_shop` is greater than 10, it inserts a new record into the `stock` table with `Shop_ID` as `shop_rec.\"Shop_ID\"`, `Device_ID` as `device_rec.\"Device_ID\"`, and `Quantity` as `v_avg_per_shop`.\n          Else if `v_avg_per_shop` is greater than 5, it inserts a new record into the `stock` table with `Shop_ID` as `shop_rec.\"Shop_ID\"`, `Device_ID` as `device_rec.\"Device_ID\"`, and `Quantity` as 5.\n          Else (if `v_avg_per_shop` is 5 or less), it inserts a new record into the `stock` table with `Shop_ID` as `shop_rec.\"Shop_ID\"`, `Device_ID` as `device_rec.\"Device_ID\"`, and `Quantity` as 1.\n        Else if `v_current_quantity` is less than `v_avg_per_shop` (meaning the shop has less than the average quantity):\n          If the difference (`v_avg_per_shop` - `v_current_quantity`) is greater than 20, it updates the `stock` table by increasing the `Quantity` by 20 for the current `shop_rec.\"Shop_ID\"` and `device_rec.\"Device_ID\"`.\n          Else, it updates the `stock` table by setting the `Quantity` to `v_avg_per_shop` for the current `shop_rec.\"Shop_ID\"` and `device_rec.\"Device_ID\"`.\n        Else if `v_current_quantity` is greater than `v_avg_per_shop` multiplied by 2 (meaning the shop has more than double the average quantity):\n          It deletes the record from the `stock` table for the current `shop_rec.\"Shop_ID\"` and `device_rec.\"Device_ID\"`.",
    "plsql": "CREATE OR REPLACE PROCEDURE redistribute_inventory_by_platform()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    platform_rec RECORD;\n    shop_rec RECORD;\n    device_rec RECORD;\n    v_total_quantity INTEGER;\n    v_shop_count INTEGER;\n    v_avg_per_shop INTEGER;\n    v_current_quantity INTEGER;\nBEGIN\n    FOR platform_rec IN SELECT DISTINCT \"Software_Platform\" FROM \"device\" WHERE \"Software_Platform\" IS NOT NULL LOOP\n        SELECT COUNT(DISTINCT s.\"Shop_ID\") INTO v_shop_count \n        FROM \"stock\" s \n        JOIN \"device\" d ON s.\"Device_ID\" = d.\"Device_ID\" \n        WHERE d.\"Software_Platform\" = platform_rec.\"Software_Platform\";\n        \n        IF v_shop_count > 0 THEN\n            FOR device_rec IN SELECT \"Device_ID\" FROM \"device\" WHERE \"Software_Platform\" = platform_rec.\"Software_Platform\" LOOP\n                SELECT COALESCE(SUM(\"Quantity\"), 0) INTO v_total_quantity \n                FROM \"stock\" \n                WHERE \"Device_ID\" = device_rec.\"Device_ID\";\n                \n                IF v_total_quantity > 0 THEN\n                    v_avg_per_shop := v_total_quantity / v_shop_count;\n                    \n                    FOR shop_rec IN SELECT \"Shop_ID\" FROM \"shop\" LOOP\n                        SELECT COALESCE(\"Quantity\", 0) INTO v_current_quantity \n                        FROM \"stock\" \n                        WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                        \n                        IF v_current_quantity = 0 THEN\n                            IF v_avg_per_shop > 10 THEN\n                                INSERT INTO \"stock\" (\"Shop_ID\", \"Device_ID\", \"Quantity\") \n                                VALUES (shop_rec.\"Shop_ID\", device_rec.\"Device_ID\", v_avg_per_shop);\n                            ELSIF v_avg_per_shop > 5 THEN\n                                INSERT INTO \"stock\" (\"Shop_ID\", \"Device_ID\", \"Quantity\") \n                                VALUES (shop_rec.\"Shop_ID\", device_rec.\"Device_ID\", 5);\n                            ELSE\n                                INSERT INTO \"stock\" (\"Shop_ID\", \"Device_ID\", \"Quantity\") \n                                VALUES (shop_rec.\"Shop_ID\", device_rec.\"Device_ID\", 1);\n                            END IF;\n                        ELSIF v_current_quantity < v_avg_per_shop THEN\n                            IF v_avg_per_shop - v_current_quantity > 20 THEN\n                                UPDATE \"stock\" \n                                SET \"Quantity\" = \"Quantity\" + 20 \n                                WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                            ELSE\n                                UPDATE \"stock\" \n                                SET \"Quantity\" = v_avg_per_shop \n                                WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                            END IF;\n                        ELSIF v_current_quantity > v_avg_per_shop * 2 THEN\n                            DELETE FROM \"stock\" \n                            WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                        END IF;\n                    END LOOP;\n                END IF;\n            END LOOP;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL redistribute_inventory_by_platform();"
    ],
    "summary": "Create a stored procedure named redistribute_inventory_by_platform to balance device stock across shops per software platform. For each platform, calculate the average quantity per shop for each device. For each shop, if it doesn't stock the device, insert stock based on the average (with minimum thresholds). If its stock is below average, top it up (with a cap). If its stock is more than double the average, remove it from that shop.",
    "natural_language": "Create a stored procedure to sort of even out the inventory for devices across different stores, focusing on their software types. For each platform, figure out roughly how many of each device there usually is per shop. For a given store, if it doesn't have a particular device at all, maybe add some stock based on that typical amount, but make sure it's not too little. If a shop has less than what's typical, bring its stock up a bit, but don't go overboard. If a shop has way more than twice the usual amount, consider taking the extra away from there.",
    "id": 182
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named balance_device_availability that takes no parameters and begins by declaring variables: device_rec and shop_rec as RECORD types to hold row data, v_total_shops and v_stocked_shops as INTEGER for shop counts, v_max_stock as INTEGER for a maximum quantity value, and v_current_quantity and v_target_quantity as INTEGER for stock calculations. The procedure first calculates the total number of shops by performing a SELECT COUNT(*) from the \"shop\" table, storing the result in v_total_shops. It then enters a loop that iterates over each device record from a query that selects the \"Device_ID\", \"Device\", and \"Carrier\" columns from the \"device\" table, and uses a LEFT JOIN with the \"stock\" table on matching \"Device_ID\" columns, applying a window function last_value(s.\"Quantity\") OVER (PARTITION BY d.\"Device_ID\" ORDER BY s.\"Quantity\" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) to derive an alias max_quantity representing the highest stock quantity for that device across all shops. For each device record in this loop, it calculates the number of distinct shops stocking that device by selecting COUNT(DISTINCT \"Shop_ID\") from the \"stock\" table where \"Device_ID\" equals the current device_rec.\"Device_ID\", storing the result in v_stocked_shops, and sets v_max_stock to the COALESCE value of device_rec.max_quantity (or 0 if null). The core logic uses v_stocked_shops compared to v_total_shops: if v_stocked_shops is less than half of v_total_shops (v_total_shops / 2), it enters a nested loop over all shop IDs from the \"shop\" table. For each shop, it retrieves the current stock quantity for the specific device and shop by selecting COALESCE(\"Quantity\", 0) from the \"stock\" table where \"Shop_ID\" equals shop_rec.\"Shop_ID\" and \"Device_ID\" equals device_rec.\"Device_ID\", storing it in v_current_quantity. If v_current_quantity is zero, it determines a v_target_quantity based on v_max_stock: if v_max_stock is greater than 100, v_target_quantity is 30; else if greater than 50, it is 15; else if greater than 20, it is 8; otherwise, it is 3, and then performs an INSERT into the \"stock\" table with columns \"Shop_ID\", \"Device_ID\", and \"Quantity\" set to the current shop_rec.\"Shop_ID\", device_rec.\"Device_ID\", and v_target_quantity. If v_current_quantity is not zero but is less than one-third of v_max_stock (v_max_stock / 3), it performs an UPDATE on the \"stock\" table, increasing the \"Quantity\" by a fraction of v_max_stock based on the device's carrier: if device_rec.\"Carrier\" is 'Verizon Wireless', it adds v_max_stock divided by 4; else if it is 'MTS Mobility', it adds v_max_stock divided by 6; for any other carrier, it adds v_max_stock divided by 8, and the update applies where \"Shop_ID\" equals shop_rec.\"Shop_ID\" and \"Device_ID\" equals device_rec.\"Device_ID\". Alternatively, if v_stocked_shops is greater than 80 percent of v_total_shops (v_total_shops * 0.8), it enters a different nested loop over all shop IDs. For each shop, it again retrieves v_current_quantity from the \"stock\" table for the specific device and shop. If v_current_quantity is greater than twice v_max_stock (v_max_stock * 2), it executes a DELETE from the \"stock\" table where \"Shop_ID\" equals shop_rec.\"Shop_ID\" and \"Device_ID\" equals device_rec.\"Device_ID\". If v_current_quantity is greater than v_max_stock but not greater than twice v_max_stock, it performs an UPDATE on the \"stock\" table, setting the \"Quantity\" column to exactly v_max_stock for the matching shop and device record. The procedure continues these loops until all devices and relevant shops are processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE balance_device_availability()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    device_rec RECORD;\n    shop_rec RECORD;\n    v_total_shops INTEGER;\n    v_stocked_shops INTEGER;\n    v_max_stock INTEGER;\n    v_current_quantity INTEGER;\n    v_target_quantity INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_shops FROM \"shop\";\n    \n    FOR device_rec IN \n        SELECT d.\"Device_ID\", d.\"Device\", d.\"Carrier\",\n               last_value(s.\"Quantity\") OVER (PARTITION BY d.\"Device_ID\" ORDER BY s.\"Quantity\" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as max_quantity\n        FROM \"device\" d \n        LEFT JOIN \"stock\" s ON d.\"Device_ID\" = s.\"Device_ID\"\n    LOOP\n        SELECT COUNT(DISTINCT \"Shop_ID\") INTO v_stocked_shops \n        FROM \"stock\" \n        WHERE \"Device_ID\" = device_rec.\"Device_ID\";\n        \n        v_max_stock := COALESCE(device_rec.max_quantity, 0);\n        \n        IF v_stocked_shops < v_total_shops / 2 THEN\n            FOR shop_rec IN SELECT \"Shop_ID\" FROM \"shop\" LOOP\n                SELECT COALESCE(\"Quantity\", 0) INTO v_current_quantity \n                FROM \"stock\" \n                WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                \n                IF v_current_quantity = 0 THEN\n                    IF v_max_stock > 100 THEN\n                        v_target_quantity := 30;\n                    ELSIF v_max_stock > 50 THEN\n                        v_target_quantity := 15;\n                    ELSIF v_max_stock > 20 THEN\n                        v_target_quantity := 8;\n                    ELSE\n                        v_target_quantity := 3;\n                    END IF;\n                    \n                    INSERT INTO \"stock\" (\"Shop_ID\", \"Device_ID\", \"Quantity\") \n                    VALUES (shop_rec.\"Shop_ID\", device_rec.\"Device_ID\", v_target_quantity);\n                ELSIF v_current_quantity < v_max_stock / 3 THEN\n                    IF device_rec.\"Carrier\" = 'Verizon Wireless' THEN\n                        UPDATE \"stock\" \n                        SET \"Quantity\" = \"Quantity\" + (v_max_stock / 4) \n                        WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                    ELSIF device_rec.\"Carrier\" = 'MTS Mobility' THEN\n                        UPDATE \"stock\" \n                        SET \"Quantity\" = \"Quantity\" + (v_max_stock / 6) \n                        WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                    ELSE\n                        UPDATE \"stock\" \n                        SET \"Quantity\" = \"Quantity\" + (v_max_stock / 8) \n                        WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                    END IF;\n                END IF;\n            END LOOP;\n        ELSIF v_stocked_shops > v_total_shops * 0.8 THEN\n            FOR shop_rec IN SELECT \"Shop_ID\" FROM \"shop\" LOOP\n                SELECT COALESCE(\"Quantity\", 0) INTO v_current_quantity \n                FROM \"stock\" \n                WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                \n                IF v_current_quantity > v_max_stock * 2 THEN\n                    DELETE FROM \"stock\" \n                    WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                ELSIF v_current_quantity > v_max_stock THEN\n                    UPDATE \"stock\" \n                    SET \"Quantity\" = v_max_stock \n                    WHERE \"Shop_ID\" = shop_rec.\"Shop_ID\" AND \"Device_ID\" = device_rec.\"Device_ID\";\n                END IF;\n            END LOOP;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL balance_device_availability();"
    ],
    "summary": "Create a stored procedure named balance_device_availability with no parameters. For each device, count how many shops stock it and find its maximum stock quantity. If fewer than half of all shops stock it, add stock to shops that have none, with a target quantity based on the max stock. For shops with low stock, increase it based on the device's carrier. If more than 80% of shops stock it, reduce overstock by deleting or capping quantities in shops that have too much.",
    "natural_language": "Create procedure balance_device_availability. For each device: count shops stocking it and find max stock. If under half of shops stock it, add stock to empty shops based on max. For low stock, increase per carrier. If over 80% stock it, reduce overstock by capping or deleting excess.",
    "id": 183
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_camera_lens_id of type integer, p_mountain_id of type integer, and p_color_factor of type real. The procedure begins by declaring a local variable v_color of type text. It then evaluates the value of p_color_factor using a conditional statement: if p_color_factor is greater than 0.5, it assigns the string 'RBG' to v_color; otherwise, it assigns the string 'Black/White' to v_color. Following this conditional logic, the procedure performs an insert operation into the photos table, specifically targeting the columns camera_lens_id, mountain_id, color, and name. The values inserted are p_camera_lens_id for the camera_lens_id column, p_mountain_id for the mountain_id column, the value of v_color for the color column, and the string 'New Photo' for the name column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_photo_with_calculated_color(p_camera_lens_id integer, p_mountain_id integer, p_color_factor real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_color text;\nBEGIN\n    IF p_color_factor > 0.5 THEN\n        v_color := 'RBG';\n    ELSE\n        v_color := 'Black/White';\n    END IF;\n    \n    INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n    VALUES (p_camera_lens_id, p_mountain_id, v_color, 'New Photo');\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL insert_photo_with_calculated_color(1, 1, 0.7);",
      "CALL insert_photo_with_calculated_color(2, 2, 0.3);",
      "CALL insert_photo_with_calculated_color(3, 3, 0.9);",
      "CALL insert_photo_with_calculated_color(1, 2, 0.1);",
      "CALL insert_photo_with_calculated_color(2, 1, 0.6);"
    ],
    "summary": "Create a stored procedure that takes a camera_lens_id (integer), a mountain_id (integer), and a color_factor (real). Determine the color as 'RGB' if color_factor > 0.5, otherwise 'Black/White'. Insert a new photo with these IDs, the determined color, and the name 'New Photo'.",
    "natural_language": "Please construct a stored procedure that accepts three input parameters: an integer designated as camera_lens_id, an integer designated as mountain_id, and a real number designated as color_factor. The procedure shall evaluate the color_factor; if its value exceeds 0.5, the color shall be determined as 'RGB'. Otherwise, the color shall be determined as 'Black/White'. Subsequently, the procedure must execute an insertion into the photo table, incorporating the provided identifiers, the determined color value, and a static name of 'New Photo'.",
    "id": 184
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_mountain_prominence` that accepts three input parameters: `p_mountain_id` of type `integer`, `p_height` of type `real`, and `p_angle_factor` of type `real`. The purpose of this procedure is to calculate a new prominence value for a specific mountain and then update that mountain's record in the `mountain` table.\n\nThe procedure begins by declaring a local variable `v_new_prominence` of type `real`. It then calculates the value for `v_new_prominence` using the formula `p_height * asin(p_angle_factor / p_height)`. This calculation involves multiplying the input parameter `p_height` by the arc sine (inverse sine) of the result of dividing the input parameter `p_angle_factor` by the input parameter `p_height`. The `asin` function is a standard mathematical function that returns the arc sine of its argument.\n\nAfter calculating `v_new_prominence`, the procedure executes an `UPDATE` statement on the `mountain` table. This `UPDATE` statement sets the value of the column named `\"Prominence\"` to the newly calculated `v_new_prominence`. The update is applied only to the row in the `mountain` table where the `id` column matches the value provided by the input parameter `p_mountain_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_mountain_prominence(p_mountain_id integer, p_height real, p_angle_factor real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_prominence real;\nBEGIN\n    v_new_prominence := p_height * asin(p_angle_factor / p_height);\n    \n    UPDATE mountain \n    SET \"Prominence\" = v_new_prominence\n    WHERE id = p_mountain_id;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL update_mountain_prominence(1, 4260.0, 2000.0);",
      "CALL update_mountain_prominence(2, 4220.0, 300.0);",
      "CALL update_mountain_prominence(3, 4195.0, 1500.0);",
      "CALL update_mountain_prominence(1, 4300.0, 2100.0);",
      "CALL update_mountain_prominence(2, 4200.0, 320.0);"
    ],
    "summary": "Create a stored procedure named update_mountain_prominence that accepts a mountain_id (integer), a height (real), and an angle_factor (real). Calculate a new prominence value as height * asin(angle_factor / height). Update the mountain's Prominence column with this calculated value for the specified mountain_id.",
    "natural_language": "Please construct a stored procedure designated as 'update_mountain_prominence'. This procedure is to accept three input parameters: a mountain identifier of integer type, a height value of real type, and an angle factor of real type. The procedure must compute a new prominence metric by multiplying the height parameter by the arcsine of the quotient obtained from dividing the angle factor by the height. Subsequently, it should execute an update to the 'Prominence' column within the relevant database table, assigning the newly calculated value to the record corresponding to the provided mountain identifier.",
    "id": 185
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named insert_camera_lens_with_calculated_aperture that accepts three input parameters: p_brand of type text to represent the lens manufacturer, p_name of type text to represent the lens model name, and p_focal_length_mm of type real to represent the focal length in millimeters. The procedure declares a local variable v_max_aperture of type real. It calculates the value for v_max_aperture by applying the mathematical arcsine function (asin) to the result of dividing the input focal length p_focal_length_mm by 100. The procedure then performs an INSERT operation into a table named camera_lens, which contains columns brand, name, focal_length_mm, and max_aperture. The inserted values are the input parameter p_brand for the brand column, the input parameter p_name for the name column, the input parameter p_focal_length_mm for the focal_length_mm column, and the calculated local variable v_max_aperture for the max_aperture column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_camera_lens_with_calculated_aperture(p_brand text, p_name text, p_focal_length_mm real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_max_aperture real;\nBEGIN\n    v_max_aperture := asin(p_focal_length_mm / 100);\n    \n    INSERT INTO camera_lens (brand, name, focal_length_mm, max_aperture)\n    VALUES (p_brand, p_name, p_focal_length_mm, v_max_aperture);\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL insert_camera_lens_with_calculated_aperture('Canon', 'EF 50mm f/1.8 STM', 50.0);",
      "CALL insert_camera_lens_with_calculated_aperture('Nikon', 'Nikkor Z 24-70mm f/2.8 S', 70.0);",
      "CALL insert_camera_lens_with_calculated_aperture('Sony', 'FE 85mm f/1.8', 85.0);",
      "CALL insert_camera_lens_with_calculated_aperture('Olympus', 'M.Zuiko Digital ED 12-40mm f/2.8 PRO', 40.0);",
      "CALL insert_camera_lens_with_calculated_aperture('Sigma', 'Art 35mm f/1.4 DG HSM', 35.0);"
    ],
    "summary": "Create a stored procedure named insert_camera_lens_with_calculated_aperture that inserts a new row into the camera_lens table. The procedure accepts lens brand, model name, and focal length as input parameters. It calculates the max_aperture by applying the arcsine function to the focal length divided by 100, then inserts all values into their corresponding columns.",
    "natural_language": "Hey, can you whip up a stored procedure called insert_camera_lens_with_calculated_aperture? It's gotta pop a new entry into the camera_lens table. We'll feed it the lens brand, model name, and focal length. The trick is, it needs to figure out the max_aperture on the fly by doing this math: take the focal length, divide it by 100, and then get the arcsine of that result. Once that's done, just shove all the values into their right spots in the table.",
    "id": 186
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `delete_photos_by_lens_and_mountain` that accepts three input parameters: `p_camera_lens_id` of type `integer`, `p_mountain_id` of type `integer`, and `p_color` of type `text`. The purpose of this procedure is to remove records from the `photos` table. Specifically, it performs a `DELETE` operation on the `photos` table, targeting rows where the value in the `camera_lens_id` column exactly matches the value provided in the `p_camera_lens_id` parameter, AND the value in the `mountain_id` column exactly matches the value provided in the `p_mountain_id` parameter, AND the value in the `color` column exactly matches the value provided in the `p_color` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_photos_by_lens_and_mountain(p_camera_lens_id integer, p_mountain_id integer, p_color text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM photos\n    WHERE camera_lens_id = p_camera_lens_id AND mountain_id = p_mountain_id AND color = p_color;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL delete_photos_by_lens_and_mountain(1, 20, 'RBG');",
      "CALL delete_photos_by_lens_and_mountain(10, 2, 'Black/White');",
      "CALL delete_photos_by_lens_and_mountain(1, 1, 'RBG');",
      "CALL delete_photos_by_lens_and_mountain(10, 20, 'Black/White');",
      "CALL delete_photos_by_lens_and_mountain(1, 2, 'RBG');"
    ],
    "summary": "Create a stored procedure named delete_photos_by_lens_and_mountain that deletes rows from the photos table. The procedure accepts camera lens ID, mountain ID, and color as input parameters. It deletes rows where all three column values exactly match the provided parameters.",
    "natural_language": "Create a stored procedure to delete some photos from the photos table. The procedure should take a camera lens, a mountain, and a general color as inputs. It should remove those photo entries that seem to match the given lens and mountain pretty closely and are of a roughly similar color.",
    "id": 187
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `proc_merge_staff_assignments` that accepts five input parameters: `p_old_staff_id` of type `bigint`, representing the identifier of the staff member whose assignments are to be merged; `p_new_staff_id` of type `bigint`, representing the identifier of the staff member to whom the assignments will be merged; `p_merge_date` of type `timestamp with time zone`, indicating the effective start date for the merged assignments; `p_default_job_title` of type `text`, providing a default job title code to use if an existing assignment lacks one; and `p_department_filter` of type `bigint`, an optional parameter used to restrict the merge operation to a specific department.\n\nThe procedure begins by declaring a local variable `v_assignment_count` of type `integer` to store the number of rows affected by an `INSERT` operation.\n\nThe core logic is encapsulated within a conditional block. This block first checks three conditions:\n1.  Whether a staff member with `staff_id` equal to `p_new_staff_id` exists in the `\"Staff\"` table.\n2.  Whether a staff member with `staff_id` equal to `p_old_staff_id` exists in the `\"Staff\"` table.\n3.  Whether `p_old_staff_id` is distinct from `p_new_staff_id`.\nAll three conditions must evaluate to true for the subsequent operations to proceed.\n\nIf all conditions are met, the procedure then performs an `INSERT` operation into the `\"Staff_Department_Assignments\"` table. This `INSERT` statement selects data from existing assignments of the `p_old_staff_id` and attempts to insert them as new assignments for `p_new_staff_id`. Specifically, it selects `p_new_staff_id` for the `staff_id` column, `sda.department_id` for the `department_id` column, `p_merge_date` for the `date_assigned_from` column, `COALESCE(sda.job_title_code, p_default_job_title)` for the `job_title_code` column (which means it uses the existing `job_title_code` from `sda` if it's not `NULL`, otherwise it uses `p_default_job_title`), and `sda.date_assigned_to` for the `date_assigned_to` column. The source data for this `INSERT` is derived from rows in `\"Staff_Department_Assignments\"` (aliased as `sda`) where `sda.staff_id` matches `p_old_staff_id`. An additional filter is applied: if `p_department_filter` is `NULL`, all assignments for `p_old_staff_id` are considered; otherwise, only assignments where `sda.department_id` matches `p_department_filter` are considered.\n\nThis `INSERT` statement includes an `ON CONFLICT (staff_id, department_id) DO UPDATE SET` clause. This means if an attempt to insert a new assignment for `p_new_staff_id` results in a unique constraint violation on the `(staff_id, department_id)` pair (i.e., an assignment for `p_new_staff_id` to that specific department already exists), an update operation is performed instead of an insert. The update logic is as follows:\n*   The `date_assigned_from` column is set to the `LEAST` (earliest) of the `date_assigned_from` value from the row being inserted (`EXCLUDED.date_assigned_from`) and the `date_assigned_from` value of the existing row in `\"Staff_Department_Assignments\"`.\n*   The `job_title_code` column is set to `COALESCE(EXCLUDED.job_title_code, \"Staff_Department_Assignments\".job_title_code)`. This means if the `job_title_code` from the row being inserted (`EXCLUDED.job_title_code`) is not `NULL`, it is used; otherwise, the existing `job_title_code` in `\"Staff_Department_Assignments\"` is retained.\n*   The `date_assigned_to` column is set to the `GREATEST` (latest) of the `date_assigned_to` value from the row being inserted (`EXCLUDED.date_assigned_to`) and the `date_assigned_to` value of the existing row in `\"Staff_Department_Assignments\"`.\n\nAfter the `INSERT...ON CONFLICT` operation, the procedure uses `GET DIAGNOSTICS v_assignment_count = ROW_COUNT;` to retrieve the total number of rows inserted or updated by the preceding statement and stores this count in the `v_assignment_count` variable.\n\nFollowing this, another conditional block checks if `v_assignment_count` is greater than 0. If it is, indicating that at least one assignment was successfully merged (either inserted or updated), a `DELETE` operation is performed on the `\"Staff_Department_Assignments\"` table. This `DELETE` targets rows where `staff_id` matches `p_old_staff_id`. Similar to the `INSERT` statement, an optional filter is applied: if `p_department_filter` is `NULL`, all assignments for `p_old_staff_id` are deleted; otherwise, only assignments where `department_id` matches `p_department_filter` are deleted.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_merge_staff_assignments(\n    p_old_staff_id bigint,\n    p_new_staff_id bigint,\n    p_merge_date timestamp with time zone,\n    p_default_job_title text,\n    p_department_filter bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_assignment_count integer;\nBEGIN\n    -- Check if both staff IDs exist and are different\n    IF EXISTS (SELECT 1 FROM \"Staff\" WHERE staff_id = p_new_staff_id) \n       AND EXISTS (SELECT 1 FROM \"Staff\" WHERE staff_id = p_old_staff_id) \n       AND p_old_staff_id <> p_new_staff_id THEN\n        \n        -- Insert merged assignments for the new staff member with conflict handling\n        INSERT INTO \"Staff_Department_Assignments\" (staff_id, department_id, date_assigned_from, job_title_code, date_assigned_to)\n        SELECT p_new_staff_id, sda.department_id, p_merge_date, COALESCE(sda.job_title_code, p_default_job_title), sda.date_assigned_to\n        FROM \"Staff_Department_Assignments\" sda\n        WHERE sda.staff_id = p_old_staff_id\n        AND (p_department_filter IS NULL OR sda.department_id = p_department_filter)\n        ON CONFLICT (staff_id, department_id) \n        DO UPDATE SET\n            date_assigned_from = LEAST(EXCLUDED.date_assigned_from, \"Staff_Department_Assignments\".date_assigned_from),\n            job_title_code = COALESCE(EXCLUDED.job_title_code, \"Staff_Department_Assignments\".job_title_code),\n            date_assigned_to = GREATEST(EXCLUDED.date_assigned_to, \"Staff_Department_Assignments\".date_assigned_to);\n        \n        GET DIAGNOSTICS v_assignment_count = ROW_COUNT;\n        \n        -- Delete old assignments only if they were successfully merged\n        IF v_assignment_count > 0 THEN\n            DELETE FROM \"Staff_Department_Assignments\"\n            WHERE staff_id = p_old_staff_id\n            AND (p_department_filter IS NULL OR department_id = p_department_filter);\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "department_store",
    "tables": [
      "Staff",
      "Staff_Department_Assignments"
    ],
    "call_sqls": [
      "CALL proc_merge_staff_assignments(1, 2, '2023-01-01 00:00:00+00', 'Senior Staff', NULL);",
      "CALL proc_merge_staff_assignments(5, 10, '2022-06-15 10:30:00+00', 'Team Lead', 4);",
      "CALL proc_merge_staff_assignments(1, 5, '2023-03-01 09:00:00+00', 'Project Coordinator', 5);",
      "CALL proc_merge_staff_assignments(10, 1, '2023-07-20 14:00:00+00', 'Manager', NULL);",
      "CALL proc_merge_staff_assignments(2, 3, '2023-09-01 11:00:00+00', 'Analyst', 4);"
    ],
    "summary": "Create a stored procedure named proc_merge_staff_assignments that merges department assignments from an old staff member to a new one. It validates that both staff IDs exist and are different. For each of the old staff's assignments (optionally filtered by department), it inserts or updates an assignment for the new staff using a default job title if needed and adjusting date ranges. If the merge is successful, it deletes the old staff's assignments. The procedure returns the count of merged assignments.",
    "natural_language": "Create a stored procedure called proc_merge_staff_assignments that handles moving work assignments from one person to another. It should check that both staff members are real and aren't the same person. For the assignments the old staff member hasâ€”maybe just from certain departments you're thinking ofâ€”it sets up similar assignments for the new person, using a standard job title if one isn't clear and sorting out the dates. If everything goes through okay, it gets rid of the old assignments. In the end, it tells you roughly how many assignments were moved over.",
    "id": 188
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_championship_records` that does not accept any parameters. The procedure begins by declaring a record variable named `champ_rec` to hold the data fetched during iteration. It then initiates a loop that iterates over each row retrieved from the `Championship` table. For each row, it selects the values from the `\"Institution_ID\"` and `\"Number_of_Championships\"` columns into the `champ_rec` record.\n\nInside the loop, a series of conditional statements (IF-ELSIF-ELSE) are executed based on the value of `champ_rec.\"Number_of_Championships\"`. The comparisons use the `ABS()` function to check if the difference between `champ_rec.\"Number_of_Championships\"` and a specific floating-point value is less than `0.001`, effectively checking for approximate equality to integer values.\n\n1.  **First Condition:** If the absolute difference between `champ_rec.\"Number_of_Championships\"` and `0.0` is less than `0.001` (i.e., `Number_of_Championships` is approximately `0`), the procedure executes a `DELETE` statement. This statement removes rows from the `\"Championship\"` table where the `\"Institution_ID\"` column matches the value of `champ_rec.\"Institution_ID\"`.\n\n2.  **Second Condition:** Else if the absolute difference between `champ_rec.\"Number_of_Championships\"` and `1.0` is less than `0.001` (i.e., `Number_of_Championships` is approximately `1`), the procedure executes an `UPDATE` statement. This statement modifies the `\"institution\"` table by incrementing the value in the `\"Enrollment\"` column by `1000`. This update is applied to the row where the `\"Institution_ID\"` column matches the value of `champ_rec.\"Institution_ID\"`.\n\n3.  **Third Condition:** Else if the absolute difference between `champ_rec.\"Number_of_Championships\"` and `2.0` is less than `0.001` (i.e., `Number_of_Championships` is approximately `2`), the procedure executes an `INSERT` statement. This statement adds a new row into the `\"Championship\"` table. The values inserted are: `champ_rec.\"Institution_ID\" + 10` for `\"Institution_ID\"`, `'Newcomers'` for `\"Nickname\"`, `2025.0` for `\"Joined\"`, and `0.0` for `\"Number_of_Championships\"`.\n\n4.  **Fourth Condition:** Else if the absolute difference between `champ_rec.\"Number_of_Championships\"` and `3.0` is less than `0.001` (i.e., `Number_of_Championships` is approximately `3`), the procedure executes a `DELETE` statement. This statement removes rows from the `\"institution\"` table where the `\"Institution_ID\"` column matches the value of `champ_rec.\"Institution_ID\"`.\n\n5.  **Fifth Condition:** Else if the absolute difference between `champ_rec.\"Number_of_Championships\"` and `4.0` is less than `0.001` (i.e., `Number_of_Championships` is approximately `4`), the procedure executes an `UPDATE` statement. This statement modifies the `\"Championship\"` table by setting the value of the `\"Nickname\"` column to `'Champions'`. This update is applied to the row where the `\"Institution_ID\"` column matches the value of `champ_rec.\"Institution_ID\"`.\n\n6.  **Sixth Condition:** Else if the absolute difference between `champ_rec.\"Number_of_Championships\"` and `5.0` is less than `0.001` (i.e., `Number_of_Championships` is approximately `5`), the procedure executes an `INSERT` statement. This statement adds a new row into the `\"institution\"` table. The values inserted are: `champ_rec.\"Institution_ID\" + 20` for `\"Institution_ID\"`, `'New University'` for `\"Name\"`, `'New Team'` for `\"Team\"`, `'New City'` for `\"City\"`, `'NP'` for `\"Province\"`, `2025.0` for `\"Founded\"`, `'Private'` for `\"Affiliation\"`, `5000.0` for `\"Enrollment\"`, `'$100M'` for `\"Endowment\"`, `'New Stadium'` for `\"Stadium\"`, and `10000.0` for `\"Capacity\"`.\n\n7.  **Else Condition:** If none of the preceding conditions are met, the procedure executes an `UPDATE` statement. This statement modifies the `\"Championship\"` table by setting the value of the `\"Joined\"` column to `2025.0`. This update is applied to the row where the `\"Institution_ID\"` column matches the value of `champ_rec.\"Institution_ID\"`.\n\nAfter the loop completes, the procedure includes an exception handling block.\n1.  **`undefined_table` Exception:** If an `undefined_table` error occurs (e.g., if one of the referenced tables like `\"Championship\"` or `\"institution\"` does not exist), a notice message `'Table not found. Check table names and schema.'` is raised.\n2.  **`OTHERS` Exception:** For any other type of error, a notice message `'An error occurred: %'` is raised, where `%` is replaced by the specific error message obtained from `SQLERRM`.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_championship_records()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    champ_rec RECORD;\nBEGIN\n    FOR champ_rec IN SELECT \"Institution_ID\", \"Number_of_Championships\" FROM \"Championship\" LOOP\n        IF ABS(champ_rec.\"Number_of_Championships\" - 0.0) < 0.001 THEN\n            DELETE FROM \"Championship\" WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF ABS(champ_rec.\"Number_of_Championships\" - 1.0) < 0.001 THEN\n            UPDATE \"institution\" SET \"Enrollment\" = \"Enrollment\" + 1000 WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF ABS(champ_rec.\"Number_of_Championships\" - 2.0) < 0.001 THEN\n            INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") \n            VALUES (champ_rec.\"Institution_ID\" + 10, 'Newcomers', 2025.0, 0.0);\n        ELSIF ABS(champ_rec.\"Number_of_Championships\" - 3.0) < 0.001 THEN\n            DELETE FROM \"institution\" WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF ABS(champ_rec.\"Number_of_Championships\" - 4.0) < 0.001 THEN\n            UPDATE \"Championship\" SET \"Nickname\" = 'Champions' WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF ABS(champ_rec.\"Number_of_Championships\" - 5.0) < 0.001 THEN\n            INSERT INTO \"institution\" (\"Institution_ID\", \"Name\", \"Team\", \"City\", \"Province\", \"Founded\", \"Affiliation\", \"Enrollment\", \"Endowment\", \"Stadium\", \"Capacity\") \n            VALUES (champ_rec.\"Institution_ID\" + 20, 'New University', 'New Team', 'New City', 'NP', 2025.0, 'Private', 5000.0, '$100M', 'New Stadium', 10000.0);\n        ELSE\n            UPDATE \"Championship\" SET \"Joined\" = 2025.0 WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        END IF;\n    END LOOP;\nEXCEPTION\n    WHEN undefined_table THEN\n        RAISE NOTICE 'Table not found. Check table names and schema.';\n    WHEN OTHERS THEN\n        RAISE NOTICE 'An error occurred: %', SQLERRM;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL update_championship_records();"
    ],
    "summary": "Create a parameterless stored procedure named update_championship_records that loops through the Championship table. For each record, it performs different database operations (DELETE, UPDATE, or INSERT on either the Championship or institution table) based on the approximate integer value of the Number_of_Championships field. Handle exceptions for missing tables and other errors.",
    "natural_language": "Construct a stored procedure without parameters, to be named update_championship_records, which meticulously iterates through every single record within the Championship table. For each individual row encountered during this comprehensive loop, the procedure will intelligently determine and execute a distinct database operationâ€”specifically, either a DELETE, an UPDATE, or an INSERT action, targeting either the Championship table itself or the related institution table. This critical decision is based precisely on the approximate integer value derived from the record's Number_of_Championships field. Furthermore, the procedure must robustly handle any potential exceptions, including those arising from missing database tables or various other operational errors, to ensure graceful and reliable execution.",
    "id": 189
  },
  {
    "ir": "Write a PLpgSQL stored procedure named adjust_championship_data that iterates over each record in the Championship table, selecting the Institution_ID and Joined columns. For each record, it performs different operations based on the value of the Joined column: if Joined is less than 1990.0, it deletes the corresponding row from the Championship table using the Institution_ID; if Joined is between 1990.0 and 1999.9, it updates the Founded column in the institution table to 1900.0 for the matching Institution_ID; if Joined is between 2000.0 and 2009.9, it inserts a new row into the Championship table with Institution_ID incremented by 50, Nickname set to 'Legends', Joined set to 2025.0, and Number_of_Championships set to 2.0; if Joined is between 2010.0 and 2019.9, it deletes the corresponding row from the institution table using the Institution_ID; if Joined is between 2020.0 and 2024.9, it updates the Number_of_Championships column in the Championship table to 3.0 for the matching Institution_ID; if Joined equals 2025.0, it inserts a new row into the institution table with Institution_ID incremented by 60, Name set to 'Future University', Team set to 'Future Team', City set to 'Future City', Province set to 'FP', Founded set to 2025.0, Affiliation set to 'Private', Enrollment set to 20000.0, Endowment set to '$300M', Stadium set to 'Future Stadium', and Capacity set to 30000.0; otherwise, it updates the Nickname column in the Championship table to 'Pioneers' for the matching Institution_ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_championship_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    champ_rec RECORD;\nBEGIN\n    FOR champ_rec IN SELECT \"Institution_ID\", \"Joined\" FROM \"Championship\" LOOP\n        IF champ_rec.\"Joined\" < 1990.0 THEN\n            DELETE FROM \"Championship\" WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Joined\" < 2000.0 THEN\n            UPDATE institution SET \"Founded\" = 1900.0 WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Joined\" < 2010.0 THEN\n            INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (champ_rec.\"Institution_ID\" + 50, 'Legends', 2025.0, 2.0);\n        ELSIF champ_rec.\"Joined\" < 2020.0 THEN\n            DELETE FROM institution WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Joined\" < 2025.0 THEN\n            UPDATE \"Championship\" SET \"Number_of_Championships\" = 3.0 WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Joined\" = 2025.0 THEN\n            INSERT INTO institution (\"Institution_ID\", \"Name\", \"Team\", \"City\", \"Province\", \"Founded\", \"Affiliation\", \"Enrollment\", \"Endowment\", \"Stadium\", \"Capacity\") VALUES (champ_rec.\"Institution_ID\" + 60, 'Future University', 'Future Team', 'Future City', 'FP', 2025.0, 'Private', 20000.0, '$300M', 'Future Stadium', 30000.0);\n        ELSE\n            UPDATE \"Championship\" SET \"Nickname\" = 'Pioneers' WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL adjust_championship_data();"
    ],
    "summary": "Create a stored procedure named adjust_championship_data that loops through the Championship table. For each record, it performs different database operations (DELETE, UPDATE, or INSERT on either the Championship or institution table) based on the value range of the Joined field.",
    "natural_language": "Create a stored procedure called adjust_championship_data that goes through the Championship table. For each row, it should do different things to the databaseâ€”like removing, changing, or adding records to either the Championship or institution tableâ€”depending roughly on what the Joined field looks like.",
    "id": 190
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named modify_institution_data that takes no parameters and processes every row from the institution table by iterating through a cursor that selects the Institution_ID and Founded columns for each record. For each fetched record, the procedure executes conditional logic based on the value of the Founded column: if Founded is less than 1900.0, it deletes the corresponding row from the institution table where the Institution_ID matches the current record's Institution_ID; else if Founded is less than 1950.0, it updates the Championship table by setting the Joined column to 2000.0 for all rows where the Institution_ID matches the current record's Institution_ID; else if Founded is less than 2000.0, it inserts a new row into the Championship table with values for Institution_ID (calculated as the current Institution_ID plus 70), Nickname set to 'Veterans', Joined set to 2025.0, and Number_of_Championships set to 4.0; else if Founded is less than 2010.0, it deletes rows from the Championship table where the Institution_ID matches the current record's Institution_ID; else if Founded is less than 2020.0, it updates the institution table by setting the Enrollment column to 25000.0 for the row where Institution_ID matches the current record's Institution_ID; else if Founded equals exactly 2025.0, it inserts a new row into the institution table with values for Institution_ID (calculated as the current Institution_ID plus 80), Name set to 'Historic University', Team set to 'Historic Team', City set to 'Historic City', Province set to 'HP', Founded set to 2025.0, Affiliation set to 'Public', Enrollment set to 30000.0, Endowment set to '$400M', Stadium set to 'Historic Stadium', and Capacity set to 40000.0; for all other cases (the ELSE condition), it updates the Championship table by setting the Nickname column to 'Innovators' for rows where the Institution_ID matches the current record's Institution_ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE modify_institution_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    inst_rec RECORD;\nBEGIN\n    FOR inst_rec IN SELECT \"Institution_ID\", \"Founded\" FROM institution LOOP\n        IF inst_rec.\"Founded\" < 1900.0 THEN\n            DELETE FROM institution WHERE \"Institution_ID\" = inst_rec.\"Institution_ID\";\n        ELSIF inst_rec.\"Founded\" < 1950.0 THEN\n            UPDATE \"Championship\" SET \"Joined\" = 2000.0 WHERE \"Institution_ID\" = inst_rec.\"Institution_ID\";\n        ELSIF inst_rec.\"Founded\" < 2000.0 THEN\n            INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (inst_rec.\"Institution_ID\" + 70, 'Veterans', 2025.0, 4.0);\n        ELSIF inst_rec.\"Founded\" < 2010.0 THEN\n            DELETE FROM \"Championship\" WHERE \"Institution_ID\" = inst_rec.\"Institution_ID\";\n        ELSIF inst_rec.\"Founded\" < 2020.0 THEN\n            UPDATE institution SET \"Enrollment\" = 25000.0 WHERE \"Institution_ID\" = inst_rec.\"Institution_ID\";\n        ELSIF inst_rec.\"Founded\" = 2025.0 THEN\n            INSERT INTO institution (\"Institution_ID\", \"Name\", \"Team\", \"City\", \"Province\", \"Founded\", \"Affiliation\", \"Enrollment\", \"Endowment\", \"Stadium\", \"Capacity\") VALUES (inst_rec.\"Institution_ID\" + 80, 'Historic University', 'Historic Team', 'Historic City', 'HP', 2025.0, 'Public', 30000.0, '$400M', 'Historic Stadium', 40000.0);\n        ELSE\n            UPDATE \"Championship\" SET \"Nickname\" = 'Innovators' WHERE \"Institution_ID\" = inst_rec.\"Institution_ID\";\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL modify_institution_data();"
    ],
    "summary": "Create a stored procedure named modify_institution_data with no parameters. For each row in the institution table, process based on the Founded year: delete the institution if Founded < 1900; if Founded < 1950, update matching rows in the Championship table to set Joined = 2000; if Founded < 2000, insert a new row into Championship with Institution_ID + 70, Nickname 'Veterans', Joined 2025, and Number_of_Championships 4; if Founded < 2010, delete matching rows from Championship; if Founded < 2020, update the institution to set Enrollment = 25000; if Founded = 2025, insert a new institution with Institution_ID + 80 and predefined values; otherwise, update matching rows in Championship to set Nickname = 'Innovators'.",
    "natural_language": "Construct a stored procedure designated as 'modify_institution_data' that accepts no parameters. The procedure shall iterate through each record in the institution table. For each row, evaluate the value in the 'Founded' column and execute the following conditional logic: If the 'Founded' year is prior to 1900, delete the corresponding institution record. If the 'Founded' year is prior to 1950, update all matching entries in the Championship table by setting the 'Joined' field to 2000. If the 'Founded' year is prior to 2000, insert a new record into the Championship table with an 'Institution_ID' equal to the original value plus 70, a 'Nickname' of 'Veterans', a 'Joined' year of 2025, and a 'Number_of_Championships' value of 4. If the 'Founded' year is prior to 2010, delete any matching records from the Championship table. If the 'Founded' year is prior to 2020, update the current institution record to set its 'Enrollment' to 25000. If the 'Founded' year is exactly 2025, insert a new institution record with an 'Institution_ID' equal to the original value plus 80 and with other fields populated by predefined values. For all other cases, update matching rows in the Championship table to set the 'Nickname' field to 'Innovators'.",
    "id": 191
  },
  {
    "ir": "Write a PLpgSQL stored procedure named transform_championship_entries that iterates over each record in the Championship table, selecting the Institution_ID and Nickname columns. For each record, it performs conditional operations based on the Nickname value: if the Nickname is 'Colonials', it deletes the record from the Championship table where the Institution_ID matches; if the Nickname is 'Terrapins', it updates the institution table by setting the Team column to 'Updated Team' for the matching Institution_ID; if the Nickname is 'Wildcats', it inserts a new record into the Championship table with Institution_ID incremented by 90, Nickname set to 'Champions', Joined set to 2025.0, and Number_of_Championships set to 5.0; if the Nickname is 'Pioneers', it deletes the record from the institution table where the Institution_ID matches; if the Nickname is 'Innovators', it updates the Championship table by setting the Joined column to 2025.0 for the matching Institution_ID; if the Nickname is 'Legends', it inserts a new record into the institution table with Institution_ID incremented by 100, Name set to 'Legendary University', Team set to 'Legendary Team', City set to 'Legendary City', Province set to 'LP', Founded set to 2025.0, Affiliation set to 'Private', Enrollment set to 35000.0, Endowment set to '$500M', Stadium set to 'Legendary Stadium', and Capacity set to 50000.0; for any other Nickname, it updates the Championship table by setting the Number_of_Championships column to 6.0 for the matching Institution_ID. The procedure includes exception handling to raise a notice if a table is not found or if any other error occurs, displaying the error message.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_championship_entries()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    champ_rec RECORD;\nBEGIN\n    FOR champ_rec IN SELECT \"Institution_ID\", \"Nickname\" FROM \"Championship\" LOOP\n        IF champ_rec.\"Nickname\" = 'Colonials' THEN\n            DELETE FROM \"Championship\" WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Nickname\" = 'Terrapins' THEN\n            UPDATE \"institution\" SET \"Team\" = 'Updated Team' WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Nickname\" = 'Wildcats' THEN\n            INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (champ_rec.\"Institution_ID\" + 90, 'Champions', 2025.0, 5.0);\n        ELSIF champ_rec.\"Nickname\" = 'Pioneers' THEN\n            DELETE FROM \"institution\" WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Nickname\" = 'Innovators' THEN\n            UPDATE \"Championship\" SET \"Joined\" = 2025.0 WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        ELSIF champ_rec.\"Nickname\" = 'Legends' THEN\n            INSERT INTO \"institution\" (\"Institution_ID\", \"Name\", \"Team\", \"City\", \"Province\", \"Founded\", \"Affiliation\", \"Enrollment\", \"Endowment\", \"Stadium\", \"Capacity\") VALUES (champ_rec.\"Institution_ID\" + 100, 'Legendary University', 'Legendary Team', 'Legendary City', 'LP', 2025.0, 'Private', 35000.0, '$500M', 'Legendary Stadium', 50000.0);\n        ELSE\n            UPDATE \"Championship\" SET \"Number_of_Championships\" = 6.0 WHERE \"Institution_ID\" = champ_rec.\"Institution_ID\";\n        END IF;\n    END LOOP;\nEXCEPTION\n    WHEN undefined_table THEN\n        RAISE NOTICE 'Table not found. Check table names and schema.';\n    WHEN OTHERS THEN\n        RAISE NOTICE 'An error occurred: %', SQLERRM;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL transform_championship_entries();"
    ],
    "summary": "Create a stored procedure named transform_championship_entries. For each row in the Championship table, process based on the Nickname: if 'Colonials', delete the Championship row; if 'Terrapins', update the matching institution's Team to 'Updated Team'; if 'Wildcats', insert a new Championship row with Institution_ID + 90, Nickname 'Champions', Joined 2025, and Number_of_Championships 5; if 'Pioneers', delete the matching institution row; if 'Innovators', update the Championship row to set Joined = 2025; if 'Legends', insert a new institution with Institution_ID + 100 and predefined values; otherwise, update the Championship row to set Number_of_Championships = 6. Include exception handling to raise a notice for any errors.",
    "natural_language": "How can I create a stored procedure called transform_championship_entries that processes each row in the Championship table based on the Nickname? For rows with the Nickname 'Colonials', it should delete the Championship row. For 'Terrapins', it should update the matching institution's Team to 'Updated Team'. For 'Wildcats', it should insert a new Championship row using Institution_ID + 90, setting Nickname to 'Champions', Joined to 2025, and Number_of_Championships to 5. For 'Pioneers', it should delete the matching institution row. For 'Innovators', it should update the Championship row to set Joined to 2025. For 'Legends', it should insert a new institution with Institution_ID + 100 and predefined values. For any other Nickname, it should update the Championship row to set Number_of_Championships to 6. How do I also include exception handling to raise a notice for any errors?",
    "id": 192
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named insert_new_song that accepts two input parameters: a TEXT parameter named song_title and an INTEGER parameter named singer_id, and performs a single INSERT operation into the database table named song, specifically populating the columns \"Title\" with the value from the song_title parameter, \"Singer_ID\" with the value from the singer_id parameter, the \"Sales\" column with a literal integer value of 0, and the \"Highest_Position\" column with a NULL value.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_song(IN song_title TEXT, IN singer_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO song (\"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n    VALUES (song_title, singer_id, 0, NULL);\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL insert_new_song('My New Song 1', 1);",
      "CALL insert_new_song('Another Hit', 2);",
      "CALL insert_new_song('Summer Jam', 3);",
      "CALL insert_new_song('Winter Blues', 1);",
      "CALL insert_new_song('Rock Anthem', 2);"
    ],
    "summary": "Create a stored procedure named insert_new_song with parameters song_title (TEXT) and singer_id (INTEGER). Insert a row into the song table with the given Title and Singer_ID, set Sales to 0, and set Highest_Position to NULL.",
    "natural_language": "Write a stored procedure called insert_new_song that takes song_title as TEXT and singer_id as INTEGER. Have it insert a new record into the song table using the provided Title and Singer_ID, initialize Sales to 0, and set Highest_Position to NULL.",
    "id": 193
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `delete_low_sales_songs` that accepts two input parameters: `threshold`, which is of type `REAL`, representing a sales value used as a comparison point, and `singer_id`, which is of type `INTEGER`, representing the unique identifier of a singer. The procedure's sole operation is to perform a `DELETE` statement on the `song` table. This `DELETE` operation targets and removes rows from the `song` table where two conditions are simultaneously met: first, the value in the `\"Sales\"` column is strictly less than the value provided in the `threshold` input parameter, and second, the value in the `\"Singer_ID\"` column is exactly equal to the value provided in the `singer_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_low_sales_songs(IN threshold REAL, IN singer_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM song\n    WHERE \"Sales\" < threshold AND \"Singer_ID\" = singer_id;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL delete_low_sales_songs(100000.0, 1);",
      "CALL delete_low_sales_songs(500000.0, 2);",
      "CALL delete_low_sales_songs(200000.0, 1);",
      "CALL delete_low_sales_songs(700000.0, 2);",
      "CALL delete_low_sales_songs(300000.0, 1);"
    ],
    "summary": "Create a stored procedure named delete_low_sales_songs with parameters threshold (REAL) and singer_id (INTEGER). Delete rows from the song table where Sales is less than the threshold and Singer_ID equals the provided singer_id.",
    "natural_language": "Develop a stored procedure called delete_low_sales_songs, which must be configured to accept two distinct input parameters: a threshold value of type REAL and a singer identifier of type INTEGER. This procedure should meticulously remove all records from the song table where the Sales figure is definitively lower than the specified threshold value and, concurrently, where the Singer_ID column matches exactly the provided singer_id parameter.",
    "id": 194
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five parameters: p_cutoff_date of type timestamp with time zone, p_min_amount of type numeric, p_archive_prefix of type text, p_batch_size of type bigint, and p_retention_days of type integer. The procedure begins by declaring two local variables, v_count of type integer and v_archive_id of type bigint. It then performs a SELECT COUNT(*) operation to determine the number of rows in the \"Invoices\" table joined with the \"Invoice_Line_Items\" table where the invoice_date is earlier than p_cutoff_date and the derived_total_cost in \"Invoice_Line_Items\" exceeds p_min_amount, storing the result in v_count. If v_count is greater than zero, the procedure assigns v_archive_id the current timestamp in seconds since the epoch, cast to bigint. It then inserts new rows into the \"Invoices\" table, selecting invoice_number as v_archive_id plus a row number ordered by invoice_number, order_id, and the current timestamp as invoice_date from the \"Invoices\" table where invoice_date is less than p_cutoff_date, limiting the number of rows inserted to p_batch_size. Finally, it deletes rows from the \"Invoice_Line_Items\" table where the invoice_number exists in the \"Invoices\" table with an invoice_date older than the current timestamp minus the number of days specified by p_retention_days.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_invoice_data(\n    p_cutoff_date timestamp with time zone,\n    p_min_amount numeric,\n    p_archive_prefix text,\n    p_batch_size bigint,\n    p_retention_days integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count integer;\n    v_archive_id bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM \"Invoices\" i\n    JOIN \"Invoice_Line_Items\" ili ON i.invoice_number = ili.invoice_number\n    WHERE i.invoice_date < p_cutoff_date\n    AND ili.derived_total_cost > p_min_amount;\n    \n    IF v_count > 0 THEN\n        v_archive_id := EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::bigint;\n        \n        INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date)\n        SELECT \n            v_archive_id + ROW_NUMBER() OVER (ORDER BY invoice_number),\n            order_id,\n            CURRENT_TIMESTAMP\n        FROM \"Invoices\"\n        WHERE invoice_date < p_cutoff_date\n        LIMIT p_batch_size;\n        \n        DELETE FROM \"Invoice_Line_Items\"\n        WHERE invoice_number IN (\n            SELECT invoice_number\n            FROM \"Invoices\"\n            WHERE invoice_date < (CURRENT_TIMESTAMP - INTERVAL '1 day' * p_retention_days)\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "CALL archive_invoice_data('2023-01-01 00:00:00+00', 60.00, 'arch_', 100, 30);",
      "CALL archive_invoice_data('2023-06-01 00:00:00+00', 70.00, 'archive_', 50, 60);",
      "CALL archive_invoice_data('2023-03-01 00:00:00+00', 80.00, 'backup_', 200, 90);",
      "CALL archive_invoice_data('2023-09-01 00:00:00+00', 50.00, 'old_', 150, 120);",
      "CALL archive_invoice_data('2023-12-01 00:00:00+00', 65.00, 'save_', 75, 45);"
    ],
    "summary": "Create a stored procedure with parameters p_cutoff_date (TIMESTAMPTZ), p_min_amount (NUMERIC), p_archive_prefix (TEXT), p_batch_size (BIGINT), and p_retention_days (INTEGER). Count rows from Invoices joined with Invoice_Line_Items where invoice_date < p_cutoff_date and derived_total_cost > p_min_amount. If count > 0, generate an archive ID from the epoch timestamp. Insert up to p_batch_size rows into Invoices, creating new invoice numbers. Finally, delete rows from Invoice_Line_Items where the invoice_number exists in Invoices with an invoice_date older than current date minus p_retention_days.",
    "natural_language": "Make a stored procedure that takes a sort of recent date, a not-too-small money amount, a text prefix for archives, a decent batch size, and a number of days to keep stuff. Figure out roughly how many invoice and line item records there are from a while back that had pretty high totals. If you find a bunch, come up with a new archive ID based on the current time. Then, copy a good chunk of those old invoices over with new invoice numbers. Lastly, clean out any really old line items for invoices that are past their keep-around time.",
    "id": 195
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named generate_product_reports that accepts five input parameters: a bigint parameter p_invoice_start defining the starting invoice number, a bigint parameter p_invoice_end defining the ending invoice number, a numeric parameter p_price_threshold defining a minimum average price, a text parameter p_title_filter for filtering product titles, and an integer parameter p_report_code. The procedure first declares variables rec of type RECORD, v_existing_order_item_id of type bigint, and v_existing_product_id of type bigint. It then queries the \"Invoice_Line_Items\" table to retrieve a single order_item_id value, assigning it to v_existing_order_item_id; if this variable is null, the procedure raises an exception stating no existing order_item_id was found to satisfy a foreign key constraint to the \"Order_Items\" table. Next, it queries the \"Invoice_Line_Items\" table again to retrieve a single product_id value, assigning it to v_existing_product_id; if this variable is null, the procedure raises an exception stating no existing product_id was found to satisfy a foreign key constraint to the \"Products\" table. Following these checks, the procedure enters a loop that iterates over a result set from a SELECT DISTINCT query on the \"Invoice_Line_Items\" table, where the query selects the product_title column and the average of the product_price column aliased as avg_price, filtering rows where the invoice_number is between p_invoice_start and p_invoice_end inclusive and where the product_title contains the substring p_title_filter (using the LIKE operator with wildcards '%' || p_title_filter || '%'), grouping the results by product_title, and having a clause that filters groups where the average product_price is greater than p_price_threshold. For each record in this loop, the procedure performs an INSERT into the \"Invoice_Line_Items\" table, specifying columns order_item_id, invoice_number, product_id, product_title, product_quantity, product_price, derived_product_cost, and derived_total_cost, with values: v_existing_order_item_id for order_item_id, p_invoice_start for invoice_number, v_existing_product_id for product_id, a concatenated string 'REPORT_' || rec.product_title for product_title, the string literal '1' for product_quantity, rec.avg_price for product_price, the expression rec.avg_price * 0.8 for derived_product_cost, and rec.avg_price for derived_total_cost.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_product_reports(\n    p_invoice_start bigint,\n    p_invoice_end bigint,\n    p_price_threshold numeric,\n    p_title_filter text,\n    p_report_code integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    rec RECORD;\n    v_existing_order_item_id bigint; -- To hold an existing order_item_id\n    v_existing_product_id bigint;   -- To hold an existing product_id\nBEGIN\n    -- First, try to find any existing order_item_id from Invoice_Line_Items.\n    -- This ID will be used for all new report entries to satisfy the FK constraint\n    -- to the (unseen) Order_Items table.\n    SELECT order_item_id\n    INTO v_existing_order_item_id\n    FROM \"Invoice_Line_Items\"\n    LIMIT 1;\n\n    -- If no existing order_item_id is found, it means Invoice_Line_Items is empty.\n    -- In this scenario, the procedure cannot proceed without violating the FK.\n    IF v_existing_order_item_id IS NULL THEN\n        RAISE EXCEPTION 'Cannot generate reports: No existing order_item_id found in \"Invoice_Line_Items\" to satisfy foreign key constraint to \"Order_Items\".';\n    END IF;\n\n    -- Next, find an existing product_id from Invoice_Line_Items.\n    -- This ID will be used for all new report entries to satisfy the FK constraint\n    -- to the (unseen) Products table.\n    SELECT product_id\n    INTO v_existing_product_id\n    FROM \"Invoice_Line_Items\"\n    LIMIT 1;\n\n    -- If no existing product_id is found, it means Invoice_Line_Items is empty.\n    -- In this scenario, the procedure cannot proceed without violating the FK.\n    IF v_existing_product_id IS NULL THEN\n        RAISE EXCEPTION 'Cannot generate reports: No existing product_id found in \"Invoice_Line_Items\" to satisfy foreign key constraint to \"Products\".';\n    END IF;\n\n    FOR rec IN\n        SELECT DISTINCT product_title, AVG(product_price) as avg_price\n        FROM \"Invoice_Line_Items\"\n        WHERE invoice_number BETWEEN p_invoice_start AND p_invoice_end\n        AND product_title LIKE '%' || p_title_filter || '%'\n        GROUP BY product_title\n        HAVING AVG(product_price) > p_price_threshold\n    LOOP\n        -- Use the found existing order_item_id and product_id for all new report entries.\n        -- This ensures the foreign key constraints are satisfied.\n        INSERT INTO \"Invoice_Line_Items\" (\n            order_item_id, invoice_number, product_id,\n            product_title, product_quantity, product_price,\n            derived_product_cost, derived_total_cost\n        )\n        VALUES (\n            v_existing_order_item_id, -- Use an existing order_item_id to satisfy FK\n            p_invoice_start,\n            v_existing_product_id,    -- Use an existing product_id to satisfy FK\n            'REPORT_' || rec.product_title,\n            '1',\n            rec.avg_price,\n            rec.avg_price * 0.8,\n            rec.avg_price\n        );\n    END LOOP;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "CALL generate_product_reports(9, 10, 800.0, 'prod', 1);",
      "CALL generate_product_reports(9, 10, 700.0, 'prod', 2);",
      "CALL generate_product_reports(9, 10, 900.0, 'prod', 3);",
      "CALL generate_product_reports(9, 10, 750.0, 'prod', 4);",
      "CALL generate_product_reports(9, 10, 850.0, 'prod', 5);"
    ],
    "summary": "Create a stored procedure named generate_product_reports with parameters p_invoice_start (bigint), p_invoice_end (bigint), p_price_threshold (numeric), p_title_filter (text), and p_report_code (integer). Validate that valid order_item_id and product_id exist in Invoice_Line_Items, raising exceptions if not. Then, for each distinct product_title (filtered by invoice range and title substring) where the average product_price exceeds the threshold, insert a new record into Invoice_Line_Items using the validated IDs, with modified title, quantity of 1, and calculated costs.",
    "natural_language": "Alright, so we need a stored procedure called generate_product_reports. It's gotta take in a few things: p_invoice_start and p_invoice_end (both big numbers), a p_price_threshold (a decimal), some p_title_filter (text), and a p_report_code (integer). First off, we gotta check that the order_item_id and product_id we're gonna use are actually real and kicking around in the Invoice_Line_Items table. If they're not, throw an error and bail. Then, for every unique product title (but only for invoices in that range and where the title kinda matches our filter), if the average price for that product is higher than our threshold, we slap a new row into Invoice_Line_Items. Use the IDs we just checked, tweak the title a bit, set the quantity to 1, and figure out the costs.",
    "id": 196
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_invoice_analytics that accepts five input parameters: an integer p_analysis_period representing a number of days, a numeric p_revenue_target, a text p_product_category, a numeric p_adjustment_rate, and a bigint p_batch_identifier. The procedure begins by calculating a start timestamp v_period_start by subtracting p_analysis_period days from the current timestamp, and it computes an analytics identifier v_analytics_id by adding the ASCII code of the first character of p_product_category to p_batch_identifier. It then performs a SELECT query to sum the derived_total_cost column from the Invoice_Line_Items table, aliasing the result as v_revenue_sum, by joining the Invoice_Line_Items table with the Invoices table on the invoice_number column, where the invoice_date from the Invoices table is on or after v_period_start and the product_title from the Invoice_Line_Items table contains the p_product_category string; if no rows match, the sum defaults to zero via the COALESCE function. The procedure subsequently retrieves the minimum order_item_id from the Order_Items table into variable v_valid_order_item_id and the minimum product_id from the Products table into variable v_valid_product_id. Using a conditional IF-THEN-ELSE block, if the calculated v_revenue_sum is greater than or equal to the p_revenue_target parameter, the procedure inserts a new row into the Invoice_Line_Items table with the following column values: v_valid_order_item_id for order_item_id, the literal integer 1 for invoice_number, v_valid_product_id for product_id, a concatenated string 'ANALYTICS_SUCCESS_' followed by p_product_category for product_title, the integer 1 for product_quantity, v_revenue_sum for product_price, v_revenue_sum multiplied by 0.9 for derived_product_cost, and v_revenue_sum multiplied by p_adjustment_rate for derived_total_cost. If v_revenue_sum is less than p_revenue_target, the procedure instead inserts a row into Invoice_Line_Items with these values: v_valid_order_item_id for order_item_id, the literal integer 1 for invoice_number, v_valid_product_id for product_id, a concatenated string 'ANALYTICS_DEFICIT_' followed by p_product_category for product_title, the integer 1 for product_quantity, the difference between p_revenue_target and v_revenue_sum for product_price, zero for derived_product_cost, and the difference between p_revenue_target and v_revenue_sum multiplied by p_adjustment_rate for derived_total_cost.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_invoice_analytics(\n    p_analysis_period integer,\n    p_revenue_target numeric,\n    p_product_category text,\n    p_adjustment_rate numeric,\n    p_batch_identifier bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_period_start timestamp with time zone;\n    v_analytics_id bigint;\n    v_revenue_sum numeric;\n    v_valid_order_item_id bigint;\n    v_valid_product_id bigint; -- New variable to hold a valid product_id\nBEGIN\n    v_period_start := CURRENT_TIMESTAMP - INTERVAL '1 day' * p_analysis_period;\n    v_analytics_id := p_batch_identifier + ascii(p_product_category);\n    \n    SELECT COALESCE(SUM(ili.derived_total_cost), 0)\n    INTO v_revenue_sum\n    FROM \"Invoice_Line_Items\" ili\n    JOIN \"Invoices\" i ON ili.invoice_number = i.invoice_number\n    WHERE i.invoice_date >= v_period_start\n    AND ili.product_title LIKE '%' || p_product_category || '%';\n    \n    -- Retrieve a valid order_item_id from the Order_Items table\n    -- This assumes Order_Items table exists and has at least one entry.\n    SELECT MIN(order_item_id) INTO v_valid_order_item_id FROM \"Order_Items\";\n\n    -- Retrieve a valid product_id from the Products table\n    -- This assumes Products table exists and has at least one entry.\n    SELECT MIN(product_id) INTO v_valid_product_id FROM \"Products\";\n    \n    IF v_revenue_sum >= p_revenue_target THEN\n        INSERT INTO \"Invoice_Line_Items\" (\n            order_item_id, invoice_number, product_id,\n            product_title, product_quantity, product_price,\n            derived_product_cost, derived_total_cost\n        )\n        VALUES (\n            v_valid_order_item_id,\n            1, -- Assuming invoice_number 1 exists in Invoices table\n            v_valid_product_id, -- Use a valid product_id\n            'ANALYTICS_SUCCESS_' || p_product_category,\n            1, -- Changed to integer type\n            v_revenue_sum,\n            v_revenue_sum * 0.9,\n            v_revenue_sum * p_adjustment_rate\n        );\n    ELSE\n        INSERT INTO \"Invoice_Line_Items\" (\n            order_item_id, invoice_number, product_id,\n            product_title, product_quantity, product_price,\n            derived_product_cost, derived_total_cost\n        )\n        VALUES (\n            v_valid_order_item_id,\n            1, -- Assuming invoice_number 1 exists in Invoices table\n            v_valid_product_id, -- Use a valid product_id\n            'ANALYTICS_DEFICIT_' || p_product_category,\n            1, -- Changed to integer type\n            p_revenue_target - v_revenue_sum,\n            0,\n            (p_revenue_target - v_revenue_sum) * p_adjustment_rate\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "CALL process_invoice_analytics(30, 1000.00, 'prod_name', 0.95, 1001);",
      "CALL process_invoice_analytics(60, 2000.00, 'prod_name', 0.90, 1002);",
      "CALL process_invoice_analytics(90, 1500.00, 'prod_name', 0.85, 1003);",
      "CALL process_invoice_analytics(120, 2500.00, 'prod_name', 0.80, 1004);",
      "CALL process_invoice_analytics(180, 3000.00, 'prod_name', 0.75, 1005);"
    ],
    "summary": "Create a stored procedure named process_invoice_analytics with parameters p_analysis_period (integer days), p_revenue_target (numeric), p_product_category (text), p_adjustment_rate (numeric), and p_batch_identifier (bigint). Calculate total revenue from recent invoices for the specified category. Get valid order_item_id and product_id. If revenue meets or exceeds target, insert a success record into Invoice_Line_Items; otherwise, insert a deficit record with calculated price and costs.",
    "natural_language": "Create a stored procedure called process_invoice_analytics. It should take in a few parameters: an analysis period (a number of days), a revenue target (a numeric figure), a product category (some text), an adjustment rate (another numeric value), and a batch identifier (a big integer). The procedure needs to figure out the total revenue from some recent invoices for that particular product category and gather valid order and product IDs. If the revenue looks good and hits or passes the target, put a success entry into the Invoice_Line_Items table. If the revenue isn't quite there and falls short, then insert a deficit record that includes the calculated price and various costs.",
    "id": 197
  },
  {
    "ir": "Write a PLpgSQL stored procedure named calculate_average_speed that accepts three parameters: p_ship_id of type integer representing the identifier of a ship, p_year of type integer indicating the year of interest, and p_min_speed of type integer specifying the minimum speed threshold. The procedure begins by declaring a local variable avg_speed of type numeric to store the calculated average speed. It then executes a SELECT statement to compute the average of the \"Speed_knots\" column from the mission table, filtering rows where \"Ship_ID\" matches p_ship_id, \"Launched_Year\" equals p_year, and \"Speed_knots\" exceeds p_min_speed, storing the result in avg_speed. If avg_speed is not NULL, indicating that there are valid rows meeting the criteria, the procedure proceeds to insert a new row into the mission table. This insertion includes generating a new \"Mission_ID\" by selecting the maximum existing \"Mission_ID\" from the mission table and adding 1, ensuring uniqueness. The new row is populated with the values: the generated \"Mission_ID\", the provided p_ship_id, a \"Code\" formed by concatenating 'AVG-' with p_year, the specified p_year, a fixed \"Location\" value of 'Calculated', the computed avg_speed, and a \"Fate\" value of 'N/A'. The procedure concludes without any further actions or outputs.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_speed(p_ship_id integer, p_year integer, p_min_speed integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_speed numeric;\nBEGIN\n    SELECT AVG(\"Speed_knots\") INTO avg_speed\n    FROM mission\n    WHERE \"Ship_ID\" = p_ship_id AND \"Launched_Year\" = p_year AND \"Speed_knots\" > p_min_speed;\n    \n    IF avg_speed IS NOT NULL THEN\n        INSERT INTO mission (\"Mission_ID\", \"Ship_ID\", \"Code\", \"Launched_Year\", \"Location\", \"Speed_knots\", \"Fate\")\n        VALUES ((SELECT COALESCE(MAX(\"Mission_ID\"), 0) + 1 FROM mission), p_ship_id, 'AVG-' || p_year, p_year, 'Calculated', avg_speed, 'N/A');\n    END IF;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL calculate_average_speed(1, 1930, 20);",
      "CALL calculate_average_speed(2, 1930, 15);",
      "CALL calculate_average_speed(3, 1930, 10);",
      "CALL calculate_average_speed(1, 1931, 22);",
      "CALL calculate_average_speed(2, 1929, 18);"
    ],
    "summary": "Create a stored procedure named calculate_average_speed with parameters p_ship_id (integer), p_year (integer), and p_min_speed (integer). Calculate the average Speed_knots from the mission table for the given ship and year where speed exceeds the minimum. If a valid average is found, insert a new mission record with a generated ID, using the calculated average speed and fixed values for Location and Fate.",
    "natural_language": "Hey, so I need you to whip up a stored procedure called calculate_average_speed. It's gotta take in a ship ID (that's an integer), a year (also an integer), and a minimum speed threshold (integer again). What it does is figure out the average Speed_knots from the mission table, but only for that specific ship and year, and only for trips where the speed was higher than that minimum we gave it. If you manage to get a legit average out of that, then go ahead and slap a new record into the mission table. For that new entry, just generate a fresh ID, use the average speed you just calculated, and for the Location and Fate fields, just plug in some fixed, pre-set values.",
    "id": 198
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `transfer_missions` that accepts three input parameters: `p_old_ship_id` of type `integer`, representing the identifier of the ship from which missions are to be transferred; `p_new_ship_id` of type `integer`, representing the identifier of the ship to which missions will be assigned; and `p_year` of type `integer`, representing a threshold year for mission transfer. The procedure begins by declaring a local variable `next_id` of type `integer`, which will be used to store the next available mission identifier.\n\nThe first operation performed is a `DELETE` statement on the `mission` table. This statement removes all records from the `mission` table where the value in the `\"Ship_ID\"` column matches the `p_old_ship_id` parameter AND the value in the `\"Launched_Year\"` column is strictly less than the `p_year` parameter.\n\nFollowing the deletion, the procedure executes a `SELECT` statement to determine the next available mission identifier. This `SELECT` statement queries the `mission` table to find the maximum value in the `\"Mission_ID\"` column. The `COALESCE` function is used to handle cases where the `mission` table might be empty or contain no `\"Mission_ID\"` values, in which case `MAX(\"Mission_ID\")` would return `NULL`; `COALESCE` replaces `NULL` with `0`. One is then added to this maximum value (or `0` if no missions exist) to generate a new, unique identifier, which is then stored into the `next_id` local variable.\n\nFinally, the procedure performs an `INSERT` statement to add new records into the `mission` table. The columns targeted for insertion are `\"Mission_ID\"`, `\"Ship_ID\"`, `\"Code\"`, `\"Launched_Year\"`, `\"Location\"`, `\"Speed_knots\"`, and `\"Fate\"`. The values for these columns are derived from a `SELECT` subquery that retrieves data from the `mission` table. This subquery selects records where the `\"Ship_ID\"` column matches the `p_old_ship_id` parameter AND the `\"Launched_Year\"` column is greater than or equal to the `p_year` parameter. For each row selected by this subquery:\n- The `\"Mission_ID\"` for the new record is calculated as `next_id` plus the `ROW_NUMBER()` assigned to the current row within the result set of the subquery. The `ROW_NUMBER()` analytic function assigns a sequential integer starting from 1 to each row within its partition, ordered by `\"Mission_ID\"`. This ensures that the newly inserted missions receive unique and sequential `Mission_ID` values starting from `next_id`.\n- The `\"Ship_ID\"` for the new record is set to the value of the `p_new_ship_id` parameter.\n- The `\"Code\"`, `\"Launched_Year\"`, `\"Location\"`, `\"Speed_knots\"`, and `\"Fate\"` columns for the new record are populated directly with the corresponding values from the selected row in the original `mission` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_missions(p_old_ship_id integer, p_new_ship_id integer, p_year integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    next_id integer;\nBEGIN\n    DELETE FROM mission\n    WHERE \"Ship_ID\" = p_old_ship_id AND \"Launched_Year\" < p_year;\n    \n    SELECT COALESCE(MAX(\"Mission_ID\"), 0) + 1 INTO next_id FROM mission;\n    \n    INSERT INTO mission (\"Mission_ID\", \"Ship_ID\", \"Code\", \"Launched_Year\", \"Location\", \"Speed_knots\", \"Fate\")\n    SELECT next_id + ROW_NUMBER() OVER (ORDER BY \"Mission_ID\"), p_new_ship_id, \"Code\", \"Launched_Year\", \"Location\", \"Speed_knots\", \"Fate\"\n    FROM mission\n    WHERE \"Ship_ID\" = p_old_ship_id AND \"Launched_Year\" >= p_year;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL transfer_missions(1, 2, 1930);",
      "CALL transfer_missions(2, 3, 1930);",
      "CALL transfer_missions(3, 1, 1930);",
      "CALL transfer_missions(1, 3, 1930);",
      "CALL transfer_missions(2, 1, 1930);"
    ],
    "summary": "Create a stored procedure named transfer_missions with parameters p_old_ship_id (integer), p_new_ship_id (integer), and p_year (integer). Delete missions for the old ship launched before the given year. Then, reassign missions launched from that year onward to the new ship by inserting them with new sequential Mission_IDs, preserving their other data.",
    "natural_language": "Create procedure transfer_missions(p_old_ship_id int, p_new_ship_id int, p_year int). Delete old ship's missions before p_year. Reassign later missions to new ship with new sequential IDs.",
    "id": 199
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `insert_writer_if_odd` that accepts two input parameters: `p_wid` of type `integer` and `p_gender` of type `text`. The procedure first declares a local variable `v_mod_result` of type `integer`. It then calculates the remainder of `p_wid` divided by 2 using the `mod()` function and assigns this result to `v_mod_result`. Subsequently, it evaluates a conditional statement: if the value of `v_mod_result` is equal to 1, indicating that `p_wid` is an odd number, the procedure proceeds to insert a new row into the `writer` table. The `wid` column of the `writer` table is populated with the value of the `p_wid` parameter, the `gender` column is populated with the value of the `p_gender` parameter, and the `name`, `nationality`, `num_of_episodes`, and `birth_year` columns are all populated with the integer value 0. The `birth_city` column is populated with an empty string (''). If `v_mod_result` is not equal to 1 (i.e., `p_wid` is an even number), no insertion operation is performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_writer_if_odd(p_wid integer, p_gender text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_mod_result integer;\nBEGIN\n    v_mod_result := mod(p_wid, 2);\n    IF v_mod_result = 1 THEN\n        INSERT INTO writer (\"wid\", \"gender\", \"name\", \"nationality\", \"num_of_episodes\", \"birth_city\", \"birth_year\")\n        VALUES (p_wid, p_gender, 0, 0, 0, '', 0);\n    END IF;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "CALL insert_writer_if_odd(1, 'Male');",
      "CALL insert_writer_if_odd(3, 'Female');",
      "CALL insert_writer_if_odd(5, 'Non-binary');",
      "CALL insert_writer_if_odd(7, 'Male');",
      "CALL insert_writer_if_odd(9, 'Female');"
    ],
    "summary": "Create a stored procedure named insert_writer_if_odd with parameters p_wid (integer) and p_gender (text). Check if the writer ID is odd. If it is, insert a new writer with the given ID and gender, setting name, nationality, episode count, and birth year to 0, and birth city to an empty string. If the ID is even, do nothing.",
    "natural_language": "Create a stored procedure called insert_writer_if_odd that takes a writer ID number and a gender text. The procedure should check if the provided ID seems like an odd number. If it looks odd, then add a new writer entry using that ID and gender. For the other details like name, where they're from, how many episodes they've done, their birth year, and birth city, just set them to some basic default or empty values. If the ID appears to be an even number, then the procedure shouldn't really do anything.",
    "id": 200
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_writer_genre that accepts two integer parameters: p_wid and p_gid, representing a writer ID and a genre ID, respectively. The procedure begins by declaring two boolean variables, v_writer_exists and v_genre_exists, to determine the existence of the specified writer and genre in their respective tables. It performs a SELECT operation on the writer table to check if a record with the writer ID matching p_wid exists, storing the result in v_writer_exists. Similarly, it checks the genre table for the existence of a record with the genre ID matching p_gid, storing the result in v_genre_exists. The procedure then evaluates a conditional statement: if both v_writer_exists and v_genre_exists are true, it inserts a new record into the written_by table, setting the id column to one more than the current maximum id value in the table, and assigning p_gid to the msid column and p_wid to the wid column. If v_writer_exists is false, indicating the writer does not exist, it inserts a new record into the writer table with the wid column set to p_wid and default values for the other columns: 'unknown' for gender, 0 for name, nationality, num_of_episodes, and birth_year, and an empty string for birth_city.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_writer_genre(p_wid integer, p_gid integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_writer_exists boolean;\n    v_genre_exists boolean;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM writer WHERE \"wid\" = p_wid) INTO v_writer_exists;\n    SELECT EXISTS(SELECT 1 FROM genre WHERE \"gid\" = p_gid) INTO v_genre_exists;\n    \n    IF v_writer_exists AND v_genre_exists THEN\n        INSERT INTO written_by (\"id\", \"msid\", \"wid\")\n        VALUES ((SELECT COALESCE(MAX(\"id\"), 0) + 1 FROM written_by), p_gid, p_wid);\n    ELSIF NOT v_writer_exists THEN\n        INSERT INTO writer (\"wid\", \"gender\", \"name\", \"nationality\", \"num_of_episodes\", \"birth_city\", \"birth_year\")\n        VALUES (p_wid, 'unknown', 0, 0, 0, '', 0);\n    END IF;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "CALL process_writer_genre(1, 1);",
      "CALL process_writer_genre(2, 2);",
      "CALL process_writer_genre(3, 3);",
      "CALL process_writer_genre(4, 4);",
      "CALL process_writer_genre(5, 5);"
    ],
    "summary": "Create a stored procedure named process_writer_genre that accepts a writer ID and a genre ID. Check if the writer and genre exist in their respective tables. If both exist, insert a new record into the written_by table with a new ID (current max + 1), the genre ID, and the writer ID. If the writer does not exist, insert a new writer record with the given ID and default values for other columns.",
    "natural_language": "Develop a stored procedure called process_writer_genre that is designed to receive a specific writer ID and a particular genre ID as its input parameters. Initially, the procedure must meticulously verify whether the provided writer ID corresponds to an existing entry within the writers table and, similarly, confirm that the supplied genre ID is present within the genres table. Should both of these checks confirm the existence of the respective records, the procedure will then proceed to insert a brand new record into the written_by table. This new record will be assigned a unique identifier calculated by incrementing the current maximum ID value by one, and it will also incorporate the validated genre ID and writer ID. However, in the specific scenario where the writer ID is determined to be non-existent, the procedure must instead carefully insert a completely new writer record, utilizing the given writer ID while populating all other columns with sensible default values.",
    "id": 201
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `adjust_writer_episodes` that accepts two input parameters: `p_wid`, an integer representing a writer's unique identifier, and `p_adjustment`, an integer representing an adjustment value for the number of episodes. The procedure begins by declaring two local variables: `v_current_episodes`, an integer to store the current number of episodes for a writer, and `v_mod_check`, an integer to store the result of a modulo operation. It then retrieves the value from the `num_of_episodes` column for the row in the `writer` table where the `wid` column matches the input parameter `p_wid`, and stores this retrieved value into the `v_current_episodes` variable. Subsequently, it calculates the remainder of `p_wid` divided by 3 using the `mod` function and assigns this result to the `v_mod_check` variable. Following this, the procedure executes a conditional block based on the value of `v_mod_check`. If `v_mod_check` is equal to 0, it attempts to insert a new row into the `writer` table with the following values: `p_wid` for the `wid` column, the string literal 'adjusted' for the `gender` column, the integer 0 for the `name` column, the integer 0 for the `nationality` column, `p_adjustment` for the `num_of_episodes` column, an empty string '' for the `birth_city` column, and the integer 0 for the `birth_year` column. If a row with the same `wid` already exists (due to a unique constraint on the `wid` column), it instead updates the existing row by adding the value of `p_adjustment` to the current value of the `num_of_episodes` column in that row. If `v_mod_check` is equal to 1, it deletes all rows from the `written_by` table where the `wid` column matches the input parameter `p_wid`. If `v_mod_check` is neither 0 nor 1 (i.e., it is 2), it inserts a new row into the `genre` table with the value of `p_wid` for the `gid` column and the string literal 'auto-generated' for the `genre` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_writer_episodes(p_wid integer, p_adjustment integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_episodes integer;\n    v_mod_check integer;\nBEGIN\n    SELECT \"num_of_episodes\" INTO v_current_episodes FROM writer WHERE \"wid\" = p_wid;\n    v_mod_check := mod(p_wid, 3);\n    \n    IF v_mod_check = 0 THEN\n        INSERT INTO writer (\"wid\", \"gender\", \"name\", \"nationality\", \"num_of_episodes\", \"birth_city\", \"birth_year\")\n        VALUES (p_wid, 'adjusted', 0, 0, p_adjustment, '', 0)\n        ON CONFLICT (\"wid\") DO UPDATE SET \"num_of_episodes\" = writer.\"num_of_episodes\" + p_adjustment;\n    ELSIF v_mod_check = 1 THEN\n        DELETE FROM written_by WHERE \"wid\" = p_wid;\n    ELSE\n        INSERT INTO genre (\"gid\", \"genre\") VALUES (p_wid, 'auto-generated');\n    END IF;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "CALL adjust_writer_episodes(3, 10);",
      "CALL adjust_writer_episodes(1, 5);",
      "CALL adjust_writer_episodes(2, 20);",
      "CALL adjust_writer_episodes(6, -5);",
      "CALL adjust_writer_episodes(4, 15);"
    ],
    "summary": "Create a stored procedure named adjust_writer_episodes that accepts a writer ID and an episode adjustment value. Get the writer's current episode count. Calculate the writer ID modulo 3. If the result is 0, insert a new writer record with the given ID and adjustment value, or update the existing writer's episode count by adding the adjustment if the ID already exists. If the result is 1, delete all records for that writer from the written_by table. If the result is 2, insert a new genre record with the writer ID and 'auto-generated' as the genre name.",
    "natural_language": "Make a stored procedure called adjust_writer_episodes that takes a writer ID and a number to adjust episodes by. First, find out how many episodes the writer currently has. Then, do a calculation with the writer ID and the number 3. If that calculation gives a certain result, just add the new adjustment to the writer's total if they're already there, or put them in if they're not. If the calculation gives a different result, clean out any mentions of that writer from the written_by list. For another possible result of the calculation, add a new genre entry for that writer with a standard made-up name.",
    "id": 202
  },
  {
    "ir": "Write a PLpgSQL stored procedure named handle_writer_mod_operation that accepts two integer parameters: p_wid and p_operation_type. The procedure begins by calculating the remainder of p_wid divided by 4, storing this result in the variable v_mod_result. It then evaluates the value of p_operation_type to determine the operation to perform. If p_operation_type equals 1, the procedure counts the number of rows in the writer table where the remainder of the wid column divided by 2 equals v_mod_result, storing this count in v_writer_count. It then inserts a new row into the genre table with the gid column set to v_writer_count and the genre column set to 'count_based'. If p_operation_type equals 2, the procedure deletes rows from the written_by table where the remainder of the wid column divided by 3 equals v_mod_result. If p_operation_type is neither 1 nor 2, the procedure attempts to insert a new row into the writer table with the wid column set to the sum of p_wid and v_mod_result, and other columns set to default values ('batch' for gender, 0 for name, nationality, num_of_episodes, birth_year, and an empty string for birth_city), but only if no existing row in the writer table has a wid equal to this calculated value.",
    "plsql": "CREATE OR REPLACE PROCEDURE handle_writer_mod_operation(p_wid integer, p_operation_type integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_mod_result integer;\n    v_writer_count integer;\nBEGIN\n    v_mod_result := mod(p_wid, 4);\n    \n    IF p_operation_type = 1 THEN\n        SELECT COUNT(*) INTO v_writer_count FROM writer WHERE mod(\"wid\", 2) = v_mod_result;\n        INSERT INTO genre (\"gid\", \"genre\") VALUES (v_writer_count, 'count_based');\n    ELSIF p_operation_type = 2 THEN\n        DELETE FROM written_by WHERE mod(\"wid\", 3) = v_mod_result;\n    ELSE\n        INSERT INTO writer (\"wid\", \"gender\", \"name\", \"nationality\", \"num_of_episodes\", \"birth_city\", \"birth_year\")\n        SELECT p_wid + v_mod_result, 'batch', 0, 0, 0, '', 0\n        WHERE NOT EXISTS (SELECT 1 FROM writer WHERE \"wid\" = p_wid + v_mod_result);\n    END IF;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "CALL handle_writer_mod_operation(1, 1);",
      "CALL handle_writer_mod_operation(2, 2);",
      "CALL handle_writer_mod_operation(3, 3);",
      "CALL handle_writer_mod_operation(4, 1);",
      "CALL handle_writer_mod_operation(5, 2);"
    ],
    "summary": "Create a stored procedure named handle_writer_mod_operation that accepts a writer ID and an operation type. Calculate the writer ID modulo 4. If the operation type is 1, count writers whose ID modulo 2 equals the calculated result, then insert a new genre record using that count as the ID and 'count_based' as the genre. If the operation type is 2, delete records from the written_by table where the writer ID modulo 3 equals the calculated result. For any other operation type, insert a new writer record with an ID equal to the sum of the input ID and the calculated result, using default values, only if that ID does not already exist.",
    "natural_language": "Please construct a stored procedure designated as 'handle_writer_mod_operation' that receives a writer identifier and an operation type as parameters. The procedure shall first compute the modulus of the provided writer identifier with respect to the value four. Subsequently, if the operation type parameter is equal to one, the procedure must count the number of writers whose identifier modulo two yields the previously calculated result. This count value shall then be utilized as the identifier for a new record to be inserted into the genre table, with the genre name specified as 'count_based'. If the operation type parameter is equal to two, the procedure must delete all entries from the written_by table where the writer identifier modulo three is equivalent to the calculated result. For any operation type value other than one or two, the procedure is to insert a new record into the writer table. This insertion shall employ an identifier equal to the sum of the input writer identifier and the calculated modulo result, along with default values for other columns, but only under the condition that an entry with that specific identifier does not already exist within the table.",
    "id": 203
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named calculate_movie_radians that accepts a single integer input parameter p_movie_id, then queries the Rating table to compute the average value of the stars column for all rows where the mID column equals the provided p_movie_id, storing this result into a local numeric variable v_avg_stars; if the computed average is not null, the procedure calculates the radian equivalent of that average value using the built-in radians() function, stores this result in a local numeric variable v_radians_value, constructs a new text title by concatenating the string 'Radians: ' with the string representation of v_radians_value, and inserts a new row into the Movie table with an mID value equal to the input p_movie_id plus 500, a title value set to the constructed v_new_title, a year value set to the current year extracted from the system date using EXTRACT(YEAR FROM CURRENT_DATE), and a director value set to 'Radians Calculator'; if the computed average is null, indicating no ratings were found for the given movie ID, the procedure instead inserts a new row into the Movie table with an mID value equal to p_movie_id plus 500, a title value set to 'No Ratings Found', a year value set to the current year extracted from the system date, and a director value set to 'System'.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_movie_radians(p_movie_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_stars numeric;\n    v_radians_value numeric;\n    v_new_title text;\nBEGIN\n    SELECT AVG(\"stars\") INTO v_avg_stars\n    FROM \"Rating\"\n    WHERE \"mID\" = p_movie_id;\n    \n    IF v_avg_stars IS NOT NULL THEN\n        v_radians_value := radians(v_avg_stars);\n        v_new_title := 'Radians: ' || v_radians_value::text;\n        \n        INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n        VALUES (p_movie_id + 500, v_new_title, EXTRACT(YEAR FROM CURRENT_DATE), 'Radians Calculator');\n    ELSE\n        INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n        VALUES (p_movie_id + 500, 'No Ratings Found', EXTRACT(YEAR FROM CURRENT_DATE), 'System');\n    END IF;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL calculate_movie_radians(101);",
      "CALL calculate_movie_radians(102);",
      "CALL calculate_movie_radians(103);",
      "CALL calculate_movie_radians(106);",
      "CALL calculate_movie_radians(107);"
    ],
    "summary": "Create a stored procedure named calculate_movie_radians that accepts a movie ID. Calculate the average star rating for that movie. If an average exists, convert it to radians, construct a title string, and insert a new movie record with an ID of the input plus 500, the constructed title, the current year, and 'Radians Calculator' as the director. If no average exists (null), insert a new movie record with the same ID offset, the title 'No Ratings Found', the current year, and 'System' as the director.",
    "natural_language": "Make procedure calculate_movie_radians with movie ID. Get its average rating. If average exists, convert to radians, build title, insert new movie: ID+500, built title, current year, director 'Radians Calculator'. If no average, insert new movie: ID+500, title 'No Ratings Found', current year, director 'System'.",
    "id": 204
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_reviewer_ratings that accepts a single integer parameter p_reviewer_id, which represents the ID of a reviewer. The procedure begins by declaring three local variables: v_total_movies of type integer, v_avg_rating of type numeric, and v_angle_value of type numeric. It then executes a SELECT statement to count the distinct movie IDs (\"mID\") and calculate the average of the \"stars\" column from the \"Rating\" table, where the \"rID\" column matches the provided p_reviewer_id. The results of this query are stored in the v_total_movies and v_avg_rating variables. If the v_total_movies variable is greater than zero, indicating that the reviewer has rated at least one movie, the procedure calculates the v_angle_value by converting the product of v_avg_rating and 20 into radians using the radians() function. Following this, the procedure deletes all rows from the \"Rating\" table where the \"rID\" matches p_reviewer_id and the \"stars\" value is less than 3. Finally, it inserts a new row into the \"Movie\" table with the \"mID\" set to the sum of p_reviewer_id and 1000, the \"title\" set to a string concatenation of 'Reviewer Angle: ' and the text representation of v_angle_value, the \"year\" set to 2024, and the \"director\" set to 'Auto'.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_reviewer_ratings(p_reviewer_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_movies integer;\n    v_avg_rating numeric;\n    v_angle_value numeric;\nBEGIN\n    SELECT COUNT(DISTINCT \"mID\"), AVG(\"stars\") \n    INTO v_total_movies, v_avg_rating\n    FROM \"Rating\"\n    WHERE \"rID\" = p_reviewer_id;\n    \n    IF v_total_movies > 0 THEN\n        v_angle_value := radians(v_avg_rating * 20);\n        \n        DELETE FROM \"Rating\"\n        WHERE \"rID\" = p_reviewer_id AND \"stars\" < 3;\n        \n        INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n        VALUES (p_reviewer_id + 1000, 'Reviewer Angle: ' || v_angle_value::text, 2024, 'Auto');\n    END IF;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL process_reviewer_ratings(201);",
      "CALL process_reviewer_ratings(202);",
      "CALL process_reviewer_ratings(203);",
      "CALL process_reviewer_ratings(999);",
      "CALL process_reviewer_ratings(200);"
    ],
    "summary": "Create a stored procedure named process_reviewer_ratings that accepts a reviewer ID. Count the distinct movies and calculate the average star rating for that reviewer. If the movie count is greater than zero, convert the product of the average rating and 20 into radians. Then, delete all ratings by that reviewer where the stars are less than 3. Finally, insert a new movie record with an ID of the reviewer ID plus 1000, a title containing the calculated angle, the year 2024, and 'Auto' as the director.",
    "natural_language": "Make a procedure 'process_reviewer_ratings' for a reviewer ID. Count their distinct movies and get average stars. If movies > 0, turn (avg * 20) into radians. Delete their ratings under 3 stars. Insert a movie with ID reviewer+1000, title with the angle, year 2024, director 'Auto'.",
    "id": 205
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `analyze_rating_patterns` that accepts one input parameter, `p_min_stars`, which is an integer representing a minimum star rating threshold. The procedure begins by declaring three local variables: `v_reviewer_count` of type integer, `v_avg_year` of type numeric, and `v_radians_result` of type numeric. It then executes a `SELECT` statement to calculate two aggregate values: the count of distinct `rID` values from the `\"Reviewer\"` table and the average of the `\"year\"` column from the `\"Movie\"` table. These calculated values are stored into the `v_reviewer_count` and `v_avg_year` variables, respectively. This `SELECT` statement joins three tables: `\"Rating\"` (aliased as `rt`), `\"Reviewer\"` (aliased as `r`), and `\"Movie\"` (aliased as `m`). The join conditions are `rt.\"rID\" = r.\"rID\"` to link ratings to reviewers, and `rt.\"mID\" = m.\"mID\"` to link ratings to movies. The selection is filtered by a `WHERE` clause, including only those records from the `\"Rating\"` table where the `\"stars\"` column is greater than or equal to the input parameter `p_min_stars`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block (`IF`) that checks two conditions: if `v_reviewer_count` is greater than 0 AND `v_avg_year` is not NULL. If both conditions are true, the procedure proceeds with further operations. Inside this conditional block, the `v_radians_result` variable is assigned the result of applying the `radians()` function to the `v_avg_year` value. The `radians()` function converts a degree value (in this case, the average year is treated as a degree value for this mathematical operation) into its equivalent in radians. Subsequently, a `DELETE` statement is executed on the `\"Rating\"` table. This `DELETE` operation removes rows where the `\"ratingDate\"` column is NULL AND the `\"stars\"` column is less than the input parameter `p_min_stars`. After the deletion, an `INSERT` statement is executed to add a new row into the `\"Movie\"` table. The new row's values are: `mID` is calculated as `3000 + p_min_stars`, `title` is set to the string literal 'Analysis Result', `year` is set to the rounded value of `v_avg_year` using the `ROUND()` function, and `director` is set to the string literal 'Pattern Detector'. The procedure concludes after this conditional block.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_rating_patterns(p_min_stars integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_reviewer_count integer;\n    v_avg_year numeric;\n    v_radians_result numeric;\nBEGIN\n    SELECT COUNT(DISTINCT r.\"rID\"), AVG(m.\"year\")\n    INTO v_reviewer_count, v_avg_year\n    FROM \"Rating\" rt\n    JOIN \"Reviewer\" r ON rt.\"rID\" = r.\"rID\"\n    JOIN \"Movie\" m ON rt.\"mID\" = m.\"mID\"\n    WHERE rt.\"stars\" >= p_min_stars;\n    \n    IF v_reviewer_count > 0 AND v_avg_year IS NOT NULL THEN\n        v_radians_result := radians(v_avg_year);\n        \n        DELETE FROM \"Rating\"\n        WHERE \"ratingDate\" IS NULL AND \"stars\" < p_min_stars;\n        \n        INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n        VALUES (3000 + p_min_stars, 'Analysis Result', ROUND(v_avg_year), 'Pattern Detector');\n    END IF;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL analyze_rating_patterns(1);",
      "CALL analyze_rating_patterns(2);",
      "CALL analyze_rating_patterns(3);",
      "CALL analyze_rating_patterns(4);",
      "CALL analyze_rating_patterns(5);"
    ],
    "summary": "Create a stored procedure named `analyze_rating_patterns` that takes an integer parameter `p_min_stars`. It calculates the count of distinct reviewers and the average movie year from a join of the Rating, Reviewer, and Movie tables, filtered by ratings with stars >= `p_min_stars`. If the reviewer count > 0 and the average year is not null, it converts the average year to radians, deletes Rating rows where ratingDate is null and stars < `p_min_stars`, and inserts a new Movie row with a calculated ID, title 'Analysis Result', the rounded average year, and director 'Pattern Detector'.",
    "natural_language": "Develop a comprehensive stored procedure, to be named `analyze_rating_patterns`, which accepts a single integer input parameter designated as `p_min_stars`. This procedure meticulously performs a calculation to determine both the total number of unique reviewers and the mean production year of movies, derived from an intricate join operation involving the Rating, Reviewer, and Movie tables, specifically filtering for those rating entries where the number of stars meets or exceeds the provided `p_min_stars` threshold. Subsequently, if the computed count of distinct reviewers is definitively greater than zero and the resulting average movie year is a non-null value, the procedure executes a series of precise operations: it first transforms the average year into its radian equivalent, then proceeds to permanently delete all rows from the Rating table where the ratingDate field is empty and the stars are strictly less than the `p_min_stars` parameter. Finally, it inserts a brand new record into the Movie table, featuring a dynamically calculated identifier, a formal title explicitly set to 'Analysis Result', the average year rounded to the nearest whole number, and a director name officially listed as 'Pattern Detector'.",
    "id": 206
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named generate_angle_based_titles that accepts one input parameter p_director_pattern of type text, which is used to filter movie directors via a pattern match, and then processes each matching movie to insert new rows into the Movie table. The procedure begins by declaring local variables: v_movie_id and v_movie_year to hold values from a cursor loop, v_angle_value to store a computed numeric result, and v_counter initialized to zero for counting iterations. It opens a FOR loop that iterates over a result set from a SELECT query on the Movie table, specifically retrieving the mID and year columns for every row where the director column contains the substring specified by p_director_pattern, using the LIKE operator with wildcards ('%') concatenated before and after the parameter. For each fetched row, the procedure calculates v_angle_value by converting the movie year (cast to a numeric value via multiplication by 1.0) into radians using the built-in radians() function. It then checks a conditional block: if the v_counter is less than 3, it performs an INSERT into the Movie table, creating a new record with an mID equal to the original v_movie_id plus 4000, a title constructed by concatenating the string 'Angle Title ' with the current v_counter value, the original v_movie_year, and a hardcoded director value of 'Generated'. If v_counter is 3 or greater, it executes an alternative INSERT, still using the adjusted mID (v_movie_id + 4000) and the original year, but with a title built from 'Extra Angle ' concatenated with v_counter and a director set to 'System'. After each insert operation, the v_counter is incremented by one, and the loop continues until all rows from the SELECT query have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_angle_based_titles(p_director_pattern text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_movie_id integer;\n    v_movie_year integer;\n    v_angle_value numeric;\n    v_counter integer := 0;\nBEGIN\n    FOR v_movie_id, v_movie_year IN \n        SELECT \"mID\", \"year\" \n        FROM \"Movie\" \n        WHERE \"director\" LIKE '%' || p_director_pattern || '%'\n    LOOP\n        v_angle_value := radians(v_movie_year * 1.0);\n        \n        IF v_counter < 3 THEN\n            INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n            VALUES (v_movie_id + 4000, 'Angle Title ' || v_counter, v_movie_year, 'Generated');\n        ELSE\n            INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n            VALUES (v_movie_id + 4000, 'Extra Angle ' || v_counter, v_movie_year, 'System');\n        END IF;\n        \n        v_counter := v_counter + 1;\n    END LOOP;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL generate_angle_based_titles('Lucas');",
      "CALL generate_angle_based_titles('Fleming');",
      "CALL generate_angle_based_titles('Wise');",
      "CALL generate_angle_based_titles('Spielberg');",
      "CALL generate_angle_based_titles('Cameron');"
    ],
    "summary": "Create a stored procedure named `generate_angle_based_titles` that takes a text parameter `p_director_pattern`. It loops through movies where the director contains the pattern. For each movie, it calculates the radian value of the movie year. For the first three movies, it inserts a new Movie row with an ID offset by 4000, a title 'Angle Title' plus counter, the original year, and director 'Generated'. For subsequent movies, it inserts a row with title 'Extra Angle' plus counter and director 'System'. Increment the counter each iteration.",
    "natural_language": "Alright, so we need a stored procedure called `generate_angle_based_titles` that takes in a text parameter, let's call it `p_director_pattern`. Basically, it's gonna look through all the movies where the director's name kinda matches that pattern. For every movie it finds, it'll do some math to get the radian value from the movie's year. Now, for the first three movies it picks up, we wanna insert a brand new row into the Movie table. Give it an ID that's the original plus 4000, slap on a title like 'Angle Title' followed by a running number, keep the original year, and set the director to 'Generated'. For any movies after those first three, we still insert a new row, but this time the title should be 'Extra Angle' plus that same running number and the director is just 'System'. Oh, and don't forget to bump up that counter every single time we go through the loop.",
    "id": 207
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_new_stock_record that accepts three mandatory integer input parameters: p_shop_id to represent a shop identifier, p_device_id to represent a device identifier, and p_quantity to represent a quantity to be added. The procedure performs a single data manipulation operation on the table named stock, targeting the columns Shop_ID, Device_ID, and Quantity. It attempts to insert a new row into the stock table using the provided parameter values for these columns. If a conflict arises because a row already exists with the same combination of Shop_ID and Device_ID values as specified by the parameters, the operation does not insert a new row but instead updates the existing conflicting row. The update action increases the existing value in the Quantity column of the conflicting stock row by adding the value from the p_quantity parameter to it, effectively incrementing the stock quantity for that specific shop and device.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_stock_record(IN p_shop_id INTEGER, IN p_device_id INTEGER, IN p_quantity INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"stock\" (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n    VALUES (p_shop_id, p_device_id, p_quantity)\n    ON CONFLICT (\"Shop_ID\", \"Device_ID\") DO UPDATE\n    SET \"Quantity\" = \"stock\".\"Quantity\" + p_quantity;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL insert_new_stock_record(1, 1, 50);",
      "CALL insert_new_stock_record(2, 2, 75);",
      "CALL insert_new_stock_record(3, 3, 100);",
      "CALL insert_new_stock_record(1, 2, 25);",
      "CALL insert_new_stock_record(2, 3, 60);"
    ],
    "summary": "Create a stored procedure named `insert_new_stock_record` that takes three integer parameters: `p_shop_id`, `p_device_id`, and `p_quantity`. It inserts a new row into the stock table with these values. If a row with the same shop and device ID already exists, update that row by adding `p_quantity` to the existing Quantity.",
    "natural_language": "Hey, can you whip up a stored procedure called `insert_new_stock_record`? It needs to take three numbers: `p_shop_id`, `p_device_id`, and `p_quantity`. Basically, it should add a new entry to the stock table using those numbers. But here's the catch: if there's already an entry for that same shop and device combo, don't just add a duplicate. Instead, just bump up the existing Quantity by adding the new `p_quantity` to it.",
    "id": 208
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named remove_stock_by_criteria that accepts three input parameters: an integer parameter p_shop_id representing a specific shop identifier, an integer parameter p_device_id representing a specific device identifier, and an integer parameter p_min_quantity representing a minimum quantity threshold; the procedure performs a DELETE operation on the table named \"stock\", targeting all rows where the column \"Shop_ID\" exactly matches the provided p_shop_id value, and simultaneously the column \"Device_ID\" exactly matches the provided p_device_id value, and concurrently the column \"Quantity\" is greater than or equal to the provided p_min_quantity value.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_stock_by_criteria(IN p_shop_id INTEGER, IN p_device_id INTEGER, IN p_min_quantity INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"stock\" WHERE \"Shop_ID\" = p_shop_id AND \"Device_ID\" = p_device_id AND \"Quantity\" >= p_min_quantity;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL remove_stock_by_criteria(1, 6, 100);",
      "CALL remove_stock_by_criteria(2, 6, 110);",
      "CALL remove_stock_by_criteria(3, 6, 134);",
      "CALL remove_stock_by_criteria(1, 6, 50);",
      "CALL remove_stock_by_criteria(2, 6, 200);"
    ],
    "summary": "Create a stored procedure named `remove_stock_by_criteria` that takes three integer parameters: `p_shop_id`, `p_device_id`, and `p_min_quantity`. It deletes rows from the stock table where Shop_ID equals `p_shop_id`, Device_ID equals `p_device_id`, and Quantity is >= `p_min_quantity`.",
    "natural_language": "Please construct a stored procedure designated as `remove_stock_by_criteria`. This procedure is to accept three integer input parameters: `p_shop_id`, `p_device_id`, and `p_min_quantity`. Its function is to delete records from the stock table where the Shop_ID column matches the provided `p_shop_id`, the Device_ID column matches the provided `p_device_id`, and the Quantity column is greater than or equal to the specified `p_min_quantity`.",
    "id": 209
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named analyze_college_membership that accepts four input parameters: an integer p_college_id, a text p_country, an integer p_min_members, and an integer p_precision; the procedure first declares three local variables: an integer v_member_count, a numeric v_percentage, and an integer v_total_members; it then performs a SELECT COUNT(*) query on the \"member\" table, storing the result into v_member_count, where the \"College_ID\" column equals the p_college_id parameter and the \"Country\" column equals the p_country parameter; subsequently, it performs another SELECT COUNT(*) query on the \"member\" table without any filter, storing the total number of all members into v_total_members; next, it calculates v_percentage by computing (v_member_count multiplied by 100.0) divided by v_total_members and applies the round function to the result using the p_precision parameter to determine the number of decimal places; following this calculation, the procedure uses an IF-THEN-ELSE conditional block: if v_member_count is greater than or equal to the p_min_members parameter, it executes an INSERT statement into the \"college\" table, specifying the columns \"College_ID\", \"Name\", \"Leader_Name\", and \"College_Location\", with values set to (v_member_count plus 100), the literal string 'High Membership College', the literal string 'System Generated', and the p_country parameter respectively; otherwise, if v_member_count is less than p_min_members, it executes a DELETE statement on the \"member\" table, removing all rows where the \"College_ID\" column equals p_college_id and the \"Country\" column equals p_country.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_college_membership(\n    p_college_id INTEGER,\n    p_country TEXT,\n    p_min_members INTEGER,\n    p_precision INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_count INTEGER;\n    v_percentage NUMERIC;\n    v_total_members INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO v_member_count\n    FROM \"member\"\n    WHERE \"College_ID\" = p_college_id AND \"Country\" = p_country;\n    \n    SELECT COUNT(*) INTO v_total_members\n    FROM \"member\";\n    \n    v_percentage := round((v_member_count * 100.0) / v_total_members, p_precision);\n    \n    IF v_member_count >= p_min_members THEN\n        INSERT INTO \"college\" (\"College_ID\", \"Name\", \"Leader_Name\", \"College_Location\")\n        VALUES (v_member_count + 100, 'High Membership College', 'System Generated', p_country);\n    ELSE\n        DELETE FROM \"member\" WHERE \"College_ID\" = p_college_id AND \"Country\" = p_country;\n    END IF;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member"
    ],
    "call_sqls": [
      "CALL analyze_college_membership(1, 'United States', 50, 2);",
      "CALL analyze_college_membership(2, 'Canada', 10, 1);",
      "CALL analyze_college_membership(4, 'United States', 100, 3);",
      "CALL analyze_college_membership(1, 'Canada', 5, 0);",
      "CALL analyze_college_membership(3, 'United States', 25, 2);"
    ],
    "summary": "Create a stored procedure named `analyze_college_membership` that takes four parameters: integer `p_college_id`, text `p_country`, integer `p_min_members`, and integer `p_precision`. It calculates the count of members for the given college and country, and the total count of all members. It then calculates the percentage (rounded to `p_precision` decimals) of the specific members out of the total. If the specific member count >= `p_min_members`, insert a new college row with a calculated ID, name 'High Membership College', leader 'System Generated', and location set to `p_country`. Otherwise, delete all member rows for that college and country.",
    "natural_language": "Please construct a stored procedure designated as `analyze_college_membership`. This procedure is to accept four input parameters: an integer `p_college_id`, a text value `p_country`, an integer `p_min_members`, and an integer `p_precision`. Its function is to compute the number of members associated with the specified college and country, as well as the aggregate count of all members. Subsequently, it shall calculate the proportion, expressed as a percentage and rounded to the number of decimal places indicated by `p_precision`, of the specific members relative to the total. Should the specific member count meet or exceed the threshold defined by `p_min_members`, the procedure must insert a new record into the college table. This new record should possess a calculated identifier, the name 'High Membership College', the leader designation 'System Generated', and its location set to the provided `p_country`. Conversely, if the specific member count is below the stated minimum, the procedure is to delete all member records corresponding to that college and country.",
    "id": 210
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named process_member_data that accepts four input parameters: a text parameter p_member_name representing a member's name, a text parameter p_country representing a member's country, an integer parameter p_college_id representing a college identifier, and an integer parameter p_new_member_id representing a new member identifier, and performs an upsert operation on the table named member by attempting to insert a new row with the column Member_ID set to the value of p_new_member_id, the column Name set to the value of p_member_name, the column Country set to the value of p_country, and the column College_ID set to the value of p_college_id, and if a conflict arises due to an existing row already having the same value in the Member_ID column, then instead of inserting, it updates the existing conflicting row by setting its Name column to the value of the EXCLUDED virtual row's Name column from the attempted insert, setting its Country column to the value of the EXCLUDED virtual row's Country column, and setting its College_ID column to the value of the EXCLUDED virtual row's College_ID column.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_member_data(\n    p_member_name TEXT,\n    p_country TEXT,\n    p_college_id INTEGER,\n    p_new_member_id INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\")\n    VALUES (p_new_member_id, p_member_name, p_country, p_college_id)\n    ON CONFLICT (\"Member_ID\") DO UPDATE\n    SET\n        \"Name\" = EXCLUDED.\"Name\",\n        \"Country\" = EXCLUDED.\"Country\",\n        \"College_ID\" = EXCLUDED.\"College_ID\";\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member"
    ],
    "call_sqls": [
      "CALL process_member_data('John Doe', 'United States', 1, 4);",
      "CALL process_member_data('Jane Smith', 'Canada', 2, 5);",
      "CALL process_member_data('Alice Johnson', 'United States', 3, 6);",
      "CALL process_member_data('Bob Brown', 'Canada', 1, 7);",
      "CALL process_member_data('Charlie Black', 'United States', 2, 8);"
    ],
    "summary": "Create a stored procedure named process_member_data that performs an upsert on the member table. It accepts parameters for member_id, name, country, and college_id. On conflict of member_id, update the existing row with the new values.",
    "natural_language": "Write a stored procedure called process_member_data to upsert the member table. The procedure should take member_id, name, country, and college_id as parameters. If a conflict on member_id occurs, update the existing record with the new parameter values.",
    "id": 211
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `manage_college_operations` that accepts four input parameters: `p_leader_name` of type `TEXT`, representing the name of a college leader; `p_location` of type `TEXT`, representing the location for a new college; `p_member_threshold` of type `INTEGER`, representing a minimum member count threshold; and `p_new_college_id` of type `INTEGER`, representing a unique identifier for a new college. The procedure first declares two local integer variables: `v_member_count` to store the count of members associated with a specific college leader, and `v_college_exists` to store a count indicating whether a college with a specific leader name already exists.\n\nThe procedure begins by executing a `SELECT COUNT(*)` statement to determine if a college with the `Leader_Name` matching the input `p_leader_name` already exists in the `\"college\"` table. The result of this count is stored in the `v_college_exists` variable.\n\nNext, the procedure executes another `SELECT COUNT(*)` statement to count the number of members associated with a college whose `Leader_Name` matches the input `p_leader_name`. This is achieved by joining the `\"member\"` table (aliased as `m`) with the `\"college\"` table (aliased as `c`) on the condition that `m.\"College_ID\"` equals `c.\"College_ID\"`, and then filtering the results where `c.\"Leader_Name\"` equals `p_leader_name`. The result of this member count is stored in the `v_member_count` variable.\n\nFollowing these data retrievals, the procedure enters a conditional block.\nIf `v_college_exists` is equal to `0` (meaning no college with the specified `p_leader_name` was found), the procedure executes an `INSERT` statement. This statement inserts a new row into the `\"college\"` table, populating the `\"College_ID\"` column with `p_new_college_id`, the `\"Name\"` column with the literal string `'New Leadership College'`, the `\"Leader_Name\"` column with `p_leader_name`, and the `\"College_Location\"` column with `p_location`.\nOtherwise, if `v_college_exists` is not `0` (meaning a college with the specified `p_leader_name` already exists), the procedure proceeds to an `ELSIF` condition. This condition checks if `v_member_count` is less than `p_member_threshold`. If this condition is true, the procedure executes a `DELETE` statement. This statement removes all rows from the `\"college\"` table where the `\"Leader_Name\"` column matches the input `p_leader_name`.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_college_operations(\n    p_leader_name TEXT,\n    p_location TEXT,\n    p_member_threshold INTEGER,\n    p_new_college_id INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_count INTEGER;\n    v_college_exists INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO v_college_exists\n    FROM \"college\"\n    WHERE \"Leader_Name\" = p_leader_name;\n    \n    SELECT COUNT(*) INTO v_member_count\n    FROM \"member\" m\n    JOIN \"college\" c ON m.\"College_ID\" = c.\"College_ID\"\n    WHERE c.\"Leader_Name\" = p_leader_name;\n    \n    IF v_college_exists = 0 THEN\n        INSERT INTO \"college\" (\"College_ID\", \"Name\", \"Leader_Name\", \"College_Location\")\n        VALUES (p_new_college_id, 'New Leadership College', p_leader_name, p_location);\n    ELSIF v_member_count < p_member_threshold THEN\n        DELETE FROM \"college\" WHERE \"Leader_Name\" = p_leader_name;\n    END IF;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member"
    ],
    "call_sqls": [
      "CALL manage_college_operations('John Smith', 'Toronto', 5, 100);",
      "CALL manage_college_operations('Ousame Tounkara', 'Vancouver', 10, 101);",
      "CALL manage_college_operations('Ryan Thelwell', 'Montreal', 1, 102);",
      "CALL manage_college_operations('Jane Doe', 'Calgary', 3, 103);",
      "CALL manage_college_operations('Andre Arlain', 'Edmonton', 0, 104);"
    ],
    "summary": "Create a stored procedure named manage_college_operations that accepts parameters for leader_name, location, member_threshold, and new_college_id. If no college exists for the leader, insert a new college. If a college exists and its member count is below the threshold, delete that college.",
    "natural_language": "Create a comprehensive stored procedure, to be named manage_college_operations, which must accept specific input parameters including the leader's full name, the precise geographical location, a defined numerical threshold for members, and a unique identifier for a new college. The procedure's logic should first check for the existence of a college associated with the provided leader. If no such college is found, it must meticulously insert a brand new college record using the supplied details. Conversely, if a college for that leader already exists within the system, the procedure should then carefully evaluate its current member count; should this count be determined to be regrettably below the specified threshold, the procedure must then proceed to permanently delete that particular college record.",
    "id": 212
  },
  {
    "ir": "Write a PLpgSQL stored procedure named redistribute_members that takes four parameters: p_source_college of type INTEGER, p_target_college of type INTEGER, p_country_filter of type TEXT, and p_batch_size of type INTEGER. The procedure begins by declaring two local variables, v_transfer_count and v_remaining_members, both of type INTEGER. It first performs a SELECT operation to count the number of members in the member table where the College_ID matches p_source_college and the Country matches p_country_filter, storing the result in v_transfer_count. If v_transfer_count exceeds p_batch_size, the procedure executes a DELETE operation on the member table to remove members whose Member_ID is in a subquery that selects Member_IDs from the member table with the same College_ID and Country conditions, limited by p_batch_size. Subsequently, it performs an INSERT operation into the member table, selecting Member_ID incremented by 1000, Name, Country, and p_target_college from the member table with the same College_ID and Country conditions, again limited by p_batch_size. Afterward, the procedure performs another SELECT operation to count the remaining members in the member table where College_ID matches p_source_college, storing the result in v_remaining_members. If v_remaining_members equals zero, it executes a DELETE operation on the college table to remove the row where College_ID matches p_source_college.",
    "plsql": "CREATE OR REPLACE PROCEDURE redistribute_members(\n    p_source_college INTEGER,\n    p_target_college INTEGER,\n    p_country_filter TEXT,\n    p_batch_size INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_transfer_count INTEGER;\n    v_remaining_members INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO v_transfer_count\n    FROM \"member\"\n    WHERE \"College_ID\" = p_source_college AND \"Country\" = p_country_filter;\n    \n    IF v_transfer_count > p_batch_size THEN\n        DELETE FROM \"member\"\n        WHERE \"Member_ID\" IN (\n            SELECT \"Member_ID\"\n            FROM \"member\"\n            WHERE \"College_ID\" = p_source_college AND \"Country\" = p_country_filter\n            LIMIT p_batch_size\n        );\n        \n        INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\")\n        SELECT \"Member_ID\" + 1000, \"Name\", \"Country\", p_target_college\n        FROM \"member\"\n        WHERE \"College_ID\" = p_source_college AND \"Country\" = p_country_filter\n        LIMIT p_batch_size;\n    END IF;\n    \n    SELECT COUNT(*) INTO v_remaining_members\n    FROM \"member\"\n    WHERE \"College_ID\" = p_source_college;\n    \n    IF v_remaining_members = 0 THEN\n        DELETE FROM \"college\" WHERE \"College_ID\" = p_source_college;\n    END IF;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member"
    ],
    "call_sqls": [
      "CALL redistribute_members(1, 2, 'United States', 1);",
      "CALL redistribute_members(1, 4, 'Canada', 2);",
      "CALL redistribute_members(3, 1, 'United States', 5);",
      "CALL redistribute_members(2, 3, 'Canada', 10);",
      "CALL redistribute_members(1, 2, 'United States', 100);"
    ],
    "summary": "Create a stored procedure named redistribute_members that transfers members from a source college to a target college. It accepts parameters for source_college, target_college, country_filter, and batch_size. Transfer members in batches. If the source college has no remaining members after the transfer, delete it from the college table.",
    "natural_language": "Write a stored procedure called 'redistribute_members' to move members from a source college to a target college in batches, using parameters for source_college, target_college, country_filter, and batch_size. After the transfer, delete the source college from the college table if it has no members left.",
    "id": 213
  },
  {
    "ir": "Write a PLpgSQL stored procedure named \"AddParticipantToEvent\" that accepts three parameters: \"eventId\" of type BIGINT, \"participantId\" of type BIGINT, and \"participantType\" of type TEXT. The procedure begins by checking if there exists a record in the \"Participants\" table where the \"Participant_ID\" column matches the value of \"participantId\" and the \"Participant_Type_Code\" column matches the value of \"participantType\". If such a record exists, the procedure proceeds to insert a new row into the \"Participants_in_Events\" table with the \"Event_ID\" column set to the value of \"eventId\" and the \"Participant_ID\" column set to the value of \"participantId\". The insertion operation is performed with an \"ON CONFLICT\" clause that specifies \"DO NOTHING\" if a conflict arises on the combination of \"Event_ID\" and \"Participant_ID\", meaning that if a row with the same \"Event_ID\" and \"Participant_ID\" already exists in the \"Participants_in_Events\" table, the insertion will be skipped without any error.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"AddParticipantToEvent\"(\"eventId\" BIGINT, \"participantId\" BIGINT, \"participantType\" TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Participants\" WHERE \"Participant_ID\" = \"participantId\" AND \"Participant_Type_Code\" = \"participantType\") THEN\n        INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\")\n        VALUES (\"eventId\", \"participantId\")\n        ON CONFLICT (\"Event_ID\", \"Participant_ID\") DO NOTHING;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "CALL \"AddParticipantToEvent\"(3, 9, 'Organizer');",
      "CALL \"AddParticipantToEvent\"(8, 26, 'Organizer');",
      "CALL \"AddParticipantToEvent\"(13, 28, 'Organizer');",
      "CALL \"AddParticipantToEvent\"(3, 26, 'Organizer');",
      "CALL \"AddParticipantToEvent\"(8, 9, 'Organizer');"
    ],
    "summary": "Create a stored procedure named AddParticipantToEvent that adds a participant to an event. It accepts parameters for event_id, participant_id, and participant_type. First, verify the participant exists. Then, insert the participant into the event, skipping if the combination already exists.",
    "natural_language": "Create AddParticipantToEvent procedure. Check participant exists, then add to event if not already present. Use event_id, participant_id, participant_type.",
    "id": 214
  },
  {
    "ir": "Write a PostgreSQL stored procedure named \"RemoveParticipantFromEvent\" that accepts three input parameters: \"eventId\" of type BIGINT, representing the unique identifier of an event; \"participantId\" of type BIGINT, representing the unique identifier of a participant; and \"serviceId\" of type BIGINT, representing the unique identifier of a service. This procedure performs a DELETE operation on the \"Participants_in_Events\" table. The rows to be deleted from \"Participants_in_Events\" are determined by two primary conditions: first, the value in the \"Event_ID\" column must exactly match the input parameter \"eventId\", and second, the value in the \"Participant_ID\" column must exactly match the input parameter \"participantId\". Additionally, an EXISTS subquery imposes a crucial third condition: a row will only be deleted if there exists at least one corresponding record in the \"Events\" table where the \"Event_ID\" column matches the input parameter \"eventId\" AND the \"Service_ID\" column matches the input parameter \"serviceId\". This ensures that a participant is only removed from an event if that event genuinely belongs to the specified service.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"RemoveParticipantFromEvent\"(\"eventId\" BIGINT, \"participantId\" BIGINT, \"serviceId\" BIGINT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Participants_in_Events\"\n    WHERE \"Event_ID\" = \"eventId\" AND \"Participant_ID\" = \"participantId\"\n    AND EXISTS (SELECT 1 FROM \"Events\" WHERE \"Event_ID\" = \"eventId\" AND \"Service_ID\" = \"serviceId\");\nEND;\n$$;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "CALL \"RemoveParticipantFromEvent\"(3, 26, 5);",
      "CALL \"RemoveParticipantFromEvent\"(8, 66, 8);",
      "CALL \"RemoveParticipantFromEvent\"(13, 86, 5);",
      "CALL \"RemoveParticipantFromEvent\"(3, 9, 5);",
      "CALL \"RemoveParticipantFromEvent\"(8, 28, 8);"
    ],
    "summary": "Create a stored procedure named RemoveParticipantFromEvent that removes a participant from an event. It accepts parameters for event_id, participant_id, and service_id. Delete the participant from the event only if the event belongs to the specified service.",
    "natural_language": "Hey, can you whip up a stored procedure called RemoveParticipantFromEvent? It should boot a participant from an event. You'll need to feed it the event_id, participant_id, and service_id. Only go ahead and delete the person if the event actually belongs to that service.",
    "id": 215
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_mountain_photo_data` that takes no parameters. The procedure begins by declaring several local variables: `mountain_count` of type `INTEGER`, `photo_count` of type `INTEGER`, `lens_count` of type `INTEGER`, `avg_height` of type `REAL`, `max_prominence` of type `REAL`, `min_focal_length` of type `REAL`, `high_mountain_id` of type `INTEGER`, `low_mountain_id` of type `INTEGER`, `premium_lens_id` of type `INTEGER`, and `basic_lens_id` of type `INTEGER`.\n\nThe procedure then proceeds to populate these variables with data retrieved from various tables:\n1. It selects the total number of rows from the `mountain` table and stores this count in the `mountain_count` variable.\n2. It selects the total number of rows from the `photos` table and stores this count in the `photo_count` variable.\n3. It selects the total number of rows from the `camera_lens` table and stores this count in the `lens_count` variable.\n4. It calculates the average value of the `\"Height\"` column from the `mountain` table and stores this average in the `avg_height` variable.\n5. It calculates the maximum value of the `\"Prominence\"` column from the `mountain` table and stores this maximum in the `max_prominence` variable.\n6. It calculates the minimum value of the `focal_length_mm` column from the `camera_lens` table and stores this minimum in the `min_focal_length` variable.\n\nFollowing these initial data retrievals, the procedure enters a series of conditional logic blocks based primarily on the `mountain_count` variable:\n\n**First Conditional Block:**\nIf `mountain_count` is greater than 100:\n    1. It selects the `id` of the first mountain found where the `\"Height\"` is greater than the previously calculated `avg_height` and stores this `id` in the `high_mountain_id` variable.\n    2. It then enters a nested conditional block based on `photo_count`:\n        *   If `photo_count` is greater than 50:\n            It inserts a new row into the `photos` table. The `id` column is set to its default value, `camera_lens_id` is set to `1`, `mountain_id` is set to the value of `high_mountain_id`, `color` is set to `'Color'`, and `name` is set to `'summit_view'`.\n        *   Else if `lens_count` is greater than 20:\n            It inserts a new row into the `camera_lens` table. The `id` column is set to its default value, `brand` is set to `'Canon'`, `name` is set to `'EF 24-70mm'`, `focal_length_mm` is set to `50.0`, and `max_aperture` is set to `2.8`.\n        *   Else (if `photo_count` is not greater than 50 and `lens_count` is not greater than 20):\n            It deletes rows from the `photos` table where the `mountain_id` is present in the set of `id`s from the `mountain` table where `\"Height\"` is less than `3000`.\n\n**Second Conditional Block (Else If for `mountain_count`):**\nElse if `mountain_count` is greater than 50 (meaning `mountain_count` is between 51 and 100, inclusive):\n    1. It selects the `id` of the first mountain found where the `\"Height\"` is less than the previously calculated `avg_height` and stores this `id` in the `low_mountain_id` variable.\n    2. It then enters a nested conditional block based on `max_prominence` and `min_focal_length`:\n        *   If `max_prominence` is greater than `2000`:\n            It inserts a new row into the `mountain` table. The `id` column is set to its default value, `name` is set to `'New Peak'`, `\"Height\"` is set to `4500`, `\"Prominence\"` is set to `1800`, `\"Range\"` is set to `'Test Range'`, and `\"Country\"` is set to `'Test Country'`.\n        *   Else if `min_focal_length` is less than `20`:\n            It deletes rows from the `camera_lens` table where `focal_length_mm` is less than `15`.\n        *   Else (if `max_prominence` is not greater than 2000 and `min_focal_length` is not less than 20):\n            It inserts a new row into the `photos` table. The `id` column is set to its default value, `camera_lens_id` is set to `2`, `mountain_id` is set to the value of `low_mountain_id`, `color` is set to `'Sepia'`, and `name` is set to `'valley_shot'`.\n\n**Third Conditional Block (Else for `mountain_count`):**\nElse (if `mountain_count` is 50 or less):\n    1. It selects the `id` of the first camera lens found where `max_aperture` is less than `2.0` and stores this `id` in the `premium_lens_id` variable.\n    2. It then enters a nested conditional block based on `premium_lens_id` and `photo_count`:\n        *   If `premium_lens_id` is not `NULL`:\n            It inserts a new row into the `photos` table. The `id` column is set to its default value, `camera_lens_id` is set to the value of `premium_lens_id`, `mountain_id` is set to `1`, `color` is set to `'HDR'`, and `name` is set to `'premium_capture'`.\n        *   Else if `photo_count` is less than `10`:\n            It inserts a new row into the `mountain` table. The `id` column is set to its default value, `name` is set to `'Backup Mountain'`, `\"Height\"` is set to `3500`, `\"Prominence\"` is set to `1200`, `\"Range\"` is set to `'Backup Range'`, and `\"Country\"` is set to `'Backup Country'`.\n        *   Else (if `premium_lens_id` is `NULL` and `photo_count` is not less than 10):\n            It deletes rows from the `photos` table where the `color` column is equal to `'Black/White'`.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_mountain_photo_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    mountain_count INTEGER;\n    photo_count INTEGER;\n    lens_count INTEGER;\n    avg_height REAL;\n    max_prominence REAL;\n    min_focal_length REAL;\n    high_mountain_id INTEGER;\n    low_mountain_id INTEGER;\n    premium_lens_id INTEGER;\n    basic_lens_id INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO mountain_count FROM mountain;\n    SELECT COUNT(*) INTO photo_count FROM photos;\n    SELECT COUNT(*) INTO lens_count FROM camera_lens;\n    SELECT AVG(\"Height\") INTO avg_height FROM mountain;\n    SELECT MAX(\"Prominence\") INTO max_prominence FROM mountain;\n    SELECT MIN(focal_length_mm) INTO min_focal_length FROM camera_lens;\n    \n    IF mountain_count > 100 THEN\n        SELECT id INTO high_mountain_id FROM mountain WHERE \"Height\" > avg_height LIMIT 1;\n        IF photo_count > 50 THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 1, high_mountain_id, 'Color', 'summit_view');\n        ELSIF lens_count > 20 THEN\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Canon', 'EF 24-70mm', 50.0, 2.8);\n        ELSE\n            DELETE FROM photos WHERE mountain_id IN (SELECT id FROM mountain WHERE \"Height\" < 3000);\n        END IF;\n    ELSIF mountain_count > 50 THEN\n        SELECT id INTO low_mountain_id FROM mountain WHERE \"Height\" < avg_height LIMIT 1;\n        IF max_prominence > 2000 THEN\n            INSERT INTO mountain (id, name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES (DEFAULT, 'New Peak', 4500, 1800, 'Test Range', 'Test Country');\n        ELSIF min_focal_length < 20 THEN\n            DELETE FROM camera_lens WHERE focal_length_mm < 15;\n        ELSE\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 2, low_mountain_id, 'Sepia', 'valley_shot');\n        END IF;\n    ELSE\n        SELECT id INTO premium_lens_id FROM camera_lens WHERE max_aperture < 2.0 LIMIT 1;\n        IF premium_lens_id IS NOT NULL THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, premium_lens_id, 1, 'HDR', 'premium_capture');\n        ELSIF photo_count < 10 THEN\n            INSERT INTO mountain (id, name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES (DEFAULT, 'Backup Mountain', 3500, 1200, 'Backup Range', 'Backup Country');\n        ELSE\n            DELETE FROM photos WHERE color = 'Black/White';\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL process_mountain_photo_data();"
    ],
    "summary": "Create a stored procedure named `process_mountain_photo_data` with no parameters. Declare variables for counts of mountains, photos, and lenses, as well as for average height, maximum prominence, minimum focal length, and IDs for high/low mountains and premium/basic lenses. Populate these variables by selecting counts from the mountain, photos, and camera_lens tables, and calculating aggregates from the mountain and camera_lens tables. Then, implement conditional logic: If the mountain count exceeds 100, find a high mountain ID and, based on photo and lens counts, either insert a new photo, insert a new lens, or delete photos of low mountains. If the mountain count is between 51 and 100, find a low mountain ID and, based on prominence and focal length, either insert a new mountain, delete short lenses, or insert a sepia photo. If the mountain count is 50 or less, find a premium lens ID and, based on its existence and photo count, either insert a photo with that lens, insert a backup mountain, or delete black-and-white photos.",
    "natural_language": "Please construct a stored procedure designated as `process_mountain_photo_data` that accepts no parameters. Within this procedure, it is necessary to declare variables to hold the following: the counts of mountains, photographs, and camera lenses; the average height and maximum prominence of mountains; the minimum focal length of lenses; and specific identifiers for high and low mountains as well as for premium and basic lenses. These variables should be populated by executing SELECT statements to obtain counts from the mountain, photos, and camera_lens tables, and to compute aggregate values from the mountain and camera_lens tables.\n\nSubsequently, implement conditional logic as follows:\n- Should the mountain count exceed 100, ascertain the identifier of a high mountain. Then, depending on the counts of photographs and lenses, execute one of the following actions: insert a new photograph, insert a new lens, or delete photographs associated with low mountains.\n- If the mountain count is determined to be between 51 and 100, inclusive, ascertain the identifier of a low mountain. Based on the values for maximum prominence and minimum focal length, proceed with one of these operations: insert a new mountain record, delete lenses with short focal lengths, or insert a photograph with a sepia tone.\n- In the event the mountain count is 50 or fewer, ascertain the identifier of a premium lens. Depending on the existence of such a lens and the total photo count, perform one of the following: insert a photograph utilizing that lens, insert a backup mountain record, or delete all black-and-white photographs.",
    "id": 216
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `analyze_photography_metrics` that takes no parameters. The procedure begins by declaring several local variables: `total_photos` of type `INTEGER`, `color_photos` of type `INTEGER`, `bw_photos` of type `INTEGER`, `wide_lens_count` of type `INTEGER`, `tele_lens_count` of type `INTEGER`, `high_mountains` of type `INTEGER`, `low_mountains` of type `INTEGER`, `ethiopian_peaks` of type `INTEGER`, `log_height` of type `REAL`, and `log_prominence` of type `REAL`.\n\nThe procedure then proceeds to populate these variables with counts from various tables:\n1. It selects the total number of rows from the `photos` table and stores this count into the `total_photos` variable.\n2. It selects the number of rows from the `photos` table where the `color` column is equal to the string 'RBG' and stores this count into the `color_photos` variable.\n3. It selects the number of rows from the `photos` table where the `color` column is equal to the string 'Black/White' and stores this count into the `bw_photos` variable.\n4. It selects the number of rows from the `camera_lens` table where the `focal_length_mm` column is less than 35 and stores this count into the `wide_lens_count` variable.\n5. It selects the number of rows from the `camera_lens` table where the `focal_length_mm` column is greater than 85 and stores this count into the `tele_lens_count` variable.\n6. It selects the number of rows from the `mountain` table where the `Height` column is greater than 4000 and stores this count into the `high_mountains` variable.\n7. It selects the number of rows from the `mountain` table where the `Height` column is less than 4000 and stores this count into the `low_mountains` variable.\n8. It selects the number of rows from the `mountain` table where the `Country` column is equal to the string 'Ethiopia' and stores this count into the `ethiopian_peaks` variable.\n\nFollowing these initial data retrievals, the procedure executes a series of conditional logic blocks based on the value of `total_photos`:\n\n**First Conditional Block:** If `total_photos` is greater than 100:\n    *   **Nested Conditional Block 1.1:** If `color_photos` is greater than `bw_photos`:\n        *   It calculates the natural logarithm of the `Height` column from the `mountain` table where the `id` column is equal to 1, and stores the result into the `log_height` variable.\n        *   It inserts a new row into the `photos` table with `id` set to its default value, `camera_lens_id` set to 1, `mountain_id` set to 1, `color` set to 'Color', and `name` set to 'test_shot'.\n    *   **Nested Conditional Block 1.2:** Else if `wide_lens_count` is greater than `tele_lens_count`:\n        *   It deletes rows from the `photos` table where the `camera_lens_id` column is present in the set of `id` values retrieved from the `camera_lens` table where `focal_length_mm` is greater than 200.\n    *   **Nested Conditional Block 1.3:** Else (if neither of the above conditions in the first nested block are met):\n        *   It inserts a new row into the `camera_lens` table with `id` set to its default value, `brand` set to 'Nikon', `name` set to 'AF-S 85mm', `focal_length_mm` set to 85.0, and `max_aperture` set to 1.4.\n\n**Second Conditional Block:** Else if `total_photos` is greater than 50 (and not greater than 100):\n    *   **Nested Conditional Block 2.1:** If `high_mountains` is greater than `low_mountains`:\n        *   It calculates the natural logarithm of the `Prominence` column from the `mountain` table where the `Prominence` column is greater than 1000, limiting the result to the first row found, and stores this value into the `log_prominence` variable.\n        *   It deletes rows from the `mountain` table where the `Height` column is less than 3500.\n    *   **Nested Conditional Block 2.2:** Else if `ethiopian_peaks` is greater than 10:\n        *   It inserts a new row into the `mountain` table with `id` set to its default value, `name` set to 'Test Peak', `Height` set to 4200, `Prominence` set to 1500, `Range` set to 'Test Massif', and `Country` set to 'Ethiopia'.\n    *   **Nested Conditional Block 2.3:** Else (if neither of the above conditions in the second nested block are met):\n        *   It deletes rows from the `photos` table where the `name` column is equal to the string 'deers'.\n\n**Third Conditional Block:** Else (if `total_photos` is not greater than 50):\n    *   **Nested Conditional Block 3.1:** If `wide_lens_count` is greater than 5:\n        *   It inserts a new row into the `photos` table with `id` set to its default value, `camera_lens_id` set to 2, `mountain_id` set to 2, `color` set to 'Vintage', and `name` set to 'landscape'.\n    *   **Nested Conditional Block 3.2:** Else if `tele_lens_count` is greater than 3:\n        *   It deletes rows from the `camera_lens` table where the `max_aperture` column is greater than 5.6.\n    *   **Nested Conditional Block 3.3:** Else (if neither of the above conditions in the third nested block are met):\n        *   It inserts a new row into the `mountain` table with `id` set to its default value, `name` set to 'Final Peak', `Height` set to 3800, `Prominence` set to 900, `Range` set to 'Final Range', and `Country` set to 'Test Nation'.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_photography_metrics()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_photos INTEGER;\n    color_photos INTEGER;\n    bw_photos INTEGER;\n    wide_lens_count INTEGER;\n    tele_lens_count INTEGER;\n    high_mountains INTEGER;\n    low_mountains INTEGER;\n    ethiopian_peaks INTEGER;\n    log_height REAL;\n    log_prominence REAL;\nBEGIN\n    SELECT COUNT(*) INTO total_photos FROM photos;\n    SELECT COUNT(*) INTO color_photos FROM photos WHERE color = 'RBG';\n    SELECT COUNT(*) INTO bw_photos FROM photos WHERE color = 'Black/White';\n    SELECT COUNT(*) INTO wide_lens_count FROM camera_lens WHERE focal_length_mm < 35;\n    SELECT COUNT(*) INTO tele_lens_count FROM camera_lens WHERE focal_length_mm > 85;\n    SELECT COUNT(*) INTO high_mountains FROM mountain WHERE \"Height\" > 4000;\n    SELECT COUNT(*) INTO low_mountains FROM mountain WHERE \"Height\" < 4000;\n    SELECT COUNT(*) INTO ethiopian_peaks FROM mountain WHERE \"Country\" = 'Ethiopia';\n    \n    IF total_photos > 100 THEN\n        IF color_photos > bw_photos THEN\n            SELECT ln(\"Height\") INTO log_height FROM mountain WHERE id = 1;\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 1, 1, 'Color', 'test_shot');\n        ELSIF wide_lens_count > tele_lens_count THEN\n            DELETE FROM photos WHERE camera_lens_id IN (SELECT id FROM camera_lens WHERE focal_length_mm > 200);\n        ELSE\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Nikon', 'AF-S 85mm', 85.0, 1.4);\n        END IF;\n    ELSIF total_photos > 50 THEN\n        IF high_mountains > low_mountains THEN\n            SELECT ln(\"Prominence\") INTO log_prominence FROM mountain WHERE \"Prominence\" > 1000 LIMIT 1;\n            DELETE FROM mountain WHERE \"Height\" < 3500;\n        ELSIF ethiopian_peaks > 10 THEN\n            INSERT INTO mountain (id, name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES (DEFAULT, 'Test Peak', 4200, 1500, 'Test Massif', 'Ethiopia');\n        ELSE\n            DELETE FROM photos WHERE name = 'deers';\n        END IF;\n    ELSE\n        IF wide_lens_count > 5 THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 2, 2, 'Vintage', 'landscape');\n        ELSIF tele_lens_count > 3 THEN\n            DELETE FROM camera_lens WHERE max_aperture > 5.6;\n        ELSE\n            INSERT INTO mountain (id, name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES (DEFAULT, 'Final Peak', 3800, 900, 'Final Range', 'Test Nation');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL analyze_photography_metrics();"
    ],
    "summary": "Create a stored procedure named `analyze_photography_metrics` with no parameters. Declare variables for total, color, and black-and-white photo counts, wide and telephoto lens counts, high and low mountain counts, Ethiopian peak count, and logarithmic values for height and prominence. Populate these variables by selecting counts from the photos, camera_lens, and mountain tables with specific filters. Then, implement conditional logic based on total photos: If over 100, based on color vs. black-and-white photos or wide vs. telephoto lenses, either insert a test photo, delete photos taken with very long lenses, or insert a new lens. If between 51 and 100, based on high vs. low mountain counts or Ethiopian peak count, either calculate a log prominence and delete low mountains, insert a test mountain in Ethiopia, or delete photos named 'deers'. If 50 or less, based on wide or telephoto lens counts, either insert a vintage landscape photo, delete lenses with high aperture, or insert a final mountain.",
    "natural_language": "Alright, so we need to whip up a stored procedure called `analyze_photography_metrics` that doesn't take any parameters. First off, we gotta set up some variables to hold stuff like the total number of photos, how many are color vs. black-and-white, counts for wide and telephoto lenses, tall and short mountain tallies, how many peaks are in Ethiopia, and some log math for height and prominence. We'll fill these in by pulling counts from the photos, camera_lens, and mountain tables with certain conditions.\n\nNow, here's the fun part with the if-then logic based on the total photo count:\n- If we've got over 100 photos total, we check out the color vs. black-and-white split or the wide vs. telephoto lens situation. Depending on what we find, we either add a dummy photo, get rid of pics taken with super long lenses, or toss in a new lens.\n- If the total is between 51 and 100, we look at the high vs. low mountain numbers or that Ethiopian peak count. Based on that, we either crunch a log for prominence and delete the puny mountains, add a test mountain in Ethiopia, or delete any photos tagged as 'deers'.\n- If it's 50 photos or fewer, we check the wide or telephoto lens counts. Then we either add a vintage landscape shot, delete lenses with a really high aperture, or insert one last mountain record.",
    "id": 217
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_equipment_inventory that performs several operations on the camera_lens table. It begins by declaring integer variables to store counts of different types of camera lenses based on brand and specifications. The procedure then executes multiple SELECT COUNT(*) queries to populate these variables: olympus_count, canon_count, and nikon_count store the number of lenses for the brands 'Olympus', 'Canon', and 'Nikon', respectively; fast_lens_count and slow_lens_count store counts of lenses with max_aperture less than 2.0 and greater than 4.0, respectively; macro_lens_count stores the count of lenses with focal_length_mm between 90 and 105; wide_lens_count, standard_lens_count, tele_lens_count, and super_tele_count store counts of lenses with focal_length_mm less than 24, between 24 and 70, between 70 and 200, and greater than 200, respectively. The procedure then uses conditional logic to compare these counts and perform different actions based on the results. If olympus_count is greater than canon_count, it checks if fast_lens_count is greater than slow_lens_count and inserts a new lens with brand 'Sony', name 'FE 24-70mm', focal_length_mm 50.0, and max_aperture 2.8 into the camera_lens table; if not, it checks if macro_lens_count is greater than 0 and deletes lenses with focal_length_mm greater than 300; otherwise, it inserts a lens with brand 'Fuji', name 'XF 56mm', focal_length_mm 56.0, and max_aperture 1.2. If canon_count is greater than nikon_count, it checks if wide_lens_count is greater than standard_lens_count and inserts a lens with brand 'Sigma', name '14-24mm', focal_length_mm 19.0, and max_aperture 2.8; if not, it checks if tele_lens_count is greater than super_tele_count and deletes lenses with max_aperture greater than 8.0; otherwise, it inserts a lens with brand 'Tamron', name '70-200mm', focal_length_mm 135.0, and max_aperture 2.8. If neither of the previous conditions is true, it checks if standard_lens_count is greater than tele_lens_count and inserts a lens with brand 'Pentax', name 'DA 18-55mm', focal_length_mm 35.0, and max_aperture 3.5; if not, it checks if super_tele_count is greater than 0 and deletes lenses with focal_length_mm less than 10; otherwise, it inserts a lens with brand 'Leica', name 'Summilux 50mm', focal_length_mm 50.0, and max_aperture 1.4.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_equipment_inventory()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    olympus_count INTEGER;\n    canon_count INTEGER;\n    nikon_count INTEGER;\n    fast_lens_count INTEGER;\n    slow_lens_count INTEGER;\n    macro_lens_count INTEGER;\n    wide_lens_count INTEGER;\n    standard_lens_count INTEGER;\n    tele_lens_count INTEGER;\n    super_tele_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO olympus_count FROM camera_lens WHERE brand = 'Olympus';\n    SELECT COUNT(*) INTO canon_count FROM camera_lens WHERE brand = 'Canon';\n    SELECT COUNT(*) INTO nikon_count FROM camera_lens WHERE brand = 'Nikon';\n    SELECT COUNT(*) INTO fast_lens_count FROM camera_lens WHERE max_aperture < 2.0;\n    SELECT COUNT(*) INTO slow_lens_count FROM camera_lens WHERE max_aperture > 4.0;\n    SELECT COUNT(*) INTO macro_lens_count FROM camera_lens WHERE focal_length_mm BETWEEN 90 AND 105;\n    SELECT COUNT(*) INTO wide_lens_count FROM camera_lens WHERE focal_length_mm < 24;\n    SELECT COUNT(*) INTO standard_lens_count FROM camera_lens WHERE focal_length_mm BETWEEN 24 AND 70;\n    SELECT COUNT(*) INTO tele_lens_count FROM camera_lens WHERE focal_length_mm BETWEEN 70 AND 200;\n    SELECT COUNT(*) INTO super_tele_count FROM camera_lens WHERE focal_length_mm > 200;\n    \n    IF olympus_count > canon_count THEN\n        IF fast_lens_count > slow_lens_count THEN\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Sony', 'FE 24-70mm', 50.0, 2.8);\n        ELSIF macro_lens_count > 0 THEN\n            DELETE FROM camera_lens WHERE focal_length_mm > 300;\n        ELSE\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Fuji', 'XF 56mm', 56.0, 1.2);\n        END IF;\n    ELSIF canon_count > nikon_count THEN\n        IF wide_lens_count > standard_lens_count THEN\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Sigma', '14-24mm', 19.0, 2.8);\n        ELSIF tele_lens_count > super_tele_count THEN\n            DELETE FROM camera_lens WHERE max_aperture > 8.0;\n        ELSE\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Tamron', '70-200mm', 135.0, 2.8);\n        END IF;\n    ELSE\n        IF standard_lens_count > tele_lens_count THEN\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Pentax', 'DA 18-55mm', 35.0, 3.5);\n        ELSIF super_tele_count > 0 THEN\n            DELETE FROM camera_lens WHERE focal_length_mm < 10;\n        ELSE\n            INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (DEFAULT, 'Leica', 'Summilux 50mm', 50.0, 1.4);\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL manage_equipment_inventory();"
    ],
    "summary": "Create a stored procedure named `manage_equipment_inventory` with no parameters. Declare variables to store counts of camera lenses by brand (Olympus, Canon, Nikon), by aperture (fast, slow), by macro range, and by focal length categories (wide, standard, telephoto, super-telephoto). Populate these variables by selecting counts from the camera_lens table with specific filters for each category. Then, implement conditional logic: If Olympus lenses outnumber Canon lenses, check fast vs. slow lens counts or macro lens count to either insert a Sony lens, delete very long lenses, or insert a Fuji lens. If Canon lenses outnumber Nikon lenses, check wide vs. standard lens counts or telephoto vs. super-telephoto counts to either insert a Sigma lens, delete high-aperture lenses, or insert a Tamron lens. Otherwise, check standard vs. telephoto lens counts or super-telephoto count to either insert a Pentax lens, delete very short lenses, or insert a Leica lens.",
    "natural_language": "Alright, so I need you to whip up a stored procedure called `manage_equipment_inventory`â€”no parameters needed. First, set up some variables to keep track of how many camera lenses we've got. We're talking counts by brand (like Olympus, Canon, Nikon), by how fast the aperture is (fast or slow), by if they're macro, and by focal length (wide, standard, telephoto, super-telephoto). Grab these counts from the `camera_lens` table, using the right filters for each group.\n\nNow, here's the fun part with the if-then logic:\n*   If we've got more Olympus lenses than Canon ones, then take a look at the fast vs. slow lens counts or the macro lens count. Depending on what you find, either add a Sony lens, get rid of the super long lenses, or pop in a Fuji lens.\n*   If, on the other hand, Canon beats Nikon, then check the wide vs. standard lens counts or the telephoto vs. super-telephoto counts. Based on that, you'd either insert a Sigma lens, delete the high-aperture ones, or add a Tamron lens.\n*   If neither of those is true, then just compare the standard vs. telephoto counts or look at the super-telephoto number. Then, either slot in a Pentax lens, delete the really short lenses, or throw in a Leica lens.",
    "id": 218
  },
  {
    "ir": "Write a PLpgSQL stored procedure named optimize_photo_collection that takes no parameters and begins by declaring eleven integer variables: rabbit_photos, monkey_photos, deer_photos, rgb_photos, bw_photos, sepia_photos, mountain_1_photos, mountain_2_photos, mountain_20_photos, lens_1_photos, and lens_10_photos. It then performs a series of eleven separate SELECT COUNT(*) queries from the photos table, each storing the result into one of the declared variables: the first query counts rows where the name column equals 'rabbits' into rabbit_photos; the second counts rows where name equals 'monkey' into monkey_photos; the third counts rows where name equals 'deers' into deer_photos; the fourth counts rows where the color column equals 'RBG' into rgb_photos; the fifth counts rows where color equals 'Black/White' into bw_photos; the sixth counts rows where color equals 'Sepia' into sepia_photos; the seventh counts rows where the mountain_id column equals 1 into mountain_1_photos; the eighth counts rows where mountain_id equals 2 into mountain_2_photos; the ninth counts rows where mountain_id equals 20 into mountain_20_photos; the tenth counts rows where the camera_lens_id column equals 1 into lens_1_photos; and the eleventh counts rows where camera_lens_id equals 10 into lens_10_photos. The procedure then enters a main conditional block: if rabbit_photos is greater than monkey_photos, it enters a nested conditional where, if rgb_photos is greater than bw_photos, it executes a DELETE operation on the photos table for rows where the name column is 'deers' and the color column is 'Black/White'; otherwise, if the first nested condition is false and mountain_1_photos is greater than mountain_2_photos, it executes an INSERT operation into the photos table, providing values for the columns id (using the DEFAULT keyword), camera_lens_id (set to 1), mountain_id (set to 3), color (set to 'Color'), and name (set to 'wildlife'); otherwise, if neither nested condition is true, it executes a DELETE operation on the photos table for rows where camera_lens_id equals 10 and mountain_id equals 20. If the initial condition is false and monkey_photos is greater than deer_photos, it enters a different nested conditional where, if sepia_photos is greater than 0, it executes an INSERT into the photos table with values id (DEFAULT), camera_lens_id (2), mountain_id (1), color ('HDR'), and name ('landscape'); otherwise, if that condition is false and mountain_20_photos is greater than mountain_1_photos, it executes a DELETE from the photos table for rows where the color column equals 'Sepia'; otherwise, it executes an INSERT into the photos table with values id (DEFAULT), camera_lens_id (10), mountain_id (2), color ('Vintage'), and name ('nature'). If neither of the two main initial conditions is true (i.e., rabbit_photos is not greater than monkey_photos and monkey_photos is not greater than deer_photos), it enters a final else block with a nested conditional: if lens_1_photos is greater than lens_10_photos, it executes a DELETE from the photos table for rows where the name column equals 'monkey' and the mountain_id column equals 1; otherwise, if that condition is false and bw_photos is greater than rgb_photos, it executes an INSERT into the photos table with values id (DEFAULT), camera_lens_id (1), mountain_id (20), color ('Monochrome'), and name ('artistic'); otherwise, it executes a DELETE from the photos table for rows where camera_lens_id equals 1 and the color column equals 'RBG'.",
    "plsql": "CREATE OR REPLACE PROCEDURE optimize_photo_collection()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    rabbit_photos INTEGER;\n    monkey_photos INTEGER;\n    deer_photos INTEGER;\n    rgb_photos INTEGER;\n    bw_photos INTEGER;\n    sepia_photos INTEGER;\n    mountain_1_photos INTEGER;\n    mountain_2_photos INTEGER;\n    mountain_20_photos INTEGER;\n    lens_1_photos INTEGER;\n    lens_10_photos INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO rabbit_photos FROM photos WHERE name = 'rabbits';\n    SELECT COUNT(*) INTO monkey_photos FROM photos WHERE name = 'monkey';\n    SELECT COUNT(*) INTO deer_photos FROM photos WHERE name = 'deers';\n    SELECT COUNT(*) INTO rgb_photos FROM photos WHERE color = 'RBG';\n    SELECT COUNT(*) INTO bw_photos FROM photos WHERE color = 'Black/White';\n    SELECT COUNT(*) INTO sepia_photos FROM photos WHERE color = 'Sepia';\n    SELECT COUNT(*) INTO mountain_1_photos FROM photos WHERE mountain_id = 1;\n    SELECT COUNT(*) INTO mountain_2_photos FROM photos WHERE mountain_id = 2;\n    SELECT COUNT(*) INTO mountain_20_photos FROM photos WHERE mountain_id = 20;\n    SELECT COUNT(*) INTO lens_1_photos FROM photos WHERE camera_lens_id = 1;\n    SELECT COUNT(*) INTO lens_10_photos FROM photos WHERE camera_lens_id = 10;\n    \n    IF rabbit_photos > monkey_photos THEN\n        IF rgb_photos > bw_photos THEN\n            DELETE FROM photos WHERE name = 'deers' AND color = 'Black/White';\n        ELSIF mountain_1_photos > mountain_2_photos THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 1, 3, 'Color', 'wildlife');\n        ELSE\n            DELETE FROM photos WHERE camera_lens_id = 10 AND mountain_id = 20;\n        END IF;\n    ELSIF monkey_photos > deer_photos THEN\n        IF sepia_photos > 0 THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 2, 1, 'HDR', 'landscape');\n        ELSIF mountain_20_photos > mountain_1_photos THEN\n            DELETE FROM photos WHERE color = 'Sepia';\n        ELSE\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 10, 2, 'Vintage', 'nature');\n        END IF;\n    ELSE\n        IF lens_1_photos > lens_10_photos THEN\n            DELETE FROM photos WHERE name = 'monkey' AND mountain_id = 1;\n        ELSIF bw_photos > rgb_photos THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (DEFAULT, 1, 20, 'Monochrome', 'artistic');\n        ELSE\n            DELETE FROM photos WHERE camera_lens_id = 1 AND color = 'RBG';\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL optimize_photo_collection();"
    ],
    "summary": "Create a stored procedure named `optimize_photo_collection` with no parameters. Declare integer variables for counts of photos by name (rabbits, monkey, deers), by color (RBG, Black/White, Sepia), by mountain_id (1, 2, 20), and by camera_lens_id (1, 10). Populate these variables by selecting counts from the photos table with specific filters for each variable. Then, implement conditional logic: If rabbit photos exceed monkey photos, check if RBG photos exceed Black/White photos or if photos for mountain 1 exceed those for mountain 2, to either delete specific deer photos, insert a wildlife photo, or delete photos with lens 10 and mountain 20. If monkey photos exceed deer photos, check if Sepia photos exist or if photos for mountain 20 exceed those for mountain 1, to either insert an HDR landscape photo, delete Sepia photos, or insert a vintage nature photo. Otherwise, check if photos with lens 1 exceed those with lens 10 or if Black/White photos exceed RBG photos, to either delete specific monkey photos, insert an artistic monochrome photo, or delete photos with lens 1 and RBG color.",
    "natural_language": "How can I create a stored procedure named `optimize_photo_collection` with no parameters? The procedure should declare integer variables to count photos by name (such as rabbits, monkey, and deers), by color (like RBG, Black/White, and Sepia), by mountain_id (specifically 1, 2, and 20), and by camera_lens_id (1 and 10). How do I populate these variables by selecting counts from the photos table with specific filters for each? Then, what conditional logic should be implemented? For instance, if rabbit photos exceed monkey photos, how do I check whether RBG photos exceed Black/White photos or if photos for mountain 1 exceed those for mountain 2, in order to decide whether to delete specific deer photos, insert a wildlife photo, or delete photos with lens 10 and mountain 20? Alternatively, if monkey photos exceed deer photos, how do I check if Sepia photos exist or if photos for mountain 20 exceed those for mountain 1, to determine whether to insert an HDR landscape photo, delete Sepia photos, or insert a vintage nature photo? Otherwise, if neither of those conditions is true, how do I check if photos with lens 1 exceed those with lens 10 or if Black/White photos exceed RBG photos, to choose between deleting specific monkey photos, inserting an artistic monochrome photo, or deleting photos with lens 1 and RBG color?",
    "id": 219
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `archive_old_institutions` that accepts two input parameters: `p_founded_before` of type `real`, which represents a threshold year or date before which institutions were founded, and `p_city_name` of type `text`, which represents the name of the city where institutions are located. The procedure first declares a local variable `v_total_capacity` of type `real` to store the sum of capacities. It then executes a `SELECT` statement to calculate the sum of the `Capacity` column from the `institution` table. This sum is filtered by two conditions: the `City` column must be equal to the value provided in the `p_city_name` parameter, and the `Founded` column must be less than the value provided in the `p_founded_before` parameter. The result of this sum is stored into the `v_total_capacity` variable. Following this, the procedure performs a `DELETE` operation on the `Championship` table. The rows to be deleted are determined by a subquery that selects `Institution_ID` values from the `institution` table. This subquery also applies the same two filtering conditions: the `City` column must match `p_city_name`, and the `Founded` column must be less than `p_founded_before`. Finally, the procedure executes another `DELETE` operation, this time on the `institution` table itself. This `DELETE` statement removes rows from the `institution` table where the `City` column matches the `p_city_name` parameter and the `Founded` column is less than the `p_founded_before` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_institutions(\n    p_founded_before real,\n    p_city_name text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_capacity real;\nBEGIN\n    SELECT SUM(\"institution\".\"Capacity\") INTO v_total_capacity\n    FROM \"institution\"\n    WHERE \"City\" = p_city_name AND \"Founded\" < p_founded_before;\n\n    DELETE FROM \"Championship\"\n    WHERE \"Institution_ID\" IN (\n        SELECT \"Institution_ID\"\n        FROM \"institution\"\n        WHERE \"City\" = p_city_name AND \"Founded\" < p_founded_before\n    );\n\n    DELETE FROM \"institution\"\n    WHERE \"City\" = p_city_name AND \"Founded\" < p_founded_before;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL archive_old_institutions(1950.0, 'Vancouver');",
      "CALL archive_old_institutions(1960.0, 'Calgary');",
      "CALL archive_old_institutions(1970.0, 'Edmonton');",
      "CALL archive_old_institutions(1900.0, 'Vancouver');",
      "CALL archive_old_institutions(1980.0, 'Calgary');"
    ],
    "summary": "Create a stored procedure named `archive_old_institutions` with two input parameters: a threshold year `p_founded_before` (real) and a city name `p_city_name` (text). Declare a variable to store total capacity. Calculate and store the sum of the Capacity column from the institution table for institutions in the specified city founded before the threshold. Then, delete rows from the Championship table where the Institution_ID matches institutions from the same city and founding date criteria. Finally, delete the qualifying rows from the institution table itself.",
    "natural_language": "How can I create a stored procedure called `archive_old_institutions` that takes a threshold year `p_founded_before` and a city name `p_city_name` as inputs, calculates the total capacity of qualifying institutions, and then deletes related championship and institution records?",
    "id": 220
  },
  {
    "ir": "Write a PLpgSQL stored procedure named consolidate_low_value_boxes that accepts three input parameters: a bigint parameter p_warehouse_code to identify a specific warehouse, a real parameter p_value_limit to define a maximum box value threshold, and a bigint parameter p_batch_size to control the number of boxes processed. The procedure operates on a table named \"Boxes\" with columns \"Code\", \"Contents\", \"Value\", and \"Warehouse\". It begins by declaring a cursor named box_cursor that selects the \"Code\", \"Contents\", and \"Value\" columns from the \"Boxes\" table for rows where the \"Warehouse\" column equals the input p_warehouse_code and the \"Value\" column is less than the input p_value_limit, ordering the results by the \"Value\" column in ascending order and limiting the number of rows returned to the value of p_batch_size. The procedure then iterates through each record from this cursor using a FOR LOOP; for each record, it accumulates the \"Value\" into a local variable named consolidated_value, increments a local counter variable named item_count, and performs a DELETE operation on the \"Boxes\" table where the \"Code\" column matches the \"Code\" from the current cursor record. After the loop completes, the procedure checks if the item_count is greater than zero; if this condition is true, it executes an INSERT operation into the \"Boxes\" table, creating a new row with a \"Code\" column value formed by concatenating the string 'CONS' with the p_warehouse_code parameter, a \"Contents\" column value of 'Consolidated Items', a \"Value\" column equal to the accumulated consolidated_value, and a \"Warehouse\" column set to the input p_warehouse_code.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_low_value_boxes(\n    p_warehouse_code bigint,\n    p_value_limit real,\n    p_batch_size bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    box_cursor CURSOR FOR \n        SELECT \"Code\", \"Contents\", \"Value\"\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = p_warehouse_code\n        AND \"Value\" < p_value_limit\n        ORDER BY \"Value\" ASC\n        LIMIT p_batch_size;\n    \n    box_rec RECORD;\n    consolidated_value real := 0;\n    item_count bigint := 0;\nBEGIN\n    FOR box_rec IN box_cursor LOOP\n        consolidated_value := consolidated_value + box_rec.\"Value\";\n        item_count := item_count + 1;\n        \n        DELETE FROM \"Boxes\" WHERE \"Code\" = box_rec.\"Code\";\n    END LOOP;\n    \n    IF item_count > 0 THEN\n        INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\")\n        VALUES ('CONS' || p_warehouse_code, 'Consolidated Items', consolidated_value, p_warehouse_code);\n    END IF;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL consolidate_low_value_boxes(1, 200.0, 5);",
      "CALL consolidate_low_value_boxes(2, 150.0, 10);",
      "CALL consolidate_low_value_boxes(3, 100.0, 3);",
      "CALL consolidate_low_value_boxes(1, 250.0, 7);",
      "CALL consolidate_low_value_boxes(3, 180.0, 4);"
    ],
    "summary": "Create a stored procedure named consolidate_low_value_boxes that takes a warehouse code, a value limit, and a batch size. For the specified warehouse, select up to the batch size of boxes with a value below the limit, ordered by value ascending. Delete each selected box, accumulate their total value, and count them. If any boxes were processed, insert a new consolidated box record with the total value into the same warehouse.",
    "natural_language": "Design a stored procedure called consolidate_low_value_boxes which requires three input parameters: a specific warehouse code, a defined monetary value limit, and a batch size number. For the indicated warehouse, carefully identify and select a group of boxes, limited to the specified batch size, whose individual value falls beneath the provided limit, arranging them in ascending order based on their value. Subsequently, proceed to delete each of these selected boxes one by one, while meticulously accumulating their combined total value and keeping a precise count of how many were processed. If any boxes were successfully handled during this operation, then insert a brand new consolidated box record, containing the amassed total value, into the very same warehouse location.",
    "id": 221
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `rank_and_relocate_boxes` that accepts three input parameters: `p_source_warehouse` of type `bigint`, representing the identifier of the warehouse from which boxes will be moved; `p_target_warehouse` of type `bigint`, representing the identifier of the warehouse to which boxes will be relocated; and `p_rank_threshold` of type `bigint`, representing the maximum rank a box's value can have to be considered for relocation. The procedure first declares a cursor named `ranked_boxes`. This cursor is defined to select specific columns from the `\"Boxes\"` table: `\"Code\"`, `\"Contents\"`, and `\"Value\"`. Additionally, it calculates a `value_rank` for each box using the `dense_rank()` window function, ordering the boxes by their `\"Value\"` in descending order. The selection for this cursor is restricted to boxes where the `\"Warehouse\"` column matches the `p_source_warehouse` parameter. A record variable named `box_rec` is also declared to hold the data fetched from the `ranked_boxes` cursor during iteration. The procedure then enters a loop that iterates through each record returned by the `ranked_boxes` cursor, assigning the current record's data to `box_rec`. Inside this loop, a conditional check is performed: if the `value_rank` of the current `box_rec` is less than or equal to the `p_rank_threshold` parameter, then two operations are executed. First, a `DELETE` statement is performed on the `\"Boxes\"` table, removing the row where the `\"Code\"` column matches the `\"Code\"` of the current `box_rec`. Second, an `INSERT` statement is executed on the `\"Boxes\"` table. This statement inserts a new row with the `\"Code\"`, `\"Contents\"`, and `\"Value\"` taken from the current `box_rec`, but sets the `\"Warehouse\"` column to the value provided by the `p_target_warehouse` parameter. This effectively moves the box from the source warehouse to the target warehouse by deleting its original record and inserting a new one with the updated warehouse assignment. The loop continues until all records from the `ranked_boxes` cursor have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE rank_and_relocate_boxes(\n    p_source_warehouse bigint,\n    p_target_warehouse bigint,\n    p_rank_threshold bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    ranked_boxes CURSOR FOR\n        SELECT \"Code\", \"Contents\", \"Value\",\n               dense_rank() OVER (ORDER BY \"Value\" DESC) as value_rank\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = p_source_warehouse;\n    \n    box_rec RECORD;\nBEGIN\n    FOR box_rec IN ranked_boxes LOOP\n        IF box_rec.value_rank <= p_rank_threshold THEN\n            DELETE FROM \"Boxes\" WHERE \"Code\" = box_rec.\"Code\";\n            \n            INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\")\n            VALUES (box_rec.\"Code\", box_rec.\"Contents\", box_rec.\"Value\", p_target_warehouse);\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL rank_and_relocate_boxes(1, 2, 1);",
      "CALL rank_and_relocate_boxes(3, 4, 2);",
      "CALL rank_and_relocate_boxes(1, 3, 0);",
      "CALL rank_and_relocate_boxes(4, 1, 3);",
      "CALL rank_and_relocate_boxes(2, 3, 1);"
    ],
    "summary": "Create a stored procedure named rank_and_relocate_boxes that takes a source warehouse, a target warehouse, and a rank threshold. For boxes in the source warehouse, assign a dense rank based on value descending. For each box with a rank less than or equal to the threshold, delete it from the source warehouse and insert it into the target warehouse.",
    "natural_language": "List all boxes in the source warehouse, then assign a dense rank to each based on descending value. For every box whose rank is less than or equal to the given threshold, remove it from the source warehouse and add it to the target warehouse. Do this by creating a stored procedure named rank_and_relocate_boxes.",
    "id": 222
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `transfer_members_between_clubs` that accepts two integer parameters: `p_source_club_id` and `p_target_club_id`. The `p_source_club_id` parameter represents the unique identifier of the club from which members are to be transferred, and the `p_target_club_id` parameter represents the unique identifier of the club to which members will be transferred. The procedure begins by declaring two local variables: `v_member_record`, which is of type `RECORD` and will be used to hold individual member records during iteration, and `v_current_year`, which is of type `text` and will store the current year. The procedure first initializes `v_current_year` by calling the `TO_CHAR` function with `CURRENT_DATE` and the format mask 'YYYY', effectively extracting the four-digit year from the current date. Following this, the procedure enters a `FOR` loop that iterates over a result set obtained by selecting the `Member_ID` column from the `club_leader` table. The selection is filtered by a `WHERE` clause where the `Club_ID` column matches the value provided in the `p_source_club_id` parameter. For each `v_member_record` retrieved in this loop, the procedure performs two operations. First, it executes a `DELETE` statement on the `club_leader` table, removing rows where the `Club_ID` column matches `p_source_club_id` AND the `Member_ID` column matches the `Member_ID` value from the current `v_member_record`. Second, it executes an `INSERT` statement into the `club_leader` table, adding a new row with values for `Club_ID` set to `p_target_club_id`, `Member_ID` set to the `Member_ID` from the current `v_member_record`, and `Year_Join` set to the `v_current_year` variable. This sequence of operations effectively moves each member associated with the source club to the target club by deleting their association with the source club and creating a new association with the target club, recording the current year as their join year for the new club.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_members_between_clubs(p_source_club_id integer, p_target_club_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_record RECORD;\n    v_current_year text;\nBEGIN\n    v_current_year := TO_CHAR(CURRENT_DATE, 'YYYY');\n    \n    FOR v_member_record IN \n        SELECT \"Member_ID\" FROM club_leader WHERE \"Club_ID\" = p_source_club_id\n    LOOP\n        DELETE FROM club_leader WHERE \"Club_ID\" = p_source_club_id AND \"Member_ID\" = v_member_record.\"Member_ID\";\n        INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (p_target_club_id, v_member_record.\"Member_ID\", v_current_year);\n    END LOOP;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL transfer_members_between_clubs(1, 3);",
      "CALL transfer_members_between_clubs(3, 4);",
      "CALL transfer_members_between_clubs(4, 1);",
      "CALL transfer_members_between_clubs(1, 4);",
      "CALL transfer_members_between_clubs(3, 1);"
    ],
    "summary": "Create a stored procedure named transfer_members_between_clubs that takes a source club ID and a target club ID. For each member associated with the source club in the club_leader table, delete that association and insert a new association with the target club, setting the join year to the current year.",
    "natural_language": "Please construct a stored procedure designated as 'transfer_members_between_clubs'. This procedure must accept two input parameters: a source club identifier and a target club identifier. For every member currently affiliated with the source club as recorded in the club_leader table, the procedure shall remove that existing affiliation. Subsequently, it shall establish a new affiliation for each such member with the specified target club, assigning the current year as the join year.",
    "id": 223
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `archive_old_memberships` that accepts two input parameters: `p_club_id` of type `integer`, representing the unique identifier of a club, and `p_cutoff_year` of type `integer`, representing a threshold year. The procedure begins by declaring a cursor named `v_member_cursor`. This cursor is designed to select specific member information by joining the `club_leader` table (aliased as `cl`) with the `member` table (aliased as `m`). The join condition links rows where the `\"Member_ID\"` column in `club_leader` matches the `\"Member_ID\"` column in `member`. The selection criteria for the cursor are as follows: it retrieves rows from the joined tables where the `\"Club_ID\"` column in the `club_leader` table is equal to the value provided in the `p_club_id` parameter, AND where the year extracted from the `\"Year_Join\"` column in the `club_leader` table is less than the value provided in the `p_cutoff_year` parameter. To extract the year, the `TO_DATE` function is first used to convert the string value in the `\"Year_Join\"` column into a date type, assuming a 'YYYY' format, and then the `EXTRACT(YEAR FROM ...)` function is applied to get the year component. For each matching record, the cursor selects the `\"Member_ID\"` from the `club_leader` table and the `\"Name\"` from the `member` table. A record variable named `v_member_rec` is also declared to hold the data fetched from the cursor.\n\nThe executable part of the procedure starts by opening the `v_member_cursor`. It then enters a loop. Inside the loop, it attempts to fetch the next row from `v_member_cursor` into the `v_member_rec` record variable. Immediately after the fetch operation, it checks if no row was found (`NOT FOUND`). If no row was found, the loop is exited. If a row was successfully fetched, the procedure executes a `DELETE` statement. This `DELETE` statement targets the `club_leader` table and removes rows where the `\"Club_ID\"` column matches the `p_club_id` parameter AND the `\"Member_ID\"` column matches the `\"Member_ID\"` value currently stored in `v_member_rec` (which was fetched from the cursor). This process effectively removes club leadership records for members who joined before the specified cutoff year for the given club. The loop continues until all relevant records identified by the cursor have been processed. After the loop finishes, the `v_member_cursor` is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_memberships(p_club_id integer, p_cutoff_year integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_cursor CURSOR FOR \n        SELECT cl.\"Member_ID\", m.\"Name\" \n        FROM club_leader cl \n        JOIN member m ON cl.\"Member_ID\" = m.\"Member_ID\" \n        WHERE cl.\"Club_ID\" = p_club_id AND EXTRACT(YEAR FROM TO_DATE(cl.\"Year_Join\", 'YYYY')) < p_cutoff_year;\n    v_member_rec RECORD;\nBEGIN\n    OPEN v_member_cursor;\n    LOOP\n        FETCH v_member_cursor INTO v_member_rec;\n        EXIT WHEN NOT FOUND;\n        DELETE FROM club_leader WHERE \"Club_ID\" = p_club_id AND \"Member_ID\" = v_member_rec.\"Member_ID\";\n    END LOOP;\n    CLOSE v_member_cursor;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL archive_old_memberships(1, 2019);",
      "CALL archive_old_memberships(3, 2016);",
      "CALL archive_old_memberships(4, 2017);",
      "CALL archive_old_memberships(1, 2015);",
      "CALL archive_old_memberships(3, 2018);"
    ],
    "summary": "Create a stored procedure named archive_old_memberships that takes a club ID and a cutoff year. For members of the specified club who joined before the cutoff year, delete their records from the club_leader table.",
    "natural_language": "Develop a stored procedure called archive_old_memberships that accepts two parameters: a specific club identifier and a designated cutoff year. This procedure should meticulously identify all members belonging to the indicated club whose membership commencement date precedes the provided cutoff year and subsequently, permanently remove their corresponding entries from the club_leader table.",
    "id": 224
  },
  {
    "ir": "Write a PostgreSQL stored procedure named populate_club_leadership that accepts two input parameters: an integer p_min_age representing a minimum age threshold and an integer p_max_ranking representing a maximum ranking threshold. The procedure begins by declaring local integer variables v_club_id and v_member_id, and a text variable v_join_year. It initializes v_join_year by converting the current system date to a four-digit year string using the TO_CHAR function with the format 'YYYY'. It then queries the club table to select a single Club_ID value, assigning it to v_club_id, where the Overall_Ranking column is less than or equal to the p_max_ranking parameter, ordering the results by Overall_Ranking in ascending order and limiting the result to one row. Subsequently, it queries the member table to select a single Member_ID value, assigning it to v_member_id, where the Age column is greater than or equal to the p_min_age parameter and the length of the Name column is greater than 8 characters, ordering the results by Age in descending order and limiting the result to one row. If both v_club_id and v_member_id are not null, the procedure performs an insert into the club_leader table for the columns Club_ID, Member_ID, and Year_Join using the values from the variables v_club_id, v_member_id, and v_join_year, but only if a row with the same Club_ID and Member_ID combination does not already exist in the club_leader table, as determined by a WHERE NOT EXISTS subquery that selects the constant 1 from club_leader where Club_ID equals v_club_id and Member_ID equals v_member_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE populate_club_leadership(p_min_age integer, p_max_ranking integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_club_id integer;\n    v_member_id integer;\n    v_join_year text;\nBEGIN\n    v_join_year := TO_CHAR(CURRENT_DATE, 'YYYY');\n    \n    SELECT \"Club_ID\" INTO v_club_id FROM club WHERE \"Overall_Ranking\" <= p_max_ranking ORDER BY \"Overall_Ranking\" LIMIT 1;\n    SELECT \"Member_ID\" INTO v_member_id FROM member WHERE \"Age\" >= p_min_age AND LENGTH(\"Name\") > 8 ORDER BY \"Age\" DESC LIMIT 1;\n    \n    IF v_club_id IS NOT NULL AND v_member_id IS NOT NULL THEN\n        INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") \n        SELECT v_club_id, v_member_id, v_join_year\n        WHERE NOT EXISTS (\n            SELECT 1 FROM club_leader \n            WHERE \"Club_ID\" = v_club_id AND \"Member_ID\" = v_member_id\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL populate_club_leadership(20, 50);",
      "CALL populate_club_leadership(25, 30);",
      "CALL populate_club_leadership(18, 100);",
      "CALL populate_club_leadership(30, 10);",
      "CALL populate_club_leadership(22, 75);"
    ],
    "summary": "Create a stored procedure named populate_club_leadership that takes a minimum age and a maximum ranking. Select the club with the lowest ranking that meets the maximum ranking threshold. Select the oldest member who meets the minimum age and has a name longer than 8 characters. If both a club and a member are found, insert a record into the club_leader table for the current year, but only if the combination does not already exist.",
    "natural_language": "Construct a stored procedure called populate_club_leadership, which is designed to accept two distinct parameters: a specified minimum age and a defined maximum ranking. The procedure must first identify the single club that possesses the very lowest ranking, provided that this ranking does not exceed the supplied maximum threshold. Subsequently, it should locate the most elderly member from the entire roster, who is both at or above the stipulated minimum age and has a full name consisting of more than eight characters in length. In the event that both a qualifying club and a suitable member are successfully discovered, the procedure must then insert a new entry into the club_leader table for the present calendar year, taking careful precaution to ensure that this precise club-member pairing is not already recorded in the table to avoid any duplication.",
    "id": 225
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named migrate_young_members that accepts two integer input parameters: p_source_club_id to identify the originating club and p_target_club_id to identify the destination club. The procedure begins by declaring a local integer variable v_member_id and a local text variable v_new_year. It then calculates the value for v_new_year by taking the current date, adding an interval of one year to it, and converting the resulting date to a four-digit year string using the TO_CHAR function with the 'YYYY' format mask. The procedure enters a loop that iterates over a result set obtained from a SELECT query. This query retrieves the Member_ID column from the club_leader table, aliased as cl, by performing an inner join with the member table, aliased as m, on the condition that the Member_ID column from club_leader equals the Member_ID column from member. The query filters the joined records to include only those where the Club_ID column in the club_leader table matches the input parameter p_source_club_id and where the Age column in the member table is less than 20. For each member ID fetched into v_member_id during iteration, the procedure executes two data manipulation statements. First, it deletes a row from the club_leader table where the Club_ID column equals p_source_club_id and the Member_ID column equals the current loop variable v_member_id. Second, it inserts a new row into the club_leader table, providing values for three columns: the Club_ID column is set to the input parameter p_target_club_id, the Member_ID column is set to the current v_member_id, and the Year_Join column is set to the previously calculated v_new_year string.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_young_members(p_source_club_id integer, p_target_club_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_id integer;\n    v_new_year text;\nBEGIN\n    v_new_year := TO_CHAR(CURRENT_DATE + INTERVAL '1 year', 'YYYY');\n    \n    FOR v_member_id IN \n        SELECT cl.\"Member_ID\" \n        FROM club_leader cl \n        JOIN member m ON cl.\"Member_ID\" = m.\"Member_ID\" \n        WHERE cl.\"Club_ID\" = p_source_club_id AND m.\"Age\" < 20\n    LOOP\n        DELETE FROM club_leader WHERE \"Club_ID\" = p_source_club_id AND \"Member_ID\" = v_member_id;\n        INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (p_target_club_id, v_member_id, v_new_year);\n    END LOOP;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL migrate_young_members(1, 3);",
      "CALL migrate_young_members(1, 4);",
      "CALL migrate_young_members(3, 1);",
      "CALL migrate_young_members(3, 4);",
      "CALL migrate_young_members(4, 1);"
    ],
    "summary": "Create a stored procedure named migrate_young_members that transfers young members (under 20) from a source club to a target club. For each member, delete their leadership record from the source club and insert a new record in the target club with a join year set to next year.",
    "natural_language": "Develop a stored procedure called migrate_young_members that meticulously handles the transfer of all youthful members, specifically those who are under the age of twenty, from a designated source club to a specified target club. For every single one of these young members, the procedure must carefully delete their existing leadership entry from the original source club and then thoughtfully insert a brand-new record for them into the destination target club, explicitly setting their join year to the upcoming calendar year.",
    "id": 226
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `manage_employee_promotions` that automates employee promotion logic based on their tenure and department. The procedure begins by declaring several local variables: `dept_record` of type `RECORD` to hold department information, `top_emp` of type `RECORD` to store details of the highest-paid employee in a department, `history_days` of type `INTEGER` to calculate an employee's tenure, and `new_job_id` of type `TEXT` to temporarily store a potential new job ID.\n\nThe core logic of the procedure involves iterating through each department that has an assigned manager. This is achieved by a `FOR` loop that selects `DEPARTMENT_ID`, `DEPARTMENT_NAME`, and `MANAGER_ID` from the `departments` table, specifically for rows where `MANAGER_ID` is not `NULL`.\n\nInside this department loop, for each `dept_record`, the procedure attempts to identify the highest-paid employee within that department, excluding the department's manager. It selects `EMPLOYEE_ID`, `JOB_ID`, `SALARY`, and `HIRE_DATE` from the `employees` table into the `top_emp` record. The selection criteria are: the employee's `DEPARTMENT_ID` must match the current `dept_record.\"DEPARTMENT_ID\"`, and the employee's `EMPLOYEE_ID` must not be equal to the `dept_record.\"MANAGER_ID\"`. The results are ordered in descending order by `SALARY`, and `LIMIT 1` ensures that only the single highest-paid employee (excluding the manager) is selected.\n\nFollowing this selection, an `IF FOUND` block checks if a `top_emp` was successfully identified. If an employee is found, the procedure then calculates the employee's tenure in days. It first attempts to retrieve the difference in days between the `CURRENT_DATE` and the `START_DATE` of the employee's most recent job history entry from the `job_history` table. This is done by selecting `(CURRENT_DATE - jh.\"START_DATE\")` into `history_days` where `jh.\"EMPLOYEE_ID\"` matches `top_emp.\"EMPLOYEE_ID\"`, ordered by `START_DATE` in descending order, and limited to 1 result.\n\nIf `history_days` remains `NULL` (meaning no job history entries were found for the employee), the procedure calculates `history_days` as the difference between `CURRENT_DATE` and the employee's `HIRE_DATE` from the `employees` table (`top_emp.\"HIRE_DATE\"`).\n\nNext, a series of `IF-ELSIF` statements evaluate `history_days` to determine potential promotion actions:\n\n1.  **If `history_days` is less than 365 days:** The `new_job_id` variable is set to `'AD_ASST'`.\n2.  **If `history_days` is greater than or equal to 365 days AND less than 730 days:** The `new_job_id` variable is set to `'AD_VP'`.\n3.  **If `history_days` is greater than or equal to 730 days AND less than 1825 days:** The `new_job_id` variable is set to `'AD_PRES'`.\n4.  **If `history_days` is greater than or equal to 1825 days AND less than 3650 days:** The `employees` table is updated. For the `top_emp.\"EMPLOYEE_ID\"`, the `MANAGER_ID` is set to `dept_record.\"MANAGER_ID\"`, and the `SALARY` is increased by 25% (multiplied by 1.25).\n5.  **If `history_days` is greater than or equal to 3650 days AND less than 7300 days:**\n    *   An `INSERT` statement adds a new record to the `job_history` table. The values inserted are `top_emp.\"EMPLOYEE_ID\"` for `EMPLOYEE_ID`, `CURRENT_DATE` for `START_DATE`, `CURRENT_DATE + 365` (one year from now) for `END_DATE`, `top_emp.\"JOB_ID\"` for `JOB_ID`, and `dept_record.\"DEPARTMENT_ID\"` for `DEPARTMENT_ID`.\n    *   Subsequently, the `employees` table is updated. For the `top_emp.\"EMPLOYEE_ID\"`, the `JOB_ID` is set to `'AD_PRES'`, and the `SALARY` is increased by 50% (multiplied by 1.50).\n6.  **For any other `history_days` value (i.e., greater than or equal to 7300 days):**\n    *   A `DELETE` statement removes records from the `job_history` table where the `EMPLOYEE_ID` matches `top_emp.\"EMPLOYEE_ID\"` and the `END_DATE` is older than `CURRENT_DATE - INTERVAL '10 years'`.\n    *   Then, the `employees` table is updated. For the `top_emp.\"EMPLOYEE_ID\"`, the `SALARY` is increased by 100% (multiplied by 2.00).\n\nFinally, after the `IF-ELSIF` block for `history_days`, there's an additional `IF` statement. If `new_job_id` is not `NULL` (meaning one of the first three `history_days` conditions was met), the `employees` table is updated. For the `top_emp.\"EMPLOYEE_ID\"`, the `JOB_ID` is set to the value stored in `new_job_id`, and the `SALARY` is increased by 15% (multiplied by 1.15). This concludes the processing for a single `top_emp`. The procedure then continues to the next department in the `FOR` loop until all eligible departments have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_employee_promotions()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    dept_record RECORD;\n    top_emp RECORD;\n    history_days INTEGER;\n    new_job_id TEXT;\nBEGIN\n    FOR dept_record IN\n        SELECT d.\"DEPARTMENT_ID\", d.\"DEPARTMENT_NAME\", d.\"MANAGER_ID\"\n        FROM departments d\n        WHERE d.\"MANAGER_ID\" IS NOT NULL\n    LOOP\n        SELECT e.\"EMPLOYEE_ID\", e.\"JOB_ID\", e.\"SALARY\", e.\"HIRE_DATE\"\n        INTO top_emp\n        FROM employees e\n        WHERE e.\"DEPARTMENT_ID\" = dept_record.\"DEPARTMENT_ID\"\n        AND e.\"EMPLOYEE_ID\" != dept_record.\"MANAGER_ID\"\n        ORDER BY e.\"SALARY\" DESC\n        LIMIT 1;\n\n        IF FOUND THEN\n            SELECT (CURRENT_DATE - jh.\"START_DATE\") INTO history_days\n            FROM job_history jh\n            WHERE jh.\"EMPLOYEE_ID\" = top_emp.\"EMPLOYEE_ID\"\n            ORDER BY jh.\"START_DATE\" DESC\n            LIMIT 1;\n\n            IF history_days IS NULL THEN\n                history_days := (CURRENT_DATE - top_emp.\"HIRE_DATE\");\n            END IF;\n\n            IF history_days < 365 THEN\n                new_job_id := 'AD_ASST';\n            ELSIF history_days >= 365 AND history_days < 730 THEN\n                new_job_id := 'AD_VP';\n            ELSIF history_days >= 730 AND history_days < 1825 THEN\n                new_job_id := 'AD_PRES';\n            ELSIF history_days >= 1825 AND history_days < 3650 THEN\n                UPDATE employees\n                SET \"MANAGER_ID\" = dept_record.\"MANAGER_ID\",\n                    \"SALARY\" = \"SALARY\" * 1.25\n                WHERE \"EMPLOYEE_ID\" = top_emp.\"EMPLOYEE_ID\";\n            ELSIF history_days >= 3650 AND history_days < 7300 THEN\n                INSERT INTO job_history (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\")\n                VALUES (top_emp.\"EMPLOYEE_ID\", CURRENT_DATE, CURRENT_DATE + 365, top_emp.\"JOB_ID\", dept_record.\"DEPARTMENT_ID\");\n                \n                UPDATE employees\n                SET \"JOB_ID\" = 'AD_PRES',\n                    \"SALARY\" = \"SALARY\" * 1.50\n                WHERE \"EMPLOYEE_ID\" = top_emp.\"EMPLOYEE_ID\";\n            ELSE\n                DELETE FROM job_history\n                WHERE \"EMPLOYEE_ID\" = top_emp.\"EMPLOYEE_ID\"\n                AND \"END_DATE\" < CURRENT_DATE - INTERVAL '10 years';\n                \n                UPDATE employees\n                SET \"SALARY\" = \"SALARY\" * 2.00\n                WHERE \"EMPLOYEE_ID\" = top_emp.\"EMPLOYEE_ID\";\n            END IF;\n\n            IF new_job_id IS NOT NULL THEN\n                UPDATE employees\n                SET \"JOB_ID\" = new_job_id,\n                    \"SALARY\" = \"SALARY\" * 1.15\n                WHERE \"EMPLOYEE_ID\" = top_emp.\"EMPLOYEE_ID\";\n            END IF;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history",
      "locations"
    ],
    "call_sqls": [
      "CALL manage_employee_promotions();"
    ],
    "summary": "Create a stored procedure named manage_employee_promotions that processes each department with a manager. For each department, find the highest-paid non-manager employee. Based on their tenure (calculated from job history or hire date), perform different actions: assign a new job ID for short tenures, update salary and manager for medium tenure, insert job history and update for long tenure, or delete old history and update salary for very long tenure.",
    "natural_language": "Write a stored procedure called manage_employee_promotions to process every department that has a manager. For each such department, identify the non-manager employee with the highest salary. Then, depending on their tenureâ€”calculated from their job history or hire dateâ€”take the appropriate action: assign a new job ID for short tenure, update salary and manager for medium tenure, insert job history and update for long tenure, or delete old history and update salary for very long tenure.",
    "id": 227
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `synchronize_location_department_data` that takes no parameters. The procedure declares several local variables: `country_record` of type `RECORD` to hold data for each distinct country, `loc_total` of type `INTEGER` to store the count of locations, `dept_total` of type `INTEGER` to store the count of departments, `salary_sum` of type `NUMERIC` to accumulate salaries, and `avg_salary` of type `NUMERIC` to store the average salary.\n\nThe procedure begins by iterating through a cursor that selects distinct `COUNTRY_ID` values from the `locations` table, specifically where `COUNTRY_ID` is not null, and orders these distinct `COUNTRY_ID` values in ascending order. For each `country_record` retrieved in this loop, the following operations are performed:\n\nFirst, it calculates the total number of locations for the current `COUNTRY_ID`. This count is stored in the `loc_total` variable by querying the `locations` table and counting rows where the `COUNTRY_ID` column matches `country_record.\"COUNTRY_ID\"`.\n\nSecond, it calculates the total number of departments associated with the current `COUNTRY_ID`. This count is stored in the `dept_total` variable by joining the `departments` table with the `locations` table on `DEPARTMENT_ID` and `LOCATION_ID` respectively, and then counting rows where the `COUNTRY_ID` column in the `locations` table matches `country_record.\"COUNTRY_ID\"`.\n\nFollowing these counts, a series of conditional statements are executed based on the values of `loc_total` and `dept_total`:\n\n1.  **If `loc_total` is equal to 0:**\n    An `INSERT` statement is executed on the `locations` table. A new row is inserted with a generated `LOCATION_ID`, a `CITY`, and the current `COUNTRY_ID`. The `LOCATION_ID` is calculated as the absolute value of the modulo of (`country_record.\"COUNTRY_ID\"` cast to `NUMERIC` multiplied by 1000) divided by 10000. The `CITY` is constructed by concatenating the string 'CAPITAL_' with `country_record.\"COUNTRY_ID\"`. The `COUNTRY_ID` is set to `country_record.\"COUNTRY_ID\"`.\n\n2.  **Else if `loc_total` is equal to 1 AND `dept_total` is equal to 0:**\n    An `UPDATE` statement is executed on the `locations` table. For all locations where the `COUNTRY_ID` matches `country_record.\"COUNTRY_ID\"`, the `STREET_ADDRESS` column is set to 'GENERIC_ADDRESS' and the `POSTAL_CODE` column is set to '00000'.\n\n3.  **Else if `loc_total` is between 2 and 5 (inclusive):**\n    The sum of salaries for all employees associated with the current `COUNTRY_ID` is calculated. This sum is stored in the `salary_sum` variable by joining the `employees` table with the `departments` table on `DEPARTMENT_ID`, and then joining with the `locations` table on `LOCATION_ID`, and finally summing the `SALARY` column for rows where the `COUNTRY_ID` in the `locations` table matches `country_record.\"COUNTRY_ID\"`.\n    If `salary_sum` is greater than 0, the `avg_salary` is calculated by dividing `salary_sum` by `dept_total`. Then, an `UPDATE` statement is executed on the `employees` table. The `SALARY` column is updated based on a `CASE` statement for employees whose `DEPARTMENT_ID` is associated with the current `COUNTRY_ID`. Specifically, if an employee's `SALARY` is less than `avg_salary`, their `SALARY` is increased by 10% (multiplied by 1.10). If an employee's `SALARY` is greater than `avg_salary` multiplied by 1.5, their `SALARY` is decreased by 10% (multiplied by 0.90). Otherwise, their `SALARY` remains unchanged. The employees targeted by this update are those whose `DEPARTMENT_ID` is found in a subquery that selects `DEPARTMENT_ID` from the `departments` table, joined with the `locations` table, where `COUNTRY_ID` matches `country_record.\"COUNTRY_ID\"`.\n\n4.  **Else if `loc_total` is between 6 and 10 (inclusive):**\n    A `DELETE` statement is executed on the `departments` table. It removes departments whose `LOCATION_ID` is associated with the current `COUNTRY_ID` AND for which no employees exist in that department. The `LOCATION_ID`s are identified by a subquery on the `locations` table where `COUNTRY_ID` matches `country_record.\"COUNTRY_ID\"`. The condition `NOT EXISTS` checks for the absence of employees in the `employees` table for the `DEPARTMENT_ID` of the department being considered for deletion.\n\n5.  **Else if `loc_total` is greater than 10 AND `dept_total` is greater than 0:**\n    An `UPDATE` statement is executed on the `departments` table. The `DEPARTMENT_NAME` column is modified for a subset of departments. The new `DEPARTMENT_NAME` is constructed by taking the first character of the original `DEPARTMENT_NAME` and converting it to uppercase using `UPPER(SUBSTRING(\"DEPARTMENT_NAME\" FROM 1 FOR 1))`, concatenating it with the rest of the `DEPARTMENT_NAME` converted to lowercase using `LOWER(SUBSTRING(\"DEPARTMENT_NAME\" FROM 2))`, and then appending an underscore `_` followed by `country_record.\"COUNTRY_ID\"`. This update applies to departments whose `LOCATION_ID` is associated with the current `COUNTRY_ID` (identified by a subquery on `locations` table) AND whose `DEPARTMENT_ID` is among the first `CEIL(dept_total * 0.5)` departments (rounded up to the nearest integer and cast to `INTEGER`) when ordered by `DEPARTMENT_ID` within the current `COUNTRY_ID` (identified by a subquery joining `departments` and `locations` tables).\n\n6.  **Else (if none of the above conditions are met):**\n    An `INSERT` statement is executed on the `job_history` table. It inserts up to 5 records for employees associated with the current `COUNTRY_ID` who were hired more than one year ago. The inserted values are: `EMPLOYEE_ID`, `CURRENT_DATE` for `START_DATE`, `CURRENT_DATE + 180` days for `END_DATE`, `JOB_ID`, and `DEPARTMENT_ID`. These values are selected from the `employees` table, joined with the `departments` table on `DEPARTMENT_ID`, and then joined with the `locations` table on `LOCATION_ID`, where `COUNTRY_ID` in the `locations` table matches `country_record.\"COUNTRY_ID\"` and the `HIRE_DATE` in the `employees` table is earlier than `CURRENT_DATE - INTERVAL '1 year'`. The `LIMIT 5` clause ensures that a maximum of 5 such records are inserted.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_location_department_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    country_record RECORD;\n    loc_total INTEGER;\n    dept_total INTEGER;\n    salary_sum NUMERIC;\n    avg_salary NUMERIC;\nBEGIN\n    FOR country_record IN\n        SELECT DISTINCT l.\"COUNTRY_ID\"\n        FROM locations l\n        WHERE l.\"COUNTRY_ID\" IS NOT NULL\n        ORDER BY l.\"COUNTRY_ID\"\n    LOOP\n        SELECT COUNT(*) INTO loc_total\n        FROM locations l\n        WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\";\n\n        SELECT COUNT(*) INTO dept_total\n        FROM departments d\n        JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n        WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\";\n\n        IF loc_total = 0 THEN\n            INSERT INTO locations (\"LOCATION_ID\", \"CITY\", \"COUNTRY_ID\")\n            VALUES (ABS(MOD(CAST(country_record.\"COUNTRY_ID\" AS NUMERIC) * 1000, 10000)), 'CAPITAL_' || country_record.\"COUNTRY_ID\", country_record.\"COUNTRY_ID\");\n        ELSIF loc_total = 1 AND dept_total = 0 THEN\n            UPDATE locations\n            SET \"STREET_ADDRESS\" = 'GENERIC_ADDRESS',\n                \"POSTAL_CODE\" = '00000'\n            WHERE \"COUNTRY_ID\" = country_record.\"COUNTRY_ID\";\n        ELSIF loc_total BETWEEN 2 AND 5 THEN\n            SELECT SUM(e.\"SALARY\") INTO salary_sum\n            FROM employees e\n            JOIN departments d ON e.\"DEPARTMENT_ID\" = d.\"DEPARTMENT_ID\"\n            JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n            WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\";\n\n            IF salary_sum > 0 THEN\n                avg_salary := salary_sum / dept_total;\n                UPDATE employees\n                SET \"SALARY\" = CASE\n                    WHEN \"SALARY\" < avg_salary THEN \"SALARY\" * 1.10\n                    WHEN \"SALARY\" > avg_salary * 1.5 THEN \"SALARY\" * 0.90\n                    ELSE \"SALARY\"\n                END\n                WHERE \"DEPARTMENT_ID\" IN (\n                    SELECT d.\"DEPARTMENT_ID\"\n                    FROM departments d\n                    JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n                    WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\"\n                );\n            END IF;\n        ELSIF loc_total BETWEEN 6 AND 10 THEN\n            DELETE FROM departments\n            WHERE \"LOCATION_ID\" IN (\n                SELECT l.\"LOCATION_ID\"\n                FROM locations l\n                WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\"\n                AND NOT EXISTS (\n                    SELECT 1\n                    FROM employees e\n                    WHERE e.\"DEPARTMENT_ID\" = departments.\"DEPARTMENT_ID\"\n                )\n            );\n        ELSIF loc_total > 10 AND dept_total > 0 THEN\n            UPDATE departments\n            SET \"DEPARTMENT_NAME\" = UPPER(SUBSTRING(\"DEPARTMENT_NAME\" FROM 1 FOR 1)) || LOWER(SUBSTRING(\"DEPARTMENT_NAME\" FROM 2)) || '_' || country_record.\"COUNTRY_ID\"\n            WHERE \"LOCATION_ID\" IN (\n                SELECT l.\"LOCATION_ID\"\n                FROM locations l\n                WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\"\n            )\n            AND \"DEPARTMENT_ID\" IN (\n                SELECT d.\"DEPARTMENT_ID\"\n                FROM departments d\n                JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n                WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\"\n                ORDER BY d.\"DEPARTMENT_ID\"\n                LIMIT CEIL(dept_total * 0.5)::INTEGER\n            );\n        ELSE\n            INSERT INTO job_history (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\")\n            SELECT e.\"EMPLOYEE_ID\", CURRENT_DATE, CURRENT_DATE + 180, e.\"JOB_ID\", e.\"DEPARTMENT_ID\"\n            FROM employees e\n            JOIN departments d ON e.\"DEPARTMENT_ID\" = d.\"DEPARTMENT_ID\"\n            JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n            WHERE l.\"COUNTRY_ID\" = country_record.\"COUNTRY_ID\"\n            AND e.\"HIRE_DATE\" < CURRENT_DATE - INTERVAL '1 year'\n            LIMIT 5;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history",
      "locations"
    ],
    "call_sqls": [
      "CALL synchronize_location_department_data();"
    ],
    "summary": "Create a stored procedure named synchronize_location_department_data that processes each distinct country. For each country, count its locations and departments. Then perform conditional operations: insert a capital location if none exist; update location details if only one location exists with no departments; adjust employee salaries based on the country's average salary if there are 2-5 locations; delete empty departments if there are 6-10 locations; update department names if there are over 10 locations with departments; otherwise, insert job history for employees hired over a year ago.",
    "natural_language": "Formulate a stored procedure designated as 'synchronize_location_department_data'. This procedure shall iterate through each unique country. For every country, it must compute the respective counts of locations and departments. Subsequently, conditional logic is to be executed as follows: if no capital location is present, one shall be inserted; if precisely one location exists and it is associated with zero departments, its details are to be updated; for countries possessing between two and five locations, employee salaries must be adjusted in accordance with the national average salary; for countries with six to ten locations, any departments devoid of employees are to be deleted; for countries with more than ten locations that also contain departments, department names require updating; in all other cases, a job history record should be inserted for employees whose hiring date exceeds one year.",
    "id": 228
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `analyze_book_series` that accepts three input parameters: `p_title_pattern` of type `TEXT`, `p_min_pages` of type `INTEGER`, and `p_max_pages` of type `INTEGER`. The purpose of this procedure is to analyze books based on a title pattern and page range, and conditionally insert a summary review record.\n\nFirst, the procedure declares three local variables: `v_book_count` of type `INTEGER`, `v_avg_rating` of type `REAL`, and `v_total_readers` of type `REAL`.\n\nNext, it executes a `SELECT` statement to retrieve aggregated data from the `book` and `review` tables. This `SELECT` statement performs an inner join between the `book` table (aliased as `b`) and the `review` table (aliased as `r`) on the condition that the `Book_ID` column in the `book` table matches the `Book_ID` column in the `review` table (`b.\"Book_ID\" = r.\"Book_ID\"`). The `WHERE` clause filters these joined records based on two conditions:\n1. The `Title` column in the `book` table (`b.\"Title\"`) must match the pattern specified by the `p_title_pattern` parameter using the `LIKE` operator.\n2. The `Pages` column in the `book` table (`b.\"Pages\"`) must be within the inclusive range defined by `p_min_pages` and `p_max_pages` parameters, using the `BETWEEN` operator.\n\nFrom the filtered and joined records, the `SELECT` statement calculates three aggregate values:\n1. `COUNT(*)`: This counts the total number of books that satisfy the `WHERE` clause conditions. The result is stored in the `v_book_count` variable.\n2. `AVG(r.\"Rating\")`: This calculates the average of the `Rating` column from the `review` table for the selected books. The result is stored in the `v_avg_rating` variable.\n3. `SUM(r.\"Readers_in_Million\")`: This calculates the sum of the `Readers_in_Million` column from the `review` table for the selected books. The result is stored in the `v_total_readers` variable.\n\nAfter the `SELECT` statement, the procedure enters a conditional block (`IF v_book_count > 0 THEN`). This block executes only if the `v_book_count` variable, which represents the number of books found matching the criteria, is greater than zero.\n\nInside this conditional block, an `INSERT` statement is executed to add a new record into the `review` table. The values for the new record's columns are determined as follows:\n1. For the `Review_ID` column: It calculates the maximum existing `Review_ID` from the `review` table, adds 1 to it, and uses this as the new `Review_ID`. If no `Review_ID` exists (i.e., `MAX(\"Review_ID\")` returns `NULL`), `COALESCE` ensures that `0` is used instead, resulting in a `Review_ID` of `1`.\n2. For the `Book_ID` column: It selects the minimum `Book_ID` from the `book` table where the `Title` column matches the `p_title_pattern` parameter using the `LIKE` operator.\n3. For the `Rating` column: It uses the previously calculated `v_avg_rating` variable.\n4. For the `Readers_in_Million` column: It uses the previously calculated `v_total_readers` variable.\n5. For the `Rank` column: It uses the `v_book_count` variable, which represents the number of books found.\n\nThe procedure concludes after this conditional `INSERT` statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_book_series(p_title_pattern TEXT, p_min_pages INTEGER, p_max_pages INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_book_count INTEGER;\n    v_avg_rating REAL;\n    v_total_readers REAL;\nBEGIN\n    SELECT COUNT(*), AVG(r.\"Rating\"), SUM(r.\"Readers_in_Million\") \n    INTO v_book_count, v_avg_rating, v_total_readers \n    FROM book b \n    JOIN review r ON b.\"Book_ID\" = r.\"Book_ID\" \n    WHERE b.\"Title\" LIKE p_title_pattern \n    AND b.\"Pages\" BETWEEN p_min_pages AND p_max_pages;\n    \n    IF v_book_count > 0 THEN\n        INSERT INTO review (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") \n        VALUES (\n            (SELECT COALESCE(MAX(\"Review_ID\"),0)+1 FROM review), \n            (SELECT MIN(\"Book_ID\") FROM book WHERE \"Title\" LIKE p_title_pattern), \n            v_avg_rating, \n            v_total_readers, \n            v_book_count\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL analyze_book_series('A%', 700, 800);",
      "CALL analyze_book_series('The%', 500, 1000);",
      "CALL analyze_book_series('%Storm%', 900, 1200);",
      "CALL analyze_book_series('Game%', 600, 800);",
      "CALL analyze_book_series('Kings%', 750, 850);"
    ],
    "summary": "Create a stored procedure named analyze_book_series that analyzes books matching a title pattern and page range. Calculate the count of matching books, their average rating, and total readers. If books are found, insert a summary review record with these aggregated values, using the minimum matching book ID and a new review ID.",
    "natural_language": "How can I create a stored procedure named analyze_book_series to analyze books by a title pattern and page range, calculate the count, average rating, and total readers, and then, if books are found, insert a summary review record with these aggregated values using the minimum matching book ID and a new review ID?",
    "id": 229
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_audio_duration` that accepts three input parameters: `p_book_id` of type `INTEGER`, `p_hour_multiplier` of type `REAL`, and `p_minute_multiplier` of type `REAL`. The purpose of this procedure is to extract audio duration information from a specific book record, calculate a total duration based on provided multipliers, and then insert a new record into the `review` table using this calculated duration and other derived values.\n\nThe procedure begins by declaring four local variables: `v_audio_text` of type `TEXT` to store the audio duration string, `v_hours` of type `INTEGER` to store the extracted hours component, `v_minutes` of type `INTEGER` to store the extracted minutes component, and `v_total_minutes` of type `INTEGER` to store the final calculated total minutes.\n\nThe first operation performed is a `SELECT` statement. It retrieves the value from the `\"Audio\"` column of the `book` table and stores it into the `v_audio_text` variable. This selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Book_ID\"` column matches the input parameter `p_book_id` is considered.\n\nNext, the procedure calculates the `v_hours` variable. This is achieved by first calling the `SPLIT_PART` function. The outer `SPLIT_PART` function takes `v_audio_text` as the string, 'h' as the delimiter, and 1 as the part number, effectively extracting the portion of the string before the first 'h'. The result of this is then passed to an inner `SPLIT_PART` function, which takes the previous result as the string, a space character (' ') as the delimiter, and 1 as the part number, extracting the first word (which should represent the hours). Finally, the result of this operation is explicitly cast to an `INTEGER` type using `CAST()`.\n\nFollowing this, the procedure calculates the `v_minutes` variable. Similar to `v_hours`, this involves nested `SPLIT_PART` calls. The outer `SPLIT_PART` function takes `v_audio_text` as the string, 'm' as the delimiter, and 1 as the part number, extracting the portion of the string before the first 'm'. The result of this is then passed to an inner `SPLIT_PART` function, which takes the previous result as the string, a space character (' ') as the delimiter, and 2 as the part number, extracting the second word (which should represent the minutes). Finally, the result of this operation is explicitly cast to an `INTEGER` type using `CAST()`.\n\nSubsequently, the `v_total_minutes` variable is calculated. This involves a mathematical expression: `(v_hours * p_hour_multiplier * 60) + (v_minutes * p_minute_multiplier)`. This expression multiplies the extracted `v_hours` by the `p_hour_multiplier` and then by 60 (to convert hours to minutes), and adds this to the product of `v_minutes` and `p_minute_multiplier`. The entire result of this calculation is then explicitly cast to an `INTEGER` type using `CAST()`.\n\nFinally, the procedure performs an `INSERT` operation into the `review` table. The values inserted into the columns are as follows:\n- For `\"Review_ID\"`: A subquery `(SELECT COALESCE(MAX(\"Review_ID\"),0)+1 FROM review)` is executed. This subquery finds the maximum existing `\"Review_ID\"` in the `review` table. If no records exist (i.e., `MAX(\"Review_ID\")` returns `NULL`), `COALESCE` replaces `NULL` with `0`. Then, `1` is added to this value to generate a new, unique `\"Review_ID\"`.\n- For `\"Book_ID\"`: The value of the input parameter `p_book_id` is used.\n- For `\"Rating\"`: The value of the `v_hours` variable is used.\n- For `\"Readers_in_Million\"`: The value of the `v_minutes` variable is used.\n- For `\"Rank\"`: The value of the `v_total_minutes` variable is used.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_audio_duration(p_book_id INTEGER, p_hour_multiplier REAL, p_minute_multiplier REAL)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_audio_text TEXT;\n    v_hours INTEGER;\n    v_minutes INTEGER;\n    v_total_minutes INTEGER;\nBEGIN\n    SELECT \"Audio\" INTO v_audio_text FROM book WHERE \"Book_ID\" = p_book_id;\n    v_hours := CAST(SPLIT_PART(SPLIT_PART(v_audio_text, 'h', 1), ' ', 1) AS INTEGER);\n    v_minutes := CAST(SPLIT_PART(SPLIT_PART(v_audio_text, 'm', 1), ' ', 2) AS INTEGER);\n    v_total_minutes := CAST((v_hours * p_hour_multiplier * 60) + (v_minutes * p_minute_multiplier) AS INTEGER);\n    INSERT INTO review (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES ((SELECT COALESCE(MAX(\"Review_ID\"),0)+1 FROM review), p_book_id, v_hours, v_minutes, v_total_minutes);\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL process_audio_duration(1, 1.0, 1.0);",
      "CALL process_audio_duration(2, 1.5, 1.0);",
      "CALL process_audio_duration(3, 1.0, 1.2);",
      "CALL process_audio_duration(1, 0.8, 0.9);",
      "CALL process_audio_duration(2, 1.2, 1.1);"
    ],
    "summary": "Create a stored procedure named process_audio_duration that processes a book's audio duration string. Extract the hours and minutes from the audio field. Calculate total minutes using provided multipliers for hours and minutes. Insert a new review record using the book ID, extracted hours as rating, extracted minutes as readers, and calculated total minutes as rank.",
    "natural_language": "Make a stored procedure called process_audio_duration to handle a book's audio length text. Figure out the hours and minutes from that audio info. Work out the total minutes with the usual multipliers for hours and minutes. Add a new review entry using the book's ID, the hours you got as a sort of rating, the minutes as reader count, and the total minutes as a ranking score.",
    "id": 230
  },
  {
    "ir": "Write a PLpgSQL stored procedure named compare_book_metrics that accepts three parameters: p_first_id of type INTEGER, p_second_id of type INTEGER, and p_threshold of type REAL. The procedure begins by declaring four local variables: v_first_rating and v_second_rating of type REAL, and v_first_readers and v_second_readers of type REAL. It then retrieves the \"Rating\" and \"Readers_in_Million\" values from the review table for the book with the ID matching p_first_id, storing these values into v_first_rating and v_first_readers, respectively. Similarly, it retrieves the \"Rating\" and \"Readers_in_Million\" values for the book with the ID matching p_second_id, storing these values into v_second_rating and v_second_readers. The procedure then evaluates the absolute difference between v_first_rating and v_second_rating. If this difference exceeds the value of p_threshold, it inserts a new row into the review table with the following values: a \"Review_ID\" generated by selecting the maximum \"Review_ID\" from the review table and adding one, the book ID p_first_id, the rating v_first_rating, the readers count v_first_readers, and a rank of 1. If the difference does not exceed p_threshold, it inserts a new row into the review table with a \"Review_ID\" generated similarly, the book ID p_second_id, the rating v_second_rating, the readers count v_second_readers, and a rank of 2.",
    "plsql": "CREATE OR REPLACE PROCEDURE compare_book_metrics(p_first_id INTEGER, p_second_id INTEGER, p_threshold REAL)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_first_rating REAL;\n    v_second_rating REAL;\n    v_first_readers REAL;\n    v_second_readers REAL;\nBEGIN\n    SELECT \"Rating\", \"Readers_in_Million\" INTO v_first_rating, v_first_readers FROM review WHERE \"Book_ID\" = p_first_id;\n    SELECT \"Rating\", \"Readers_in_Million\" INTO v_second_rating, v_second_readers FROM review WHERE \"Book_ID\" = p_second_id;\n    IF ABS(v_first_rating - v_second_rating) > p_threshold THEN\n        INSERT INTO review (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES ((SELECT COALESCE(MAX(\"Review_ID\"),0)+1 FROM review), p_first_id, v_first_rating, v_first_readers, 1);\n    ELSE\n        INSERT INTO review (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES ((SELECT COALESCE(MAX(\"Review_ID\"),0)+1 FROM review), p_second_id, v_second_rating, v_second_readers, 2);\n    END IF;\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL compare_book_metrics(1, 2, 0.5);",
      "CALL compare_book_metrics(2, 3, 0.3);",
      "CALL compare_book_metrics(1, 3, 0.7);",
      "CALL compare_book_metrics(3, 1, 0.4);",
      "CALL compare_book_metrics(2, 1, 0.6);"
    ],
    "summary": "Create a stored procedure named compare_book_metrics that takes two book IDs and a threshold value. Retrieve the rating and readers count for each book. If the absolute difference between their ratings exceeds the threshold, insert a new review record for the first book with rank 1. Otherwise, insert a new review record for the second book with rank 2. Generate a new Review_ID by incrementing the maximum existing ID.",
    "natural_language": "List the rating and readers count for two specified books. If the absolute difference between their ratings is greater than a given threshold, insert a new review record with rank 1 for the first book. Otherwise, insert a new review record with rank 2 for the second book. Generate a new Review_ID by incrementing the maximum existing ID. Do this by creating a stored procedure named compare_book_metrics that accepts the two book IDs and the threshold value.",
    "id": 231
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named transform_release_date that accepts three input parameters: p_book_id of type INTEGER to identify a specific book record, p_date_format of type TEXT which is declared but not used within the procedure's logic, and p_year_offset of type INTEGER to adjust the year value. The procedure begins by declaring local variables v_release_text, v_month, v_year, and v_transformed_date, all of type TEXT except v_year which is INTEGER. It executes a SELECT query to retrieve the value from the \"Release\" column of the book table for the row where the \"Book_ID\" column matches the provided p_book_id parameter, storing the result into v_release_text. If no such row is found, it raises an exception with the message 'Book_ID % not found', where the placeholder is replaced by the actual p_book_id value. Assuming a row is found, it uses the SPLIT_PART function to parse v_release_text, assuming it contains a space-separated string; the first part (before the first space) is assigned to v_month, and the second part (after the first space) is cast to an INTEGER, has the p_year_offset added to it, and the result is assigned to v_year. It then constructs v_transformed_date by concatenating v_month, a single space, and the string representation of v_year. Finally, the procedure performs an INSERT operation into the review table, specifying the columns \"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", and \"Rank\". The value for \"Review_ID\" is determined by a subquery that selects the maximum existing value from the \"Review_ID\" column in the review table, uses COALESCE to return 0 if the maximum is NULL, and adds 1 to that result. The \"Book_ID\" is set to the input parameter p_book_id, the \"Rating\" is set to the calculated v_year integer, the \"Readers_in_Million\" is hardcoded to 0, and the \"Rank\" is set to the character length of the v_transformed_date string, obtained using the LENGTH function.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_release_date(p_book_id INTEGER, p_date_format TEXT, p_year_offset INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_release_text TEXT;\n    v_month TEXT;\n    v_year INTEGER;\n    v_transformed_date TEXT;\nBEGIN\n    SELECT \"Release\" INTO v_release_text FROM book WHERE \"Book_ID\" = p_book_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Book_ID % not found', p_book_id;\n    END IF;\n    \n    v_month := SPLIT_PART(v_release_text, ' ', 1);\n    v_year := CAST(SPLIT_PART(v_release_text, ' ', 2) AS INTEGER) + p_year_offset;\n    v_transformed_date := v_month || ' ' || CAST(v_year AS TEXT);\n    \n    INSERT INTO review (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") \n    VALUES ((SELECT COALESCE(MAX(\"Review_ID\"),0)+1 FROM review), p_book_id, v_year, 0, LENGTH(v_transformed_date));\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL transform_release_date(1, 'MM YYYY', 1);",
      "CALL transform_release_date(2, 'MM YYYY', 2);",
      "CALL transform_release_date(3, 'MM YYYY', 3);",
      "CALL transform_release_date(1, 'MM YYYY', 0);",
      "CALL transform_release_date(2, 'MM YYYY', -1);"
    ],
    "summary": "Create a stored procedure named transform_release_date that takes a book ID, an unused date format, and a year offset. Retrieve the book's release text. If not found, raise an exception. Parse the text to extract month and year, add the offset to the year, and reconstruct the date. Insert a new review record using the book ID, the calculated year as the rating, 0 for readers, and the length of the transformed date string as the rank. Generate a new Review_ID by incrementing the maximum existing ID.",
    "natural_language": "Create a stored procedure called transform_release_date that needs a book ID, some kind of date format that isn't used, and a number to adjust the year. Get the book's release text. If you can't find it, throw an error. Figure out the month and year from that text, tweak the year by the given amount, and put the date back together. Then, add a new review entry using the book ID, the adjusted year as the rating, set readers to zero, and use how long the new date string is for the rank. Make a new Review_ID by taking the highest current ID and adding a bit to it.",
    "id": 232
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `insert_new_genre` that accepts a single input parameter. This parameter, named `new_genre`, is of type `TEXT` and represents the name of the new genre to be added to the database. The procedure begins by declaring a local variable named `max_gid` of type `INTEGER`. It then executes a `SELECT` statement to retrieve the maximum value currently present in the `gid` column of the `genre` table. The result of this `SELECT` statement is stored in the `max_gid` variable. Following this, the procedure performs an `INSERT` operation into the `genre` table. For the `gid` column, it calculates the value by taking the `max_gid` variable, applying the `COALESCE` function to it (which returns `max_gid` if it's not `NULL`, otherwise it returns `0`), and then adding `1` to the result. For the `genre` column, it uses the value provided by the `new_genre` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_genre(IN new_genre TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    max_gid INTEGER;\nBEGIN\n    SELECT MAX(\"gid\") INTO max_gid FROM \"genre\";\n    INSERT INTO \"genre\" (\"gid\", \"genre\") VALUES (COALESCE(max_gid, 0) + 1, new_genre);\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "classification",
      "directed_by",
      "director",
      "genre",
      "made_by",
      "producer"
    ],
    "call_sqls": [
      "CALL insert_new_genre('Action');",
      "CALL insert_new_genre('Comedy');",
      "CALL insert_new_genre('Drama');",
      "CALL insert_new_genre('Science Fiction');",
      "CALL insert_new_genre('Horror');"
    ],
    "summary": "Create a stored procedure named insert_new_genre that takes a new genre name. Find the maximum existing genre ID. Insert a new genre record with an ID calculated by incrementing the maximum ID (or starting at 1 if none exist) and the provided genre name.",
    "natural_language": "Create procedure insert_new_genre to add a new genre. It finds the max current genre ID, increments it (or uses 1 if none), and inserts the new record.",
    "id": 233
  },
  {
    "ir": "Write a PLpgSQL stored procedure named analyze_movie_ratings that accepts a single integer parameter p_year_threshold, which serves as a threshold year for categorizing movies into old and new. The procedure begins by declaring several integer and numeric variables: v_old_movie_count, v_new_movie_count, v_high_rating_count, v_low_rating_count, v_avg_rating, and v_total_reviewers. It then performs a series of SELECT operations to populate these variables. First, it counts the number of distinct movies released before the threshold year and stores this count in v_old_movie_count. Next, it counts the number of distinct movies released in or after the threshold year and stores this count in v_new_movie_count. It then counts the number of ratings with 4 or more stars and stores this count in v_high_rating_count, followed by counting ratings with 2 or fewer stars and storing this count in v_low_rating_count. The procedure calculates the average star rating across all ratings and stores this value in v_avg_rating. Finally, it counts the number of distinct reviewers and stores this count in v_total_reviewers. The procedure then evaluates several conditional statements based on the values of these variables. If the count of old movies exceeds the count of new movies and the average rating is greater than 3, it deletes ratings with fewer than 3 stars for movies released before the threshold year. If the count of new movies exceeds the count of old movies and the average rating is 3 or less, it deletes ratings with more than 3 stars for movies released in or after the threshold year. If the count of high ratings exceeds the count of low ratings and there are reviewers available, it inserts new ratings with 3 stars for up to 5 combinations of reviewers and movies where the reviewer has not yet rated the movie. If the count of low ratings exceeds the count of high ratings and there are reviewers available, it inserts new ratings with 4 stars for up to 3 combinations of reviewers and movies where the reviewer has not yet rated the movie. If the average rating is null, indicating no ratings exist, it inserts a default rating of 3 stars for a specific reviewer and movie. Otherwise, it inserts a new rating with 2 stars for one combination of reviewer and movie where the reviewer has not yet rated the movie.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_movie_ratings(p_year_threshold integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_old_movie_count integer;\n    v_new_movie_count integer;\n    v_high_rating_count integer;\n    v_low_rating_count integer;\n    v_avg_rating numeric;\n    v_total_reviewers integer;\nBEGIN\n    SELECT COUNT(DISTINCT m.\"mID\") INTO v_old_movie_count FROM \"Movie\" m WHERE m.\"year\" < p_year_threshold;\n    SELECT COUNT(DISTINCT m.\"mID\") INTO v_new_movie_count FROM \"Movie\" m WHERE m.\"year\" >= p_year_threshold;\n    SELECT COUNT(*) INTO v_high_rating_count FROM \"Rating\" rt WHERE rt.\"stars\" >= 4;\n    SELECT COUNT(*) INTO v_low_rating_count FROM \"Rating\" rt WHERE rt.\"stars\" <= 2;\n    SELECT AVG(rt.\"stars\") INTO v_avg_rating FROM \"Rating\" rt;\n    SELECT COUNT(DISTINCT r.\"rID\") INTO v_total_reviewers FROM \"Reviewer\" r;\n    \n    IF v_old_movie_count > v_new_movie_count AND v_avg_rating > 3 THEN\n        DELETE FROM \"Rating\" rt WHERE rt.\"mID\" IN (SELECT m.\"mID\" FROM \"Movie\" m WHERE m.\"year\" < p_year_threshold) AND rt.\"stars\" < 3;\n    ELSIF v_new_movie_count > v_old_movie_count AND v_avg_rating <= 3 THEN\n        DELETE FROM \"Rating\" rt WHERE rt.\"mID\" IN (SELECT m.\"mID\" FROM \"Movie\" m WHERE m.\"year\" >= p_year_threshold) AND rt.\"stars\" > 3;\n    ELSIF v_high_rating_count > v_low_rating_count AND v_total_reviewers > 0 THEN\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") SELECT r.\"rID\", m.\"mID\", 3, CURRENT_DATE FROM \"Reviewer\" r CROSS JOIN \"Movie\" m WHERE r.\"rID\" NOT IN (SELECT \"rID\" FROM \"Rating\" WHERE \"mID\" = m.\"mID\") LIMIT 5;\n    ELSIF v_low_rating_count > v_high_rating_count AND v_total_reviewers > 0 THEN\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") SELECT r.\"rID\", m.\"mID\", 4, CURRENT_DATE FROM \"Reviewer\" r CROSS JOIN \"Movie\" m WHERE r.\"rID\" NOT IN (SELECT \"rID\" FROM \"Rating\" WHERE \"mID\" = m.\"mID\") LIMIT 3;\n    ELSIF v_avg_rating IS NULL THEN\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") VALUES (1, 1, 3, CURRENT_DATE);\n    ELSE\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") SELECT r.\"rID\", m.\"mID\", 2, CURRENT_DATE FROM \"Reviewer\" r CROSS JOIN \"Movie\" m WHERE r.\"rID\" NOT IN (SELECT \"rID\" FROM \"Rating\" WHERE \"mID\" = m.\"mID\") LIMIT 1;\n    END IF;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL analyze_movie_ratings(1950);",
      "CALL analyze_movie_ratings(1960);",
      "CALL analyze_movie_ratings(1970);",
      "CALL analyze_movie_ratings(1980);",
      "CALL analyze_movie_ratings(1990);"
    ],
    "summary": "Create a stored procedure named analyze_movie_ratings that takes a year threshold. Count old and new movies, high and low ratings, calculate the average rating, and count total reviewers. Based on these counts and averages: delete low-rated old movies if old movies outnumber new ones and average rating > 3; delete high-rated new movies if new movies outnumber old ones and average rating <= 3; insert up to 5 new 3-star ratings if high ratings outnumber low ratings and reviewers exist; insert up to 3 new 4-star ratings if low ratings outnumber high ratings and reviewers exist; insert a default 3-star rating if no ratings exist; otherwise, insert one new 2-star rating.",
    "natural_language": "What stored procedure can be created to analyze movie ratings based on a given year threshold? The procedure should count old and new movies, high and low ratings, calculate the average rating, and count total reviewers. Based on these results, what actions should it take: deleting low-rated old movies if old movies outnumber new ones and the average rating is above 3; deleting high-rated new movies if new movies outnumber old ones and the average rating is 3 or less; inserting up to 5 new 3-star ratings if high ratings outnumber low ratings and reviewers exist; inserting up to 3 new 4-star ratings if low ratings outnumber high ratings and reviewers exist; inserting a default 3-star rating if no ratings exist; or otherwise inserting one new 2-star rating?",
    "id": 234
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named process_enrollment_schedule that takes no parameters and begins by declaring four local variables: a TEXT variable named current_day, and three BOOLEAN variables named math_exists, science_exists, and arts_exists. The procedure first extracts the current day of the month as a number from the system's transaction timestamp using the EXTRACT(day FROM ...) function, casts it to TEXT, and stores it in the current_day variable. It then performs three separate existence checks on the course table, each using a SELECT EXISTS subquery that looks for a specific value in the Course column; the first check looks for the exact string 'Math' and stores the result in math_exists, the second looks for 'Science' and stores the result in science_exists, and the third looks for 'Language Arts' and stores the result in arts_exists. The core logic uses nested IF-ELSIF-ELSE conditional blocks based on these Boolean flags: if both math_exists and science_exists are TRUE, it checks arts_exists, and if arts_exists is also TRUE, it executes a DELETE statement on the course table to remove any rows where the Course column equals 'Language Arts', but if arts_exists is FALSE, it executes an INSERT statement into the course table, providing values for the Course_ID, Staring_Date, and Course columns, where Course_ID is the integer 500, Staring_Date is a string concatenation of the current_day variable and the literal ' August', and Course is the string 'Combined STEM'. If the first condition is not met but either math_exists OR science_exists is TRUE, it again checks arts_exists; if arts_exists is TRUE, it executes an INSERT into the course table with Course_ID as 600, Staring_Date as the concatenation of current_day and ' September', and Course as 'Interdisciplinary', but if arts_exists is FALSE, it executes a DELETE from the course table for any rows where the Course column is IN the list ('Math', 'Science'). If none of the above conditions are met (meaning both math_exists and science_exists are FALSE), it checks arts_exists one final time; if arts_exists is TRUE, it executes an INSERT into the course table with Course_ID as 700, Staring_Date as the concatenation of current_day and ' October', and Course as 'Humanities Focus', but if arts_exists is FALSE, it executes an INSERT with Course_ID as 800, Staring_Date as the concatenation of current_day and ' November', and Course as 'Foundation Course'.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_enrollment_schedule()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    current_day TEXT;\n    math_exists BOOLEAN;\n    science_exists BOOLEAN;\n    arts_exists BOOLEAN;\nBEGIN\n    SELECT EXTRACT(day FROM transaction_timestamp())::TEXT INTO current_day;\n    \n    SELECT EXISTS(SELECT 1 FROM course WHERE \"Course\" = 'Math') INTO math_exists;\n    SELECT EXISTS(SELECT 1 FROM course WHERE \"Course\" = 'Science') INTO science_exists;\n    SELECT EXISTS(SELECT 1 FROM course WHERE \"Course\" = 'Language Arts') INTO arts_exists;\n    \n    IF math_exists AND science_exists THEN\n        IF arts_exists THEN\n            DELETE FROM course WHERE \"Course\" = 'Language Arts';\n        ELSE\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (500, current_day || ' August', 'Combined STEM');\n        END IF;\n    ELSIF math_exists OR science_exists THEN\n        IF arts_exists THEN\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (600, current_day || ' September', 'Interdisciplinary');\n        ELSE\n            DELETE FROM course WHERE \"Course\" IN ('Math', 'Science');\n        END IF;\n    ELSE\n        IF arts_exists THEN\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (700, current_day || ' October', 'Humanities Focus');\n        ELSE\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (800, current_day || ' November', 'Foundation Course');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL process_enrollment_schedule();"
    ],
    "summary": "Create a stored procedure named process_enrollment_schedule with no parameters. Get the current day of the month. Check if 'Math', 'Science', and 'Language Arts' courses exist. If Math and Science exist and Language Arts exists, delete the 'Language Arts' course. If Math and Science exist but Language Arts does not, insert a 'Combined STEM' course. If either Math or Science exists and Language Arts exists, insert an 'Interdisciplinary' course. If either Math or Science exists but Language Arts does not, delete the 'Math' and 'Science' courses. If neither Math nor Science exists and Language Arts exists, insert a 'Humanities Focus' course. If none of the above conditions are met, insert a 'Foundation Course'. Use the current day in the starting date for inserted courses.",
    "natural_language": "Write a stored procedure called process_enrollment_schedule that takes no parameters. First, determine the current day of the month. Then, check for the existence of the 'Math', 'Science', and 'Language Arts' courses. If both Math and Science exist and Language Arts also exists, delete the 'Language Arts' course. If Math and Science exist but Language Arts does not, insert a 'Combined STEM' course. If either Math or Science exists and Language Arts exists, insert an 'Interdisciplinary' course. If either Math or Science exists but Language Arts does not, delete both the 'Math' and 'Science' courses. If neither Math nor Science exists but Language Arts does exist, insert a 'Humanities Focus' course. If none of these conditions are met, insert a 'Foundation Course'. For any inserted course, use the current day as the day component in its starting date.",
    "id": 235
  },
  {
    "ir": "Write a PLpgSQL stored procedure named reorganize_course_structure that performs operations on the course table based on the total number of courses. First, it declares three integer variables: total_courses, first_course_id, and last_course_id. It then selects the count of all rows in the course table into the total_courses variable. If total_courses is greater than 8, it selects the minimum Course_ID from the course table into first_course_id. If first_course_id is less than 5, it deletes the row from the course table where Course_ID equals first_course_id. Otherwise, it inserts a new row into the course table with Course_ID set to 900, Staring_Date set to '1 December', and Course set to 'Preparatory Course'. If total_courses is greater than 4 but not more than 8, it selects the maximum Course_ID from the course table into last_course_id. If last_course_id is greater than 10, it inserts a new row into the course table with Course_ID set to 1000, Staring_Date set to '15 December', and Course set to 'Advanced Studies'. Otherwise, it deletes the row from the course table where Course_ID equals last_course_id. If total_courses is 4 or fewer, it selects the minimum Course_ID from the course table where the Course column contains the substring 'Math' into first_course_id. If first_course_id is not null, it inserts a new row into the course table with Course_ID set to 1100, Staring_Date set to '31 December', and Course set to 'Mathematics Extension'. If first_course_id is null, it inserts a new row into the course table with Course_ID set to 1200, Staring_Date set to '1 January', and Course set to 'Basic Mathematics'.",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_course_structure()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_courses INTEGER;\n    first_course_id INTEGER;\n    last_course_id INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO total_courses FROM course;\n    \n    IF total_courses > 8 THEN\n        SELECT MIN(\"Course_ID\") INTO first_course_id FROM course;\n        IF first_course_id < 5 THEN\n            DELETE FROM course WHERE \"Course_ID\" = first_course_id;\n        ELSE\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (900, '1 December', 'Preparatory Course');\n        END IF;\n    ELSIF total_courses > 4 THEN\n        SELECT MAX(\"Course_ID\") INTO last_course_id FROM course;\n        IF last_course_id > 10 THEN\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (1000, '15 December', 'Advanced Studies');\n        ELSE\n            DELETE FROM course WHERE \"Course_ID\" = last_course_id;\n        END IF;\n    ELSE\n        SELECT MIN(\"Course_ID\") INTO first_course_id FROM course WHERE \"Course\" LIKE '%Math%';\n        IF first_course_id IS NOT NULL THEN\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (1100, '31 December', 'Mathematics Extension');\n        ELSE\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (1200, '1 January', 'Basic Mathematics');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL reorganize_course_structure();"
    ],
    "summary": "Create a stored procedure named reorganize_course_structure. Declare integer variables total_courses, first_course_id, and last_course_id. Count all rows in the course table into total_courses. If total_courses > 8, find the minimum Course_ID into first_course_id. If first_course_id < 5, delete the row where Course_ID equals first_course_id. Otherwise, insert a new row with Course_ID=900, Staring_Date='1 December', Course='Preparatory Course'. If total_courses > 4 and <= 8, find the maximum Course_ID into last_course_id. If last_course_id > 10, insert a new row with Course_ID=1000, Staring_Date='15 December', Course='Advanced Studies'. Otherwise, delete the row where Course_ID equals last_course_id. If total_courses <= 4, find the minimum Course_ID where Course contains 'Math' into first_course_id. If first_course_id is not null, insert a new row with Course_ID=1100, Staring_Date='31 December', Course='Mathematics Extension'. If first_course_id is null, insert a new row with Course_ID=1200, Staring_Date='1 January', Course='Basic Mathematics'.",
    "natural_language": "Alright, so we need a stored procedure called 'reorganize_course_structure'. We'll need a few integer variables: total_courses, first_course_id, and last_course_id. First off, count up all the courses in the table and stash that number in total_courses. If we've got more than 8 courses total, we gotta find the smallest Course_ID and put it in first_course_id. If that smallest ID is less than 5, just go ahead and delete that course row. If it's not less than 5, then we should add a new course with ID 900, starting on '1 December', called 'Preparatory Course'.\n\nNow, if the total is more than 4 but 8 or less, we need to find the biggest Course_ID and put it in last_course_id. If that biggest ID is bigger than 10, we'll insert a new advanced course: ID 1000, starting '15 December', named 'Advanced Studies'. Otherwise, if it's not bigger than 10, just delete that last course row.\n\nIf we've got 4 or fewer courses total, look for the smallest Course_ID where the course name has 'Math' in it and put that in first_course_id. If we actually found a math course (so first_course_id isn't null), then add a new math extension course: ID 1100, starting '31 December', called 'Mathematics Extension'. If we didn't find any math course (first_course_id is null), then add a basic math course instead: ID 1200, starting '1 January', called 'Basic Mathematics'.",
    "id": 236
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `validate_course_offerings` that performs a series of conditional data manipulations on the `course` table. The procedure begins by declaring a record variable named `course_rec` to hold individual row data and a cursor named `course_cursor`. This cursor is defined to select the `Course_ID`, `Course`, and `Staring_Date` columns from the `course` table, with the results ordered in ascending order by the `Course_ID` column. The procedure then opens the `course_cursor` to activate the query and prepare for fetching rows. It enters a loop that continuously fetches the next row from `course_cursor` into the `course_rec` record variable. The loop terminates when no more rows are found by the `FETCH` operation. Inside the loop, for each fetched `course_rec`, a series of conditional checks are performed based on the value of `course_rec.\"Course_ID\"`.\n\nThe first condition checks if `course_rec.\"Course_ID\"` is less than 10.\nIf this condition is true, a nested conditional check is performed:\n    If `course_rec.\"Course\"` is exactly equal to the string 'Math', then a `DELETE` operation is executed on the `course` table, removing the row where the `Course_ID` column matches the `Course_ID` value from the current `course_rec`.\n    Otherwise (if `course_rec.\"Course\"` is not 'Math'), an `INSERT` operation is executed on the `course` table. A new row is inserted with `Course_ID` set to the value of `course_rec.\"Course_ID\"` plus 1000, `Staring_Date` set to the literal string '1 February', and `Course` set to the concatenation of the string 'Updated ' and the value of `course_rec.\"Course\"`.\n\nIf the first condition (`course_rec.\"Course_ID\"` < 10) is false, the procedure proceeds to the next condition, which checks if `course_rec.\"Course_ID\"` is less than 50.\nIf this condition is true, another nested conditional check is performed:\n    If `course_rec.\"Course\"` is exactly equal to the string 'Science', then an `INSERT` operation is executed on the `course` table. A new row is inserted with `Course_ID` set to the value of `course_rec.\"Course_ID\"` plus 2000, `Staring_Date` set to the literal string '15 February', and `Course` set to the literal string 'Enhanced Science'.\n    Otherwise (if `course_rec.\"Course\"` is not 'Science'), a `DELETE` operation is executed on the `course` table, removing rows where the `Course_ID` column matches the `Course_ID` value from the current `course_rec` AND the `Course` column is NOT equal to the string 'Language Arts'.\n\nIf both previous conditions (`course_rec.\"Course_ID\"` < 10 and `course_rec.\"Course_ID\"` < 50) are false, the procedure executes the `ELSE` block, meaning `course_rec.\"Course_ID\"` is 50 or greater.\nInside this `ELSE` block, a final nested conditional check is performed:\n    If `course_rec.\"Course\"` contains the substring 'Arts' (case-insensitive due to `LIKE` operator), then an `INSERT` operation is executed on the `course` table. A new row is inserted with `Course_ID` set to the value of `course_rec.\"Course_ID\"` plus 3000, `Staring_Date` set to the literal string '28 February', and `Course` set to the literal string 'Creative Arts'.\n    Otherwise (if `course_rec.\"Course\"` does not contain the substring 'Arts'), an `INSERT` operation is executed on the `course` table. A new row is inserted with `Course_ID` set to the value of `course_rec.\"Course_ID\"` plus 4000, `Staring_Date` set to the literal string '1 March', and `Course` set to the literal string 'General Studies'.\n\nAfter the loop finishes processing all rows from the `course_cursor`, the procedure closes the `course_cursor` to release its resources.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_course_offerings()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    course_rec RECORD;\n    course_cursor CURSOR FOR SELECT \"Course_ID\", \"Course\", \"Staring_Date\" FROM course ORDER BY \"Course_ID\";\nBEGIN\n    OPEN course_cursor;\n    \n    LOOP\n        FETCH course_cursor INTO course_rec;\n        EXIT WHEN NOT FOUND;\n        \n        IF course_rec.\"Course_ID\" < 10 THEN\n            IF course_rec.\"Course\" = 'Math' THEN\n                DELETE FROM course WHERE \"Course_ID\" = course_rec.\"Course_ID\";\n            ELSE\n                INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (course_rec.\"Course_ID\" + 1000, '1 February', 'Updated ' || course_rec.\"Course\");\n            END IF;\n        ELSIF course_rec.\"Course_ID\" < 50 THEN\n            IF course_rec.\"Course\" = 'Science' THEN\n                INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (course_rec.\"Course_ID\" + 2000, '15 February', 'Enhanced Science');\n            ELSE\n                DELETE FROM course WHERE \"Course_ID\" = course_rec.\"Course_ID\" AND \"Course\" != 'Language Arts';\n            END IF;\n        ELSE\n            IF course_rec.\"Course\" LIKE '%Arts%' THEN\n                INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (course_rec.\"Course_ID\" + 3000, '28 February', 'Creative Arts');\n            ELSE\n                INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (course_rec.\"Course_ID\" + 4000, '1 March', 'General Studies');\n            END IF;\n        END IF;\n    END LOOP;\n    \n    CLOSE course_cursor;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL validate_course_offerings();"
    ],
    "summary": "Create a stored procedure named validate_course_offerings. Declare a record variable course_rec and a cursor course_cursor to select Course_ID, Course, and Staring_Date from the course table ordered by Course_ID. Loop through each row from the cursor. If Course_ID < 10 and Course = 'Math', delete the row with that Course_ID. If Course_ID < 10 and Course != 'Math', insert a new row with Course_ID = (original Course_ID + 1000), Staring_Date='1 February', Course='Updated ' || original Course. If Course_ID >= 10 and < 50 and Course = 'Science', insert a new row with Course_ID = (original Course_ID + 2000), Staring_Date='15 February', Course='Enhanced Science'. If Course_ID >= 10 and < 50 and Course != 'Science', delete rows where Course_ID matches the original AND Course != 'Language Arts'. If Course_ID >= 50 and Course contains 'Arts', insert a new row with Course_ID = (original Course_ID + 3000), Staring_Date='28 February', Course='Creative Arts'. If Course_ID >= 50 and Course does not contain 'Arts', insert a new row with Course_ID = (original Course_ID + 4000), Staring_Date='1 March', Course='General Studies'. Close the cursor after the loop.",
    "natural_language": "Create a stored procedure called validate_course_offerings. Declare a record variable named course_rec and a cursor named course_cursor to fetch Course_ID, Course, and Staring_Date from the course table, ordering by Course_ID. Loop through each cursor row. For rows where Course_ID is less than 10 and Course is 'Math', delete the row with that Course_ID. For rows where Course_ID is less than 10 and Course is not 'Math', insert a new row using the original Course_ID plus 1000, set Staring_Date to '1 February', and set Course to 'Updated ' concatenated with the original Course. For rows where Course_ID is between 10 and 49 and Course is 'Science', insert a new row using the original Course_ID plus 2000, set Staring_Date to '15 February', and set Course to 'Enhanced Science'. For rows where Course_ID is between 10 and 49 and Course is not 'Science', delete any rows from the table where the Course_ID matches the original and the Course is not 'Language Arts'. For rows where Course_ID is 50 or greater and the Course contains 'Arts', insert a new row using the original Course_ID plus 3000, set Staring_Date to '28 February', and set Course to 'Creative Arts'. For rows where Course_ID is 50 or greater and the Course does not contain 'Arts', insert a new row using the original Course_ID plus 4000, set Staring_Date to '1 March', and set Course to 'General Studies'. Close the cursor after finishing the loop.",
    "id": 237
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named archive_course_data that takes no parameters and operates on a table named course. The procedure begins by declaring four integer variables: archive_count, math_count, science_count, and arts_count. It then executes four separate SELECT COUNT(*) queries into these variables from the course table. The first query, for archive_count, counts all rows where the column \"Staring_Date\" contains the substring 'May' anywhere within it. The second query, for math_count, counts rows where the column \"Course\" exactly equals the string 'Math'. The third query, for science_count, counts rows where \"Course\" exactly equals 'Science'. The fourth query, for arts_count, counts rows where \"Course\" exactly equals 'Language Arts'.\n\nFollowing these counts, the procedure uses a nested IF-ELSIF-ELSE conditional structure to determine its actions. If archive_count is greater than 2, it enters a secondary IF block: if math_count is greater than 0, it executes a DELETE operation on the course table, removing any rows where the \"Course\" column is 'Math' AND the \"Staring_Date\" column contains 'May'; otherwise, if math_count is 0, it performs an INSERT into the course table, adding a new row with \"Course_ID\" set to 5000, \"Staring_Date\" set to '1 April', and \"Course\" set to 'Archived Math'.\n\nIf the initial condition is not met and archive_count is greater than 0 (but less than or equal to 2), the procedure enters the ELSIF block. Within this block, if science_count is greater than 0, it executes an INSERT into the course table, adding a new row with \"Course_ID\" set to 6000, \"Staring_Date\" set to '15 April', and \"Course\" set to 'Archived Science'; otherwise, if science_count is 0, it executes a DELETE operation, removing all rows from the course table where the \"Course\" column is 'Science'.\n\nIf neither of the above conditions is true (meaning archive_count is 0), the procedure enters the final ELSE block. Here, if arts_count is greater than 0, it executes an INSERT into the course table, adding a new row with \"Course_ID\" set to 7000, \"Staring_Date\" set to '30 April', and \"Course\" set to 'Archived Arts'; otherwise, if arts_count is 0, it executes a different INSERT, adding a new row with \"Course_ID\" set to 8000, \"Staring_Date\" set to '1 May', and \"Course\" set to 'New Archive Entry'.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_course_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    archive_count INTEGER;\n    math_count INTEGER;\n    science_count INTEGER;\n    arts_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO archive_count FROM course WHERE \"Staring_Date\" LIKE '%May%';\n    SELECT COUNT(*) INTO math_count FROM course WHERE \"Course\" = 'Math';\n    SELECT COUNT(*) INTO science_count FROM course WHERE \"Course\" = 'Science';\n    SELECT COUNT(*) INTO arts_count FROM course WHERE \"Course\" = 'Language Arts';\n    \n    IF archive_count > 2 THEN\n        IF math_count > 0 THEN\n            DELETE FROM course WHERE \"Course\" = 'Math' AND \"Staring_Date\" LIKE '%May%';\n        ELSE\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (5000, '1 April', 'Archived Math');\n        END IF;\n    ELSIF archive_count > 0 THEN\n        IF science_count > 0 THEN\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (6000, '15 April', 'Archived Science');\n        ELSE\n            DELETE FROM course WHERE \"Course\" = 'Science';\n        END IF;\n    ELSE\n        IF arts_count > 0 THEN\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (7000, '30 April', 'Archived Arts');\n        ELSE\n            INSERT INTO course (\"Course_ID\", \"Staring_Date\", \"Course\") VALUES (8000, '1 May', 'New Archive Entry');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL archive_course_data();"
    ],
    "summary": "Create a stored procedure named archive_course_data. Declare integer variables archive_count, math_count, science_count, and arts_count. Set archive_count to the count of rows where Staring_Date contains 'May'. Set math_count to the count where Course = 'Math'. Set science_count to the count where Course = 'Science'. Set arts_count to the count where Course = 'Language Arts'. If archive_count > 2 and math_count > 0, delete rows where Course = 'Math' and Staring_Date contains 'May'. If archive_count > 2 and math_count = 0, insert a row with Course_ID=5000, Staring_Date='1 April', Course='Archived Math'. If archive_count > 0 and <= 2 and science_count > 0, insert a row with Course_ID=6000, Staring_Date='15 April', Course='Archived Science'. If archive_count > 0 and <= 2 and science_count = 0, delete rows where Course = 'Science'. If archive_count = 0 and arts_count > 0, insert a row with Course_ID=7000, Staring_Date='30 April', Course='Archived Arts'. If archive_count = 0 and arts_count = 0, insert a row with Course_ID=8000, Staring_Date='1 May', Course='New Archive Entry'.",
    "natural_language": "Create procedure archive_course_data. Declare integers archive_count, math_count, science_count, arts_count. Set archive_count = rows where Staring_Date has 'May'. Set math_count = rows where Course is 'Math'. Set science_count = rows where Course is 'Science'. Set arts_count = rows where Course is 'Language Arts'. If archive_count > 2 and math_count > 0, delete rows for Course='Math' and Staring_Date with 'May'. If archive_count > 2 and math_count = 0, insert row (5000, '1 April', 'Archived Math'). If archive_count > 0 and <= 2 and science_count > 0, insert row (6000, '15 April', 'Archived Science'). If archive_count > 0 and <= 2 and science_count = 0, delete rows for Course='Science'. If archive_count = 0 and arts_count > 0, insert row (7000, '30 April', 'Archived Arts'). If archive_count = 0 and arts_count = 0, insert row (8000, '1 May', 'New Archive Entry').",
    "id": 238
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named register_party_service that accepts four input parameters: a parameter named customer_party_id of type BIGINT which represents the unique identifier for the customer party, a parameter named target_service_id of type BIGINT which represents the unique identifier for the service to be booked, a parameter named booking_date of type DATE which signifies the date when the booking is being made, and a parameter named service_schedule_date of type DATE which indicates the scheduled date for the service to be performed. The procedure executes a single SQL INSERT operation into a table named \"Party_Services\". The insertion populates four columns in the \"Party_Services\" table: the customer_id column is set to the value of the customer_party_id input parameter, the service_id column is set to the value of the target_service_id input parameter, the booking_made_date column is set to the booking_date input parameter after explicitly casting it to a TIMESTAMP WITH TIME ZONE data type, and the service_datetime column is set to the service_schedule_date input parameter after explicitly casting it to a TIMESTAMP WITH TIME ZONE data type.",
    "plsql": "CREATE OR REPLACE PROCEDURE register_party_service(customer_party_id BIGINT, target_service_id BIGINT, booking_date DATE, service_schedule_date DATE)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Party_Services\" (customer_id, service_id, booking_made_date, service_datetime)\n    VALUES (\n        customer_party_id,\n        target_service_id,\n        booking_date::timestamp with time zone,\n        service_schedule_date::timestamp with time zone\n    );\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Forms",
      "Services",
      "Party_Forms",
      "Party_Services",
      "Individuals"
    ],
    "call_sqls": [
      "CALL register_party_service(10, 12, '2023-10-15', '2023-11-20');",
      "CALL register_party_service(14, 11, '2023-10-16', '2023-11-25');",
      "CALL register_party_service(4, 7, '2023-10-17', '2023-11-30');",
      "CALL register_party_service(1, 1, '2023-10-18', '2023-12-01');",
      "CALL register_party_service(2, 3, '2023-10-19', '2023-12-05');"
    ],
    "summary": "Create a stored procedure named register_party_service with input parameters: customer_party_id (BIGINT), target_service_id (BIGINT), booking_date (DATE), service_schedule_date (DATE). Insert a row into the Party_Services table. Set customer_id to customer_party_id, service_id to target_service_id, booking_made_date to booking_date cast as TIMESTAMP WITH TIME ZONE, and service_datetime to service_schedule_date cast as TIMESTAMP WITH TIME ZONE.",
    "natural_language": "Create procedure register_party_service with inputs customer_party_id BIGINT, target_service_id BIGINT, booking_date DATE, service_schedule_date DATE. Insert into Party_Services setting customer_id to customer_party_id, service_id to target_service_id, booking_made_date to booking_date::TIMESTAMPTZ, service_datetime to service_schedule_date::TIMESTAMPTZ.",
    "id": 239
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `remove_expired_addresses` that accepts four input parameters: `target_party_id` of type `BIGINT`, `expiry_date` of type `DATE`, `address_type` of type `TEXT`, and `state_filter` of type `TEXT`. The purpose of this procedure is to remove specific address records from the `\"Party_Addresses\"` table based on a combination of criteria. The `target_party_id` parameter is used to identify the specific party whose addresses are being considered for removal. The `expiry_date` parameter defines the cutoff date for address expiration; addresses with a `date_address_to` on or before this date are candidates for removal. The `address_type` parameter specifies the type of address to be removed, matching against the `address_type_code` column. The `state_filter` parameter is used to narrow down the addresses to those located in a particular state, province, or county.\n\nThe procedure performs a single `DELETE` operation on the `\"Party_Addresses\"` table. This `DELETE` statement targets rows where the `party_id` column exactly matches the `target_party_id` input parameter. Additionally, it requires that the `DATE` part of the `date_address_to` column in `\"Party_Addresses\"` is less than or equal to the `expiry_date` input parameter. Furthermore, the `address_type_code` column in `\"Party_Addresses\"` must exactly match the `address_type` input parameter. Finally, to be deleted, the `address_id` from the `\"Party_Addresses\"` table must be present in the result set of a subquery. This subquery selects `address_id` values from the `\"Addresses\"` table where the `state_province_county` column exactly matches the `state_filter` input parameter. In essence, the procedure deletes party address records that belong to a specific party, have an expiration date on or before the provided `expiry_date`, are of a particular `address_type`, and are associated with an address located in the specified state, province, or county.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_expired_addresses(target_party_id BIGINT, expiry_date DATE, address_type TEXT, state_filter TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Party_Addresses\"\n    WHERE party_id = target_party_id\n    AND DATE(date_address_to) <= expiry_date\n    AND address_type_code = address_type\n    AND address_id IN (\n        SELECT address_id\n        FROM \"Addresses\"\n        WHERE state_province_county = state_filter\n    );\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Forms",
      "Services",
      "Party_Forms",
      "Party_Services",
      "Individuals"
    ],
    "call_sqls": [
      "CALL remove_expired_addresses(10, '2023-12-31', 'Residence', 'NorthCarolina');",
      "CALL remove_expired_addresses(15, '2022-06-15', 'Billing', 'Colorado');",
      "CALL remove_expired_addresses(4, '2024-01-01', 'Delivery', 'NewHampshire');",
      "CALL remove_expired_addresses(2, '2021-03-20', 'Residence', 'California');",
      "CALL remove_expired_addresses(8, '2023-10-10', 'Billing', 'Texas');"
    ],
    "summary": "Create a stored procedure named remove_expired_addresses with input parameters: target_party_id (BIGINT), expiry_date (DATE), address_type (TEXT), state_filter (TEXT). Delete rows from the Party_Addresses table where party_id equals target_party_id, the DATE part of date_address_to is <= expiry_date, and address_type_code equals address_type. Also, the address_id must be in the result of a subquery that selects address_id from the Addresses table where state_province_county equals state_filter.",
    "natural_language": "Create a stored procedure called remove_expired_addresses that takes in a target_party_id (BIGINT), an expiry_date (DATE), an address_type (TEXT), and a state_filter (TEXT). The procedure should get rid of some old entries from the Party_Addresses table for the given party. It should remove records where the address type matches the provided one, and where the end date is on or before the specified expiry date. Also, only delete addresses that are located in the general area or state indicated by the state_filter.",
    "id": 240
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_new_bridge that accepts two input parameters: an integer parameter named arch_id representing the identifier of an architect, and a text parameter named bridge_name representing the name of a bridge to be created, and performs a single INSERT operation into a table named bridge, specifying values for five columns: the architect_id column is set to the value of the arch_id input parameter, the name column is set to the value of the bridge_name input parameter, the location column is set to the literal string 'Unknown Location', the length_meters column is set to the numeric literal 0.0, and the length_feet column is also set to the numeric literal 0.0.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_bridge(arch_id INTEGER, bridge_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO bridge (architect_id, name, location, length_meters, length_feet)\n    VALUES (arch_id, bridge_name, 'Unknown Location', 0.0, 0.0);\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL insert_new_bridge(1, 'Golden Gate Bridge');",
      "CALL insert_new_bridge(2, 'Brooklyn Bridge');",
      "CALL insert_new_bridge(3, 'Millau Viaduct');",
      "CALL insert_new_bridge(1, 'London Bridge');",
      "CALL insert_new_bridge(2, 'Tower Bridge');"
    ],
    "summary": "Create a stored procedure named insert_new_bridge that inserts a new bridge record. It takes an architect ID and a bridge name as inputs. The procedure sets the bridge's location to 'Unknown Location' and its length fields to 0.0.",
    "natural_language": "Create a stored procedure called insert_new_bridge to add a new bridge record. It needs an architect ID and the bridge's name. The procedure should set the location to something like a default placeholder and initialize the length figures to a basic starting value.",
    "id": 241
  },
  {
    "ir": "Write a PLpgSQL stored procedure that accepts two parameters: arch_id of type INTEGER and data_type of type TEXT. The procedure performs a conditional deletion operation based on the value of the data_type parameter. If data_type is equal to the string 'bridges', the procedure deletes all rows from the bridge table where the architect_id column matches the provided arch_id. If data_type is not 'bridges', the procedure deletes all rows from the mill table where the architect_id column matches the provided arch_id. The procedure uses an IF statement to determine which table to delete from, ensuring that only the relevant data associated with the specified architect is removed based on the given data_type.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_architect_data(arch_id INTEGER, data_type TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF data_type = 'bridges' THEN\n        DELETE FROM bridge WHERE architect_id = arch_id;\n    ELSE\n        DELETE FROM mill WHERE architect_id = arch_id;\n    END IF;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL remove_architect_data(1, 'bridges');",
      "CALL remove_architect_data(2, 'mills');",
      "CALL remove_architect_data(3, 'bridges');",
      "CALL remove_architect_data(1, 'mills');",
      "CALL remove_architect_data(2, 'bridges');"
    ],
    "summary": "Create a stored procedure that conditionally deletes records based on a data type parameter. If the data type is 'bridges', delete from the bridge table where the architect ID matches. Otherwise, delete from the mill table where the architect ID matches.",
    "natural_language": "How can I create a stored procedure that deletes records from either the bridge table or the mill table, based on a provided data type parameter? It should delete from the bridge table when the data type is 'bridges' for a matching architect ID, and from the mill table otherwise for the same matching condition.",
    "id": 242
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named add_mill_structure that accepts two input parameters: an integer parameter named arch_id and a text parameter named mill_name, and performs a single INSERT operation into a database table named mill, specifically populating the architect_id column with the value from the arch_id parameter, the name column with the value from the mill_name parameter, the location column with the hardcoded string literal 'Default Location', the type column with the hardcoded string literal 'Standard', and the built_year column with the current calendar year derived by applying the EXTRACT function to the CURRENT_DATE function to obtain its YEAR component.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_mill_structure(arch_id INTEGER, mill_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO mill (architect_id, name, location, type, built_year)\n    VALUES (arch_id, mill_name, 'Default Location', 'Standard', EXTRACT(YEAR FROM CURRENT_DATE));\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL add_mill_structure(1, 'New Mill One');",
      "CALL add_mill_structure(2, 'Modern Mill Design');",
      "CALL add_mill_structure(3, 'Hadid Mill Project');",
      "CALL add_mill_structure(1, 'Second Wright Mill');",
      "CALL add_mill_structure(2, 'Gehry Experimental Mill');"
    ],
    "summary": "Create a stored procedure named add_mill_structure that inserts a new mill record. It takes an architect ID and a mill name as inputs. The procedure sets the location to 'Default Location', the type to 'Standard', and the built year to the current year.",
    "natural_language": "Create a comprehensive stored procedure, which should be named 'add_mill_structure', that is specifically designed to insert a brand new record into the mill table. This procedure must accept two distinct input parameters: the unique identifier for the architect and the full, official name of the mill. Within its detailed logic, it will meticulously assign the location to the predefined string 'Default Location', explicitly set the structural type to 'Standard', and carefully populate the built year with the exact current year from the system.",
    "id": 243
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_singer_id of type integer, p_start_date of type text, and p_end_date of type text. The procedure calculates the average sales for songs associated with the given singer ID by selecting the average value from the Sales column in the song table where the Singer_ID matches the provided p_singer_id. The result of this average calculation is stored in a variable named v_average_sales of type real. Subsequently, the procedure attempts to insert a new row into the song table with the following values: a Song_ID that is one greater than the current maximum Song_ID in the table (or 1 if the table is empty), a Title set to 'Average Sales', the provided p_singer_id, the calculated v_average_sales, and a Highest_Position of 0. If a conflict occurs on the Song_ID column during the insertion, the procedure does nothing and does not insert the row. The procedure does not utilize the p_start_date and p_end_date parameters in any operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_sales(p_singer_id integer, p_start_date text, p_end_date text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_average_sales real;\nBEGIN\n    -- The original code attempted to convert the 'Title' column (which contains song names) to a date,\n    -- leading to an error. The 'song' table schema does not have a date column for songs.\n    -- Therefore, the date filtering based on 'Title' is removed.\n    SELECT AVG(\"Sales\") INTO v_average_sales \n    FROM \"song\" \n    WHERE \"Singer_ID\" = p_singer_id;\n\n    INSERT INTO \"song\" (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n    VALUES ((SELECT COALESCE(MAX(\"Song_ID\"), 0) + 1 FROM \"song\"), 'Average Sales', p_singer_id, v_average_sales, 0)\n    ON CONFLICT (\"Song_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL calculate_average_sales(1, '2023-01-01', '2023-12-31');",
      "CALL calculate_average_sales(2, '2023-01-01', '2023-12-31');",
      "CALL calculate_average_sales(3, '2023-01-01', '2023-12-31');",
      "CALL calculate_average_sales(1, '2022-01-01', '2022-12-31');",
      "CALL calculate_average_sales(2, '2022-01-01', '2022-12-31');"
    ],
    "summary": "Create a stored procedure that calculates the average sales for a given singer ID and inserts a new song record titled 'Average Sales' with that value. The new song's ID is set to one greater than the current maximum. The insertion should ignore conflicts on the Song_ID. The start and end date parameters are not used.",
    "natural_language": "Please construct a stored procedure to compute the average sales figure for a specified singer identifier. Subsequently, insert a new record into the song table with the title 'Average Sales', assigning the calculated average as its value. The new song's identifier must be set to one unit higher than the present maximum Song_ID. The insertion operation should be designed to gracefully handle any conflicts on the Song_ID column by ignoring them. Note that the provided start date and end date parameters are to be disregarded within this procedure.",
    "id": 244
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `update_singer_birth_year` that accepts three input parameters: `p_singer_id` of type `integer`, `p_new_birth_year` of type `real`, and `p_citizenship` of type `text`. The primary purpose of this procedure is to modify existing records within the `singer` table. Specifically, it performs an `UPDATE` operation on the `singer` table. During this update, it sets the value of the `Birth_Year` column to the value provided by the `p_new_birth_year` parameter. This update is not applied universally to all rows in the `singer` table; instead, it is conditionally applied based on a `WHERE` clause. The `WHERE` clause specifies two conditions that must both be met for a row to be updated. The first condition requires that the value in the `Singer_ID` column of a row must be equal to the value passed in the `p_singer_id` parameter. The second condition, which is combined with the first using an `AND` operator, requires that the value in the `Citizenship` column of the same row must be equal to the value provided by the `p_citizenship` parameter. Only rows that satisfy both of these conditions will have their `Birth_Year` column updated.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_singer_birth_year(p_singer_id integer, p_new_birth_year real, p_citizenship text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"singer\" \n    SET \"Birth_Year\" = p_new_birth_year \n    WHERE \"Singer_ID\" = p_singer_id \n    AND \"Citizenship\" = p_citizenship;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL update_singer_birth_year(1, 1945.0, 'France');",
      "CALL update_singer_birth_year(2, 1949.0, 'United States');",
      "CALL update_singer_birth_year(3, 1950.0, 'United States');",
      "CALL update_singer_birth_year(1, 1944.0, 'France');",
      "CALL update_singer_birth_year(2, 1948.0, 'United States');"
    ],
    "summary": "Create a stored procedure named update_singer_birth_year that updates a singer's birth year. It updates the record only where the singer ID and citizenship match the provided input parameters.",
    "natural_language": "Make a stored procedure called update_singer_birth_year to adjust a singer's birth year. It should only change the record when the singer's ID and their citizenship are roughly in line with the given parameters.",
    "id": 245
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_songs_by_sales` that accepts three input parameters: `p_singer_id` of type `integer`, `p_sales_threshold` of type `real`, and `p_citizenship` of type `text`. This procedure performs a `DELETE` operation on the `song` table. The deletion targets rows in the `song` table where the value in the `Singer_ID` column exactly matches the value provided in the `p_singer_id` parameter, AND the value in the `Sales` column is strictly less than the value provided in the `p_sales_threshold` parameter, AND there exists at least one corresponding row in the `singer` table. The existence check for the `singer` table is performed by a subquery that verifies two conditions simultaneously: the `Singer_ID` column in the `singer` table must exactly match the value provided in the `p_singer_id` parameter, AND the `Citizenship` column in the `singer` table must exactly match the value provided in the `p_citizenship` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_songs_by_sales(p_singer_id integer, p_sales_threshold real, p_citizenship text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"song\" \n    WHERE \"Singer_ID\" = p_singer_id \n    AND \"Sales\" < p_sales_threshold \n    AND EXISTS (SELECT 1 FROM \"singer\" WHERE \"Singer_ID\" = p_singer_id AND \"Citizenship\" = p_citizenship);\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL delete_songs_by_sales(1, 500000.0, 'France');",
      "CALL delete_songs_by_sales(2, 1000000.0, 'United States');",
      "CALL delete_songs_by_sales(1, 100000.0, 'France');",
      "CALL delete_songs_by_sales(3, 200000.0, 'United States');",
      "CALL delete_songs_by_sales(2, 700000.0, 'United States');"
    ],
    "summary": "Create a stored procedure named delete_songs_by_sales that deletes songs from the song table for a specified singer_id where sales are below a threshold, only if a singer with that ID and a matching citizenship exists.",
    "natural_language": "Please construct a stored procedure designated as 'delete_songs_by_sales'. This procedure shall remove records from the song table for a provided singer identifier, contingent upon the condition that the associated sales figures are beneath a specified threshold. The deletion operation must be executed only if a singer possessing the given identifier and a corresponding citizenship entry exists within the relevant table.",
    "id": 246
  },
  {
    "ir": "Write a PLpgSQL stored procedure that inserts a new record into the song table with the following columns: Song_ID, Title, Singer_ID, Sales, and Highest_Position. The procedure takes three parameters: p_title of type text, p_singer_id of type integer, and p_sales of type real. The Song_ID is determined by selecting the maximum Song_ID currently in the song table, using the COALESCE function to handle cases where the table might be empty by defaulting to 0, and then incrementing this value by 1 to ensure a unique identifier for the new song. The Title column is set to the value of the p_title parameter, the Singer_ID column is set to the value of the p_singer_id parameter, and the Sales column is set to the value of the p_sales parameter. The Highest_Position column is initialized to 0. If an insertion conflict occurs on the Song_ID column, the procedure does nothing, effectively ignoring the insertion attempt.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_song(p_title text, p_singer_id integer, p_sales real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"song\" (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n    VALUES ((SELECT COALESCE(MAX(\"Song_ID\"), 0) + 1 FROM \"song\"), p_title, p_singer_id, p_sales, 0)\n    ON CONFLICT (\"Song_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL insert_new_song('New Song 1', 1, 500000.0);",
      "CALL insert_new_song('New Song 2', 2, 600000.0);",
      "CALL insert_new_song('New Song 3', 3, 700000.0);",
      "CALL insert_new_song('New Song 4', 1, 800000.0);",
      "CALL insert_new_song('New Song 5', 2, 900000.0);"
    ],
    "summary": "Create a stored procedure that inserts a new song. Generate a unique Song_ID by incrementing the current maximum, use provided parameters for Title, Singer_ID, and Sales, set Highest_Position to 0, and ignore insertion conflicts on Song_ID.",
    "natural_language": "Write a stored procedure to insert a new song. Increment the current maximum to generate a unique Song_ID, take the provided Title, Singer_ID, and Sales as parameters, set Highest_Position to 0, and ignore any insertion conflicts on Song_ID.",
    "id": 247
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_singer_id of type integer, p_multiplier of type real, and p_citizenship of type text. The procedure begins by declaring a variable v_total_sales of type real. It then performs a SELECT operation to calculate the sum of the \"Sales\" column from the \"song\" table, filtering rows where the \"Singer_ID\" column matches the value of p_singer_id, and stores the result into the v_total_sales variable. If v_total_sales is not NULL, the procedure proceeds to execute an UPDATE operation on the \"singer\" table. This update sets the \"Net_Worth_Millions\" column to the product of v_total_sales and p_multiplier for rows where the \"Singer_ID\" column equals p_singer_id and the \"Citizenship\" column matches the value of p_citizenship. The procedure does not perform any operations if v_total_sales is NULL.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_net_worth_based_on_sales(p_singer_id integer, p_multiplier real, p_citizenship text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_sales real;\nBEGIN\n    SELECT SUM(\"Sales\") INTO v_total_sales FROM \"song\" WHERE \"Singer_ID\" = p_singer_id;\n    IF v_total_sales IS NOT NULL THEN\n        UPDATE \"singer\" \n        SET \"Net_Worth_Millions\" = v_total_sales * p_multiplier \n        WHERE \"Singer_ID\" = p_singer_id \n        AND \"Citizenship\" = p_citizenship;\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL update_net_worth_based_on_sales(1, 0.001, 'France');",
      "CALL update_net_worth_based_on_sales(2, 0.002, 'United States');",
      "CALL update_net_worth_based_on_sales(3, 0.0015, 'United States');",
      "CALL update_net_worth_based_on_sales(1, 0.0005, 'France');",
      "CALL update_net_worth_based_on_sales(2, 0.003, 'United States');"
    ],
    "summary": "Create a stored procedure that calculates the total sales for a given singer_id. If the total is not null, update the singer's Net_Worth_Millions by multiplying the total sales with a provided multiplier, but only for singers with a matching citizenship.",
    "natural_language": "Please construct a stored procedure to compute the aggregate sales figure for a specified singer identifier. Should the computed total be non-null, proceed to update the singer's Net_Worth_Millions by applying the supplied multiplier to the total sales value, contingent upon the singer possessing the corresponding citizenship.",
    "id": 248
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Financial_Transactions\" table where the account_id column matches the provided parameter account_id_input of type BIGINT, and the transaction_date column is earlier than one year ago from the current date and time, determined by subtracting an interval of '1 year' from the result of the NOW() function.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_transactions(IN account_id_input BIGINT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Financial_Transactions\"\n    WHERE account_id = account_id_input AND transaction_date < NOW() - INTERVAL '1 year';\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Financial_Transactions"
    ],
    "call_sqls": [
      "CALL delete_old_transactions(1);",
      "CALL delete_old_transactions(2);",
      "CALL delete_old_transactions(3);",
      "CALL delete_old_transactions(13);",
      "CALL delete_old_transactions(9);"
    ],
    "summary": "Create a stored procedure that deletes financial transactions older than one year for a specified account_id.",
    "natural_language": "Write a procedure to get rid of older financial transaction records for a given account, focusing on those that have been around for a while and aren't needed anymore.",
    "id": 249
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `TransferBoxesToWarehouse` that accepts a single input parameter, `p_target_warehouse`, which is of type `bigint`. This procedure performs an `UPDATE` operation on the table named `\"Boxes\"`. The `UPDATE` operation sets the value of the column named `\"Warehouse\"` to the value provided by the `p_target_warehouse` parameter. This update is applied only to rows where two conditions are met simultaneously. The first condition is that the current value of the `\"Warehouse\"` column in a given row is not equal to the value of the `p_target_warehouse` parameter. The second condition is that the value of the `\"Value\"` column in the same row is strictly less than the average of all values in the `\"Value\"` column across all rows in the `\"Boxes\"` table. The average value is determined by a subquery that `SELECT`s the `AVG` (average) of the `\"Value\"` column from the `\"Boxes\"` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE TransferBoxesToWarehouse(p_target_warehouse bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"Boxes\"\n    SET \"Warehouse\" = p_target_warehouse\n    WHERE \"Warehouse\" <> p_target_warehouse\n    AND \"Value\" < (\n        SELECT AVG(\"Value\")\n        FROM \"Boxes\"\n    );\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL TransferBoxesToWarehouse(1);",
      "CALL TransferBoxesToWarehouse(2);",
      "CALL TransferBoxesToWarehouse(3);",
      "CALL TransferBoxesToWarehouse(4);",
      "CALL TransferBoxesToWarehouse(5);"
    ],
    "summary": "Create a stored procedure named TransferBoxesToWarehouse that updates the Warehouse for boxes not already in the target warehouse and whose value is below the average value of all boxes.",
    "natural_language": "Hey, can you whip up a stored procedure called TransferBoxesToWarehouse? It should move boxes to a new warehouse, but only the ones that aren't already there and are worth less than what the average box is going for.",
    "id": 250
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Boxes\" table where the \"Value\" column is less than a specified threshold. The procedure is named DeleteLowValueBoxes and accepts a single parameter, p_value_threshold, of type real, which represents the threshold value. The procedure performs a DELETE operation on the \"Boxes\" table, targeting rows where the \"Value\" column is less than the provided p_value_threshold parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteLowValueBoxes(p_value_threshold real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\"\n    WHERE \"Value\" < p_value_threshold;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL DeleteLowValueBoxes(100.0);",
      "CALL DeleteLowValueBoxes(200.0);",
      "CALL DeleteLowValueBoxes(50.0);",
      "CALL DeleteLowValueBoxes(300.0);",
      "CALL DeleteLowValueBoxes(150.0);"
    ],
    "summary": "Create a stored procedure named DeleteLowValueBoxes that deletes rows from the Boxes table where the Value column is less than the provided real parameter p_value_threshold.",
    "natural_language": "Please construct a stored procedure designated as 'DeleteLowValueBoxes' to remove records from the Boxes table for which the Value column is inferior to the supplied real parameter, p_value_threshold.",
    "id": 251
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named MoveBoxesByContent that accepts one input parameter p_content of type text, representing the content description to match, and begins by declaring a local variable v_new_warehouse of type bigint to store a warehouse identifier; the procedure then executes a SELECT query to find and assign to v_new_warehouse the single \"Code\" value from the \"Warehouses\" table where the \"Capacity\" column value is greater than the current count of rows in the \"Boxes\" table that have their \"Warehouse\" column equal to that warehouse's \"Code\", selecting from all such qualifying warehouses the one with the largest \"Capacity\" value by ordering in descending order and limiting the result to one row; if the v_new_warehouse variable is not null after this selection, the procedure performs an UPDATE operation on the \"Boxes\" table, setting the \"Warehouse\" column to the value stored in v_new_warehouse for every row where the \"Contents\" column exactly matches the input parameter p_content.",
    "plsql": "CREATE OR REPLACE PROCEDURE MoveBoxesByContent(p_content text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_warehouse bigint;\nBEGIN\n    SELECT \"Code\" INTO v_new_warehouse\n    FROM \"Warehouses\"\n    WHERE \"Capacity\" > (\n        SELECT COUNT(*)\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = \"Warehouses\".\"Code\"\n    )\n    ORDER BY \"Capacity\" DESC\n    LIMIT 1;\n\n    IF v_new_warehouse IS NOT NULL THEN\n        UPDATE \"Boxes\"\n        SET \"Warehouse\" = v_new_warehouse\n        WHERE \"Contents\" = p_content;\n    END IF;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL MoveBoxesByContent('Rocks');",
      "CALL MoveBoxesByContent('Scissors');",
      "CALL MoveBoxesByContent('Paper');",
      "CALL MoveBoxesByContent('Books');",
      "CALL MoveBoxesByContent('Toys');"
    ],
    "summary": "Create a stored procedure named MoveBoxesByContent that accepts a text parameter p_content. It finds the warehouse with the largest capacity that is greater than its current number of boxes, stores its Code in a variable, and if found, updates the Boxes table to set the Warehouse to that code for all rows where Contents matches p_content.",
    "natural_language": "Hey, can you whip up a stored procedure called MoveBoxesByContent that takes a text parameter p_content? It needs to find the warehouse with the most space leftâ€”you know, where the capacity is bigger than the number of boxes it's currently holding. Grab that warehouse's Code and stash it in a variable. If we actually find one, then go ahead and update the Boxes table: set the Warehouse to that code for every box where the Contents match the p_content we got.",
    "id": 252
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `add_new_country` that is designed to insert a new record into the `country` table. This procedure accepts four parameters: `country_name`, which is an `IN` parameter of type `TEXT` representing the name of the country to be added; `population`, which is an `IN` parameter of type `INTEGER` representing the population of the country; `area`, which is an `IN` parameter of type `INTEGER` representing the geographical area of the country; and `new_country_id`, which is an `INOUT` parameter of type `INTEGER` that will be used to return the `Country_ID` of the newly inserted country. The procedure's core operation involves an `INSERT` statement targeting the `country` table. Specifically, it inserts values into the `Name`, `Population`, and `Area` columns of the `country` table. The value for the `Name` column is sourced from the `country_name` input parameter. The value for the `Population` column is sourced from the `population` input parameter. The value for the `Area` column is sourced from the `area` input parameter. Following the insertion, the `RETURNING` clause is used to capture the value generated for the `Country_ID` column of the newly inserted row. This captured `Country_ID` value is then assigned to the `new_country_id` `INOUT` parameter, making it available to the caller of the procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_country(IN country_name TEXT, IN population INTEGER, IN area INTEGER, INOUT new_country_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO country (\"Name\", \"Population\", \"Area\")\n    VALUES (country_name, population, area)\n    RETURNING \"Country_ID\" INTO new_country_id;\nEND;\n$$;",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "CALL add_new_country('Germany', 83166711, 357022, NULL);",
      "CALL add_new_country('Norway', 5391369, 385207, NULL);",
      "CALL add_new_country('Denmark', 5831404, 42931, NULL);",
      "CALL add_new_country('Italy', 59554023, 301340, NULL);",
      "CALL add_new_country('Spain', 47351567, 505990, NULL);"
    ],
    "summary": "Create a stored procedure named add_new_country to insert a new country. It accepts IN parameters for name (TEXT), population (INTEGER), and area (INTEGER), and an INOUT parameter new_country_id (INTEGER). It inserts the values into the country table and returns the generated Country_ID into the new_country_id parameter.",
    "natural_language": "Make a stored procedure called add_new_country to add a new country. It should take in a name, a rough population number, and an approximate area size, along with a parameter for the new country's ID that you provide and get back. It puts the details into the country table and gives back the created Country_ID into that ID parameter.",
    "id": 253
  },
  {
    "ir": "Write a PLpgSQL stored procedure named delete_roller_coaster that accepts three parameters: an input parameter coaster_id of type INTEGER, and two INOUT parameters, deleted of type BOOLEAN and coaster_name of type TEXT. The procedure begins by executing a SELECT statement to retrieve the \"Name\" column from the roller_coaster table where the \"Roller_Coaster_ID\" column matches the provided coaster_id. The retrieved name is stored in the coaster_name parameter. The procedure then checks if the coaster_name is not NULL, indicating that a roller coaster with the specified ID exists. If this condition is true, it performs a DELETE operation on the roller_coaster table to remove the row where \"Roller_Coaster_ID\" equals the given coaster_id, and sets the deleted parameter to TRUE to indicate successful deletion. If the coaster_name is NULL, meaning no matching roller coaster was found, the procedure sets the deleted parameter to FALSE, indicating that no deletion occurred.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_roller_coaster(IN coaster_id INTEGER, INOUT deleted BOOLEAN, INOUT coaster_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT \"Name\" INTO coaster_name FROM roller_coaster WHERE \"Roller_Coaster_ID\" = coaster_id;\n    IF coaster_name IS NOT NULL THEN\n        DELETE FROM roller_coaster WHERE \"Roller_Coaster_ID\" = coaster_id;\n        deleted := TRUE;\n    ELSE\n        deleted := FALSE;\n    END IF;\nEND;\n$$;",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "CALL delete_roller_coaster(1, NULL, NULL);",
      "CALL delete_roller_coaster(2, FALSE, '');",
      "CALL delete_roller_coaster(3, NULL, '');",
      "CALL delete_roller_coaster(999, FALSE, '');",
      "CALL delete_roller_coaster(4, NULL, NULL);"
    ],
    "summary": "Create a stored procedure named delete_roller_coaster that accepts an INTEGER coaster_id parameter and INOUT BOOLEAN deleted and TEXT coaster_name parameters. It retrieves the coaster name into coaster_name. If found, it deletes the record and sets deleted to TRUE; otherwise, it sets deleted to FALSE.",
    "natural_language": "How can I create a stored procedure called delete_roller_coaster that takes an INTEGER coaster_id and INOUT parameters for BOOLEAN deleted and TEXT coaster_name, so that it fetches the coaster name, deletes the record if it exists setting deleted to TRUE, and otherwise sets deleted to FALSE?",
    "id": 254
  },
  {
    "ir": "Write a PLpgSQL stored procedure that inserts a new customer into the \"Customers\" table by first determining the next available customer_id by selecting the maximum current customer_id from the \"Customers\" table, defaulting to 0 if no customers exist, and incrementing it by 1. This new customer_id is stored in a variable v_new_customer_id. The procedure then generates a customer_number by converting v_new_customer_id to text and left-padding it with zeros to ensure it is at least three characters long, storing this result in the variable v_customer_number. The procedure takes two input parameters: p_customer_name and p_customer_email, both of type text, which represent the name and email of the new customer, respectively. It then inserts a new row into the \"Customers\" table with the columns customer_id, customer_name, customer_email, and customer_number populated with v_new_customer_id, p_customer_name, p_customer_email, and v_customer_number, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_customer(\n    p_customer_name text,\n    p_customer_email text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_customer_id bigint;\n    v_customer_number text;\nBEGIN\n    SELECT COALESCE(MAX(customer_id), 0) + 1\n    INTO v_new_customer_id\n    FROM \"Customers\";\n    \n    v_customer_number := LPAD(v_new_customer_id::text, 3, '0');\n    \n    INSERT INTO \"Customers\" (customer_id, customer_name, customer_email, customer_number)\n    VALUES (v_new_customer_id, p_customer_name, p_customer_email, v_customer_number);\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL insert_new_customer('Alice Smith', 'alice.smith@example.com');",
      "CALL insert_new_customer('Bob Johnson', 'bob.johnson@example.net');",
      "CALL insert_new_customer('Charlie Brown', 'charlie.brown@example.org');",
      "CALL insert_new_customer('Diana Prince', 'diana.prince@example.com');",
      "CALL insert_new_customer('Eve Adams', 'eve.adams@example.net');"
    ],
    "summary": "Create a stored procedure to insert a new customer. It calculates the next customer_id by incrementing the current maximum, generates a zero-padded customer_number from it, and inserts a row into the Customers table using the provided p_customer_name and p_customer_email parameters along with the generated IDs.",
    "natural_language": "Develop a comprehensive stored procedure that meticulously inserts a brand new customer record. This procedure must first intelligently determine the next available customer_id by carefully incrementing the highest existing value, then it must construct a formally formatted, zero-padded customer_number based on that new identifier. Finally, it will seamlessly insert a complete row into the Customers table, utilizing the supplied parameters for the customer's full name and email address, along with both of the systematically generated ID values.",
    "id": 255
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_product_bits` that accepts two input parameters: `p_product_type` of type `text`, intended to specify a product category code for filtering, and `p_bit_position` of type `integer`, intended to specify a zero-based index within a predefined bit string. The procedure declares three local variables: `v_product_record` of type `RECORD` to hold individual product data during iteration, `v_bit_result` of type `integer` to store the value of a specific bit, and `v_bit_string` of type `bit(18)` initialized with the binary value `B'101010101010101010'`. The procedure first performs a validation check: it verifies if the `p_bit_position` parameter is within the valid bounds of the `v_bit_string`. This is done by checking if `p_bit_position` is less than 0 or greater than or equal to the length of `v_bit_string`, which is determined by the `length()` function. If the `p_bit_position` is found to be out of these bounds, the procedure raises an exception with a message indicating that the bit position is out of bounds for the bit string of the given length, providing the problematic `p_bit_position` and the `length(v_bit_string)`. Following this validation, the procedure initiates a loop that iterates over a result set. This result set is obtained by selecting the `product_id` and `product_name` columns from the `Products` table, filtering records where the `product_type_code` column matches the value provided in the `p_product_type` input parameter. For each `v_product_record` retrieved in this loop, the procedure calls the `get_bit()` function, passing `v_bit_string` and `p_bit_position` as arguments, to extract the bit value at the specified position. The result of `get_bit()` is then assigned to the `v_bit_result` variable. Subsequently, a conditional check is performed: if `v_bit_result` is equal to 1, the procedure proceeds to delete records from the `Order_Items` table. The deletion targets rows where the `product_id` column matches the `product_id` from the current `v_product_record`. Additionally, this `DELETE` operation includes an `EXISTS` subquery condition to ensure that the deletion only occurs if there is at least one matching record in the `Order_Items` table for the `product_id` of the current `v_product_record`. The `EXISTS` subquery selects `1` from `Order_Items` (aliased as `oi`) where `oi.product_id` equals `v_product_record.product_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_product_bits(\n    p_product_type text,\n    p_bit_position integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_product_record RECORD;\n    v_bit_result integer;\n    v_bit_string bit(18) := B'101010101010101010';\nBEGIN\n    -- Validate bit position is within bounds\n    IF p_bit_position < 0 OR p_bit_position >= length(v_bit_string) THEN\n        RAISE EXCEPTION 'Bit position % is out of bounds for bit string of length %', \n            p_bit_position, length(v_bit_string);\n    END IF;\n\n    FOR v_product_record IN\n        SELECT product_id, product_name\n        FROM \"Products\"\n        WHERE product_type_code = p_product_type\n    LOOP\n        v_bit_result := get_bit(v_bit_string, p_bit_position);\n        \n        IF v_bit_result = 1 THEN\n            -- Only delete if there are matching order items\n            DELETE FROM \"Order_Items\"\n            WHERE product_id = v_product_record.product_id\n            AND EXISTS (\n                SELECT 1 FROM \"Order_Items\" oi\n                WHERE oi.product_id = v_product_record.product_id\n            );\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL process_product_bits('Hardware', 0);",
      "CALL process_product_bits('Hardware', 1);",
      "CALL process_product_bits('Clothes', 2);",
      "CALL process_product_bits('Clothes', 3);",
      "CALL process_product_bits('Hardware', 4);"
    ],
    "summary": "Create a stored procedure named `process_product_bits` that takes a product type code and a bit position. It validates the bit position against a fixed 18-bit string. For each product matching the type, it extracts the bit at the given position. If the bit is 1, it deletes all order items for that product, provided such items exist.",
    "natural_language": "Make a stored procedure called `process_product_bits` that uses a product type code and a bit position. It should check the bit position against a standard 18-bit setup. For products of that general type, it looks at the bit in that spot. If it finds the bit is set, it gets rid of any related order items, assuming there are some to begin with.",
    "id": 256
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `validate_order_integrity` that accepts two input parameters: `p_order_id` of type `bigint` representing a specific order identifier, and `p_customer_id` of type `bigint` representing a specific customer identifier. The procedure begins by declaring three local variables: `v_order_exists` of type `boolean` to store whether a matching order is found, `v_item_count` of type `integer` to store the number of items associated with an order, and `v_bit_check` of type `integer` to store the result of a bit manipulation operation. The procedure then executes a `SELECT EXISTS` statement to determine if a record exists in the `Customer_Orders` table where the `order_id` column matches the input `p_order_id` and the `customer_id` column matches the input `p_customer_id`. The result of this existence check is stored in the `v_order_exists` variable. Subsequently, an `IF` conditional block checks if `v_order_exists` is true. If the order exists, the procedure proceeds to execute another `SELECT COUNT(*)` statement to count the total number of rows in the `Order_Items` table where the `order_id` column matches the input `p_order_id`. This count is then stored in the `v_item_count` variable. Following this, the procedure calls a function named `get_bit`, passing a bit string literal `B'111000111000111000'` and the result of the modulo operation `v_item_count % 18` as arguments. The return value of `get_bit` is assigned to the `v_bit_check` variable. Another `IF` conditional block then checks if the value of `v_bit_check` is equal to `0`. If `v_bit_check` is `0`, the procedure executes two `DELETE` statements: first, it deletes all rows from the `Order_Items` table where the `order_id` column matches the input `p_order_id`; second, it deletes all rows from the `Customer_Orders` table where the `order_id` column matches the input `p_order_id`. The procedure concludes after these conditional operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_order_integrity(\n    p_order_id bigint,\n    p_customer_id bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_order_exists boolean;\n    v_item_count integer;\n    v_bit_check integer;\nBEGIN\n    SELECT EXISTS(\n        SELECT 1 \n        FROM \"Customer_Orders\" \n        WHERE order_id = p_order_id AND customer_id = p_customer_id\n    ) INTO v_order_exists;\n    \n    IF v_order_exists THEN\n        SELECT COUNT(*)\n        INTO v_item_count\n        FROM \"Order_Items\"\n        WHERE order_id = p_order_id;\n        \n        -- Assuming get_bit is a user-defined function or a placeholder for bit manipulation.\n        -- For standard PostgreSQL, get_bit operates on BIT strings or BYTEA.\n        -- The example uses B'...' which is a bit string literal.\n        v_bit_check := get_bit(B'111000111000111000', v_item_count % 18);\n        \n        IF v_bit_check = 0 THEN\n            DELETE FROM \"Order_Items\" WHERE order_id = p_order_id;\n            DELETE FROM \"Customer_Orders\" WHERE order_id = p_order_id;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL validate_order_integrity(1, 12);",
      "CALL validate_order_integrity(2, 3);",
      "CALL validate_order_integrity(3, 12);",
      "CALL validate_order_integrity(1, 3);",
      "CALL validate_order_integrity(2, 12);"
    ],
    "summary": "Create a stored procedure named `validate_order_integrity` that takes an order ID and a customer ID. It checks if the order exists for that customer. If it exists, it counts the items in the order. It then checks a specific bit in a fixed bit string, using the item count modulo 18 as the position. If that bit is 0, it deletes all items for that order and then deletes the order itself.",
    "natural_language": "How can I create a stored procedure named `validate_order_integrity` that, given an order ID and a customer ID, checks for the order's existence for that customer, counts the items if it exists, and then, based on a specific bit in a fixed bit string (using the item count modulo 18 as the position), deletes all items and the order itself if that bit is 0?",
    "id": 257
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `create_order_with_items` that accepts two input parameters: `p_customer_id`, which is of type `bigint` and represents the unique identifier of the customer for whom the order is being created, and `p_product_id`, which is also of type `bigint` and represents the unique identifier of the product to be included in the order. The procedure begins by declaring two local variables: `v_new_order_id` of type `bigint` to store the newly generated order identifier, and `v_new_item_id` of type `bigint` to store the newly generated order item identifier. The execution flow then proceeds as follows: First, it calculates the next available `order_id` by querying the `\"Customer_Orders\"` table. Specifically, it selects the maximum value of the `\"order_id\"` column from `\"Customer_Orders\"`, uses the `COALESCE` function to treat a `NULL` result (which would occur if the table is empty) as `0`, and then adds `1` to this result. This calculated value is then stored into the `v_new_order_id` variable. Second, it inserts a new record into the `\"Customer_Orders\"` table. The `\"order_id\"` column is populated with the value from `v_new_order_id`, the `\"customer_id\"` column is populated with the value from the input parameter `p_customer_id`, the `\"order_date\"` column is populated with the current timestamp obtained by calling the `NOW()` function, and the `\"order_status_code\"` column is set to the literal string value `'New'`. Third, it calculates the next available `order_item_id` by querying the `\"Order_Items\"` table. Specifically, it selects the maximum value of the `\"order_item_id\"` column from `\"Order_Items\"`, uses the `COALESCE` function to treat a `NULL` result (if the table is empty) as `0`, and then adds `1` to this result. This calculated value is then stored into the `v_new_item_id` variable. Fourth, it inserts a new record into the `\"Order_Items\"` table. The `\"order_item_id\"` column is populated with the value from `v_new_item_id`, the `\"order_id\"` column is populated with the value from `v_new_order_id` (which was generated in the first step), the `\"product_id\"` column is populated with the value from the input parameter `p_product_id`, and the `\"order_quantity\"` column is set to the literal string value `'1'`.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_order_with_items(\n    p_customer_id bigint,\n    p_product_id bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_order_id bigint;\n    v_new_item_id bigint;\nBEGIN\n    SELECT COALESCE(MAX(\"order_id\"), 0) + 1\n    INTO v_new_order_id\n    FROM \"Customer_Orders\";\n    \n    INSERT INTO \"Customer_Orders\" (\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n    VALUES (v_new_order_id, p_customer_id, NOW(), 'New');\n    \n    SELECT COALESCE(MAX(\"order_item_id\"), 0) + 1\n    INTO v_new_item_id\n    FROM \"Order_Items\";\n    \n    INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\")\n    VALUES (v_new_item_id, v_new_order_id, p_product_id, '1');\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL create_order_with_items(12, 13);",
      "CALL create_order_with_items(3, 10);",
      "CALL create_order_with_items(1, 1);",
      "CALL create_order_with_items(2, 2);",
      "CALL create_order_with_items(12, 3);"
    ],
    "summary": "Create a stored procedure named `create_order_with_items` that takes a customer ID and a product ID. It generates a new order ID and inserts a new order for the customer with a 'New' status. It then generates a new order item ID and inserts an order item for the generated order, linking the product with a quantity of 1.",
    "natural_language": "How can I create a stored procedure called `create_order_with_items` that accepts a customer ID and a product ID, generates a new order ID to insert an order with a 'New' status for that customer, and then generates a new order item ID to insert an order item for that order, linking the specified product with a quantity of 1?",
    "id": 258
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `manage_institution_building` that accepts five input parameters: `p_institution_id` of type `text`, `p_building_id` of type `text`, `p_height_feet` of type `integer`, `p_floors` of type `integer`, and `p_enrollment` of type `integer`. The purpose of this procedure is to either delete a record from the `Institution` table or insert/update a record in the `building` table based on a conditional check. The procedure begins by evaluating a conditional `IF` statement. This condition checks for the existence of any record in the `building` table, aliased as `b`, where the `building_id` column exactly matches the value provided in the `p_building_id` parameter, AND the `Height_feet` column's value is strictly less than the value provided in the `p_height_feet` parameter, AND the `Floors` column's value is strictly less than the value provided in the `p_floors` parameter. If this `SELECT` query returns at least one row (meaning such a building exists with a height and floor count less than the provided parameters), then the `THEN` block is executed. Inside the `THEN` block, a `DELETE` operation is performed on the `Institution` table, removing all rows where the `Institution_id` column exactly matches the value provided in the `p_institution_id` parameter. If the initial `SELECT` query in the `IF` condition does not return any rows (meaning no such building exists that satisfies all three conditions), then the `ELSE` block is executed. Inside the `ELSE` block, an `INSERT` operation is attempted on the `building` table. This `INSERT` statement attempts to add a new row with the following column values: `building_id` is set to the value of `p_building_id`, `Name` is set to the literal string 'New Building', `Street_address` is set to the literal string 'Unknown Address', `Years_as_tallest` is set to the literal string '2024â€“', `Height_feet` is set to the value of `p_height_feet`, and `Floors` is set to the value of `p_floors`. This `INSERT` statement includes an `ON CONFLICT (\"building_id\") DO UPDATE` clause. This clause specifies that if an `INSERT` attempt results in a unique constraint violation on the `building_id` column (meaning a row with the same `building_id` already exists), then instead of failing, an `UPDATE` operation should be performed on the existing row. The `UPDATE` sets the `Height_feet` column to the value that was attempted to be inserted for `Height_feet` (referenced as `EXCLUDED.\"Height_feet\"`) and sets the `Floors` column to the value that was attempted to be inserted for `Floors` (referenced as `EXCLUDED.\"Floors\"`). The procedure concludes after either the `DELETE` or the `INSERT`/`UPDATE` operation is completed.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_institution_building(p_institution_id text, p_building_id text, p_height_feet integer, p_floors integer, p_enrollment integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (\n        SELECT 1 FROM building b\n        WHERE b.\"building_id\" = p_building_id\n        AND b.\"Height_feet\" < p_height_feet\n        AND b.\"Floors\" < p_floors\n    ) THEN\n        DELETE FROM \"Institution\"\n        WHERE \"Institution_id\" = p_institution_id;\n    ELSE\n        INSERT INTO building (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\")\n        VALUES (p_building_id, 'New Building', 'Unknown Address', '2024â€“', p_height_feet, p_floors)\n        ON CONFLICT (\"building_id\") DO UPDATE\n        SET \"Height_feet\" = EXCLUDED.\"Height_feet\",\n            \"Floors\" = EXCLUDED.\"Floors\";\n    END IF;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building"
    ],
    "call_sqls": [
      "CALL manage_institution_building('0', '1', 150, 15, 1200);",
      "CALL manage_institution_building('1', '3', 180, 20, 3102);",
      "CALL manage_institution_building('2', '2', 100, 8, 800);",
      "CALL manage_institution_building('3', '4', 250, 25, 5000);",
      "CALL manage_institution_building('4', '5', 130, 12, 2500);"
    ],
    "summary": "Create a stored procedure named `manage_institution_building` that takes institution ID, building ID, height, floors, and enrollment. If a building exists with the given ID and its height and floors are both less than the provided values, delete the institution with the given ID. Otherwise, insert a new building record with default name and address, using the provided height and floors. If the building ID already exists, update its height and floors instead.",
    "natural_language": "Alright, so we need a stored procedure called `manage_institution_building`. It's gotta take an institution ID, a building ID, the height, how many floors it has, and the enrollment. Here's the deal: first, check if there's already a building with that ID. If there is, and its current height and number of floors are both lower than the new numbers we're providing, then just go ahead and delete the whole institution that matches the institution ID. If that's not the case, then we need to add a new building record. Give it some default name and address, but use the height and floors we got. Oh, and if that building ID is already in the system but the height/floors condition wasn't met, then just update that existing building's height and floors with the new info.",
    "id": 259
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_building_info` that accepts six input parameters: `p_building_id` of type `text`, `p_name` of type `text`, `p_street_address` of type `text`, `p_years_as_tallest` of type `text`, `p_height_feet` of type `integer`, and `p_floors` of type `integer`. The purpose of this procedure is to either update an existing building record or insert a new building record into the `building` table based on the provided `p_building_id`.\n\nThe procedure begins by executing a conditional check. It first attempts to select a single row (specifically, the literal value `1`) from the `building` table. This selection is performed to determine if a record with a matching `building_id` already exists. The condition for this selection is that the value in the `building_id` column of the `building` table must be equal to the value provided in the `p_building_id` input parameter.\n\nIf the `SELECT` statement finds at least one row that satisfies this condition (meaning a building with the specified `p_building_id` already exists), the procedure proceeds to execute an `UPDATE` operation. This `UPDATE` targets the `building` table. It sets the value of the `Name` column to the value provided in the `p_name` parameter, the `Street_address` column to the value from the `p_street_address` parameter, the `Years_as_tallest` column to the value from the `p_years_as_tallest` parameter, the `Height_feet` column to the value from the `p_height_feet` parameter, and the `Floors` column to the value from the `p_floors` parameter. This `UPDATE` operation is specifically applied to the row(s) where the `building_id` column in the `building` table matches the value of the `p_building_id` input parameter.\n\nIf the `SELECT` statement does not find any rows that satisfy the condition (meaning a building with the specified `p_building_id` does not exist), the procedure proceeds to execute an `INSERT` operation. This `INSERT` targets the `building` table. It inserts a new row into the `building` table, populating the `building_id` column with the value from the `p_building_id` parameter, the `Name` column with the value from the `p_name` parameter, the `Street_address` column with the value from the `p_street_address` parameter, the `Years_as_tallest` column with the value from the `p_years_as_tallest` parameter, the `Height_feet` column with the value from the `p_height_feet` parameter, and the `Floors` column with the value from the `p_floors` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_building_info(p_building_id text, p_name text, p_street_address text, p_years_as_tallest text, p_height_feet integer, p_floors integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (\n        SELECT 1 FROM building\n        WHERE \"building_id\" = p_building_id\n    ) THEN\n        -- If the building exists, update its information\n        UPDATE building\n        SET\n            \"Name\" = p_name,\n            \"Street_address\" = p_street_address,\n            \"Years_as_tallest\" = p_years_as_tallest,\n            \"Height_feet\" = p_height_feet,\n            \"Floors\" = p_floors\n        WHERE \"building_id\" = p_building_id;\n    ELSE\n        -- If the building does not exist, insert a new record\n        INSERT INTO building (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\")\n        VALUES (p_building_id, p_name, p_street_address, p_years_as_tallest, p_height_feet, p_floors);\n    END IF;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building"
    ],
    "call_sqls": [
      "CALL update_building_info('0', 'Citizens Bank Building', '701 North Franklin Street', '1913â€“1915', 145, 12);",
      "CALL update_building_info('1', 'Tampa City Hall', '315 John F. Kennedy Boulevard', '1915â€“1926', 160, 10);",
      "CALL update_building_info('2', 'Floridan Hotel', '905 Franklin Street', '1926â€“1966', 204, 17);",
      "CALL update_building_info('3', 'New Building', '123 Main Street', '2023-present', 500, 50);",
      "CALL update_building_info('0', 'Updated Citizens Bank Building', '701 North Franklin Street', '1913â€“1915', 150, 13);"
    ],
    "summary": "Create a stored procedure named `update_building_info` that takes building ID, name, address, years as tallest, height, and floors. If a building with the given ID exists, update its information with the provided values. If it does not exist, insert a new building record with the provided values.",
    "natural_language": "Update or insert building information. For building ID, name, address, years as tallest, height, and floors, if a building with the given ID exists, update its record with the new values. If it does not exist, insert a new building record with these values. Name this stored procedure `update_building_info`.",
    "id": 260
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named insert_course_with_arrangement that accepts four input parameters: an integer parameter p_course_id representing a course identifier, a text parameter p_course_name representing the name of the course, a text parameter p_start_date representing the starting date of the course, and an integer parameter p_teacher_id representing a teacher identifier. The procedure first attempts to insert a new record into the table named \"course\", specifically into the columns \"Course_ID\", \"Course\", and \"Staring_Date\", using the values from parameters p_course_id, p_course_name, and p_start_date respectively; this insert operation includes an ON CONFLICT clause on the \"Course_ID\" column which specifies that if a row with the same \"Course_ID\" value already exists in the \"course\" table, the insert operation should do nothing and not raise an error. The procedure then calculates a value for a local variable v_grade by taking the modulo of the p_course_id parameter divided by 5 using the MOD function, adding 1 to the result, and assigning this computed integer to v_grade. Finally, the procedure performs a second insert operation into the table named \"course_arrange\", inserting values into the columns \"Course_ID\", \"Teacher_ID\", and \"Grade\" using the parameter p_course_id, the parameter p_teacher_id, and the locally computed variable v_grade respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_course_with_arrangement(p_course_id integer, p_course_name text, p_start_date text, p_teacher_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_grade integer;\nBEGIN\n    INSERT INTO \"course\" (\"Course_ID\", \"Course\", \"Staring_Date\")\n    VALUES (p_course_id, p_course_name, p_start_date)\n    ON CONFLICT (\"Course_ID\") DO NOTHING;\n    \n    v_grade := MOD(p_course_id, 5) + 1;\n    \n    INSERT INTO \"course_arrange\" (\"Course_ID\", \"Teacher_ID\", \"Grade\")\n    VALUES (p_course_id, p_teacher_id, v_grade);\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL insert_course_with_arrangement(4, 'History', '8 May', 1);",
      "CALL insert_course_with_arrangement(5, 'Geography', '9 May', 2);",
      "CALL insert_course_with_arrangement(6, 'Physics', '10 May', 3);",
      "CALL insert_course_with_arrangement(7, 'Chemistry', '11 May', 1);",
      "CALL insert_course_with_arrangement(8, 'Biology', '12 May', 2);"
    ],
    "summary": "Create a stored procedure named insert_course_with_arrangement that inserts a course record with conflict handling, calculates a grade based on the course ID modulo 5 plus 1, and then inserts a corresponding arrangement record.",
    "natural_language": "Hey, can you whip up a stored procedure called 'insert_course_with_arrangement'? It needs to pop a new course into the database, but handle any conflicts that pop up. Then, it should figure out a grade by taking the course ID, doing a modulo 5 on it, and adding 1. After that, it's gotta insert a matching arrangement record for the course.",
    "id": 261
  },
  {
    "ir": "Write a PLpgSQL stored procedure named calculate_teacher_statistics that accepts four parameters: p_min_grade (integer), p_max_grade (integer), p_output_course_id (integer), and p_output_teacher_id (integer). The procedure begins by declaring two local variables: v_avg_grade of type numeric and v_total_courses of type integer. It then performs a SELECT operation on the \"course_arrange\" table to calculate the average of the \"Grade\" column for rows where the \"Grade\" value falls between the values of p_min_grade and p_max_grade, inclusive. The result of this average calculation is stored in the variable v_avg_grade. Next, the procedure executes another SELECT operation on the same table to count the total number of courses associated with the teacher identified by p_output_teacher_id, storing this count in the variable v_total_courses. Following these calculations, the procedure performs an INSERT operation into the \"course_arrange\" table, adding a new row with the \"Course_ID\" set to p_output_course_id, \"Teacher_ID\" set to p_output_teacher_id, and \"Grade\" set to the rounded value of v_avg_grade. The procedure does not include any conditional statements or loops, and it concludes after executing the INSERT operation.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_teacher_statistics(p_min_grade integer, p_max_grade integer, p_output_course_id integer, p_output_teacher_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_grade numeric;\n    v_total_courses integer;\nBEGIN\n    SELECT AVG(\"Grade\") INTO v_avg_grade\n    FROM \"course_arrange\"\n    WHERE \"Grade\" BETWEEN p_min_grade AND p_max_grade;\n    \n    SELECT COUNT(*) INTO v_total_courses\n    FROM \"course_arrange\"\n    WHERE \"Teacher_ID\" = p_output_teacher_id;\n    \n    INSERT INTO \"course_arrange\" (\"Course_ID\", \"Teacher_ID\", \"Grade\")\n    VALUES (p_output_course_id, p_output_teacher_id, ROUND(v_avg_grade));\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL calculate_teacher_statistics(1, 5, 101, 5);",
      "CALL calculate_teacher_statistics(3, 7, 102, 3);",
      "CALL calculate_teacher_statistics(0, 10, 103, 2);",
      "CALL calculate_teacher_statistics(2, 6, 104, 1);",
      "CALL calculate_teacher_statistics(4, 8, 105, 3);"
    ],
    "summary": "Create a stored procedure named calculate_teacher_statistics that calculates the average grade within a specified range and the total courses for a teacher, then inserts a new arrangement record using the rounded average grade.",
    "natural_language": "Make a stored procedure called calculate_teacher_statistics that figures out the typical grade around a certain level and the overall number of courses for an instructor, then adds a new arrangement entry using the kind of rounded typical grade.",
    "id": 262
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `transform_distance_data` that processes distance data, potentially modifying records in the `Direct_distance`, `City`, and `Student` tables based on specific distance thresholds. The procedure declares several local variables: `v_distance_record` of type `RECORD` to hold the current row's data during iteration, `v_city1_name` of type `text` to store the name of the first city, `v_city2_name` of type `text` to store the name of the second city, `v_new_distance` of type `bigint` to store a potentially modified distance value, `v_category` of type `text` to store a distance category, and `v_operation_count` of type `integer` initialized to `0` to track the number of operations performed.\n\nThe procedure begins by iterating through a `FOR` loop. The loop's cursor is defined by a `SELECT` statement that retrieves `city1_code`, `city2_code`, `distance` from the `\"Direct_distance\"` table (aliased as `dd`), and `city_name` for `city1_code` (aliased as `city1_name`) and `city_name` for `city2_code` (aliased as `city2_name`) from the `\"City\"` table (aliased as `c1` and `c2` respectively). This `SELECT` statement performs two `JOIN` operations: one joining `\"Direct_distance\"` (`dd`) with `\"City\"` (`c1`) on `dd.\"city1_code\" = c1.\"city_code\"`, and another joining `\"Direct_distance\"` (`dd`) with `\"City\"` (`c2`) on `dd.\"city2_code\" = c2.\"city_code\"`. The `WHERE` clause filters these records to include only those where `dd.\"distance\"` is greater than `0`.\n\nInside the loop, for each `v_distance_record` fetched:\n1. The `v_new_distance` variable is initially set to the current `v_distance_record.\"distance\"`.\n2. A series of conditional statements (`IF-ELSIF-ELSE`) evaluate the `v_distance_record.\"distance\"`:\n    a. If `v_distance_record.\"distance\"` is greater than `5000`:\n        i. `v_category` is set to the string `'LONG'`.\n        ii. `v_new_distance` is updated to `v_distance_record.\"distance\" * 2`.\n        iii. An `INSERT` statement adds a new row into the `\"Student\"` table with the following values:\n            - `\"StuID\"`: `2000 + v_operation_count`\n            - `\"LName\"`: the value of `v_category` (`'LONG'`)\n            - `\"Fname\"`: `v_distance_record.\"city1_name\"`\n            - `\"Age\"`: `25`\n            - `\"Sex\"`: `'M'`\n            - `\"Major\"`: `700`\n            - `\"Advisor\"`: `1111`\n            - `\"city_code\"`: `v_distance_record.\"city1_code\"`\n    b. Else if `v_distance_record.\"distance\"` is greater than `2000`:\n        i. `v_category` is set to the string `'MEDIUM'`.\n        ii. `v_new_distance` is updated to `v_distance_record.\"distance\" + 100`.\n        iii. An `UPDATE` statement modifies the `\"City\"` table, setting the `\"latitude\"` column to its current value plus `0.1` for the row where `\"city_code\"` matches `v_distance_record.\"city1_code\"`.\n    c. Else if `v_distance_record.\"distance\"` is greater than `500`:\n        i. `v_category` is set to the string `'SHORT'`.\n        ii. `v_new_distance` is updated to `v_distance_record.\"distance\" / 2`.\n        iii. A `DELETE` statement removes rows from the `\"Direct_distance\"` table where `\"city1_code\"` matches `v_distance_record.\"city1_code\"`, `\"city2_code\"` matches `v_distance_record.\"city2_code\"`, AND `\"distance\"` is less than `100`.\n    d. Else if `v_distance_record.\"distance\"` is greater than `100`:\n        i. `v_category` is set to the string `'VERY_SHORT'`.\n        ii. `v_new_distance` is updated to `100`.\n        iii. An `UPDATE` statement modifies the `\"City\"` table, setting the `\"longitude\"` column to its current value minus `0.5` for the row where `\"city_code\"` matches `v_distance_record.\"city2_code\"`.\n    e. Else (if `v_distance_record.\"distance\"` is `100` or less, but greater than `0` due to the initial `WHERE` clause):\n        i. `v_category` is set to the string `'MINIMAL'`.\n        ii. `v_new_distance` is updated to `0`.\n        iii. An `INSERT` statement adds a new row into the `\"Direct_distance\"` table with the following values:\n            - `\"city1_code\"`: `v_distance_record.\"city2_code\"`\n            - `\"city2_code\"`: `v_distance_record.\"city1_code\"`\n            - `\"distance\"`: `v_distance_record.\"distance\"`\n3. After the conditional block, an `IF` statement checks if `v_new_distance` is not equal to the original `v_distance_record.\"distance\"`. If they are different:\n    a. An `UPDATE` statement modifies the `\"Direct_distance\"` table, setting the `\"distance\"` column to the value of `v_new_distance` for the row where `\"city1_code\"` matches `v_distance_record.\"city1_code\"` AND `\"city2_code\"` matches `v_distance_record.\"city2_code\"`.\n4. The `v_operation_count` variable is incremented by `1`.\n5. Another `IF` statement checks if `v_operation_count` is greater than `50`. If it is, the `EXIT` statement terminates the `FOR` loop prematurely.\n\nAfter the `FOR` loop completes (either naturally or by `EXIT`), a final `IF` statement checks if `v_operation_count` is greater than `0`. If it is:\n1. A `DELETE` statement removes rows from the `\"Direct_distance\"` table where `\"city1_code\"` is equal to the string `'AVG'` OR `\"city2_code\"` is equal to the string `'AVG'`.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_distance_data()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_distance_record RECORD;\n    v_city1_name text;\n    v_city2_name text;\n    v_new_distance bigint;\n    v_category text;\n    v_operation_count integer := 0;\nBEGIN\n    FOR v_distance_record IN SELECT dd.\"city1_code\", dd.\"city2_code\", dd.\"distance\", c1.\"city_name\" as city1_name, c2.\"city_name\" as city2_name\n    FROM \"Direct_distance\" dd\n    JOIN \"City\" c1 ON dd.\"city1_code\" = c1.\"city_code\"\n    JOIN \"City\" c2 ON dd.\"city2_code\" = c2.\"city_code\"\n    WHERE dd.\"distance\" > 0\n    LOOP\n        v_new_distance := v_distance_record.\"distance\";\n        \n        IF v_distance_record.\"distance\" > 5000 THEN\n            v_category := 'LONG';\n            v_new_distance := v_distance_record.\"distance\" * 2;\n            INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n            VALUES (2000 + v_operation_count, v_category, v_distance_record.\"city1_name\", 25, 'M', 700, 1111, v_distance_record.\"city1_code\");\n        ELSIF v_distance_record.\"distance\" > 2000 THEN\n            v_category := 'MEDIUM';\n            v_new_distance := v_distance_record.\"distance\" + 100;\n            UPDATE \"City\" SET \"latitude\" = \"latitude\" + 0.1 WHERE \"city_code\" = v_distance_record.\"city1_code\";\n        ELSIF v_distance_record.\"distance\" > 500 THEN\n            v_category := 'SHORT';\n            v_new_distance := v_distance_record.\"distance\" / 2;\n            DELETE FROM \"Direct_distance\" WHERE \"city1_code\" = v_distance_record.\"city1_code\" AND \"city2_code\" = v_distance_record.\"city2_code\" AND \"distance\" < 100;\n        ELSIF v_distance_record.\"distance\" > 100 THEN\n            v_category := 'VERY_SHORT';\n            v_new_distance := 100;\n            UPDATE \"City\" SET \"longitude\" = \"longitude\" - 0.5 WHERE \"city_code\" = v_distance_record.\"city2_code\";\n        ELSE\n            v_category := 'MINIMAL';\n            v_new_distance := 0;\n            INSERT INTO \"Direct_distance\" (\"city1_code\", \"city2_code\", \"distance\")\n            VALUES (v_distance_record.\"city2_code\", v_distance_record.\"city1_code\", v_distance_record.\"distance\");\n        END IF;\n        \n        IF v_new_distance <> v_distance_record.\"distance\" THEN\n            UPDATE \"Direct_distance\" SET \"distance\" = v_new_distance\n            WHERE \"city1_code\" = v_distance_record.\"city1_code\" AND \"city2_code\" = v_distance_record.\"city2_code\";\n        END IF;\n        \n        v_operation_count := v_operation_count + 1;\n        \n        IF v_operation_count > 50 THEN\n            EXIT;\n        END IF;\n    END LOOP;\n    \n    IF v_operation_count > 0 THEN\n        DELETE FROM \"Direct_distance\" WHERE \"city1_code\" = 'AVG' OR \"city2_code\" = 'AVG';\n    END IF;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL transform_distance_data();"
    ],
    "summary": "Create a stored procedure named transform_distance_data that processes distance records, categorizes them based on thresholds, performs conditional inserts, updates, or deletes on related tables, modifies distances, and limits operations to 50.",
    "natural_language": "Write a stored procedure called transform_distance_data to process distance records, categorize them by thresholds, conditionally insert, update, or delete in related tables, modify distances, and restrict all operations to 50 records.",
    "id": 263
  },
  {
    "ir": "Write a PLpgSQL stored procedure named synchronize_city_distance_network with no parameters that iterates through all USA cities from the City table ordered by city_name, and for each source city, it counts the number of students in the Student table with that city_code, storing the count in v_student_source_count; then, for each source city, it iterates through up to three target USA cities from the City table where the target city_code is lexicographically greater than the source city_code, incrementing a loop counter v_loop_counter for each pair, and for each target city, it counts the number of students in the Student table with that target city_code, storing the count in v_student_target_count, then attempts to retrieve an existing distance value from the Direct_distance table where the city pair matches either (city1_code = source and city2_code = target) or (city1_code = target and city2_code = source), storing it in v_existing_distance; it then calculates a new distance v_calculated_distance as the absolute difference between v_student_source_count and v_student_target_count multiplied by 100; if no existing distance record is found (v_existing_distance is NULL) and the calculated distance is greater than zero, it inserts a new row into the Direct_distance table with city1_code as the source city, city2_code as the target city, and distance as the calculated distance, and increments the total operations counter v_total_operations; if an existing distance is found, it compares the calculated distance to the existing distance: if the calculated distance is greater than the existing distance, it further checks if the calculated distance is greater than 500, in which case it updates the Direct_distance table for the city pair by setting the distance to twice the calculated distance and also deletes from the Student table any records for the source city where the Age is greater than 25; if the calculated distance is not greater than 500 but is greater than 200, it updates the Direct_distance table for the city pair by setting the distance to the calculated distance plus 50 and also updates the City table for the target city by setting its city_name to the uppercase version of the first five characters of its current city_name using the UPPER and SUBSTR functions; if the calculated distance is greater than the existing distance but not greater than 200, it simply updates the Direct_distance table for the city pair to the calculated distance, and after any of these update branches, it increments v_total_operations; if the calculated distance is less than the existing distance, it checks if the difference (existing minus calculated) exceeds 300, in which case it deletes the existing record from the Direct_distance table for the city pair and inserts a new student record into the Student table with a StuID of 4000 plus the current loop counter, fixed values for LName ('SYNC'), Fname ('OP'), Age (22), Sex ('M'), Major (888), Advisor (6666), and the source city_code; if the difference does not exceed 300, it updates the Direct_distance table for the city pair to the calculated distance, and after either branch, it increments v_total_operations; after processing each city pair, it checks if the loop counter v_loop_counter has reached or exceeded 20 and if so, exits both inner and outer loops; after completing all loops, if the total operations counter v_total_operations exceeds 10, it deletes from the Direct_distance table any records where the distance column equals zero.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_city_distance_network()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_source_city text;\n    v_target_city text;\n    v_existing_distance bigint;\n    v_calculated_distance bigint;\n    v_student_source_count bigint;\n    v_student_target_count bigint;\n    v_total_operations integer := 0;\n    v_loop_counter integer := 0;\nBEGIN\n    FOR v_source_city IN SELECT \"city_code\" FROM \"City\" WHERE \"country\" = 'USA' ORDER BY \"city_name\"\n    LOOP\n        SELECT COUNT(*) INTO v_student_source_count FROM \"Student\" WHERE \"city_code\" = v_source_city;\n        \n        FOR v_target_city IN SELECT \"city_code\" FROM \"City\" WHERE \"city_code\" > v_source_city AND \"country\" = 'USA' LIMIT 3\n        LOOP\n            v_loop_counter := v_loop_counter + 1;\n            \n            SELECT COUNT(*) INTO v_student_target_count FROM \"Student\" WHERE \"city_code\" = v_target_city;\n            \n            SELECT \"distance\" INTO v_existing_distance FROM \"Direct_distance\"\n            WHERE (\"city1_code\" = v_source_city AND \"city2_code\" = v_target_city)\n               OR (\"city1_code\" = v_target_city AND \"city2_code\" = v_source_city)\n            LIMIT 1;\n            \n            v_calculated_distance := ABS(v_student_source_count - v_student_target_count) * 100;\n            \n            IF v_existing_distance IS NULL THEN\n                IF v_calculated_distance > 0 THEN\n                    INSERT INTO \"Direct_distance\" (\"city1_code\", \"city2_code\", \"distance\")\n                    VALUES (v_source_city, v_target_city, v_calculated_distance);\n                    v_total_operations := v_total_operations + 1;\n                END IF;\n            ELSE\n                IF v_calculated_distance > v_existing_distance THEN\n                    IF v_calculated_distance > 500 THEN\n                        UPDATE \"Direct_distance\" SET \"distance\" = v_calculated_distance * 2\n                        WHERE (\"city1_code\" = v_source_city AND \"city2_code\" = v_target_city)\n                           OR (\"city1_code\" = v_target_city AND \"city2_code\" = v_source_city);\n                        DELETE FROM \"Student\" WHERE \"city_code\" = v_source_city AND \"Age\" > 25;\n                    ELSIF v_calculated_distance > 200 THEN\n                        UPDATE \"Direct_distance\" SET \"distance\" = v_calculated_distance + 50\n                        WHERE (\"city1_code\" = v_source_city AND \"city2_code\" = v_target_city)\n                           OR (\"city1_code\" = v_target_city AND \"city2_code\" = v_source_city);\n                        UPDATE \"City\" SET \"city_name\" = UPPER(SUBSTR(\"city_name\", 1, 5)) WHERE \"city_code\" = v_target_city;\n                    ELSE\n                        UPDATE \"Direct_distance\" SET \"distance\" = v_calculated_distance\n                        WHERE (\"city1_code\" = v_source_city AND \"city2_code\" = v_target_city)\n                           OR (\"city1_code\" = v_target_city AND \"city2_code\" = v_source_city);\n                    END IF;\n                    v_total_operations := v_total_operations + 1;\n                ELSIF v_calculated_distance < v_existing_distance THEN\n                    IF v_existing_distance - v_calculated_distance > 300 THEN\n                        DELETE FROM \"Direct_distance\"\n                        WHERE (\"city1_code\" = v_source_city AND \"city2_code\" = v_target_city)\n                           OR (\"city1_code\" = v_target_city AND \"city2_code\" = v_source_city);\n                        INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n                        VALUES (4000 + v_loop_counter, 'SYNC', 'OP', 22, 'M', 888, 6666, v_source_city);\n                    ELSE\n                        UPDATE \"Direct_distance\" SET \"distance\" = v_calculated_distance\n                        WHERE (\"city1_code\" = v_source_city AND \"city2_code\" = v_target_city)\n                           OR (\"city1_code\" = v_target_city AND \"city2_code\" = v_source_city);\n                    END IF;\n                    v_total_operations := v_total_operations + 1;\n                END IF;\n            END IF;\n            \n            IF v_loop_counter >= 20 THEN\n                EXIT;\n            END IF;\n        END LOOP;\n        \n        IF v_loop_counter >= 20 THEN\n            EXIT;\n        END IF;\n    END LOOP;\n    \n    IF v_total_operations > 10 THEN\n        DELETE FROM \"Direct_distance\" WHERE \"distance\" = 0;\n    END IF;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL synchronize_city_distance_network();"
    ],
    "summary": "Create a stored procedure named synchronize_city_distance_network that synchronizes distances between city pairs based on student count differences, conditionally inserts, updates, or deletes records, and exits after processing 20 pairs or if total operations exceed 10.",
    "natural_language": "Create procedure synchronize_city_distance_network to sync city distances by student count, conditionally insert, update, or delete records, stopping after 20 pairs or 10 total operations.",
    "id": 264
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `insert_actor_with_age_calculation` that accepts three input parameters: `p_name` of type `text`, `p_musical_id` of type `integer`, and `p_birth_year` of type `integer`. The procedure begins by declaring two local variables: `v_new_id` of type `integer` and `v_calculated_age` of type `integer`. The first operation performed is a `SELECT` statement that calculates a new `Actor_ID`. This is achieved by querying the `actor` table to find the maximum value in the `\"Actor_ID\"` column. The `COALESCE` function is used to handle cases where no rows exist in the `actor` table or if `\"Actor_ID\"` is `NULL`, in which case it defaults to `0`. This maximum value (or `0`) is then incremented by `1`, and the result is assigned to the `v_new_id` variable. Subsequently, the `v_calculated_age` variable is assigned a value derived by subtracting the input parameter `p_birth_year` from the constant `2024`. Finally, an `INSERT` statement is executed to add a new row into the `actor` table. The values inserted into the columns are as follows: `v_new_id` is inserted into the `\"Actor_ID\"` column, `p_name` is inserted into the `\"Name\"` column, `p_musical_id` is inserted into the `\"Musical_ID\"` column, the literal string `'TBD'` is inserted into the `\"Character\"` column, the literal string `'2024â€”'` is inserted into the `\"Duration\"` column, and `v_calculated_age` is inserted into the `age` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_actor_with_age_calculation(IN p_name text, IN p_musical_id integer, IN p_birth_year integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_id integer;\n    v_calculated_age integer;\nBEGIN\n    SELECT COALESCE(MAX(\"Actor_ID\"), 0) + 1 INTO v_new_id FROM actor;\n    v_calculated_age := 2024 - p_birth_year;\n    INSERT INTO actor (\"Actor_ID\", \"Name\", \"Musical_ID\", \"Character\", \"Duration\", age)\n    VALUES (v_new_id, p_name, p_musical_id, 'TBD', '2024â€”', v_calculated_age);\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL insert_actor_with_age_calculation('John Doe', 1, 1990);",
      "CALL insert_actor_with_age_calculation('Jane Smith', 2, 1985);",
      "CALL insert_actor_with_age_calculation('Robert Johnson', 1, 1978);",
      "CALL insert_actor_with_age_calculation('Emily Davis', 3, 1995);",
      "CALL insert_actor_with_age_calculation('Michael Brown', 2, 2000);"
    ],
    "summary": "Create a stored procedure named insert_actor_with_age_calculation that generates a new actor ID, calculates age from a birth year, and inserts a new actor record with default values for character and duration.",
    "natural_language": "Please construct a stored procedure designated as 'insert_actor_with_age_calculation'. This procedure shall be responsible for generating a unique identifier for a new actor, computing the actor's age based on a provided year of birth, and subsequently inserting a new record into the actor table. The insertion should employ default values for the character name and duration fields.",
    "id": 265
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_actors_by_criteria that accepts three input parameters: an integer parameter p_min_age specifying the lower bound of an age range, an integer parameter p_max_age specifying the upper bound of an age range, and an integer parameter p_musical_id specifying a musical identifier; the procedure executes a DELETE operation on the actor table, targeting rows where the age column value falls inclusively between the p_min_age and p_max_age parameter values and where the value in the column named \"Musical_ID\" (case-sensitive) is exactly equal to the p_musical_id parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_actors_by_criteria(IN p_min_age integer, IN p_max_age integer, IN p_musical_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM actor \n    WHERE age BETWEEN p_min_age AND p_max_age \n    AND \"Musical_ID\" = p_musical_id;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL delete_actors_by_criteria(20, 25, 1);",
      "CALL delete_actors_by_criteria(18, 30, 2);",
      "CALL delete_actors_by_criteria(25, 35, 1);",
      "CALL delete_actors_by_criteria(40, 50, 3);",
      "CALL delete_actors_by_criteria(21, 26, 2);"
    ],
    "summary": "Create a stored procedure named delete_actors_by_criteria that deletes actors from the actor table where their age is between two given inclusive values and their Musical_ID matches a specified musical ID.",
    "natural_language": "How can I create a stored procedure called delete_actors_by_criteria to remove actors from the actor table when their age falls within a specified inclusive range and their Musical_ID equals a given musical ID?",
    "id": 266
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three input parameters: p_musical_id (integer), p_year_threshold (integer), and p_age_multiplier (integer). The procedure begins by querying the actor table to count the number of actors associated with the specified musical ID (p_musical_id) and calculates the average age of these actors, rounding the result to the nearest whole number. These values are stored in the variables v_actor_count and v_avg_age, respectively. Next, the procedure calculates a total score by multiplying the actor count (v_actor_count) by the age multiplier (p_age_multiplier) and adding the year threshold (p_year_threshold). This calculated score is stored in the variable v_total_score. The procedure then inserts a new row into the musical table with the following values: the Musical_ID column is set to the maximum existing Musical_ID value in the table incremented by 1 (or 1 if the table is empty), the Name column is set to 'Statistics Report', the Year column is set to the calculated total score (v_total_score), the Award column is set to 'Data Award', the Category column is set to 'Best Analysis', the Nominee column is set to 'System', and the Result column is set to 'Calculated'.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_musical_statistics(IN p_musical_id integer, IN p_year_threshold integer, IN p_age_multiplier integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_actor_count integer;\n    v_avg_age numeric;\n    v_total_score integer;\nBEGIN\n    SELECT COUNT(*), ROUND(AVG(age)) INTO v_actor_count, v_avg_age\n    FROM actor \n    WHERE \"Musical_ID\" = p_musical_id;\n    \n    v_total_score := v_actor_count * p_age_multiplier + p_year_threshold;\n    \n    INSERT INTO musical (\"Musical_ID\", \"Name\", \"Year\", \"Award\", \"Category\", \"Nominee\", \"Result\")\n    SELECT COALESCE(MAX(\"Musical_ID\"), 0) + 1, 'Statistics Report', v_total_score, 'Data Award', 'Best Analysis', 'System', 'Calculated'\n    FROM musical;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL calculate_musical_statistics(1, 2000, 5);",
      "CALL calculate_musical_statistics(2, 1990, 3);",
      "CALL calculate_musical_statistics(1, 2010, 4);",
      "CALL calculate_musical_statistics(2, 1985, 2);",
      "CALL calculate_musical_statistics(1, 2020, 6);"
    ],
    "summary": "Create a stored procedure that counts actors and calculates their average age for a given musical ID. It then calculates a total score using these values, a multiplier, and a threshold. Finally, it inserts a new record into the musical table with the calculated score and predefined static values.",
    "natural_language": "How can I create a stored procedure that, for a specified musical ID, counts the actors and calculates their average age, uses these values along with a multiplier and a threshold to compute a total score, and then inserts a new record with that score and some static values into the musical table?",
    "id": 267
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three input parameters: p_source_musical (an integer representing the ID of the source musical), p_target_musical (an integer representing the ID of the target musical), and p_age_limit (an integer representing an age threshold). The procedure transfers actors from the source musical to the target musical if their age is greater than the specified age limit. It begins by iterating over all rows in the actor table where the \"Musical_ID\" column matches the value of p_source_musical and the age column is greater than p_age_limit. For each such row, it retrieves the values of the \"Actor_ID\", \"Name\", \"Character\", \"Duration\", and age columns. Within the loop, it inserts a new row into the actor table with the following values: a new \"Actor_ID\" generated by adding the current \"Actor_ID\" value to the result of a subquery that calculates the maximum \"Actor_ID\" in the actor table (or 0 if the table is empty), the \"Name\" value from the current row, the value of p_target_musical as the new \"Musical_ID\", the \"Character\" value from the current row, the \"Duration\" value from the current row, and the age value from the current row. After inserting the new row, the procedure deletes the original row from the actor table where the \"Actor_ID\" matches the \"Actor_ID\" of the current row being processed. This process repeats for all rows that meet the specified conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_actors_between_musicals(IN p_source_musical integer, IN p_target_musical integer, IN p_age_limit integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    actor_rec RECORD;\nBEGIN\n    FOR actor_rec IN \n        SELECT \"Actor_ID\", \"Name\", \"Character\", \"Duration\", age \n        FROM actor \n        WHERE \"Musical_ID\" = p_source_musical AND age > p_age_limit\n    LOOP\n        INSERT INTO actor (\"Actor_ID\", \"Name\", \"Musical_ID\", \"Character\", \"Duration\", age)\n        VALUES (\n            (SELECT COALESCE(MAX(\"Actor_ID\"), 0) + 1 FROM actor) + actor_rec.\"Actor_ID\",\n            actor_rec.\"Name\",\n            p_target_musical,\n            actor_rec.\"Character\",\n            actor_rec.\"Duration\",\n            actor_rec.age\n        );\n        \n        DELETE FROM actor WHERE \"Actor_ID\" = actor_rec.\"Actor_ID\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL transfer_actors_between_musicals(1, 2, 25);",
      "CALL transfer_actors_between_musicals(2, 3, 20);",
      "CALL transfer_actors_between_musicals(1, 3, 22);",
      "CALL transfer_actors_between_musicals(3, 1, 21);",
      "CALL transfer_actors_between_musicals(2, 1, 26);"
    ],
    "summary": "Create a stored procedure that transfers actors from a source musical to a target musical if their age exceeds a given limit. For each qualifying actor, insert a new record with a new Actor_ID (current ID plus max ID) and the target musical ID, then delete the original record.",
    "natural_language": "How can I create a stored procedure to move actors from one musical to another if they are above a certain age? For each actor that qualifies, it should insert a new record with a new Actor_ID (calculated as the current ID plus the maximum existing ID) and the target musical's ID, and then delete the original actor record.",
    "id": 268
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named create_musical_summary that accepts three input parameters: an integer p_start_year, an integer p_end_year, and a text p_category_filter. The procedure first declares three local integer variables: v_musical_count, v_new_musical_id, and v_summary_year. It begins execution by performing a SELECT query on the musical table to count all rows where the Year column value falls inclusively between the p_start_year and p_end_year parameters and where the Category column contains the string from p_category_filter as a substring, achieved by using the LIKE operator with wildcard characters '%' on both sides of the filter parameter; the resulting count is stored in v_musical_count. Next, it executes another SELECT query to retrieve the maximum existing value from the Musical_ID column in the musical table, applies the COALESCE function to substitute a value of 0 if the maximum is NULL, adds 1 to this value, and assigns the result to v_new_musical_id. It then calculates v_summary_year by taking the average of p_start_year and p_end_year, dividing their sum by 2, and applying the FLOOR function to the result to obtain an integer. Finally, the procedure performs an INSERT operation into the musical table, specifying values for the columns Musical_ID, Name, Year, Award, Category, Nominee, and Result. The inserted values are: v_new_musical_id for Musical_ID; a string concatenation of the literal 'Summary Report ' and the text cast of v_musical_count for Name; v_summary_year for Year; the literal string 'Summary Award' for Award; the p_category_filter parameter for Category; the literal string 'System Generated' for Nominee; and the literal string 'Completed' for Result.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_musical_summary(IN p_start_year integer, IN p_end_year integer, IN p_category_filter text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_musical_count integer;\n    v_new_musical_id integer;\n    v_summary_year integer;\nBEGIN\n    SELECT COUNT(*) INTO v_musical_count \n    FROM musical \n    WHERE \"Year\" BETWEEN p_start_year AND p_end_year \n    AND \"Category\" LIKE '%' || p_category_filter || '%';\n    \n    SELECT COALESCE(MAX(\"Musical_ID\"), 0) + 1 INTO v_new_musical_id FROM musical;\n    v_summary_year := FLOOR((p_start_year + p_end_year) / 2);\n    \n    INSERT INTO musical (\"Musical_ID\", \"Name\", \"Year\", \"Award\", \"Category\", \"Nominee\", \"Result\")\n    VALUES (\n        v_new_musical_id,\n        'Summary Report ' || v_musical_count::text,\n        v_summary_year,\n        'Summary Award',\n        p_category_filter,\n        'System Generated',\n        'Completed'\n    );\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL create_musical_summary(1980, 1990, 'Best Book');",
      "CALL create_musical_summary(1990, 2000, 'Best Performance');",
      "CALL create_musical_summary(2000, 2010, 'Best Direction');",
      "CALL create_musical_summary(1985, 1995, 'Musical');",
      "CALL create_musical_summary(2010, 2020, 'Award');"
    ],
    "summary": "Create a stored procedure named create_musical_summary that counts musicals within a year range and matching a category substring. It then generates a new musical ID, calculates a summary year, and inserts a summary report record into the musical table with these calculated values.",
    "natural_language": "Please construct a stored procedure designated as 'create_musical_summary'. This procedure shall perform the following operations: it must count the number of musicals that fall within a specified year range and whose category contains a given substring. Subsequently, it is to generate a new musical identifier, compute a summary year, and finally insert a record into the musical table. This new record will constitute a summary report containing the aforementioned calculated values.",
    "id": 269
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_major_popularity that accepts a single integer input parameter p_major_id, which identifies a specific major record. The procedure begins by declaring three local integer variables: v_total_rank, v_university_count, and v_popularity_score. It first queries the major_ranking table to compute the sum of all Rank column values associated with the provided p_major_id, using the COALESCE function to return 0 if no ranks are found, and stores this result in v_total_rank. It then performs a second query on the same major_ranking table to count the distinct University_ID values for the same p_major_id, storing this count in v_university_count. The procedure calculates a v_popularity_score by adding the v_total_rank and v_university_count values together. It subsequently updates the major table, setting the Major_Code column to the calculated v_popularity_score specifically for the row where the Major_ID matches the input p_major_id. Following the update, it checks the special FOUND boolean variable; if no rows were updated, indicating the p_major_id does not exist in the major table, it raises a NOTICE with the message 'Major with ID [p_major_id] not found'.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_major_popularity(p_major_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_rank integer;\n    v_university_count integer;\n    v_popularity_score integer;\nBEGIN\n    SELECT COALESCE(SUM(\"Rank\"), 0) INTO v_total_rank\n    FROM \"major_ranking\"\n    WHERE \"Major_ID\" = p_major_id;\n\n    SELECT COUNT(DISTINCT \"University_ID\") INTO v_university_count\n    FROM \"major_ranking\"\n    WHERE \"Major_ID\" = p_major_id;\n\n    v_popularity_score := v_total_rank + v_university_count;\n\n    UPDATE \"major\" \n    SET \"Major_Code\" = v_popularity_score\n    WHERE \"Major_ID\" = p_major_id;\n    \n    IF NOT FOUND THEN\n        RAISE NOTICE 'Major with ID % not found', p_major_id;\n    END IF;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL calculate_major_popularity(1);",
      "CALL calculate_major_popularity(2);",
      "CALL calculate_major_popularity(3);",
      "CALL calculate_major_popularity(5);",
      "CALL calculate_major_popularity(10);"
    ],
    "summary": "Create a stored procedure named calculate_major_popularity that calculates a popularity score for a given major by summing its ranks and counting distinct universities. It updates the major table with this score. If the major ID is not found, it raises a notice.",
    "natural_language": "Hey, can you whip up a stored procedure called calculate_major_popularity? Basically, it needs to figure out how popular a major is by adding up all its ranks and seeing how many different unis offer it. Then, it should slap that score into the major table. Oh, and if the major ID doesn't exist, just give a heads-up notice.",
    "id": 270
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_university_performance that accepts a single integer input parameter p_university_id, which identifies a specific university record to process. The procedure begins by declaring four local integer variables: v_reputation, v_research, v_citation, and v_total_score. It then executes a SELECT query on the overall_ranking table to retrieve and sum three specific point values for the given university. The query uses a WHERE clause to filter rows where the University_ID column matches the input parameter p_university_id. For each of the three columnsâ€”Reputation_point, Research_point, and Citation_pointâ€”the COALESCE function is applied to convert any NULL summation results to zero, ensuring no null values are assigned to the variables. The summed values are stored into the corresponding variables v_reputation, v_research, and v_citation. Following this, the procedure calculates v_total_score by adding the values of v_reputation, v_research, and v_citation together. Finally, the procedure performs an UPDATE operation on the university table. It modifies the record where the University_ID column equals the input p_university_id. The update sets the Enrollment column to its current value plus the calculated v_total_score, and it sets the Home_Conference column to the literal string value 'Updated'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_university_performance(p_university_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_reputation integer;\n    v_research integer;\n    v_citation integer;\n    v_total_score integer;\nBEGIN\n    SELECT COALESCE(SUM(\"Reputation_point\"), 0), COALESCE(SUM(\"Research_point\"), 0), COALESCE(SUM(\"Citation_point\"), 0) INTO v_reputation, v_research, v_citation\n    FROM \"overall_ranking\"\n    WHERE \"University_ID\" = p_university_id;\n\n    v_total_score := v_reputation + v_research + v_citation;\n\n    UPDATE \"university\"\n    SET \"Enrollment\" = \"Enrollment\" + v_total_score,\n        \"Home_Conference\" = 'Updated'\n    WHERE \"University_ID\" = p_university_id;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL update_university_performance(1);",
      "CALL update_university_performance(2);",
      "CALL update_university_performance(3);"
    ],
    "summary": "Create a stored procedure named update_university_performance that accepts a university ID. It retrieves and sums the reputation, research, and citation points for that university from the overall_ranking table, converting nulls to zero. It calculates a total score from these sums. Finally, it updates the university table for the given ID, incrementing the Enrollment column by the total score and setting the Home_Conference column to 'Updated'.",
    "natural_language": "Hey, can you whip up a stored procedure called update_university_performance that takes a uni's ID? It should grab that uni's rep, research, and citation points from the overall_ranking table, treating any nulls as zero, and add 'em all up. Then, figure out the total score from those sums. Finally, for that uni ID, bump up the Enrollment column by that total score and switch the Home_Conference column to say 'Updated'.",
    "id": 271
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `calculate_major_ranking_average` that accepts a single input parameter, `p_major_id`, which is of type `integer`. This procedure is designed to calculate the average rank for a specific major and then update a related major record with a rounded integer representation of this average.\n\nThe procedure begins by declaring a local variable, `v_avg_rank`, of type `numeric`, which will temporarily store the calculated average rank.\n\nNext, the procedure executes a `SELECT` statement to retrieve data. This `SELECT` statement calculates the average of the values in the `\"Rank\"` column from the `\"major_ranking\"` table. The `COALESCE` function is applied to this average, ensuring that if `AVG(\"Rank\")` returns `NULL` (which would happen if no rows match the `WHERE` clause), the value `0` is used instead. This calculated average (or `0`) is then stored into the `v_avg_rank` variable. The selection of rows for this average calculation is filtered by a `WHERE` clause, which specifies that only rows where the `\"Major_ID\"` column in the `\"major_ranking\"` table is equal to the value provided by the `p_major_id` input parameter are considered.\n\nFollowing the calculation, the procedure performs an `UPDATE` operation on the `\"major\"` table. This `UPDATE` statement sets the value of the `\"Major_Code\"` column. The new value for `\"Major_Code\"` is derived from the `v_avg_rank` variable: `ROUND(v_avg_rank)` is used to round the numeric average to the nearest whole number, and then `::integer` explicitly casts this rounded numeric value to an `integer` type. The `UPDATE` operation is restricted by a `WHERE` clause, ensuring that only the row in the `\"major\"` table where the `\"Major_ID\"` column matches the `p_major_id` input parameter is modified.\n\nFinally, the procedure includes a conditional statement (`IF NOT FOUND THEN`). This condition checks the `FOUND` status, which is a special variable in PL/pgSQL that indicates whether the immediately preceding `UPDATE`, `DELETE`, or `INSERT` statement affected any rows. If `NOT FOUND` is true, meaning the `UPDATE` statement did not find any row in the `\"major\"` table matching the `p_major_id`, then a `RAISE NOTICE` statement is executed. This `RAISE NOTICE` statement generates an informational message, displaying the text 'No major found with ID ' followed by the value of the `p_major_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_major_ranking_average(p_major_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_rank numeric;\nBEGIN\n    SELECT COALESCE(AVG(\"Rank\"), 0) INTO v_avg_rank\n    FROM \"major_ranking\"\n    WHERE \"Major_ID\" = p_major_id;\n\n    UPDATE \"major\" \n    SET \"Major_Code\" = ROUND(v_avg_rank)::integer\n    WHERE \"Major_ID\" = p_major_id;\n    \n    IF NOT FOUND THEN\n        RAISE NOTICE 'No major found with ID %', p_major_id;\n    END IF;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL calculate_major_ranking_average(1);",
      "CALL calculate_major_ranking_average(2);",
      "CALL calculate_major_ranking_average(3);",
      "CALL calculate_major_ranking_average(5);",
      "CALL calculate_major_ranking_average(99);"
    ],
    "summary": "Create a stored procedure named calculate_major_ranking_average that accepts a major ID. It calculates the average rank for that major from the major_ranking table, defaulting to zero if no rows are found. It then updates the major table for that ID, setting the Major_Code to the rounded integer average. If no matching major is found for the update, raise a notice.",
    "natural_language": "How can I create a stored procedure called calculate_major_ranking_average that takes a major ID, calculates the average rank for that major from the major_ranking table (defaulting to zero if no rows exist), and then updates the major table for that ID by setting the Major_Code to the rounded integer average, while also raising a notice if no matching major is found for the update?",
    "id": 272
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_university_enrollment that accepts a single integer input parameter named p_university_id, which is used to identify a specific university record, and within its execution block, it first declares a local integer variable v_total_enrollment, then performs a SELECT query on the university table to compute the sum of values in the Enrollment column for all rows where the University_ID column matches the provided p_university_id parameter, using the COALESCE function to return a sum of 0 if the SUM aggregation yields a NULL result, and stores this computed total into the v_total_enrollment variable, and subsequently executes an UPDATE operation on the university table, setting the Enrollment column to the value of the v_total_enrollment variable increased by 100, but only for the row where the University_ID column is equal to the input p_university_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_university_enrollment(p_university_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_enrollment integer;\nBEGIN\n    SELECT COALESCE(SUM(\"Enrollment\"), 0) INTO v_total_enrollment\n    FROM \"university\"\n    WHERE \"University_ID\" = p_university_id;\n\n    UPDATE \"university\"\n    SET \"Enrollment\" = v_total_enrollment + 100\n    WHERE \"University_ID\" = p_university_id;\nEND;\n$$;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "CALL update_university_enrollment(1);",
      "CALL update_university_enrollment(2);",
      "CALL update_university_enrollment(3);"
    ],
    "summary": "Create a stored procedure named update_university_enrollment that accepts a university ID. It calculates the total enrollment for that university from the university table, defaulting to zero. It then updates the university table for that ID, setting the Enrollment column to the calculated total plus 100.",
    "natural_language": "How can I create a stored procedure called update_university_enrollment that takes a university ID, calculates the total enrollment for that university from the university table (defaulting to zero), and then updates the university table for that ID by setting the Enrollment column to the calculated total plus 100?",
    "id": 273
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `calculate_student_distances` that accepts two input parameters: `p_student_id` of type `bigint`, representing the unique identifier of a student, and `p_target_city` of type `text`, representing the code of a target city. The procedure declares two local variables: `v_student_city` of type `text` to store the city code of the student, and `v_distance` of type `bigint` to store a calculated or retrieved distance. The procedure begins by executing a `SELECT` statement to retrieve the `city_code` from the `public.\"Student\"` table where the `\"StuID\"` column matches the value provided in the `p_student_id` parameter. The retrieved `city_code` is then assigned to the `v_student_city` variable. Following this, another `SELECT` statement is executed to retrieve the `\"distance\"` from the `public.\"Direct_distance\"` table. This selection is based on a compound `WHERE` clause that checks for two conditions: either `city1_code` in the table matches the `v_student_city` and `city2_code` matches the `p_target_city`, OR `city1_code` matches the `p_target_city` and `city2_code` matches the `v_student_city`. This ensures that the distance is found regardless of the order in which the cities are stored in the `Direct_distance` table. The retrieved `\"distance\"` is then assigned to the `v_distance` variable. Finally, an `INSERT` statement is executed to add a new row into the `public.\"Direct_distance\"` table. This `INSERT` statement specifies the values for the `\"city1_code\"`, `\"city2_code\"`, and `\"distance\"` columns as `v_student_city`, `p_target_city`, and `0` respectively. This `INSERT` operation is conditional, only proceeding if two conditions are met: `v_distance` is `NULL` (meaning no existing direct distance was found between the student's city and the target city) AND `v_student_city` is not `NULL` (ensuring that a valid student city was successfully retrieved).",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_student_distances(p_student_id bigint, p_target_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_city text;\n    v_distance bigint;\nBEGIN\n    SELECT city_code INTO v_student_city FROM public.\"Student\" WHERE \"StuID\" = p_student_id;\n    \n    SELECT \"distance\" INTO v_distance \n    FROM public.\"Direct_distance\" \n    WHERE (\"city1_code\" = v_student_city AND \"city2_code\" = p_target_city) \n       OR (\"city1_code\" = p_target_city AND \"city2_code\" = v_student_city);\n    \n    INSERT INTO public.\"Direct_distance\" (\"city1_code\", \"city2_code\", \"distance\") \n    SELECT v_student_city, p_target_city, 0 \n    WHERE v_distance IS NULL AND v_student_city IS NOT NULL;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL calculate_student_distances(1001, 'PIT');",
      "CALL calculate_student_distances(1002, 'PHL');",
      "CALL calculate_student_distances(1003, 'BAL');",
      "CALL calculate_student_distances(1001, 'PHL');",
      "CALL calculate_student_distances(1002, 'BAL');"
    ],
    "summary": "Create a stored procedure named calculate_student_distances that accepts a student ID and a target city code. It retrieves the student's city code. Then it attempts to find the distance between the two cities in the Direct_distance table, checking both column orders. If no distance is found and the student's city code is valid, it inserts a new record into the Direct_distance table with the two city codes and a distance of zero.",
    "natural_language": "Create procedure calculate_student_distances. Input: student ID and target city. Get student's city. Check Direct_distance table for a matching distance in either column order. If no match and student's city is valid, insert a zero-distance record for the two cities.",
    "id": 274
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `remove_student_city_data` that accepts two input parameters: `p_city_code` of type `text` and `p_min_age` of type `bigint`. The purpose of this procedure is to remove specific data related to students and direct distances based on the provided city code and minimum age. The procedure first performs a `DELETE` operation on the table named `\"Student\"`. This deletion targets rows where the value in the `city_code` column exactly matches the value provided in the `p_city_code` parameter AND the value in the `\"Age\"` column is strictly less than the value provided in the `p_min_age` parameter. Following this, the procedure performs a second `DELETE` operation on the table named `\"Direct_distance\"`. This deletion targets rows where the value in the `city1_code` column exactly matches the value provided in the `p_city_code` parameter OR the value in the `city2_code` column exactly matches the value provided in the `p_city_code` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_student_city_data(p_city_code text, p_min_age bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Student\" \n    WHERE city_code = p_city_code AND \"Age\" < p_min_age;\n    \n    DELETE FROM \"Direct_distance\" \n    WHERE city1_code = p_city_code OR city2_code = p_city_code;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL remove_student_city_data('BAL', 20);",
      "CALL remove_student_city_data('PIT', 18);",
      "CALL remove_student_city_data('PHL', 19);",
      "CALL remove_student_city_data('BAL', 21);",
      "CALL remove_student_city_data('PIT', 22);"
    ],
    "summary": "Create a stored procedure named remove_student_city_data that accepts a city code and a minimum age. First, delete from the Student table where the city_code matches and the age is less than the minimum. Then, delete from the Direct_distance table where the provided city code matches either the city1_code or city2_code column.",
    "natural_language": "What stored procedure can be created to remove student and distance data based on a city code and a minimum age? The procedure should first delete students from the Student table who are from the specified city and are younger than the given minimum age, and then it should delete any records from the Direct_distance table where the provided city code is either the starting or ending city.",
    "id": 275
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two input parameters, p_source_city and p_target_city, both of type text, and performs the following operations: First, it declares two local variables, v_lat and v_lon, both of type double precision, to temporarily store the latitude and longitude values. Then, it retrieves the latitude and longitude values from the \"City\" table for the row where the city_code column matches the value of the p_source_city parameter and assigns these values to the v_lat and v_lon variables. Next, it updates the \"City\" table by setting the latitude and longitude columns to the values stored in v_lat and v_lon for the row where the city_code column matches the value of the p_target_city parameter, but only if the value of v_lat is not NULL.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_city_coordinates(p_source_city text, p_target_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lat double precision;\n    v_lon double precision;\nBEGIN\n    SELECT latitude, longitude INTO v_lat, v_lon \n    FROM \"City\" \n    WHERE city_code = p_source_city;\n    \n    UPDATE \"City\" \n    SET latitude = v_lat, longitude = v_lon \n    WHERE city_code = p_target_city AND v_lat IS NOT NULL;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL sync_city_coordinates('BAL', 'PIT');",
      "CALL sync_city_coordinates('PHL', 'BAL');",
      "CALL sync_city_coordinates('PIT', 'PHL');",
      "CALL sync_city_coordinates('BAL', 'BAL');",
      "CALL sync_city_coordinates('PHL', 'PIT');"
    ],
    "summary": "Create a stored procedure that copies the latitude and longitude from a source city to a target city in the City table, using city codes as identifiers. The update should only occur if the source city's latitude is not null.",
    "natural_language": "Develop a comprehensive stored procedure that meticulously transfers the precise latitude and longitudinal coordinates from a carefully specified source city over to a distinctly identified target city, both of which are located within the extensive City table, by utilizing their unique city codes as the primary identifiers for matching. This crucial update operation must be executed exclusively under the strict condition that the source city's latitude value is definitively populated and not null.",
    "id": 276
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named migrate_students_by_distance that accepts two text parameters, p_from_city and p_to_city, representing source and destination city codes, declares a local variable v_distance of type bigint, and begins by querying the Direct_distance table to retrieve a single distance value where the city1_code and city2_code columns match the two input parameters in either order, storing the result in v_distance; if v_distance is not null, the procedure then executes an update on the Student table, setting the city_code column to the value of p_to_city for every row where the city_code column currently equals p_from_city, but only if the retrieved v_distance is less than 1000.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_students_by_distance(p_from_city text, p_to_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_distance bigint;\nBEGIN\n    SELECT distance INTO v_distance \n    FROM \"Direct_distance\" \n    WHERE (city1_code = p_from_city AND city2_code = p_to_city) \n       OR (city1_code = p_to_city AND city2_code = p_from_city);\n    \n    IF v_distance IS NOT NULL THEN\n        UPDATE \"Student\" \n        SET city_code = p_to_city \n        WHERE city_code = p_from_city AND v_distance < 1000;\n    END IF;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL migrate_students_by_distance('BAL', 'PIT');",
      "CALL migrate_students_by_distance('PHL', 'BAL');",
      "CALL migrate_students_by_distance('PIT', 'PHL');",
      "CALL migrate_students_by_distance('BAL', 'ATL');",
      "CALL migrate_students_by_distance('PHL', 'ATL');"
    ],
    "summary": "Create a stored procedure named migrate_students_by_distance that moves students from a source city to a target city, but only if the distance between the two cities (retrieved from the Direct_distance table) is less than 1000.",
    "natural_language": "What stored procedure can be created to migrate students from a source city to a target city, but only when the distance between them, as found in the Direct_distance table, is under 1000?",
    "id": 277
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named archive_distant_connections that accepts two input parameters: a text parameter named p_city_code and a bigint parameter named p_max_distance, and performs an INSERT operation into a table named \"Direct_distance\" by selecting distinct pairs of city codes from the \"Student\" table where the first student's city_code matches the input p_city_code and the second student's city_code is different from p_city_code, and where a corresponding pair does not already exist in the \"Direct_distance\" table, checking for existence by ensuring there is no row where either (city1_code equals the first student's city_code and city2_code equals the second student's city_code) or (city1_code equals the second student's city_code and city2_code equals the first student's city_code), and for each qualifying pair, inserts a new row into \"Direct_distance\" with city1_code set to the first student's city_code, city2_code set to the second student's city_code, and the distance column set to the value of the input parameter p_max_distance increased by 1000.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_distant_connections(p_city_code text, p_max_distance bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Direct_distance\" (city1_code, city2_code, distance)\n    SELECT DISTINCT s1.city_code, s2.city_code, p_max_distance + 1000\n    FROM \"Student\" s1, \"Student\" s2\n    WHERE s1.city_code = p_city_code \n      AND s2.city_code != p_city_code\n      AND NOT EXISTS (\n          SELECT 1 FROM \"Direct_distance\" d \n          WHERE (d.city1_code = s1.city_code AND d.city2_code = s2.city_code)\n             OR (d.city1_code = s2.city_code AND d.city2_code = s1.city_code)\n      );\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL archive_distant_connections('BAL', 1000);",
      "CALL archive_distant_connections('PIT', 500);",
      "CALL archive_distant_connections('PHL', 2000);",
      "CALL archive_distant_connections('HKG', 10000);",
      "CALL archive_distant_connections('WAS', 750);"
    ],
    "summary": "Create a stored procedure named archive_distant_connections that inserts new distance records into the Direct_distance table. For a given city code, it finds all distinct connections to other cities via the Student table, avoids duplicates, and sets the distance to a provided maximum value plus 1000.",
    "natural_language": "Create procedure archive_distant_connections to insert records into Direct_distance. For a city code, find its distinct student connections, prevent duplicates, and set distance to max value plus 1000.",
    "id": 278
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes four input parameters: p_min_age (bigint), p_max_age (bigint), p_pet_type_filter (text), and p_output_city (text). The procedure performs multiple operations involving the \"Pets\", \"Has_Pet\", and \"Student\" tables. First, it calculates the average weight of pets whose \"PetType\" matches the value of p_pet_type_filter and whose \"pet_age\" falls between p_min_age and p_max_age, storing the result in the variable v_avg_weight. Next, it counts the total number of pets associated with students residing in the city specified by p_output_city by joining the \"Pets\" table with the \"Has_Pet\" table on \"PetID\" and further joining with the \"Student\" table on \"StuID\", storing the count in the variable v_total_pets. Then, it determines the maximum age of pets whose \"PetType\" matches p_pet_type_filter, storing the result in the variable v_oldest_pet_age. After that, it counts the number of distinct students who own pets of the type specified by p_pet_type_filter and whose \"Age\" is greater than p_min_age by joining the \"Student\" table with the \"Has_Pet\" table on \"StuID\" and further joining with the \"Pets\" table on \"PetID\", storing the count in the variable v_student_count. Finally, the procedure inserts a new row into the \"Student\" table with fixed values for \"StuID\" (9999), \"Fname\" ('Stats'), \"LName\" ('Report'), \"Sex\" ('M'), and \"Major\" (v_student_count), while dynamically assigning the values of v_oldest_pet_age to \"Age\", v_total_pets to \"Advisor\", and p_output_city to \"city_code\".",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_student_pet_stats(\n    p_min_age bigint,\n    p_max_age bigint,\n    p_pet_type_filter text,\n    p_output_city text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_weight real;\n    v_total_pets bigint;\n    v_oldest_pet_age bigint;\n    v_student_count bigint;\nBEGIN\n    SELECT AVG(\"weight\") INTO v_avg_weight\n    FROM \"Pets\"\n    WHERE \"PetType\" = p_pet_type_filter\n    AND \"pet_age\" BETWEEN p_min_age AND p_max_age;\n    \n    SELECT COUNT(*) INTO v_total_pets\n    FROM \"Pets\" p\n    INNER JOIN \"Has_Pet\" hp ON p.\"PetID\" = hp.\"PetID\"\n    INNER JOIN \"Student\" s ON hp.\"StuID\" = s.\"StuID\"\n    WHERE s.\"city_code\" = p_output_city;\n    \n    SELECT MAX(\"pet_age\") INTO v_oldest_pet_age\n    FROM \"Pets\"\n    WHERE \"PetType\" = p_pet_type_filter;\n    \n    SELECT COUNT(DISTINCT s.\"StuID\") INTO v_student_count\n    FROM \"Student\" s\n    INNER JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n    INNER JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\"\n    WHERE p.\"PetType\" = p_pet_type_filter\n    AND s.\"Age\" > p_min_age;\n    \n    INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n    VALUES (9999, 'Stats', 'Report', v_oldest_pet_age, 'M', v_student_count, v_total_pets, p_output_city);\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL calculate_student_pet_stats(1, 5, 'dog', 'BAL');",
      "CALL calculate_student_pet_stats(0, 10, 'cat', 'HKG');",
      "CALL calculate_student_pet_stats(2, 8, 'dog', 'WAS');",
      "CALL calculate_student_pet_stats(1, 3, 'cat', 'NYC');",
      "CALL calculate_student_pet_stats(5, 15, 'bird', 'LAX');"
    ],
    "summary": "Create a stored procedure that calculates several pet-related statistics based on age range, pet type, and a target city. It then inserts a summary report as a new student record with the calculated values (oldest pet age, total pet count, student count) and fixed dummy data.",
    "natural_language": "Calculate pet statistics by age range, pet type, and target city, then insert a summary report as a new student record with the oldest pet age, total pet count, student count, and fixed dummy data.",
    "id": 279
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named transfer_pets_between_students that accepts four input parameters: p_source_student of type bigint representing the student identifier from whom pets will be transferred, p_target_student of type bigint representing the student identifier to whom pets will be transferred, p_pet_type_to_transfer of type text specifying the species or type of pet to be moved, and p_max_pets_to_transfer of type bigint defining the maximum number of pets of the specified type to transfer. The procedure declares a local variable v_transferred_count of type bigint initialized to zero to track the number of pets successfully transferred, a variable v_pet_record of type RECORD to hold fetched rows, and a cursor named v_cursor defined by a SELECT statement that queries the Pets table aliased as p, performing an inner join with the Has_Pet table aliased as hp on the condition that p.PetID equals hp.PetID, filtering the results where the hp.StuID matches the p_source_student parameter and the p.PetType equals the p_pet_type_to_transfer parameter, and limiting the result set to the number of rows specified by the p_max_pets_to_transfer parameter, selecting only the p.PetID column. The procedure opens the cursor, then enters a loop where it fetches the next row from the cursor into v_pet_record, exiting the loop when no more rows are found. For each fetched row, it executes a DELETE operation on the Has_Pet table, removing the row where the StuID column equals p_source_student and the PetID column equals the v_pet_record.PetID value from the cursor, then performs an INSERT operation into the Has_Pet table, adding a new row with the StuID column set to p_target_student and the PetID column set to v_pet_record.PetID, and increments the v_transferred_count variable by one. After the loop concludes, the procedure closes the cursor. Finally, it executes an UPDATE statement on the Pets table, setting the weight column to its current value multiplied by 1.1 for all rows where the PetID is found in a subquery that selects the PetID from the Has_Pet table for rows where the StuID equals the p_target_student parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_pets_between_students(\n    p_source_student bigint,\n    p_target_student bigint,\n    p_pet_type_to_transfer text,\n    p_max_pets_to_transfer bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_transferred_count bigint := 0;\n    v_pet_record RECORD;\n    v_cursor CURSOR FOR\n        SELECT p.\"PetID\"\n        FROM \"Pets\" p\n        INNER JOIN \"Has_Pet\" hp ON p.\"PetID\" = hp.\"PetID\"\n        WHERE hp.\"StuID\" = p_source_student\n        AND p.\"PetType\" = p_pet_type_to_transfer\n        LIMIT p_max_pets_to_transfer;\nBEGIN\n    OPEN v_cursor;\n    \n    LOOP\n        FETCH v_cursor INTO v_pet_record;\n        EXIT WHEN NOT FOUND;\n        \n        DELETE FROM \"Has_Pet\"\n        WHERE \"StuID\" = p_source_student\n        AND \"PetID\" = v_pet_record.\"PetID\";\n        \n        INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\")\n        VALUES (p_target_student, v_pet_record.\"PetID\");\n        \n        v_transferred_count := v_transferred_count + 1;\n    END LOOP;\n    \n    CLOSE v_cursor;\n    \n    UPDATE \"Pets\"\n    SET \"weight\" = \"weight\" * 1.1\n    WHERE \"PetID\" IN (\n        SELECT \"PetID\" FROM \"Has_Pet\"\n        WHERE \"StuID\" = p_target_student\n    );\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL transfer_pets_between_students(1001, 1002, 'dog', 2);",
      "CALL transfer_pets_between_students(1002, 1003, 'cat', 1);",
      "CALL transfer_pets_between_students(1001, 1003, 'dog', 5);",
      "CALL transfer_pets_between_students(1003, 1001, 'cat', 3);",
      "CALL transfer_pets_between_students(1002, 1001, 'dog', 1);"
    ],
    "summary": "Create a stored procedure named transfer_pets_between_students that transfers a specified type and maximum number of pets from a source student to a target student. It updates ownership records and increases the weight of the transferred pets by 10% for the new owner.",
    "natural_language": "Create a stored procedure named transfer_pets_between_students that carefully orchestrates the transfer of a specified type and a defined maximum number of beloved pets from a designated source student over to a grateful target student. This intricate procedure meticulously updates all relevant pet ownership records and, as a welcoming gesture for the new owner, thoughtfully increases the weight of each transferred pet by a full ten percent.",
    "id": 280
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes four input parameters: p_age_threshold (bigint), p_weight_limit (real), p_city_pattern (text), and p_major_code (bigint). The procedure performs multiple operations to analyze pet distribution and student demographics based on these parameters. First, it calculates the count of dogs owned by students whose age exceeds p_age_threshold and whose major matches p_major_code by joining the Pets table, Has_Pet table, and Student table, filtering rows where PetType is 'dog'. The result is stored in the variable v_dog_count. Next, it calculates the count of cats owned by students living in cities whose city_code matches the pattern specified in p_city_pattern and whose pet weight is less than p_weight_limit, using a similar join across the Pets, Has_Pet, and Student tables, filtering rows where PetType is 'cat'. The result is stored in the variable v_cat_count. Then, it calculates the count of pets that are neither dogs nor cats and whose pet_age is less than or equal to p_age_threshold by joining the Pets and Has_Pet tables and filtering rows where PetType is not 'dog' or 'cat'. The result is stored in the variable v_other_count. Afterward, it calculates the average age of students who own pets and whose major matches p_major_code by querying the Student table and checking for the existence of a corresponding record in the Has_Pet table. The result is stored in the variable v_avg_student_age. Finally, the procedure evaluates three conditional branches: if v_dog_count is greater than v_cat_count, it inserts a new record into the Pets table with PetType set to 'dog', pet_age set to p_age_threshold, and weight set to p_weight_limit, using v_dog_count multiplied by 1000 as the PetID; if v_cat_count is greater than v_other_count, it inserts a new record into the Pets table with PetType set to 'cat', pet_age set to p_age_threshold, and weight set to half of p_weight_limit, using v_cat_count multiplied by 1000 as the PetID; otherwise, it inserts a new record into the Pets table with PetType set to 'other', pet_age set to p_age_threshold, and weight set to 1.5 times p_weight_limit, using v_other_count multiplied by 1000 as the PetID.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_pet_distribution(\n    p_age_threshold bigint,\n    p_weight_limit real,\n    p_city_pattern text,\n    p_major_code bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dog_count bigint;\n    v_cat_count bigint;\n    v_other_count bigint;\n    v_avg_student_age real;\nBEGIN\n    SELECT COUNT(*) INTO v_dog_count\n    FROM \"Pets\" p\n    INNER JOIN \"Has_Pet\" hp ON p.\"PetID\" = hp.\"PetID\"\n    INNER JOIN \"Student\" s ON hp.\"StuID\" = s.\"StuID\"\n    WHERE p.\"PetType\" = 'dog'\n    AND s.\"Age\" > p_age_threshold\n    AND s.\"Major\" = p_major_code;\n    \n    SELECT COUNT(*) INTO v_cat_count\n    FROM \"Pets\" p\n    INNER JOIN \"Has_Pet\" hp ON p.\"PetID\" = hp.\"PetID\"\n    INNER JOIN \"Student\" s ON hp.\"StuID\" = s.\"StuID\"\n    WHERE p.\"PetType\" = 'cat'\n    AND p.\"weight\" < p_weight_limit\n    AND s.\"city_code\" LIKE '%' || p_city_pattern || '%';\n    \n    SELECT COUNT(*) INTO v_other_count\n    FROM \"Pets\" p\n    INNER JOIN \"Has_Pet\" hp ON p.\"PetID\" = hp.\"PetID\"\n    WHERE p.\"PetType\" NOT IN ('dog', 'cat')\n    AND p.\"pet_age\" <= p_age_threshold;\n    \n    SELECT AVG(\"Age\") INTO v_avg_student_age\n    FROM \"Student\" s\n    WHERE EXISTS (\n        SELECT 1 FROM \"Has_Pet\" hp\n        WHERE hp.\"StuID\" = s.\"StuID\"\n    )\n    AND s.\"Major\" = p_major_code;\n    \n    IF v_dog_count > v_cat_count THEN\n        INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\")\n        VALUES (v_dog_count * 1000, 'dog', p_age_threshold, p_weight_limit);\n    ELSIF v_cat_count > v_other_count THEN\n        INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\")\n        VALUES (v_cat_count * 1000, 'cat', p_age_threshold, p_weight_limit / 2);\n    ELSE\n        INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\")\n        VALUES (v_other_count * 1000, 'other', p_age_threshold, p_weight_limit * 1.5);\n    END IF;\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL analyze_pet_distribution(20, 15.5, 'BAL', 600);",
      "CALL analyze_pet_distribution(25, 10.0, 'HKG', 700);",
      "CALL analyze_pet_distribution(18, 20.0, 'WAS', 600);",
      "CALL analyze_pet_distribution(30, 8.5, 'NYC', 800);",
      "CALL analyze_pet_distribution(22, 12.3, 'LA', 650);"
    ],
    "summary": "Create a PL/pgSQL procedure with parameters p_age_threshold (bigint), p_weight_limit (real), p_city_pattern (text), and p_major_code (bigint). Count dogs owned by students older than p_age_threshold with major p_major_code. Count cats owned by students in cities matching p_city_pattern with pet weight below p_weight_limit. Count other pets (not dog/cat) with age <= p_age_threshold. Calculate the average age of pet-owning students with major p_major_code. Based on counts: if dog count > cat count, insert a dog with ID (dog_count*1000), age p_age_threshold, weight p_weight_limit; else if cat count > other count, insert a cat with ID (cat_count*1000), age p_age_threshold, weight (p_weight_limit/2); else insert an 'other' pet with ID (other_count*1000), age p_age_threshold, weight (p_weight_limit*1.5).",
    "natural_language": "Count dogs owned by students older than p_age_threshold with major p_major_code. Count cats from students in cities like p_city_pattern with weight under p_weight_limit. Count other pets (not dog/cat) with age <= p_age_threshold. Get average student age for major p_major_code. If dog count > cat count, insert dog with ID (dog_count*1000), age p_age_threshold, weight p_weight_limit. Else if cat count > other count, insert cat with ID (cat_count*1000), age p_age_threshold, weight (p_weight_limit/2). Else insert other pet with ID (other_count*1000), age p_age_threshold, weight (p_weight_limit*1.5).",
    "id": 281
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named reorganize_pet_ownership that accepts four input parameters: a bigint parameter p_age_cutoff, a real parameter p_weight_multiplier, a text parameter p_target_city, and a bigint parameter p_new_major. The procedure begins by declaring a record variable v_student_record to hold student rows and a bigint variable v_pet_counter initialized to zero. It then enters a loop that iterates over a result set from a SELECT query on the Student table, aliased as s, which retrieves the StuID, Fname, and LName columns for students where the city_code column equals the p_target_city parameter, the Age column is less than the p_age_cutoff parameter, and a correlated subquery using NOT EXISTS confirms the student has no existing entry in the Has_Pet table (by checking for the absence of a matching StuID in the Has_Pet table, aliased as hp). For each student record fetched into v_student_record, the procedure performs a series of operations: first, it inserts a new row into the Pets table, specifying the PetID column as the student's StuID plus 5000, the PetType column as the literal string 'assigned', the pet_age column as the value of the p_age_cutoff parameter, and the weight column as 15.0 multiplied by the p_weight_multiplier parameter; second, it inserts a corresponding row into the Has_Pet table, linking the student's StuID to the newly created PetID (which is StuID + 5000); third, it updates the Student table for the current student, setting the Major column to the value of the p_new_major parameter and incrementing the Age column by one; fourth, it increments the v_pet_counter variable by one. The loop includes an EXIT condition that terminates the loop when v_pet_counter reaches or exceeds 5, meaning the loop processes a maximum of five qualifying student records. After the loop completes, the procedure executes a DELETE operation on the Has_Pet table, removing rows where the PetID is found in a subquery that selects PetID from the Pets table, aliased as p, for pets where the pet_age column is greater than twice the p_age_cutoff parameter and the weight column is less than 5.0. Finally, it executes a second DELETE operation directly on the Pets table, removing rows where the pet_age column is greater than twice the p_age_cutoff parameter and the weight column is less than 5.0.",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_pet_ownership(\n    p_age_cutoff bigint,\n    p_weight_multiplier real,\n    p_target_city text,\n    p_new_major bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_record RECORD;\n    v_pet_counter bigint := 0;\nBEGIN\n    FOR v_student_record IN\n        SELECT s.\"StuID\", s.\"Fname\", s.\"LName\"\n        FROM \"Student\" s\n        WHERE s.\"city_code\" = p_target_city\n        AND s.\"Age\" < p_age_cutoff\n        AND NOT EXISTS (\n            SELECT 1 FROM \"Has_Pet\" hp\n            WHERE hp.\"StuID\" = s.\"StuID\"\n        )\n    LOOP\n        INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\")\n        VALUES (v_student_record.\"StuID\" + 5000, 'assigned', p_age_cutoff, 15.0 * p_weight_multiplier);\n        \n        INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\")\n        VALUES (v_student_record.\"StuID\", v_student_record.\"StuID\" + 5000);\n        \n        UPDATE \"Student\"\n        SET \"Major\" = p_new_major,\n            \"Age\" = \"Age\" + 1\n        WHERE \"StuID\" = v_student_record.\"StuID\";\n        \n        v_pet_counter := v_pet_counter + 1;\n        \n        EXIT WHEN v_pet_counter >= 5;\n    END LOOP;\n    \n    DELETE FROM \"Has_Pet\"\n    WHERE \"PetID\" IN (\n        SELECT p.\"PetID\"\n        FROM \"Pets\" p\n        WHERE p.\"pet_age\" > p_age_cutoff * 2\n        AND p.\"weight\" < 5.0\n    );\n    \n    DELETE FROM \"Pets\"\n    WHERE \"pet_age\" > p_age_cutoff * 2\n    AND \"weight\" < 5.0;\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL reorganize_pet_ownership(20, 1.5, 'BAL', 700);",
      "CALL reorganize_pet_ownership(25, 2.0, 'HKG', 800);",
      "CALL reorganize_pet_ownership(18, 1.2, 'WAS', 900);",
      "CALL reorganize_pet_ownership(22, 1.8, 'BAL', 750);",
      "CALL reorganize_pet_ownership(30, 2.5, 'HKG', 850);"
    ],
    "summary": "Create a PL/pgSQL procedure named reorganize_pet_ownership with parameters p_age_cutoff (bigint), p_weight_multiplier (real), p_target_city (text), and p_new_major (bigint). For up to 5 students in city p_target_city, younger than p_age_cutoff, and without pets: assign them a new pet (ID = StuID+5000, type 'assigned', age p_age_cutoff, weight 15.0 * p_weight_multiplier), link it in Has_Pet, update the student's major to p_new_major and increment their age by 1. Then, delete from Has_Pet and Pets where pet_age > (2 * p_age_cutoff) and weight < 5.0.",
    "natural_language": "Alright, so we need a procedure called reorganize_pet_ownership. It's gotta take a few inputs: p_age_cutoff (a big number), p_weight_multiplier (a decimal), p_target_city (some text), and p_new_major (another big number). Here's the deal: grab up to 5 students who live in that target city, are younger than the age cutoff, and don't have any pets yet. For each of these students, we're gonna give 'em a new pet. The pet's ID is the student's ID plus 5000, its type is just 'assigned', its age is the same as the age cutoff, and its weight is 15.0 times that weight multiplier. Don't forget to link the pet to the student in the Has_Pet table. Also, update the student's major to the new major and bump their age up by one. After that's done, go ahead and clean out any old, tiny pets: delete records from both Has_Pet and Pets where the pet's age is more than double the age cutoff and its weight is less than 5.0.",
    "id": 282
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named generate_pet_summary_report that accepts four input parameters: a real number p_min_weight, a real number p_max_weight, a text string p_name_prefix, and a big integer p_advisor_id. The procedure begins by declaring local variables v_type_summary as text, v_total_students, v_pet_count as bigint, and v_heaviest_pet_weight, v_lightest_pet_weight as real. It first uses a common table expression named pet_counts to select the PetType column and count rows from the Pets table where the weight column value falls between p_min_weight and p_max_weight inclusive, grouping the results by PetType. It then aggregates the results from this CTE into the v_type_summary variable by using STRING_AGG to concatenate each PetType with its corresponding count, separated by a colon, with each pair joined by a comma and space. Next, it calculates v_total_students by counting distinct StuID values from the Student table after performing an inner join with the Has_Pet table on matching StuID and another inner join with the Pets table on matching PetID, filtering for rows where the Student.Advisor column equals the p_advisor_id parameter and the Pets.weight column is greater than p_min_weight. It then finds the maximum weight from the Pets table where the PetType column starts with the string in p_name_prefix and stores it in v_heaviest_pet_weight, and similarly finds the minimum weight under the same PetType condition and stores it in v_lightest_pet_weight. Following this, a conditional block executes: if v_heaviest_pet_weight is greater than p_max_weight, it inserts a new row into the Student table with StuID 8888, Fname 'Heavy', LName 'PetOwner', Age 25, Sex 'F', Major 999, Advisor set to p_advisor_id, and city_code 'SUM', but only if a student with StuID 8888 does not already exist; else if v_lightest_pet_weight is less than p_min_weight, it inserts a new row with StuID 8889, Fname 'Light', LName 'PetOwner', Age 22, Sex 'M', Major 888, Advisor p_advisor_id, and city_code 'SUM', provided a student with StuID 8889 does not already exist; otherwise, it inserts a row with StuID 8890, Fname 'Average', LName 'PetOwner', Age 20, Sex 'F', Major 777, Advisor p_advisor_id, and city_code 'SUM', conditional on the non-existence of StuID 8890. Finally, the procedure updates the Pets table for all rows where PetType starts with p_name_prefix, incrementing the pet_age column by one and adjusting the weight column using a CASE expression: if weight is less than p_min_weight, weight is multiplied by 1.2; if weight is greater than p_max_weight, weight is multiplied by 0.9; otherwise, weight remains unchanged.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_pet_summary_report(\n    p_min_weight real,\n    p_max_weight real,\n    p_name_prefix text,\n    p_advisor_id bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_type_summary text;\n    v_total_students bigint;\n    v_heaviest_pet_weight real;\n    v_lightest_pet_weight real;\n    v_pet_count bigint;\nBEGIN\n    WITH pet_counts AS (\n        SELECT \"PetType\", COUNT(*) as type_count\n        FROM \"Pets\"\n        WHERE \"weight\" BETWEEN p_min_weight AND p_max_weight\n        GROUP BY \"PetType\"\n    )\n    SELECT STRING_AGG(\"PetType\" || ':' || type_count::text, ', ') INTO v_type_summary\n    FROM pet_counts;\n    \n    SELECT COUNT(DISTINCT s.\"StuID\") INTO v_total_students\n    FROM \"Student\" s\n    INNER JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n    INNER JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\"\n    WHERE s.\"Advisor\" = p_advisor_id\n    AND p.\"weight\" > p_min_weight;\n    \n    SELECT MAX(\"weight\") INTO v_heaviest_pet_weight\n    FROM \"Pets\"\n    WHERE \"PetType\" LIKE p_name_prefix || '%';\n    \n    SELECT MIN(\"weight\") INTO v_lightest_pet_weight\n    FROM \"Pets\"\n    WHERE \"PetType\" LIKE p_name_prefix || '%';\n    \n    IF v_heaviest_pet_weight > p_max_weight THEN\n        INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n        SELECT 8888, 'Heavy', 'PetOwner', 25, 'F', 999, p_advisor_id, 'SUM'\n        WHERE NOT EXISTS (SELECT 1 FROM \"Student\" WHERE \"StuID\" = 8888);\n    ELSIF v_lightest_pet_weight < p_min_weight THEN\n        INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n        SELECT 8889, 'Light', 'PetOwner', 22, 'M', 888, p_advisor_id, 'SUM'\n        WHERE NOT EXISTS (SELECT 1 FROM \"Student\" WHERE \"StuID\" = 8889);\n    ELSE\n        INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n        SELECT 8890, 'Average', 'PetOwner', 20, 'F', 777, p_advisor_id, 'SUM'\n        WHERE NOT EXISTS (SELECT 1 FROM \"Student\" WHERE \"StuID\" = 8890);\n    END IF;\n    \n    UPDATE \"Pets\"\n    SET \"pet_age\" = \"pet_age\" + 1,\n        \"weight\" = CASE\n            WHEN \"weight\" < p_min_weight THEN \"weight\" * 1.2\n            WHEN \"weight\" > p_max_weight THEN \"weight\" * 0.9\n            ELSE \"weight\"\n        END\n    WHERE \"PetType\" LIKE p_name_prefix || '%';\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL generate_pet_summary_report(5.0, 15.0, 'c', 1121);",
      "CALL generate_pet_summary_report(10.0, 20.0, 'd', 7712);",
      "CALL generate_pet_summary_report(1.0, 10.0, 'b', 7792);",
      "CALL generate_pet_summary_report(8.0, 18.0, 'a', 1121);",
      "CALL generate_pet_summary_report(12.0, 25.0, 'f', 7712);"
    ],
    "summary": "Create a PL/pgSQL procedure named generate_pet_summary_report with parameters p_min_weight (real), p_max_weight (real), p_name_prefix (text), and p_advisor_id (bigint). Generate a summary string of pet types and their counts for weights between p_min_weight and p_max_weight. Count distinct students with pets (weight > p_min_weight) advised by p_advisor_id. Find the heaviest and lightest pet weight for types starting with p_name_prefix. Conditionally insert a student (ID 8888, 8889, or 8890) based on weight comparisons. Update pets of types starting with p_name_prefix: increment age by 1, adjust weight (multiply by 1.2 if < p_min_weight, by 0.9 if > p_max_weight).",
    "natural_language": "Develop a comprehensive PL/pgSQL procedure, which should be named generate_pet_summary_report, that accepts the following parameters: a minimum weight threshold p_min_weight (as a real number), a maximum weight threshold p_max_weight (also a real number), a text prefix for pet types p_name_prefix, and a specific advisor identifier p_advisor_id (as a bigint). This procedure must meticulously generate a detailed summary string that enumerates various pet types alongside their corresponding counts, specifically for those pets whose weights fall inclusively between the provided minimum and maximum parameters. Furthermore, it should accurately calculate the count of distinct students who are advised by the specified advisor and own pets weighing more than the p_min_weight threshold. Additionally, the procedure needs to diligently ascertain the single heaviest and the single lightest weight among all pets whose type names begin with the given p_name_prefix. Based on a conditional logic that compares these extreme weight values, the procedure must then insert a new student record, selecting the student ID from the set {8888, 8889, 8890}. Finally, it should perform an update on all pets whose types start with the provided prefix: increment each pet's age by one year, and carefully adjust its weight by multiplying it by 1.2 if the current weight is below p_min_weight, or by 0.9 if it exceeds p_max_weight.",
    "id": 283
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five input parameters: p_building_id (text), p_min_enrollment (integer), p_max_enrollment (integer), p_founded_year (real), and p_conference_filter (text). The procedure begins by retrieving the Name column from the building table for the row where the building_id matches the value of p_building_id and stores this value in the local variable v_building_name. Next, it calculates the count of rows in the Institution table where the building_id matches p_building_id, the Enrollment column falls between p_min_enrollment and p_max_enrollment, the Founded column is greater than or equal to p_founded_year, and the Primary_Conference column contains the substring specified in p_conference_filter. This count is stored in the local variable v_institution_count. The procedure then evaluates the value of v_institution_count using conditional logic. If v_institution_count is greater than 0, it deletes rows from the Institution table where the building_id matches p_building_id and the Enrollment column is less than p_min_enrollment. If v_institution_count equals 0, it inserts a new row into the Institution table with the following values: Institution_id set to the concatenation of p_building_id and '-NEW', Institution set to 'New Institution for ' concatenated with v_building_name, Location set to 'Unknown Location', Founded set to p_founded_year, Type set to 'Private', Enrollment set to p_min_enrollment, Team set to 'New Team', Primary_Conference set to p_conference_filter, and building_id set to p_building_id. If v_institution_count is neither greater than 0 nor equal to 0, it updates the Primary_Conference column in the Institution table to the result of the enum_last function applied to a null text value for rows where the building_id matches p_building_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_building_institutions(\n    IN p_building_id text,\n    IN p_min_enrollment integer,\n    IN p_max_enrollment integer,\n    IN p_founded_year real,\n    IN p_conference_filter text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_building_name text;\n    v_institution_count integer;\nBEGIN\n    SELECT \"Name\" INTO v_building_name\n    FROM \"building\"\n    WHERE \"building_id\" = p_building_id;\n\n    SELECT COUNT(*) INTO v_institution_count\n    FROM \"Institution\" i\n    WHERE i.\"building_id\" = p_building_id\n      AND i.\"Enrollment\" BETWEEN p_min_enrollment AND p_max_enrollment\n      AND i.\"Founded\" >= p_founded_year\n      AND i.\"Primary_Conference\" LIKE '%' || p_conference_filter || '%';\n\n    IF v_institution_count > 0 THEN\n        DELETE FROM \"Institution\"\n        WHERE \"building_id\" = p_building_id\n          AND \"Enrollment\" < p_min_enrollment;\n    ELSIF v_institution_count = 0 THEN\n        INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\")\n        VALUES (p_building_id || '-NEW', 'New Institution for ' || v_building_name, 'Unknown Location', p_founded_year, 'Private', p_min_enrollment, 'New Team', p_conference_filter, p_building_id);\n    ELSE\n        UPDATE \"Institution\"\n        SET \"Primary_Conference\" = enum_last(null::text)\n        WHERE \"building_id\" = p_building_id;\n    END IF;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "CALL process_building_institutions('1', 1000, 5000, 1900.0, 'Sun');",
      "CALL process_building_institutions('3', 500, 2000, 1850.0, 'none');",
      "CALL process_building_institutions('0', 100, 1000, 2000.0, 'Big Ten');",
      "CALL process_building_institutions('1', 100, 200, 1950.0, 'SEC');",
      "CALL process_building_institutions('2', 2000, 10000, 1800.0, 'ACC');"
    ],
    "summary": "Create a PL/pgSQL procedure with parameters p_building_id (text), p_min_enrollment (integer), p_max_enrollment (integer), p_founded_year (real), and p_conference_filter (text). Get the building name for p_building_id. Count institutions in that building where enrollment is between p_min_enrollment and p_max_enrollment, founded >= p_founded_year, and primary conference contains p_conference_filter. If count > 0, delete institutions in the building with enrollment < p_min_enrollment. If count = 0, insert a new institution with ID (p_building_id + '-NEW'), name 'New Institution for [building_name]', and other provided/default values. Otherwise, update the primary conference for institutions in the building using the enum_last function.",
    "natural_language": "Write a procedure that takes a building ID, a range for how many students are enrolled, a founding year, and something about a conference. First, find out the building's name. Then, see roughly how many institutions are in that building that have a decent number of students within that range, were founded around or after that year, and whose main conference is somewhat related to the given filter text. If you find a fair number of such places, remove any institutions in the building that have a pretty low enrollment. If you don't find any at all, add a new institution with a made-up ID based on the building, a generic name for that building, and some other typical details. Otherwise, if there's some other outcome, adjust the primary conference for institutions there using a special function.",
    "id": 284
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five input parameters: p_common_name_pattern (text), p_min_identity (text), p_max_identity (text), p_length_multiplier (real), and p_divergence_adjustment (real). The procedure iterates over all rows in the \"protein\" table where the \"common_name\" column contains the substring specified by p_common_name_pattern and the \"sequence_identity_to_human_protein\" column, after removing the '%' character and converting it to an integer, falls within the range defined by p_min_identity and p_max_identity, also processed similarly. For each matching row, the procedure calculates a new sequence length by multiplying the \"sequence_length\" column value by p_length_multiplier and computes a new divergence value by adding p_divergence_adjustment to the \"divergence_from_human_lineage\" column value. It then inserts a new row into the \"protein\" table with the following values: the \"common_name\" prefixed with 'Transformed: ', the original \"protein_name\", the newly calculated divergence value, the original \"accession_number\" prefixed with 'TRANS-', the newly calculated sequence length, the original \"sequence_identity_to_human_protein\", and the original \"Institution_id\".",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_protein_data(\n    IN p_common_name_pattern text,\n    IN p_min_identity text,\n    IN p_max_identity text,\n    IN p_length_multiplier real,\n    IN p_divergence_adjustment real\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_protein_record RECORD;\n    v_new_length real;\n    v_new_divergence real;\nBEGIN\n    FOR v_protein_record IN \n        SELECT * FROM \"protein\"\n        WHERE \"common_name\" LIKE '%' || p_common_name_pattern || '%'\n          AND REPLACE(\"sequence_identity_to_human_protein\", '%', '')::integer BETWEEN \n              REPLACE(p_min_identity, '%', '')::integer AND \n              REPLACE(p_max_identity, '%', '')::integer\n    LOOP\n        v_new_length := v_protein_record.\"sequence_length\" * p_length_multiplier;\n        v_new_divergence := v_protein_record.\"divergence_from_human_lineage\" + p_divergence_adjustment;\n        \n        INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\")\n        VALUES (\n            'Transformed: ' || v_protein_record.\"common_name\",\n            v_protein_record.\"protein_name\",\n            v_new_divergence,\n            'TRANS-' || v_protein_record.\"accession_number\",\n            v_new_length,\n            v_protein_record.\"sequence_identity_to_human_protein\",\n            v_protein_record.\"Institution_id\"\n        );\n    END LOOP;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "CALL transform_protein_data('Frog', '30%', '50%', 1.1, 50.0);",
      "CALL transform_protein_data('urchin', '40%', '60%', 0.9, -20.0);",
      "CALL transform_protein_data('louse', '20%', '40%', 1.2, 100.0);",
      "CALL transform_protein_data('protein', '35%', '55%', 1.05, 25.0);",
      "CALL transform_protein_data('human', '25%', '45%', 0.95, -10.0);"
    ],
    "summary": "Create a PL/pgSQL procedure with parameters p_common_name_pattern (text), p_min_identity (text), p_max_identity (text), p_length_multiplier (real), and p_divergence_adjustment (real). For each protein where common_name contains p_common_name_pattern and its sequence identity (as integer) is between p_min_identity and p_max_identity, insert a new transformed protein record. The new record has: common_name prefixed with 'Transformed: ', the original protein_name, divergence increased by p_divergence_adjustment, accession_number prefixed with 'TRANS-', sequence_length multiplied by p_length_multiplier, and the original sequence_identity and Institution_id.",
    "natural_language": "For each protein where the common name contains the specified pattern and its sequence identity falls between the given minimum and maximum values, insert a new transformed protein record. Prefix the common name with 'Transformed: ', keep the original protein name, increase the divergence by the provided adjustment, prefix the accession number with 'TRANS-', multiply the sequence length by the given multiplier, and carry over the original sequence identity and Institution_id. Use the parameters p_common_name_pattern, p_min_identity, p_max_identity, p_length_multiplier, and p_divergence_adjustment.",
    "id": 285
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `aggregate_protein_metrics` that accepts five input parameters: `p_institution_id_list` of type `text`, `p_divergence_threshold` of type `real`, `p_length_threshold` of type `real`, `p_identity_threshold` of type `text`, and `p_output_prefix` of type `text`. The procedure's primary purpose is to process protein data for a list of specified institutions, calculate aggregate metrics for proteins meeting certain criteria, insert or update these aggregate metrics into the \"protein\" table, and then delete specific protein records that fall below a divergence threshold.\n\nFirst, the procedure declares three local variables: `v_institution_ids` as a `text` array to store individual institution IDs, `v_current_id` as `text` to hold the institution ID being processed in each iteration, and `v_avg_metrics` as a `RECORD` type to store the results of aggregate calculations.\n\nThe execution begins by converting the comma-separated string of institution IDs provided in `p_institution_id_list` into an array of `text` using the `string_to_array` function, with a comma (`,`) as the delimiter. This resulting array is assigned to `v_institution_ids`.\n\nNext, the procedure enters a `FOREACH` loop, iterating through each `v_current_id` in the `v_institution_ids` array.\n\nInside the loop, for each `v_current_id`, a `SELECT` statement is executed to calculate aggregate metrics from the \"protein\" table. This `SELECT` statement calculates the average of the \"divergence_from_human_lineage\" column, aliased as `avg_divergence`, the average of the \"sequence_length\" column, aliased as `avg_length`, and the total count of rows, aliased as `protein_count`. These calculated aggregate values are stored into the `v_avg_metrics` record variable. The selection of rows for these calculations is subject to several `WHERE` clause conditions:\n1. The \"Institution_id\" column must be equal to the `v_current_id` being processed in the current loop iteration.\n2. The \"divergence_from_human_lineage\" column must be strictly greater than the `p_divergence_threshold` input parameter.\n3. The \"sequence_length\" column must be strictly greater than the `p_length_threshold` input parameter.\n4. The numerical value derived from the \"sequence_identity_to_human_protein\" column must be strictly greater than the numerical value derived from the `p_identity_threshold` input parameter. For both \"sequence_identity_to_human_protein\" and `p_identity_threshold`, the percentage sign (`%`) is removed using the `REPLACE` function, and the resulting string is cast to an `integer` type before comparison.\n\nFollowing the `SELECT` statement, an `IF` conditional block checks if `v_avg_metrics.protein_count` is greater than 0. This condition ensures that an aggregate record is only created or updated if there were actual protein records meeting the specified criteria for the current institution.\n\nIf `v_avg_metrics.protein_count` is greater than 0, an `INSERT` statement is executed on the \"protein\" table. This `INSERT` statement attempts to add a new row with the following values:\n- \"common_name\": Constructed by concatenating `p_output_prefix`, the literal string ' Aggregate ', and `v_current_id`.\n- \"protein_name\": Constructed by concatenating the literal string 'Institution ', `v_current_id`, and the literal string ' Metrics'.\n- \"divergence_from_human_lineage\": Set to the `v_avg_metrics.avg_divergence` value.\n- \"accession_number\": Constructed by concatenating the literal string 'AGG-' and `v_current_id`.\n- \"sequence_length\": Set to the `v_avg_metrics.avg_length` value.\n- \"sequence_identity_to_human_protein\": Set to the literal string '100%'.\n- \"Institution_id\": Set to `v_current_id`.\n\nThis `INSERT` statement includes an `ON CONFLICT (\"common_name\") DO UPDATE SET` clause. This means if a row with the same \"common_name\" (which is derived from `p_output_prefix` and `v_current_id`) already exists in the \"protein\" table, instead of inserting a new row, the existing row will be updated. The update operation sets the following columns of the existing row to the values that would have been inserted:\n- \"protein_name\" is updated to `EXCLUDED.\"protein_name\"`.\n- \"divergence_from_human_lineage\" is updated to `EXCLUDED.\"divergence_from_human_lineage\"`.\n- \"accession_number\" is updated to `EXCLUDED.\"accession_number\"`.\n- \"sequence_length\" is updated to `EXCLUDED.\"sequence_length\"`.\n- \"sequence_identity_to_human_protein\" is updated to `EXCLUDED.\"sequence_identity_to_human_protein\"`.\n- \"Institution_id\" is updated to `EXCLUDED.\"Institution_id\"`.\n\nImmediately after the `INSERT` or `UPDATE` operation (if `v_avg_metrics.protein_count` was greater than 0), a `DELETE` statement is executed on the \"protein\" table. This `DELETE` statement removes rows that meet the following conditions:\n1. The \"Institution_id\" column must be equal to the `v_current_id` being processed.\n2. The \"divergence_from_human_lineage\" column must be less than or equal to the `p_divergence_threshold` input parameter.\n3. The \"common_name\" column must not be equal to the aggregate common name that was just inserted or updated (i.e., `p_output_prefix || ' Aggregate ' || v_current_id`). This condition prevents the newly created or updated aggregate record from being deleted.\n\nThe loop then continues to the next `v_current_id` in `v_institution_ids` until all institution IDs have been processed.\n\nFinally, after the `FOREACH` loop completes, the procedure concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE aggregate_protein_metrics(\n    IN p_institution_id_list text,\n    IN p_divergence_threshold real,\n    IN p_length_threshold real,\n    IN p_identity_threshold text,\n    IN p_output_prefix text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_institution_ids text[];\n    v_current_id text;\n    v_avg_metrics RECORD;\nBEGIN\n    v_institution_ids := string_to_array(p_institution_id_list, ',');\n    \n    FOREACH v_current_id IN ARRAY v_institution_ids\n    LOOP\n        SELECT \n            AVG(\"divergence_from_human_lineage\") as avg_divergence,\n            AVG(\"sequence_length\") as avg_length,\n            COUNT(*) as protein_count\n        INTO v_avg_metrics\n        FROM \"protein\"\n        WHERE \"Institution_id\" = v_current_id\n          AND \"divergence_from_human_lineage\" > p_divergence_threshold\n          AND \"sequence_length\" > p_length_threshold\n          AND REPLACE(\"sequence_identity_to_human_protein\", '%', '')::integer > \n              REPLACE(p_identity_threshold, '%', '')::integer;\n\n        IF v_avg_metrics.protein_count > 0 THEN\n            INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\")\n            VALUES (\n                p_output_prefix || ' Aggregate ' || v_current_id,\n                'Institution ' || v_current_id || ' Metrics',\n                v_avg_metrics.avg_divergence,\n                'AGG-' || v_current_id,\n                v_avg_metrics.avg_length,\n                '100%',\n                v_current_id\n            )\n            ON CONFLICT (\"common_name\") DO UPDATE SET\n                \"protein_name\" = EXCLUDED.\"protein_name\",\n                \"divergence_from_human_lineage\" = EXCLUDED.\"divergence_from_human_lineage\",\n                \"accession_number\" = EXCLUDED.\"accession_number\",\n                \"sequence_length\" = EXCLUDED.\"sequence_length\",\n                \"sequence_identity_to_human_protein\" = EXCLUDED.\"sequence_identity_to_human_protein\",\n                \"Institution_id\" = EXCLUDED.\"Institution_id\";\n            \n            DELETE FROM \"protein\"\n            WHERE \"Institution_id\" = v_current_id\n              AND \"divergence_from_human_lineage\" <= p_divergence_threshold\n              AND \"common_name\" != p_output_prefix || ' Aggregate ' || v_current_id;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "CALL aggregate_protein_metrics('0,1', 100.0, 500.0, '50%', 'Aggregated_Proteins');",
      "CALL aggregate_protein_metrics('2', 200.0, 1000.0, '60%', 'High_Divergence_Proteins');",
      "CALL aggregate_protein_metrics('0,1,2', 50.0, 200.0, '30%', 'All_Institutions_Low_Threshold');",
      "CALL aggregate_protein_metrics('1', 300.0, 1500.0, '70%', 'Institution1_Strict_Metrics');",
      "CALL aggregate_protein_metrics('0', 0.0, 0.0, '0%', 'Institution0_All_Proteins');"
    ],
    "summary": "Create a stored procedure named `aggregate_protein_metrics` that takes a comma-separated list of institution IDs, a divergence threshold, a length threshold, an identity threshold (as a percentage string), and an output prefix. For each institution, calculate the average divergence, average length, and count of proteins where divergence, length, and identity exceed their respective thresholds (converting the identity percentage to integer). If the count is greater than zero, insert or update a summary record in the protein table with a constructed common name, protein name, average values, a fixed '100%' identity, and an accession number. Then, delete all proteins for that institution where divergence is less than or equal to the threshold, excluding the newly created summary record.",
    "natural_language": "Create a stored procedure called `aggregate_protein_metrics` that takes in a list of institution IDs, some thresholds for divergence and length, a percentage for identity, and a prefix for output. For each institution, figure out the typical divergence and length, and see how many proteins are past those general thresholds, treating the identity percentage as a whole number. If you find a decent number of them, put a summary entry into the protein table with a made-up common name, protein name, the average figures, full identity, and an accession number. After that, clean up by removing the less divergent proteins for that place, but keep the new summary you just made.",
    "id": 286
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `analyze_subject_performance` that accepts three input parameters: `p_subject_id` of type `bigint`, `p_start_date` of type `timestamp with time zone`, and `p_end_date` of type `timestamp with time zone`. The purpose of this procedure is to analyze student performance for a specific subject within a given date range and then perform a conditional data manipulation operation based on the analysis.\n\nThe procedure begins by declaring three local variables: `v_pass_count` of type `integer` to store the number of passing test results, `v_fail_count` of type `integer` to store the number of failing test results, and `v_total_students` of type `integer` to store the count of unique students enrolled in the subject.\n\nThe first operation is to calculate the number of passing test results. This is achieved by executing a `SELECT COUNT(*)` statement. This query retrieves data from the `\"Student_Tests_Taken\"` table, aliased as `stt`. It then performs an `INNER JOIN` with the `\"Student_Course_Enrolment\"` table, aliased as `sce`, on the condition `stt.registration_id = sce.registration_id`. Subsequently, it performs another `INNER JOIN` with the `\"Courses\"` table, aliased as `c`, on the condition `sce.course_id = c.course_id`. The results are filtered using a `WHERE` clause: `c.subject_id` must be equal to the input parameter `p_subject_id`, `stt.date_test_taken` must fall `BETWEEN` the input parameters `p_start_date` and `p_end_date` (inclusive), and `stt.test_result` must be equal to the string literal 'Pass'. The resulting count is stored in the `v_pass_count` variable.\n\nThe second operation is to calculate the number of failing test results. This is also achieved by executing a `SELECT COUNT(*)` statement, which is structurally identical to the first query. It retrieves data from `\"Student_Tests_Taken\"` (`stt`), `INNER JOIN`s with `\"Student_Course_Enrolment\"` (`sce`) on `stt.registration_id = sce.registration_id`, and then `INNER JOIN`s with `\"Courses\"` (`c`) on `sce.course_id = c.course_id`. The filtering conditions in the `WHERE` clause are: `c.subject_id` must be equal to `p_subject_id`, `stt.date_test_taken` must be `BETWEEN` `p_start_date` and `p_end_date`, and `stt.test_result` must be equal to the string literal 'Fail'. The resulting count is stored in the `v_fail_count` variable.\n\nThe third operation is to calculate the total number of unique students enrolled in the specified subject within the given date range. This is done by executing a `SELECT COUNT(DISTINCT sce.student_id)` statement. This query retrieves data from the `\"Student_Course_Enrolment\"` table, aliased as `sce`. It then performs an `INNER JOIN` with the `\"Courses\"` table, aliased as `c`, on the condition `sce.course_id = c.course_id`. The results are filtered using a `WHERE` clause: `c.subject_id` must be equal to the input parameter `p_subject_id`, and `sce.date_of_enrolment` must fall `BETWEEN` the input parameters `p_start_date` and `p_end_date` (inclusive). The count of distinct `student_id` values is stored in the `v_total_students` variable.\n\nFollowing these calculations, the procedure executes a conditional block using an `IF` statement.\nIf the value of `v_total_students` is `>` 0 (meaning there was at least one student enrolled in the subject within the specified period), then an `INSERT` operation is performed. A new row is inserted into the `\"Subjects\"` table. The `subject_id` column is populated with the value of `p_subject_id + 1000`. The `subject_name` column is populated with a concatenated string literal 'Analysis_', followed by the `v_pass_count` converted to `text` using `CAST(v_pass_count AS text)`, followed by an underscore '_', followed by the `v_fail_count` converted to `text` using `CAST(v_fail_count AS text)`.\n\nOtherwise (if `v_total_students` is not `>` 0, meaning `v_total_students` is 0 or less), a `DELETE` operation is performed. Rows are deleted from the `\"Student_Tests_Taken\"` table. The `WHERE` clause for the `DELETE` statement specifies that `registration_id` must be `IN` the result set of a subquery. This subquery selects `sce.registration_id` from the `\"Student_Course_Enrolment\"` table, aliased as `sce`, `INNER JOIN`ed with the `\"Courses\"` table, aliased as `c`, on `sce.course_id = c.course_id`. The subquery's results are filtered where `c.subject_id` is equal to the input parameter `p_subject_id`. This effectively deletes all test records for students enrolled in the specified subject, regardless of the date range.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_subject_performance(\n    p_subject_id bigint,\n    p_start_date timestamp with time zone,\n    p_end_date timestamp with time zone\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_pass_count integer;\n    v_fail_count integer;\n    v_total_students integer;\nBEGIN\n    SELECT COUNT(*) INTO v_pass_count\n    FROM \"Student_Tests_Taken\" stt\n    INNER JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n    INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n    WHERE c.subject_id = p_subject_id\n    AND stt.date_test_taken BETWEEN p_start_date AND p_end_date\n    AND stt.test_result = 'Pass';\n    \n    SELECT COUNT(*) INTO v_fail_count\n    FROM \"Student_Tests_Taken\" stt\n    INNER JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n    INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n    WHERE c.subject_id = p_subject_id\n    AND stt.date_test_taken BETWEEN p_start_date AND p_end_date\n    AND stt.test_result = 'Fail';\n    \n    SELECT COUNT(DISTINCT sce.student_id) INTO v_total_students\n    FROM \"Student_Course_Enrolment\" sce\n    INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n    WHERE c.subject_id = p_subject_id\n    AND sce.date_of_enrolment BETWEEN p_start_date AND p_end_date;\n    \n    IF v_total_students > 0 THEN\n        INSERT INTO \"Subjects\" (subject_id, subject_name)\n        VALUES (p_subject_id + 1000, 'Analysis_' || CAST(v_pass_count AS text) || '_' || CAST(v_fail_count AS text));\n    ELSE\n        DELETE FROM \"Student_Tests_Taken\"\n        WHERE registration_id IN (\n            SELECT sce.registration_id\n            FROM \"Student_Course_Enrolment\" sce\n            INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n            WHERE c.subject_id = p_subject_id\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "CALL analyze_subject_performance(1, '2018-01-01 00:00:00+00', '2018-12-31 23:59:59+00');",
      "CALL analyze_subject_performance(2, '2017-10-01 00:00:00+08', '2018-03-31 23:59:59+08');",
      "CALL analyze_subject_performance(3, '2018-03-01 00:00:00+00', '2018-03-31 23:59:59+00');",
      "CALL analyze_subject_performance(1, '2017-09-01 00:00:00+08', '2017-11-30 23:59:59+08');",
      "CALL analyze_subject_performance(2, '2018-01-15 00:00:00+00', '2018-02-15 23:59:59+00');"
    ],
    "summary": "Create a stored procedure named `analyze_subject_performance` that takes a subject ID, a start date, and an end date. Count the number of 'Pass' and 'Fail' test results for that subject within the date range, and count the distinct students enrolled. If at least one student was enrolled, insert a new subject record with an ID offset by 1000 and a name containing the pass and fail counts. Otherwise, delete all test records for students enrolled in that subject.",
    "natural_language": "Alright, so we need a stored procedure called `analyze_subject_performance`. It's gotta take a subject ID, a start date, and an end date. Here's what it does: it counts up how many tests got a 'Pass' or 'Fail' for that subject between those dates, and also figures out how many different students were signed up. If there was at least one student enrolled, then we pop a new subject record into the database. This new record's ID should be the old one plus 1000, and its name should include the pass and fail counts we just tallied. But if nobody was enrolled at all, then we gotta clean house and delete all the test records for any students who were ever in that subject.",
    "id": 287
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_course_id of type bigint, p_new_subject_id of type bigint, and p_operation_mode of type text. The procedure performs a series of operations to synchronize course data based on the provided parameters. First, it calculates the number of students enrolled in the course identified by p_course_id by counting rows in the \"Student_Course_Enrolment\" table where the course_id matches p_course_id, storing the result in the variable v_student_count. Next, it calculates the number of test results associated with the course by joining the \"Student_Tests_Taken\" table with the \"Student_Course_Enrolment\" table on the registration_id column and filtering rows where the course_id matches p_course_id, storing the result in the variable v_test_results_count. It then checks if there is an author associated with the course by verifying the existence of a row in the \"Course_Authors_and_Tutors\" table joined with the \"Courses\" table on the author_id column, where the course_id matches p_course_id, storing the result in the boolean variable v_author_exists. Additionally, it checks if a subject with the ID p_new_subject_id exists in the \"Subjects\" table, storing the result in the boolean variable v_subject_exists. If no such subject exists, it inserts a new row into the \"Subjects\" table with the subject_id set to p_new_subject_id and the subject_name set to a concatenated string 'Sync_' followed by the p_course_id and p_operation_mode values. If the p_operation_mode is 'MIGRATE' and the number of students enrolled in the course (v_student_count) is greater than zero, it calculates a new course ID by finding the maximum course_id in the \"Courses\" table, adding one to it, and storing the result in the variable v_new_course_id. It then inserts a new row into the \"Courses\" table with the new course_id, the author_id and course details copied from the course identified by p_course_id, the subject_id set to p_new_subject_id, and the course_name appended with '_migrated'. Afterward, it deletes all rows from the \"Student_Tests_Taken\" table where the registration_id matches any registration_id in the \"Student_Course_Enrolment\" table for the course identified by p_course_id. If the p_operation_mode is 'CLEANUP' and the number of test results associated with the course (v_test_results_count) is zero, it deletes all rows from the \"Student_Course_Enrolment\" table where the course_id matches p_course_id and then deletes the corresponding row from the \"Courses\" table. If neither of these conditions is met, it checks if there is no author associated with the course (v_author_exists is false) and, if so, inserts a new row into the \"Course_Authors_and_Tutors\" table with an author_id set to p_course_id plus 500, default values for other columns, and an auto-generated login_name, password, and address.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_course_data(\n    p_course_id bigint,\n    p_new_subject_id bigint,\n    p_operation_mode text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_count integer;\n    v_test_results_count integer;\n    v_author_exists boolean;\n    v_new_course_id bigint;\n    v_subject_exists boolean;\nBEGIN\n    SELECT COUNT(*) INTO v_student_count\n    FROM \"Student_Course_Enrolment\"\n    WHERE course_id = p_course_id;\n    \n    SELECT COUNT(*) INTO v_test_results_count\n    FROM \"Student_Tests_Taken\" stt\n    INNER JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n    WHERE sce.course_id = p_course_id;\n    \n    SELECT EXISTS(SELECT 1 FROM \"Course_Authors_and_Tutors\" cat\n                 INNER JOIN \"Courses\" c ON cat.author_id = c.author_id\n                 WHERE c.course_id = p_course_id) INTO v_author_exists;\n    \n    SELECT EXISTS(SELECT 1 FROM \"Subjects\" WHERE subject_id = p_new_subject_id) INTO v_subject_exists;\n    \n    IF NOT v_subject_exists THEN\n        INSERT INTO \"Subjects\" (subject_id, subject_name)\n        VALUES (p_new_subject_id, 'Sync_' || CAST(p_course_id AS text) || '_' || p_operation_mode);\n    END IF;\n    \n    IF p_operation_mode = 'MIGRATE' AND v_student_count > 0 THEN\n        SELECT COALESCE(MAX(course_id), 0) + 1 INTO v_new_course_id FROM \"Courses\";\n        \n        INSERT INTO \"Courses\" (course_id, author_id, subject_id, course_name, course_description)\n        SELECT v_new_course_id, author_id, p_new_subject_id, course_name || '_migrated', course_description\n        FROM \"Courses\"\n        WHERE course_id = p_course_id;\n        \n        DELETE FROM \"Student_Tests_Taken\"\n        WHERE registration_id IN (\n            SELECT registration_id FROM \"Student_Course_Enrolment\"\n            WHERE course_id = p_course_id\n        );\n    ELSIF p_operation_mode = 'CLEANUP' AND v_test_results_count = 0 THEN\n        DELETE FROM \"Student_Course_Enrolment\"\n        WHERE course_id = p_course_id;\n        \n        DELETE FROM \"Courses\"\n        WHERE course_id = p_course_id;\n    ELSE\n        IF NOT v_author_exists THEN\n            INSERT INTO \"Course_Authors_and_Tutors\" (author_id, author_tutor_ATB, login_name, password, personal_name, middle_name, family_name, gender_mf, address_line_1)\n            VALUES (p_course_id + 500, '777', 'auto_' || CAST(p_course_id AS text), 'auto_pass', 'Auto', 'Generated', 'Author', '0', 'Auto-generated address');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "CALL synchronize_course_data(1, 101, 'MIGRATE');",
      "CALL synchronize_course_data(2, 102, 'CLEANUP');",
      "CALL synchronize_course_data(3, 103, 'UPDATE');",
      "CALL synchronize_course_data(4, 104, 'MIGRATE');",
      "CALL synchronize_course_data(5, 105, 'CLEANUP');"
    ],
    "summary": "Create a stored procedure that takes a course ID, a new subject ID, and an operation mode ('MIGRATE' or 'CLEANUP'). Count the students enrolled and test results for the course, and check if an author and the new subject exist. If the subject does not exist, create it. If the mode is 'MIGRATE' and there are enrolled students, create a new migrated course with the new subject ID, copy details from the old course, and delete its test records. If the mode is 'CLEANUP' and there are no test results, delete the course's enrolments and the course itself. Otherwise, if no author exists for the course, create a new author record with a derived ID.",
    "natural_language": "Write a stored procedure that accepts a course ID, a new subject ID, and an operation mode ('MIGRATE' or 'CLEANUP'). Count the enrolled students and test results for the course, and verify the existence of an author and the new subject. If the subject does not exist, create it. For 'MIGRATE' mode with enrolled students, create a new migrated course under the new subject ID, copy the old course's details, and remove its test records. For 'CLEANUP' mode with no test results, delete the course's enrolments and then the course itself. Otherwise, if the course lacks an author, create a new author record using a derived ID.",
    "id": 288
  },
  {
    "ir": "Write a PLpgSQL stored procedure that iterates over all records in the architect table, identified by the id column, and for each architect, calculates the total length of all bridges associated with that architect (using the length_meters column in the bridge table), the count of bridges, and the average length of those bridges. If the architect has no associated bridges, a notice is raised indicating the architect's id. If the architect has one bridge, the procedure updates the length_meters column of all bridges associated with that architect by multiplying the current value by 1.05. If the architect has two bridges, the procedure updates the length_meters column of all bridges associated with that architect by multiplying the current value by 1.10. If the architect has three bridges, the procedure updates the length_meters column of all bridges associated with that architect by multiplying the current value by 1.15. If the architect has more than three bridges and the average length of those bridges is less than 50 meters, the procedure updates the length_meters column of all bridges associated with that architect by multiplying the current value by 1.20. If the architect has more than three bridges and the average length of those bridges is 50 meters or greater, the procedure updates the length_meters column of all bridges associated with that architect by multiplying the current value by 1.25. The procedure uses a loop to process each architect record, and within the loop, it performs a SELECT query on the bridge table to calculate the total length, count, and average length of bridges for the current architect, using the architect_id column to filter the bridges. The COALESCE function is used to handle null values for the total length and average length calculations, ensuring that zero is returned if no bridges exist for the architect. Conditional statements are used to determine the appropriate update logic based on the count of bridges and the average length. All updates are performed on the bridge table, targeting rows where the architect_id matches the current architect's id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_bridge_lengths_by_architect()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    arch_record RECORD;\n    total_length REAL;\n    avg_length REAL;\n    bridge_count INTEGER;\nBEGIN\n    FOR arch_record IN SELECT \"id\" FROM \"architect\" LOOP\n        SELECT COALESCE(SUM(\"length_meters\"), 0), COUNT(*), COALESCE(AVG(\"length_meters\"), 0) \n        INTO total_length, bridge_count, avg_length \n        FROM \"bridge\" \n        WHERE \"architect_id\" = (arch_record.\"id\")::integer;\n        \n        IF bridge_count = 0 THEN\n            RAISE NOTICE 'Architect % has no bridges', arch_record.\"id\";\n        ELSIF bridge_count = 1 THEN\n            UPDATE \"bridge\" SET \"length_meters\" = \"length_meters\" * 1.05 WHERE \"architect_id\" = (arch_record.\"id\")::integer;\n        ELSIF bridge_count = 2 THEN\n            UPDATE \"bridge\" SET \"length_meters\" = \"length_meters\" * 1.10 WHERE \"architect_id\" = (arch_record.\"id\")::integer;\n        ELSIF bridge_count = 3 THEN\n            UPDATE \"bridge\" SET \"length_meters\" = \"length_meters\" * 1.15 WHERE \"architect_id\" = (arch_record.\"id\")::integer;\n        ELSIF bridge_count > 3 AND avg_length < 50 THEN\n            UPDATE \"bridge\" SET \"length_meters\" = \"length_meters\" * 1.20 WHERE \"architect_id\" = (arch_record.\"id\")::integer;\n        ELSE\n            UPDATE \"bridge\" SET \"length_meters\" = \"length_meters\" * 1.25 WHERE \"architect_id\" = (arch_record.\"id\")::integer;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL update_bridge_lengths_by_architect();"
    ],
    "summary": "Create a stored procedure that loops through all architects. For each, calculate the total length, count, and average length of their associated bridges. If the count is zero, raise a notice. If the count is one, two, or three, update all their bridges by multiplying the length by 1.05, 1.10, or 1.15 respectively. If the count is greater than three, update all their bridges by multiplying the length by 1.20 if the average length is less than 50 meters, or by 1.25 otherwise.",
    "natural_language": "How can I create a stored procedure that iterates over each architect, computes the total length, count, and average length of their bridges, and then conditionally updates bridge lengths based on the count and average? For zero bridges, a notice should be raised. For one, two, or three bridges, lengths should be multiplied by 1.05, 1.10, or 1.15, respectively. For more than three bridges, lengths should be multiplied by 1.20 if the average is under 50 meters, or by 1.25 otherwise.",
    "id": 289
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `process_architect_contributions` that takes no parameters. This procedure is designed to iterate through each architect record in the `\"architect\"` table and, based on their contributions to `\"bridge\"` and `\"mill\"` projects, perform specific updates or deletions on their corresponding record in the `\"architect\"` table. The procedure begins by declaring four local variables: `arch_id` of type `TEXT` to store the architect's identifier, `bridge_num` of type `INTEGER` to count the number of bridges an architect has designed, `mill_num` of type `INTEGER` to count the number of mills an architect has designed, and `total_works` of type `INTEGER` to store the sum of bridges and mills designed by an architect. The core logic is encapsulated within a `FOR` loop that iterates over each `id` from the `\"architect\"` table. For each `arch_id` retrieved from the `\"architect\"` table, the procedure first executes a `SELECT COUNT(*)` query on the `\"bridge\"` table to count the number of records where the `\"architect_id\"` column matches the current `arch_id` (after casting `arch_id` from `TEXT` to `INTEGER`), storing this count in the `bridge_num` variable. Immediately following this, another `SELECT COUNT(*)` query is executed on the `\"mill\"` table to count the number of records where the `\"architect_id\"` column matches the current `arch_id` (after casting `arch_id` from `TEXT` to `INTEGER`), storing this count in the `mill_num` variable. The `total_works` variable is then calculated as the sum of `bridge_num` and `mill_num`. A series of conditional statements (`IF`, `ELSIF`, `ELSE`) then determine the action to be taken for the current architect:\n1. If `total_works` is equal to `0`, meaning the architect has not contributed to any bridges or mills, a `DELETE` operation is performed on the `\"architect\"` table, removing the record where the `\"id\"` column matches the current `arch_id`.\n2. If `total_works` is equal to `1` AND `bridge_num` is equal to `1`, meaning the architect has contributed to exactly one bridge and no mills, an `UPDATE` operation is performed on the `\"architect\"` table. The `\"name\"` column for the architect's record (identified by `id` matching `arch_id`) is updated to its uppercase version using the `UPPER()` function.\n3. If `total_works` is equal to `1` AND `mill_num` is equal to `1`, meaning the architect has contributed to exactly one mill and no bridges, an `UPDATE` operation is performed on the `\"architect\"` table. The `\"name\"` column for the architect's record (identified by `id` matching `arch_id`) is updated to its lowercase version using the `LOWER()` function.\n4. If `total_works` is equal to `2` AND `bridge_num` is equal to `2`, meaning the architect has contributed to exactly two bridges and no mills, an `UPDATE` operation is performed on the `\"architect\"` table. The `\"nationality\"` column for the architect's record (identified by `id` matching `arch_id`) is updated by concatenating the string ' (Bridge Expert)' to its existing value.\n5. If `total_works` is equal to `2` AND `mill_num` is equal to `2`, meaning the architect has contributed to exactly two mills and no bridges, an `UPDATE` operation is performed on the `\"architect\"` table. The `\"nationality\"` column for the architect's record (identified by `id` matching `arch_id`) is updated by concatenating the string ' (Mill Expert)' to its existing value.\n6. In all other cases (the `ELSE` block), an `UPDATE` operation is performed on the `\"architect\"` table. The `\"nationality\"` column for the architect's record (identified by `id` matching `arch_id`) is updated by concatenating the string ' (Multi-talented)' to its existing value.\nThe loop continues until all architects in the `\"architect\"` table have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_architect_contributions()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    arch_id TEXT;\n    bridge_num INTEGER;\n    mill_num INTEGER;\n    total_works INTEGER;\nBEGIN\n    FOR arch_id IN SELECT \"id\" FROM \"architect\" LOOP\n        SELECT COUNT(*) INTO bridge_num FROM \"bridge\" WHERE \"architect_id\" = arch_id::INTEGER;\n        SELECT COUNT(*) INTO mill_num FROM \"mill\" WHERE \"architect_id\" = arch_id::INTEGER;\n        total_works := bridge_num + mill_num;\n        IF total_works = 0 THEN\n            DELETE FROM \"architect\" WHERE \"id\" = arch_id;\n        ELSIF total_works = 1 AND bridge_num = 1 THEN\n            UPDATE \"architect\" SET \"name\" = UPPER(\"name\") WHERE \"id\" = arch_id;\n        ELSIF total_works = 1 AND mill_num = 1 THEN\n            UPDATE \"architect\" SET \"name\" = LOWER(\"name\") WHERE \"id\" = arch_id;\n        ELSIF total_works = 2 AND bridge_num = 2 THEN\n            UPDATE \"architect\" SET \"nationality\" = \"nationality\" || ' (Bridge Expert)' WHERE \"id\" = arch_id;\n        ELSIF total_works = 2 AND mill_num = 2 THEN\n            UPDATE \"architect\" SET \"nationality\" = \"nationality\" || ' (Mill Expert)' WHERE \"id\" = arch_id;\n        ELSE\n            UPDATE \"architect\" SET \"nationality\" = \"nationality\" || ' (Multi-talented)' WHERE \"id\" = arch_id;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL process_architect_contributions();"
    ],
    "summary": "Create a stored procedure named `process_architect_contributions` with no parameters. For each architect, count their bridges and mills. Calculate the total works. If total works is zero, delete the architect. If total works is one and it's a bridge, update the architect's name to uppercase. If total works is one and it's a mill, update the name to lowercase. If total works is two and both are bridges, append ' (Bridge Expert)' to their nationality. If total works is two and both are mills, append ' (Mill Expert)' to their nationality. In all other cases, append ' (Multi-talented)' to their nationality.",
    "natural_language": "Please construct a stored procedure designated as `process_architect_contributions` that accepts no parameters. For every architect record, compute the number of bridges and mills associated with them, and derive the total count of these works. Should the total be zero, the corresponding architect entry is to be deleted. If the total is precisely one and the work is a bridge, the architect's name must be updated to uppercase characters. Conversely, if the total is one and the work is a mill, the name should be updated to lowercase. In instances where the total is two and both works are bridges, the string ' (Bridge Expert)' shall be appended to the architect's nationality. If the total is two and both are mills, the string ' (Mill Expert)' is to be appended. For all remaining cases, please append the string ' (Multi-talented)' to the nationality.",
    "id": 290
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `analyze_location_patterns` that takes no input parameters. This procedure is designed to analyze location data from two tables, `\"bridge\"` and `\"mill\"`, and then insert new records into the `\"bridge\"` table based on this analysis.\n\nThe procedure begins by declaring several local variables: `loc_record` of type `RECORD` to hold a row from the location iteration, `bridge_cnt` of type `INTEGER` to store the count of bridges at a specific location, `mill_cnt` of type `INTEGER` to store the count of mills at a specific location, and `loc_type` of type `TEXT` to store the categorized type of a location.\n\nThe core logic of the procedure involves iterating through a set of distinct locations. This set of distinct locations is generated by first selecting all unique values from the `\"location\"` column of the `\"bridge\"` table, then selecting all unique values from the `\"location\"` column of the `\"mill\"` table, and finally combining these two sets of unique locations using a `UNION` operation to ensure only distinct locations are considered.\n\nFor each `loc_record` obtained from this iteration (where `loc_record.\"location\"` represents the current distinct location being processed):\n1. The procedure queries the `\"bridge\"` table to count the number of rows where the `\"location\"` column matches the `loc_record.\"location\"`. This count is then stored in the `bridge_cnt` variable.\n2. Subsequently, the procedure queries the `\"mill\"` table to count the number of rows where the `\"location\"` column matches the `loc_record.\"location\"`. This count is then stored in the `mill_cnt` variable.\n3. A series of conditional checks are then performed to determine the `loc_type` based on the values of `bridge_cnt` and `mill_cnt`:\n    - If `bridge_cnt` is greater than 0 AND `mill_cnt` is greater than 0, then `loc_type` is set to the string 'Mixed'.\n    - ELSE IF `bridge_cnt` is greater than 2, then `loc_type` is set to the string 'Bridge Hub'.\n    - ELSE IF `mill_cnt` is greater than 2, then `loc_type` is set to the string 'Mill Hub'.\n    - ELSE IF `bridge_cnt` is equal to 1 AND `mill_cnt` is equal to 0, then `loc_type` is set to the string 'Single Bridge'.\n    - ELSE IF `mill_cnt` is equal to 1 AND `bridge_cnt` is equal to 0, then `loc_type` is set to the string 'Single Mill'.\n    - In all other cases (ELSE), `loc_type` is set to the string 'Other'.\n4. Finally, a new row is inserted into the `\"bridge\"` table with the following column values:\n    - `\"architect_id\"` is set to the integer value 1.\n    - `\"name\"` is set to the string 'Analysis Marker'.\n    - `\"location\"` is set to the current `loc_record.\"location\"`.\n    - `\"length_meters\"` is calculated as `bridge_cnt` multiplied by 10.0.\n    - `\"length_feet\"` is calculated as `mill_cnt` multiplied by 10.0.\n\nThis process repeats for every distinct location identified in the initial `FOR` loop.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_location_patterns()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    loc_record RECORD;\n    bridge_cnt INTEGER;\n    mill_cnt INTEGER;\n    loc_type TEXT;\nBEGIN\n    FOR loc_record IN SELECT DISTINCT \"location\" FROM \"bridge\" UNION SELECT DISTINCT \"location\" FROM \"mill\" LOOP\n        SELECT COUNT(*) INTO bridge_cnt FROM \"bridge\" WHERE \"location\" = loc_record.\"location\";\n        SELECT COUNT(*) INTO mill_cnt FROM \"mill\" WHERE \"location\" = loc_record.\"location\";\n        IF bridge_cnt > 0 AND mill_cnt > 0 THEN\n            loc_type := 'Mixed';\n        ELSIF bridge_cnt > 2 THEN\n            loc_type := 'Bridge Hub';\n        ELSIF mill_cnt > 2 THEN\n            loc_type := 'Mill Hub';\n        ELSIF bridge_cnt = 1 AND mill_cnt = 0 THEN\n            loc_type := 'Single Bridge';\n        ELSIF mill_cnt = 1 AND bridge_cnt = 0 THEN\n            loc_type := 'Single Mill';\n        ELSE\n            loc_type := 'Other';\n        END IF;\n        INSERT INTO \"bridge\" (\"architect_id\", \"name\", \"location\", \"length_meters\", \"length_feet\") VALUES (1, 'Analysis Marker', loc_record.\"location\", bridge_cnt * 10.0, mill_cnt * 10.0);\n    END LOOP;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL analyze_location_patterns();"
    ],
    "summary": "Create a stored procedure named `analyze_location_patterns` with no parameters. For each distinct location found in the `bridge` and `mill` tables, count the bridges and mills at that location. Categorize the location type based on these counts (e.g., 'Mixed', 'Bridge Hub'). Then, insert a new record into the `bridge` table with the location, its type, and calculated lengths based on the counts.",
    "natural_language": "Create procedure `analyze_location_patterns`. For each unique location in `bridge` and `mill` tables, count bridges and mills there. Categorize the type (e.g., 'Mixed'). Insert a new record into `bridge` with the location, its type, and lengths derived from the counts.",
    "id": 291
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `adjust_structures_by_gender` that takes no input parameters. This procedure is designed to iterate through distinct gender values found in the `architect` table and, for each gender, calculate average structural properties and then apply an adjustment factor to the `length_meters` of bridges associated with architects of that gender.\n\nThe procedure begins by declaring several local variables:\n- `gender_record`: A `RECORD` type variable used to hold the current distinct gender value being processed during the loop.\n- `avg_bridge_len`: A `REAL` type variable to store the calculated average length of bridges.\n- `avg_mill_year`: An `INTEGER` type variable to store the calculated average built year of mills.\n- `adjustment`: A `REAL` type variable to store the calculated adjustment factor.\n\nThe core logic of the procedure is encapsulated within a `FOR` loop. This loop iterates over each distinct value present in the `gender` column of the `architect` table. For each `gender_record` obtained from this iteration:\n\n1.  It calculates the average length of bridges (`avg_bridge_len`). This is achieved by executing a `SELECT` statement that computes the `AVG` of the `length_meters` column from the `bridge` table. This calculation is performed for bridges (`b`) that are linked to architects (`a`) where the `architect_id` in the `bridge` table matches the `id` (cast to `INTEGER`) in the `architect` table, and the `gender` of the architect matches the `gender` value currently held in `gender_record`. The result is stored in the `avg_bridge_len` variable.\n\n2.  It calculates the average built year of mills (`avg_mill_year`). This is achieved by executing a `SELECT` statement that computes the `AVG` of the `built_year` column from the `mill` table. This calculation is performed for mills (`m`) that are linked to architects (`a`) where the `architect_id` in the `mill` table matches the `id` (cast to `INTEGER`) in the `architect` table, and the `gender` of the architect matches the `gender` value currently held in `gender_record`. The result is stored in the `avg_mill_year` variable.\n\n3.  It then enters a series of conditional statements (`IF...ELSIF...ELSE`) to determine the `adjustment` factor based on the current `gender` and the calculated average values:\n    *   If the `gender` in `gender_record` is exactly 'male' AND the `avg_bridge_len` is greater than 80, then `adjustment` is set to 0.9.\n    *   Else if the `gender` in `gender_record` is exactly 'male' AND the `avg_bridge_len` is less than or equal to 80, then `adjustment` is set to 1.1.\n    *   Else if the `gender` in `gender_record` is exactly 'female' AND the `avg_mill_year` is greater than 1850, then `adjustment` is set to 0.85.\n    *   Else if the `gender` in `gender_record` is exactly 'female' AND the `avg_mill_year` is less than or equal to 1850, then `adjustment` is set to 1.15.\n    *   Else if the `gender` in `gender_record` is `NULL`, then `adjustment` is set to 1.0.\n    *   In all other cases (i.e., if the gender is not 'male', 'female', or `NULL`), `adjustment` is set to 1.05.\n\n4.  Finally, it performs an `UPDATE` operation on the `bridge` table. For all bridges (`b`) where the `architect_id` matches the `id` (cast to `INTEGER`) of an architect (`a`) and the `gender` of that architect matches the `gender` value currently held in `gender_record`, the `length_meters` column of these bridges is updated by multiplying its current value by the calculated `adjustment` factor.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_structures_by_gender()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    gender_record RECORD;\n    avg_bridge_len REAL;\n    avg_mill_year INTEGER;\n    adjustment REAL;\nBEGIN\n    FOR gender_record IN SELECT DISTINCT \"gender\" FROM \"architect\" LOOP\n        SELECT AVG(b.\"length_meters\") INTO avg_bridge_len FROM \"bridge\" b JOIN \"architect\" a ON b.\"architect_id\" = a.\"id\"::INTEGER WHERE a.\"gender\" = gender_record.\"gender\";\n        SELECT AVG(m.\"built_year\") INTO avg_mill_year FROM \"mill\" m JOIN \"architect\" a ON m.\"architect_id\" = a.\"id\"::INTEGER WHERE a.\"gender\" = gender_record.\"gender\";\n        IF gender_record.\"gender\" = 'male' AND avg_bridge_len > 80 THEN\n            adjustment := 0.9;\n        ELSIF gender_record.\"gender\" = 'male' AND avg_bridge_len <= 80 THEN\n            adjustment := 1.1;\n        ELSIF gender_record.\"gender\" = 'female' AND avg_mill_year > 1850 THEN\n            adjustment := 0.85;\n        ELSIF gender_record.\"gender\" = 'female' AND avg_mill_year <= 1850 THEN\n            adjustment := 1.15;\n        ELSIF gender_record.\"gender\" IS NULL THEN\n            adjustment := 1.0;\n        ELSE\n            adjustment := 1.05;\n        END IF;\n        UPDATE \"bridge\" b SET \"length_meters\" = \"length_meters\" * adjustment FROM \"architect\" a WHERE b.\"architect_id\" = a.\"id\"::INTEGER AND a.\"gender\" = gender_record.\"gender\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL adjust_structures_by_gender();"
    ],
    "summary": "Create a stored procedure named `adjust_structures_by_gender` with no parameters. For each distinct gender in the `architect` table, calculate the average bridge length and average mill built year for architects of that gender. Determine an adjustment factor based on the gender and these averages. Then, update the `length_meters` for all bridges associated with architects of that gender by multiplying by the adjustment factor.",
    "natural_language": "How can I create a stored procedure called `adjust_structures_by_gender` with no parameters that, for each distinct gender in the `architect` table, calculates the average bridge length and average mill built year, determines an adjustment factor based on that gender and the averages, and then updates the `length_meters` for all bridges linked to architects of that gender by multiplying by the factor?",
    "id": 292
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named update_player_team_based_on_age that accepts two input parameters: an integer parameter named min_age and a text parameter named new_team, and performs an update operation on the player table, specifically modifying the value of the column named \"Team\" to the value supplied in the new_team parameter for every row in the table where the value in the column named \"Age\" is greater than or equal to the value supplied in the min_age parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_player_team_based_on_age(IN min_age INTEGER, IN new_team TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE player\n    SET \"Team\" = new_team\n    WHERE \"Age\" >= min_age;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school"
    ],
    "call_sqls": [
      "CALL update_player_team_based_on_age(15, 'New Team A');",
      "CALL update_player_team_based_on_age(14, 'New Team B');",
      "CALL update_player_team_based_on_age(16, 'New Team C');",
      "CALL update_player_team_based_on_age(10, 'Junior League');",
      "CALL update_player_team_based_on_age(20, 'Senior League');"
    ],
    "summary": "Create a stored procedure named `update_player_team_based_on_age` that accepts `min_age` (INTEGER) and `new_team` (TEXT) parameters. Update the `player` table, setting the \"Team\" column to `new_team` for all rows where the \"Age\" column is greater than or equal to `min_age`.",
    "natural_language": "Write a stored procedure called `update_player_team_based_on_age` that takes a `min_age` (INTEGER) and a `new_team` (TEXT) as inputs. It should adjust the `player` table by changing the \"Team\" to the provided `new_team` for those players whose \"Age\" is around or above the specified `min_age` threshold.",
    "id": 293
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three input parameters: school_name of type TEXT, min_age of type INTEGER, and new_team of type TEXT. The procedure updates the \"Team\" column in the player table to the value of new_team for all rows where the \"School_ID\" column matches any \"School_ID\" from the school table that corresponds to the school_name parameter, and where the \"Age\" column in the player table is greater than or equal to the min_age parameter. Specifically, the procedure first identifies the relevant \"School_ID\" values by performing a SELECT operation on the school table, filtering rows where the \"School\" column matches the school_name parameter. Then, it uses these \"School_ID\" values in a WHERE condition to update the \"Team\" column in the player table for rows that also satisfy the condition of having an \"Age\" value greater than or equal to the min_age parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_team_based_on_school_and_age(IN school_name TEXT, IN min_age INTEGER, IN new_team TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE player\n    SET \"Team\" = new_team\n    WHERE \"School_ID\" IN (\n        SELECT \"School_ID\"\n        FROM school\n        WHERE \"School\" = school_name\n    ) AND \"Age\" >= min_age;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school"
    ],
    "call_sqls": [
      "CALL assign_team_based_on_school_and_age('St Aloysius'' College', 15, 'New Team A');",
      "CALL assign_team_based_on_school_and_age('Barker College', 14, 'New Team B');",
      "CALL assign_team_based_on_school_and_age('Cranbrook School', 16, 'New Team C');",
      "CALL assign_team_based_on_school_and_age('St Aloysius'' College', 10, 'Junior Team');",
      "CALL assign_team_based_on_school_and_age('Barker College', 20, 'Senior Team');"
    ],
    "summary": "Create a stored procedure that accepts `school_name` (TEXT), `min_age` (INTEGER), and `new_team` (TEXT) parameters. Update the `player` table, setting the \"Team\" column to `new_team` for all players whose \"School_ID\" matches the school with the given `school_name` and whose \"Age\" is greater than or equal to `min_age`.",
    "natural_language": "Update player team to new_team where school matches school_name and age >= min_age.",
    "id": 294
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_teacher_hometown that accepts two input parameters: an integer parameter named teacher_id to identify a teacher record, and a text parameter named new_hometown to specify a new hometown value. The procedure first checks for the existence of a record in the \"teacher\" table where the \"Teacher_ID\" column matches the provided teacher_id parameter. If such a record exists, it performs an update operation on the \"teacher\" table, setting the \"Hometown\" column for that specific record to the trimmed version of the new_hometown parameter, where the TRIM function removes leading and trailing spaces from the input string. If no record with the matching \"Teacher_ID\" is found, the procedure executes an insert operation into the \"teacher\" table, creating a new row with the provided teacher_id for the \"Teacher_ID\" column, the string literal 'Unknown' for the \"Name\" column, the string literal 'Unknown' for the \"Age\" column, and the trimmed version of new_hometown for the \"Hometown\" column. If neither the existence nor the non-existence condition is met, which is logically impossible in this flow, the procedure's ELSE block executes a delete operation on the \"teacher\" table, removing any row where the \"Teacher_ID\" column equals the provided teacher_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_teacher_hometown(IN teacher_id integer, IN new_hometown text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"teacher\" WHERE \"Teacher_ID\" = teacher_id) THEN\n        UPDATE \"teacher\"\n        SET \"Hometown\" = TRIM(new_hometown)\n        WHERE \"Teacher_ID\" = teacher_id;\n    ELSIF NOT EXISTS (SELECT 1 FROM \"teacher\" WHERE \"Teacher_ID\" = teacher_id) THEN\n        INSERT INTO \"teacher\" (\"Teacher_ID\", \"Name\", \"Age\", \"Hometown\")\n        VALUES (teacher_id, 'Unknown', 'Unknown', TRIM(new_hometown));\n    ELSE\n        DELETE FROM \"teacher\" WHERE \"Teacher_ID\" = teacher_id;\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL update_teacher_hometown(1, 'Manchester');",
      "CALL update_teacher_hometown(5, 'London');",
      "CALL update_teacher_hometown(3, 'Birmingham');",
      "CALL update_teacher_hometown(10, 'Liverpool');",
      "CALL update_teacher_hometown(2, 'Leeds');"
    ],
    "summary": "Create a stored procedure named `update_teacher_hometown` that accepts `teacher_id` (INTEGER) and `new_hometown` (TEXT) parameters. If a teacher with the given ID exists, update their \"Hometown\" to the trimmed `new_hometown`. If not, insert a new teacher record with the given ID, 'Unknown' for name and age, and the trimmed hometown as the hometown.",
    "natural_language": "Construct a stored procedure, which we shall name `update_teacher_hometown`, that is designed to receive two distinct input parameters: a `teacher_id` of type INTEGER and a `new_hometown` of type TEXT. The procedure should first check, in a detailed manner, whether a teacher record corresponding to the provided identifier already exists within the database. If such a teacher is indeed found, then the procedure must meticulously update their \"Hometown\" field, carefully applying a trim function to the supplied `new_hometown` value to remove any extraneous whitespace. Conversely, if the search concludes that no teacher with that specific ID is present, the procedure must comprehensively insert a brand new teacher record. This new entry should use the given ID for the teacher_id, assign the placeholder values 'Unknown' for both the name and age columns, and set the hometown column to the neatly trimmed version of the `new_hometown` parameter.",
    "id": 295
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two input parameters, teacher_id of type integer and grade of type integer, and performs conditional operations on the teacher and course_arrange tables. First, it checks if a row exists in the teacher table where the Teacher_ID column matches the value of teacher_id. If such a row exists, it updates the Grade column in the course_arrange table to the value of grade for all rows where the Teacher_ID column matches teacher_id. If no row exists in the teacher table with the specified Teacher_ID and no row exists in the course_arrange table where the Teacher_ID column matches teacher_id, it inserts a new row into the course_arrange table with the values 1 for the Course_ID column, teacher_id for the Teacher_ID column, and grade for the Grade column. If neither of the above conditions is met, meaning a row exists in the course_arrange table with the specified Teacher_ID but no corresponding row exists in the teacher table, it deletes all rows from the course_arrange table where the Teacher_ID column matches teacher_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_grade_to_teacher(IN teacher_id integer, IN grade integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"teacher\" WHERE \"Teacher_ID\" = teacher_id) THEN\n        UPDATE \"course_arrange\"\n        SET \"Grade\" = grade\n        WHERE \"Teacher_ID\" = teacher_id;\n    ELSIF NOT EXISTS (SELECT 1 FROM \"course_arrange\" WHERE \"Teacher_ID\" = teacher_id) THEN\n        INSERT INTO \"course_arrange\" (\"Course_ID\", \"Teacher_ID\", \"Grade\")\n        VALUES (1, teacher_id, grade);\n    ELSE\n        DELETE FROM \"course_arrange\" WHERE \"Teacher_ID\" = teacher_id;\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL assign_grade_to_teacher(1, 4);",
      "CALL assign_grade_to_teacher(2, 5);",
      "CALL assign_grade_to_teacher(3, 3);",
      "CALL assign_grade_to_teacher(5, 2);",
      "CALL assign_grade_to_teacher(6, 1);"
    ],
    "summary": "Create a stored procedure that accepts teacher_id (integer) and grade (integer). If the teacher exists, update all course_arrange rows for that teacher with the grade. If the teacher does not exist and the teacher has no course_arrange records, insert a new course_arrange row (Course_ID=1, Teacher_ID=teacher_id, Grade=grade). If the teacher does not exist but has course_arrange records, delete all course_arrange rows for that teacher.",
    "natural_language": "Update course_arrange grade for a teacher. If teacher missing and has no records, insert new row. If teacher missing but has records, delete them.",
    "id": 296
  },
  {
    "ir": "Write a PLpgSQL stored procedure that operates on the \"music_festival\" table and performs conditional updates or deletions based on the count of rows where the \"Result\" column has the value 'Nominated'. The procedure begins by declaring a local variable named festival_count of type INTEGER, which is used to store the count of rows meeting the specified condition. It then executes a SELECT statement to count the number of rows in the \"music_festival\" table where the \"Result\" column equals 'Nominated' and stores this count in the festival_count variable. Next, the procedure evaluates the value of festival_count using an IF-ELSIF-ELSE conditional structure. If festival_count is greater than 10, the procedure updates the \"music_festival\" table by setting the \"Result\" column to 'Awarded' for all rows where the \"Result\" column equals 'Nominated' and the \"Volume\" column has a value greater than 2. If festival_count is between 5 and 10 (inclusive), the procedure updates the \"music_festival\" table by setting the \"Result\" column to 'Pending' for all rows where the \"Result\" column equals 'Nominated'. If festival_count is less than 5, the procedure deletes all rows from the \"music_festival\" table where the \"Result\" column equals 'Nominated'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_music_festival_results()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    festival_count INTEGER;\nBEGIN\n    SELECT COUNT(\"ID\") INTO festival_count FROM \"music_festival\" WHERE \"Result\" = 'Nominated';\n    IF festival_count > 10 THEN\n        UPDATE \"music_festival\"\n        SET \"Result\" = 'Awarded'\n        WHERE \"Result\" = 'Nominated' AND \"Volume\" > 2;\n    ELSIF festival_count BETWEEN 5 AND 10 THEN\n        UPDATE \"music_festival\"\n        SET \"Result\" = 'Pending'\n        WHERE \"Result\" = 'Nominated';\n    ELSE\n        DELETE FROM \"music_festival\"\n        WHERE \"Result\" = 'Nominated';\n    END IF;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL update_music_festival_results();"
    ],
    "summary": "Create a stored procedure for the music_festival table. Count rows where Result='Nominated'. If count > 10, update rows with Result='Nominated' and Volume>2 to Result='Awarded'. If count between 5 and 10 (inclusive), update all rows with Result='Nominated' to Result='Pending'. If count < 5, delete all rows where Result='Nominated'.",
    "natural_language": "Create a stored procedure for the music_festival table. If there are quite a few rows with a Result of 'Nominated', say more than a handful, then update those that are also fairly loud to 'Awarded'. If the number is around a moderate amount, between a few and several, then change all those 'Nominated' entries to 'Pending'. If there are only a small number, just remove all the rows that are 'Nominated'.",
    "id": 297
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `insert_new_artist` that accepts four input parameters: `p_artist` of type `TEXT`, representing the name of the artist; `p_age` of type `INTEGER`, representing the age of the artist; `p_title` of type `TEXT`, representing a famous title associated with the artist; and `p_release_date` of type `TEXT`, representing the release date of the famous title. The procedure begins by declaring a local boolean variable named `artist_exists`. It then executes a `SELECT` statement to determine if an artist with the name provided in the `p_artist` parameter already exists in the `artist` table. Specifically, it performs a subquery `SELECT 1 FROM \"artist\" WHERE \"Artist\" = p_artist` to check for the presence of any row where the `Artist` column matches the value of `p_artist`. The result of this existence check is then assigned to the `artist_exists` boolean variable. Following this, a conditional `IF` statement evaluates the `artist_exists` variable. If `artist_exists` is `TRUE`, indicating that an artist with the given name already exists, the procedure raises a `NOTICE` message to the user, informing them that 'Artist % already exists in the database.', with the `%` placeholder replaced by the value of `p_artist`. If `artist_exists` is `FALSE`, meaning the artist does not yet exist in the database, the procedure proceeds to execute an `INSERT` statement. This `INSERT` statement adds a new row into the `artist` table, populating the `Artist` column with the value from `p_artist`, the `Age` column with the value from `p_age`, the `Famous_Title` column with the value from `p_title`, and the `Famous_Release_date` column with the value from `p_release_date`. After successfully inserting the new artist, the procedure raises another `NOTICE` message, stating 'Artist % successfully added to the database.', again replacing the `%` placeholder with the value of `p_artist`.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_artist(p_artist TEXT, p_age INTEGER, p_title TEXT, p_release_date TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    artist_exists BOOLEAN;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM \"artist\" WHERE \"Artist\" = p_artist) INTO artist_exists;\n    IF artist_exists THEN\n        RAISE NOTICE 'Artist % already exists in the database.', p_artist;\n    ELSE\n        INSERT INTO \"artist\" (\"Artist\", \"Age\", \"Famous_Title\", \"Famous_Release_date\")\n        VALUES (p_artist, p_age, p_title, p_release_date);\n        RAISE NOTICE 'Artist % successfully added to the database.', p_artist;\n    END IF;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL insert_new_artist('New Artist 1', 30, 'New Title 1', '2023-01-01');",
      "CALL insert_new_artist('Gorgoroth', 40, 'Existing Title', '2000-01-01');",
      "CALL insert_new_artist('New Artist 2', 25, 'Another Title', '2022-05-15');",
      "CALL insert_new_artist('Ophiolatry', 38, 'Old Title', '1999-11-20');",
      "CALL insert_new_artist('New Artist 3', 50, 'Final Title', '2024-03-10');"
    ],
    "summary": "Create a stored procedure named insert_new_artist that accepts artist name (text), age (integer), title (text), and release date (text). Check if the artist already exists. If exists, raise a notice 'Artist already exists'. If not, insert a new row into the artist table with the provided values and raise a notice 'Artist successfully added'.",
    "natural_language": "Create a stored procedure called insert_new_artist. It must take an artist name as text, an age as an integer, a title as text, and a release date as text. First, check for an existing artist. If the artist is found, raise a notice saying 'Artist already exists'. If not, insert the new data into the artist table and raise a notice stating 'Artist successfully added'.",
    "id": 298
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_city_institutions that accepts a single input parameter p_city of type text, representing a city name, and performs a series of operations on the institution and Championship tables based on the count of institutions and championships associated with that city. The procedure first declares two local integer variables, v_institution_count and v_championship_count. It then calculates v_institution_count by performing a SELECT COUNT(*) query from the institution table where the City column exactly matches the provided p_city parameter. Next, it calculates v_championship_count by performing a SELECT COUNT(*) query from the Championship table (aliased as c) joined with the institution table (aliased as i) on the condition that c.Institution_ID equals i.Institution_ID, where the i.City column matches the p_city parameter. Following these counts, the procedure executes a conditional IF-ELSIF-ELSE block. If v_institution_count equals zero, indicating no institutions exist for the city, it performs an INSERT into the institution table, specifying values for the columns Institution_ID, Name, Team, City, Province, Founded, Affiliation, Enrollment, Endowment, Stadium, and Capacity. The Institution_ID value is derived from a subquery that selects the COALESCE(MAX(Institution_ID), 0) + 1 from the institution table. The Name is set to 'New University', Team to 'New Team', City to the p_city parameter, Province to 'Unknown', Founded to the current year extracted via EXTRACT(YEAR FROM CURRENT_DATE), Affiliation to 'Public', Enrollment to 1000, Endowment to '$0', Stadium to 'Temporary', and Capacity to 1000. If the first condition is false and v_championship_count equals zero, indicating institutions exist but no championships are associated with them for the city, it performs an INSERT into the Championship table, specifying columns Institution_ID, Nickname, Joined, and Number_of_Championships. The values are selected from a query on the institution table (aliased as i) where i.City equals p_city and where a NOT EXISTS subquery ensures the record does not already exist in the Championship table (aliased as c) for the same Institution_ID. The selected values are i.Institution_ID, a concatenated string using CONCAT(i.Team, '-Champs') for Nickname, the current year extracted via EXTRACT(YEAR FROM CURRENT_DATE) for Joined, and 0 for Number_of_Championships. If neither of the previous conditions is true, meaning both institution and championship counts are greater than zero, it executes a DELETE operation on the Championship table where the Institution_ID is in a subquery result. The subquery selects i.Institution_ID from the institution table (aliased as i) where i.City equals p_city and the i.Enrollment column is less than 10000, and the deletion only occurs for those records where the Championship table's Number_of_Championships column equals 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_city_institutions(p_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_institution_count integer;\n    v_championship_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_institution_count\n    FROM \"institution\"\n    WHERE \"City\" = p_city;\n\n    SELECT COUNT(*) INTO v_championship_count\n    FROM \"Championship\" c\n    JOIN \"institution\" i ON c.\"Institution_ID\" = i.\"Institution_ID\"\n    WHERE i.\"City\" = p_city;\n\n    IF v_institution_count = 0 THEN\n        INSERT INTO \"institution\" (\"Institution_ID\", \"Name\", \"Team\", \"City\", \"Province\", \"Founded\", \"Affiliation\", \"Enrollment\", \"Endowment\", \"Stadium\", \"Capacity\")\n        VALUES ((SELECT COALESCE(MAX(\"Institution_ID\"), 0) + 1 FROM \"institution\"), 'New University', 'New Team', p_city, 'Unknown', EXTRACT(YEAR FROM CURRENT_DATE), 'Public', 1000, '$0', 'Temporary', 1000);\n    ELSIF v_championship_count = 0 THEN\n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        SELECT i.\"Institution_ID\", CONCAT(i.\"Team\", '-Champs'), EXTRACT(YEAR FROM CURRENT_DATE), 0\n        FROM \"institution\" i\n        WHERE i.\"City\" = p_city\n        AND NOT EXISTS (SELECT 1 FROM \"Championship\" c WHERE c.\"Institution_ID\" = i.\"Institution_ID\");\n    ELSE\n        DELETE FROM \"Championship\"\n        WHERE \"Institution_ID\" IN (\n            SELECT i.\"Institution_ID\"\n            FROM \"institution\" i\n            WHERE i.\"City\" = p_city\n            AND i.\"Enrollment\" < 10000\n        )\n        AND \"Number_of_Championships\" = 0;\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL process_city_institutions('Vancouver');",
      "CALL process_city_institutions('Calgary');",
      "CALL process_city_institutions('Edmonton');",
      "CALL process_city_institutions('Toronto');",
      "CALL process_city_institutions('Montreal');"
    ],
    "summary": "Create a stored procedure named process_city_institutions that accepts a city name (text). Count institutions in the city and championships for those institutions. If no institutions exist, insert a new institution with default values. If institutions exist but no championships, insert a new championship for each institution. If both exist, delete championships for institutions in the city with enrollment < 10000 and number_of_championships = 0.",
    "natural_language": "Make a stored procedure called process_city_institutions that takes a city name. Figure out roughly how many institutions are in that general area and also get a sense of their championship counts. If there don't seem to be any institutions at all, put in a new institution with some basic default details. If there are institutions but they don't appear to have any championships, add a new championship for each of those places. If both are present, remove championships for institutions in that city that have kind of low enrollment and no championships to speak of.",
    "id": 299
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named adjust_championship_data that accepts a single input parameter p_threshold of type real, which serves as a control value to determine one of three distinct data modification paths. The procedure first declares a local variable v_current_year of type real and initializes it by extracting the four-digit year component from the system's current date using the EXTRACT(YEAR FROM CURRENT_DATE) function. The core logic is a conditional block that branches based on the value of p_threshold. If p_threshold is greater than zero, the procedure executes a DELETE operation on the \"Championship\" table, removing rows where the absolute value of the \"Number_of_Championships\" column, obtained via the abs() function, is less than the provided p_threshold AND where the \"Joined\" column value is less than the result of the expression v_current_year - 10 (i.e., the year joined is more than ten years before the current year). If p_threshold is exactly equal to zero, the procedure performs an INSERT operation into the \"Championship\" table, specifying the columns \"Institution_ID\", \"Nickname\", \"Joined\", and \"Number_of_Championships\". The data to insert is selected from the \"institution\" table (aliased as i), where the institution's \"Enrollment\" column is greater than 30000 AND where a correlated subquery using NOT EXISTS confirms that no corresponding record already exists in the \"Championship\" table (aliased as c) with a matching \"Institution_ID\". For each qualifying institution row, the inserted values are: the i.\"Institution_ID\", a constructed nickname using the CONCAT function to combine the literal string 'Zero-' with a substring of the i.\"Team\" column starting at the first character and taking the next seven characters (via SUBSTRING(i.\"Team\" FROM 1 FOR 7)), the v_current_year for the \"Joined\" value, and the literal number 0 for \"Number_of_Championships\". For any other case where p_threshold is not greater than and not equal to zero (i.e., it is a negative number), the procedure executes a different DELETE operation on the \"Championship\" table, removing rows where either the \"Number_of_Championships\" column is less than zero OR where the \"Joined\" column value is greater than the v_current_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_championship_data(p_threshold real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_year real;\nBEGIN\n    v_current_year := EXTRACT(YEAR FROM CURRENT_DATE);\n\n    IF p_threshold > 0 THEN\n        DELETE FROM \"Championship\"\n        WHERE abs(\"Number_of_Championships\") < p_threshold\n        AND \"Joined\" < v_current_year - 10;\n    ELSIF p_threshold = 0 THEN\n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        SELECT i.\"Institution_ID\", CONCAT('Zero-', SUBSTRING(i.\"Team\" FROM 1 FOR 7)), v_current_year, 0\n        FROM \"institution\" i\n        WHERE i.\"Enrollment\" > 30000\n        AND NOT EXISTS (SELECT 1 FROM \"Championship\" c WHERE c.\"Institution_ID\" = i.\"Institution_ID\");\n    ELSE\n        DELETE FROM \"Championship\"\n        WHERE \"Number_of_Championships\" < 0\n        OR \"Joined\" > v_current_year;\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL adjust_championship_data(1.5);",
      "CALL adjust_championship_data(0);",
      "CALL adjust_championship_data(-1.0);",
      "CALL adjust_championship_data(0.5);",
      "CALL adjust_championship_data(2.0);"
    ],
    "summary": "Create a stored procedure named adjust_championship_data that accepts a threshold (real). Get the current year. If threshold > 0, delete rows where absolute(number_of_championships) < threshold and joined < (current_year - 10). If threshold = 0, insert rows for institutions with enrollment > 30000 not already in Championship, with nickname 'Zero-' + team substring, joined=current_year, number_of_championships=0. If threshold < 0, delete rows where number_of_championships < 0 or joined > current_year.",
    "natural_language": "Write a stored procedure called adjust_championship_data that takes a real number threshold. First, determine the current year. If the threshold is greater than zero, remove all records where the absolute value of number_of_championships is below the threshold and the joined year is more than ten years before the current year. If the threshold equals zero, add new records for any institution with an enrollment over 30000 that isn't already in the Championship table; set their nickname to 'Zero-' plus a substring of the team name, their joined year to the current year, and their number_of_championships to zero. If the threshold is less than zero, delete any rows where number_of_championships is negative or the joined year is in the future relative to the current year.",
    "id": 300
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named sync_institution_championships that accepts a single input parameter p_affiliation of type text, which is used to filter institutions by their affiliation. The procedure begins by calculating a variable v_year_offset as the difference between the current year and the year 2000. It then executes a loop over a result set obtained from a SELECT query that joins the institution table (aliased as i) with the Championship table (aliased as c) using a LEFT JOIN on the Institution_ID column, selecting the Institution_ID, Name, and Founded columns from the institution table and the Number_of_Championships column from the Championship table, where the institution's Affiliation column matches the input parameter p_affiliation. For each record (v_record) in this result set, the procedure performs conditional logic: if the Number_of_Championships value for the record is NULL, it inserts a new row into the Championship table with the Institution_ID from the record, a Nickname constructed by concatenating the string 'New-' with the first four characters of the institution's Name (extracted using the SUBSTRING function), a Joined date calculated by adding the v_year_offset to the institution's Founded year, and a Number_of_Championships set to 0. If the Number_of_Championships is not NULL and its absolute value (obtained via the abs function) is greater than 5, it deletes rows from the Championship table where the Institution_ID matches the record's Institution_ID and the Joined year is less than 2010. Otherwise, if the previous conditions are not met, it attempts to insert a new row into the Championship table with the record's Institution_ID, a Nickname constructed by concatenating 'Alt-' with the first six characters of the institution's Name, a Joined date set to the current year (extracted using EXTRACT(YEAR FROM CURRENT_DATE)), and a Number_of_Championships set to 1, using an ON CONFLICT clause on the Institution_ID column to perform no action if a conflict arises.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_institution_championships(p_affiliation text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_record RECORD;\n    v_year_offset real;\nBEGIN\n    v_year_offset := EXTRACT(YEAR FROM CURRENT_DATE) - 2000;\n\n    FOR v_record IN (\n        SELECT i.\"Institution_ID\", i.\"Name\", i.\"Founded\", c.\"Number_of_Championships\"\n        FROM \"institution\" i\n        LEFT JOIN \"Championship\" c ON i.\"Institution_ID\" = c.\"Institution_ID\"\n        WHERE i.\"Affiliation\" = p_affiliation\n    )\n    LOOP\n        IF v_record.\"Number_of_Championships\" IS NULL THEN\n            INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n            VALUES (v_record.\"Institution_ID\", CONCAT('New-', SUBSTRING(v_record.\"Name\" FROM 1 FOR 4)), v_record.\"Founded\" + v_year_offset, 0);\n        ELSIF abs(v_record.\"Number_of_Championships\") > 5 THEN\n            DELETE FROM \"Championship\"\n            WHERE \"Institution_ID\" = v_record.\"Institution_ID\"\n            AND \"Joined\" < 2010;\n        ELSE\n            INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n            VALUES (v_record.\"Institution_ID\", CONCAT('Alt-', SUBSTRING(v_record.\"Name\" FROM 1 FOR 6)), EXTRACT(YEAR FROM CURRENT_DATE), 1)\n            ON CONFLICT (\"Institution_ID\") DO NOTHING;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL sync_institution_championships('Public');",
      "CALL sync_institution_championships('Private');",
      "CALL sync_institution_championships('Government');"
    ],
    "summary": "Create a stored procedure named sync_institution_championships that takes a text parameter p_affiliation. For institutions matching this affiliation, loop through their championship records. If a record has no championships (NULL), insert a new championship with a nickname based on the institution name, a joined date offset from its founding year, and 0 championships. If the absolute number of championships exceeds 5, delete championships for that institution joined before 2010. Otherwise, insert an alternative championship record with a different nickname and the current year, ignoring conflicts on Institution_ID.",
    "natural_language": "Create a stored procedure called sync_institution_championships that uses a text parameter for the affiliation. For institutions that are somewhat related to that affiliation, go through their championship history. For records where the championship details are missing or unclear, add a new entry with a kind of nickname inspired by the institution, a joined date that's a good while after it started, and set championships to none. If there are a lot of championships, say more than a handful, clean out the older ones from before 2010 for that place. If not, just put in another championship record with a different casual name and the recent year, even if it seems like it might already be there for that institution.",
    "id": 301
  },
  {
    "ir": "Write a PostgreSQL stored procedure named manage_stadium_capacity that accepts a single input parameter p_capacity_limit of type real, which serves as a threshold value for evaluating stadium capacity. The procedure begins by declaring two integer variables, v_small_institution_count and v_large_institution_count. It then executes a query to count rows from the institution table where the Capacity column is less than the input parameter p_capacity_limit and the Enrollment column is less than 20000, storing the result in v_small_institution_count. Subsequently, it executes another query to count rows from the institution table where the Capacity column is greater than or equal to p_capacity_limit and the Enrollment column is greater than or equal to 20000, storing the result in v_large_institution_count. Following these counts, the procedure evaluates a conditional block: if v_small_institution_count is greater than v_large_institution_count, it performs a delete operation on the Championship table, removing rows where the Institution_ID matches any Institution_ID from the institution table that has a Capacity less than p_capacity_limit and where the absolute difference between Capacity and p_capacity_limit exceeds 10000. If the first condition is false and v_large_institution_count is greater than zero, the procedure executes an insert operation into the Championship table, specifying columns Institution_ID, Nickname, Joined, and Number_of_Championships; the inserted values are selected from the institution table (aliased as i) where i.Capacity is greater than or equal to p_capacity_limit and where no corresponding entry exists in the Championship table (checked via a NOT EXISTS subquery that selects a constant 1 from the Championship table c where c.Institution_ID equals i.Institution_ID); for each qualifying institution row, the Nickname is constructed by concatenating the string 'Stadium-' with the first five characters extracted from the i.Stadium column using the SUBSTRING function, the Joined column is set to the current year extracted via EXTRACT(YEAR FROM CURRENT_DATE), and the Number_of_Championships is set to 2. If neither of the previous conditions is met, the procedure executes a delete operation on the institution table itself, removing rows where Capacity is less than 1000 and where the Institution_ID is not found in the Championship table (checked via a NOT IN subquery that selects Institution_ID from the Championship table).",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_stadium_capacity(p_capacity_limit real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_small_institution_count integer;\n    v_large_institution_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_small_institution_count\n    FROM \"institution\"\n    WHERE \"Capacity\" < p_capacity_limit\n    AND \"Enrollment\" < 20000;\n\n    SELECT COUNT(*) INTO v_large_institution_count\n    FROM \"institution\"\n    WHERE \"Capacity\" >= p_capacity_limit\n    AND \"Enrollment\" >= 20000;\n\n    IF v_small_institution_count > v_large_institution_count THEN\n        DELETE FROM \"Championship\"\n        WHERE \"Institution_ID\" IN (\n            SELECT \"Institution_ID\"\n            FROM \"institution\"\n            WHERE \"Capacity\" < p_capacity_limit\n            AND abs(\"Capacity\" - p_capacity_limit) > 10000\n        );\n    ELSIF v_large_institution_count > 0 THEN\n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        SELECT i.\"Institution_ID\", CONCAT('Stadium-', SUBSTRING(i.\"Stadium\" FROM 1 FOR 5)), EXTRACT(YEAR FROM CURRENT_DATE), 2\n        FROM \"institution\" i\n        WHERE i.\"Capacity\" >= p_capacity_limit\n        AND NOT EXISTS (SELECT 1 FROM \"Championship\" c WHERE c.\"Institution_ID\" = i.\"Institution_ID\");\n    ELSE\n        DELETE FROM \"institution\"\n        WHERE \"Capacity\" < 1000\n        AND \"Institution_ID\" NOT IN (SELECT \"Institution_ID\" FROM \"Championship\");\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL manage_stadium_capacity(5000.0);",
      "CALL manage_stadium_capacity(10000.0);",
      "CALL manage_stadium_capacity(25000.0);",
      "CALL manage_stadium_capacity(1500.0);",
      "CALL manage_stadium_capacity(50000.0);"
    ],
    "summary": "Create a stored procedure named manage_stadium_capacity that takes a real parameter p_capacity_limit. Count institutions with small capacity and enrollment, and those with large capacity and enrollment. If small institutions are more numerous, delete championships for institutions where capacity is below the limit and the difference from the limit exceeds 10000. If large institutions exist and the first condition is false, insert new championship records for large-capacity institutions not already in the championship table, using a nickname derived from the stadium name. If neither condition is met, delete institutions with capacity below 1000 that have no championship records.",
    "natural_language": "Alright, so we need a stored procedure called manage_stadium_capacity that takes in a number for the capacity limit. First, figure out how many places have a small stadium and small enrollment, and how many have a big stadium and big enrollment. If the small ones are winning in numbers, then get rid of any championship records for places where the stadium size is under the given limit and is more than 10,000 seats short of it. If that first bit isn't true but there are some big institutions, then for those big-capacity places that aren't already in the championship list, add new championship entries for them. Make up a nickname for these new entries based on the stadium's name. If neither of those situations pans out, just clean out any institutions with a tiny stadium (under 1000 seats) that don't have any championship records at all.",
    "id": 302
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named \"InsertNewSong\" that accepts three input parameters: \"title\" of type TEXT, representing the title of the new song; \"singerId\" of type INTEGER, representing the unique identifier of the singer associated with the new song; and \"salesAmount\" of type REAL, representing the sales amount for the new song. The procedure begins by declaring a local variable named `new_song_id` of type INTEGER, which will be used to store the calculated unique identifier for the new song. It then executes a SELECT statement to determine the next available `Song_ID` for the \"song\" table. This SELECT statement queries the \"song\" table, specifically selecting the maximum value from the \"Song_ID\" column. The `COALESCE` function is applied to this maximum value, ensuring that if no songs exist in the table (i.e., `MAX(\"Song_ID\")` returns NULL), the value defaults to 0. One is then added to this result to generate the `new_song_id`. After calculating the `new_song_id`, the procedure proceeds to insert a new record into the \"song\" table. The INSERT statement specifies the columns to be populated: \"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", and \"Highest_Position\". The values provided for these columns are `new_song_id` for \"Song_ID\", the input parameter \"title\" for \"Title\", the input parameter \"singerId\" for \"Singer_ID\", the input parameter \"salesAmount\" for \"Sales\", and NULL for \"Highest_Position\".",
    "plsql": "CREATE OR REPLACE PROCEDURE \"InsertNewSong\"(\"title\" TEXT, \"singerId\" INTEGER, \"salesAmount\" REAL)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    new_song_id INTEGER;\nBEGIN\n    SELECT COALESCE(MAX(\"Song_ID\"), 0) + 1 INTO new_song_id FROM \"song\";\n    \n    INSERT INTO \"song\" (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n    VALUES (new_song_id, \"title\", \"singerId\", \"salesAmount\", NULL);\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL \"InsertNewSong\"('New Song Title 1', 1, 100000.0);",
      "CALL \"InsertNewSong\"('Another Hit', 2, 500000.50);",
      "CALL \"InsertNewSong\"('Summer Jam', 3, 75000.25);",
      "CALL \"InsertNewSong\"('Ballad of Love', 1, 25000.0);",
      "CALL \"InsertNewSong\"('Rock Anthem', 2, 1200000.75);"
    ],
    "summary": "Create a stored procedure named InsertNewSong that takes parameters for title (text), singerId (integer), and salesAmount (real). Calculate the next Song_ID by finding the maximum existing ID plus one (defaulting to 0 if none exist). Insert a new song record with this ID, the provided title, singerId, salesAmount, and a NULL Highest_Position.",
    "natural_language": "Create a stored procedure, which should be named InsertNewSong, that is designed to accept three distinct input parameters: a detailed title as text, a specific singer identifier as an integer, and a precise sales amount as a real number. This procedure must first intelligently calculate the next available Song_ID by meticulously determining the maximum existing ID value currently present in the table and then incrementing it by one; however, if no records exist at all, it must gracefully default this new ID to zero. Subsequently, it should insert a brand new song record, carefully populating it with this freshly generated ID, the provided descriptive title, the given singer identifier, the specified sales amount, and intentionally setting the Highest_Position field to a NULL value.",
    "id": 303
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `remove_low_value_boxes` that accepts three input parameters: `p_warehouse_code` of type `bigint`, `p_value_threshold` of type `real`, and `p_contents_pattern` of type `text`. The purpose of this procedure is to remove specific records from the table named `\"Boxes\"`. The procedure performs a single `DELETE` operation. This `DELETE` operation targets rows in the `\"Boxes\"` table that satisfy three simultaneous conditions. The first condition requires that the value in the `\"Warehouse\"` column of a given row must be equal to the value provided by the `p_warehouse_code` input parameter. The second condition specifies that the value in the `\"Value\"` column of the same row must be strictly less than the value provided by the `p_value_threshold` input parameter. The third condition involves a pattern matching comparison on the `\"Contents\"` column. Specifically, it requires that the uppercase version of the string in the `\"Contents\"` column must match a pattern. This pattern is constructed by taking the `p_contents_pattern` input parameter, converting it to uppercase using the `UPPER()` function, and then enclosing it with wildcard characters (`%`) on both sides. The `LIKE` operator is used for this case-insensitive pattern matching. Only rows that meet all three of these criteria will be permanently removed from the `\"Boxes\"` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_low_value_boxes(p_warehouse_code bigint, p_value_threshold real, p_contents_pattern text)\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\"\n    WHERE \"Warehouse\" = p_warehouse_code\n    AND \"Value\" < p_value_threshold\n    AND UPPER(\"Contents\") LIKE UPPER('%' || p_contents_pattern || '%');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL remove_low_value_boxes(1, 100.0, 'rock');",
      "CALL remove_low_value_boxes(3, 200.0, 'scissors');",
      "CALL remove_low_value_boxes(4, 50.0, 'paper');",
      "CALL remove_low_value_boxes(2, 150.0, 'tool');",
      "CALL remove_low_value_boxes(1, 75.5, '');"
    ],
    "summary": "Create a stored procedure named remove_low_value_boxes that takes parameters for warehouse_code (bigint), value_threshold (real), and contents_pattern (text). Delete boxes from the specified warehouse where the value is below the threshold and the contents (case-insensitive) match the pattern with wildcards.",
    "natural_language": "Create a comprehensive stored procedure, which should be named `remove_low_value_boxes`, designed to accept three distinct input parameters: a `warehouse_code` of type bigint, a `value_threshold` of type real, and a `contents_pattern` of type text. This procedure must meticulously delete all boxes located within the precisely specified warehouse, but only under the strict condition that each box's monetary value is demonstrably and significantly below the provided financial threshold, while also ensuring that the textual description of the box's contents, when evaluated in a completely case-insensitive manner, successfully matches the given pattern, which may intelligently incorporate wildcard characters for flexible matching.",
    "id": 304
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `validate_warehouse_capacity_limits` that accepts three input parameters: `p_capacity_threshold` of type `bigint`, `p_value_limit` of type `real`, and `p_location_substring` of type `text`. The procedure declares three local variables: `v_warehouse_code` of type `bigint`, `v_current_box_count` of type `integer`, and `v_high_value_boxes` of type `integer`. The procedure then initiates a loop that iterates over a specific set of warehouse codes. This set is determined by selecting the \"Code\" column from the \"Warehouses\" table where the \"Capacity\" column is strictly greater than the input parameter `p_capacity_threshold` AND the \"Location\" column contains the `p_location_substring` as a case-sensitive substring (achieved by concatenating '%' before and after `p_location_substring`). For each `v_warehouse_code` obtained from this selection, the procedure performs the following operations: First, it calculates the total number of boxes currently stored in the warehouse identified by `v_warehouse_code` by selecting the count of all rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code`, and stores this count in the `v_current_box_count` variable. Second, it calculates the number of \"high-value\" boxes in the same warehouse by selecting the count of rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code` AND the \"Value\" column is strictly greater than the input parameter `p_value_limit`, and stores this count in the `v_high_value_boxes` variable. Third, it evaluates a conditional statement: if the `v_current_box_count` is strictly greater than the \"Capacity\" value for the current `v_warehouse_code` (which is retrieved by selecting the \"Capacity\" column from the \"Warehouses\" table where the \"Code\" column matches `v_warehouse_code`), then it proceeds to delete a specific box. The deletion targets rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code` AND the \"Value\" column is equal to the minimum \"Value\" found among all boxes in that same warehouse (this minimum value is determined by a subquery that selects the minimum \"Value\" from the \"Boxes\" table where the \"Warehouse\" column matches `v_warehouse_code`). This loop continues until all relevant warehouse codes have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_warehouse_capacity_limits(p_capacity_threshold bigint, p_value_limit real, p_location_substring text)\nAS $$\nDECLARE\n    v_warehouse_code bigint;\n    v_current_box_count integer;\n    v_high_value_boxes integer;\nBEGIN\n    FOR v_warehouse_code IN\n        SELECT \"Code\"\n        FROM \"Warehouses\"\n        WHERE \"Capacity\" > p_capacity_threshold\n        AND \"Location\" LIKE '%' || p_location_substring || '%'\n    LOOP\n        SELECT COUNT(*) INTO v_current_box_count\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = v_warehouse_code;\n        \n        SELECT COUNT(*) INTO v_high_value_boxes\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = v_warehouse_code\n        AND \"Value\" > p_value_limit;\n        \n        IF v_current_box_count > (SELECT \"Capacity\" FROM \"Warehouses\" WHERE \"Code\" = v_warehouse_code) THEN\n            DELETE FROM \"Boxes\"\n            WHERE \"Warehouse\" = v_warehouse_code\n            AND \"Value\" = (SELECT MIN(\"Value\") FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_code);\n        END IF;\n    END LOOP;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL validate_warehouse_capacity_limits(2, 200.0, 'Chicago');",
      "CALL validate_warehouse_capacity_limits(3, 150.0, 'New York');",
      "CALL validate_warehouse_capacity_limits(1, 180.0, 'York');",
      "CALL validate_warehouse_capacity_limits(4, 250.0, 'Chic');",
      "CALL validate_warehouse_capacity_limits(5, 100.0, 'New');"
    ],
    "summary": "Create a stored procedure named validate_warehouse_capacity_limits that takes parameters for capacity_threshold (bigint), value_limit (real), and location_substring (text). Loop through warehouses with capacity exceeding the threshold and location containing the substring. For each, count its total boxes and high-value boxes (value above limit). If the box count exceeds the warehouse's capacity, delete the box with the minimum value in that warehouse.",
    "natural_language": "Make a stored procedure called validate_warehouse_capacity_limits that uses inputs for a capacity threshold (bigint), a value cutoff (real), and a bit of text for location. Go through warehouses that have a capacity over that rough threshold and where the location kind of matches that text snippet. For each one, figure out roughly how many boxes it has in total and how many are the more valuable ones (above that limit). If the number of boxes seems to be more than what the warehouse should hold, get rid of the least valuable box found there.",
    "id": 305
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named generate_inventory_report_data that accepts three input parameters: a real number parameter p_min_box_value, a bigint parameter p_warehouse_capacity_filter, and a text parameter p_contents_search. The procedure begins by declaring a cursor named report_cursor that selects data from the Boxes table joined with the Warehouses table on the condition that the Boxes.Warehouse column equals the Warehouses.Code column. The cursor's query specifically retrieves the Boxes.Code, Boxes.Contents, Boxes.Value, Warehouses.Location, and Warehouses.Capacity columns. The selection is filtered by three conditions: first, the Boxes.Value must be greater than or equal to the p_min_box_value parameter; second, the Warehouses.Capacity must be greater than or equal to the p_warehouse_capacity_filter parameter; and third, the Boxes.Contents column, after being trimmed of leading and trailing spaces and converted to lowercase using the TRIM and LOWER functions, must contain the string from the p_contents_search parameter, which is also trimmed and lowercased, with the match pattern allowing any characters before and after the search term. The procedure also declares a variable v_record of type RECORD to hold fetched rows and an integer variable v_processed_count initialized to zero. The procedure's execution logic opens the declared cursor, then enters a loop that repeatedly fetches a row from the cursor into the v_record variable. The loop exits when no more rows are found. For each fetched row, the v_processed_count is incremented by one, and an INSERT operation is performed into the Boxes table. The inserted row consists of a new Code value formed by concatenating the string 'RPT_' with the original v_record.Code value, a new Contents value formed by concatenating the string 'Report: ' with the original v_record.Contents, the string ' at ', and the v_record.Location, a new Value calculated by applying the CEIL function to the original v_record.Value multiplied by 1.1, and a Warehouse value determined by a subquery that selects the Code from the Warehouses table where the Location equals the v_record.Location, limited to one result. After the loop completes, the cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_inventory_report_data(p_min_box_value real, p_warehouse_capacity_filter bigint, p_contents_search text)\nAS $$\nDECLARE\n    report_cursor CURSOR FOR\n        SELECT b.\"Code\", b.\"Contents\", b.\"Value\", w.\"Location\", w.\"Capacity\"\n        FROM \"Boxes\" b\n        JOIN \"Warehouses\" w ON b.\"Warehouse\" = w.\"Code\"\n        WHERE b.\"Value\" >= p_min_box_value\n        AND w.\"Capacity\" >= p_warehouse_capacity_filter\n        AND TRIM(LOWER(b.\"Contents\")) LIKE '%' || TRIM(LOWER(p_contents_search)) || '%';\n    \n    v_record RECORD;\n    v_processed_count integer := 0;\nBEGIN\n    OPEN report_cursor;\n    \n    LOOP\n        FETCH report_cursor INTO v_record;\n        EXIT WHEN NOT FOUND;\n        \n        v_processed_count := v_processed_count + 1;\n        \n        INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\")\n        VALUES (\n            'RPT_' || v_record.\"Code\",\n            'Report: ' || v_record.\"Contents\" || ' at ' || v_record.\"Location\",\n            CEIL(v_record.\"Value\" * 1.1),\n            (SELECT \"Code\" FROM \"Warehouses\" WHERE \"Location\" = v_record.\"Location\" LIMIT 1)\n        );\n    END LOOP;\n    \n    CLOSE report_cursor;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL generate_inventory_report_data(100.0, 5, 'rocks');",
      "CALL generate_inventory_report_data(50.0, 3, 'scissors');",
      "CALL generate_inventory_report_data(200.0, 7, 'tools');",
      "CALL generate_inventory_report_data(150.0, 4, 'paper');",
      "CALL generate_inventory_report_data(75.0, 2, 'metal');"
    ],
    "summary": "Create a stored procedure named generate_inventory_report_data with three input parameters: p_min_box_value (REAL), p_warehouse_capacity_filter (BIGINT), and p_contents_search (TEXT). The procedure must generate a report by selecting box and warehouse data where the box value meets a minimum, the warehouse meets a minimum capacity, and the box contents contain a search string (case-insensitive, trimmed). For each matching row, increment a counter and insert a new record into the Boxes table. The new record should have a modified code ('RPT_' prefix), updated contents ('Report: ' prefix plus original contents and location), a value increased by 10% and rounded up, and a warehouse code looked up by location. Finally, close the cursor.",
    "natural_language": "How can I create a stored procedure named generate_inventory_report_data that takes three parametersâ€”p_min_box_value (REAL), p_warehouse_capacity_filter (BIGINT), and p_contents_search (TEXT)â€”to generate a report? The procedure should select box and warehouse data where the box value is at least the minimum, the warehouse meets the minimum capacity, and the box contents contain the search string (case-insensitive and trimmed). For each matching row, it should increment a counter, insert a new record into the Boxes table with a modified code (prefixed with 'RPT_'), updated contents (prefixed with 'Report: ' and including the original contents and location), a value increased by 10% and rounded up, and a warehouse code looked up by location. Finally, how does the procedure close the cursor?",
    "id": 306
  }
]