[
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert or update operation on the bridge table. This function checks the values of the length_meters and length_feet columns for the row being inserted or updated. If the length_meters column is NULL, it calculates its value by converting the length_feet value from feet to meters using the conversion factor 0.3048, rounds the result to two decimal places, and assigns it to length_meters. If the length_feet column is NULL, it calculates its value by converting the length_meters value from meters to feet using the conversion factor 0.3048, rounds the result to two decimal places, and assigns it to length_feet. If neither column is NULL, it checks if length_meters is negative and, if so, replaces it with its absolute value. Similarly, it checks if length_feet is negative and, if so, replaces it with its absolute value. The function then returns the modified row. The trigger named bridge_length_conversion is associated with this function and is set to execute for each row before an insert or update operation on the bridge table.",
    "plsql": "CREATE OR REPLACE FUNCTION trigger_function_1() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.length_meters IS NULL THEN\n        NEW.length_meters := ROUND(NEW.length_feet::numeric * 0.3048, 2)::real;\n    ELSIF NEW.length_feet IS NULL THEN\n        NEW.length_feet := ROUND(NEW.length_meters::numeric / 0.3048, 2)::real;\n    ELSE\n        IF NEW.length_meters < 0 THEN\n            NEW.length_meters := ABS(NEW.length_meters);\n        END IF;\n        IF NEW.length_feet < 0 THEN\n            NEW.length_feet := ABS(NEW.length_feet);\n        END IF;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER bridge_length_conversion\nBEFORE INSERT OR UPDATE ON bridge\nFOR EACH ROW EXECUTE FUNCTION trigger_function_1();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO bridge (architect_id, id, name, location, length_meters, length_feet) VALUES (1, 4, 'New Bridge 1', 'Someplace, USA', NULL, 100.0);",
      "INSERT INTO bridge (architect_id, id, name, location, length_meters, length_feet) VALUES (2, 5, 'New Bridge 2', 'Anotherplace, UK', 50.0, NULL);",
      "UPDATE bridge SET length_meters = -10.0 WHERE id = 1;",
      "UPDATE bridge SET length_feet = -50.0 WHERE id = 2;",
      "INSERT INTO bridge (architect_id, id, name, location, length_meters, length_feet) VALUES (3, 6, 'New Bridge 3', 'Somewhere, Canada', 75.0, 246.0);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger for the bridge table. If length_meters is NULL, calculate it from length_feet using a 0.3048 conversion factor and round to two decimals. If length_feet is NULL, calculate it from length_meters using the same factor and round to two decimals. If both are not NULL, replace any negative values with their absolute values. Return the modified row.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE row-level trigger for the bridge table. The trigger's logic must adhere to the following specifications: if the `length_meters` field is NULL, it should be computed from the `length_feet` value by applying a conversion factor of 0.3048, with the result rounded to two decimal places. Conversely, if the `length_feet` field is NULL, it should be derived from the `length_meters` value using the same conversion factor, also rounded to two decimal places. In instances where both fields contain non-NULL values, any negative entries must be replaced with their absolute values. The trigger must then return the modified row.",
    "id": 1
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before each row is inserted or updated in the architect table. The function first checks the name column of the NEW record: if the name is NULL, it assigns the string 'Unknown' to it; if the name exceeds 50 characters, it truncates the name to the first 50 characters. If the name is not NULL and within the length limit, it checks the nationality and gender columns: if either is NULL, it assigns 'Unknown' to the respective column. For INSERT operations, the function handles potential id conflicts by initializing a base_id with the NEW record's id and appending an underscore followed by an incrementing counter to the id until a unique id is found that does not exist in the architect table. The function then returns the modified NEW record. The trigger architect_name_check is created to invoke this function before any row is inserted or updated in the architect table.",
    "plsql": "CREATE OR REPLACE FUNCTION trigger_function_3() RETURNS TRIGGER AS $$\nDECLARE\n    counter INTEGER := 1;\n    base_id TEXT;\nBEGIN\n    -- Handle name field\n    IF NEW.name IS NULL THEN\n        NEW.name := 'Unknown';\n    ELSIF LENGTH(NEW.name) > 50 THEN\n        NEW.name := SUBSTRING(NEW.name FROM 1 FOR 50);\n    ELSE\n        IF NEW.nationality IS NULL THEN\n            NEW.nationality := 'Unknown';\n        END IF;\n        IF NEW.gender IS NULL THEN\n            NEW.gender := 'Unknown';\n        END IF;\n    END IF;\n    \n    -- Handle potential id conflicts for INSERT operations\n    IF TG_OP = 'INSERT' THEN\n        base_id := NEW.id;\n        WHILE EXISTS (SELECT 1 FROM architect WHERE id = NEW.id) LOOP\n            NEW.id := base_id || '_' || counter::TEXT;\n            counter := counter + 1;\n        END LOOP;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER architect_name_check\nBEFORE INSERT OR UPDATE ON architect\nFOR EACH ROW EXECUTE FUNCTION trigger_function_3();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO architect (id, name, nationality, gender) VALUES ('4', 'Antoni Gaudí', 'Spanish', 'male');",
      "INSERT INTO architect (id, name, nationality, gender) VALUES ('5', NULL, 'Italian', 'female');",
      "INSERT INTO architect (id, name, nationality, gender) VALUES ('6', 'Renzo Piano', NULL, NULL);",
      "INSERT INTO architect (id, name, nationality, gender) VALUES ('7', 'Norman Foster', 'British', NULL);",
      "INSERT INTO architect (id, name, nationality, gender) VALUES ('8', 'Santiago Calatrava', 'Spanish', 'male');"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger for the architect table. If name is NULL, set it to 'Unknown'. If name exceeds 50 characters, truncate it. If nationality or gender is NULL, set them to 'Unknown'. For INSERT operations, if the provided id already exists, generate a new unique id by appending an underscore and an incrementing counter to a base id. Return the modified row.",
    "natural_language": "Hey, can you set up a trigger for the architect table that fires before any new row is added or an existing one is updated? Here's what it needs to do: if the name's left blank, just put 'Unknown'. If the name's way too long, like over 50 letters, chop it down to size. If nationality or gender aren't filled in, mark 'em as 'Unknown' too. Oh, and for brand new entries, if the ID they're trying to use is already taken, don't just error out—make a new unique one by slapping an underscore and a number onto the original ID, counting up until it's free. Finally, just hand back the row with all these tweaks.",
    "id": 2
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert or update operation on the bridge table. This function modifies the NEW row being inserted or updated by first checking the location column: if the location is NULL, it sets the location to 'Unknown'; if the location does not contain a comma, it appends ', Unknown' to the existing location value. The function then ensures that the length_meters and length_feet columns have default values: if length_meters is NULL, it sets it to 0, and similarly, if length_feet is NULL, it sets it to 0. The function returns the modified NEW row for further processing. The trigger named bridge_location_check is associated with this function and is set to execute for each row before any insert or update operation on the bridge table, ensuring that the specified modifications are applied to the location, length_meters, and length_feet columns of the affected rows.",
    "plsql": "CREATE OR REPLACE FUNCTION trigger_function_4() RETURNS TRIGGER AS $$\nBEGIN\n    -- Handle location formatting\n    IF NEW.location IS NULL THEN\n        NEW.location := 'Unknown';\n    ELSIF POSITION(',' IN NEW.location) = 0 THEN\n        NEW.location := NEW.location || ', Unknown';\n    END IF;\n    \n    -- Always ensure length fields have defaults if NULL\n    IF NEW.length_meters IS NULL THEN\n        NEW.length_meters := 0;\n    END IF;\n    \n    IF NEW.length_feet IS NULL THEN\n        NEW.length_feet := 0;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER bridge_location_check\nBEFORE INSERT OR UPDATE ON bridge\nFOR EACH ROW EXECUTE FUNCTION trigger_function_4();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO bridge (architect_id, id, name, location, length_meters, length_feet) VALUES (1, 4, 'New Bridge 1', NULL, 100.0, 328.0);",
      "INSERT INTO bridge (architect_id, id, name, location, length_meters, length_feet) VALUES (2, 5, 'New Bridge 2', 'Paris', 150.0, NULL);",
      "INSERT INTO bridge (architect_id, id, name, location, length_meters, length_feet) VALUES (3, 6, 'New Bridge 3', 'London, UK', NULL, 492.0);",
      "UPDATE bridge SET location = NULL WHERE id = 1;",
      "UPDATE bridge SET location = 'Rome', length_meters = NULL, length_feet = NULL WHERE id = 2;"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger for the bridge table. If location is NULL, set it to 'Unknown'. If location does not contain a comma, append ', Unknown' to it. If length_meters is NULL, set it to 0. If length_feet is NULL, set it to 0. Return the modified row.",
    "natural_language": "Construct a detailed BEFORE INSERT OR UPDATE row-level trigger specifically for the bridge table, which will meticulously handle several data validation and default assignment scenarios. This trigger should first check if the location field is NULL and, in such cases, thoughtfully assign it the default value of 'Unknown'. Furthermore, if the location field contains a value but that string notably lacks a comma, the procedure must carefully append the suffix ', Unknown' to the existing location text. Additionally, the trigger must comprehensively verify the length_meters column, setting it to a value of 0 whenever it encounters a NULL entry. Similarly, it must examine the length_feet column and, if it finds a NULL value, dutifully set it to 0 as well. Finally, the trigger must ensure that the newly modified row is properly returned.",
    "id": 3
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trigger_function_5` that is designed to be executed `BEFORE INSERT OR UPDATE` operations on the `mill` table, `FOR EACH ROW`. This function takes no explicit parameters but implicitly receives special trigger variables: `NEW` (representing the new row data for `INSERT` or `UPDATE` operations) and `TG_OP` (a text variable indicating the operation type, e.g., 'INSERT', 'UPDATE', 'DELETE'). The function declares a local integer variable named `max_id`.\n\nUpon execution, the function first checks the value of `TG_OP`. If `TG_OP` is equal to the string literal 'INSERT', indicating an `INSERT` operation, the function proceeds to handle potential duplicate `id` values. It executes a subquery `SELECT 1 FROM mill WHERE id = NEW.id` to check if an `id` matching `NEW.id` (the `id` provided for the new row) already exists in the `mill` table. If this `EXISTS` condition is true, meaning a duplicate `id` is found, the function then calculates a new unique `id`. It performs a `SELECT COALESCE(MAX(id), 0) + 1 INTO max_id FROM mill;` query. This query retrieves the maximum `id` value from the `mill` table. If `MAX(id)` returns `NULL` (meaning the table is empty), `COALESCE` replaces `NULL` with `0`. The result is then incremented by `1` and stored in the `max_id` variable. Subsequently, the `id` of the `NEW` row is updated to this newly generated `max_id` value (`NEW.id := max_id;`).\n\nFollowing the `id` handling, regardless of the operation type or whether an `id` was modified, the function checks if the `type` column of the `NEW` row (`NEW.type`) is `NULL`. If `NEW.type` is `NULL`, it assigns the string literal 'Unknown' to `NEW.type` (`NEW.type := 'Unknown';`).\n\nNext, the function checks if the `built_year` column of the `NEW` row (`NEW.built_year`) is `NULL`. If `NEW.built_year` is `NULL`, it assigns the integer value `1900` to `NEW.built_year` (`NEW.built_year := 1900;`).\n\nSubsequently, the function checks if the `notes` column of the `NEW` row (`NEW.notes`) is `NULL`. If `NEW.notes` is `NULL`, it assigns the string literal 'No additional notes' to `NEW.notes` (`NEW.notes := 'No additional notes';`).\n\nFinally, the function checks the length of the `notes` column of the `NEW` row (`NEW.notes`). If the `LENGTH(NEW.notes)` is greater than `100`, it truncates the `notes` value. It uses the `SUBSTRING` function to extract the first `100` characters from `NEW.notes` (`SUBSTRING(NEW.notes FROM 1 FOR 100)`) and assigns this truncated string back to `NEW.notes` (`NEW.notes := SUBSTRING(NEW.notes FROM 1 FOR 100);`).\n\nAfter all these checks and potential modifications, the function returns the `NEW` row, which will then be used for the actual `INSERT` or `UPDATE` operation on the `mill` table.",
    "plsql": "CREATE OR REPLACE FUNCTION trigger_function_5() RETURNS TRIGGER AS $$\nDECLARE\n    max_id INTEGER;\nBEGIN\n    -- Handle duplicate id for INSERT operations\n    IF TG_OP = 'INSERT' THEN\n        -- Check if the id already exists\n        IF EXISTS (SELECT 1 FROM mill WHERE id = NEW.id) THEN\n            -- Generate a new unique id\n            SELECT COALESCE(MAX(id), 0) + 1 INTO max_id FROM mill;\n            NEW.id := max_id;\n        END IF;\n    END IF;\n\n    -- Ensure type is set if null\n    IF NEW.type IS NULL THEN\n        NEW.type := 'Unknown';\n    END IF;\n\n    -- Ensure built_year is set if null\n    IF NEW.built_year IS NULL THEN\n        NEW.built_year := 1900;\n    END IF;\n\n    -- Handle notes regardless of type or built_year null status\n    IF NEW.notes IS NULL THEN\n        NEW.notes := 'No additional notes';\n    END IF;\n\n    -- Truncate notes if too long\n    IF LENGTH(NEW.notes) > 100 THEN\n        NEW.notes := SUBSTRING(NEW.notes FROM 1 FOR 100);\n    END IF;\n\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER mill_type_check\nBEFORE INSERT OR UPDATE ON mill\nFOR EACH ROW EXECUTE FUNCTION trigger_function_5();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (1, 1, 'Coswarem', 'Le Vieux Molen', NULL, NULL, NULL);",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (2, 2, 'Donceel', 'Moulin Bertrand', NULL, NULL, NULL);",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (1, 3, 'Fexhe-le-haut-Clocher', 'Moulin de Fexhe', NULL, NULL, NULL);",
      "UPDATE mill SET type = NULL, built_year = NULL, notes = NULL WHERE id = 1;",
      "UPDATE mill SET type = NULL, built_year = NULL, notes = NULL WHERE id = 2;"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger for the mill table. For INSERT operations, if the new id already exists, generate a new unique id by taking the maximum existing id plus one. If the type column is NULL, set it to 'Unknown'. If the built_year column is NULL, set it to 1900. If the notes column is NULL, set it to 'No additional notes'. If notes exceed 100 characters, truncate them to 100 characters. Return the modified row.",
    "natural_language": "Define a BEFORE INSERT OR UPDATE row-level trigger on the mill table. For INSERT operations, if the new id already exists, generate a new unique id by taking the maximum existing id plus one. For any operation, if the type column is NULL, set it to 'Unknown'. If the built_year column is NULL, set it to 1900. If the notes column is NULL, set it to 'No additional notes'. If notes exceed 100 characters, truncate them to 100 characters. Return the modified row.",
    "id": 4
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `delete_book_reviews_trigger` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` record variables. The purpose of this function is to perform a data manipulation operation: specifically, a `DELETE` statement. It targets the table named `\"review\"`. The `DELETE` operation is conditional, removing rows from `\"review\"` where the value in its `\"Book_ID\"` column exactly matches the value of the `\"Book_ID\"` column from the `OLD` record. The `OLD` record represents the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` record.\n\nAdditionally, define a PostgreSQL trigger named `delete_book_reviews`. This trigger is configured to activate `AFTER DELETE` operations on the table named `\"book\"`. It is specified to execute `FOR EACH ROW`, meaning that for every individual row deleted from the `\"book\"` table, the trigger will fire. When activated, this trigger executes the previously defined function `delete_book_reviews_trigger()`. The overall effect of this trigger and function combination is to automatically delete all associated review records from the `\"review\"` table whenever a corresponding book record is deleted from the `\"book\"` table, ensuring referential integrity by cascading deletions based on the `\"Book_ID\"` column.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_book_reviews_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"review\" WHERE \"Book_ID\" = OLD.\"Book_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_book_reviews\n    AFTER DELETE ON \"book\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_book_reviews_trigger();",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "DELETE FROM book WHERE Book_ID = 1;",
      "DELETE FROM book WHERE Book_ID = 2;",
      "DELETE FROM book WHERE Book_ID = 3;",
      "DELETE FROM book WHERE Book_ID = 4;",
      "DELETE FROM book WHERE Book_ID = 5;"
    ],
    "summary": "Create an AFTER DELETE row-level trigger for the book table. For each deleted book row, delete all rows from the review table where the Book_ID matches the deleted book's Book_ID. Return the OLD record.",
    "natural_language": "Please construct an AFTER DELETE row-level trigger for the book table. The trigger's function shall be to delete all corresponding entries from the review table for each deleted book row, specifically those rows where the Book_ID matches the Book_ID of the deleted record. The trigger must then return the OLD record.",
    "id": 5
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `insert_review_trigger` that is designed to be executed as a trigger, and a trigger named `auto_create_review` that invokes this function. The `insert_review_trigger` function takes no explicit parameters but operates within the context of a trigger, meaning it has access to `NEW` and `OLD` pseudo-records. It declares a local variable `next_rank` of type `INTEGER`. The function's execution begins by performing a `SELECT` operation on the `\"review\"` table. Specifically, it calculates the maximum value of the `\"Rank\"` column. If no rows exist in the `\"review\"` table or if the maximum `\"Rank\"` is `NULL`, the `COALESCE` function ensures that `0` is used instead. This calculated maximum value is then incremented by `1`, and the result is stored in the `next_rank` variable. Following this, an `INSERT` operation is performed into the `\"review\"` table. The columns targeted for insertion are `\"Review_ID\"`, `\"Book_ID\"`, `\"Rating\"`, `\"Readers_in_Million\"`, and `\"Rank\"`. The values inserted into these columns are derived as follows: for `\"Review_ID\"`, it uses the value of `NEW.\"Book_ID\"` (which represents the `Book_ID` of the newly inserted row in the `book` table that fired the trigger) multiplied by `100`; for `\"Book_ID\"`, it uses the value of `NEW.\"Book_ID\"`; for `\"Rating\"`, it inserts the literal floating-point value `5.0`; for `\"Readers_in_Million\"`, it inserts the literal floating-point value `1.0`; and for `\"Rank\"`, it uses the value stored in the `next_rank` variable. Finally, the function returns `NEW`, which represents the new row that was just inserted into the `book` table, indicating that the trigger operation was successful and the original `INSERT` into `book` should proceed with the `NEW` row. The `auto_create_review` trigger is defined to execute `AFTER INSERT` operations on the `\"book\"` table. It is configured to fire `FOR EACH ROW` that is inserted into the `\"book\"` table. When activated, this trigger `EXECUTE FUNCTION insert_review_trigger()`, thereby calling the previously described function to automatically create a corresponding review entry for each new book inserted.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_review_trigger() RETURNS TRIGGER AS $$\nDECLARE\n    next_rank INTEGER;\nBEGIN\n    SELECT COALESCE(MAX(\"Rank\"), 0) + 1 INTO next_rank FROM \"review\";\n\n    INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\")\n    VALUES (NEW.\"Book_ID\" * 100, NEW.\"Book_ID\", 5.0, 1.0, next_rank);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER auto_create_review\n    AFTER INSERT ON \"book\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_review_trigger();",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (10, 'The Hobbit', 'Novel', 310, 19, '11h 5m', 'September 1937');",
      "INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (11, '1984', 'Novel', 328, 23, '11h 22m', 'June 1949');",
      "INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (12, 'Pride and Prejudice', 'Novel', 432, 61, '15h 28m', 'January 1813');",
      "INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (13, 'The Catcher in the Rye', 'Novel', 234, 26, '7h 53m', 'July 1951');",
      "INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (14, 'To Kill a Mockingbird', 'Novel', 281, 31, '12h 17m', 'July 1960');"
    ],
    "summary": "Create a trigger function named insert_review_trigger and a trigger named auto_create_review. The function, executed AFTER INSERT on the book table for each row, calculates the next rank by finding the maximum existing rank in the review table (defaulting to 0) and adding 1. It then inserts a new row into the review table using the new book's ID (multiplied by 100 for Review_ID), a rating of 5.0, readers of 1.0 million, and the calculated rank. The function returns NEW.",
    "natural_language": "Alright, so we need to set up a trigger. First, make a trigger function called insert_review_trigger. Then, create the actual trigger itself and name it auto_create_review. Here's the deal: after a new book gets added to the book table, this function kicks in for that new row. It figures out the next rank number by checking the highest rank already in the review table (if there's none, it starts at 0) and just adds 1 to it. Then, it pops a new entry into the review table. For that new entry, it uses the new book's ID times 100 for the Review_ID, sets the rating to a solid 5.0, says there are 1.0 million readers, and slaps on that calculated rank. Finally, the function just hands back the NEW row. That's pretty much it.",
    "id": 6
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `insert_book_trigger` that is designed to be executed in response to data manipulation language (DML) events on a specific table, and a trigger named `create_book_from_review` that invokes this function.\n\nThe `insert_book_trigger` function is defined as `CREATE OR REPLACE FUNCTION insert_book_trigger() RETURNS TRIGGER AS $$ ... $$ LANGUAGE plpgsql;`. This indicates it is a function that returns a `TRIGGER` pseudotype, meaning it is intended to be used as a trigger function. It does not accept any explicit input parameters in its signature, as trigger functions receive their context (like `NEW` and `OLD` records) implicitly.\n\nInside the `insert_book_trigger` function, a single `INSERT` operation is performed. This `INSERT` statement targets the table named `\"book\"`. The `INSERT` statement specifies the columns to be populated: `\"Book_ID\"`, `\"Title\"`, `\"Type\"`, `\"Pages\"`, `\"Chapters\"`, `\"Audio\"`, and `\"Release\"`. The values provided for these columns are as follows:\n- For `\"Book_ID\"`, the value is derived from `NEW.\"Review_ID\" + 1000`. `NEW` refers to the new row that is being inserted into the `review` table (the table on which the trigger is defined). Specifically, it takes the value from the `\"Review_ID\"` column of this new row and adds `1000` to it.\n- For `\"Title\"`, the literal string value `'Generated Book'` is used.\n- For `\"Type\"`, the literal string value `'Novel'` is used.\n- For `\"Pages\"`, the integer literal `300` is used.\n- For `\"Chapters\"`, the integer literal `20` is used.\n- For `\"Audio\"`, the literal string value `'15h 30m'` is used.\n- For `\"Release\"`, the literal string value `'January 2024'` is used.\n\nAfter the `INSERT` operation, the function executes `RETURN NEW;`. In the context of an `AFTER` trigger, `RETURN NEW;` simply indicates that the trigger has completed successfully and does not modify the row that caused the trigger to fire.\n\nThe `create_book_from_review` trigger is defined as `CREATE TRIGGER create_book_from_review AFTER INSERT ON \"review\" FOR EACH ROW EXECUTE FUNCTION insert_book_trigger();`.\n- The trigger is named `create_book_from_review`.\n- It is an `AFTER INSERT` trigger, meaning it will execute after an `INSERT` operation has successfully completed on the table.\n- The trigger is defined `ON \"review\"`, indicating that it will activate whenever a new row is inserted into the table named `\"review\"`.\n- The `FOR EACH ROW` clause specifies that the trigger function (`insert_book_trigger()`) will be executed once for every row that is inserted into the `\"review\"` table.\n- The `EXECUTE FUNCTION insert_book_trigger()` clause specifies that the `insert_book_trigger` function should be called when the trigger fires.\n\nIn summary, whenever a new row is successfully inserted into the `\"review\"` table, this trigger will automatically execute the `insert_book_trigger` function. This function, in turn, will insert a new row into the `\"book\"` table. The `\"Book_ID\"` for this new book will be generated by adding `1000` to the `\"Review_ID\"` of the newly inserted review. The other columns of the new book record (`\"Title\"`, `\"Type\"`, `\"Pages\"`, `\"Chapters\"`, `\"Audio\"`, `\"Release\"`) will be populated with predefined, static literal values.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_book_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (NEW.\"Review_ID\" + 1000, 'Generated Book', 'Novel', 300, 20, '15h 30m', 'January 2024');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER create_book_from_review\n    AFTER INSERT ON \"review\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_book_trigger();",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (1, 1, 8.5, 5.2, 1);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (2, 2, 7.9, 4.8, 2);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (3, 3, 9.1, 6.1, 3);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (4, 4, 7.2, 3.5, 4);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (5, 5, 8.8, 5.9, 5);"
    ],
    "summary": "Create a trigger function named insert_book_trigger and a trigger named create_book_from_review. The function, executed AFTER INSERT on the review table for each row, inserts a new book into the book table. The book's ID is the new review's ID plus 1000. Other columns are set to static values: 'Generated Book' for Title, 'Novel' for Type, 300 for Pages, 20 for Chapters, '15h 30m' for Audio, and 'January 2024' for Release. The function returns NEW.",
    "natural_language": "Set up a trigger and its function so that after a new review is added, it sometimes makes a book entry too. The function, called insert_book_trigger, should run after inserts on the review table. For the new book, its ID should be kind of based on the review's ID, maybe by adding a large number like 1000 to it. For the book details, just use some reasonable placeholder values: a generic title like 'Generated Book', set the type to something common like 'Novel', use a typical page count around 300, a moderate number of chapters like 20, a decent audio length such as '15h 30m', and a recent release period like 'January 2024'. The function should end by returning the new record.",
    "id": 7
  },
  {
    "ir": "Write a PLpgSQL function named update_order_details_on_customer_change that is designed to be executed as a trigger function. This function does not take any parameters directly but operates on the implicit NEW record provided by the trigger mechanism. The function updates the \"Orders\" table, specifically modifying the order_details column. The update operation is performed for rows where the customer_id column matches the customer_id value from the NEW record, which represents the updated row in the \"Customers\" table. The order_details column is set to a string that concatenates the text 'Customer updated: ' with the NEW.customer_first_name and NEW.customer_last_name values, effectively recording the updated customer's first and last name in the order details. The function returns the NEW record, which is standard practice for trigger functions to allow the triggering operation to proceed. The function is associated with a trigger named trg_update_order_details, which is defined to fire after an update operation on the \"Customers\" table. This trigger is specified to execute for each row that is updated, ensuring that the function is called individually for each updated customer record. The trigger uses the AFTER UPDATE timing, meaning it executes after the update operation on the \"Customers\" table has been completed, allowing the function to access the updated values in the NEW record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_details_on_customer_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Orders\" SET order_details = 'Customer updated: ' || NEW.customer_first_name || ' ' || NEW.customer_last_name WHERE customer_id = NEW.customer_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_details\n    AFTER UPDATE ON \"Customers\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_order_details_on_customer_change();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoices",
      "Invoice_Line_Items",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "UPDATE \"Customers\" SET customer_first_name = 'NewFirstName', customer_last_name = 'NewLastName' WHERE customer_id = 1;",
      "UPDATE \"Customers\" SET customer_first_name = 'Updated', customer_last_name = 'Customer' WHERE customer_id = 2;",
      "UPDATE \"Customers\" SET customer_first_name = 'Another', customer_last_name = 'Name' WHERE customer_id = 3;",
      "UPDATE \"Customers\" SET customer_first_name = 'Test', customer_last_name = 'User' WHERE customer_id = 8;",
      "UPDATE \"Customers\" SET customer_first_name = 'Changed', customer_last_name = 'Person' WHERE customer_id = 12;"
    ],
    "summary": "Create a trigger function named update_order_details_on_customer_change and a trigger named trg_update_order_details. The function, executed AFTER UPDATE on the Customers table for each row, updates the order_details column in the Orders table for all rows matching the updated customer's ID. It sets order_details to a concatenated string: 'Customer updated: ' followed by the customer's new first and last names. The function returns NEW.",
    "natural_language": "How can I create a trigger function called update_order_details_on_customer_change and a trigger named trg_update_order_details that, after a customer's details are updated, modifies the order_details column in the Orders table for that customer's orders by setting it to 'Customer updated: ' combined with the new first and last name?",
    "id": 8
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_invoice_line_on_order_item that is executed automatically by a trigger named trg_insert_invoice_line, which is defined to fire AFTER an INSERT operation occurs on the table named \"Order_Items\" for each new row added, and this function performs a single INSERT operation into the table named \"Invoice_Line_Items\", populating its columns with specific values: the order_item_id column receives the value from the NEW.order_item_id field of the newly inserted \"Order_Items\" row, the product_id column receives the value from the NEW.product_id field, the product_title column is set to the literal string 'Product from Order', the product_quantity column receives the value from the NEW.product_quantity field, the product_price column is set to the fixed numeric value 100.00, the derived_product_cost column is set to the fixed numeric value 50.00, and the derived_total_cost column is set to the fixed numeric value 150.00, after which the function returns the NEW row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_invoice_line_on_order_item() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Invoice_Line_Items\" (order_item_id, product_id, product_title, product_quantity, product_price, derived_product_cost, derived_total_cost) VALUES (NEW.order_item_id, NEW.product_id, 'Product from Order', NEW.product_quantity, 100.00, 50.00, 150.00);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_invoice_line\n    AFTER INSERT ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_invoice_line_on_order_item();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoices",
      "Invoice_Line_Items",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (1, 1, 101, '2');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (2, 1, 102, '1');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (3, 2, 201, '3');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (4, 3, 305, '5');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (5, 4, 401, '1');"
    ],
    "summary": "Create a trigger function named insert_invoice_line_on_order_item and a trigger named trg_insert_invoice_line. The function, executed AFTER INSERT on the Order_Items table for each row, inserts a new row into the Invoice_Line_Items table. It populates the columns using values from the new order item (order_item_id, product_id, product_quantity) and sets static values for product_title ('Product from Order'), product_price (100.00), derived_product_cost (50.00), and derived_total_cost (150.00). The function returns NEW.",
    "natural_language": "Alright, so we need a trigger function called insert_invoice_line_on_order_item and a trigger named trg_insert_invoice_line. Here's the deal: every time a new row gets added to the Order_Items table, this function kicks in right after. For each new order item, it'll automatically slap a new row into the Invoice_Line_Items table. It grabs the order_item_id, product_id, and product_quantity from the fresh order item. Then it fills in the rest with some fixed stuff: the product_title is always 'Product from Order', price is set at 100 bucks, cost is 50, and the total cost comes out to 150. Oh, and the function just hands back the NEW record at the end.",
    "id": 9
  },
  {
    "ir": "Write a PLpgSQL trigger function that is invoked before a row is deleted from the \"Accounts\" table. The function, named delete_account_transactions, does not take any parameters directly but operates using the OLD record, which represents the row being deleted from the \"Accounts\" table. The function performs a DELETE operation on the \"Financial_Transactions\" table, removing all rows where the account_id column matches the account_id of the OLD record from the \"Accounts\" table. This ensures that all financial transactions associated with the account being deleted are also removed. The function then returns the OLD record, which is standard practice for trigger functions to allow the deletion operation on the \"Accounts\" table to proceed. The trigger, named trg_delete_account_transactions, is defined to execute this function before any DELETE operation on the \"Accounts\" table, ensuring that the associated transactions are cleaned up prior to the account's removal.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_account_transactions() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Financial_Transactions\" WHERE account_id = OLD.account_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_account_transactions\n    BEFORE DELETE ON \"Accounts\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_account_transactions();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoices",
      "Invoice_Line_Items",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "DELETE FROM \"Accounts\" WHERE account_id = 1;",
      "DELETE FROM \"Accounts\" WHERE account_id = 2;",
      "DELETE FROM \"Accounts\" WHERE account_id = 3;",
      "DELETE FROM \"Accounts\" WHERE account_id = 4;",
      "DELETE FROM \"Accounts\" WHERE account_id = 5;"
    ],
    "summary": "Create a trigger function named delete_account_transactions and a trigger named trg_delete_account_transactions. The function, executed BEFORE DELETE on the Accounts table for each row, deletes all rows from the Financial_Transactions table where the account_id matches the ID of the account being deleted. The function returns OLD.",
    "natural_language": "Please implement a trigger function designated as 'delete_account_transactions' along with an associated trigger named 'trg_delete_account_transactions'. This function is to be invoked BEFORE a DELETE operation on the Accounts table for each individual row. Its purpose is to remove all corresponding entries from the Financial_Transactions table where the account_id corresponds to the ID of the account slated for deletion. The function shall return the OLD record.",
    "id": 10
  },
  {
    "ir": "Write a PostgreSQL trigger function named create_invoice_for_order that is automatically executed as an AFTER INSERT trigger on the \"Orders\" table for each new row inserted, which performs a single INSERT operation into the \"Invoices\" table, generating values for the invoice_number, order_id, and invoice_date columns; the invoice_number is derived by querying the \"Invoices\" table to find the current maximum value in the invoice_number column, using the COALESCE function to return 0 if no maximum exists (i.e., the table is empty), and then adding 1 to this value to create a new sequential number; the order_id for the new invoice is taken directly from the NEW pseudo-record's order_id field, which represents the order_id value of the newly inserted row in the \"Orders\" table; the invoice_date is set to the current date and time using the CURRENT_TIMESTAMP function; after the INSERT, the function returns the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION create_invoice_for_order() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES ((SELECT COALESCE(MAX(invoice_number), 0) + 1 FROM \"Invoices\"), NEW.order_id, CURRENT_TIMESTAMP);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_create_invoice_for_order\n    AFTER INSERT ON \"Orders\"\n    FOR EACH ROW\n    EXECUTE FUNCTION create_invoice_for_order();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoices",
      "Invoice_Line_Items",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (4, 12, '2023-10-01 10:00:00+08:00', 'Order details 1');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (5, 8, '2023-10-02 11:00:00+08:00', 'Order details 2');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (6, 3, '2023-10-03 12:00:00+08:00', 'Order details 3');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (7, 1, '2023-10-04 13:00:00+08:00', 'Order details 4');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (8, 2, '2023-10-05 14:00:00+08:00', 'Order details 5');"
    ],
    "summary": "Create an AFTER INSERT trigger function named create_invoice_for_order on the Orders table. For each new order, insert a row into the Invoices table. Generate the invoice_number by taking the maximum existing value plus one (or start at 1 if the table is empty). Set order_id to the new order's ID and invoice_date to the current timestamp. Return the NEW record.",
    "natural_language": "Create an AFTER INSERT trigger function called create_invoice_for_order on the Orders table. For every new order, insert a corresponding record into the Invoices table. Generate the invoice_number by incrementing the current maximum value by one, or start at 1 if the table is empty. Set the order_id to the new order's ID and the invoice_date to the current timestamp. Finally, return the NEW record.",
    "id": 11
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_delivery_status that returns a trigger, which is automatically executed by a trigger named trg_update_delivery_status defined on the Actual_Orders table to fire after every row update operation, and within this function, for each updated row, it performs an update on the Order_Deliveries table, specifically setting the delivery_status_code column to the result of applying the LOWER function to the NEW.order_status_code value, which converts the new order status code string to lowercase, and this update is applied only to those rows in the Order_Deliveries table where the actual_order_id column matches the NEW.actual_order_id value from the triggering row in the Actual_Orders table, and finally the function returns the NEW row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION update_delivery_status() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Order_Deliveries\" SET delivery_status_code = LOWER(NEW.order_status_code) WHERE actual_order_id = NEW.actual_order_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_delivery_status\nAFTER UPDATE ON \"Actual_Orders\"\nFOR EACH ROW EXECUTE FUNCTION update_delivery_status();",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Order_Products",
      "Actual_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Customers"
    ],
    "call_sqls": [
      "UPDATE \"Actual_Orders\" SET order_status_code = 'Success' WHERE actual_order_id = 1;",
      "UPDATE \"Actual_Orders\" SET order_status_code = 'Cancel' WHERE actual_order_id = 2;",
      "UPDATE \"Actual_Orders\" SET order_status_code = 'Success' WHERE actual_order_id = 3;",
      "UPDATE \"Actual_Orders\" SET order_status_code = 'Cancel' WHERE actual_order_id = 1;",
      "UPDATE \"Actual_Orders\" SET order_status_code = 'Success' WHERE actual_order_id = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_delivery_status on the Actual_Orders table. For each updated row, update the Order_Deliveries table. Set delivery_status_code to the lowercase value of the new order_status_code, but only for rows where actual_order_id matches the updated order's ID. Return the NEW record.",
    "natural_language": "Please construct an AFTER UPDATE trigger function designated as 'update_delivery_status' on the Actual_Orders table. For every row that is updated, it is required to modify the Order_Deliveries table. Specifically, set the delivery_status_code to the lowercase equivalent of the new order_status_code, but restrict this operation to those rows in the Order_Deliveries table where the actual_order_id corresponds to the ID of the updated order. The function should conclude by returning the NEW record.",
    "id": 12
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_order_product that returns a trigger and is invoked by a trigger named trg_update_order_product, which is defined to fire after any row is updated on the table named \"Actual_Order_Products\" for each affected row, where the function body contains a single comment stating that the trigger should be on the Actual_Order_Products table and not on Actual_Orders because Actual_Orders lacks a product_id column, and the function concludes by returning the NEW row record variable without performing any data manipulation, conditional logic, or other operations.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_product() RETURNS TRIGGER AS $$\nBEGIN\n  -- This trigger should be on Actual_Order_Products table, not Actual_Orders\n  -- Since Actual_Orders doesn't have product_id column\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_product\nAFTER UPDATE ON \"Actual_Order_Products\"\nFOR EACH ROW EXECUTE FUNCTION update_order_product();",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Order_Products",
      "Actual_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Customers"
    ],
    "call_sqls": [
      "UPDATE \"Actual_Order_Products\" SET product_id = 2 WHERE actual_order_id = 2 AND product_id = 1;",
      "UPDATE \"Actual_Order_Products\" SET actual_order_id = 15 WHERE actual_order_id = 14 AND product_id = 5;",
      "UPDATE \"Actual_Order_Products\" SET product_id = 7 WHERE actual_order_id = 13 AND product_id = 6;",
      "UPDATE \"Actual_Order_Products\" SET actual_order_id = 1 WHERE actual_order_id = 2 AND product_id = 2;",
      "UPDATE \"Actual_Order_Products\" SET product_id = 10 WHERE actual_order_id = 15 AND product_id = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_order_product on the Actual_Order_Products table. The function should contain a comment explaining the trigger is on this table because Actual_Orders lacks product_id. Perform no data operations and return the NEW record.",
    "natural_language": "Set up a trigger function that runs after updates on that order products table. Call it something like update_order_product. It should have a note in it saying why we're using this table and not the main orders one, since the main one doesn't track product details. The function itself shouldn't really change any data; just have it give back the new record info.",
    "id": 13
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Customer_Addresses\" table. The function, named archive_old_addresses, takes no parameters directly but operates on the NEW record being inserted. It performs a delete operation on the \"Customer_Addresses\" table, removing any existing records where the customer_id matches the customer_id of the NEW record being inserted, the date_to column is NULL, indicating the address is currently active, and the address_id is not equal to the address_id of the NEW record. This ensures that only the newly inserted address remains active for the customer, effectively archiving any previous active addresses. The function then returns the NEW record, allowing the insert operation to proceed with the new address. The trigger named trigger_archive_old_addresses is defined to execute this function before each row is inserted into the \"Customer_Addresses\" table, ensuring the archival process is applied to every new address insertion.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_old_addresses() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Customer_Addresses\"\n    WHERE customer_id = NEW.customer_id\n    AND date_to IS NULL\n    AND address_id != NEW.address_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_archive_old_addresses\nBEFORE INSERT ON \"Customer_Addresses\"\nFOR EACH ROW\nEXECUTE FUNCTION archive_old_addresses();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products",
      "Customer_Addresses",
      "Department_Stores",
      "Departments"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Addresses\" (customer_id, address_id, date_from) VALUES (2, 9, '2023-10-01 10:00:00+08:00');",
      "INSERT INTO \"Customer_Addresses\" (customer_id, address_id, date_from) VALUES (1, 6, '2023-10-02 11:00:00+08:00');",
      "INSERT INTO \"Customer_Addresses\" (customer_id, address_id, date_from) VALUES (10, 8, '2023-10-03 12:00:00+08:00');",
      "INSERT INTO \"Customer_Addresses\" (customer_id, address_id, date_from) VALUES (2, 8, '2023-10-04 13:00:00+08:00');",
      "INSERT INTO \"Customer_Addresses\" (customer_id, address_id, date_from) VALUES (1, 9, '2023-10-05 14:00:00+08:00');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named archive_old_addresses on the Customer_Addresses table. For each new address, delete any existing active addresses (where date_to is NULL) for the same customer, except the one being inserted. This ensures only the new address remains active. Return the NEW record.",
    "natural_language": "Create a BEFORE INSERT trigger named archive_old_addresses for the Customer_Addresses table. For each new address, ensure you delete any existing active addresses (where date_to is NULL) for the same customer, but exclude the new address being inserted. This will keep only the new address as active. Finally, return the NEW record.",
    "id": 14
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an insert operation on the \"Order_Items\" table. This function, named remove_product_from_order, does not take any parameters directly but operates on the NEW record, which represents the row being inserted. The function performs a DELETE operation on the \"Order_Items\" table, targeting rows where the order_id matches the order_id of the newly inserted row (NEW.order_id) and the product_id is found within a modified array. This array is initially composed of the integers 1, 2, and 3, cast to an array of type bigint. The function uses the array_remove function to exclude the product_id of the newly inserted row (NEW.product_id) from this array. The DELETE operation thus removes any existing order items that have the same order_id as the new row and a product_id that is either 1, 2, or 3, except for the product_id of the newly inserted row. After performing the DELETE operation, the function returns the NEW record, allowing the insert operation to proceed. The trigger, named trigger_remove_product_from_order, is defined to execute this function after each row is inserted into the \"Order_Items\" table, ensuring that the described logic is applied to every new insertion.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_product_from_order() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Order_Items\"\n    WHERE order_id = NEW.order_id\n    AND product_id = ANY(array_remove(ARRAY[1, 2, 3]::bigint[], NEW.product_id));\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_remove_product_from_order\nAFTER INSERT ON \"Order_Items\"\nFOR EACH ROW\nEXECUTE FUNCTION remove_product_from_order();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products",
      "Customer_Addresses",
      "Department_Stores",
      "Departments"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (100, 1, 1);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (101, 1, 2);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (102, 1, 3);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (103, 2, 1);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (104, 2, 4);"
    ],
    "summary": "Create an AFTER INSERT trigger function named remove_product_from_order on the Order_Items table. For each new item inserted, delete any other items in the same order that have a product_id of 1, 2, or 3, but exclude the product_id of the newly inserted row from this deletion. Return the NEW record.",
    "natural_language": "Alright, so set up a trigger function called remove_product_from_order that kicks in AFTER we INSERT something into the Order_Items table. Basically, whenever a new item gets added, it should clean out any other items in that same order that have a product_id of 1, 2, or 3. But hey, don't touch the product_id we just inserted—leave that one alone. After all that, just hand back the NEW record.",
    "id": 15
  },
  {
    "ir": "Write a PostgreSQL trigger function named adjust_stock_quantity that returns a trigger, which is invoked automatically after each row update operation on the shop table, but only when the old value of the Shop_Name column is different from the new value of the Shop_Name column for that specific row; within this function, a local integer variable v_device_id is declared, then a SELECT query is executed on the device table to retrieve a single Device_ID value from any row where the Carrier column exactly equals the string 'Verizon Wireless', and this retrieved value is stored into v_device_id; if the v_device_id variable is not null, an INSERT operation is performed into the stock table, populating the Shop_ID column with the new Shop_ID value from the updated shop row, the Device_ID column with the v_device_id value obtained from the query, and the Quantity column with the integer value 50; finally, the function returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_stock_quantity() RETURNS TRIGGER AS $$\nDECLARE\n    v_device_id INTEGER;\nBEGIN\n    SELECT \"Device_ID\" INTO v_device_id\n    FROM device\n    WHERE \"Carrier\" = 'Verizon Wireless'\n    LIMIT 1;\n    \n    IF v_device_id IS NOT NULL THEN\n        INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n        VALUES (NEW.\"Shop_ID\", v_device_id, 50);\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_adjust_stock_quantity\n    AFTER UPDATE ON shop\n    FOR EACH ROW\n    WHEN (OLD.\"Shop_Name\" IS DISTINCT FROM NEW.\"Shop_Name\")\n    EXECUTE FUNCTION adjust_stock_quantity();",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "UPDATE shop SET \"Shop_Name\" = 'New Shop Name 1' WHERE \"Shop_ID\" = 1;",
      "UPDATE shop SET \"Shop_Name\" = 'New Shop Name 2' WHERE \"Shop_ID\" = 2;",
      "UPDATE shop SET \"Shop_Name\" = 'New Shop Name 3' WHERE \"Shop_ID\" = 3;",
      "UPDATE shop SET \"Shop_Name\" = 'Updated Best Buy' WHERE \"Shop_Name\" = 'Best Buy';",
      "UPDATE shop SET \"Shop_Name\" = 'Updated Dinas Device' WHERE \"Shop_ID\" = 1;"
    ],
    "summary": "Create a PostgreSQL trigger function named adjust_stock_quantity that fires AFTER UPDATE on the shop table for each row, but only when the Shop_Name changes. It retrieves a Device_ID from the device table where Carrier is 'Verizon Wireless'. If found, it inserts a new row into the stock table with the updated Shop_ID, the retrieved Device_ID, and a Quantity of 50. The function returns the NEW row.",
    "natural_language": "Construct a PostgreSQL trigger function, which should be named adjust_stock_quantity, designed to activate automatically AFTER an UPDATE operation is performed on the shop table, specifically for each individual row, but it must only execute its logic when the Shop_Name column's value is actually modified. This detailed function will then proceed to carefully retrieve a single Device_ID from the extensive device table, but only for entries where the Carrier field is precisely set to 'Verizon Wireless'. Should such a device be successfully located, the function will meticulously insert a brand new row into the stock table, populating it with the recently updated Shop_ID, the specific Device_ID that was just retrieved, and a predetermined Quantity of 50. Finally, the function will gracefully return the NEW row to complete the operation.",
    "id": 16
  },
  {
    "ir": "Write a PLpgSQL trigger function that is invoked before a row is deleted from the shop table. The function, named delete_related_stock, does not take any parameters directly but operates in the context of a trigger. It performs a delete operation on the stock table, removing all rows where the Shop_ID column matches the Shop_ID value of the row being deleted from the shop table. The OLD keyword is used to reference the Shop_ID of the row that is about to be deleted from the shop table. After executing the delete operation, the function returns the OLD record, which represents the row that was deleted from the shop table. The trigger, named trg_delete_related_stock, is defined to execute this function before any delete operation on the shop table, ensuring that related stock records are removed whenever a shop record is deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_stock() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM stock WHERE \"Shop_ID\" = OLD.\"Shop_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_related_stock\n    BEFORE DELETE ON shop\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_related_stock();",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "DELETE FROM shop WHERE Shop_ID = 1;",
      "DELETE FROM shop WHERE Shop_ID = 2;",
      "DELETE FROM shop WHERE Shop_ID = 3;",
      "DELETE FROM shop WHERE Shop_Name = 'Best Buy';",
      "DELETE FROM shop WHERE Location = 'Dinas';"
    ],
    "summary": "Create a PostgreSQL trigger function named delete_related_stock that fires BEFORE DELETE on the shop table for each row. It deletes all rows from the stock table where the Shop_ID matches the OLD.Shop_ID. The function returns the OLD row.",
    "natural_language": "Set up a trigger function called delete_related_stock that runs before a shop entry is removed. It should clear out any stock records that seem to be linked to that shop's ID, more or less matching the old shop ID. The function should then give back the original row that's being deleted.",
    "id": 17
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `auto_assign_charge_id` that is designed to automatically generate a unique identifier for new charge records, and then create a trigger named `trg_auto_assign_charge_id` that executes this function before each new row is inserted into the `Charges` table. The `auto_assign_charge_id` function is defined to return a `TRIGGER` type, indicating its purpose as a trigger function. It does not accept any explicit input parameters, but as a trigger function, it implicitly operates on special record variables: `NEW` (representing the new row being inserted or updated) and `OLD` (representing the old row before an update or delete, though `OLD` is not used in this specific function). Inside the function's `BEGIN...END` block, the primary operation is an assignment to the `charge_id` column of the `NEW` record. Specifically, `NEW.charge_id` is assigned a value derived from a `SELECT` statement. This `SELECT` statement queries the `Charges` table to find the maximum existing value in the `charge_id` column. The `COALESCE` function is used to handle cases where the `SELECT MAX(charge_id)` operation might return `NULL` (which would happen if the `Charges` table is empty or if all existing `charge_id` values are `NULL`). If `MAX(charge_id)` returns `NULL`, `COALESCE` substitutes `0` for `NULL`. This result (either the maximum `charge_id` or `0`) is then incremented by `1`. The final calculated value is then assigned to `NEW.charge_id`. After this assignment, the function concludes by returning the `NEW` record, which contains the newly assigned `charge_id` value, allowing the insertion operation to proceed with this modified row. The `trg_auto_assign_charge_id` trigger is then defined to activate `BEFORE INSERT` operations on the table named `\"Charges\"`. The `FOR EACH ROW` clause specifies that the trigger function `auto_assign_charge_id()` should be executed once for every row that is being inserted into the `\"Charges\"` table. The `EXECUTE FUNCTION auto_assign_charge_id()` clause specifies that the previously defined PL/pgSQL function `auto_assign_charge_id` is the routine to be executed when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION auto_assign_charge_id() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.charge_id := COALESCE((SELECT MAX(charge_id) FROM \"Charges\"), 0) + 1;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_auto_assign_charge_id\n    BEFORE INSERT ON \"Charges\"\n    FOR EACH ROW\n    EXECUTE FUNCTION auto_assign_charge_id();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Charges\" (charge_type, charge_amount) VALUES ('Daily Accommodation', 98.00);",
      "INSERT INTO \"Charges\" (charge_type, charge_amount) VALUES ('Drugs', 322.00);",
      "INSERT INTO \"Charges\" (charge_type, charge_amount) VALUES ('Health Check', 640.00);",
      "INSERT INTO \"Charges\" (charge_type, charge_amount) VALUES ('Grooming', 75.50);",
      "INSERT INTO \"Charges\" (charge_type, charge_amount) VALUES ('Training Session', 120.00);"
    ],
    "summary": "Create a PostgreSQL trigger function named auto_assign_charge_id that fires BEFORE INSERT on the Charges table for each row. It assigns a new charge_id to NEW.charge_id by taking the maximum existing charge_id (or 0 if NULL) and adding 1. The function returns the NEW row.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called auto_assign_charge_id? It should kick in BEFORE any new row gets INSERTed into the Charges table. For each new row, it's gotta set the NEW.charge_id by grabbing the biggest charge_id we already have (or just start at 0 if there's none) and then bumping it up by 1. Oh, and the function needs to spit back that NEW row.",
    "id": 18
  },
  {
    "ir": "Write a PostgreSQL trigger function named validate_dog_weight that returns a trigger and is executed automatically by a trigger named trg_validate_dog_weight, which is defined to fire BEFORE any INSERT or UPDATE operation on the table named \"Dogs\" for each individual row being processed; the function's logic operates on the NEW row variable, specifically its weight column, and uses a CASE statement to evaluate and potentially modify the weight value: first, it explicitly casts the NEW.weight value to the NUMERIC data type and checks if it is less than 0.5, and if this condition is true, it sets the NEW.weight value to the string '0.5'; if the first condition is false, it proceeds to check if the cast NUMERIC value of NEW.weight is greater than 100, and if this condition is true, it sets NEW.weight to the string '100'; if neither condition is met, it leaves the NEW.weight value unchanged, and finally, the function returns the modified NEW row record to the triggering statement.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_dog_weight() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.weight := CASE \n        WHEN CAST(NEW.weight AS NUMERIC) < 0.5 THEN '0.5'\n        WHEN CAST(NEW.weight AS NUMERIC) > 100 THEN '100'\n        ELSE NEW.weight\n    END;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_dog_weight\n    BEFORE INSERT OR UPDATE ON \"Dogs\"\n    FOR EACH ROW\n    EXECUTE FUNCTION validate_dog_weight();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (4, 2, '0', 'HUS', 'MED', 'Buddy', '5', '2015-06-15 10:00:00+08:00', '1', '0.3', '2023-10-01 10:00:00+08:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (5, 3, '1', 'BUL', 'LGE', 'Max', '7', '2016-04-20 10:00:00+08:00', '0', '150', '2023-10-02 10:00:00+08:00', NULL, NULL);",
      "UPDATE \"Dogs\" SET weight = '0.2' WHERE dog_id = 1;",
      "UPDATE \"Dogs\" SET weight = '120' WHERE dog_id = 2;",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (6, 1, '0', 'ESK', 'SML', 'Charlie', '3', '2020-01-10 10:00:00+08:00', '1', '0.4', '2023-10-03 10:00:00+08:00', NULL, NULL);"
    ],
    "summary": "Create a PostgreSQL trigger function named validate_dog_weight that fires BEFORE INSERT OR UPDATE on the Dogs table for each row. It validates the NEW.weight value: if less than 0.5, set it to '0.5'; if greater than 100, set it to '100'. The function returns the modified NEW row.",
    "natural_language": "Create trigger function validate_dog_weight for Dogs table. Before insert or update per row, cap NEW.weight: min 0.5, max 100. Return NEW.",
    "id": 19
  },
  {
    "ir": "Write a PostgreSQL trigger function named normalize_owner_data that is executed automatically by a trigger named trg_normalize_owner_data before any INSERT or UPDATE operation on the \"Owners\" table for each affected row, which processes the NEW row variable containing the incoming column values, specifically taking the first_name column value, applying the TRIM function to remove leading and trailing whitespace, then applying the UPPER function to convert all alphabetical characters to uppercase, and assigning this transformed value back to the NEW.first_name column, then taking the last_name column value, applying the TRIM function to remove leading and trailing whitespace, then applying the UPPER function to convert all alphabetical characters to uppercase, and assigning this transformed value back to the NEW.last_name column, then taking the email_address column value, applying the TRIM function to remove leading and trailing whitespace, and assigning this cleaned value back to the NEW.email_address column, and finally returning the modified NEW row variable to the database engine for the subsequent INSERT or UPDATE operation.",
    "plsql": "CREATE OR REPLACE FUNCTION normalize_owner_data() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.first_name := UPPER(TRIM(NEW.first_name));\n    NEW.last_name := UPPER(TRIM(NEW.last_name));\n    NEW.email_address := TRIM(NEW.email_address);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_normalize_owner_data\n    BEFORE INSERT OR UPDATE ON \"Owners\"\n    FOR EACH ROW\n    EXECUTE FUNCTION normalize_owner_data();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Owners\" (owner_id, first_name, last_name, email_address) VALUES (101, '  john  ', '  DOE  ', 'john.doe@example.com   ');",
      "INSERT INTO \"Owners\" (owner_id, first_name, last_name, email_address) VALUES (102, '  jane', 'SMITH   ', 'jane.smith@example.org');",
      "UPDATE \"Owners\" SET first_name = '  peter ', last_name = '  jones  ', email_address = 'peter.jones@example.net ' WHERE owner_id = 1;",
      "INSERT INTO \"Owners\" (owner_id, first_name, last_name, email_address) VALUES (103, '  alice ', '  WILLIAMS', 'alice.williams@example.com');",
      "UPDATE \"Owners\" SET first_name = '  bob', last_name = '  BROWN', email_address = 'bob.brown@example.org   ' WHERE owner_id = 2;"
    ],
    "summary": "Create a PostgreSQL trigger function named normalize_owner_data that fires BEFORE INSERT OR UPDATE on the Owners table for each row. It trims and uppercases the NEW.first_name and NEW.last_name values, and trims the NEW.email_address value. The function returns the modified NEW row.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called normalize_owner_data? It should kick in BEFORE we INSERT or UPDATE a row in the Owners table. For each row, it needs to clean up the data: trim and uppercase the NEW.first_name and NEW.last_name, and just trim the NEW.email_address. The function should then hand back the tweaked NEW row.",
    "id": 20
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `format_professional_phone` that is designed to be executed before an `INSERT` or `UPDATE` operation on the table named `\"Professionals\"`. This function operates on a row-by-row basis. Upon execution, it first accesses the `home_phone` column of the `NEW` record (representing the row being inserted or updated) and modifies its value. The modification involves extracting a substring from the original `home_phone` value, starting from the first character and extending for a maximum of 15 characters. This truncated string then replaces the original value in the `home_phone` column of the `NEW` record. Subsequently, the function performs a similar operation on the `cell_number` column of the `NEW` record. It extracts a substring from the original `cell_number` value, starting from the first character and extending for a maximum of 15 characters. This truncated string then replaces the original value in the `cell_number` column of the `NEW` record. Finally, the function returns the modified `NEW` record, allowing the `INSERT` or `UPDATE` operation to proceed with the formatted phone numbers. This trigger function is associated with a trigger named `trg_format_professional_phone`, which is configured to fire `BEFORE` any `INSERT` or `UPDATE` event on the `\"Professionals\"` table, `FOR EACH ROW`, and executes the `format_professional_phone()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION format_professional_phone() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.home_phone := SUBSTR(NEW.home_phone, 1, 15);\n    NEW.cell_number := SUBSTR(NEW.cell_number, 1, 15);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_format_professional_phone\n    BEFORE INSERT OR UPDATE ON \"Professionals\"\n    FOR EACH ROW\n    EXECUTE FUNCTION format_professional_phone();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Professionals\" (professional_id, role_code, first_name, street, city, state, zip_code, last_name, email_address, home_phone, cell_number) VALUES (101, 'Employee', 'John', '123 Main St', 'Anytown', 'CA', '90210', 'Doe', 'john.doe@example.com', '123-456-78901234567890', '987-654-32101234567890');",
      "UPDATE \"Professionals\" SET home_phone = '111-222-3333444455556666', cell_number = '777-888-9999000011112222' WHERE professional_id = 1;",
      "INSERT INTO \"Professionals\" (professional_id, role_code, first_name, street, city, state, zip_code, last_name, email_address, home_phone, cell_number) VALUES (102, 'Employee', 'Jane', '456 Oak Ave', 'Otherville', 'NY', '10001', 'Smith', 'jane.smith@example.com', '(555) 123-4567 ext 12345', '555-987-6543 ext 67890');",
      "UPDATE \"Professionals\" SET home_phone = '000-111-2222', cell_number = '333-444-5555' WHERE professional_id = 2;",
      "INSERT INTO \"Professionals\" (professional_id, role_code, first_name, street, city, state, zip_code, last_name, email_address, home_phone, cell_number) VALUES (103, 'Employee', 'Peter', '789 Pine Ln', 'Smalltown', 'TX', '75001', 'Jones', 'peter.jones@example.com', '1-800-CALL-NOW-1234567890', '1-800-BUY-THIS-1234567890');"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named format_professional_phone for the \"Professionals\" table. For each row, truncate the home_phone and cell_number values to a maximum of 15 characters. Return the modified NEW record.",
    "natural_language": "Construct a BEFORE INSERT OR UPDATE trigger function, which should be named format_professional_phone, specifically for the 'Professionals' table. For every individual row being processed, meticulously truncate both the home_phone and the cell_number field values, ensuring they do not exceed a maximum length of fifteen characters. Finally, the function must return the appropriately modified NEW record.",
    "id": 21
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_gymnast_total_points` that is designed to be executed as a `BEFORE INSERT OR UPDATE` trigger on the `gymnast` table. This function does not accept any explicit input parameters but implicitly receives special `NEW` and `OLD` records from the trigger mechanism. The `NEW` record represents the row that is about to be inserted or updated, while the `OLD` record represents the row's state before the update (or is NULL for an insert). The function's purpose is to calculate and set the value of the `Total_Points` column in the `NEW` record. Specifically, it calculates `NEW.\"Total_Points\"` by summing the values from several other columns within the `NEW` record: `NEW.\"Floor_Exercise_Points\"`, `NEW.\"Pommel_Horse_Points\"`, `NEW.\"Rings_Points\"`, `NEW.\"Parallel_Bars_Points\"`, and `NEW.\"Horizontal_Bar_Points\"`. For the `NEW.\"Vault_Points\"` column, it uses the `COALESCE` function to handle potential `NULL` values, treating a `NULL` `NEW.\"Vault_Points\"` as `0` for the sum calculation. After performing this calculation and assigning the result to `NEW.\"Total_Points\"`, the function returns the modified `NEW` record, allowing the database to proceed with the `INSERT` or `UPDATE` operation using the updated `Total_Points` value.\n\nAccompanying this function is a trigger named `trg_update_gymnast_total_points`. This trigger is configured to activate `BEFORE` any `INSERT` or `UPDATE` operation performed on the `gymnast` table. It is defined as a `FOR EACH ROW` trigger, meaning that the `update_gymnast_total_points` function will be executed once for each row affected by the `INSERT` or `UPDATE` statement. The trigger's action is to `EXECUTE FUNCTION update_gymnast_total_points()`, thereby invoking the previously described function to automatically calculate and update the `Total_Points` column for each new or modified gymnast record before it is permanently stored in the `gymnast` table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_gymnast_total_points() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Total_Points\" := NEW.\"Floor_Exercise_Points\" + NEW.\"Pommel_Horse_Points\" + NEW.\"Rings_Points\" + COALESCE(NEW.\"Vault_Points\", 0) + NEW.\"Parallel_Bars_Points\" + NEW.\"Horizontal_Bar_Points\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_gymnast_total_points\n    BEFORE INSERT OR UPDATE ON gymnast\n    FOR EACH ROW\n    EXECUTE FUNCTION update_gymnast_total_points();",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\") VALUES (10, 9.5, 9.3, 9.4, 9.6, 9.2, 9.7);",
      "UPDATE gymnast SET \"Vault_Points\" = 9.8 WHERE \"Gymnast_ID\" = 1;",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\") VALUES (11, 8.9, 9.1, 9.0, 9.3, 9.4);",
      "UPDATE gymnast SET \"Floor_Exercise_Points\" = 9.9, \"Horizontal_Bar_Points\" = 9.8 WHERE \"Gymnast_ID\" = 2;",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\") VALUES (12, 9.8, 9.9, 9.7, NULL, 9.6, 9.5);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named update_gymnast_total_points for the gymnast table. For each row, calculate Total_Points as the sum of Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Parallel_Bars_Points, Horizontal_Bar_Points, and COALESCE(Vault_Points, 0). Return the modified NEW record.",
    "natural_language": "Alright, so we need a trigger function called update_gymnast_total_points that fires off before any new entry is added or an existing one is updated in the gymnast table. For each gymnast row, we gotta figure out their Total_Points. Just add up their scores from the Floor_Exercise, Pommel_Horse, Rings, Parallel_Bars, and Horizontal_Bar. Oh, and for the Vault_Points, if it's missing, just treat it as a zero. Once that's done, hand back the updated NEW record.",
    "id": 22
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically inserts a new row into the people table whenever a new row is inserted into the gymnast table. The function is named insert_new_gymnast_in_people and is designed to be executed as a trigger. It operates after an insert event on the gymnast table, for each row that is inserted. The function does not take any parameters directly, but it utilizes the NEW record, which represents the newly inserted row in the gymnast table. The function performs an INSERT operation into the people table, with the following column values: \"People_ID\" is set to the value of NEW.\"Gymnast_ID\" from the gymnast table, \"Name\" is set to the string 'New Gymnast', \"Age\" is set to the numeric value 20.0, \"Height\" is set to the numeric value 1.70, and \"Hometown\" is set to the string 'Unknown'. This insertion is conditional, executed only if there is no existing row in the people table with a \"People_ID\" that matches NEW.\"Gymnast_ID\". This condition is checked using a WHERE NOT EXISTS clause, which performs a subquery to select 1 from the people table where \"People_ID\" equals NEW.\"Gymnast_ID\". If no such row exists, the insertion proceeds. The function returns the NEW record, which is standard practice for trigger functions to allow the triggering operation to continue. The trigger associated with this function is named trg_insert_new_gymnast_in_people, and it is defined to execute the function after an insert operation on the gymnast table, ensuring that the function is called for each new row inserted into the gymnast table.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_new_gymnast_in_people() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO people (\"People_ID\", \"Name\", \"Age\", \"Height\", \"Hometown\") SELECT NEW.\"Gymnast_ID\", 'New Gymnast', 20.0, 1.70, 'Unknown' WHERE NOT EXISTS (SELECT 1 FROM people WHERE \"People_ID\" = NEW.\"Gymnast_ID\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_new_gymnast_in_people\n    AFTER INSERT ON gymnast\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_new_gymnast_in_people();",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (3, 9.8, 9.7, 9.6, 9.5, 9.7, 9.8, 58.1);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (5, 9.6, 9.5, 9.4, 9.3, 9.6, 9.7, 57.1);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (6, 9.9, 9.8, 9.7, 9.6, 9.8, 9.9, 59.1);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (7, 9.7, 9.6, 9.5, 9.4, 9.7, 9.8, 58.0);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (8, 9.5, 9.4, 9.3, 9.2, 9.5, 9.6, 56.5);"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_new_gymnast_in_people for the gymnast table. For each new row, insert a corresponding record into the people table with People_ID set to NEW.Gymnast_ID, Name as 'New Gymnast', Age as 20.0, Height as 1.70, and Hometown as 'Unknown', but only if a record with that People_ID does not already exist. Return the NEW record.",
    "natural_language": "Construct an AFTER INSERT trigger function, which should be named insert_new_gymnast_in_people, specifically for the gymnast table. For every single new row that is successfully inserted, you must carefully insert a corresponding and detailed record into the people table. This new record should meticulously assign the People_ID to the value from NEW.Gymnast_ID, set the Name to the descriptive placeholder 'New Gymnast', specify the Age precisely as 20.0, define the Height exactly as 1.70, and finally, list the Hometown as the generic term 'Unknown'. However, this insertion must only proceed cautiously under the important condition that an existing record with that identical People_ID is not already present in the table. The function should then appropriately return the complete NEW record.",
    "id": 23
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_people_on_gymnast_delete that returns a trigger, which is automatically executed by a trigger named trg_delete_people_on_gymnast_delete configured to fire after a delete operation on the gymnast table for each row that is deleted; the function performs a delete operation on the people table where the value in the People_ID column of the people table is exactly equal to the value that was in the Gymnast_ID column of the gymnast table row that was just deleted, as referenced by the OLD record's Gymnast_ID field, and the function concludes by returning the OLD record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_people_on_gymnast_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM people WHERE \"People_ID\" = OLD.\"Gymnast_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_people_on_gymnast_delete\n    AFTER DELETE ON gymnast\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_people_on_gymnast_delete();",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "DELETE FROM gymnast WHERE \"Gymnast_ID\" = 1;",
      "DELETE FROM gymnast WHERE \"Gymnast_ID\" = 2;",
      "DELETE FROM gymnast WHERE \"Gymnast_ID\" = 4;",
      "DELETE FROM gymnast WHERE \"Gymnast_ID\" = 5;",
      "DELETE FROM gymnast WHERE \"Gymnast_ID\" = 6;"
    ],
    "summary": "Create an AFTER DELETE trigger function named delete_people_on_gymnast_delete for the gymnast table. For each deleted row, delete the corresponding record from the people table where People_ID equals OLD.Gymnast_ID. Return the OLD record.",
    "natural_language": "Set up a trigger that runs after something gets removed from the gymnast table. It should clean up the related entries in the people table, matching the IDs from what was just taken out. Make sure it gives back the old record details.",
    "id": 24
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_update_job_title_on_change` that is designed to be executed in response to data manipulation language (DML) events on a specific table. This function does not accept any explicit input parameters beyond the standard trigger context variables. Upon execution, the function performs a single `UPDATE` operation on the `employees` table. The `UPDATE` statement modifies the `JOB_ID` column within the `employees` table. The new value for the `JOB_ID` column in the `employees` table is derived from the `NEW` record's `JOB_ID` column, which represents the state of the row *after* the DML operation that fired the trigger. This update is applied to rows in the `employees` table where the existing value of the `JOB_ID` column matches the `OLD` record's `JOB_ID` column, which represents the state of the row *before* the DML operation that fired the trigger. After performing this update, the function returns the `NEW` record, indicating that the row that triggered the operation should be processed as modified.\n\nA trigger named `update_job_title_on_change` is defined to execute this function. This trigger is configured to activate `AFTER` an `UPDATE` operation occurs on the `jobs` table. Specifically, the trigger is sensitive only to updates that modify the `JOB_ID` column of the `jobs` table. The trigger is set to execute `FOR EACH ROW` that is affected by such an `UPDATE` statement, meaning the `trg_update_job_title_on_change` function will be invoked once for every row where the `JOB_ID` column in the `jobs` table has been updated.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_job_title_on_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE employees SET \"JOB_ID\" = NEW.\"JOB_ID\" WHERE \"JOB_ID\" = OLD.\"JOB_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_job_title_on_change\nAFTER UPDATE OF \"JOB_ID\" ON jobs\nFOR EACH ROW EXECUTE FUNCTION trg_update_job_title_on_change();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "UPDATE jobs SET \"JOB_ID\" = 'AD_VP' WHERE \"JOB_ID\" = 'AD_PRES';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_ASST' WHERE \"JOB_ID\" = 'AD_VP';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_PRES' WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_VP' WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_ASST' WHERE \"JOB_ID\" = 'AD_PRES';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_update_job_title_on_change for the jobs table, triggered only when the JOB_ID column is updated. For each updated row, update the employees table, setting JOB_ID to NEW.JOB_ID where JOB_ID equals OLD.JOB_ID. Return the NEW record.",
    "natural_language": "Create AFTER UPDATE trigger trg_update_job_title_on_change on jobs for JOB_ID changes. Update employees' JOB_ID from OLD to NEW value. Return NEW.",
    "id": 25
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `log_new_claim` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the new and old row data, respectively, for the triggering event. The function returns a `TRIGGER` type, which is standard for PostgreSQL trigger functions.\n\nInside the function, a local variable named `next_settlement_id` of type `BIGINT` is declared. The first operation performed is a `SELECT` statement to determine the next available `Settlement_ID` for insertion into the `\"Settlements\"` table. This `SELECT` statement queries the `\"Settlements\"` table, specifically selecting the maximum value from the `\"Settlement_ID\"` column. The `COALESCE` function is used to handle cases where the `\"Settlements\"` table might be empty; if `MAX(\"Settlement_ID\")` returns `NULL` (indicating an empty table), `COALESCE` will substitute `0` instead. This result is then incremented by `1` to generate a unique `Settlement_ID` for the new record. The calculated value is stored in the `next_settlement_id` variable.\n\nFollowing this, an `INSERT` statement is executed to add a new record into the `\"Settlements\"` table. The columns targeted for insertion are `\"Settlement_ID\"`, `\"Claim_ID\"`, `\"Date_Claim_Made\"`, `\"Date_Claim_Settled\"`, `\"Amount_Claimed\"`, `\"Amount_Settled\"`, and `\"Customer_Policy_ID\"`. The values provided for these columns are as follows:\n- For `\"Settlement_ID\"`, the value from the `next_settlement_id` variable is used.\n- For `\"Claim_ID\"`, the value is taken from the `\"Claim_ID\"` column of the `NEW` record, which represents the row that just triggered this function.\n- For `\"Date_Claim_Made\"`, the value is taken from the `\"Date_Claim_Made\"` column of the `NEW` record.\n- For `\"Date_Claim_Settled\"`, the value is calculated by adding an `INTERVAL '30 days'` to the `\"Date_Claim_Made\"` column of the `NEW` record. This effectively sets the settlement date to 30 days after the claim was made.\n- For `\"Amount_Claimed\"`, the value is taken from the `\"Amount_Claimed\"` column of the `NEW` record.\n- For `\"Amount_Settled\"`, the value is taken from the `\"Amount_Settled\"` column of the `NEW` record.\n- For `\"Customer_Policy_ID\"`, the value is taken from the `\"Policy_ID\"` column of the `NEW` record.\n\nFinally, the function returns `NEW`, which is required for `AFTER` row-level triggers in PostgreSQL, indicating that the original row that triggered the event should be returned unchanged.\n\nA trigger named `trg_log_new_claim` is created. This trigger is configured to execute `AFTER INSERT` operations on the `\"Claims\"` table. It is a `FOR EACH ROW` trigger, meaning it will execute the associated function once for every row inserted into the `\"Claims\"` table. The function executed by this trigger is `log_new_claim()`. Therefore, whenever a new row is successfully inserted into the `\"Claims\"` table, this trigger will activate, and the `log_new_claim` function will be called to create a corresponding entry in the `\"Settlements\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION log_new_claim() RETURNS TRIGGER AS $$\nDECLARE\n  next_settlement_id BIGINT;\nBEGIN\n  -- Get the next Settlement_ID safely\n  SELECT COALESCE(MAX(\"Settlement_ID\"), 0) + 1 INTO next_settlement_id FROM \"Settlements\";\n  \n  INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\")\n  VALUES (\n    next_settlement_id,\n    NEW.\"Claim_ID\",\n    NEW.\"Date_Claim_Made\",\n    NEW.\"Date_Claim_Made\" + INTERVAL '30 days',\n    NEW.\"Amount_Claimed\",\n    NEW.\"Amount_Settled\",\n    NEW.\"Policy_ID\"\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_new_claim\nAFTER INSERT ON \"Claims\"\nFOR EACH ROW EXECUTE FUNCTION log_new_claim();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1001, 744, '2024-01-15', NULL, 50000, NULL);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1002, 552, '2024-02-20', NULL, 75000, 60000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1003, 473, '2024-03-10', '2024-04-10', 30000, 25000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Amount_Claimed\") VALUES (1004, 119, '2024-03-25', 42000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1005, 141, CURRENT_DATE, NULL, 88000, NULL);"
    ],
    "summary": "Create a PostgreSQL trigger function named `log_new_claim` that, after each insert into the \"Claims\" table, inserts a corresponding record into the \"Settlements\" table. The function must generate a new `Settlement_ID` by incrementing the maximum existing ID (starting from 0 if the table is empty). The new settlement record should use the new claim's `Claim_ID`, `Date_Claim_Made`, `Amount_Claimed`, `Amount_Settled`, and `Policy_ID` (as `Customer_Policy_ID`). Set `Date_Claim_Settled` to 30 days after `Date_Claim_Made`. The function must return the NEW row. Also, create an AFTER INSERT FOR EACH ROW trigger named `trg_log_new_claim` on the \"Claims\" table to execute this function.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as `log_new_claim`. This function is to be invoked subsequent to every insertion into the \"Claims\" table, with the purpose of inserting a corresponding entry into the \"Settlements\" table. The function must generate a novel `Settlement_ID` by incrementing the highest existing ID value, commencing from 0 should the table be devoid of records. The new settlement entry shall incorporate the newly inserted claim's `Claim_ID`, `Date_Claim_Made`, `Amount_Claimed`, `Amount_Settled`, and `Policy_ID` (to be recorded as `Customer_Policy_ID`). The `Date_Claim_Settled` field is to be assigned a value equivalent to 30 days following the `Date_Claim_Made`. The function is required to return the NEW row. Furthermore, establish an AFTER INSERT FOR EACH ROW trigger named `trg_log_new_claim` on the \"Claims\" table to execute the aforementioned function.",
    "id": 26
  },
  {
    "ir": "Write a PostgreSQL trigger function named archive_expired_policy that returns a trigger and is executed by a trigger named trg_archive_expired_policy, which is defined to fire after a delete operation on the Customer_Policies table for each row that is deleted, where the function's logic is to perform a delete operation on the Claims table, specifically targeting all rows in the Claims table where the value in its Policy_ID column is equal to the value of the Policy_ID column from the OLD record, which represents the row just deleted from the Customer_Policies table, and then the function returns the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_expired_policy() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Claims\" WHERE \"Policy_ID\" = OLD.\"Policy_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_archive_expired_policy\nAFTER DELETE ON \"Customer_Policies\"\nFOR EACH ROW EXECUTE FUNCTION archive_expired_policy();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "DELETE FROM \"Customer_Policies\" WHERE \"Policy_ID\" = 119;",
      "DELETE FROM \"Customer_Policies\" WHERE \"Policy_ID\" = 141;",
      "DELETE FROM \"Customer_Policies\" WHERE \"Policy_ID\" = 143;",
      "DELETE FROM \"Customer_Policies\" WHERE \"Policy_ID\" = (SELECT \"Policy_ID\" FROM \"Customer_Policies\" ORDER BY RANDOM() LIMIT 1);",
      "DELETE FROM \"Customer_Policies\" WHERE \"Policy_ID\" IN (SELECT \"Policy_ID\" FROM \"Customer_Policies\" ORDER BY \"Policy_ID\" DESC LIMIT 2);"
    ],
    "summary": "Create a PostgreSQL trigger function named `archive_expired_policy` that, after a row is deleted from the `Customer_Policies` table, deletes all rows from the `Claims` table where the `Policy_ID` matches the deleted policy's `Policy_ID`. The function must return the OLD row. Also, create an AFTER DELETE FOR EACH ROW trigger named `trg_archive_expired_policy` on the `Customer_Policies` table to execute this function.",
    "natural_language": "Construct a PostgreSQL trigger function, which should be named `archive_expired_policy`, that performs a detailed and comprehensive cleanup operation. Specifically, after a row is meticulously deleted from the `Customer_Policies` table, this function must thoroughly and systematically delete all associated rows from the `Claims` table, but only where the `Policy_ID` column precisely matches the `Policy_ID` of the policy that was just deleted. It is critically important that this function reliably returns the OLD row. Furthermore, you must carefully create an AFTER DELETE FOR EACH ROW trigger, to be named `trg_archive_expired_policy`, which will be explicitly attached to the `Customer_Policies` table for the sole purpose of executing this function automatically.",
    "id": 27
  },
  {
    "ir": "Write a PL/pgSQL trigger that is activated immediately before a row is deleted from the \"Customers\" table. This trigger is defined by a function named `remove_customer_data` which takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. In this specific case, since the trigger fires `BEFORE DELETE`, the `OLD` record contains the data of the row that is about to be deleted from the \"Customers\" table. The function's primary operation is to perform a `DELETE` statement on the \"Customer_Policies\" table. This `DELETE` operation targets rows in the \"Customer_Policies\" table where the value in its \"Customer_ID\" column exactly matches the value of the \"Customer_ID\" column from the `OLD` record, which represents the customer being deleted from the \"Customers\" table. After executing this `DELETE` statement, the function returns the `OLD` record. The trigger, named `trg_remove_customer_data`, is configured to execute the `remove_customer_data()` function for each row that is deleted from the \"Customers\" table. The purpose of this trigger is to maintain referential integrity by automatically removing all associated policy records from the \"Customer_Policies\" table whenever a customer record is deleted from the \"Customers\" table, ensuring that no orphaned policy records remain.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_customer_data() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Customer_Policies\" WHERE \"Customer_ID\" = OLD.\"Customer_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_remove_customer_data\nBEFORE DELETE ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION remove_customer_data();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "DELETE FROM \"Customers\" WHERE \"Customer_ID\" = 1;",
      "DELETE FROM \"Customers\" WHERE \"Customer_ID\" = 2;",
      "DELETE FROM \"Customers\" WHERE \"Customer_ID\" = 3;",
      "DELETE FROM \"Customers\" WHERE \"Customer_ID\" = 10;",
      "DELETE FROM \"Customers\" WHERE \"Customer_ID\" = 15;"
    ],
    "summary": "Create a PostgreSQL trigger function named `remove_customer_data` that, before a row is deleted from the \"Customers\" table, deletes all rows from the \"Customer_Policies\" table where the `Customer_ID` matches the customer being deleted. The function must return the OLD row. Also, create a BEFORE DELETE FOR EACH ROW trigger named `trg_remove_customer_data` on the \"Customers\" table to execute this function.",
    "natural_language": "Write a PostgreSQL trigger function called `remove_customer_data` that deletes all matching rows from the \"Customer_Policies\" table before a customer is removed from the \"Customers\" table. Ensure the function returns the OLD row. Then, set up a BEFORE DELETE FOR EACH ROW trigger named `trg_remove_customer_data` on the \"Customers\" table to call this function.",
    "id": 28
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger that is named `trg_cleanup_payment_records` and is associated with the `\"Settlements\"` table. This trigger is configured to execute `AFTER DELETE` operations on the `\"Settlements\"` table, meaning it will activate immediately after a row has been successfully deleted from `\"Settlements\"`. The trigger is defined to execute `FOR EACH ROW`, indicating that the associated function will be invoked once for every row that is deleted from the `\"Settlements\"` table. The trigger executes the `cleanup_payment_records()` function. The `cleanup_payment_records()` function is a PostgreSQL PL/pgSQL function that returns a `TRIGGER` type, signifying its intended use as a trigger function. When this function is executed as part of the `trg_cleanup_payment_records` trigger, it performs a `DELETE` operation on the `\"Payments\"` table. The `DELETE` operation targets rows in the `\"Payments\"` table where the value in the `\"Settlement_ID\"` column of the `\"Payments\"` table is equal to the value of the `\"Settlement_ID\"` column from the row that was just deleted from the `\"Settlements\"` table. This value is accessed via the `OLD` special record, specifically `OLD.\"Settlement_ID\"`. After executing the `DELETE` statement, the function returns the `OLD` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the original deleted row is returned.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_payment_records() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Payments\" WHERE \"Settlement_ID\" = OLD.\"Settlement_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_payment_records\nAFTER DELETE ON \"Settlements\"\nFOR EACH ROW EXECUTE FUNCTION cleanup_payment_records();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "DELETE FROM \"Settlements\" WHERE \"Settlement_ID\" = 357;",
      "DELETE FROM \"Settlements\" WHERE \"Settlement_ID\" = 412;",
      "DELETE FROM \"Settlements\" WHERE \"Settlement_ID\" = 476;",
      "DELETE FROM \"Settlements\" WHERE \"Settlement_ID\" = 516;",
      "DELETE FROM \"Settlements\" WHERE \"Settlement_ID\" = 621;"
    ],
    "summary": "Create a PostgreSQL trigger function named `cleanup_payment_records` that, after a row is deleted from the \"Settlements\" table, deletes all rows from the \"Payments\" table where the `Settlement_ID` matches the deleted settlement's `Settlement_ID`. The function must return the OLD row. Also, create an AFTER DELETE FOR EACH ROW trigger named `trg_cleanup_payment_records` on the \"Settlements\" table to execute this function.",
    "natural_language": "Create trigger function `cleanup_payment_records` to delete related payments after a settlement is deleted. Return OLD. Attach it to Settlements with an AFTER DELETE trigger named `trg_cleanup_payment_records`.",
    "id": 29
  },
  {
    "ir": "Write a PLpgSQL function named update_participant_type that is designed to be used as a trigger function, which updates the Participants table by setting the Participant_Type_Code column to the string 'Updated' for the row where the Participant_ID matches the Participant_ID of the newly updated row in the Participants_in_Events table, and returns the newly updated row. Additionally, write another PLpgSQL function named check_participant_event that serves as a trigger function to prevent duplicate entries in the Participants_in_Events table by checking if a pair of Event_ID and Participant_ID already exists in the table; if such a pair exists, the function returns NULL to skip the insertion, otherwise, it returns the new row to allow the insertion. Implement a trigger named prevent_duplicate_participant_event on the Participants_in_Events table that executes the check_participant_event function before any insert operation to ensure no duplicate Event_ID and Participant_ID pairs are inserted. Also, implement a trigger named participant_type_trigger on the Participants_in_Events table that executes the update_participant_type function after any update operation to ensure the Participant_Type_Code in the Participants table is updated accordingly.",
    "plsql": "CREATE OR REPLACE FUNCTION update_participant_type() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Participants\"\n  SET \"Participant_Type_Code\" = 'Updated'\n  WHERE \"Participant_ID\" = NEW.\"Participant_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE OR REPLACE FUNCTION check_participant_event() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the (Event_ID, Participant_ID) pair already exists\n  IF EXISTS (\n    SELECT 1 FROM \"Participants_in_Events\" \n    WHERE \"Event_ID\" = NEW.\"Event_ID\" \n    AND \"Participant_ID\" = NEW.\"Participant_ID\"\n  ) THEN\n    -- If it exists, skip the insertion\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Drop existing trigger if it exists\nDROP TRIGGER IF EXISTS participant_type_trigger ON \"Participants_in_Events\";\nDROP TRIGGER IF EXISTS prevent_duplicate_participant_event ON \"Participants_in_Events\";\n\n-- Create trigger to prevent duplicates BEFORE INSERT\nCREATE TRIGGER prevent_duplicate_participant_event\nBEFORE INSERT ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION check_participant_event();\n\n-- Create the original trigger for AFTER UPDATE\nCREATE TRIGGER participant_type_trigger\nAFTER UPDATE ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION update_participant_type();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 26);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 66);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (13, 86);",
      "UPDATE \"Participants_in_Events\" SET \"Event_ID\" = 8 WHERE \"Participant_ID\" = 26;",
      "UPDATE \"Participants_in_Events\" SET \"Event_ID\" = 3 WHERE \"Participant_ID\" = 66;"
    ],
    "summary": "Create two PostgreSQL trigger functions. First, create a function named `update_participant_type` that, after an update on the `Participants_in_Events` table, updates the `Participants` table by setting `Participant_Type_Code` to 'Updated' for the row where `Participant_ID` matches the updated row's `Participant_ID`. It must return the NEW row. Create an AFTER UPDATE FOR EACH ROW trigger named `participant_type_trigger` on `Participants_in_Events` to execute it. Second, create a function named `check_participant_event` that, before an insert on the `Participants_in_Events` table, checks if the (`Event_ID`, `Participant_ID`) pair already exists. If it exists, return NULL to abort the insert; otherwise, return the NEW row to proceed. Create a BEFORE INSERT FOR EACH ROW trigger named `prevent_duplicate_participant_event` on `Participants_in_Events` to execute it.",
    "natural_language": "Create a couple of PostgreSQL trigger functions. First, make a function called `update_participant_type` that, after some changes to the `Participants_in_Events` table, goes and updates the `Participants` table by setting the `Participant_Type_Code` to something like 'Updated' for any matching participant. It should give back the new row. Set up an AFTER UPDATE trigger named `participant_type_trigger` on that table to run it. Second, create another function named `check_participant_event` that, before putting new data into `Participants_in_Events`, checks if a similar participant-event combination is already there. If it looks like a duplicate, stop the insert; otherwise, let it go through. Create a BEFORE INSERT trigger named `prevent_duplicate_participant_event` to handle that.",
    "id": 30
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `delete_event_participants` that is designed to be executed in response to a data manipulation event on a specific table, and then describe the trigger named `event_participants_delete_trigger` that utilizes this function. The `delete_event_participants` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. This function does not accept any explicit input parameters beyond the implicit `OLD` and `NEW` records provided by the trigger mechanism. Upon execution, the function performs a `DELETE` operation on the table named `\"Participants_in_Events\"`. The rows to be deleted from `\"Participants_in_Events\"` are determined by a `WHERE` clause that specifies a condition: the value in the `\"Event_ID\"` column of the `\"Participants_in_Events\"` table must be equal to the value of the `\"Event_ID\"` column from the `OLD` record. The `OLD` record represents the state of the row *before* the triggering event occurred. After successfully executing the `DELETE` statement, the function returns the `OLD` record. The `event_participants_delete_trigger` is defined as an `AFTER DELETE` trigger, meaning it will activate immediately after a `DELETE` operation has successfully completed on the table named `\"Events\"`. This trigger is configured to execute `FOR EACH ROW`, which means that for every single row that is deleted from the `\"Events\"` table, the associated trigger function will be invoked. The function executed by this trigger is `delete_event_participants()`. Therefore, whenever a row is deleted from the `\"Events\"` table, the `event_participants_delete_trigger` will activate, and for each deleted row, it will call the `delete_event_participants` function. This function, in turn, will delete all corresponding entries in the `\"Participants_in_Events\"` table where the `\"Event_ID\"` matches the `\"Event_ID\"` of the row that was just deleted from the `\"Events\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_event_participants() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Participants_in_Events\"\n  WHERE \"Event_ID\" = OLD.\"Event_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER event_participants_delete_trigger\nAFTER DELETE ON \"Events\"\nFOR EACH ROW EXECUTE FUNCTION delete_event_participants();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = 3;",
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = 8;",
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = 13;"
    ],
    "summary": "Create a trigger function named `delete_event_participants` that returns a trigger. After a row is deleted from the `\"Events\"` table, the function deletes all rows from the `\"Participants_in_Events\"` table where the `\"Event_ID\"` matches the `\"Event_ID\"` of the deleted row (from the OLD record). Then, create an AFTER DELETE trigger named `event_participants_delete_trigger` on the `\"Events\"` table that executes this function FOR EACH ROW.",
    "natural_language": "Define a trigger function entitled `delete_event_participants` that yields a trigger. Following the deletion of a row from the `\"Events\"` table, this function shall proceed to remove all corresponding entries from the `\"Participants_in_Events\"` table where the `\"Event_ID\"` column corresponds to the `\"Event_ID\"` value from the OLD record. Subsequently, establish an AFTER DELETE trigger named `event_participants_delete_trigger` on the `\"Events\"` table, which will invoke the aforementioned function for each affected row.",
    "id": 31
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_service_type that returns a trigger and is invoked automatically after each row update operation on the Events table; this function executes a SQL UPDATE statement on the Services table, specifically setting the value of the Service_Type_Code column to the literal string 'Updated' for every row in the Services table where the value in its Service_ID column is equal to the value of the Service_ID column from the newly updated row (represented by the NEW record) in the Events table; the function then returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_service_type() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Services\"\n  SET \"Service_Type_Code\" = 'Updated'\n  WHERE \"Service_ID\" = NEW.\"Service_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER service_type_update_trigger\nAFTER UPDATE ON \"Events\"\nFOR EACH ROW EXECUTE FUNCTION update_service_type();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "UPDATE \"Events\" SET \"Event_Details\" = 'Success' WHERE \"Event_ID\" = 3;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Fail' WHERE \"Event_ID\" = 8;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Success' WHERE \"Event_ID\" = 13;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Fail' WHERE \"Event_ID\" = 3;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Success' WHERE \"Event_ID\" = 8;"
    ],
    "summary": "Create a trigger function named `update_service_type` that returns a trigger. After a row is updated in the `Events` table, the function updates the `Services` table, setting the `Service_Type_Code` column to 'Updated' for all rows where the `Service_ID` matches the `Service_ID` of the newly updated row (from the NEW record).",
    "natural_language": "Alright, so we need a trigger function called `update_service_type` that spits out a trigger. Here's the deal: whenever a row gets changed in the `Events` table, this function should kick in. It's gotta go into the `Services` table and flip the `Service_Type_Code` to 'Updated' for every service entry that has the same `Service_ID` as the one from the freshly updated event row (that's the NEW record we're talking about).",
    "id": 32
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after a row is deleted from the \"Services\" table. This function, named delete_service_events, does not take any parameters directly but operates in the context of a trigger. It performs a delete operation on the \"Events\" table, specifically removing all rows where the \"Service_ID\" column matches the \"Service_ID\" of the row that was just deleted from the \"Services\" table. The function returns the OLD record, which represents the state of the deleted row from the \"Services\" table before the deletion occurred. The trigger, named service_events_delete_trigger, is defined to fire after a delete operation on each row of the \"Services\" table, ensuring that the corresponding events in the \"Events\" table are also deleted whenever a service is removed.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_service_events() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Events\"\n  WHERE \"Service_ID\" = OLD.\"Service_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER service_events_delete_trigger\nAFTER DELETE ON \"Services\"\nFOR EACH ROW EXECUTE FUNCTION delete_service_events();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "DELETE FROM \"Services\" WHERE \"Service_ID\" = 2;",
      "DELETE FROM \"Services\" WHERE \"Service_ID\" = 5;",
      "DELETE FROM \"Services\" WHERE \"Service_ID\" = 6;",
      "DELETE FROM \"Services\" WHERE \"Service_ID\" = 1;",
      "DELETE FROM \"Services\" WHERE \"Service_ID\" = 10;"
    ],
    "summary": "Create a trigger function named `delete_service_events` that returns a trigger. After a row is deleted from the `\"Services\"` table, the function deletes all rows from the `\"Events\"` table where the `\"Service_ID\"` matches the `\"Service_ID\"` of the deleted row (from the OLD record). Then, create an AFTER DELETE trigger named `service_events_delete_trigger` on the `\"Services\"` table that executes this function FOR EACH ROW.",
    "natural_language": "How can I create a trigger function called `delete_service_events` that returns a trigger, which, after a row is deleted from the `\"Services\"` table, deletes all corresponding rows from the `\"Events\"` table where the `\"Service_ID\"` matches the deleted row's `\"Service_ID`? Furthermore, how do I then create an AFTER DELETE trigger named `service_events_delete_trigger` on the `\"Services\"` table to execute this function for each row?",
    "id": 33
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_log_friend_changes that returns a trigger and is executed by a trigger named log_friend_changes_trigger, which is defined to fire after every insert operation on the table named \"Friend\" for each new row added. The function begins by evaluating a conditional statement that checks if the value of the NEW.friend_id column, representing the newly inserted friend_id, is less than 1000. If this condition is true, the function performs an insert operation into the same \"Friend\" table, specifying values for the student_id and friend_id columns. The value for the student_id column in this new insert is taken directly from the NEW.student_id of the triggering row. The value for the friend_id column is calculated by taking the NEW.friend_id from the triggering row and adding 1000 to it. After this conditional insert, the function returns the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_log_friend_changes() RETURNS TRIGGER AS $$\nBEGIN\n    -- Avoid infinite recursion by checking if friend_id is already modified\n    IF NEW.friend_id < 1000 THEN\n        INSERT INTO \"Friend\" (student_id, friend_id) VALUES (NEW.student_id, NEW.friend_id + 1000);\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_friend_changes_trigger\nAFTER INSERT ON \"Friend\"\nFOR EACH ROW EXECUTE FUNCTION trg_log_friend_changes();",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler"
    ],
    "call_sqls": [
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 500);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1689, 999);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1381, 100);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1709, 1);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 2000);"
    ],
    "summary": "Create a trigger function named `trg_log_friend_changes` that returns a trigger. After a row is inserted into the `\"Friend\"` table, if the new `friend_id` is less than 1000, the function inserts a new row into the same `\"Friend\"` table. The new row's `student_id` is the same as the triggering row's `NEW.student_id`, and its `friend_id` is the triggering row's `NEW.friend_id` plus 1000. Then, create an AFTER INSERT trigger named `log_friend_changes_trigger` on the `\"Friend\"` table that executes this function FOR EACH ROW.",
    "natural_language": "Please construct a trigger function designated as `trg_log_friend_changes` that yields a trigger. Following the insertion of a row into the `\"Friend\"` table, should the newly inserted `friend_id` value be below 1000, the function is to insert an additional row into the same `\"Friend\"` table. For this new row, the `student_id` shall be identical to the `NEW.student_id` from the triggering row, while the `friend_id` shall be derived by adding 1000 to the triggering row's `NEW.friend_id`. Subsequently, establish an AFTER INSERT trigger named `log_friend_changes_trigger` on the `\"Friend\"` table, which invokes the aforementioned function for each affected row.",
    "id": 34
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_limit_friends_per_student` that is designed to be executed `BEFORE INSERT` operations on the table named `\"Friend\"`, for `EACH ROW` being inserted. This trigger function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records representing the new and old row values, respectively, for the current operation. The primary purpose of this trigger is to enforce two business rules related to friend relationships: preventing duplicate friend entries and limiting the total number of friends a student can have to five.\n\nUpon activation for an `INSERT` operation on the `\"Friend\"` table, the function first performs a check to determine if the exact friend relationship being inserted already exists. This is achieved by executing a `SELECT` statement that attempts to retrieve `1` (a constant value, indicating existence) from the `\"Friend\"` table. The `WHERE` clause of this `SELECT` statement specifies two conditions: `student_id = NEW.student_id` and `friend_id = NEW.friend_id`. `NEW.student_id` refers to the `student_id` value from the row currently being inserted, and `NEW.friend_id` refers to the `friend_id` value from the row currently being inserted. If this `SELECT` query finds any matching row, indicating a duplicate entry, the `IF EXISTS` condition evaluates to true. In this scenario, the function immediately returns `NULL`, which effectively cancels the current `INSERT` operation for that specific row, preventing the duplicate friend entry from being added to the `\"Friend\"` table.\n\nIf the first check for duplicate entries passes (i.e., the `IF EXISTS` condition is false), the function proceeds to its second validation step: checking the friend count limit for the student associated with the new friend entry. This is done by executing another `SELECT` statement that calculates the `COUNT(*)` (the total number of rows) from the `\"Friend\"` table. The `WHERE` clause for this `SELECT` statement is `student_id = NEW.student_id`, which filters the count to include only friends associated with the `student_id` of the row currently being inserted. The result of this `COUNT(*)` is then compared to the integer value `5` using the `>=` (greater than or equal to) operator. If the count of existing friends for `NEW.student_id` is `5` or more, the `IF` condition evaluates to true. In this case, the function raises an exception with the message `'Maximum 5 friends allowed per student'`, which aborts the current `INSERT` operation and rolls back any changes made within the current statement, preventing the student from having more than five friends.\n\nIf both the duplicate entry check and the friend count limit check pass (i.e., no duplicate is found and the student has fewer than 5 friends), the function concludes by returning `NEW`. Returning `NEW` allows the `INSERT` operation to proceed with the row as originally intended, effectively adding the new friend relationship to the `\"Friend\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_limit_friends_per_student() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if this (student_id, friend_id) pair already exists\n    IF EXISTS (SELECT 1 FROM \"Friend\" WHERE student_id = NEW.student_id AND friend_id = NEW.friend_id) THEN\n        -- Duplicate entry, skip this insertion\n        RETURN NULL;\n    END IF;\n    \n    -- Check friend count limit for the student\n    IF (SELECT COUNT(*) FROM \"Friend\" WHERE student_id = NEW.student_id) >= 5 THEN\n        RAISE EXCEPTION 'Maximum 5 friends allowed per student';\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER limit_friends_per_student_trigger\nBEFORE INSERT ON \"Friend\"\nFOR EACH ROW EXECUTE FUNCTION trg_limit_friends_per_student();",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler"
    ],
    "call_sqls": [
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 1381);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 1689);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 1709);",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 1234);"
    ],
    "summary": "Create a trigger function named `trg_limit_friends_per_student` that returns a trigger. Before a row is inserted into the `\"Friend\"` table, the function checks two rules. First, it prevents duplicate entries by checking if a row with the same `student_id` and `friend_id` already exists; if so, it cancels the insert. Second, it enforces a limit of five friends per student by checking the count of existing friends for the `NEW.student_id`; if the count is five or more, it raises an exception with the message 'Maximum 5 friends allowed per student'. If both checks pass, the insert proceeds. Create a BEFORE INSERT trigger on the `\"Friend\"` table that executes this function FOR EACH ROW.",
    "natural_language": "How can I create a trigger function called `trg_limit_friends_per_student` that returns a trigger? The function should run before a row is inserted into the `\"Friend\"` table and enforce two rules. First, how does it prevent duplicate entries by checking for an existing row with the same `student_id` and `friend_id` and canceling the insert if found? Second, how does it enforce a limit of five friends per student by checking the count of existing friends for `NEW.student_id` and raising an exception with the message 'Maximum 5 friends allowed per student' if the count is five or more? How do I then create a BEFORE INSERT trigger on the `\"Friend\"` table that executes this function for each row?",
    "id": 35
  },
  {
    "ir": "Write a PostgreSQL trigger function named log_pet_insertion that returns a trigger, which is then bound to the Pets table via a trigger named pet_insert_log, where the trigger is configured to fire automatically after every successful insertion of a new row into the Pets table, executing the log_pet_insertion function once for each inserted row, and within the function body, the only operation performed is to return the NEW record variable, which contains the column values of the newly inserted row, thereby allowing the trigger to complete without performing any additional logging or data manipulation.",
    "plsql": "CREATE OR REPLACE FUNCTION log_pet_insertion() RETURNS TRIGGER AS $$\nBEGIN\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER pet_insert_log\nAFTER INSERT ON \"Pets\"\nFOR EACH ROW EXECUTE FUNCTION log_pet_insertion();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Pets\" (PetID, PetType, pet_age, weight) VALUES (2004, 'dog', 5, 15.2);",
      "INSERT INTO \"Pets\" (PetID, PetType, pet_age, weight) VALUES (2005, 'cat', 2, 8.7);",
      "INSERT INTO \"Pets\" (PetID, PetType, pet_age, weight) VALUES (2006, 'bird', 1, 0.5);",
      "INSERT INTO \"Pets\" (PetID, PetType, pet_age, weight) VALUES (2007, 'dog', 7, 22.1);",
      "INSERT INTO \"Pets\" (PetID, PetType, pet_age, weight) VALUES (2008, 'hamster', 1, 0.2);"
    ],
    "summary": "Create an AFTER INSERT trigger function named log_pet_insertion for the Pets table. The function should return the NEW record without performing any additional operations.",
    "natural_language": "Define an AFTER INSERT trigger function called log_pet_insertion for the Pets table. Ensure the function returns the NEW record and performs no other actions.",
    "id": 36
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `validate_student_deletion` that is designed to be executed before a row is deleted from the `\"Student\"` table. This function takes no explicit parameters but implicitly receives special `OLD` and `NEW` records from the triggering event. Specifically, it accesses the `OLD` record, which represents the row that is about to be deleted from the `\"Student\"` table. The primary purpose of this function is to maintain referential integrity by deleting related records in another table before the main student record is removed. Inside the function, a `DELETE` operation is performed on the `\"Has_Pet\"` table. This `DELETE` statement targets all rows in the `\"Has_Pet\"` table where the value in its `\"StuID\"` column matches the value of the `\"StuID\"` column from the `OLD` record (i.e., the student ID of the student being deleted). After successfully deleting these associated pet relationships, the function returns the `OLD` record. This return value is standard for `BEFORE` triggers and indicates that the original `DELETE` operation on the `\"Student\"` table should proceed.\n\nA trigger named `student_delete_validate` is then created. This trigger is configured to activate `BEFORE DELETE` operations on the `\"Student\"` table. It is set to execute `FOR EACH ROW`, meaning that the `validate_student_deletion()` function will be invoked once for every individual row that is targeted for deletion from the `\"Student\"` table. The `EXECUTE FUNCTION validate_student_deletion()` clause specifies that the `validate_student_deletion` function is the routine to be executed when this trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_student_deletion() RETURNS TRIGGER AS $$\nBEGIN\n    -- Delete associated pet relationships before deleting the student\n    DELETE FROM \"Has_Pet\" WHERE \"StuID\" = OLD.\"StuID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER student_delete_validate\nBEFORE DELETE ON \"Student\"\nFOR EACH ROW EXECUTE FUNCTION validate_student_deletion();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "DELETE FROM \"Student\" WHERE \"StuID\" = 1001;",
      "DELETE FROM \"Student\" WHERE \"StuID\" = 1002;",
      "DELETE FROM \"Student\" WHERE \"StuID\" = 1003;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named validate_student_deletion for the Student table. The function must delete related records from the Has_Pet table where StuID matches the OLD record's StuID, then return the OLD record.",
    "natural_language": "Please construct a BEFORE DELETE trigger function designated as 'validate_student_deletion' for the Student table. The function is required to first remove any associated records from the Has_Pet table where the StuID corresponds to the StuID of the OLD record. Subsequently, the function must return the OLD record.",
    "id": 37
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_institution_cleanup that returns a trigger, which is executed by a trigger named trg_delete_institution_cleanup configured to fire BEFORE DELETE on the Institution table for each row being deleted, where the function's logic performs a DELETE operation on the protein table targeting all rows whose Institution_id column value matches the Institution_id column value from the OLD record (the row being deleted from the Institution table), and the function concludes by returning the OLD record.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_institution_cleanup() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"protein\" WHERE \"Institution_id\" = OLD.\"Institution_id\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_institution_cleanup\nBEFORE DELETE ON \"Institution\"\nFOR EACH ROW EXECUTE FUNCTION delete_institution_cleanup();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '0';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '1';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '2';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '3';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '5';"
    ],
    "summary": "Create a BEFORE DELETE trigger function named delete_institution_cleanup for the Institution table. The function must delete rows from the protein table where Institution_id matches the OLD record's Institution_id, then return the OLD record.",
    "natural_language": "Please construct a BEFORE DELETE trigger function designated as 'delete_institution_cleanup' for the Institution table. The function is required to perform the deletion of all corresponding entries from the protein table where the Institution_id column corresponds to the Institution_id value of the OLD record. Subsequently, the function must return the OLD record.",
    "id": 38
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `adjust_enrollment_on_height` that is designed to be executed in response to specific data manipulation language (DML) events on the `\"building\"` table, and a trigger named `trg_adjust_enrollment_on_height` that invokes this function. The trigger function `adjust_enrollment_on_height` takes no explicit parameters but implicitly receives special record variables `NEW` and `OLD` from the triggering event. The `NEW` record variable represents the new row data for `INSERT` and `UPDATE` operations, while the `OLD` record variable represents the old row data for `UPDATE` and `DELETE` operations. In this specific context, since the trigger is defined for `AFTER INSERT OR UPDATE`, the `NEW` record variable will contain the data of the row that was just inserted or updated. The function's primary purpose is to update the `\"Enrollment\"` column in the `\"Institution\"` table. Specifically, it performs an `UPDATE` operation on the `\"Institution\"` table. For each row in the `\"Institution\"` table, it sets the value of the `\"Enrollment\"` column to the result of the `GREATEST` function. The `GREATEST` function compares two values and returns the larger of the two. The first value provided to `GREATEST` is the current value of the `\"Enrollment\"` column in the `\"Institution\"` table. The second value provided to `GREATEST` is calculated by multiplying the value of the `\"Height_feet\"` column from the `NEW` record (representing the newly inserted or updated row in the `\"building\"` table) by 10. This `UPDATE` operation is conditionally applied only to those rows in the `\"Institution\"` table where the `\"building_id\"` column matches the value of the `\"building_id\"` column from the `NEW` record. After performing this update, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL. The trigger `trg_adjust_enrollment_on_height` is defined to execute `AFTER INSERT OR UPDATE OF \"Height_feet\"` on the `\"building\"` table. This means the trigger will fire after a new row is inserted into the `\"building\"` table, or after an existing row in the `\"building\"` table is updated, but only if the `\"Height_feet\"` column is one of the columns being updated. The `FOR EACH ROW` clause specifies that the trigger function `adjust_enrollment_on_height` will be executed once for each row that is affected by the `INSERT` or `UPDATE` operation. The `EXECUTE FUNCTION adjust_enrollment_on_height()` clause specifies that the `adjust_enrollment_on_height` function should be called when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_enrollment_on_height() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Institution\" SET \"Enrollment\" = GREATEST(\"Enrollment\", NEW.\"Height_feet\" * 10) WHERE \"building_id\" = NEW.\"building_id\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_adjust_enrollment_on_height\nAFTER INSERT OR UPDATE OF \"Height_feet\" ON \"building\"\nFOR EACH ROW EXECUTE FUNCTION adjust_enrollment_on_height();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "INSERT INTO building (building_id, Name, Street_address, Years_as_tallest, Height_feet, Floors) VALUES ('10', 'New Building 1', '123 Main St', '2023-2024', 100, 10);",
      "UPDATE building SET \"Height_feet\" = 150 WHERE building_id = '1';",
      "INSERT INTO building (building_id, Name, Street_address, Years_as_tallest, Height_feet, Floors) VALUES ('11', 'New Building 2', '456 Oak Ave', '2023-2025', 200, 20);",
      "UPDATE building SET \"Height_feet\" = 250 WHERE building_id = '3';",
      "INSERT INTO building (building_id, Name, Street_address, Years_as_tallest, Height_feet, Floors) VALUES ('12', 'New Building 3', '789 Pine Ln', '2023-2026', 50, 5);"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE OF Height_feet trigger function named adjust_enrollment_on_height for the building table. The function must update the Institution table, setting Enrollment to the greater of its current value or (NEW.Height_feet * 10), where building_id matches NEW.building_id, then return the NEW record.",
    "natural_language": "Create a trigger function named adjust_enrollment_on_height for the building table that fires AFTER INSERT OR UPDATE OF Height_feet. Make it update the Institution table by setting Enrollment to the maximum of its current value or (NEW.Height_feet * 10) where the building_id matches NEW.building_id, and then return the NEW record.",
    "id": 39
  },
  {
    "ir": "Write a PostgreSQL trigger function named sync_building_institution that is automatically executed by a trigger named trg_sync_building_institution after every new row insertion operation on the table named \"building\". The function takes no explicit parameters but uses the special NEW record variable, which holds the newly inserted row's column values from the \"building\" table. The function's logic performs a single INSERT operation into the table named \"Institution\". For each new row in \"building\", it inserts a corresponding new row into \"Institution\" with the following column values: it sets the \"Institution_id\" column to the value of NEW.\"building_id\" from the triggering row, sets the \"Institution\" column to the literal string 'Auto-generated', sets the \"Location\" column to the literal string 'Unknown', sets the \"Founded\" column to the numeric literal 2000.0, sets the \"Type\" column to the literal string 'Private', sets the \"Enrollment\" column to the numeric literal 1000, sets the \"Team\" column to the literal string 'Default', sets the \"Primary_Conference\" column to the literal string 'none', and sets the \"building_id\" column to the value of NEW.\"building_id\". The function concludes by returning the NEW row record, which is the standard behavior for an AFTER INSERT trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_building_institution() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\") VALUES (NEW.\"building_id\", 'Auto-generated', 'Unknown', 2000.0, 'Private', 1000, 'Default', 'none', NEW.\"building_id\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_sync_building_institution\nAFTER INSERT ON \"building\"\nFOR EACH ROW EXECUTE FUNCTION sync_building_institution();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "INSERT INTO \"building\" (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\") VALUES ('100', 'Test Building 1', '123 Main St', '2024', 150, 10);",
      "INSERT INTO \"building\" (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\") VALUES ('101', 'Test Building 2', '456 Oak Ave', '2024', 200, 15);",
      "INSERT INTO \"building\" (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\") VALUES ('102', 'Test Building 3', '789 Pine Rd', '2024', 175, 12);",
      "INSERT INTO \"building\" (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\") VALUES ('103', 'Test Building 4', '321 Elm Blvd', '2024', 225, 20);",
      "INSERT INTO \"building\" (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\") VALUES ('104', 'Test Building 5', '654 Maple Ln', '2024', 180, 14);"
    ],
    "summary": "Create an AFTER INSERT trigger function named sync_building_institution for the building table. The function must insert a new row into the Institution table using values from the NEW record and predefined constants, then return the NEW record.",
    "natural_language": "Set up a trigger function called sync_building_institution to run after something gets added to the building table. It should basically take the new data and some standard default values to put a fresh entry into the Institution table, and then just hand back whatever was newly added.",
    "id": 40
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `update_country_area_on_coaster_insert` that is designed to be executed in response to data manipulation events on a specific table, and a trigger named `trg_update_area_on_coaster_insert` that invokes this function. The trigger function `update_country_area_on_coaster_insert` is defined to return a `TRIGGER` type, indicating its role as a trigger function. When this function is executed, it performs a single operation within an anonymous `BEGIN...END` block, which includes an exception handling mechanism. The primary operation is an `UPDATE` statement targeting the `country` table. This `UPDATE` statement modifies the `Area` column of a specific row in the `country` table. The new value for the `Area` column is calculated by taking the current value of the `Area` column and adding a derived integer value to it. The derived integer value is obtained by first dividing the `Length` column from the newly inserted row (referenced as `NEW.\"Length\"`) by 100, then rounding the result of this division to the nearest whole number using the `ROUND()` function, and finally casting this rounded numeric value to an `INTEGER` data type using `CAST(... AS INTEGER)`. The `UPDATE` operation is conditionally applied to rows in the `country` table where the `Country_ID` column matches the `Country_ID` column from the newly inserted row (referenced as `NEW.\"Country_ID\"`). Within the anonymous `BEGIN...END` block, an `EXCEPTION` handler is defined to catch any errors that might occur during the `UPDATE` operation. If any error occurs (`WHEN OTHERS`), a `RAISE NOTICE` statement is executed. This statement logs a notice message to the database's message log, indicating \"Error updating country area: \" followed by the specific error message obtained from `SQLERRM`. This error handling ensures that the trigger function does not prevent the original `INSERT` operation on the `roller_coaster` table from completing, even if the `UPDATE` to the `country` table fails. After attempting the `UPDATE` operation (and potentially handling an exception), the function concludes by returning `NEW`, which represents the newly inserted row in the `roller_coaster` table, allowing the `INSERT` operation to proceed normally. The `trg_update_area_on_coaster_insert` trigger is defined to activate `AFTER INSERT` operations on the `roller_coaster` table. It is configured to execute `FOR EACH ROW`, meaning the trigger function `update_country_area_on_coaster_insert` will be invoked once for every row that is inserted into the `roller_coaster` table. The trigger explicitly specifies `EXECUTE FUNCTION update_country_area_on_coaster_insert()` to call the previously defined trigger function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_country_area_on_coaster_insert() RETURNS TRIGGER AS $$\nBEGIN\n    BEGIN\n        UPDATE country SET \"Area\" = \"Area\" + CAST(ROUND(NEW.\"Length\" / 100) AS INTEGER) WHERE \"Country_ID\" = NEW.\"Country_ID\";\n    EXCEPTION\n        WHEN OTHERS THEN\n            -- Log error but don't prevent the insert\n            RAISE NOTICE 'Error updating country area: %', SQLERRM;\n    END;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_area_on_coaster_insert\n    AFTER INSERT ON roller_coaster\n    FOR EACH ROW\n    EXECUTE FUNCTION update_country_area_on_coaster_insert();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "INSERT INTO roller_coaster (\"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES ('Steel Vengeance', 'Cedar Point', 1, 5740.0, 205.0, '74', 'May 5, 2018', 'Operating');",
      "INSERT INTO roller_coaster (\"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES ('Wildfire', 'Kolmården Wildlife Park', 3, 4200.0, 187.0, '70', 'June 28, 2016', 'Operating');",
      "INSERT INTO roller_coaster (\"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES ('Taiga', 'Linnanmäki', 2, 3510.0, 164.0, '66', 'April 27, 2019', 'Operating');",
      "INSERT INTO roller_coaster (\"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES ('F.L.Y.', 'Phantasialand', 1, 4500.0, 89.0, '48', 'September 17, 2020', 'Operating');",
      "INSERT INTO roller_coaster (\"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES ('Helix', 'Liseberg', 3, 4400.0, 134.0, '62', 'April 26, 2014', 'Operating');"
    ],
    "summary": "Create a trigger function named `update_country_area_on_coaster_insert` that, after a row is inserted into the `roller_coaster` table, updates the `country` table. It adds a calculated integer (the coaster's `Length` divided by 100 and rounded) to the `Area` column for the country matching the new coaster's `Country_ID`. Include exception handling to log any update errors without blocking the original insert. Also, create an `AFTER INSERT FOR EACH ROW` trigger named `trg_update_area_on_coaster_insert` on the `roller_coaster` table to execute this function.",
    "natural_language": "Write a trigger function called `update_country_area_on_coaster_insert`. After a new row is added to the `roller_coaster` table, this function must update the `country` table. It should add an integer (calculated by dividing the new coaster's `Length` by 100 and rounding) to the `Area` column for the country that matches the new coaster's `Country_ID`. Include error handling to record any update failures without stopping the original insert. Then, create an `AFTER INSERT FOR EACH ROW` trigger named `trg_update_area_on_coaster_insert` on the `roller_coaster` table to run this function.",
    "id": 41
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_country_language_on_coaster_update that returns a trigger and is executed by a trigger named trg_update_language_on_coaster_update, which is defined to fire after an update operation on the Name column of the roller_coaster table for each row that is updated; the function's logic performs an update on the country table, specifically it appends the string ' Coaster' to the existing value in the Languages column for the single row in the country table where the Country_ID column value matches the NEW.Country_ID value from the updated roller_coaster row, using the concatenation operator ||, and finally the function returns the NEW row record to the invoking trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION update_country_language_on_coaster_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE country SET \"Languages\" = \"Languages\" || ' Coaster' WHERE \"Country_ID\" = NEW.\"Country_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_language_on_coaster_update\n    AFTER UPDATE OF \"Name\" ON roller_coaster\n    FOR EACH ROW\n    EXECUTE FUNCTION update_country_language_on_coaster_update();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE roller_coaster SET \"Name\" = 'New Name 1' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 2' WHERE \"Roller_Coaster_ID\" = 2;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 3' WHERE \"Roller_Coaster_ID\" = 3;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 4' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 5' WHERE \"Roller_Coaster_ID\" = 2;"
    ],
    "summary": "Create a trigger function named `update_country_language_on_coaster_update` that, after the `Name` column of a row in the `roller_coaster` table is updated, appends the string ' Coaster' to the `Languages` column in the `country` table for the row matching the updated coaster's `Country_ID`. Also, create an `AFTER UPDATE OF \"Name\" FOR EACH ROW` trigger named `trg_update_language_on_coaster_update` on the `roller_coaster` table to execute this function.",
    "natural_language": "Create a trigger function called `update_country_language_on_coaster_update`. After a `Name` update in the `roller_coaster` table, have it append ' Coaster' to the `Languages` column in the `country` table for the matching `Country_ID`. Then, set up an `AFTER UPDATE OF \"Name\" FOR EACH ROW` trigger named `trg_update_language_on_coaster_update` on the `roller_coaster` table to run this function.",
    "id": 42
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `sync_teacher_assignment` that is designed to be executed in response to data manipulation language (DML) events on a table. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The function's purpose is to synchronize teacher information by inserting a new record into the `teachers` table. Specifically, it performs an `INSERT` operation into the `teachers` table, populating the `LastName`, `FirstName`, and `Classroom` columns. The value for the `LastName` column in the `teachers` table is derived from the `LastName` column of the `NEW` record, which represents the row that triggered the event. Similarly, the value for the `FirstName` column in the `teachers` table is taken from the `FirstName` column of the `NEW` record, and the value for the `Classroom` column in the `teachers` table is sourced from the `Classroom` column of the `NEW` record. After successfully performing this insertion, the function returns the `NEW` record, indicating that the operation completed without preventing the original DML statement from proceeding.\n\nAdditionally, a trigger named `sync_teacher_on_list_insert` is defined. This trigger is configured to activate `AFTER INSERT` operations on the `list` table. It is specified to execute `FOR EACH ROW`, meaning that the trigger function will be invoked once for every row that is inserted into the `list` table. The trigger is set to execute the previously described `sync_teacher_assignment()` function. Therefore, whenever a new row is inserted into the `list` table, the `sync_teacher_assignment` function will automatically execute, taking the `LastName`, `FirstName`, and `Classroom` values from the newly inserted row in the `list` table (represented by `NEW`) and inserting them into the `teachers` table.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_teacher_assignment() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") \n  VALUES (NEW.\"LastName\", NEW.\"FirstName\", NEW.\"Classroom\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sync_teacher_on_list_insert\nAFTER INSERT ON list\nFOR EACH ROW EXECUTE FUNCTION sync_teacher_assignment();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "INSERT INTO list (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('SMITH', ' JOHN', 5, 101);",
      "INSERT INTO list (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('JONES', ' MARY', 4, 112);",
      "INSERT INTO list (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('WILLIAMS', ' DAVID', 3, 107);",
      "INSERT INTO list (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('BROWN', ' SARAH', 6, 102);",
      "INSERT INTO list (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('MILLER', ' JAMES', 2, 103);"
    ],
    "summary": "Create a trigger function named `sync_teacher_assignment` that, after a row is inserted into the `list` table, inserts a new record into the `teachers` table using the new row's `LastName`, `FirstName`, and `Classroom` values. Also, create an `AFTER INSERT FOR EACH ROW` trigger named `sync_teacher_on_list_insert` on the `list` table to execute this function.",
    "natural_language": "Define a trigger function called `sync_teacher_assignment` to insert a record into the `teachers` table with the `LastName`, `FirstName`, and `Classroom` values from any newly inserted row in the `list` table. Then, set up an `AFTER INSERT FOR EACH ROW` trigger named `sync_teacher_on_list_insert` on the `list` table to call this function.",
    "id": 43
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `remove_teacher_assignment` that is designed to be executed in response to a data manipulation event. This function does not accept any explicit input parameters in its definition, but it operates within the context of a trigger, meaning it implicitly receives special variables such as `OLD` and `NEW` which represent the row before and after the triggering event, respectively. The function is declared to return a `TRIGGER` type, which is standard for PL/pgSQL trigger functions. Upon execution, the function performs a `DELETE` operation on the `teachers` table. The rows to be deleted from the `teachers` table are identified by a `WHERE` clause that specifies a condition: the value in the column named `\"Classroom\"` within the `teachers` table must be equal to the value of the `\"Classroom\"` column from the `OLD` record. The `OLD` record refers to the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` record.\n\nAdditionally, define a trigger named `remove_teacher_on_list_delete`. This trigger is configured to activate `AFTER DELETE` operations on the `list` table. It is specified to execute `FOR EACH ROW`, meaning that the trigger function will be invoked once for every row that is deleted from the `list` table. When activated, this trigger executes the previously defined function, `remove_teacher_assignment()`. Therefore, whenever a row is deleted from the `list` table, the `remove_teacher_assignment` function will be called, and it will delete corresponding records from the `teachers` table where the `\"Classroom\"` column matches the `\"Classroom\"` value of the row that was just deleted from the `list` table.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_teacher_assignment() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM teachers WHERE \"Classroom\" = OLD.\"Classroom\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_teacher_on_list_delete\nAFTER DELETE ON list\nFOR EACH ROW EXECUTE FUNCTION remove_teacher_assignment();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "DELETE FROM list WHERE \"Classroom\" = 101;",
      "DELETE FROM list WHERE \"Classroom\" = 112;",
      "DELETE FROM list WHERE \"Classroom\" = 107;",
      "DELETE FROM list WHERE \"Classroom\" = 101 AND \"Grade\" = 2;",
      "DELETE FROM list WHERE \"Classroom\" = 112 AND \"LastName\" = 'KRISTENSEN';"
    ],
    "summary": "Create a trigger function named `remove_teacher_assignment` that, after a row is deleted from the `list` table, deletes all rows from the `teachers` table where the `Classroom` matches the deleted row's `Classroom` value. Also, create an `AFTER DELETE FOR EACH ROW` trigger named `remove_teacher_on_list_delete` on the `list` table to execute this function.",
    "natural_language": "Set up a trigger function called `remove_teacher_assignment` so that, after something gets taken out of the `list` table, it also clears out any entries in the `teachers` table that are kind of related to that same `Classroom`. Then, make a trigger named `remove_teacher_on_list_delete` on the `list` table to run that function whenever a deletion happens.",
    "id": 44
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_problem_status_on_log` that is designed to be executed in response to data manipulation language (DML) events on a specific table. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The function's primary purpose is to conditionally update a record in the `\"Problems\"` table. Specifically, it performs an `UPDATE` operation on the `\"Problems\"` table. The `UPDATE` statement targets rows in the `\"Problems\"` table where the value in the `\"problem_id\"` column matches the value of the `\"problem_id\"` column from the `NEW` record (which represents the newly inserted row in the `Problem_Log` table that activated the trigger). Additionally, this `UPDATE` operation is further conditioned by checking if the value in the `\"problem_status_code\"` column of the `NEW` record is exactly equal to the string literal `'Solved'`. If both of these conditions are met for a given row in the `\"Problems\"` table, the `UPDATE` statement sets the value of the `\"date_problem_closed\"` column in that row to the `CURRENT_TIMESTAMP`, which represents the current date and time when the statement is executed. After attempting this update, the function concludes by returning the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the row that triggered the function should be processed as usual.\n\nThis trigger function is then associated with a trigger named `trg_update_problem_status_on_log`. This trigger is configured to activate `AFTER INSERT` operations on the `\"Problem_Log\"` table. The `FOR EACH ROW` clause specifies that the trigger function `update_problem_status_on_log` will be executed once for each individual row that is inserted into the `\"Problem_Log\"` table. The `EXECUTE FUNCTION update_problem_status_on_log()` clause explicitly calls the previously defined trigger function to perform its logic whenever the trigger is activated.",
    "plsql": "CREATE OR REPLACE FUNCTION update_problem_status_on_log() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Problems\" SET \"date_problem_closed\" = CURRENT_TIMESTAMP WHERE \"problem_id\" = NEW.\"problem_id\" AND NEW.\"problem_status_code\" = 'Solved';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_problem_status_on_log\n    AFTER INSERT ON \"Problem_Log\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_problem_status_on_log();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 1, 'Solved', 11, 'Middleware', '2023-01-01 10:00:00+00', 'Initial log entry', 'Fixed issue', 'None');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 2, 'Solved', 12, 'GUI', '2023-01-02 11:00:00+00', 'Second log entry', 'Patched bug', 'Details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 3, 'Reported', 11, 'Datatabase', '2023-01-03 12:00:00+00', 'Problem reported', NULL, 'More details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 1, 'Reported', 12, 'Middleware', '2023-01-04 13:00:00+00', 'Problem re-opened', NULL, 'Re-evaluation');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 4, 'Solved', 11, 'GUI', '2023-01-05 14:00:00+00', 'Final solution', 'Implemented fix', 'Closed');"
    ],
    "summary": "Create a trigger function named `update_problem_status_on_log` that, after a row is inserted into the `\"Problem_Log\"` table, updates the `\"Problems\"` table. It sets the `\"date_problem_closed\"` to the current timestamp for the problem where the `\"problem_id\"` matches the new log's `\"problem_id\"` AND the new log's `\"problem_status_code\"` is 'Solved'. Also, create an `AFTER INSERT FOR EACH ROW` trigger named `trg_update_problem_status_on_log` on the `\"Problem_Log\"` table to execute this function.",
    "natural_language": "Please construct a trigger function designated as `update_problem_status_on_log`. This function shall be invoked subsequent to an insertion into the `\"Problem_Log\"` table. Its purpose is to modify the `\"Problems\"` table by setting the `\"date_problem_closed\"` column to the current timestamp. This update is to be applied specifically to the record whose `\"problem_id\"` corresponds to the `\"problem_id` value in the newly inserted log, but only under the condition that the new log's `\"problem_status_code\"` is precisely 'Solved'. Furthermore, please establish an `AFTER INSERT FOR EACH ROW` trigger named `trg_update_problem_status_on_log` on the `\"Problem_Log\"` table, which will call the aforementioned function.",
    "id": 45
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `validate_problem_category` that is designed to be executed before an `INSERT` operation on the `\"Problem_Log\"` table, for each row being inserted. This function takes no explicit parameters but operates on the `NEW` record, which represents the row about to be inserted into `\"Problem_Log\"`. The function's primary purpose is to ensure the existence of a `problem_category_code` in the `\"Problem_Category_Codes\"` table. It first performs a `SELECT` operation to check if a record exists in the `\"Problem_Category_Codes\"` table where the `problem_category_code` column matches the value of the `problem_category_code` column from the `NEW` record (the row being inserted into `\"Problem_Log\"`). This `SELECT` statement uses `SELECT 1` for efficiency, as it only needs to determine existence, not retrieve actual data. The condition for this check is `problem_category_code` = `NEW.\"problem_category_code\"`. If the `NOT EXISTS` condition evaluates to true, meaning no such `problem_category_code` is found in `\"Problem_Category_Codes\"`, the function then executes an `INSERT` operation. This `INSERT` statement adds a new record into the `\"Problem_Category_Codes\"` table. The `problem_category_code` column of this new record is populated with the value from `NEW.\"problem_category_code\"`, and the `problem_category_description` column is set to the literal string `'Auto-generated category'`. After this conditional logic, regardless of whether an `INSERT` was performed or not, the function returns the `NEW` record. This returned `NEW` record is then used by the `INSERT` operation on the `\"Problem_Log\"` table, allowing the original `INSERT` to proceed with the potentially validated or newly created `problem_category_code`. The trigger named `trg_validate_problem_category` is defined to execute this `validate_problem_category()` function `BEFORE INSERT` on the `\"Problem_Log\"` table `FOR EACH ROW`.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_problem_category() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Problem_Category_Codes\" WHERE \"problem_category_code\" = NEW.\"problem_category_code\") THEN\n        INSERT INTO \"Problem_Category_Codes\" (\"problem_category_code\", \"problem_category_description\") VALUES (NEW.\"problem_category_code\", 'Auto-generated category');\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_problem_category\n    BEFORE INSERT ON \"Problem_Log\"\n    FOR EACH ROW\n    EXECUTE FUNCTION validate_problem_category();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 11, 1, 'NewCategory1', 'Solved', '2023-01-01 10:00:00+08:00', 'Test description', 'Test fix', 'Test details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 12, 2, 'NewCategory2', 'Solved', '2023-01-02 11:00:00+08:00', 'Another test', 'Another fix', 'More details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 11, 3, 'Datatabase', 'Solved', '2023-01-03 12:00:00+08:00', 'Existing category test', 'Existing fix', 'Existing details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 12, 1, 'NewCategory3', 'Solved', '2023-01-04 13:00:00+08:00', 'Third new category', 'Third fix', 'Third details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 11, 2, 'GUI', 'Solved', '2023-01-05 14:00:00+08:00', 'GUI category test', 'GUI fix', 'GUI details');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named `validate_problem_category` for the `\"Problem_Log\"` table. For each new row, check if its `problem_category_code` exists in the `\"Problem_Category_Codes\"` table. If it does not exist, insert a new row into `\"Problem_Category_Codes\"` with that code and the description 'Auto-generated category'. Return the NEW row.",
    "natural_language": "Define a BEFORE INSERT trigger function called `validate_problem_category` for the `\"Problem_Log\"` table. For every new row, verify that its `problem_category_code` is present in the `\"Problem_Category_Codes\"` table. If the code is missing, insert a new record into `\"Problem_Category_Codes\"` using that code and set the description to 'Auto-generated category'. Finally, return the NEW row.",
    "id": 46
  },
  {
    "ir": "Write a PostgreSQL trigger function named log_problem_assignment_trigger that is executed automatically after each new row is inserted into the Problems table, and within this function, perform an insert operation into the Problem_Log table, populating the following columns: problem_log_id is set by calculating the next sequential integer value using a subquery that selects the maximum existing problem_log_id from the Problem_Log table, applying the COALESCE function to handle null values by returning 0 if no maximum exists, and then adding 1 to that result; assigned_to_staff_id is set to the value of the reported_by_staff_id column from the newly inserted Problems row (referenced as NEW.reported_by_staff_id); problem_id is set to the value of the problem_id column from the NEW row; problem_category_code is set to the literal string 'GUI'; problem_status_code is set to the literal string 'Reported'; log_entry_date is set to the value of the date_problem_reported column from the NEW row; log_entry_description is set to the literal string 'Problem reported'; log_entry_fix is set to an empty string; and other_log_details is also set to an empty string, and finally, the trigger function returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION log_problem_assignment_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") \n    VALUES ((SELECT COALESCE(MAX(\"problem_log_id\"), 0) + 1 FROM \"Problem_Log\"), NEW.\"reported_by_staff_id\", NEW.\"problem_id\", 'GUI', 'Reported', NEW.\"date_problem_reported\", 'Problem reported', '', '');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_problem_assignment_trigger\n    AFTER INSERT ON \"Problems\"\n    FOR EACH ROW\n    EXECUTE FUNCTION log_problem_assignment_trigger();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problems\" (\"problem_id\", \"product_id\", \"closure_authorised_by_staff_id\", \"reported_by_staff_id\", \"date_problem_reported\", \"problem_description\", \"other_problem_details\") VALUES (4, 5, 3, 2, '2023-10-01 10:00:00+08:00', 'New problem description', 'Details');",
      "INSERT INTO \"Problems\" (\"problem_id\", \"product_id\", \"closure_authorised_by_staff_id\", \"reported_by_staff_id\", \"date_problem_reported\", \"problem_description\", \"other_problem_details\") VALUES (5, 6, 4, 10, '2023-10-02 11:00:00+08:00', 'Another problem description', 'More details');",
      "INSERT INTO \"Problems\" (\"problem_id\", \"product_id\", \"closure_authorised_by_staff_id\", \"reported_by_staff_id\", \"date_problem_reported\", \"problem_description\", \"other_problem_details\") VALUES (6, 7, 1, 1, '2023-10-03 12:00:00+08:00', 'Problem description here', 'Additional details');",
      "INSERT INTO \"Problems\" (\"problem_id\", \"product_id\", \"closure_authorised_by_staff_id\", \"reported_by_staff_id\", \"date_problem_reported\", \"problem_description\", \"other_problem_details\") VALUES (7, 8, 2, 3, '2023-10-04 13:00:00+08:00', 'Description of the problem', 'Other details');",
      "INSERT INTO \"Problems\" (\"problem_id\", \"product_id\", \"closure_authorised_by_staff_id\", \"reported_by_staff_id\", \"date_problem_reported\", \"problem_description\", \"other_problem_details\") VALUES (8, 9, 3, 2, '2023-10-05 14:00:00+08:00', 'Problem details', 'Further details');"
    ],
    "summary": "Create an AFTER INSERT trigger function named `log_problem_assignment_trigger` for the `Problems` table. For each new row, insert a corresponding record into the `Problem_Log` table. The new log entry should have: a sequential `problem_log_id` (max+1 or 1), `assigned_to_staff_id` from `NEW.reported_by_staff_id`, `problem_id` from NEW, `problem_category_code` as 'GUI', `problem_status_code` as 'Reported', `log_entry_date` from `NEW.date_problem_reported`, `log_entry_description` as 'Problem reported', and empty strings for `log_entry_fix` and `other_log_details`. Return the NEW row.",
    "natural_language": "How can I create an AFTER INSERT trigger function named `log_problem_assignment_trigger` for the `Problems` table that, for each new row, inserts a corresponding record into the `Problem_Log` table? The new log entry should have: a sequential `problem_log_id` (using max+1 or starting at 1), `assigned_to_staff_id` taken from `NEW.reported_by_staff_id`, `problem_id` from NEW, `problem_category_code` set to 'GUI', `problem_status_code` set to 'Reported', `log_entry_date` taken from `NEW.date_problem_reported`, `log_entry_description` set to 'Problem reported', and empty strings for `log_entry_fix` and `other_log_details`. The function should return the NEW row.",
    "id": 47
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_problem_log_on_status_change that executes after each row update on the Problem_Log table, and within this function, if the new value of the problem_status_code column differs from the old value of the problem_status_code column, then perform an insert into the Problem_Log table with the following column values: for the problem_log_id column, use the result of a subquery that selects the maximum value from the problem_log_id column in the Problem_Log table, adds one to it, and uses zero if the maximum is null; for the assigned_to_staff_id column, use the result of a subquery that selects the reported_by_staff_id column from the Problems table where the problem_id column equals the new problem_id value from the updated row; for the problem_id column, use the new problem_id value from the updated row; for the problem_category_code column, use the result of a subquery that selects the problem_category_code column from the Problem_Log table where the problem_id column equals the new problem_id value, ordered by the log_entry_date column in descending order, and limited to one row; for the problem_status_code column, use the new problem_status_code value from the updated row; for the log_entry_date column, use the current timestamp; for the log_entry_description column, use a string concatenation of the literal 'Status changed from ', the old problem_status_code value, the literal ' to ', and the new problem_status_code value; for the log_entry_fix column, use an empty string; and for the other_log_details column, use an empty string; after the conditional block, the function returns the new row record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_problem_log_on_status_change() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"problem_status_code\" != OLD.\"problem_status_code\" THEN\n        INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") \n        VALUES ((SELECT COALESCE(MAX(\"problem_log_id\"), 0) + 1 FROM \"Problem_Log\"), (SELECT \"reported_by_staff_id\" FROM \"Problems\" WHERE \"problem_id\" = NEW.\"problem_id\"), NEW.\"problem_id\", (SELECT \"problem_category_code\" FROM \"Problem_Log\" WHERE \"problem_id\" = NEW.\"problem_id\" ORDER BY \"log_entry_date\" DESC LIMIT 1), NEW.\"problem_status_code\", CURRENT_TIMESTAMP, 'Status changed from ' || OLD.\"problem_status_code\" || ' to ' || NEW.\"problem_status_code\", '', '');\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_problem_log_on_status_change\n    AFTER UPDATE ON \"Problem_Log\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_problem_log_on_status_change();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Problem_Log\" SET \"problem_status_code\" = 'Reported' WHERE \"problem_log_id\" = 1;",
      "UPDATE \"Problem_Log\" SET \"problem_status_code\" = 'Solved' WHERE \"problem_log_id\" = 2;",
      "UPDATE \"Problem_Log\" SET \"problem_status_code\" = 'Reported' WHERE \"problem_log_id\" = 3;",
      "UPDATE \"Problem_Log\" SET \"problem_status_code\" = 'Solved' WHERE \"problem_log_id\" = 1;",
      "UPDATE \"Problem_Log\" SET \"problem_status_code\" = 'Reported' WHERE \"problem_log_id\" = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named `update_problem_log_on_status_change` for the `Problem_Log` table. If the `problem_status_code` has changed, insert a new row into `Problem_Log`. The new row should have: a sequential `problem_log_id`, `assigned_to_staff_id` from the related `Problems.reported_by_staff_id`, the updated `problem_id`, the latest `problem_category_code` for that problem, the new `problem_status_code`, the current timestamp as `log_entry_date`, a description concatenating 'Status changed from ', the old status, ' to ', and the new status, and empty strings for `log_entry_fix` and `other_log_details`. Return the NEW row.",
    "natural_language": "Make a trigger that runs after updates on the Problem_Log table, call it something like update_problem_log_on_status_change. Basically, if the problem status gets updated to something different, you should add a new record to the log. For that new entry, generate the next ID number, get the staff ID from the related problem's reporter, use the updated problem ID, grab whatever the latest category code is for that problem, take the new status code, set the timestamp to now, and for the description, just combine text saying the status changed from the old one to the new one. Leave the fix entry and other details blank. Have it return the new row data.",
    "id": 48
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Problem_Log\" table. This function, named check_staff_assignment, checks if a staff member with the ID specified in the NEW.\"assigned_to_staff_id\" column of the row being inserted already exists in the \"Staff\" table. If no such staff member exists, the function inserts a new row into the \"Staff\" table with the \"staff_id\" set to NEW.\"assigned_to_staff_id\", \"staff_first_name\" set to 'Auto', \"staff_last_name\" set to 'Generated', and \"other_staff_details\" set to 'Created by trigger'. The function then returns the NEW row, allowing the insert operation on the \"Problem_Log\" table to proceed. The trigger, named trg_check_staff_assignment, is defined to execute this function for each row before an insert operation on the \"Problem_Log\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION check_staff_assignment() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Staff\" WHERE \"staff_id\" = NEW.\"assigned_to_staff_id\") THEN\n        INSERT INTO \"Staff\" (\"staff_id\", \"staff_first_name\", \"staff_last_name\", \"other_staff_details\") VALUES (NEW.\"assigned_to_staff_id\", 'Auto', 'Generated', 'Created by trigger');\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_staff_assignment\n    BEFORE INSERT ON \"Problem_Log\"\n    FOR EACH ROW\n    EXECUTE FUNCTION check_staff_assignment();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (4, 13, 2, 'Datatabase', 'Reported', '2023-10-01 10:00:00+08:00', 'New entry', 'Fix applied', 'Details');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (5, 14, 3, 'GUI', 'Solved', '2023-10-02 11:00:00+08:00', 'Another entry', 'Another fix', 'More details');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (6, 15, 1, 'Middleware', 'Reported', '2023-10-03 12:00:00+08:00', 'Entry description', 'Fix description', 'Additional details');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (7, 16, 2, 'Datatabase', 'Solved', '2023-10-04 13:00:00+08:00', 'Description here', 'Fix here', 'Details here');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (8, 17, 3, 'GUI', 'Reported', '2023-10-05 14:00:00+08:00', 'Log entry', 'Log fix', 'Log details');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named `check_staff_assignment` for the `\"Problem_Log\"` table. For each new row, check if the `assigned_to_staff_id` exists in the `\"Staff\"` table. If it does not exist, insert a new staff member with that ID, first name 'Auto', last name 'Generated', and details 'Created by trigger'. Return the NEW row.",
    "natural_language": "Set up a trigger that runs before adding entries to the \"Problem_Log\" table. It should look at the staff ID being assigned and, if that person isn't already in the staff list, just go ahead and add a basic record for them with some generic details. Then proceed with the new log entry.",
    "id": 49
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_warehouse_capacity_on_delete that returns a trigger, which is automatically executed by a database trigger named trg_boxes_delete_capacity after a row is deleted from the \"Boxes\" table for each affected row, and within this function, it performs an update operation on the \"Warehouses\" table, specifically incrementing the value of the \"Capacity\" column by one for the single row in the \"Warehouses\" table where the value of the \"Code\" column is exactly equal to the value that was stored in the \"Warehouse\" column of the recently deleted row from the \"Boxes\" table, which is accessed via the OLD record variable, and the function concludes by returning the OLD record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_warehouse_capacity_on_delete() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + 1 WHERE \"Code\" = OLD.\"Warehouse\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_delete_capacity\nAFTER DELETE ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION update_warehouse_capacity_on_delete();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "DELETE FROM \"Boxes\" WHERE \"Code\" = '0MN7';",
      "DELETE FROM \"Boxes\" WHERE \"Warehouse\" = 3;",
      "DELETE FROM \"Boxes\" WHERE \"Contents\" = 'Rocks';",
      "DELETE FROM \"Boxes\" WHERE \"Value\" < 200;",
      "DELETE FROM \"Boxes\";"
    ],
    "summary": "Create an AFTER DELETE trigger function named `update_warehouse_capacity_on_delete` for the `\"Boxes\"` table. For each deleted row, update the `\"Warehouses\"` table by incrementing the `\"Capacity\"` column by 1 for the warehouse where its `\"Code\"` matches the deleted row's `\"Warehouse\"` value. Return the OLD row.",
    "natural_language": "Create AFTER DELETE trigger `update_warehouse_capacity_on_delete` on `\"Boxes\"`. Increment `\"Capacity\"` in `\"Warehouses\"` by 1 where `\"Code\"` matches deleted `\"Warehouse\"`. Return OLD.",
    "id": 50
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `delete_orphaned_station_company` that is designed to be executed in response to data manipulation events on a specific table. This function does not accept any explicit input parameters beyond the implicit `OLD` and `NEW` records provided by the trigger mechanism. It returns a record of type `TRIGGER`, which is a standard requirement for trigger functions in PostgreSQL. The core operation of this function is to perform a `DELETE` statement on the `station_company` table. The rows to be deleted from `station_company` are identified by a `WHERE` clause that compares the value of the `\"Company_ID\"` column in the `station_company` table (aliased as `sc`) with the value of the `\"Company_ID\"` column from the `OLD` record. The `OLD` record represents the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` record.\n\nThis trigger function is associated with a trigger named `trg_delete_orphaned_station_company`. This trigger is configured to activate `AFTER DELETE` operations on the `company` table. It is set to execute `FOR EACH ROW`, meaning that the `delete_orphaned_station_company` function will be invoked once for every row that is deleted from the `company` table. When a row is deleted from the `company` table, the `trg_delete_orphaned_station_company` trigger fires, and for each deleted row, it calls the `delete_orphaned_station_company` function. Inside this function, the `OLD.\"Company_ID\"` refers to the `Company_ID` of the row that was just deleted from the `company` table. The function then uses this `Company_ID` to locate and delete corresponding records in the `station_company` table where the `\"Company_ID\"` column matches the `Company_ID` of the deleted company.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_orphaned_station_company() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM station_company sc\n  WHERE sc.\"Company_ID\" = OLD.\"Company_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_orphaned_station_company\nAFTER DELETE ON company\nFOR EACH ROW EXECUTE FUNCTION delete_orphaned_station_company();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM company WHERE \"Company_ID\" = 1;",
      "DELETE FROM company WHERE \"Company_ID\" = 2;",
      "DELETE FROM company WHERE \"Company_ID\" = 3;",
      "DELETE FROM company WHERE \"Company_ID\" = 4;",
      "DELETE FROM company WHERE \"Company_ID\" = 5;"
    ],
    "summary": "Create a trigger function named `delete_orphaned_station_company` that returns a trigger. It executes after a row is deleted from the `company` table. For each deleted row, it deletes rows from the `station_company` table where the `\"Company_ID\"` matches the deleted row's `\"Company_ID\"`. The function returns the `OLD` record.",
    "natural_language": "Set up a trigger function called `delete_orphaned_station_company` that gives back a trigger. It should run sometime after entries are removed from the `company` table. For each company that's been taken out, it should also clear out any related entries in the `station_company` table where the `\"Company_ID\"` seems to match the old one. The function should then hand back the old record that was there before.",
    "id": 51
  },
  {
    "ir": "Write a PostgreSQL trigger function named calculate_location_bit_length that returns a trigger and is invoked automatically after any update operation on the Location column of the gas_station table for each modified row, where the function's logic compares the bit length of the new Location value to the bit length of the old Location value using the bit_length function, and if the bit length of the new Location value is strictly greater than the bit length of the old Location value, it executes an update statement on the gas_station table, incrementing the Open_Year column by one specifically for the row where the Station_ID column matches the Station_ID value from the newly updated row, and finally the function returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_location_bit_length() RETURNS TRIGGER AS $$\nBEGIN\n  IF bit_length(NEW.\"Location\") > bit_length(OLD.\"Location\") THEN\n    UPDATE gas_station SET \"Open_Year\" = \"Open_Year\" + 1 WHERE \"Station_ID\" = NEW.\"Station_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_calculate_location_bit_length\nAFTER UPDATE OF \"Location\" ON gas_station\nFOR EACH ROW EXECUTE FUNCTION calculate_location_bit_length();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "UPDATE gas_station SET \"Location\" = '123 Main Street, Springfield' WHERE \"Station_ID\" = 1;",
      "UPDATE gas_station SET \"Location\" = '456 Oak Avenue, Longer City Name Example' WHERE \"Station_ID\" = 2;",
      "UPDATE gas_station SET \"Location\" = 'A' WHERE \"Station_ID\" = 3;",
      "UPDATE gas_station SET \"Location\" = 'Herne Hill Updated with More Characters' WHERE \"Station_ID\" = 1;",
      "UPDATE gas_station SET \"Location\" = 'A very long location string designed to increase the bit length significantly compared to the previous value' WHERE \"Station_ID\" = 2;"
    ],
    "summary": "Create a trigger function named `calculate_location_bit_length` that returns a trigger. It executes after an update to the `Location` column of the `gas_station` table. For each updated row, if the bit length of the new `Location` value is greater than the old value's bit length, it increments the `Open_Year` column by one for that row. The function returns the `NEW` record.",
    "natural_language": "Create trigger `calculate_location_bit_length` that runs after updating `Location` in `gas_station`. If new `Location` bit length exceeds the old, increment that row's `Open_Year` by one. Return NEW.",
    "id": 52
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an INSERT or an UPDATE operation on the \"length_meters\" column of the \"bridge\" table. This function calculates the \"length_feet\" value by multiplying the \"length_meters\" value by 3.28084 and assigns this result to the \"length_feet\" column of the new row. During an INSERT operation, it checks if a row with the same \"id\" as the new row already exists in the \"bridge\" table. If such a row exists, the function updates the existing row's \"length_meters\" and \"length_feet\" columns with the values from the new row and returns NULL to cancel the original INSERT operation, effectively preventing duplicate entries based on the \"id\". If no existing row with the same \"id\" is found, the new row is inserted as usual. The trigger named \"bridge_feet_update\" is associated with this function and is set to execute for each row before an INSERT or an UPDATE on the \"length_meters\" column of the \"bridge\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_bridge_feet() RETURNS TRIGGER AS $$\nBEGIN\n  -- Calculate the feet value\n  NEW.\"length_feet\" := NEW.\"length_meters\" * 3.28084;\n  \n  -- For INSERT operations, check if the ID already exists\n  IF TG_OP = 'INSERT' THEN\n    -- Check if a row with this ID already exists\n    IF EXISTS (SELECT 1 FROM \"bridge\" WHERE \"id\" = NEW.\"id\") THEN\n      -- Instead of inserting a duplicate, update the existing row\n      UPDATE \"bridge\" \n      SET \"length_meters\" = NEW.\"length_meters\",\n          \"length_feet\" = NEW.\"length_feet\"\n      WHERE \"id\" = NEW.\"id\";\n      -- Return NULL to cancel the original INSERT\n      RETURN NULL;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER bridge_feet_update\nBEFORE INSERT OR UPDATE OF \"length_meters\" ON \"bridge\"\nFOR EACH ROW EXECUTE FUNCTION update_bridge_feet();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO bridge (id, name, location, length_meters, architect_id) VALUES (4, 'Golden Gate Bridge', 'San Francisco, California, USA', 1280.2, 1);",
      "INSERT INTO bridge (id, name, location, length_meters, architect_id) VALUES (1, 'Updated Fairy Bridge', 'Guangxi, China', 150.5, 2);",
      "UPDATE bridge SET length_meters = 95.0 WHERE id = 2;",
      "INSERT INTO bridge (id, name, location, length_meters, architect_id) VALUES (5, 'Brooklyn Bridge', 'New York, New York, USA', 486.3, 3);",
      "UPDATE bridge SET length_meters = 100.0, name = 'Longer Landscape Arch' WHERE id = 3;"
    ],
    "summary": "Create a trigger function that returns a trigger, named `bridge_feet_update`. It executes before an INSERT or UPDATE on the `\"length_meters\"` column of the `bridge` table. For each row, it calculates `\"length_feet\"` as `\"length_meters\" * 3.28084`. On INSERT, if a row with the same `\"id\"` already exists, it updates the existing row's `\"length_meters\"` and `\"length_feet\"` and returns NULL to cancel the INSERT. Otherwise, it proceeds with the insert.",
    "natural_language": "Define a trigger function named `bridge_feet_update` that returns a trigger. This function is to be executed prior to any INSERT or UPDATE operation on the `\"length_meters\"` column within the `bridge` table. For each affected row, it shall compute the value for the `\"length_feet\"` column as the product of `\"length_meters\"` and 3.28084. In the event of an INSERT operation, should a row possessing an identical `\"id\"` value already exist, the function will instead update the existing row's `\"length_meters\"` and `\"length_feet\"` values and return NULL to prevent the insertion. If no such row exists, the INSERT operation is permitted to proceed.",
    "id": 53
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_architect_from_mill that is executed automatically by a trigger named mill_architect_insert before any new row is inserted into the mill table; this function takes no explicit parameters but has access to the special NEW record variable representing the prospective new row for the mill table; the function's logic performs a single INSERT operation into the architect table, specifying values for two columns: for the id column, it uses the value from the NEW.architect_id field of the triggering mill row, explicitly casting it to text data type, and for the name column, it constructs a string by concatenating the literal string 'Unknown Architect ' with the text representation of the NEW.architect_id value; after this insert, the function returns the unmodified NEW record to allow the original INSERT operation on the mill table to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_architect_from_mill() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"architect\" (\"id\", \"name\") VALUES (NEW.\"architect_id\"::text, 'Unknown Architect ' || NEW.\"architect_id\"::text);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER mill_architect_insert\nBEFORE INSERT ON \"mill\"\nFOR EACH ROW EXECUTE FUNCTION insert_architect_from_mill();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (101, 1, 'Location A', 'Mill A', 'Type A', 2000, 'Notes A');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (102, 2, 'Location B', 'Mill B', 'Type B', 2001, 'Notes B');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (103, 3, 'Location C', 'Mill C', 'Type C', 2002, 'Notes C');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (104, 4, 'Location D', 'Mill D', 'Type D', 2003, 'Notes D');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (105, 5, 'Location E', 'Mill E', 'Type E', 2004, 'Notes E');"
    ],
    "summary": "Create a trigger function named `insert_architect_from_mill` that returns a trigger. It executes before an INSERT into the `mill` table. For each new row, it inserts a record into the `architect` table. The `id` column uses the `NEW.architect_id` cast to text, and the `name` column is set to `'Unknown Architect '` concatenated with the text representation of `NEW.architect_id`. The function returns the `NEW` record.",
    "natural_language": "Alright, so we need a trigger function called `insert_architect_from_mill` that spits out a trigger. Set it to fire off right before we pop a new row into the `mill` table. For every fresh mill entry, it's gotta also add a record to the `architect` table. For the architect's `id`, just use the new row's `architect_id` turned into text. For the `name`, slap together the string 'Unknown Architect ' with that same `architect_id` (as text, of course). Finally, the function should just hand back the `NEW` row.",
    "id": 54
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the architect table. This function, named delete_architect_cascade, does not take any parameters and returns a trigger type. It performs two delete operations: first, it deletes rows from the bridge table where the architect_id column matches the id of the row being deleted from the architect table, casting the OLD.id value to an integer; second, it deletes rows from the mill table where the architect_id column also matches the id of the row being deleted from the architect table, again casting the OLD.id value to an integer. The function then returns the OLD row, which is the row that is about to be deleted from the architect table. The trigger, named architect_delete_cascade, is defined to execute this function for each row before it is deleted from the architect table, ensuring that any related entries in the bridge and mill tables are removed in a cascading manner.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_architect_cascade() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"bridge\" WHERE \"architect_id\" = OLD.\"id\"::integer;\n  DELETE FROM \"mill\" WHERE \"architect_id\" = OLD.\"id\"::integer;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER architect_delete_cascade\nBEFORE DELETE ON \"architect\"\nFOR EACH ROW EXECUTE FUNCTION delete_architect_cascade();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "DELETE FROM architect WHERE id = '1';",
      "DELETE FROM architect WHERE id = '2';",
      "DELETE FROM architect WHERE id = '3';",
      "DELETE FROM architect WHERE id = '4';",
      "DELETE FROM architect WHERE id = '5';"
    ],
    "summary": "Create a trigger function named `delete_architect_cascade` that returns a trigger. It executes before a DELETE on the `architect` table. For each row to be deleted, it first deletes rows from the `bridge` table where `architect_id` matches the `OLD.id` (cast to integer), then deletes rows from the `mill` table where `architect_id` matches the `OLD.id` (cast to integer). The function returns the `OLD` record.",
    "natural_language": "Construct a trigger function, which should be named `delete_architect_cascade`, that is designed to return a trigger. This function is meticulously set to execute just prior to any DELETE operation performed on the `architect` table. For every individual row that is slated for deletion, it will first carefully and completely remove all associated rows from the `bridge` table where the `architect_id` column precisely matches the `OLD.id` value, which must be cast to an integer. Subsequently, it will proceed to delete any corresponding rows from the `mill` table where, similarly, the `architect_id` column equals the `OLD.id` value, also cast to an integer. Finally, the function will return the original `OLD` record.",
    "id": 55
  },
  {
    "ir": "Write a PLpgSQL function named validate_bridge_length that is designed to be used as a trigger function for the bridge table. This function does not take any parameters directly but operates on the special variables NEW and TG_OP, which are provided by the trigger mechanism. The function first checks if the operation being performed is an INSERT, indicated by TG_OP being equal to 'INSERT'. If so, it verifies whether the id of the new row (NEW.\"id\") already exists in the bridge table by executing a SELECT query with a condition on the id column. If a row with the same id is found, the function generates a new unique id by selecting the maximum id currently in the bridge table, adding one to it, and assigning this value to NEW.\"id\". This ensures that the id is unique for the new row. The function then proceeds to validate the length fields of the new row. It checks if the length_meters column of the new row (NEW.\"length_meters\") is less than zero, and if so, sets it to zero to prevent negative values. Similarly, it checks if the length_feet column (NEW.\"length_feet\") is less than zero and sets it to zero if necessary. After performing these validations and potential modifications, the function returns the NEW record, which contains the potentially modified data. This function is associated with a trigger named bridge_length_validation, which is set to fire before any INSERT or UPDATE operation on the bridge table, ensuring that the validations and id adjustments are applied to each new or updated row before it is committed to the table.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_bridge_length() RETURNS TRIGGER AS $$\nDECLARE\n    max_id INTEGER;\nBEGIN\n  -- Handle duplicate id for INSERT operations\n  IF TG_OP = 'INSERT' THEN\n    -- Check if the id already exists\n    IF EXISTS (SELECT 1 FROM \"bridge\" WHERE \"id\" = NEW.\"id\") THEN\n      -- Generate a new unique id\n      SELECT COALESCE(MAX(\"id\"), 0) + 1 INTO max_id FROM \"bridge\";\n      NEW.\"id\" := max_id;\n    END IF;\n  END IF;\n\n  -- Validate length fields\n  IF NEW.\"length_meters\" < 0 THEN\n    NEW.\"length_meters\" := 0;\n  END IF;\n  IF NEW.\"length_feet\" < 0 THEN\n    NEW.\"length_feet\" := 0;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER bridge_length_validation\nBEFORE INSERT OR UPDATE ON \"bridge\"\nFOR EACH ROW EXECUTE FUNCTION validate_bridge_length();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO bridge (id, name, location, length_meters, length_feet, architect_id) VALUES (1, 'Test Bridge', 'Test Location', 100.0, 328.0, 1);",
      "INSERT INTO bridge (id, name, location, length_meters, length_feet, architect_id) VALUES (1, 'Duplicate ID Bridge', 'Another Location', -50.0, -164.0, 2);",
      "UPDATE bridge SET length_meters = -25.5, length_feet = -83.7 WHERE id = 1;",
      "INSERT INTO bridge (name, location, length_meters, length_feet, architect_id) VALUES ('Auto ID Bridge', 'Auto Location', 75.0, 246.0, 3);",
      "UPDATE bridge SET length_feet = -100.0 WHERE name = 'Landscape Arch';"
    ],
    "summary": "Create a trigger function named validate_bridge_length that runs before INSERT or UPDATE on the bridge table. For INSERT operations, if the new id already exists, generate a new unique id by taking the maximum current id and adding 1. Then, ensure the length_meters and length_feet columns are not negative by setting any negative values to zero. Return the modified NEW row.",
    "natural_language": "Construct a trigger function, which should be named validate_bridge_length, designed to execute automatically prior to any INSERT or UPDATE operation performed on the bridge table. In the specific case of an INSERT, if the newly provided id is found to already exist within the table, the function must intelligently generate a fresh, unique identifier by calculating the current maximum id value and then incrementing it by one. Furthermore, the function must thoroughly validate the length_meters and length_feet columns to ensure no negative values are permitted; it should proactively intercept any negative entries and gracefully reset them to zero. Finally, the function must return the fully modified and validated NEW row for processing.",
    "id": 56
  },
  {
    "ir": "Write a PostgreSQL trigger function named log_new_member that returns a trigger, which is executed by a trigger named log_new_member_trigger configured to fire automatically after every successful insertion of a new row into the club_leader table for each affected row, where the function's logic begins by performing an insert operation into the member table targeting the columns Member_ID, Name, Nationality, and Age, using values derived from the newly inserted row in club_leader referenced by the special NEW record, specifically taking the integer value from NEW.Member_ID, adding 1000 to it, and using that result as the Member_ID for the new log entry, while the Name column is set to the literal string 'Log Entry', the Nationality column is set to the literal string 'Unknown', and the Age column is set to the integer 0, and this insert operation includes an ON CONFLICT clause specifying that if a conflict arises on the unique or primary key constraint of the Member_ID column in the member table, the operation should take no action and silently skip the insertion, and finally the function returns the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION log_new_member() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Nationality\", \"Age\") \n  VALUES (NEW.\"Member_ID\" + 1000, 'Log Entry', 'Unknown', 0)\n  ON CONFLICT (\"Member_ID\") DO NOTHING;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_new_member_trigger\nAFTER INSERT ON \"club_leader\"\nFOR EACH ROW EXECUTE FUNCTION log_new_member();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1990, '2023');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (3, 1991, '2022');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (4, 1992, '2021');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (5, 1993, '2020');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (6, 1994, '2019');"
    ],
    "summary": "Create a trigger function named log_new_member that runs after INSERT on the club_leader table. For each new row, insert a record into the member table. Set the Member_ID to the new row's Member_ID plus 1000. Set Name to 'Log Entry', Nationality to 'Unknown', and Age to 0. If a conflict occurs on the Member_ID column, do nothing. Return the NEW row.",
    "natural_language": "Please construct a trigger function designated as 'log_new_member' to execute subsequent to INSERT operations on the 'club_leader' table. For each inserted row, it is required to insert a corresponding record into the 'member' table. The 'Member_ID' value shall be derived by adding 1000 to the new row's 'Member_ID'. Assign the values 'Log Entry' to the 'Name' column, 'Unknown' to the 'Nationality' column, and 0 to the 'Age' column. In the event of a conflict pertaining to the 'Member_ID' column, the operation should take no action. The function must conclude by returning the NEW row.",
    "id": 57
  },
  {
    "ir": "Write a PostgreSQL trigger function named archive_club_data that is executed automatically by a trigger named archive_club_data_trigger after each row is deleted from the table named club, where the trigger function performs a single INSERT operation into the same club table, inserting a new row with the following column values: for the Club_ID column, it uses the value from the OLD record's Club_ID column and adds the constant integer 5000 to it; for the Overall_Ranking column, it directly uses the value from the OLD record's Overall_Ranking column; for the Team_Leader column, it inserts the constant string literal 'Archived'; and for the Club_Name column, it inserts the constant string literal 'Archive', and the function concludes by returning NULL to indicate the trigger operation does not affect the original DELETE operation.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_club_data() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"club\" (\"Club_ID\", \"Overall_Ranking\", \"Team_Leader\", \"Club_Name\") VALUES (OLD.\"Club_ID\" + 5000, OLD.\"Overall_Ranking\", 'Archived', 'Archive');\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER archive_club_data_trigger\nAFTER DELETE ON \"club\"\nFOR EACH ROW EXECUTE FUNCTION archive_club_data();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "DELETE FROM \"club\" WHERE \"Club_ID\" = 1;",
      "DELETE FROM \"club\" WHERE \"Club_ID\" = 3;",
      "DELETE FROM \"club\" WHERE \"Club_ID\" = 4;",
      "DELETE FROM \"club\" WHERE \"Overall_Ranking\" = 5;",
      "DELETE FROM \"club\" WHERE \"Team_Leader\" = 'Mack Mitchell';"
    ],
    "summary": "Create a trigger function named archive_club_data that runs after DELETE on the club table. For each deleted row, insert a new row into the club table. Set Club_ID to the old Club_ID plus 5000, Overall_Ranking to the old value, Team_Leader to 'Archived', and Club_Name to 'Archive'. Return NULL.",
    "natural_language": "How can I create a trigger function named archive_club_data that executes after a DELETE on the club table, inserting a new row for each deleted row with Club_ID set to the old Club_ID plus 5000, Overall_Ranking set to the old value, Team_Leader set to 'Archived', and Club_Name set to 'Archive', and then returns NULL?",
    "id": 58
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `track_club_changes` that, when executed, performs a single `INSERT` operation into the table named `\"club\"`. This `INSERT` operation populates four specific columns: `\"Club_ID\"`, `\"Overall_Ranking\"`, `\"Team_Leader\"`, and `\"Club_Name\"`. The value for the `\"Club_ID\"` column is derived by taking the value of the `\"Club_ID\"` column from the `OLD` row (representing the state of the row before the triggering `UPDATE` event) and adding the integer literal `3000` to it. The value for the `\"Overall_Ranking\"` column is calculated by first dividing the value of the `\"Overall_Ranking\"` column from the `OLD` row by the floating-point literal `2.0`, and then applying the `CEIL()` function to round the result up to the nearest whole number. The value for the `\"Team_Leader\"` column is set to the string literal `'Historical'`. The value for the `\"Club_Name\"` column is directly taken from the `\"Club_Name\"` column of the `OLD` row. After performing this `INSERT` operation, the function explicitly returns `NULL`, indicating that no modification to the current row is intended by the trigger function itself.\n\nAdditionally, define a trigger named `track_club_changes_trigger` that is configured to activate `AFTER` an `UPDATE` operation occurs on the table named `\"club\"`. This trigger is specified to execute `FOR EACH ROW` that is affected by the `UPDATE` statement. When activated, this trigger will `EXECUTE` the previously defined function, `track_club_changes()`.",
    "plsql": "CREATE OR REPLACE FUNCTION track_club_changes() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"club\" (\"Club_ID\", \"Overall_Ranking\", \"Team_Leader\", \"Club_Name\") VALUES (OLD.\"Club_ID\" + 3000, CEIL(OLD.\"Overall_Ranking\" / 2.0), 'Historical', OLD.\"Club_Name\");\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER track_club_changes_trigger\nAFTER UPDATE ON \"club\"\nFOR EACH ROW EXECUTE FUNCTION track_club_changes();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "UPDATE \"club\" SET \"Overall_Ranking\" = 6 WHERE \"Club_ID\" = 1;",
      "UPDATE \"club\" SET \"Overall_Ranking\" = 58 WHERE \"Club_ID\" = 3;",
      "UPDATE \"club\" SET \"Overall_Ranking\" = 83 WHERE \"Club_ID\" = 4;",
      "UPDATE \"club\" SET \"Team_Leader\" = 'New Leader' WHERE \"Club_ID\" = 1;",
      "UPDATE \"club\" SET \"Club_Name\" = 'New Club Name' WHERE \"Club_ID\" = 3;"
    ],
    "summary": "Create a trigger function named track_club_changes that runs after UPDATE on the club table. For each updated row, insert a new row into the club table. Set Club_ID to the old Club_ID plus 3000, Overall_Ranking to the ceiling of the old Overall_Ranking divided by 2.0, Team_Leader to 'Historical', and Club_Name to the old Club_Name. Return NULL.",
    "natural_language": "Construct a trigger function designated as track_club_changes, which is meticulously configured to execute automatically following any UPDATE operation performed on the club table. For every individual row that has been modified, the function must carefully insert a fresh record into the club table. In this new entry, the Club_ID should be assigned the previous Club_ID value incremented precisely by 3000, the Overall_Ranking must be calculated as the mathematical ceiling of the former Overall_Ranking divided meticulously by 2.0, the Team_Leader field should be definitively set to the static label 'Historical', and the Club_Name ought to be carried over directly from the original, old Club_Name. The function should conclusively return a NULL value.",
    "id": 59
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_teacher_age_trigger that returns a trigger object, which is automatically invoked as an AFTER INSERT trigger named teacher_age_update_trigger on the teacher table for each new row inserted. The function's logic, upon each invocation, performs an UPDATE operation on the teacher table, specifically targeting the column named Age. It sets the value of the Age column to the absolute value obtained from the abs function applied to the newly inserted row's Teacher_ID value, which is accessed via the NEW record's Teacher_ID field. This update is executed conditionally, applying only to the row in the teacher table where the Teacher_ID column matches the value of NEW.Teacher_ID from the triggering insert event. The function concludes by returning the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_teacher_age_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE teacher SET \"Age\" = abs(NEW.\"Teacher_ID\") WHERE \"Teacher_ID\" = NEW.\"Teacher_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER teacher_age_update_trigger\n    AFTER INSERT ON teacher\n    FOR EACH ROW\n    EXECUTE FUNCTION update_teacher_age_trigger();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "INSERT INTO teacher (Teacher_ID, Name, Age, Hometown) VALUES (10, 'John Doe', '30', 'New York');",
      "INSERT INTO teacher (Teacher_ID, Name, Age, Hometown) VALUES (-5, 'Jane Smith', '25', 'Los Angeles');",
      "INSERT INTO teacher (Teacher_ID, Name, Age, Hometown) VALUES (100, 'Peter Jones', '40', 'Chicago');",
      "INSERT INTO teacher (Teacher_ID, Name, Age, Hometown) VALUES (-20, 'Alice Brown', '35', 'Houston');",
      "INSERT INTO teacher (Teacher_ID, Name, Age, Hometown) VALUES (7, 'Bob White', '28', 'Miami');"
    ],
    "summary": "Create a trigger function named update_teacher_age_trigger that runs after INSERT on the teacher table. For each new row, update the Age column in the teacher table for the row with the matching Teacher_ID, setting Age to the absolute value of the new Teacher_ID. Return the NEW row.",
    "natural_language": "Set up a trigger function called update_teacher_age_trigger that activates after a teacher gets added. For each fresh entry, adjust the Age field for that specific teacher by making it the positive version of their ID number. Hand back the new record.",
    "id": 60
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_course_arrange_trigger that returns a trigger, which is executed by a trigger named course_delete_trigger configured to fire BEFORE DELETE on the course table for each individual row being deleted, where the function body performs a DELETE operation on the course_arrange table targeting all rows where the value in the course_arrange table's column named Course_ID (enclosed in double quotes) is exactly equal to the value of the column named Course_ID (also enclosed in double quotes) from the OLD special record representing the course table row that is about to be deleted, and then the function returns the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_course_arrange_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM course_arrange WHERE \"Course_ID\" = OLD.\"Course_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER course_delete_trigger\n    BEFORE DELETE ON course\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_course_arrange_trigger();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "DELETE FROM course WHERE \"Course_ID\" = 1;",
      "DELETE FROM course WHERE \"Course_ID\" = 2;",
      "DELETE FROM course WHERE \"Course_ID\" = 3;"
    ],
    "summary": "Create a trigger function named delete_course_arrange_trigger that fires BEFORE DELETE on the course table for each row. It deletes rows from the course_arrange table where its \"Course_ID\" equals the OLD record's \"Course_ID\", then returns OLD.",
    "natural_language": "How do you create a trigger function named delete_course_arrange_trigger that fires BEFORE DELETE on the course table for each row, deleting rows from the course_arrange table where its \"Course_ID\" equals the OLD record's \"Course_ID\" and then returns OLD?",
    "id": 61
  },
  {
    "ir": "Write a PLpgSQL function named update_course_grade_trigger that is designed to be executed as a trigger function. This function does not take any parameters directly but operates using the implicit NEW and OLD records provided by the trigger mechanism. The function performs an update operation on the course_arrange table, specifically targeting the Grade column. It sets the Grade column to the absolute value of the NEW.Teacher_ID, which is the identifier of the teacher after an update operation has occurred on the teacher table. The update is applied to all rows in the course_arrange table where the Teacher_ID matches the OLD.Teacher_ID, which is the identifier of the teacher before the update operation. The function concludes by returning the NEW record, which is a standard practice for trigger functions to indicate the modified row. Additionally, a trigger named teacher_update_trigger is created to automatically invoke the update_course_grade_trigger function after any update operation on the teacher table. This trigger is defined to execute for each row that is updated, ensuring that the function is called individually for each row affected by the update operation on the teacher table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_course_grade_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE course_arrange\n    SET \"Grade\" = abs(NEW.\"Teacher_ID\")\n    WHERE \"Teacher_ID\" = OLD.\"Teacher_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER teacher_update_trigger\n    AFTER UPDATE ON teacher\n    FOR EACH ROW\n    EXECUTE FUNCTION update_course_grade_trigger();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "UPDATE teacher SET \"Teacher_ID\" = 10 WHERE \"Teacher_ID\" = 1;",
      "UPDATE teacher SET \"Teacher_ID\" = 15 WHERE \"Name\" = 'Joseph Huts';",
      "UPDATE teacher SET \"Teacher_ID\" = ABS(\"Teacher_ID\") WHERE \"Teacher_ID\" = 2;",
      "UPDATE teacher SET \"Age\" = '33', \"Teacher_ID\" = 20 WHERE \"Teacher_ID\" = 3;",
      "UPDATE teacher SET \"Teacher_ID\" = -5 WHERE \"Hometown\" = 'Bolton County Borough';"
    ],
    "summary": "Create a trigger function named update_course_grade_trigger that fires AFTER UPDATE on the teacher table for each row. It updates the Grade column in the course_arrange table to the absolute value of NEW.Teacher_ID where Teacher_ID equals OLD.Teacher_ID, then returns NEW.",
    "natural_language": "Please construct a trigger function designated as 'update_course_grade_trigger'. This function should be configured to execute subsequent to any UPDATE operation performed on the 'teacher' table, acting upon each modified row. Its operational logic must update the 'Grade' column within the 'course_arrange' table, setting its value to the absolute magnitude of the NEW.Teacher_ID. This update is to be applied specifically to records where the 'Teacher_ID' matches the OLD.Teacher_ID. The function must conclude by returning the NEW row.",
    "id": 62
  },
  {
    "ir": "Write a PLpgSQL trigger function named adjust_course_grade_trigger that is executed after a new row is inserted into the course_arrange table. This function updates the Grade column in the course_arrange table to the absolute value of the newly inserted Grade for the row where the Course_ID matches the newly inserted Course_ID and the Teacher_ID matches the newly inserted Teacher_ID. The trigger named course_arrange_insert_trigger is defined to invoke this function after each row insertion into the course_arrange table, ensuring that the Grade value is always stored as a non-negative number. The function returns the newly inserted row after performing the update operation.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_course_grade_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE course_arrange SET \"Grade\" = abs(NEW.\"Grade\") WHERE \"Course_ID\" = NEW.\"Course_ID\" AND \"Teacher_ID\" = NEW.\"Teacher_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER course_arrange_insert_trigger\n    AFTER INSERT ON course_arrange\n    FOR EACH ROW\n    EXECUTE FUNCTION adjust_course_grade_trigger();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (2, 5, -1);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (3, 3, -3);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (2, 2, -5);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (3, 5, -2);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (2, 3, -4);"
    ],
    "summary": "Create a trigger function named adjust_course_grade_trigger that fires AFTER INSERT on the course_arrange table for each row. It updates the Grade column in the same table to the absolute value of the NEW.Grade for the row matching the inserted Course_ID and Teacher_ID, then returns NEW.",
    "natural_language": "Set up a trigger function called adjust_course_grade_trigger that runs after something gets added to the course_arrange table. For each new entry, it should kind of adjust the Grade column in that same table, making sure the grade is a positive number for that specific course and teacher combination, and then just pass along the new record.",
    "id": 63
  },
  {
    "ir": "Write a PLpgSQL function named update_order_details_on_invoice that is designed to be executed as a trigger function. This function is triggered before an INSERT operation on the Invoices table. The function attempts to insert a new record into the Orders table with the following columns: order_id, customer_id, date_order_placed, and order_details. The order_id is taken from the NEW record being inserted into the Invoices table. The customer_id is selected from the Customers table, specifically choosing a random customer whose customer_first_name has a length greater than 3 characters. The date_order_placed is set to the current timestamp at the time of the trigger execution. The order_details column is populated with the string 'Auto-generated from invoice via trigger'. The function uses the ON CONFLICT clause to handle any potential duplicate order_id values by doing nothing if a conflict occurs, thus preventing any duplicate key errors. After attempting the insertion into the Orders table, the function returns the NEW record, allowing the original INSERT operation into the Invoices table to proceed. The trigger named trg_invoice_to_order is created to execute this function for each row before an INSERT operation on the Invoices table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_details_on_invoice() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the order already exists in \"Orders\" to prevent duplicate key errors\n  -- and satisfy the foreign key constraint on \"Invoices\" before the actual INSERT into \"Invoices\" happens.\n  INSERT INTO \"Orders\" (\"order_id\", \"customer_id\", \"date_order_placed\", \"order_details\")\n  VALUES (\n    NEW.\"order_id\",\n    (SELECT \"customer_id\" FROM \"Customers\" WHERE LENGTH(\"customer_first_name\") > 3 ORDER BY RANDOM() LIMIT 1),\n    CURRENT_TIMESTAMP,\n    'Auto-generated from invoice via trigger'\n  )\n  ON CONFLICT (order_id) DO NOTHING; -- If an order with this ID already exists, do nothing.\n\n  RETURN NEW; -- Allow the INSERT into \"Invoices\" to proceed\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_invoice_to_order\nBEFORE INSERT ON \"Invoices\"\nFOR EACH ROW EXECUTE FUNCTION update_order_details_on_invoice();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Invoices",
      "Invoice_Line_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (100, 500, CURRENT_TIMESTAMP);",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (101, 501, '2024-01-15 10:30:00+00');",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (102, 502, CURRENT_TIMESTAMP);",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (103, 503, '2024-03-20 14:45:00+00');",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (104, 504, CURRENT_TIMESTAMP);"
    ],
    "summary": "Create a trigger function named update_order_details_on_invoice that fires BEFORE INSERT on the Invoices table for each row. It attempts to insert a row into the Orders table using NEW.order_id, a random customer_id from Customers where customer_first_name length > 3, the current timestamp, and a fixed order_details string. On conflict with order_id, do nothing. Return NEW.",
    "natural_language": "Define a trigger function called update_order_details_on_invoice to execute BEFORE INSERT on the Invoices table for each row. Make it attempt to insert a row into the Orders table using the NEW.order_id, a random customer_id from the Customers table where the length of the customer's first name is greater than 3, the current timestamp, and a fixed order_details string. Instruct it to do nothing if there is a conflict on the order_id. Ensure it returns NEW.",
    "id": 64
  },
  {
    "ir": "Write a PostgreSQL trigger function named validate_product_price that returns a trigger and is invoked by a trigger named trg_check_product_price, which is defined to execute before any insert or update operation on the table named \"Products\" for each affected row, where the function logic inspects the new row value for the column \"unit_price\" and, if this value is less than or equal to zero, modifies the new row by setting the \"unit_price\" column to the fixed numeric value 1.00, and then returns the modified new row for the database operation to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_product_price() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"unit_price\" <= 0 THEN\n    NEW.\"unit_price\" := 1.00;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_product_price\nBEFORE INSERT OR UPDATE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION validate_product_price();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Invoices",
      "Invoice_Line_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Products\" (product_id, product_name, unit_price) VALUES (100, 'Test Product', -10.00);",
      "INSERT INTO \"Products\" (product_id, product_name, unit_price) VALUES (101, 'Zero Price Product', 0.00);",
      "UPDATE \"Products\" SET unit_price = -5.50 WHERE product_id = 1;",
      "UPDATE \"Products\" SET unit_price = 0.00 WHERE product_id = 2;",
      "INSERT INTO \"Products\" (product_id, product_name, unit_price, production_type_code) VALUES (102, 'Valid Price Product', 25.99, 'Electronics');"
    ],
    "summary": "Create a trigger function named validate_product_price that fires BEFORE INSERT OR UPDATE on the \"Products\" table for each row. If the new \"unit_price\" is <= 0, set it to 1.00. Return the modified NEW row.",
    "natural_language": "Construct a trigger function, which should be named validate_product_price, designed to activate BEFORE either an INSERT operation or an UPDATE operation is performed on the database table known as \"Products,\" specifically for each individual row that is affected. In the event that the newly provided value for the \"unit_price\" column is found to be less than or equal to zero, the function must then carefully and automatically adjust that value, setting it precisely to 1.00 instead. Finally, the function must return the NEW row record, now containing the potentially modified data.",
    "id": 65
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically sets the invoice_date column in the Invoices table to the date_order_placed value from the Orders table whenever a new row is inserted into the Invoices table. The function set_invoice_date_from_order is defined to return a trigger and is executed before each row insertion on the Invoices table. It takes no parameters directly but operates on the NEW record, which represents the row being inserted. Within the function, a SELECT statement retrieves the date_order_placed from the Orders table where the order_id matches the order_id of the NEW record being inserted into the Invoices table. The retrieved date_order_placed is then assigned to the invoice_date column of the NEW record. The function concludes by returning the modified NEW record, ensuring that the invoice_date is set appropriately before the row is inserted into the Invoices table. The trigger named trg_default_invoice_date is created to invoke this function before any insert operation on the Invoices table, ensuring that every new invoice automatically inherits the order placement date from the corresponding order.",
    "plsql": "CREATE OR REPLACE FUNCTION set_invoice_date_from_order() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.\"invoice_date\" := (SELECT \"date_order_placed\" FROM \"Orders\" WHERE \"order_id\" = NEW.\"order_id\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_default_invoice_date\nBEFORE INSERT ON \"Invoices\"\nFOR EACH ROW EXECUTE FUNCTION set_invoice_date_from_order();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Invoices",
      "Invoice_Line_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Invoices\" (\"invoice_number\", \"order_id\") VALUES (100, 1);",
      "INSERT INTO \"Invoices\" (\"invoice_number\", \"order_id\") VALUES (101, 2);",
      "INSERT INTO \"Invoices\" (\"invoice_number\", \"order_id\", \"invoice_date\") VALUES (102, 3, NULL);",
      "INSERT INTO \"Invoices\" (\"invoice_number\", \"order_id\") VALUES (103, 9);",
      "INSERT INTO \"Invoices\" (\"invoice_number\", \"order_id\") VALUES (104, 12);"
    ],
    "summary": "Create a BEFORE INSERT trigger on the Invoices table. For each new row, set invoice_date to the date_order_placed from the Orders table where order_id matches.",
    "natural_language": "Please implement a BEFORE INSERT trigger for the Invoices table. For each inserted row, the invoice_date column should be populated with the date_order_placed value from the Orders table, corresponding to the matching order_id.",
    "id": 66
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `validate_employee_deletion` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function's purpose is to determine whether a `DELETE` operation on an employee record should be allowed to proceed. Inside the function, a conditional statement (`IF EXISTS`) is evaluated. This condition performs a `SELECT` operation to check for the existence of any records in the `\"Order_Deliveries\"` table. The `SELECT` statement specifically looks for rows where the `driver_employee_id` column matches the `employee_id` from the `OLD` record (the employee record being considered for deletion). If at least one such record is found in `\"Order_Deliveries\"`, indicating that the employee slated for deletion is currently associated as a driver with existing order deliveries, the function immediately returns `NULL`. A `NULL` return value from a `BEFORE` trigger in PostgreSQL signifies that the triggering operation (in this case, the `DELETE`) should be aborted, and the row should not be deleted. If, however, the `SELECT` operation finds no matching records in `\"Order_Deliveries\"`, meaning the employee is not associated with any existing order deliveries, the conditional statement evaluates to false. In this scenario, the function proceeds to return the `OLD` record. A non-`NULL` return value (like `OLD` or `NEW`) from a `BEFORE` trigger indicates that the triggering operation should be allowed to proceed with the row as returned.\n\nThis function is then associated with a trigger named `prevent_employee_delete_trigger`. This trigger is configured to activate `BEFORE DELETE` operations on the `\"Employees\"` table. It is set to execute `FOR EACH ROW`, meaning the trigger function `validate_employee_deletion()` will be invoked once for every row that is targeted for deletion. The trigger's action is to `EXECUTE FUNCTION validate_employee_deletion()`. Consequently, whenever an attempt is made to delete a row from the `\"Employees\"` table, this trigger will intercept the operation, call the `validate_employee_deletion()` function, and based on the function's return value (either `NULL` to prevent deletion or `OLD` to allow deletion), it will either abort or permit the deletion of that specific employee record.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_employee_deletion() RETURNS TRIGGER AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Order_Deliveries\" WHERE driver_employee_id = OLD.employee_id) THEN\n        RETURN NULL;\n    END IF;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER prevent_employee_delete_trigger\nBEFORE DELETE ON \"Employees\"\nFOR EACH ROW\nEXECUTE FUNCTION validate_employee_deletion();",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Order_Deliveries",
      "Employees",
      "Delivery_Route_Locations",
      "Addresses"
    ],
    "call_sqls": [
      "DELETE FROM \"Employees\" WHERE employee_id = 1;",
      "DELETE FROM \"Employees\" WHERE employee_id = 2;",
      "DELETE FROM \"Employees\" WHERE employee_id = 3;",
      "DELETE FROM \"Employees\" WHERE employee_id = 4;",
      "DELETE FROM \"Employees\" WHERE employee_id = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger on the Employees table. For each row, prevent deletion if the employee's ID exists in the Order_Deliveries table as a driver_employee_id.",
    "natural_language": "Hey, set up a trigger that kicks in before anyone tries to delete a record from the Employees table. Basically, for each employee you're trying to axe, check if their ID is hanging out in the Order_Deliveries table as a driver. If it is, block that deletion—don't let it go through.",
    "id": 67
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_log_order_insertion that is executed before each row insertion into the Customer_Orders table, which first checks if the NEW.order_id value is null and, if so, performs a SELECT query on the Customer_Orders table to calculate the COALESCE of the maximum existing order_id value and 0, adds 1 to that result, and assigns this new integer value into the NEW.order_id variable for the row being inserted, and then performs an INSERT operation into the Customer_Addresses table, specifying the columns customer_id, address_id, date_from, and date_to, using the NEW.customer_id value from the triggering row for the customer_id column, the constant integer 1 for the address_id column, the CURRENT_TIMESTAMP function call for the date_from column, and the result of adding an interval of one year to the CURRENT_TIMESTAMP for the date_to column, before finally returning the modified NEW row record to allow the insertion into Customer_Orders to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_log_order_insertion() RETURNS TRIGGER AS $$\nBEGIN\n    -- If order_id is null, generate a new one using the maximum existing order_id + 1\n    IF NEW.order_id IS NULL THEN\n        SELECT COALESCE(MAX(order_id), 0) + 1 INTO NEW.order_id FROM \"Customer_Orders\";\n    END IF;\n    \n    -- Insert into Customer_Addresses after the order is inserted\n    INSERT INTO \"Customer_Addresses\" (customer_id, address_id, date_from, date_to) \n    VALUES (NEW.customer_id, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP + INTERVAL '1 year');\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_order_insertion\nBEFORE INSERT ON \"Customer_Orders\"\nFOR EACH ROW EXECUTE FUNCTION trg_log_order_insertion();",
    "database_name": "department_store",
    "tables": [
      "Customers",
      "Customer_Addresses",
      "Addresses",
      "Customer_Orders"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Orders\" (customer_id, order_status_code, order_date) VALUES (1, 'New', '2023-10-26 10:00:00+00:00');",
      "INSERT INTO \"Customer_Orders\" (customer_id, order_status_code, order_date) VALUES (2, 'Completed', '2023-10-27 11:30:00+00:00');",
      "INSERT INTO \"Customer_Orders\" (customer_id, order_status_code, order_date) VALUES (3, 'PartFilled', '2023-10-28 14:15:00+00:00');",
      "INSERT INTO \"Customer_Orders\" (customer_id, order_status_code, order_date) VALUES (4, 'New', '2023-10-29 09:45:00+00:00');",
      "INSERT INTO \"Customer_Orders\" (customer_id, order_status_code, order_date) VALUES (5, 'Completed', '2023-10-30 16:00:00+00:00');"
    ],
    "summary": "Create a BEFORE INSERT trigger on the Customer_Orders table. For each new row, if order_id is null, assign the next sequential integer. Then insert a corresponding record into the Customer_Addresses table with customer_id from the new row, address_id as 1, date_from as current timestamp, and date_to as one year later.",
    "natural_language": "Create a BEFORE INSERT trigger for the Customer_Orders table. For every new row, check if order_id is null and, if so, assign the next sequential integer to it. Then, insert a matching record into the Customer_Addresses table using the new row's customer_id, setting address_id to 1, date_from to the current timestamp, and date_to to one year from now.",
    "id": 68
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_remove_expired_addresses that returns a trigger and is executed by a trigger named remove_expired_addresses, which is defined to fire automatically after every INSERT operation on the Customers table for each new row added. The function performs a DELETE operation on the Customer_Addresses table, targeting all rows where the customer_id column matches the customer_id value from the newly inserted row (accessed via the NEW record) and where the date_to column holds a timestamp that is earlier than the current date and time obtained via the CURRENT_TIMESTAMP function. After the deletion, the function returns the NEW record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_remove_expired_addresses() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Customer_Addresses\" WHERE customer_id = NEW.customer_id AND date_to < CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_expired_addresses\nAFTER INSERT ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION trg_remove_expired_addresses();",
    "database_name": "department_store",
    "tables": [
      "Customers",
      "Customer_Addresses",
      "Addresses",
      "Customer_Orders"
    ],
    "call_sqls": [
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (4, 'Credit Card', '123', 'John Doe', '123 Main St', '555-1234', 'john.doe@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (5, 'Direct Debit', '456', 'Jane Smith', '456 Elm St', '555-5678', 'jane.smith@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (6, 'Credit Card', '789', 'Alice Johnson', '789 Oak St', '555-9012', 'alice.johnson@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (7, 'Direct Debit', '012', 'Bob Brown', '012 Pine St', '555-3456', 'bob.brown@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (8, 'Credit Card', '345', 'Charlie Black', '345 Maple St', '555-7890', 'charlie.black@example.com');"
    ],
    "summary": "Create an AFTER INSERT trigger on the Customers table. For each new row, delete records from the Customer_Addresses table where the customer_id matches and the date_to is earlier than the current timestamp.",
    "natural_language": "For each new customer added, delete any old addresses from the Customer_Addresses table where the customer_id matches and the date_to is in the past.",
    "id": 69
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `trg_cleanup_old_addresses` that is designed to be executed after a `DELETE` operation on the `\"Customer_Addresses\"` table. This function takes no explicit parameters but implicitly receives special `OLD` and `NEW` records from the triggering event. The purpose of this function is to conditionally delete records from the `\"Addresses\"` table. Upon activation, the function first executes a `SELECT` statement to check for the existence of any records in the `\"Customer_Addresses\"` table where the `address_id` column matches the `address_id` value from the `OLD` record (which represents the row that was just deleted from `\"Customer_Addresses\"`). This `SELECT` statement uses `SELECT 1` for efficiency, as it only needs to determine existence, not retrieve actual data. If this `SELECT` query returns no rows, indicating that no other customer is currently associated with the `address_id` that was just deleted from `\"Customer_Addresses\"`, then the function proceeds to execute a `DELETE` statement. This `DELETE` statement targets the `\"Addresses\"` table and removes all rows where the `address_id` column matches the `address_id` value from the `OLD` record. After this conditional deletion, the function returns the `OLD` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL. This trigger function is then associated with a trigger named `cleanup_old_addresses`. This trigger is configured to fire `AFTER DELETE` events on the `\"Customer_Addresses\"` table `FOR EACH ROW` that is deleted, and it executes the `trg_cleanup_old_addresses()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_cleanup_old_addresses() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Customer_Addresses\" WHERE address_id = OLD.address_id) THEN\n        DELETE FROM \"Addresses\" WHERE address_id = OLD.address_id;\n    END IF;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cleanup_old_addresses\nAFTER DELETE ON \"Customer_Addresses\"\nFOR EACH ROW EXECUTE FUNCTION trg_cleanup_old_addresses();",
    "database_name": "department_store",
    "tables": [
      "Customers",
      "Customer_Addresses",
      "Addresses",
      "Customer_Orders"
    ],
    "call_sqls": [
      "INSERT INTO Addresses (address_id, address_details) VALUES (100, '123 Main St');\nINSERT INTO Customer_Addresses (customer_id, address_id, date_from, date_to) VALUES (1, 100, '2023-01-01', '2023-12-31');\nDELETE FROM Customer_Addresses WHERE customer_id = 1 AND address_id = 100;",
      "INSERT INTO Addresses (address_id, address_details) VALUES (101, '456 Oak Ave');\nINSERT INTO Customer_Addresses (customer_id, address_id, date_from, date_to) VALUES (2, 101, '2022-05-15', '2024-05-14');\nDELETE FROM Customer_Addresses WHERE customer_id = 2 AND address_id = 101;",
      "INSERT INTO Addresses (address_id, address_details) VALUES (102, '789 Pine Ln');\nINSERT INTO Customer_Addresses (customer_id, address_id, date_from, date_to) VALUES (3, 102, '2021-11-01', '2023-10-31');\nDELETE FROM Customer_Addresses WHERE customer_id = 3 AND address_id = 102;",
      "INSERT INTO Addresses (address_id, address_details) VALUES (103, '101 Elm Rd');\nINSERT INTO Customer_Addresses (customer_id, address_id, date_from, date_to) VALUES (4, 103, '2020-03-20', '2022-03-19');\nDELETE FROM Customer_Addresses WHERE customer_id = 4 AND address_id = 103;",
      "INSERT INTO Addresses (address_id, address_details) VALUES (104, '202 Birch Ct');\nINSERT INTO Customer_Addresses (customer_id, address_id, date_from, date_to) VALUES (5, 104, '2019-07-01', '2021-06-30');\nDELETE FROM Customer_Addresses WHERE customer_id = 5 AND address_id = 104;"
    ],
    "summary": "Create an AFTER DELETE trigger on the Customer_Addresses table. For each deleted row, if no other customer is associated with the same address_id, delete the corresponding record from the Addresses table.",
    "natural_language": "Please implement an AFTER DELETE trigger on the Customer_Addresses table. The trigger's logic must be as follows: for each row that is deleted, if there exists no other customer record associated with the same address_id, then the corresponding record from the Addresses table should also be deleted.",
    "id": 70
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `log_customer_payment` that is designed to be executed after an `INSERT` operation on the `\"Customers\"` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` which represents the new row being inserted into the `\"Customers\"` table. The primary purpose of this function is to record an automatic payment for a newly created customer. Inside the function, an `INSERT` statement is executed to add a new record into the `\"Customer_Payments\"` table. The `customer_id` column of `\"Customer_Payments\"` is populated with the value from `NEW.\"customer_id\"`, which is the `customer_id` of the customer just inserted into the `\"Customers\"` table. The `datetime_payment` column is set to the current timestamp using the `NOW()` function. The `payment_method_code` column is assigned the literal string value `'Auto Payment'`. The `amount_payment` column is set to the literal numeric value `100.0`. After the `INSERT` operation, the function returns `NEW`, which is required for `AFTER` row-level triggers in PostgreSQL. A separate trigger, named `auto_payment_trigger`, is defined to execute this `log_customer_payment` function. This trigger is configured to activate `AFTER INSERT` operations on the `\"Customers\"` table, and it is set to execute `FOR EACH ROW`, meaning the `log_customer_payment` function will be invoked once for every row successfully inserted into the `\"Customers\"` table. The trigger explicitly calls `EXECUTE FUNCTION log_customer_payment()`.",
    "plsql": "CREATE OR REPLACE FUNCTION log_customer_payment() RETURNS TRIGGER AS $$\nBEGIN\n  -- The error \"null value in column \"customer_id\" violates not-null constraint\"\n  -- occurs during the INSERT into the \"Customers\" table itself,\n  -- before this AFTER INSERT trigger is successfully executed.\n  -- This trigger function is not the cause of that specific error.\n  -- The external SQL statement inserting into \"Customers\" must provide a non-NULL value for \"customer_id\".\n  -- The logic within this trigger is sound for its intended purpose,\n  -- which is to insert into \"Customer_Payments\" AFTER a successful customer insertion.\n  -- The previous attempt to add IF NEW.\"customer_id\" IS NOT NULL was a defensive measure\n  -- for the trigger's own INSERT, but it does not prevent the initial Customers table insert failure.\n  INSERT INTO \"Customer_Payments\" (\"customer_id\", \"datetime_payment\", \"payment_method_code\", \"amount_payment\") \n  VALUES (NEW.\"customer_id\", NOW(), 'Auto Payment', 100.0);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER auto_payment_trigger\nAFTER INSERT ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION log_customer_payment();",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Payments",
      "Lessons",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Customers\" (\"customer_id\", \"customer_address_id\", \"customer_status_code\", \"date_became_customer\", \"date_of_birth\", \"first_name\", \"last_name\", \"amount_outstanding\", \"email_address\", \"phone_number\", \"cell_mobile_phone_number\") VALUES (101, 1, 'Good Customer', NOW(), '1990-01-01', 'John', 'Doe', 0.0, 'john.doe@example.com', '123-456-7890', '098-765-4321');",
      "INSERT INTO \"Customers\" (\"customer_id\", \"customer_address_id\", \"customer_status_code\", \"date_became_customer\", \"date_of_birth\", \"first_name\", \"last_name\", \"amount_outstanding\", \"email_address\", \"phone_number\", \"cell_mobile_phone_number\") VALUES (102, 2, 'Good Customer', NOW(), '1985-05-15', 'Jane', 'Smith', 100.0, 'jane.smith@example.com', '555-1234', '555-5678');",
      "INSERT INTO \"Customers\" (\"customer_id\", \"customer_address_id\", \"customer_status_code\", \"date_became_customer\", \"date_of_birth\", \"first_name\", \"last_name\", \"amount_outstanding\", \"email_address\", \"phone_number\", \"cell_mobile_phone_number\") VALUES (103, 3, 'Bad Customer', NOW(), '1992-11-30', 'Robert', 'Johnson', 500.0, 'robert.j@example.com', '444-5555', '444-6666');",
      "INSERT INTO \"Customers\" (\"customer_id\", \"customer_address_id\", \"customer_status_code\", \"date_became_customer\", \"date_of_birth\", \"first_name\", \"last_name\", \"amount_outstanding\", \"email_address\", \"phone_number\", \"cell_mobile_phone_number\") VALUES (104, 1, 'Good Customer', NOW(), '1988-07-22', 'Alice', 'Brown', 0.0, 'alice.b@example.com', '777-8888', '777-9999');",
      "INSERT INTO \"Customers\" (\"customer_id\", \"customer_address_id\", \"customer_status_code\", \"date_became_customer\", \"date_of_birth\", \"first_name\", \"last_name\", \"amount_outstanding\", \"email_address\", \"phone_number\", \"cell_mobile_phone_number\") VALUES (105, 2, 'Good Customer', NOW(), '1995-03-10', 'Charlie', 'Wilson', 250.0, 'charlie.w@example.com', '222-3333', '222-4444');"
    ],
    "summary": "Create an AFTER INSERT trigger function named log_customer_payment on the Customers table. For each new row, insert a record into the Customer_Payments table using the new customer_id, the current timestamp for datetime_payment, 'Auto Payment' for payment_method_code, and 100.0 for amount_payment. Return NEW.",
    "natural_language": "Please construct an AFTER INSERT trigger function designated as 'log_customer_payment' for the Customers table. This function should be configured such that, upon the insertion of each new row, a corresponding record is inserted into the Customer_Payments table. The inserted record must utilize the new row's customer_id, assign the current timestamp to the datetime_payment field, set the payment_method_code to 'Auto Payment', and specify the amount_payment as 100.0. The function must conclude by returning the NEW row.",
    "id": 71
  },
  {
    "ir": "Write a PostgreSQL trigger function named create_staff_address that returns a trigger, which is automatically executed as a BEFORE INSERT trigger named staff_address_trigger on the \"Staff\" table for each new row being inserted; the function's logic is to insert a single new record into the \"Addresses\" table, where the \"address_id\" column is populated with the value of the NEW.\"staff_id\" from the triggering \"Staff\" row incremented by 1000, the \"line_1_number_building\" column is set to the literal string 'Default Address', the \"city\" column is set to 'Default City', the \"zip_postcode\" column is set to '00000', the \"state_province_county\" column is set to 'Default State', and the \"country\" column is set to 'USA'; after performing this INSERT operation, the function returns the NEW row record to allow the original INSERT operation on the \"Staff\" table to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION create_staff_address() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Addresses\" (\"address_id\", \"line_1_number_building\", \"city\", \"zip_postcode\", \"state_province_county\", \"country\") VALUES (NEW.\"staff_id\" + 1000, 'Default Address', 'Default City', '00000', 'Default State', 'USA');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER staff_address_trigger\nBEFORE INSERT ON \"Staff\"\nFOR EACH ROW EXECUTE FUNCTION create_staff_address();",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Payments",
      "Lessons",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (4, 'john.doe', 'John', 'A.', 'Doe', '1990-01-01 00:00:00+00:00', '2023-10-01 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (5, 'jane.smith', 'Jane', 'B.', 'Smith', '1985-05-15 00:00:00+00:00', '2023-10-02 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (6, 'alice.jones', 'Alice', 'C.', 'Jones', '1992-07-20 00:00:00+00:00', '2023-10-03 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (7, 'bob.brown', 'Bob', 'D.', 'Brown', '1988-11-30 00:00:00+00:00', '2023-10-04 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (8, 'charlie.green', 'Charlie', 'E.', 'Green', '1995-03-25 00:00:00+00:00', '2023-10-05 00:00:00+00:00');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named create_staff_address on the Staff table. For each new row, insert a record into the Addresses table where address_id is the new staff_id plus 1000, line_1_number_building is 'Default Address', city is 'Default City', zip_postcode is '00000', state_province_county is 'Default State', and country is 'USA'. Return NEW.",
    "natural_language": "Please implement a BEFORE INSERT trigger function designated as 'create_staff_address' on the Staff table. For every inserted row, it is required to insert a corresponding record into the Addresses table. The 'address_id' shall be derived by adding 1000 to the new 'staff_id'. The fields 'line_1_number_building', 'city', 'zip_postcode', 'state_province_county', and 'country' should be populated with the values 'Default Address', 'Default City', '00000', 'Default State', and 'USA', respectively. The function must conclude by returning the NEW row.",
    "id": 72
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the \"Customers\" table. This function, named remove_customer_data, does not take any parameters and is designed to perform a specific operation: it deletes all records from the \"Customer_Payments\" table where the \"customer_id\" column matches the \"customer_id\" of the row being deleted from the \"Customers\" table. The function uses the OLD keyword to reference the \"customer_id\" of the row that is about to be deleted. After performing the delete operation on the \"Customer_Payments\" table, the function returns the OLD record, which is the default behavior for a trigger function that is executed before a delete operation. The trigger, named customer_cleanup_trigger, is defined to execute this function for each row that is deleted from the \"Customers\" table, ensuring that any associated payment records are removed from the \"Customer_Payments\" table before the customer record itself is deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_customer_data() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Customer_Payments\" WHERE \"customer_id\" = OLD.\"customer_id\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER customer_cleanup_trigger\nBEFORE DELETE ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION remove_customer_data();",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Payments",
      "Lessons",
      "Staff"
    ],
    "call_sqls": [
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 1;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 2;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 3;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 11;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 14;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named remove_customer_data on the Customers table. For each row to be deleted, delete all records from the Customer_Payments table where the customer_id matches the OLD.customer_id. Return OLD.",
    "natural_language": "How can I create a BEFORE DELETE trigger function called remove_customer_data for the Customers table that, for each row being deleted, removes all records from the Customer_Payments table where the customer_id matches the OLD.customer_id and then returns OLD?",
    "id": 73
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `duplicate_lesson` that is designed to be executed after an `INSERT` operation on the `\"Lessons\"` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` (representing the new row being inserted). The function's primary purpose is to conditionally insert a duplicate lesson record into the `\"Lessons\"` table. Specifically, it first evaluates a conditional statement: `IF NEW.\"lesson_status_code\" <> 'Duplicated' THEN`. This condition checks if the value in the `lesson_status_code` column of the newly inserted row (`NEW`) is not equal to the string literal `'Duplicated'`. If this condition evaluates to true, indicating that the original lesson is not already marked as 'Duplicated', the function proceeds to execute an `INSERT` statement. This `INSERT` statement targets the `\"Lessons\"` table and populates the columns `\"lesson_id\"`, `\"customer_id\"`, `\"lesson_status_code\"`, `\"staff_id\"`, `\"vehicle_id\"`, `\"lesson_date\"`, `\"lesson_time\"`, and `\"price\"`. The values for these columns are derived from the `NEW` row and some calculated values:\n- For `\"lesson_id\"`, the value is calculated as `NEW.\"lesson_id\" + 10000`, effectively creating a new lesson ID by adding 10000 to the original lesson's ID.\n- For `\"customer_id\"`, the value is taken directly from `NEW.\"customer_id\"`.\n- For `\"lesson_status_code\"`, the value is explicitly set to the string literal `'Duplicated'`.\n- For `\"staff_id\"`, the value is taken directly from `NEW.\"staff_id\"`.\n- For `\"vehicle_id\"`, the value is taken directly from `NEW.\"vehicle_id\"`.\n- For `\"lesson_date\"`, the value is calculated as `NEW.\"lesson_date\" + INTERVAL '1 day'`, effectively setting the duplicate lesson's date to one day after the original lesson's date.\n- For `\"lesson_time\"`, the value is taken directly from `NEW.\"lesson_time\"`.\n- For `\"price\"`, the value is taken directly from `NEW.\"price\"`.\nAfter the conditional block (whether the `INSERT` was executed or not), the function concludes by returning `NEW`, which represents the original row that triggered the function, allowing the `INSERT` operation on the `\"Lessons\"` table to complete successfully.\n\nA trigger named `lesson_duplicate_trigger` is defined to execute this `duplicate_lesson` function. This trigger is configured to activate `AFTER INSERT` operations on the `\"Lessons\"` table. The `FOR EACH ROW` clause specifies that the trigger function `duplicate_lesson()` will be executed once for every row that is inserted into the `\"Lessons\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION duplicate_lesson() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"lesson_status_code\" <> 'Duplicated' THEN\n    INSERT INTO \"Lessons\" (\"lesson_id\", \"customer_id\", \"lesson_status_code\", \"staff_id\", \"vehicle_id\", \"lesson_date\", \"lesson_time\", \"price\") \n    VALUES (NEW.\"lesson_id\" + 10000, NEW.\"customer_id\", 'Duplicated', NEW.\"staff_id\", NEW.\"vehicle_id\", NEW.\"lesson_date\" + INTERVAL '1 day', NEW.\"lesson_time\", NEW.\"price\");\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER lesson_duplicate_trigger\nAFTER INSERT ON \"Lessons\"\nFOR EACH ROW EXECUTE FUNCTION duplicate_lesson();",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Payments",
      "Lessons",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Lessons\" (\"lesson_id\", \"customer_id\", \"lesson_status_code\", \"staff_id\", \"vehicle_id\", \"lesson_date\", \"lesson_time\", \"price\") VALUES (1, 6, 'Scheduled', 8, 3, '2023-01-15 10:00:00+08:00', '10', 150.0);",
      "INSERT INTO \"Lessons\" (\"lesson_id\", \"customer_id\", \"lesson_status_code\", \"staff_id\", \"vehicle_id\", \"lesson_date\", \"lesson_time\", \"price\") VALUES (2, 8, 'Completed', 14, 2, '2023-01-16 11:30:00+08:00', '11', 175.0);",
      "INSERT INTO \"Lessons\" (\"lesson_id\", \"customer_id\", \"lesson_status_code\", \"staff_id\", \"vehicle_id\", \"lesson_date\", \"lesson_time\", \"price\") VALUES (3, 6, 'Cancelled', 11, 3, '2023-01-17 09:00:00+08:00', '9', 120.0);",
      "INSERT INTO \"Lessons\" (\"lesson_id\", \"customer_id\", \"lesson_status_code\", \"staff_id\", \"vehicle_id\", \"lesson_date\", \"lesson_time\", \"price\") VALUES (4, 8, 'Pending', 8, 2, '2023-01-18 14:00:00+08:00', '14', 200.0);",
      "INSERT INTO \"Lessons\" (\"lesson_id\", \"customer_id\", \"lesson_status_code\", \"staff_id\", \"vehicle_id\", \"lesson_date\", \"lesson_time\", \"price\") VALUES (5, 6, 'Confirmed', 14, 3, '2023-01-19 13:00:00+08:00', '13', 160.0);"
    ],
    "summary": "Create an AFTER INSERT trigger function named duplicate_lesson on the Lessons table. For each new row where NEW.lesson_status_code is not 'Duplicated', insert a duplicate record into the Lessons table. Set the new lesson_id to NEW.lesson_id + 10000, lesson_status_code to 'Duplicated', lesson_date to NEW.lesson_date + 1 day, and copy all other values from NEW. Return NEW.",
    "natural_language": "Define an AFTER INSERT trigger function called duplicate_lesson for the Lessons table. For every inserted row where NEW.lesson_status_code is not 'Duplicated', insert a duplicate record into the same table. Assign the new lesson_id as NEW.lesson_id + 10000, set lesson_status_code to 'Duplicated', set lesson_date to NEW.lesson_date plus one day, and copy all other column values from NEW. Finally, return NEW.",
    "id": 74
  },
  {
    "ir": "Write a PLpgSQL function named update_gymnast_total that is designed to be used as a trigger function. This function does not take any parameters directly but operates on the NEW record, which represents the row being inserted or updated in the gymnast table. The function calculates the total points for a gymnast by summing up the individual event points: Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points. For each of these columns, the function uses the COALESCE function to treat any NULL values as zero, ensuring that the sum is computed correctly even if some event points are missing. The result of this summation is assigned to the Total_Points column of the NEW record. The function then returns the modified NEW record. A trigger named update_gymnast_total_trigger is created to automatically invoke this function before any insert or update operation on the gymnast table. This trigger ensures that the Total_Points column is always up-to-date with the sum of the individual event points whenever a row is inserted or updated. Additionally, an example insert statement is provided, which attempts to insert a new row into the gymnast table with specified points for each event. If a row with the same Gymnast_ID already exists, the ON CONFLICT clause updates the existing row's event points with the new values provided in the insert statement, ensuring that the gymnast's scores are always current.",
    "plsql": "CREATE OR REPLACE FUNCTION update_gymnast_total() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Total_Points\" = COALESCE(NEW.\"Floor_Exercise_Points\", 0) + COALESCE(NEW.\"Pommel_Horse_Points\", 0) + COALESCE(NEW.\"Rings_Points\", 0) + COALESCE(NEW.\"Vault_Points\", 0) + COALESCE(NEW.\"Parallel_Bars_Points\", 0) + COALESCE(NEW.\"Horizontal_Bar_Points\", 0);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_gymnast_total_trigger\n    BEFORE INSERT OR UPDATE ON gymnast\n    FOR EACH ROW\n    EXECUTE FUNCTION update_gymnast_total();\n\n-- Example of using ON CONFLICT to handle duplicate keys\nINSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (10, 9.5, 9.6, 9.7, 9.8, 9.9, 9.4)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (1, 9.725, 9.737, 9.512, 9.575, 9.762, 9.75)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (2, 9.7, 9.625, 9.625, 9.65, 9.587, 9.737)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (4, 8.987, 9.75, 9.75, 9.575, 9.787, 9.725)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (5, 9.8, 9.6, 9.7, 9.9, 9.85, 9.65)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (6, 9.9, 9.8, 9.85, 9.75, 9.7, 9.8)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named update_gymnast_total on the gymnast table. For each row, calculate the Total_Points by summing the COALESCE values of Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points (treating NULL as 0). Assign the result to NEW.Total_Points and return NEW.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE trigger function called update_gymnast_total for the gymnast table that calculates the Total_Points by adding together the Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points (treating any NULL values as zero) and then assigns this sum to NEW.Total_Points before returning NEW?",
    "id": 75
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_old_settlements that returns a trigger, which is automatically executed as an AFTER INSERT trigger named trg_delete_old_settlements on the \"Settlements\" table for each new row inserted. The function performs a DELETE operation on the \"Settlements\" table, targeting all rows where the value in the \"Date_Claim_Settled\" column is older than one year from the current date, calculated by subtracting an interval of '1 year' from the result of the CURRENT_DATE function. The trigger function returns NULL after the deletion is complete.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_old_settlements() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Settlements\"\n  WHERE \"Date_Claim_Settled\" < (CURRENT_DATE - INTERVAL '1 year');\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_old_settlements\nAFTER INSERT ON \"Settlements\"\nFOR EACH ROW EXECUTE FUNCTION delete_old_settlements();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (501, 900, '2022-08-07', '2023-08-01', 40000, 1500, 1000);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (502, 901, '2022-09-07', '2023-09-01', 45000, 1600, 1001);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (503, 902, '2022-10-07', '2023-10-01', 50000, 1700, 1002);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (504, 903, '2022-11-07', '2023-11-01', 55000, 1800, 1003);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (505, 904, '2022-12-07', '2023-12-01', 60000, 1900, 1004);"
    ],
    "summary": "Create an AFTER INSERT trigger function named delete_old_settlements on the Settlements table. After each insert, delete rows where Date_Claim_Settled is older than one year from the current date. Return NULL.",
    "natural_language": "Define an AFTER INSERT trigger function called delete_old_settlements for the Settlements table. After every insert, remove all rows where the Date_Claim_Settled is more than one year old compared to the current date. Ensure the function returns NULL.",
    "id": 76
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_customer_policy that is executed automatically after each new row is inserted into the Customers table, where the trigger function performs the following operations: it first declares a local variable new_policy_id of type bigint, then it queries the Customer_Policies table to calculate the maximum existing value in the Policy_ID column, uses the COALESCE function to handle cases where the table is empty by substituting 0 for NULL, adds 1 to this result, and stores the computed value into the new_policy_id variable; subsequently, it inserts a new row into the Customer_Policies table, specifying the columns Policy_ID with the value from new_policy_id, Customer_ID with the value from the newly inserted Customers row's Customer_ID column (accessed via the NEW record), Policy_Type_Code with the literal string 'Health', Start_Date with the current date provided by the CURRENT_DATE function, and End_Date with a date calculated by adding an interval of one year to the current date using the expression CURRENT_DATE + INTERVAL '1 year'; the function concludes by returning the NEW record to indicate successful trigger execution.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_customer_policy() RETURNS TRIGGER AS $$\nDECLARE\n  new_policy_id bigint;\nBEGIN\n  -- Generate a new Policy_ID by finding the maximum existing Policy_ID and adding 1\n  SELECT COALESCE(MAX(\"Policy_ID\"), 0) + 1 INTO new_policy_id FROM \"Customer_Policies\";\n  \n  INSERT INTO \"Customer_Policies\" (\"Policy_ID\", \"Customer_ID\", \"Policy_Type_Code\", \"Start_Date\", \"End_Date\")\n  VALUES (new_policy_id, NEW.\"Customer_ID\", 'Health', CURRENT_DATE, CURRENT_DATE + INTERVAL '1 year');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_customer_policy\nAFTER INSERT ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION insert_customer_policy();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Customers\" (\"Customer_ID\", \"Customer_Details\") VALUES (101, 'John Doe');",
      "INSERT INTO \"Customers\" (\"Customer_ID\", \"Customer_Details\") VALUES (102, 'Jane Smith');",
      "INSERT INTO \"Customers\" (\"Customer_ID\", \"Customer_Details\") VALUES (103, 'Peter Jones');",
      "INSERT INTO \"Customers\" (\"Customer_ID\", \"Customer_Details\") VALUES (104, 'Alice Brown');",
      "INSERT INTO \"Customers\" (\"Customer_ID\", \"Customer_Details\") VALUES (105, 'Bob White');"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_customer_policy on the Customers table. After each insert, generate a new Policy_ID for the Customer_Policies table by incrementing the maximum existing Policy_ID, then insert a new policy for the customer with type 'Health', start date as current date, and end date one year later. Return NEW.",
    "natural_language": "Alright, so we need a trigger that kicks in after someone's added to the Customers table. Call it insert_customer_policy. Every time a new customer pops in, we gotta make a new policy for 'em. First, figure out the biggest Policy_ID we already have in the Customer_Policies table, then just bump it up by one for the new one. The policy type should be 'Health', it starts today, and it'll run out a year from now. Finally, just hand back the NEW record. Got it?",
    "id": 77
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_product_price that is executed automatically after each row update operation on the Manufacturers table; this function, which returns a trigger type and uses PL/pgSQL language, performs an update on the Products table, specifically setting the Price column for all rows in the Products table where the Manufacturer column value matches the newly updated row's Code column value from the Manufacturers table (accessed via the NEW record) to a calculated value of two times the NEW record's Revenue column value, and the function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_product_price() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Products\" SET \"Price\" = NEW.\"Revenue\" * 2 WHERE \"Manufacturer\" = NEW.\"Code\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_product_price_trigger\nAFTER UPDATE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION update_product_price();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 150.0 WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 200.0 WHERE \"Code\" = 2;",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 75.0 WHERE \"Code\" = 3;",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 180.0 WHERE \"Name\" = 'Sony';",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 90.0 WHERE \"Headquarter\" = 'Austin';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_product_price on the Manufacturers table. After each update, update the Price in the Products table to twice the NEW Revenue value for all products where the Manufacturer matches the NEW Code. Return NEW.",
    "natural_language": "Construct an AFTER UPDATE trigger function, meticulously named update_product_price, to be associated with the Manufacturers table. Following each and every update operation, this function must systematically adjust the Price column within the Products table, setting it precisely to double the value of the NEW Revenue entry, but only for those product records whose Manufacturer identifier corresponds exactly to the newly updated Code value from the Manufacturers table. The function should conclusively return the NEW row.",
    "id": 78
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_new_product that is executed automatically after each new row is inserted into the Manufacturers table; this function takes no explicit parameters but accesses the newly inserted row via the special NEW record variable, which contains all columns from the Manufacturers table, and its logic is to perform an INSERT operation into a separate table named Products, specifying values for four columns: for the Code column it uses the value from NEW.\"Code\", for the Name column it inserts the literal string 'New Product', for the Price column it calculates a value by taking the NEW.\"Revenue\" column value and multiplying it by 1.5, and for the Manufacturer column it again uses the value from NEW.\"Code\"; the function concludes by returning the NEW row to indicate the trigger operation is complete, and this function is bound to the Manufacturers table by a trigger named insert_new_product_trigger which is defined to fire AFTER INSERT on that table FOR EACH ROW.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_new_product() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (NEW.\"Code\", 'New Product', NEW.\"Revenue\" * 1.5, NEW.\"Code\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_new_product_trigger\nAFTER INSERT ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION insert_new_product();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (4, 'Apple', 'Cupertino', 'Steve', 200.0);",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (5, 'Samsung', 'Seoul', 'Lee', 300.0);",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (6, 'Microsoft', 'Redmond', 'Bill', 400.0);",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (7, 'Google', 'Mountain View', 'Larry', 500.0);",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (8, 'Amazon', 'Seattle', 'Jeff', 600.0);"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_new_product on the Manufacturers table. After each insert, insert a new row into the Products table using the NEW Code for Code and Manufacturer, 'New Product' for Name, and NEW Revenue multiplied by 1.5 for Price. Return NEW.",
    "natural_language": "How can I create an AFTER INSERT trigger function named insert_new_product on the Manufacturers table so that after each insert, it adds a new row to the Products table using the NEW Code for both Code and Manufacturer, sets the Name to 'New Product', and calculates the Price as NEW Revenue multiplied by 1.5, and then returns NEW?",
    "id": 79
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `delete_product_on_manufacturer_delete` that is designed to be executed in response to a data manipulation event on a specific table. This function does not accept any explicit input parameters in its definition, as it is a trigger function and receives context information implicitly. The function returns a value of type `TRIGGER`, which is a standard requirement for PostgreSQL trigger functions. The core operation performed by this function is a `DELETE` statement. This `DELETE` statement targets the table named `\"Products\"`. The rows to be deleted from the `\"Products\"` table are determined by a `WHERE` clause. The condition within the `WHERE` clause specifies that the value in the column named `\"Manufacturer\"` within the `\"Products\"` table must be equal to the value of the `\"Code\"` column from the `OLD` row. The `OLD` row refers to the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` row.\n\nThis trigger function is then associated with a trigger named `delete_product_on_manufacturer_delete_trigger`. This trigger is configured to activate `AFTER DELETE` operations on the table named `\"Manufacturers\"`. The trigger is set to execute `FOR EACH ROW`, meaning that the `delete_product_on_manufacturer_delete` function will be invoked once for every row that is deleted from the `\"Manufacturers\"` table. When the trigger fires, the `OLD` row context made available to the trigger function will contain the data of the row that was just deleted from the `\"Manufacturers\"` table. Consequently, when a row is deleted from the `\"Manufacturers\"` table, this trigger will automatically delete all corresponding products from the `\"Products\"` table where the `\"Manufacturer\"` column in the `\"Products\"` table matches the `\"Code\"` of the manufacturer that was just deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_product_on_manufacturer_delete() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Products\" WHERE \"Manufacturer\" = OLD.\"Code\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_product_on_manufacturer_delete_trigger\nAFTER DELETE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION delete_product_on_manufacturer_delete();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "DELETE FROM \"Manufacturers\" WHERE \"Code\" = 1;",
      "DELETE FROM \"Manufacturers\" WHERE \"Code\" = 2;",
      "DELETE FROM \"Manufacturers\" WHERE \"Code\" = 3;"
    ],
    "summary": "Create an AFTER DELETE trigger function named delete_product_on_manufacturer_delete on the Manufacturers table. After each row is deleted, delete all rows from the Products table where the Manufacturer column equals the OLD Code. Return OLD.",
    "natural_language": "Set up a trigger on the Manufacturers table that runs after a row is removed. It should clean up the Products table by getting rid of entries linked to that manufacturer's code. Make sure it gives back the old row details.",
    "id": 80
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_product_name that returns a trigger and is invoked by a trigger named update_product_name_trigger, which is defined to fire after an update operation on the Manufacturers table for each row that is modified, where the function executes an update on the Products table, setting the Name column to the literal string value 'Updated Product' for every row in the Products table where the Manufacturer column value matches the Code column value from the newly updated row in the Manufacturers table (accessed via the NEW record), and the function concludes by returning the NEW row record to the trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION update_product_name() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Products\" SET \"Name\" = 'Updated Product' WHERE \"Manufacturer\" = NEW.\"Code\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_product_name_trigger\nAFTER UPDATE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION update_product_name();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "UPDATE \"Manufacturers\" SET \"Name\" = 'New Name 1' WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Headquarter\" = 'New HQ 2' WHERE \"Code\" = 2;",
      "UPDATE \"Manufacturers\" SET \"Founder\" = 'New Founder 3' WHERE \"Code\" = 3;",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 150.0 WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Updated Manufacturer' WHERE \"Code\" = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the Manufacturers table. For each updated row, update the Products table, setting the Name to 'Updated Product' for all products where the Manufacturer matches the updated manufacturer's Code. Return the NEW record.",
    "natural_language": "How can I create an AFTER UPDATE trigger function on the Manufacturers table that, for each updated row, updates the Products table by setting the Name to 'Updated Product' for all products where the Manufacturer matches the updated manufacturer's Code, and then returns the NEW record?",
    "id": 81
  },
  {
    "ir": "Write a PostgreSQL trigger function named adjust_product_price that returns a trigger and is invoked automatically after each row update operation on the Manufacturers table; the function contains a single SQL update statement that modifies the Products table by setting the value of its Price column to the result of multiplying the current Price value by the mathematical result of the radians function applied to the numeric constant 30.0, but only for those rows in the Products table where the value in its Manufacturer column is exactly equal to the value of the Code column from the newly updated row in the Manufacturers table (accessible via the NEW record), and the trigger function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_product_price() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Products\" SET \"Price\" = \"Price\" * radians(30.0) WHERE \"Manufacturer\" = NEW.\"Code\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_product_price_trigger\nAFTER UPDATE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION adjust_product_price();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 150.0 WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Headquarter\" = 'New York' WHERE \"Code\" = 2;",
      "UPDATE \"Manufacturers\" SET \"Founder\" = 'John Doe' WHERE \"Code\" = 3;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'New Manufacturer Name' WHERE \"Code\" = 4;",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 200.0, \"Headquarter\" = 'London' WHERE \"Code\" = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the Manufacturers table. For each updated row, update the Products table, setting Price = Price * RADIANS(30.0) for all products where the Manufacturer matches the updated manufacturer's Code. Return the NEW record.",
    "natural_language": "Set up a trigger that runs after changes to the Manufacturers table. Whenever a manufacturer entry gets tweaked, adjust the cost for a bunch of its associated products by applying some kind of angle-based multiplier. Make sure the updated manufacturer's identifier is used to find the right items. Finally, hand back the new record.",
    "id": 82
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_prevent_duplicate_tracklist that returns a trigger and is executed as a BEFORE INSERT trigger on the \"Tracklists\" table for each new row, which checks for the existence of any record in the \"Tracklists\" table where the \"AlbumId\" column value equals the NEW.\"AlbumId\" value from the triggering insert and the \"Position\" column value equals the NEW.\"Position\" value from the triggering insert, and if such a pre-existing record is found, the function returns NULL to cancel the insert operation for that specific row, but if no such duplicate is found, the function returns the NEW row to allow the insert to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_prevent_duplicate_tracklist() RETURNS TRIGGER AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Tracklists\" WHERE \"AlbumId\" = NEW.\"AlbumId\" AND \"Position\" = NEW.\"Position\") THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER prevent_duplicate_tracklist\nBEFORE INSERT ON \"Tracklists\"\nFOR EACH ROW EXECUTE FUNCTION trg_prevent_duplicate_tracklist();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (1, 1, 100);",
      "INSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (1, 2, 101);",
      "INSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (2, 1, 200);",
      "INSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (1, 1, 102);",
      "INSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (3, 5, 300);"
    ],
    "summary": "Create a BEFORE INSERT trigger function on the Tracklists table. For each new row, check if a record with the same AlbumId and Position already exists. If a duplicate is found, return NULL to cancel the insert. Otherwise, return the NEW record to proceed.",
    "natural_language": "How can I create a BEFORE INSERT trigger for the Tracklists table that checks for existing records with the same AlbumId and Position, cancels the insert by returning NULL if a duplicate is found, and otherwise allows it by returning the NEW record?",
    "id": 83
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_validate_album_year that returns a trigger, which is then bound to the \"Albums\" table via a BEFORE INSERT OR UPDATE trigger named validate_album_year, executing for each row. The function's logic is to validate the \"Year\" column value of the new row (referenced as NEW) being inserted or updated. It performs a conditional check using an IF statement: if the value in NEW.\"Year\" is greater than the result of the EXTRACT(YEAR FROM CURRENT_DATE) function call, which retrieves the current calendar year as an integer, then the function returns NULL, effectively canceling the insert or update operation for that specific row. If the condition is not met, meaning the \"Year\" value is less than or equal to the current year, the function proceeds to return the NEW row record, allowing the insert or update operation to proceed normally with the original data.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_album_year() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Year\" > EXTRACT(YEAR FROM CURRENT_DATE) THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_album_year\nBEFORE INSERT OR UPDATE ON \"Albums\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_album_year();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Albums\" (\"Title\", \"Year\", \"Label\", \"Type\") VALUES ('Valid Album', 2023, 'Test Label', 'Studio');",
      "INSERT INTO \"Albums\" (\"Title\", \"Year\", \"Label\", \"Type\") VALUES ('Future Album', 2050, 'Future Label', 'Studio');",
      "UPDATE \"Albums\" SET \"Year\" = 2022 WHERE \"Title\" = 'Valid Album';",
      "UPDATE \"Albums\" SET \"Year\" = 2030 WHERE \"Title\" = 'Valid Album';",
      "INSERT INTO \"Albums\" (\"Title\", \"Year\", \"Label\", \"Type\") VALUES ('Current Year Album', EXTRACT(YEAR FROM CURRENT_DATE), 'Current Label', 'Live');"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function on the Albums table. For each row, validate the Year column. If the new Year is greater than the current year, return NULL to cancel the operation. Otherwise, return the NEW record to proceed.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE trigger function for the Albums table that validates the Year column, cancels the operation by returning NULL if the new Year is greater than the current year, and otherwise proceeds by returning the NEW record?",
    "id": 84
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the Instruments table, which checks if a record exists in the Band table with an Id matching the BandmateId of the new row being inserted into the Instruments table. If no such record exists in the Band table, the function returns NULL, effectively preventing the insertion of the new row into the Instruments table. If a matching record is found, the function returns the new row, allowing the insertion to proceed. The trigger named check_band_exists is associated with this function and is set to fire for each row before an insert operation on the Instruments table, ensuring that the existence check is performed for every new row being inserted.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_check_band_exists() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Band\" WHERE \"Id\" = NEW.\"BandmateId\") THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER check_band_exists\nBEFORE INSERT ON \"Instruments\"\nFOR EACH ROW EXECUTE FUNCTION trg_check_band_exists();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Band\" (\"Id\", \"Firstname\", \"Lastname\") VALUES (1, 'John', 'Doe');",
      "INSERT INTO \"Instruments\" (\"SongId\", \"BandmateId\", \"Instrument\") VALUES (101, 1, 'Guitar');",
      "INSERT INTO \"Instruments\" (\"SongId\", \"BandmateId\", \"Instrument\") VALUES (102, 2, 'Drums');",
      "INSERT INTO \"Band\" (\"Id\", \"Firstname\", \"Lastname\") VALUES (2, 'Jane', 'Smith');",
      "INSERT INTO \"Instruments\" (\"SongId\", \"BandmateId\", \"Instrument\") VALUES (103, 2, 'Bass');"
    ],
    "summary": "Create a BEFORE INSERT trigger function on the Instruments table. For each new row, check if a record with a matching Id exists in the Band table for the new row's BandmateId. If no matching band record exists, return NULL to prevent the insert. Otherwise, return the NEW record to proceed.",
    "natural_language": "Alright, so we need a trigger that kicks in before we add a new instrument. For each new entry, we gotta look in the Band table to see if there's already a band with the same Id as the new row's BandmateId. If you can't find a matching band, just bail out and return NULL to stop the insert. If you do find one, then it's all good—go ahead and return the NEW record to let it through.",
    "id": 85
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Performance\" table. This function, named trg_validate_song_reference, does not take any parameters directly but operates on the row being inserted, referred to as NEW. The function checks if there is no existing record in the \"Songs\" table where the \"SongId\" column matches the \"SongId\" value of the NEW row. If no such record exists, the function returns NULL, effectively preventing the insertion of the row into the \"Performance\" table. If a matching \"SongId\" is found in the \"Songs\" table, the function returns the NEW row, allowing the insertion to proceed. The trigger, named validate_song_reference, is defined to invoke this function before each row is inserted into the \"Performance\" table, ensuring that every inserted row references a valid \"SongId\" in the \"Songs\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_song_reference() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Songs\" WHERE \"SongId\" = NEW.\"SongId\") THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_song_reference\nBEFORE INSERT ON \"Performance\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_song_reference();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1, 1, 'Front');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (2, 2, 'Back');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (3, 3, 'Left');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (4, 4, 'Right');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (5, 5, 'Center');"
    ],
    "summary": "Create a BEFORE INSERT trigger function for the \"Performance\" table named trg_validate_song_reference. The function must validate that the NEW row's SongId exists in the \"Songs\" table. If it does not exist, return NULL to cancel the insert. If it exists, return NEW to allow the insert.",
    "natural_language": "Construct a BEFORE INSERT trigger function for the \"Performance\" table, which should be specifically named trg_validate_song_reference. This comprehensive function must meticulously validate that the SongId value within the NEW row is present and correctly referenced in the \"Songs\" table. In the detailed scenario where the specified SongId does not exist, the function must explicitly return NULL to effectively cancel the entire insert operation. Conversely, if the validation confirms that the SongId does indeed exist, the function should then return NEW to gracefully permit the insert to proceed.",
    "id": 86
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_highschooler_grade that returns a trigger, which is then bound to the \"Friend\" table via a trigger named grade_update_trigger configured to fire automatically after every successful insertion of a new row into the \"Friend\" table, and for each such new row, the function executes an update operation on the \"Highschooler\" table, specifically incrementing the value in the \"grade\" column by one for the single row in the \"Highschooler\" table where the \"ID\" column value exactly matches the value of the NEW.\"student_id\" column from the newly inserted \"Friend\" row, after which the function returns the NEW row record, and an accompanying insert statement attempts to add a new record into the \"Friend\" table with a student_id of 1510 and a friend_id of 1381, employing an ON CONFLICT DO NOTHING clause to prevent the insertion and silently skip the operation if a conflict arises on any unique constraint or exclusion constraint violation for the table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_highschooler_grade() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Highschooler\" SET \"grade\" = \"grade\" + 1 WHERE \"ID\" = NEW.\"student_id\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER grade_update_trigger\nAFTER INSERT ON \"Friend\"\nFOR EACH ROW\nEXECUTE FUNCTION update_highschooler_grade();\n\n-- Insert statement with proper conflict handling\nINSERT INTO \"Friend\" (student_id, friend_id)\nVALUES (1510, 1381)\nON CONFLICT DO NOTHING;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 1709) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1689, 1381) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1689, 1709) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1381, 1510) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1381, 1689) ON CONFLICT DO NOTHING;"
    ],
    "summary": "Create an AFTER INSERT trigger function for the \"Friend\" table named update_highschooler_grade. The function must increment the \"grade\" column in the \"Highschooler\" table by 1 for the row where its \"ID\" matches NEW.student_id. The function should return NEW. Also, write an INSERT statement for the \"Friend\" table with values (1510, 1381) that uses ON CONFLICT DO NOTHING.",
    "natural_language": "Define an AFTER INSERT trigger function called update_highschooler_grade for the \"Friend\" table. This function must add 1 to the \"grade\" column in the \"Highschooler\" table for the row whose \"ID\" equals NEW.student_id and must return NEW. Then, insert the values (1510, 1381) into the \"Friend\" table, using ON CONFLICT DO NOTHING.",
    "id": 87
  },
  {
    "ir": "Write a PostgreSQL trigger function named remove_friendship that returns a trigger, which is automatically executed by a trigger named friendship_remove_trigger after a delete operation occurs on each row of the \"Likes\" table. The function performs a delete operation on the \"Friend\" table, targeting rows where the \"Friend\" table's \"student_id\" column value is equal to the OLD.\"student_id\" value from the deleted \"Likes\" row and simultaneously where the \"Friend\" table's \"friend_id\" column value is equal to the OLD.\"liked_id\" value from the same deleted \"Likes\" row. After performing this deletion, the function returns the OLD row record from the \"Likes\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_friendship() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM \"Friend\" WHERE \"student_id\" = OLD.\"student_id\" AND \"friend_id\" = OLD.\"liked_id\";\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER friendship_remove_trigger\nAFTER DELETE ON \"Likes\"\nFOR EACH ROW\nEXECUTE FUNCTION remove_friendship();",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "DELETE FROM \"Likes\" WHERE \"student_id\" = 1689 AND \"liked_id\" = 1709;",
      "DELETE FROM \"Likes\" WHERE \"student_id\" = 1709 AND \"liked_id\" = 1689;",
      "DELETE FROM \"Likes\" WHERE \"student_id\" = 1782 AND \"liked_id\" = 1689;",
      "DELETE FROM \"Likes\" WHERE \"student_id\" = 1689 AND \"liked_id\" = 1689;",
      "DELETE FROM \"Likes\" WHERE \"student_id\" = 1709 AND \"liked_id\" = 1709;"
    ],
    "summary": "Create an AFTER DELETE trigger function for the \"Likes\" table named remove_friendship. The function must delete rows from the \"Friend\" table where its student_id equals OLD.student_id and its friend_id equals OLD.liked_id. The function should return OLD.",
    "natural_language": "Alright, so we need a trigger that kicks in after someone deletes a 'like'. Call it 'remove_friendship' for the 'Likes' table. Basically, when a like gets axed, the function should also wipe out any friendship in the 'Friend' table where the student_id matches the old student_id and the friend_id matches the old liked_id. Oh, and make sure the function spits back the OLD record.",
    "id": 88
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `trg_update_institution_enrollment` that is designed to be executed in response to specific data manipulation events on a table. This function does not accept any explicit input parameters beyond the standard trigger context variables. It returns a value of type `TRIGGER`, which is a special return type indicating that it is intended for use as a trigger function. The core logic of this function involves a single data modification operation: an `UPDATE` statement. This `UPDATE` statement targets the table named `\"Institution\"`. Within this table, it modifies the column named `\"Enrollment\"`. The new value for `\"Enrollment\"` is calculated by taking its current value and adding `100` to it. This update operation is conditional, applying only to rows where the value in the `\"Institution_id\"` column matches the value of `NEW.\"Institution_id\"`. `NEW` is a special record variable available within trigger functions that represents the new row being inserted or updated. In this specific context, since the trigger is defined `AFTER INSERT`, `NEW.\"Institution_id\"` refers to the value of the `Institution_id` column from the row that was just inserted into the `protein` table. After performing this update, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the row that caused the trigger to fire should be processed as usual.\n\nThis trigger function is then associated with a trigger named `update_institution_enrollment`. This trigger is configured to activate `AFTER INSERT` operations on the table named `\"protein\"`. The `FOR EACH ROW` clause specifies that the trigger function `trg_update_institution_enrollment()` will be executed once for every single row that is inserted into the `\"protein\"` table. The `EXECUTE FUNCTION trg_update_institution_enrollment()` clause explicitly calls the previously defined trigger function to perform its logic whenever an `INSERT` event occurs on the `\"protein\"` table for each affected row. Therefore, whenever a new row is successfully inserted into the `\"protein\"` table, the `trg_update_institution_enrollment` function will execute, locate the corresponding institution based on the `Institution_id` from the newly inserted protein record, and increment that institution's `\"Enrollment\"` count by `100`.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_institution_enrollment() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Institution\" SET \"Enrollment\" = \"Enrollment\" + 100 WHERE \"Institution_id\" = NEW.\"Institution_id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_institution_enrollment\nAFTER INSERT ON \"protein\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_institution_enrollment();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\") VALUES ('Test Frog', 'test protein A', 100.5, 'XP_TEST001.1', 500.0, '45%', '0');",
      "INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\") VALUES ('Zebra Fish', 'zebrafish protein Z', 250.3, 'XP_TEST002.1', 1200.0, '50%', '1');",
      "INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\") VALUES ('Fruit Fly', 'drosophila protein D', 600.8, 'XP_TEST003.1', 800.0, '25%', '2');",
      "INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\") VALUES ('Mouse', 'mouse protein M', 75.1, 'XP_TEST004.1', 1500.0, '85%', '0');",
      "INSERT INTO \"protein\" (\"common_name\", \"protein_name\", \"divergence_from_human_lineage\", \"accession_number\", \"sequence_length\", \"sequence_identity_to_human_protein\", \"Institution_id\") VALUES ('Chicken', 'chicken protein C', 300.0, 'XP_TEST005.1', 950.0, '60%', '1');"
    ],
    "summary": "Create an AFTER INSERT trigger function for the \"protein\" table named trg_update_institution_enrollment. The function must update the \"Institution\" table, increasing the \"Enrollment\" column by 100 for the row where its \"Institution_id\" matches NEW.Institution_id. The function should return NEW.",
    "natural_language": "Construct an AFTER INSERT trigger function specifically for the \"protein\" table, which you should name trg_update_institution_enrollment. This detailed function must carefully update the existing \"Institution\" table by precisely incrementing the value in its \"Enrollment\" column by exactly 100, but only for that particular row where the table's \"Institution_id\" column perfectly matches the NEW.Institution_id value provided by the trigger. Finally, the function should explicitly return the NEW record.",
    "id": 89
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_delete_related_proteins that returns a trigger, which is automatically executed as an AFTER DELETE trigger on the Institution table for each deleted row; this function performs a DELETE operation on the protein table where the value in the protein table's Institution_id column is equal to the value of the Institution_id column from the OLD record representing the deleted Institution row, and the function concludes by returning the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_related_proteins() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"protein\" WHERE \"Institution_id\" = OLD.\"Institution_id\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_related_proteins\nAFTER DELETE ON \"Institution\"\nFOR EACH ROW EXECUTE FUNCTION trg_delete_related_proteins();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '0';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '1';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '2';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '3';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '5';"
    ],
    "summary": "Create an AFTER DELETE trigger function for the \"Institution\" table named trg_delete_related_proteins. The function must delete rows from the \"protein\" table where its Institution_id equals OLD.Institution_id. The function should return OLD.",
    "natural_language": "Define an AFTER DELETE trigger function called trg_delete_related_proteins for the \"Institution\" table. Ensure the function deletes all corresponding rows from the \"protein\" table where the Institution_id matches the OLD.Institution_id and returns OLD.",
    "id": 90
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_insert_building_record that is executed automatically after every successful insertion of a new row into the Institution table, and within this function, perform an insert operation into the building table, populating its columns with specific values derived from the newly inserted Institution row and with constant values, where the building_id column receives the value from the NEW.Institution_id column, the Name column receives the value from the NEW.Institution column, the Street_address column receives the value from the NEW.Location column, the Height_feet column is set to the constant integer value 150, and the Floors column is set to the constant integer value 5.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_insert_building_record() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"building\" (\"building_id\", \"Name\", \"Street_address\", \"Height_feet\", \"Floors\") VALUES (NEW.\"Institution_id\", NEW.\"Institution\", NEW.\"Location\", 150, 5);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_building_record\nAFTER INSERT ON \"Institution\"\nFOR EACH ROW EXECUTE FUNCTION trg_insert_building_record();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\") VALUES ('4', 'New University', 'New City, State', 2023.0, 'Private', 1500, 'New Team', 'New Conference', '4');",
      "INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\") VALUES ('5', 'Another University', 'Another City, State', 2022.0, 'Public', 2000, 'Another Team', 'Another Conference', '5');",
      "INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\") VALUES ('6', 'Sample University', 'Sample City, State', 2021.0, 'Private', 1800, 'Sample Team', 'Sample Conference', '6');",
      "INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\") VALUES ('7', 'Test University', 'Test City, State', 2020.0, 'Public', 2200, 'Test Team', 'Test Conference', '7');",
      "INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\") VALUES ('8', 'Example University', 'Example City, State', 2019.0, 'Private', 1600, 'Example Team', 'Example Conference', '8');"
    ],
    "summary": "Create an AFTER INSERT trigger function named trg_insert_building_record. After inserting a row into the Institution table, insert a row into the building table. Set building_id to NEW.Institution_id, Name to NEW.Institution, Street_address to NEW.Location, Height_feet to 150, and Floors to 5.",
    "natural_language": "Create AFTER INSERT trigger trg_insert_building_record. On Institution insert, add building row with building_id as NEW.Institution_id, Name as NEW.Institution, Street_address as NEW.Location, Height_feet 150, Floors 5.",
    "id": 91
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_update_building_floors that returns a trigger, which is automatically invoked after each row update operation on the \"Institution\" table; the function's logic executes an UPDATE statement on the \"building\" table, specifically incrementing the value of the \"Floors\" column by 1 for the single row where the \"building_id\" column in the \"building\" table matches the NEW.\"building_id\" value from the recently updated \"Institution\" row, and the function concludes by returning the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_building_floors() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"building\" SET \"Floors\" = \"Floors\" + 1 WHERE \"building_id\" = NEW.\"building_id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_building_floors\nAFTER UPDATE ON \"Institution\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_building_floors();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "UPDATE \"Institution\" SET \"Enrollment\" = 1300 WHERE \"Institution_id\" = '0';",
      "UPDATE \"Institution\" SET \"Enrollment\" = 3200 WHERE \"Institution_id\" = '1';",
      "UPDATE \"Institution\" SET \"Enrollment\" = 900 WHERE \"Institution_id\" = '2';",
      "UPDATE \"Institution\" SET \"Type\" = 'Public' WHERE \"Institution_id\" = '0';",
      "UPDATE \"Institution\" SET \"Team\" = 'Lions' WHERE \"Institution_id\" = '1';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_update_building_floors. After updating a row in the Institution table, update the building table. Increment the Floors column by 1 for the row where building_id equals NEW.building_id. Return the NEW row.",
    "natural_language": "How do you create an AFTER UPDATE trigger function named trg_update_building_floors that, after a row in the Institution table is updated, increments the Floors column by 1 in the building table for the row where building_id equals NEW.building_id and then returns the NEW row?",
    "id": 92
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the \"building\" table. This function, named trg_remove_institution_link, does not take any parameters and returns a trigger type. When a row is about to be deleted from the \"building\" table, the function updates the \"Institution\" table by setting the \"building_id\" column to NULL for all rows where the \"building_id\" matches the \"building_id\" of the row being deleted, which is accessed using the OLD keyword. The function then returns the OLD row, which is the row that is about to be deleted from the \"building\" table. The trigger, named remove_institution_link, is defined to execute this function before any delete operation on each row of the \"building\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_remove_institution_link() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Institution\" SET \"building_id\" = NULL WHERE \"building_id\" = OLD.\"building_id\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_institution_link\nBEFORE DELETE ON \"building\"\nFOR EACH ROW EXECUTE FUNCTION trg_remove_institution_link();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "DELETE FROM \"building\" WHERE \"building_id\" = '1';",
      "DELETE FROM \"building\" WHERE \"building_id\" = '3';",
      "DELETE FROM \"building\" WHERE \"Name\" = 'Citizens Bank Building';",
      "DELETE FROM \"building\" WHERE \"Height_feet\" > 150;",
      "DELETE FROM \"building\" WHERE \"building_id\" IN ('0', '2');"
    ],
    "summary": "Create a BEFORE DELETE trigger function named trg_remove_institution_link. Before deleting a row from the building table, update the Institution table. Set the building_id column to NULL for all rows where building_id equals OLD.building_id. Return the OLD row.",
    "natural_language": "Alright, so we need a trigger function called trg_remove_institution_link that kicks in BEFORE we delete something from the building table. What it's gotta do is: before that building row gets wiped, go into the Institution table and find any records that are still linked to that building's ID. For all those linked records, just set their building_id to NULL. After that's done, hand back the OLD row.",
    "id": 93
  },
  {
    "ir": "Write a PLpgSQL function that is designed to be used as a trigger function, which automatically inserts a new record into the job_history table whenever a new row is added to the employees table. The function does not take any parameters directly, but operates using the NEW record, which is a special variable representing the row that was just inserted into the employees table. The function inserts a new row into the job_history table with the following columns: EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, and DEPARTMENT_ID. The EMPLOYEE_ID is set to the value of the EMPLOYEE_ID column from the NEW record. The START_DATE is set to the value of the HIRE_DATE column from the NEW record. The END_DATE is set to the current date, obtained using the CURRENT_DATE function, which provides the current date according to the system clock. The JOB_ID is set to the value of the JOB_ID column from the NEW record, and the DEPARTMENT_ID is set to the value of the DEPARTMENT_ID column from the NEW record. After performing the insertion into the job_history table, the function returns the NEW record, which is a standard practice in trigger functions to allow the operation that fired the trigger to proceed. The function is associated with a trigger named job_history_record_insert, which is defined to execute after an insert operation on the employees table. This trigger is specified to execute the insert_job_history_record function for each row that is inserted into the employees table, ensuring that a corresponding entry is made in the job_history table for every new employee record.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_job_history_record() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"job_history\" (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\")\n  VALUES (NEW.\"EMPLOYEE_ID\", NEW.\"HIRE_DATE\", CURRENT_DATE, NEW.\"JOB_ID\", NEW.\"DEPARTMENT_ID\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER job_history_record_insert\nAFTER INSERT ON \"employees\"\nFOR EACH ROW EXECUTE FUNCTION insert_job_history_record();",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (207, 'John', 'Doe', 'JDOE', '515.123.4570', '2023-01-15', 'IT_PROG', 8000.00, NULL, 103, 60);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (208, 'Jane', 'Smith', 'JSMITH', '515.123.4571', '2022-05-20', 'SA_REP', 9500.00, 0.10, 145, 80);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (209, 'Peter', 'Jones', 'PJONES', '515.123.4572', '2021-11-01', 'MK_REP', 7000.00, NULL, 201, 20);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (210, 'Alice', 'Williams', 'AWILLIAMS', '515.123.4573', '2024-03-10', 'HR_REP', 6000.00, NULL, 101, 40);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (211, 'Robert', 'Brown', 'RBROWN', '515.123.4574', '2020-08-25', 'PU_CLERK', 4000.00, NULL, 114, 30);"
    ],
    "summary": "Create an AFTER INSERT trigger function for the employees table. After inserting a row, insert a record into the job_history table. Set EMPLOYEE_ID to NEW.EMPLOYEE_ID, START_DATE to NEW.HIRE_DATE, END_DATE to CURRENT_DATE, JOB_ID to NEW.JOB_ID, and DEPARTMENT_ID to NEW.DEPARTMENT_ID. Return the NEW row.",
    "natural_language": "Alright, so I need a trigger that kicks in right after we add someone new to the employees table. When that happens, we gotta also log an entry in the job_history table. Just copy over the new employee's ID, their hire date as the start date, use today's date for the end date, and grab their job ID and department ID from the new record. Finally, just hand back the new row as is.",
    "id": 94
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_employee_job that is executed automatically after each row update on the \"jobs\" table, which, when the \"JOB_ID\" column value in the updated row is different from its previous value (checked using the IS DISTINCT FROM condition to properly handle nulls), performs an update on the \"employees\" table, setting the \"JOB_ID\" column for all rows in the \"employees\" table where the current \"JOB_ID\" matches the old \"JOB_ID\" value from the \"jobs\" table to the new \"JOB_ID\" value from the updated \"jobs\" table row, and the function returns the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_employee_job() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the JOB_ID actually changed in the jobs table\n  IF OLD.\"JOB_ID\" IS DISTINCT FROM NEW.\"JOB_ID\" THEN\n    -- Update employees whose old JOB_ID matches the old JOB_ID from the jobs table\n    -- to the new JOB_ID from the jobs table.\n    UPDATE \"employees\"\n    SET \"JOB_ID\" = NEW.\"JOB_ID\"\n    WHERE \"JOB_ID\" = OLD.\"JOB_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER employee_job_update\nAFTER UPDATE ON \"jobs\"\nFOR EACH ROW EXECUTE FUNCTION update_employee_job();",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "UPDATE \"jobs\" SET \"JOB_ID\" = 'AD_VP' WHERE \"JOB_ID\" = 'AD_PRES';",
      "UPDATE \"jobs\" SET \"JOB_ID\" = 'AD_ASST' WHERE \"JOB_ID\" = 'AD_VP';",
      "UPDATE \"jobs\" SET \"JOB_ID\" = 'AD_PRES' WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE \"jobs\" SET \"JOB_ID\" = 'AD_VP' WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE \"jobs\" SET \"JOB_ID\" = 'AD_ASST' WHERE \"JOB_ID\" = 'AD_PRES';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_employee_job for the jobs table. After updating a row, if the new JOB_ID is distinct from the old JOB_ID, update the employees table. Set the JOB_ID column to the new JOB_ID for all employees where JOB_ID equals the old JOB_ID. Return the NEW row.",
    "natural_language": "Set up a trigger on the jobs table that runs after updates. Call it update_employee_job. Basically, if the job ID gets changed to something different, then go and also update that same job ID for any affected people in the employees list. Just make sure the old references are swapped out for the new one. Have the function give back the updated record.",
    "id": 95
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `validate_customer_event` that is designed to be executed as a `BEFORE INSERT` trigger on the `\"Customer_Events\"` table for each row. This function takes no explicit parameters but implicitly operates on the `NEW` record, which represents the row being inserted into `\"Customer_Events\"`. The function first performs a validation check to ensure referential integrity for the `customer_id`. It executes a `SELECT 1` query on the `\"Customers\"` table, filtering by `\"customer_id\"` where `\"customer_id\"` in `\"Customers\"` is equal to the `customer_id` value from the `NEW` record (`NEW.\"customer_id\"`). If no matching record is found in `\"Customers\"`, indicating that the referenced customer does not exist, the function raises an `EXCEPTION` with the message 'Customer ID % does not exist', substituting the placeholder with the value of `NEW.\"customer_id\"`. Subsequently, the function performs another validation check for referential integrity, this time for the `thing_id`. It executes a `SELECT 1` query on the `\"Things\"` table, filtering by `\"thing_id\"` where `\"thing_id\"` in `\"Things\"` is equal to the `thing_id` value from the `NEW` record (`NEW.\"thing_id\"`). If no matching record is found in `\"Things\"`, indicating that the referenced thing does not exist, the function raises an `EXCEPTION` with the message 'Thing ID % does not exist', substituting the placeholder with the value of `NEW.\"thing_id\"`. Finally, the function checks for the presence of `NULL` values in specific columns of the `NEW` record. It evaluates if `NEW.\"resident_id\"` is `NULL` OR `NEW.\"property_id\"` is `NULL` OR `NEW.\"date_moved_in\"` is `NULL`. If any of these conditions are true, indicating that one or more of these required fields are `NULL`, the function raises an `EXCEPTION` with the message 'resident_id, property_id, and date_moved_in cannot be NULL'. If all validation checks pass without raising an exception, the function returns the `NEW` record, allowing the insertion operation to proceed.\n\nAdditionally, write a PostgreSQL PL/pgSQL function named `update_thing_service_on_event` that is designed to be executed as an `AFTER INSERT` trigger on the `\"Customer_Events\"` table for each row. This function takes no explicit parameters but implicitly operates on the `NEW` record, which represents the row that has just been inserted into `\"Customer_Events\"`. The function performs an `UPDATE` operation on the `\"Things\"` table. It sets the `\"service_details\"` column to the literal string value 'Updated via Event' for all rows in `\"Things\"` where the `\"thing_id\"` column matches the `thing_id` value from the `NEW` record (`NEW.\"thing_id\"`). After performing the update, the function returns the `NEW` record.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_customer_event() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if referenced customer exists\n    IF NOT EXISTS (SELECT 1 FROM \"Customers\" WHERE \"customer_id\" = NEW.\"customer_id\") THEN\n        RAISE EXCEPTION 'Customer ID % does not exist', NEW.\"customer_id\";\n    END IF;\n    \n    -- Check if referenced thing exists\n    IF NOT EXISTS (SELECT 1 FROM \"Things\" WHERE \"thing_id\" = NEW.\"thing_id\") THEN\n        RAISE EXCEPTION 'Thing ID % does not exist', NEW.\"thing_id\";\n    END IF;\n    \n    -- Assuming Residents table exists but isn't in provided schema, validate if possible\n    -- Since schema doesn't include Residents, we'll skip validation but ensure required fields are not null\n    IF NEW.\"resident_id\" IS NULL OR NEW.\"property_id\" IS NULL OR NEW.\"date_moved_in\" IS NULL THEN\n        RAISE EXCEPTION 'resident_id, property_id, and date_moved_in cannot be NULL';\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trg_validate_customer_event\"\n    BEFORE INSERT ON \"Customer_Events\"\n    FOR EACH ROW\n    EXECUTE FUNCTION validate_customer_event();\n\nCREATE OR REPLACE FUNCTION update_thing_service_on_event() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Things\" \n    SET \"service_details\" = 'Updated via Event' \n    WHERE \"thing_id\" = NEW.\"thing_id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trg_update_thing_service\"\n    AFTER INSERT ON \"Customer_Events\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_thing_service_on_event();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Things",
      "Timed_Status_of_Things"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Events\" (\"Customer_Event_ID\", \"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (1, 4, '2023-01-01 10:00:00+00:00', 101, 1, 1);",
      "INSERT INTO \"Customer_Events\" (\"Customer_Event_ID\", \"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (2, 5, '2023-02-01 11:00:00+00:00', 102, 2, 2);",
      "INSERT INTO \"Customer_Events\" (\"Customer_Event_ID\", \"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (3, 16, '2023-03-01 12:00:00+00:00', 103, 3, 10);",
      "INSERT INTO \"Customer_Events\" (\"Customer_Event_ID\", \"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (4, 4, '2023-04-01 13:00:00+00:00', 104, 4, 1);",
      "INSERT INTO \"Customer_Events\" (\"Customer_Event_ID\", \"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (5, 5, '2023-05-01 14:00:00+00:00', 105, 5, 2);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named validate_customer_event for the Customer_Events table. Validate that NEW.customer_id exists in the Customers table, raising 'Customer ID does not exist' if not. Validate that NEW.thing_id exists in the Things table, raising 'Thing ID does not exist' if not. Check that NEW.resident_id, NEW.property_id, and NEW.date_moved_in are NOT NULL, raising an exception if any are null. Return NEW if all checks pass.",
    "natural_language": "Set up a trigger function to run before adding entries to the Customer_Events table. It should make sure the customer ID looks right by checking it against the Customers list, and complain if it's not found. Do a similar check for the thing ID with the Things list. Also, the resident ID, property ID, and move-in date should generally have values, and the trigger should raise an issue if they seem to be missing. If everything seems okay, just proceed with the new record.",
    "id": 96
  },
  {
    "ir": "Write a PostgreSQL trigger function named check_customer_exists that is executed automatically by a trigger named trg_check_customer_exists before any new row is inserted into the Customer_Events table, and for each such row, the function first checks if a record with a customer_id matching the new row's customer_id value exists in the Customers table, and if no such record exists, it inserts a new row into the Customers table using the new customer_id and a static string 'Auto-created Customer' for the customer_details column, then the function attempts to ensure a corresponding record exists in the Residents table by executing a block that tries to insert a new row into Residents using the new row's resident_id, property_id, and date_moved_in values, with an ON CONFLICT DO NOTHING clause to prevent duplicate key violations, and if during this attempt an undefined_table exception is raised because the Residents table does not exist, the function raises an exception with a message stating the constraint cannot be satisfied and includes the new resident_id, property_id, and date_moved_in values, and if any other exception occurs, the function raises an exception with the SQL error message, and finally, if no exceptions are raised, the function returns the NEW row record to allow the triggering insert on Customer_Events to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION check_customer_exists() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check and create customer if needed\n    IF NOT EXISTS (SELECT 1 FROM \"Customers\" WHERE \"customer_id\" = NEW.\"customer_id\") THEN\n        INSERT INTO \"Customers\" (\"customer_id\", \"customer_details\") VALUES (NEW.\"customer_id\", 'Auto-created Customer');\n    END IF;\n    \n    -- Check if the resident/property combination exists in Residents table\n    -- If not, we'll create a basic record or handle the constraint violation\n    BEGIN\n        -- Attempt to insert a basic resident record if it doesn't exist\n        INSERT INTO \"Residents\" (\"resident_id\", \"property_id\", \"date_moved_in\") \n        VALUES (NEW.\"resident_id\", NEW.\"property_id\", NEW.\"date_moved_in\")\n        ON CONFLICT DO NOTHING;\n    EXCEPTION\n        WHEN undefined_table THEN\n            -- If Residents table doesn't exist, we can't proceed with this insert\n            RAISE EXCEPTION 'Cannot insert Customer_Event: Residents table constraint cannot be satisfied for resident_id=%, property_id=%, date_moved_in=%', \n                NEW.\"resident_id\", NEW.\"property_id\", NEW.\"date_moved_in\";\n        WHEN OTHERS THEN\n            -- Handle other potential issues\n            RAISE EXCEPTION 'Error handling resident constraint: %', SQLERRM;\n    END;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trg_check_customer_exists\"\n    BEFORE INSERT ON \"Customer_Events\"\n    FOR EACH ROW\n    EXECUTE FUNCTION check_customer_exists();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Things",
      "Timed_Status_of_Things"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Events\" (\"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (19, '2015-03-27 12:00:00+08:00', 605, 10, 1);",
      "INSERT INTO \"Customer_Events\" (\"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (5, '2015-03-27 12:00:00+08:00', 879, 23, 80);",
      "INSERT INTO \"Customer_Events\" (\"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (16, '2015-03-27 12:00:00+08:00', 629, 28, 14);",
      "INSERT INTO \"Customer_Events\" (\"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (19, '2015-03-27 12:00:00+08:00', 605, 28, 1);",
      "INSERT INTO \"Customer_Events\" (\"customer_id\", \"date_moved_in\", \"property_id\", \"resident_id\", \"thing_id\") VALUES (5, '2015-03-27 12:00:00+08:00', 879, 10, 80);"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_thing_service_on_event for the Customer_Events table. Update the Things table, setting service_details to 'Updated via Event' where thing_id equals NEW.thing_id. Return NEW.",
    "natural_language": "Please construct an AFTER INSERT trigger function designated as 'update_thing_service_on_event' for the Customer_Events table. The function's operation shall be to modify the Things table by assigning the value 'Updated via Event' to the service_details column for any record whose thing_id matches the NEW.thing_id value. The function must conclude by returning the NEW row.",
    "id": 97
  },
  {
    "ir": "Write a PostgreSQL trigger function named handle_station_removal that returns a trigger and is executed by a trigger named company_removal_trigger, where the trigger is defined to fire after a delete operation on the company table for each row that is deleted, and the function performs a delete operation on the station_company table targeting all rows where the column Company_ID matches the OLD.Company_ID value from the deleted company row and the column Rank_of_the_Year has a value greater than 5, and the function concludes by returning the OLD row record to the invoking trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION handle_station_removal() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM station_company WHERE \"Company_ID\" = OLD.\"Company_ID\" AND \"Rank_of_the_Year\" > 5;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER company_removal_trigger\nAFTER DELETE ON company\nFOR EACH ROW EXECUTE FUNCTION handle_station_removal();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM company WHERE \"Company_ID\" = 1;",
      "DELETE FROM company WHERE \"Company_ID\" = 3;",
      "DELETE FROM company WHERE \"Company_ID\" = 6;",
      "DELETE FROM company WHERE \"Company_ID\" = 2;",
      "DELETE FROM company WHERE \"Company_ID\" = 4;"
    ],
    "summary": "Create a BEFORE INSERT trigger function named check_customer_exists for the Customer_Events table. If NEW.customer_id does not exist in the Customers table, insert it with customer_details as 'Auto-created Customer'. Then, attempt to insert NEW.resident_id, NEW.property_id, and NEW.date_moved_in into the Residents table with ON CONFLICT DO NOTHING. If the Residents table does not exist, raise an exception stating the constraint cannot be satisfied with the provided values. For any other exception, raise the SQL error. Return NEW.",
    "natural_language": "How can I create a BEFORE INSERT trigger function named check_customer_exists for the Customer_Events table that checks if NEW.customer_id exists in the Customers table, inserts it with 'Auto-created Customer' details if it does not, then attempts to insert NEW.resident_id, NEW.property_id, and NEW.date_moved_in into the Residents table with ON CONFLICT DO NOTHING, raises an exception if the Residents table is missing, raises any other SQL error, and finally returns NEW?",
    "id": 98
  },
  {
    "ir": "Write a PLpgSQL function named log_employee_changes that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to be used with a trigger that fires after a DELETE operation on the employees table. The function performs an INSERT operation into the job_history table, which has columns EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, and DEPARTMENT_ID. The values inserted into these columns are derived from the OLD record, which represents the state of the deleted row from the employees table. Specifically, the EMPLOYEE_ID column in job_history is populated with the value from OLD.EMPLOYEE_ID, the START_DATE column is populated with the value from OLD.HIRE_DATE, the END_DATE column is set to the current date using the CURRENT_DATE function, the JOB_ID column is populated with the value from OLD.JOB_ID, and the DEPARTMENT_ID column is populated with the value from OLD.DEPARTMENT_ID. The function returns NULL, which is typical for trigger functions that do not modify the row being processed. The associated trigger, named trg_log_employee_changes, is defined to execute this function after a row is deleted from the employees table, ensuring that the job history of the deleted employee is recorded in the job_history table.",
    "plsql": "CREATE OR REPLACE FUNCTION log_employee_changes() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"job_history\" (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (OLD.\"EMPLOYEE_ID\", OLD.\"HIRE_DATE\", CURRENT_DATE, OLD.\"JOB_ID\", OLD.\"DEPARTMENT_ID\");\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_employee_changes\n    AFTER DELETE ON \"employees\"\n    FOR EACH ROW\n    EXECUTE FUNCTION log_employee_changes();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "DELETE FROM employees WHERE EMPLOYEE_ID = 100;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 101;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 102;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 103;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 104;"
    ],
    "summary": "Create an AFTER DELETE trigger function named handle_station_removal for the company table. Delete rows from the station_company table where Company_ID equals OLD.Company_ID and Rank_of_the_Year is greater than 5. Return OLD.",
    "natural_language": "Set up a trigger function called handle_station_removal to run after something gets deleted from the company table. It should clean up related entries in the station_company table for that company, but only for those with a fairly high Rank_of_the_Year. Finally, just give back the record that was removed.",
    "id": 99
  },
  {
    "ir": "Write a PLpgSQL trigger function named `update_department_manager` that is designed to be executed after an `INSERT` operation on the `\"employees\"` table. This function takes no explicit parameters but operates on the `NEW` record, which represents the newly inserted row in the `\"employees\"` table. The primary purpose of this function is to conditionally update the `MANAGER_ID` in the `\"departments\"` table. Specifically, it first checks if the `JOB_ID` of the `NEW` employee record contains either the substring `'MAN'` or the substring `'MGR'`. This check is performed using the `LIKE` operator, comparing `NEW.\"JOB_ID\"` with `'%MAN%'` and `NEW.\"JOB_ID\"` with `'%MGR%'`. If this condition is true, indicating that the new employee has a managerial job title, the function proceeds to update the `\"departments\"` table. It sets the `\"MANAGER_ID\"` column to the value of `NEW.\"EMPLOYEE_ID\"` for the row where the `\"DEPARTMENT_ID\"` column matches the value of `NEW.\"DEPARTMENT_ID\"`. After attempting this update, the function checks if any row was affected by the `UPDATE` statement using the `FOUND` special variable. If `NOT FOUND` is true, meaning no department record was found matching `NEW.\"DEPARTMENT_ID\"`, it raises a `NOTICE` message indicating that the department does not exist, specifically stating 'Department % does not exist' and substituting `%` with the value of `NEW.\"DEPARTMENT_ID\"`. Regardless of whether an update occurred or a notice was raised, the function concludes by returning the `NEW` record.\n\nThis trigger function is associated with a trigger named `trg_update_department_manager`. This trigger is configured to fire `AFTER INSERT` operations on the `\"employees\"` table. It is a `FOR EACH ROW` trigger, meaning the `update_department_manager` function will be executed once for each row that is inserted into the `\"employees\"` table. The `EXECUTE FUNCTION update_department_manager()` clause specifies that the `update_department_manager` function should be invoked when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION update_department_manager() RETURNS TRIGGER AS $$\nBEGIN\n    -- Only update manager if the new employee has a managerial job title\n    IF NEW.\"JOB_ID\" LIKE '%MAN%' OR NEW.\"JOB_ID\" LIKE '%MGR%' THEN\n        UPDATE \"departments\" \n        SET \"MANAGER_ID\" = NEW.\"EMPLOYEE_ID\" \n        WHERE \"DEPARTMENT_ID\" = NEW.\"DEPARTMENT_ID\";\n        \n        -- Check if department was found\n        IF NOT FOUND THEN\n            RAISE NOTICE 'Department % does not exist', NEW.\"DEPARTMENT_ID\";\n        END IF;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_department_manager\n    AFTER INSERT ON \"employees\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_department_manager();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "INSERT INTO \"employees\" (\"EMPLOYEE_ID\", \"FIRST_NAME\", \"LAST_NAME\", \"EMAIL\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (501, 'John', 'Smith', 'JSMITH', 'IT_MAN', 60);",
      "INSERT INTO \"employees\" (\"EMPLOYEE_ID\", \"FIRST_NAME\", \"LAST_NAME\", \"EMAIL\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (502, 'Jane', 'Doe', 'JDOE', 'SALES_MGR', 80);",
      "INSERT INTO \"employees\" (\"EMPLOYEE_ID\", \"FIRST_NAME\", \"LAST_NAME\", \"EMAIL\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (503, 'Bob', 'Wilson', 'BWILSON', 'HR_MANAGER', 70);",
      "INSERT INTO \"employees\" (\"EMPLOYEE_ID\", \"FIRST_NAME\", \"LAST_NAME\", \"EMAIL\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (504, 'Alice', 'Brown', 'ABROWN', 'FIN_MGR', 100);",
      "INSERT INTO \"employees\" (\"EMPLOYEE_ID\", \"FIRST_NAME\", \"LAST_NAME\", \"EMAIL\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (505, 'Charlie', 'Davis', 'CDAVIS', 'AD_ASST', 90);"
    ],
    "summary": "Create an AFTER DELETE trigger function named log_employee_changes for the employees table. Insert a record into the job_history table using values from the OLD record: OLD.EMPLOYEE_ID, OLD.HIRE_DATE, CURRENT_DATE, OLD.JOB_ID, and OLD.DEPARTMENT_ID. Return NULL.",
    "natural_language": "How can I create an AFTER DELETE trigger function named log_employee_changes for the employees table that inserts a record into the job_history table using the OLD.EMPLOYEE_ID, OLD.HIRE_DATE, CURRENT_DATE, OLD.JOB_ID, and OLD.DEPARTMENT_ID values and returns NULL?",
    "id": 100
  },
  {
    "ir": "Write a PostgreSQL trigger function named cleanup_job_history that returns a trigger, which is invoked by a trigger named trg_cleanup_job_history configured to execute before a delete operation on the employees table for each individual row being deleted. The function performs a delete operation on the job_history table, targeting all rows where the value in the job_history table's EMPLOYEE_ID column is equal to the EMPLOYEE_ID value from the OLD record, which represents the employee row that is about to be deleted from the employees table. The function then returns a NULL value to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_job_history() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"job_history\" WHERE \"EMPLOYEE_ID\" = OLD.\"EMPLOYEE_ID\";\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_job_history\n    BEFORE DELETE ON \"employees\"\n    FOR EACH ROW\n    EXECUTE FUNCTION cleanup_job_history();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "DELETE FROM \"employees\" WHERE \"EMPLOYEE_ID\" = 100;",
      "DELETE FROM \"employees\" WHERE \"EMPLOYEE_ID\" = 101;",
      "DELETE FROM \"employees\" WHERE \"EMPLOYEE_ID\" = 102;",
      "DELETE FROM \"employees\" WHERE \"LAST_NAME\" = 'King';",
      "DELETE FROM \"employees\" WHERE \"DEPARTMENT_ID\" = 90;"
    ],
    "summary": "Create a PostgreSQL trigger function named cleanup_job_history that executes BEFORE DELETE on the employees table for each row. It deletes rows from the job_history table where EMPLOYEE_ID equals the OLD.EMPLOYEE_ID and returns NULL.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called cleanup_job_history? It should run right before we delete a record from the employees table, for each row. Basically, it needs to clean up by deleting any matching entries in the job_history table where the EMPLOYEE_ID matches the OLD.EMPLOYEE_ID from the row we're about to ditch. Oh, and make sure it returns NULL.",
    "id": 101
  },
  {
    "ir": "Write a PLpgSQL function named trg_delete_station_company that is designed to be used as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to execute after a row is deleted from the company table. The function performs a delete operation on the station_company table, specifically removing all rows where the Company_ID column matches the Company_ID value of the deleted row from the company table, which is accessible via the OLD record. The function then returns the OLD record, which represents the state of the deleted row from the company table before the deletion occurred. The function is associated with a trigger named delete_station_company_trigger, which is defined to fire after a delete operation on the company table for each row that is deleted. This trigger ensures that whenever a row is deleted from the company table, the corresponding rows in the station_company table that share the same Company_ID are also deleted, maintaining referential integrity between the two tables.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_station_company() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM station_company\n    WHERE \"Company_ID\" = OLD.\"Company_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_station_company_trigger\nAFTER DELETE ON company\nFOR EACH ROW EXECUTE FUNCTION trg_delete_station_company();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM company WHERE \"Company_ID\" = 1;",
      "DELETE FROM company WHERE \"Company_ID\" = 2;",
      "DELETE FROM company WHERE \"Company_ID\" = 3;"
    ],
    "summary": "Create a PLpgSQL trigger function named trg_delete_station_company that executes AFTER DELETE on the company table for each row. It deletes rows from the station_company table where Company_ID equals the OLD.Company_ID and returns the OLD record.",
    "natural_language": "Alright, so we need a trigger function called trg_delete_station_company. Set it up to run after a row gets deleted from the company table. What it should do is clean up by deleting any matching entries in the station_company table where the Company_ID matches the old one from the deleted company row. Oh, and make sure it spits back that OLD record.",
    "id": 102
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_insert_job_history` that is designed to be executed after an `INSERT` operation on the `employees` table, for each row that is inserted. This function does not accept any explicit parameters but operates on the `NEW` pseudo-record, which represents the newly inserted row in the `employees` table. The primary purpose of this function is to insert a new record into the `job_history` table. Specifically, it inserts values into the `job_history` table's columns: `\"EMPLOYEE_ID\"`, `\"START_DATE\"`, `\"END_DATE\"`, `\"JOB_ID\"`, and `\"DEPARTMENT_ID\"`. The value for the `\"EMPLOYEE_ID\"` column in `job_history` is sourced from the `EMPLOYEE_ID` column of the `NEW` record (i.e., `NEW.\"EMPLOYEE_ID\"`). The value for the `\"START_DATE\"` column in `job_history` is sourced from the `HIRE_DATE` column of the `NEW` record (i.e., `NEW.\"HIRE_DATE\"`). The value for the `\"END_DATE\"` column in `job_history` is calculated by taking the `CURRENT_DATE` (the current date at the time of execution) and adding an interval of 30 days to it using the `make_interval` function with the `days` parameter set to `30`. The value for the `\"JOB_ID\"` column in `job_history` is sourced from the `JOB_ID` column of the `NEW` record (i.e., `NEW.\"JOB_ID\"`). The value for the `\"DEPARTMENT_ID\"` column in `job_history` is sourced from the `DEPARTMENT_ID` column of the `NEW` record (i.e., `NEW.\"DEPARTMENT_ID\"`). After performing this insertion, the function returns the `NEW` record, indicating that the row insertion in the `employees` table should proceed as normal. A trigger named `insert_job_history` is defined to execute this function. This trigger is configured to activate `AFTER INSERT` operations on the `employees` table and will execute `FOR EACH ROW` that is inserted, invoking the `trg_insert_job_history()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_insert_job_history() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO job_history (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\")\n  VALUES (NEW.\"EMPLOYEE_ID\", NEW.\"HIRE_DATE\", CURRENT_DATE + make_interval(days := 30), NEW.\"JOB_ID\", NEW.\"DEPARTMENT_ID\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_job_history\nAFTER INSERT ON employees\nFOR EACH ROW EXECUTE FUNCTION trg_insert_job_history();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID) VALUES (207, 'John', 'Doe', 'JDOE', CURRENT_DATE, 'AD_ASST', 10);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID) VALUES (208, 'Jane', 'Smith', 'JSMITH', '2024-01-15', 'AD_VP', 20);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, DEPARTMENT_ID, SALARY) VALUES (209, 'Robert', 'Brown', 'RBROWN', '2024-02-01', 'AD_PRES', 90, 25000);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, DEPARTMENT_ID) VALUES (210, 'Alice', 'Johnson', 'AJOHNSON', '515.123.4570', '2024-03-10', 'AD_ASST', 30);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID, MANAGER_ID, DEPARTMENT_ID) VALUES (211, 'Michael', 'Davis', 'MDAVIS', '2024-04-05', 'AD_VP', 100, 20);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL trigger function named trg_insert_job_history that executes AFTER INSERT on the employees table for each row. It inserts a new row into the job_history table using values from the NEW record: EMPLOYEE_ID, START_DATE from NEW.HIRE_DATE, END_DATE as CURRENT_DATE + 30 days, JOB_ID, and DEPARTMENT_ID. The function returns the NEW record.",
    "natural_language": "Make a trigger function called trg_insert_job_history that runs after someone gets added to the employees table. For each new person, it should put a record into the job_history table. Use the new person's ID, their hire date as the start, set the end date for roughly a month later, and include their job and department details. The function should give back the new record.",
    "id": 103
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `trg_adjust_salary` that is designed to be executed before an update operation on each row of the `\"employees\"` table. This function declares a local variable `v_min_salary` of type `numeric`. The function begins by executing a `SELECT` statement to retrieve the value of the `\"MIN_SALARY\"` column from the `\"jobs\"` table. This retrieval is conditioned by matching the `\"JOB_ID\"` column in the `\"jobs\"` table with the value of the `\"JOB_ID\"` column from the `NEW` row being updated in the `\"employees\"` table. The retrieved `\"MIN_SALARY\"` value is then assigned to the `v_min_salary` variable. Following this, a conditional check is performed: if the value of the `\"SALARY\"` column in the `NEW` row (representing the updated employee's salary) is less than the `v_min_salary` value obtained from the `\"jobs\"` table, then the `\"SALARY\"` column in the `NEW` row is updated by multiplying its current value by `1.1`. Finally, the function returns the `NEW` row, which contains the potentially adjusted salary, to the calling trigger. This trigger function is associated with a trigger named `adjust_salary`, which is configured to execute `BEFORE UPDATE` operations on the `\"employees\"` table `FOR EACH ROW`, invoking the `trg_adjust_salary()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_adjust_salary() RETURNS TRIGGER AS $$\nDECLARE\n  v_min_salary numeric;\nBEGIN\n  -- Ensure all column names are quoted to match the schema's uppercase naming\n  SELECT \"MIN_SALARY\" INTO v_min_salary FROM \"jobs\" WHERE \"JOB_ID\" = NEW.\"JOB_ID\";\n  \n  IF NEW.\"SALARY\" < v_min_salary THEN\n    NEW.\"SALARY\" := NEW.\"SALARY\" * 1.1;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_salary\nBEFORE UPDATE ON \"employees\" -- Quote table name as well for consistency\nFOR EACH ROW EXECUTE FUNCTION trg_adjust_salary();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "UPDATE \"employees\" SET \"SALARY\" = 18000 WHERE \"EMPLOYEE_ID\" = 100 AND \"JOB_ID\" = 'AD_PRES';",
      "UPDATE \"employees\" SET \"SALARY\" = 14000, \"JOB_ID\" = 'AD_VP' WHERE \"EMPLOYEE_ID\" = 101;",
      "UPDATE \"employees\" SET \"SALARY\" = 2800 WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE \"employees\" SET \"SALARY\" = \"SALARY\" - 5000 WHERE \"DEPARTMENT_ID\" = 90;",
      "UPDATE \"employees\" SET \"SALARY\" = 19000 WHERE \"EMPLOYEE_ID\" = 102 AND \"JOB_ID\" = 'AD_VP';"
    ],
    "summary": "Create a PL/pgSQL trigger function named trg_adjust_salary that executes BEFORE UPDATE on the employees table for each row. It retrieves the MIN_SALARY for the NEW.JOB_ID from the jobs table. If the NEW.SALARY is less than this minimum, it increases the NEW.SALARY by 10%. The function returns the NEW record.",
    "natural_language": "Please construct a PL/pgSQL trigger function designated as 'trg_adjust_salary'. This function is to be executed prior to any update operation on the 'employees' table, acting upon each individual row. Its procedure involves querying the 'jobs' table to ascertain the MIN_SALARY value corresponding to the NEW.JOB_ID. Should the NEW.SALARY value be found inferior to the retrieved minimum, the function shall augment the NEW.SALARY by ten percent. The function must conclude by returning the modified NEW record.",
    "id": 104
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after a row is deleted from the employees table. The function, named trg_delete_old_job_history, does not take any parameters directly but operates on the OLD record, which represents the deleted row from the employees table. The function performs a DELETE operation on the job_history table, targeting rows where the EMPLOYEE_ID column matches the EMPLOYEE_ID value from the OLD record and the END_DATE column is less than one year before the current date. The function uses the make_interval function to create a time interval of one year, which is subtracted from the current date to establish the condition for deletion. After executing the DELETE operation, the function returns the OLD record, which is the standard behavior for a trigger function in PostgreSQL. The trigger named delete_old_job_history is defined to execute this function for each row deleted from the employees table, ensuring that the job history records associated with the deleted employee and older than one year are removed from the job_history table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_old_job_history() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM job_history WHERE \"EMPLOYEE_ID\" = OLD.\"EMPLOYEE_ID\" AND \"END_DATE\" < CURRENT_DATE - make_interval(years := 1);\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_old_job_history\nAFTER DELETE ON employees\nFOR EACH ROW EXECUTE FUNCTION trg_delete_old_job_history();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "DELETE FROM employees WHERE EMPLOYEE_ID = 100;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 101;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 102;"
    ],
    "summary": "Create a PLpgSQL trigger function named trg_delete_old_job_history that executes AFTER DELETE on the employees table for each row. It deletes rows from the job_history table where EMPLOYEE_ID equals the OLD.EMPLOYEE_ID and END_DATE is older than one year from the current date. The function returns the OLD record.",
    "natural_language": "Create trigger trg_delete_old_job_history. After deleting an employee, remove their job history older than one year.",
    "id": 105
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_customer_events_insert that returns a trigger, which is executed as a BEFORE INSERT trigger on the \"Customer_Events\" table for each individual new row being inserted, where the function's logic is to simply return the NEW row record without performing any modifications, validations, or additional data operations, thereby allowing the insert operation to proceed normally with the original row data.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_customer_events_insert() RETURNS TRIGGER AS $$\nBEGIN\n    -- No need to insert into the same table; just return the new row\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER customer_events_insert_trigger\nBEFORE INSERT ON \"Customer_Events\"\nFOR EACH ROW EXECUTE FUNCTION trg_customer_events_insert();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (1, 101, '2023-01-01 10:00:00+00:00', 1001, 201, 301);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (2, 102, '2023-02-15 11:30:00+00:00', 1002, 202, 302);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (3, 103, '2023-03-20 14:00:00+00:00', 1003, 203, 303);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (4, 104, '2023-04-10 09:45:00+00:00', 1004, 204, 304);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (5, 105, '2023-05-05 16:15:00+00:00', 1005, 205, 305);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named trg_customer_events_insert on the Customer_Events table that returns the NEW row without modification.",
    "natural_language": "Hey, can you set up a trigger for me? Before any new entry gets added to the Customer_Events table, I need a trigger function called trg_customer_events_insert. It should just hand back the new row exactly as it is, no changes.",
    "id": 106
  },
  {
    "ir": "Write a PLpgSQL function named delete_related_coasters that is designed to be used as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to execute after a row is deleted from the country table. The function performs a DELETE operation on the roller_coaster table, specifically targeting rows where the Country_ID column matches the Country_ID of the deleted row from the country table, referred to as OLD.Country_ID. Additionally, the function applies a condition to the deletion process: it only deletes rows where the Name column's length is an even number, determined by the MOD function with a divisor of 2. The function returns the OLD record, which is the row that was deleted from the country table, allowing for further processing or logging if needed. The function is written in the PLpgSQL language. A trigger named cleanup_coasters_trigger is created to automatically invoke this function after a row is deleted from the country table. The trigger is defined to execute for each row that is deleted, ensuring that the function is called individually for each deletion event, thereby maintaining the integrity of the roller_coaster table by removing related entries based on the specified conditions.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_coasters() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"roller_coaster\" WHERE \"Country_ID\" = OLD.\"Country_ID\" AND MOD(LENGTH(\"Name\"), 2) = 0;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cleanup_coasters_trigger\nAFTER DELETE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION delete_related_coasters();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 1;",
      "DELETE FROM \"country\" WHERE \"Name\" = 'Finland';",
      "DELETE FROM \"country\" WHERE \"Population\" < 9000000;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" IN (2, 3);",
      "DELETE FROM \"country\" WHERE \"Area\" > 400000;"
    ],
    "summary": "Create an AFTER DELETE trigger function named delete_related_coasters on the country table. It deletes rows from the roller_coaster table where Country_ID matches OLD.Country_ID and the length of the Name is even. The function returns the OLD row.",
    "natural_language": "Define an AFTER DELETE trigger function called delete_related_coasters for the country table. This function must delete any rows in the roller_coaster table where the Country_ID equals the OLD.Country_ID and the length of the Name is an even number. Ensure the function returns the OLD row.",
    "id": 107
  },
  {
    "ir": "Write a PLpgSQL function named `adjust_coaster_length` that is designed to be executed as a trigger. This function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records when invoked by a trigger. The function's primary operation is to perform an `UPDATE` statement on the `\"roller_coaster\"` table. Specifically, it modifies the `\"Length\"` column of records in `\"roller_coaster\"`. The new value for `\"Length\"` is calculated by multiplying the existing `\"Length\"` value by `1.1`. This update is applied only to those rows in the `\"roller_coaster\"` table where two conditions are met: first, the `\"Country_ID\"` column in the `\"roller_coaster\"` table must be equal to the `\"Country_ID\"` value from the `NEW` record (which represents the new state of the row that activated the trigger); and second, the absolute difference between the `\"Height\"` column in the `\"roller_coaster\"` table and the constant value `100` must be greater than `20`. After executing the `UPDATE` statement, the function returns the `NEW` record, indicating that the row that activated the trigger should proceed with its intended modification.\n\nAdditionally, there is a trigger named `length_adjustment_trigger` defined. This trigger is configured to activate `AFTER` an `UPDATE` operation on the `\"Population\"` column of the `\"country\"` table. The trigger is set to execute `FOR EACH ROW` that is affected by such an update. When activated, this trigger `EXECUTE`s the `adjust_coaster_length()` function. This means that whenever the `\"Population\"` column of any row in the `\"country\"` table is updated, the `adjust_coaster_length` function will be called, and it will attempt to update the `\"Length\"` of roller coasters based on the `Country_ID` of the updated country and specific height criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_coaster_length() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"roller_coaster\" SET \"Length\" = \"Length\" * 1.1 WHERE \"Country_ID\" = NEW.\"Country_ID\" AND ABS(\"Height\" - 100) > 20;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER length_adjustment_trigger\nAFTER UPDATE OF \"Population\" ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION adjust_coaster_length();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE \"country\" SET \"Population\" = 8206525 WHERE \"Country_ID\" = 1;",
      "UPDATE \"country\" SET \"Population\" = 5261009 WHERE \"Country_ID\" = 2;",
      "UPDATE \"country\" SET \"Population\" = 9047753 WHERE \"Country_ID\" = 3;",
      "UPDATE \"country\" SET \"Population\" = 8206526 WHERE \"Country_ID\" = 1;",
      "UPDATE \"country\" SET \"Population\" = 5261010 WHERE \"Country_ID\" = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named adjust_coaster_length on the country table when the Population column is updated. It updates the roller_coaster table, setting Length = Length * 1.1 where Country_ID matches NEW.Country_ID and the absolute difference between Height and 100 is greater than 20. The function returns the NEW row.",
    "natural_language": "Construct an AFTER UPDATE trigger function, meticulously named adjust_coaster_length, to be associated with the country table specifically upon any modification to its Population column. This comprehensive function must proceed to update the roller_coaster table by increasing the Length value by a factor of 1.1, but only for those roller coaster records whose Country_ID corresponds precisely to the NEW.Country_ID and, furthermore, whose Height differs from 100 by an absolute margin exceeding 20. The function is then designed to dutifully return the NEW row.",
    "id": 108
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `insert_coaster_for_country` that is designed to be executed by a trigger. This function does not accept any explicit parameters but operates within the context of a trigger, meaning it has access to `NEW` and `OLD` records. The function returns a `TRIGGER` type, which is standard for PostgreSQL trigger functions. The core operation of this function is to insert a new record into the `\"roller_coaster\"` table. The values for the columns in the `\"roller_coaster\"` table are determined as follows:\n- For the `\"Roller_Coaster_ID\"` column, the function calculates the next available ID by first selecting the maximum value of `\"Roller_Coaster_ID\"` from the `\"roller_coaster\"` table. It then uses the `COALESCE` function to handle cases where no records exist (returning `0` if `MAX` returns `NULL`), and finally adds `1` to this result.\n- For the `\"Name\"` column, the function constructs a string by taking the first 5 characters of the `Name` column from the `NEW` record (the record that caused the trigger to fire) using the `SUBSTR` function, and then concatenates this substring with the literal string ' Coaster'.\n- For the `\"Park\"` column, the literal string 'New Park' is used.\n- For the `\"Country_ID\"` column, the value is taken directly from the `Country_ID` column of the `NEW` record.\n- For the `\"Length\"` column, the literal numeric value `1000.0` is used.\n- For the `\"Height\"` column, the literal numeric value `50.0` is used.\n- For the `\"Speed\"` column, the literal string '40' is used.\n- For the `\"Opened\"` column, the literal date string '2024-01-01' is used.\n- For the `\"Status\"` column, the literal string 'Planned' is used.\nAfter performing the insert operation, the function returns `NEW`, which is required for `AFTER` row-level triggers in PostgreSQL.\n\nA trigger named `coaster_creation_trigger` is defined to execute the `insert_coaster_for_country()` function. This trigger is set to activate `AFTER INSERT` operations on the `\"country\"` table. It is a `FOR EACH ROW` trigger, meaning the `insert_coaster_for_country()` function will be executed once for every row that is inserted into the `\"country\"` table. The `EXECUTE FUNCTION insert_coaster_for_country()` clause specifies that the previously defined function should be called when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_coaster_for_country() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"roller_coaster\" (\"Roller_Coaster_ID\", \"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES ((SELECT COALESCE(MAX(\"Roller_Coaster_ID\"), 0) + 1 FROM \"roller_coaster\"), SUBSTR(NEW.\"Name\", 1, 5) || ' Coaster', 'New Park', NEW.\"Country_ID\", 1000.0, 50.0, '40', '2024-01-01', 'Planned');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER coaster_creation_trigger\nAFTER INSERT ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION insert_coaster_for_country();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "INSERT INTO \"country\" (\"Country_ID\", \"Name\", \"Population\", \"Area\", \"Languages\") VALUES (4, 'Norway', 5425270, 385207, 'Norwegian');",
      "INSERT INTO \"country\" (\"Country_ID\", \"Name\", \"Population\", \"Area\", \"Languages\") VALUES (5, 'Denmark', 5854240, 42931, 'Danish');",
      "INSERT INTO \"country\" (\"Country_ID\", \"Name\", \"Population\", \"Area\", \"Languages\") VALUES (6, 'Germany', 83149300, 357022, 'German');",
      "INSERT INTO \"country\" (\"Country_ID\", \"Name\", \"Population\", \"Area\", \"Languages\") VALUES (7, 'Netherlands', 17441139, 41850, 'Dutch');",
      "INSERT INTO \"country\" (\"Country_ID\", \"Name\", \"Population\", \"Area\", \"Languages\") VALUES (8, 'Belgium', 11555997, 30528, 'Dutch French German');"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_coaster_for_country on the country table. It inserts a new row into the roller_coaster table. The Roller_Coaster_ID is the maximum existing ID plus one, the Name is the first 5 characters of the new country's name concatenated with ' Coaster', Park is 'New Park', Country_ID is from the new country, Length is 1000.0, Height is 50.0, Speed is '40', Opened is '2024-01-01', and Status is 'Planned'. The function returns the NEW row.",
    "natural_language": "Please construct an AFTER INSERT trigger function designated as 'insert_coaster_for_country' on the country table. This function shall insert a new record into the roller_coaster table. The Roller_Coaster_ID value is to be derived by incrementing the current maximum ID by one. The Name column should be populated with the first five characters of the newly inserted country's name, concatenated with the string ' Coaster'. The Park value is to be set as 'New Park', while the Country_ID is sourced from the new country entry. The Length and Height values are to be 1000.0 and 50.0, respectively. The Speed is specified as '40', the Opened date as '2024-01-01', and the Status as 'Planned'. The function must be defined to return the NEW row.",
    "id": 109
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_country_area that returns a trigger and is executed by a trigger named area_update_trigger, which fires after an update operation on the Status column of the roller_coaster table for each modified row; the function's logic is to update the Area column in the country table by adding a calculated value, specifically for the row in the country table where the Country_ID matches the NEW.Country_ID value from the updated roller_coaster row; the value added to the Area is determined by executing a subquery that counts all rows in the roller_coaster table where the Country_ID equals the NEW.Country_ID and the length of the Name column is greater than 10, then multiplies this count by 100; after performing this update, the function returns the NEW row record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_country_area() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"country\" SET \"Area\" = \"Area\" + (SELECT COUNT(*) * 100 FROM \"roller_coaster\" WHERE \"Country_ID\" = NEW.\"Country_ID\" AND LENGTH(\"Name\") > 10) WHERE \"Country_ID\" = NEW.\"Country_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER area_update_trigger\nAFTER UPDATE OF \"Status\" ON \"roller_coaster\"\nFOR EACH ROW EXECUTE FUNCTION update_country_area();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE \"roller_coaster\" SET \"Status\" = 'Operating' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE \"roller_coaster\" SET \"Status\" = 'Closed' WHERE \"Country_ID\" = 2 AND \"Name\" = 'Dauling Dragon';",
      "UPDATE \"roller_coaster\" SET \"Status\" = 'Under Construction' WHERE LENGTH(\"Name\") > 10;",
      "UPDATE \"roller_coaster\" SET \"Status\" = 'Operating' WHERE \"Country_ID\" = 3;",
      "UPDATE \"roller_coaster\" SET \"Status\" = 'Temporarily Closed', \"Park\" = 'New Park' WHERE \"Roller_Coaster_ID\" = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_country_area on the roller_coaster table when the Status column is updated. It updates the country table, adding to the Area column a value equal to (the count of rows in roller_coaster where Country_ID matches NEW.Country_ID and the length of Name > 10) multiplied by 100. The update applies where the country's Country_ID matches NEW.Country_ID. The function returns the NEW row.",
    "natural_language": "Construct an AFTER UPDATE trigger function, which should be named update_country_area, to be activated on the roller_coaster table specifically when an update occurs to its Status column. This detailed function will subsequently update the country table by incrementing its Area column with a calculated value. This value is derived by first counting all rows within the roller_coaster table where the Country_ID matches the NEW.Country_ID and, with an additional condition, where the length of the Name field exceeds ten characters; this count is then carefully multiplied by one hundred. The update to the country table is precisely applied only to the record where the country's Country_ID matches the NEW.Country_ID. Finally, the function is designed to return the complete NEW row.",
    "id": 110
  },
  {
    "ir": "Write a PLpgSQL trigger function named `update_warehouse_capacity_on_delete` that is designed to be executed in response to data manipulation events, and a trigger named `trg_boxes_delete` that invokes this function. The `update_warehouse_capacity_on_delete` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. When this function is executed, it performs a single `UPDATE` operation on the `\"Warehouses\"` table. Specifically, it modifies the `\"Capacity\"` column of a row in the `\"Warehouses\"` table. The new value for `\"Capacity\"` is calculated by taking the current value of `\"Capacity\"` for that row and incrementing it by `1`. This update is conditional, applying only to the row where the `\"Code\"` column matches the value of `OLD.\"Warehouse\"`. The `OLD` keyword refers to the row that was deleted from the table that activated the trigger. Therefore, `OLD.\"Warehouse\"` represents the value of the `\"Warehouse\"` column from the row that was just deleted from the `\"Boxes\"` table. After performing this update, the function returns `OLD`, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the original deleted row data is returned. The `trg_boxes_delete` trigger is defined to activate `AFTER DELETE` operations on the `\"Boxes\"` table. It is a `FOR EACH ROW` trigger, meaning that the `update_warehouse_capacity_on_delete` function will be executed once for each individual row that is deleted from the `\"Boxes\"` table. The `EXECUTE FUNCTION update_warehouse_capacity_on_delete()` clause specifies that the `update_warehouse_capacity_on_delete` function should be called when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION update_warehouse_capacity_on_delete() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + 1 WHERE \"Code\" = OLD.\"Warehouse\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_delete\nAFTER DELETE ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION update_warehouse_capacity_on_delete();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "DELETE FROM \"Boxes\" WHERE \"Code\" = '0MN7';",
      "DELETE FROM \"Boxes\" WHERE \"Warehouse\" = 3;",
      "DELETE FROM \"Boxes\" WHERE \"Contents\" = 'Rocks';",
      "DELETE FROM \"Boxes\" WHERE \"Value\" > 200;",
      "DELETE FROM \"Boxes\";"
    ],
    "summary": "Create a trigger function named `update_warehouse_capacity_on_delete` that, after a row is deleted from the \"Boxes\" table, updates the \"Warehouses\" table. It increases the \"Capacity\" by 1 for the warehouse whose \"Code\" matches the OLD.\"Warehouse\" value. Also, create an AFTER DELETE FOR EACH ROW trigger named `trg_boxes_delete` on the \"Boxes\" table to execute this function.",
    "natural_language": "Please construct a trigger function designated as `update_warehouse_capacity_on_delete`. This function shall be invoked subsequent to the deletion of a record from the \"Boxes\" table. Its purpose is to modify the \"Warehouses\" table by incrementing the \"Capacity\" value by one for the specific warehouse whose \"Code\" corresponds to the OLD.\"Warehouse\" value. Furthermore, establish an AFTER DELETE FOR EACH ROW trigger, named `trg_boxes_delete`, on the \"Boxes\" table to call the aforementioned function.",
    "id": 111
  },
  {
    "ir": "Write a PLpgSQL trigger function that adjusts the capacity of a warehouse based on operations performed on the Boxes table. The function, named adjust_warehouse_capacity, is designed to be executed as a trigger and returns a trigger type. It operates in response to two types of row-level events: INSERT and DELETE. When a new row is inserted into the Boxes table, the function checks if the trigger operation (TG_OP) is 'INSERT'. If true, it updates the Warehouses table by decreasing the Capacity column by 1 for the warehouse identified by the Code column that matches the NEW.Warehouse value from the inserted row. Conversely, when a row is deleted from the Boxes table, the function checks if the trigger operation is 'DELETE'. If true, it updates the Warehouses table by increasing the Capacity column by 1 for the warehouse identified by the Code column that matches the OLD.Warehouse value from the deleted row. The function returns either the NEW or OLD row, depending on the operation, using the COALESCE function to ensure a valid return value. The trigger named trg_boxes_modify is created to execute this function after an INSERT or DELETE operation on the Boxes table for each affected row, ensuring the warehouse capacity is adjusted accordingly.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_warehouse_capacity() RETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" - 1 WHERE \"Code\" = NEW.\"Warehouse\";\n    ELSIF TG_OP = 'DELETE' THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + 1 WHERE \"Code\" = OLD.\"Warehouse\";\n    END IF;\n    RETURN COALESCE(NEW, OLD);\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_modify\nAFTER INSERT OR DELETE ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION adjust_warehouse_capacity();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('TEST1', 'Books', 50.0, 1);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('TEST2', 'Electronics', 300.0, 3);",
      "DELETE FROM \"Boxes\" WHERE \"Code\" = '0MN7';",
      "DELETE FROM \"Boxes\" WHERE \"Warehouse\" = 4;",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('TEST3', 'Clothing', 75.0, 2);"
    ],
    "summary": "Create a trigger function named `adjust_warehouse_capacity` that handles both INSERT and DELETE events on the \"Boxes\" table. For an INSERT, decrease the \"Capacity\" by 1 in the \"Warehouses\" table for the warehouse with \"Code\" equal to NEW.\"Warehouse\". For a DELETE, increase the \"Capacity\" by 1 for the warehouse with \"Code\" equal to OLD.\"Warehouse\". Then, create an AFTER INSERT OR DELETE FOR EACH ROW trigger named `trg_boxes_modify` on the \"Boxes\" table to execute this function.",
    "natural_language": "Construct a trigger function, which should be named `adjust_warehouse_capacity`, to meticulously manage both INSERT and DELETE operations occurring on the \"Boxes\" table. In the detailed case of an INSERT event, you must carefully decrease the \"Capacity\" value by precisely one unit within the \"Warehouses\" table, specifically for the warehouse whose \"Code\" matches the NEW.\"Warehouse\" reference. Conversely, for a DELETE event, you are required to thoughtfully increase the \"Capacity\" value by exactly one unit for the warehouse whose \"Code\" corresponds to the OLD.\"Warehouse\" reference. Subsequently, you should create an AFTER INSERT OR DELETE FOR EACH ROW trigger, named `trg_boxes_modify`, on the \"Boxes\" table to reliably execute this comprehensive function.",
    "id": 112
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `validate_warehouse_exists` that is designed to be executed as a trigger, and a trigger named `trg_boxes_before_insert_validate` that invokes this function. The `validate_warehouse_exists` function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` which represents the new row being inserted or updated. The purpose of this function is to validate the existence of a warehouse referenced by a new row in the `\"Boxes\"` table. Specifically, when a new row is about to be inserted into the `\"Boxes\"` table, the trigger `trg_boxes_before_insert_validate` fires *before* the insertion occurs, for *each row* being inserted. The trigger then executes the `validate_warehouse_exists` function. Inside the function, a `SELECT` statement is performed to check for the existence of a record in the `\"Warehouses\"` table. This `SELECT` statement attempts to retrieve the literal value `1` from the `\"Warehouses\"` table. The condition for this `SELECT` statement is `WHERE \"Code\" = NEW.\"Warehouse\"`. This means it looks for a row in the `\"Warehouses\"` table where the value in its `\"Code\"` column exactly matches the value in the `\"Warehouse\"` column of the `NEW` row (the row currently being inserted into `\"Boxes\"`). If the `SELECT` statement returns no rows (i.e., `NOT EXISTS` is true), indicating that no warehouse with the specified code exists in the `\"Warehouses\"` table, then the function raises an exception with the message 'Warehouse does not exist'. This action prevents the `INSERT` operation on the `\"Boxes\"` table from completing. If, however, the `SELECT` statement finds at least one row (i.e., `NOT EXISTS` is false), meaning a warehouse with the specified code does exist, then the function proceeds without raising an exception and returns `NEW`. Returning `NEW` allows the `INSERT` operation on the `\"Boxes\"` table to continue with the row as it was provided.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_warehouse_exists() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Warehouses\" WHERE \"Code\" = NEW.\"Warehouse\") THEN\n        RAISE EXCEPTION 'Warehouse does not exist';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_before_insert_validate\nBEFORE INSERT ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION validate_warehouse_exists();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('0MN7', 'Rocks', 180.0, 1);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('4H8P', 'Scissors', 250.0, 2);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('4RT3', 'Rocks', 190.0, 3);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('5XY9', 'Paper', 200.0, 3);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('6AB2', 'Sand', 220.0, 1);"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger function named `validate_warehouse_exists` on the \"Boxes\" table. The function must check if a warehouse with a \"Code\" equal to NEW.\"Warehouse\" exists in the \"Warehouses\" table. If it does not exist, raise an exception with the message 'Warehouse does not exist'. If it exists, return NEW. Also, create a trigger named `trg_boxes_before_insert_validate` to execute this function.",
    "natural_language": "How can I create a BEFORE INSERT FOR EACH ROW trigger function called `validate_warehouse_exists` for the \"Boxes\" table that verifies the existence of a warehouse with a matching \"Code\" in the \"Warehouses\" table, raises an exception if it doesn't exist, and then create a trigger named `trg_boxes_before_insert_validate` to run this function?",
    "id": 113
  },
  {
    "ir": "Write a PostgreSQL trigger function named maintain_warehouse_stats that is executed automatically by a trigger named trg_boxes_maintain_stats, where the trigger is defined to fire after every insert operation on the Boxes table for each new row added, and the function performs an update on the Warehouses table, specifically modifying the Location column by concatenating its existing value with a fixed string literal ' (Updated: ' followed by the current date and time obtained via the CURRENT_TIMESTAMP function call and a closing parenthesis ')', but only for the single row in the Warehouses table where the Code column value exactly matches the value of the Warehouse column from the newly inserted row in the Boxes table (accessible via the NEW record variable), and the function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION maintain_warehouse_stats() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Warehouses\" SET \"Location\" = \"Location\" || ' (Updated: ' || CURRENT_TIMESTAMP || ')' WHERE \"Code\" = NEW.\"Warehouse\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_maintain_stats\nAFTER INSERT ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION maintain_warehouse_stats();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ1', 'Books', 150.0, 1);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ2', 'Electronics', 500.0, 2);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ3', 'Clothes', 75.0, 3);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ4', 'Tools', 200.0, 1);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ5', 'Toys', 120.0, 4);"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named `maintain_warehouse_stats` on the \"Boxes\" table. The function must update the \"Warehouses\" table by appending the string ' (Updated: ' followed by the CURRENT_TIMESTAMP and a closing ')' to the \"Location\" column for the warehouse where \"Code\" equals NEW.\"Warehouse\". Then, create a trigger named `trg_boxes_maintain_stats` to execute this function.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger function designated as `maintain_warehouse_stats` for the \"Boxes\" table. This function shall modify the \"Warehouses\" table by concatenating the string ' (Updated: ' with the CURRENT_TIMESTAMP and a closing parenthesis ')' to the existing value in the \"Location\" column. This update is to be applied specifically to the warehouse record whose \"Code\" matches the NEW.\"Warehouse\" value. Subsequently, establish a trigger named `trg_boxes_maintain_stats` to invoke the aforementioned function.",
    "id": 114
  },
  {
    "ir": "Write a PLpgSQL function that is triggered before a row is deleted from the \"Products\" table, which first deletes all records from the \"Order_Items\" table where the product_id column matches the product_id of the row being deleted from the \"Products\" table, and then allows the deletion of the original row from the \"Products\" table to proceed by returning the OLD record.",
    "plsql": "CREATE OR REPLACE FUNCTION monitor_product_updates() RETURNS TRIGGER AS $$\nBEGIN\n  -- First, delete all related records in Order_Items\n  DELETE FROM \"Order_Items\"\n  WHERE product_id = OLD.product_id;\n\n  -- Then, allow the original DELETE on Products to proceed\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_monitor_product_updates\nBEFORE DELETE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION monitor_product_updates();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "DELETE FROM \"Products\" WHERE product_id = 1;",
      "DELETE FROM \"Products\" WHERE product_id = 2;",
      "DELETE FROM \"Products\" WHERE product_id = 3;",
      "DELETE FROM \"Products\" WHERE product_id = 13;",
      "DELETE FROM \"Products\" WHERE product_id = 10;"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger function on the \"Products\" table. The function must first delete all rows from the \"Order_Items\" table where the product_id matches the OLD.product_id from the \"Products\" table. Then, return OLD to allow the original product deletion to proceed.",
    "natural_language": "Set up a trigger on the Products table that runs before any row is removed. It should handle cleaning up related order items for that product, then let the deletion go through.",
    "id": 115
  },
  {
    "ir": "Write a PLpgSQL function that updates the age of a dog in the \"Dogs\" table by calculating the difference in years between the dog's date of arrival and date of birth, using the EXTRACT function to determine the year component from the AGE function, and sets this calculated age in the \"age\" column for the row where the \"dog_id\" matches the \"dog_id\" of the newly inserted row. This function is triggered by an AFTER INSERT operation on the \"Dogs\" table, ensuring that each time a new row is inserted into the \"Dogs\" table, the function is executed for that specific row, updating the age based on the newly inserted data. The trigger is named trg_dog_age_arrival and is defined to execute the update_dog_age_on_arrival function for each new row inserted into the \"Dogs\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_dog_age_on_arrival() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Dogs\" SET \"age\" = EXTRACT(YEAR FROM AGE(NEW.\"date_arrived\", NEW.\"date_of_birth\")) WHERE \"dog_id\" = NEW.\"dog_id\";\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_dog_age_arrival\nAFTER INSERT ON \"Dogs\"\nFOR EACH ROW EXECUTE FUNCTION update_dog_age_on_arrival();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1001, 5, '0', 'HUS', 'MED', 'Buddy', NULL, '2020-05-15 10:00:00+08:00', '1', '12.5', '2024-03-20 14:30:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1002, 8, '1', 'BUL', 'SML', 'Daisy', NULL, '2019-11-03 08:15:00+08:00', '0', '8.2', '2024-03-21 09:45:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1003, 12, '0', 'ESK', 'LGE', 'Max', NULL, '2018-07-22 16:20:00+08:00', '1', '18.7', '2024-03-22 11:20:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1004, 3, '0', 'HUS', 'MED', 'Luna', NULL, '2021-02-28 12:10:00+08:00', '0', '11.8', '2024-03-23 13:15:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1005, 1, '1', 'BUL', 'SML', 'Rocky', NULL, '2017-12-10 09:45:00+08:00', '1', '9.5', '2024-03-24 10:00:00+08:00');"
    ],
    "summary": "Create an AFTER INSERT trigger function for the \"Dogs\" table. The function calculates a dog's age by extracting the year difference between its arrival date and birth date, then updates the \"age\" column for the matching dog_id.",
    "natural_language": "Create AFTER INSERT trigger for Dogs. It computes age from arrival and birth years, updating the age column for that dog.",
    "id": 116
  },
  {
    "ir": "Write a PostgreSQL trigger function named set_departure_date_on_adoption that returns a trigger, which is then bound to the table \"Dogs\" via a trigger named trg_departure_on_adoption, where the trigger is configured to fire automatically after any update operation that modifies the specific column date_adopted within the \"Dogs\" table, executing the function once for each row that is updated, and within the function body, for each invocation, it performs an update on the \"Dogs\" table, setting the column date_departed to the value returned by the function CURRENT_TIMESTAMP, which provides the current date and time, but only for the specific row where the column dog_id matches the value of the NEW record's dog_id column, which is the updated row's dog_id value, and additionally only if the condition that the NEW record's date_adopted column is not NULL is satisfied, ensuring the update occurs solely when the date_adopted field has been set to a non-null value, and finally the function returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION set_departure_date_on_adoption() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Dogs\" SET date_departed = CURRENT_TIMESTAMP WHERE dog_id = NEW.dog_id AND date_adopted IS NOT NULL;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_departure_on_adoption\nAFTER UPDATE OF date_adopted ON \"Dogs\"\nFOR EACH ROW EXECUTE FUNCTION set_departure_date_on_adoption();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "UPDATE \"Dogs\" SET date_adopted = CURRENT_TIMESTAMP WHERE dog_id = 1;",
      "UPDATE \"Dogs\" SET date_adopted = '2023-01-15 10:00:00' WHERE dog_id = 2;",
      "UPDATE \"Dogs\" SET date_adopted = NOW() WHERE dog_id = 3;",
      "UPDATE \"Dogs\" SET date_adopted = '2024-05-20 14:30:00' WHERE dog_id = 4;",
      "UPDATE \"Dogs\" SET date_adopted = CURRENT_TIMESTAMP WHERE dog_id = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger function for the \"Dogs\" table. When the \"date_adopted\" column is updated to a non-NULL value, the function sets the \"date_departed\" column to the current timestamp for that specific dog_id.",
    "natural_language": "Set up a trigger that runs after updates on the Dogs table. Basically, if the date_adopted field gets changed to some value that isn't empty, then you should also update the date_departed to be around now for that particular dog entry.",
    "id": 117
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_job_history_on_department_change that returns a trigger and is executed by a trigger named trg_update_job_history_on_department_change, which is defined to fire BEFORE an UPDATE operation on the DEPARTMENT_ID column of the employees table for each affected row; the function's logic is to insert a new record into the job_history table, populating its columns with specific values: the EMPLOYEE_ID column receives the old EMPLOYEE_ID value from the employees row, the START_DATE column receives the old HIRE_DATE value from the employees row, the END_DATE column receives the result of the CURRENT_DATE function call which provides the current date, the JOB_ID column receives the old JOB_ID value from the employees row, and the DEPARTMENT_ID column receives the old DEPARTMENT_ID value from the employees row; after performing this insert, the function returns the NEW row record to the triggering UPDATE statement.",
    "plsql": "CREATE OR REPLACE FUNCTION update_job_history_on_department_change() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO job_history (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\") \n  VALUES (OLD.\"EMPLOYEE_ID\", OLD.\"HIRE_DATE\", CURRENT_DATE, OLD.\"JOB_ID\", OLD.\"DEPARTMENT_ID\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_job_history_on_department_change\nBEFORE UPDATE OF \"DEPARTMENT_ID\" ON employees\nFOR EACH ROW EXECUTE FUNCTION update_job_history_on_department_change();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history",
      "locations"
    ],
    "call_sqls": [
      "UPDATE employees SET DEPARTMENT_ID = 20 WHERE EMPLOYEE_ID = 100;",
      "UPDATE employees SET DEPARTMENT_ID = 30 WHERE EMPLOYEE_ID = 101;",
      "UPDATE employees SET DEPARTMENT_ID = 40 WHERE EMPLOYEE_ID = 102;",
      "UPDATE employees SET DEPARTMENT_ID = 50 WHERE EMPLOYEE_ID = 103;",
      "UPDATE employees SET DEPARTMENT_ID = 60 WHERE EMPLOYEE_ID = 104;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function for the \"employees\" table. When the \"DEPARTMENT_ID\" column is updated, the function inserts a record into the \"job_history\" table containing the old employee details (EMPLOYEE_ID, HIRE_DATE as START_DATE, JOB_ID, DEPARTMENT_ID) and the current date as END_DATE.",
    "natural_language": "Write a BEFORE UPDATE trigger function for the \"employees\" table that, upon updating the \"DEPARTMENT_ID\" column, inserts a record into the \"job_history\" table with the old employee details (EMPLOYEE_ID, HIRE_DATE as START_DATE, JOB_ID, DEPARTMENT_ID) and sets the END_DATE to the current date.",
    "id": 118
  },
  {
    "ir": "Write a PostgreSQL trigger function named maintain_department_manager that is executed by a trigger named trg_maintain_department_manager, which is defined to fire BEFORE an UPDATE operation on the MANAGER_ID column of the departments table for each affected row, and within this function, if the new MANAGER_ID value in the departments row is not NULL and there does not exist a record in the employees table where the EMPLOYEE_ID equals the new MANAGER_ID and that employee's DEPARTMENT_ID equals the new DEPARTMENT_ID from the departments row, then perform an UPDATE on the employees table, setting the DEPARTMENT_ID column to the new DEPARTMENT_ID value for the specific employee whose EMPLOYEE_ID matches the new MANAGER_ID, and finally, the function returns the NEW row record to the trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION maintain_department_manager() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"MANAGER_ID\" IS NOT NULL AND NOT EXISTS (SELECT 1 FROM employees WHERE \"EMPLOYEE_ID\" = NEW.\"MANAGER_ID\" AND \"DEPARTMENT_ID\" = NEW.\"DEPARTMENT_ID\") THEN\n    UPDATE employees SET \"DEPARTMENT_ID\" = NEW.\"DEPARTMENT_ID\" WHERE \"EMPLOYEE_ID\" = NEW.\"MANAGER_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_maintain_department_manager\nBEFORE UPDATE OF \"MANAGER_ID\" ON departments\nFOR EACH ROW EXECUTE FUNCTION maintain_department_manager();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history",
      "locations"
    ],
    "call_sqls": [
      "UPDATE departments SET \"MANAGER_ID\" = 100 WHERE \"DEPARTMENT_ID\" = 10;",
      "UPDATE departments SET \"MANAGER_ID\" = 101 WHERE \"DEPARTMENT_ID\" = 20;",
      "UPDATE departments SET \"MANAGER_ID\" = 102 WHERE \"DEPARTMENT_ID\" = 30;",
      "UPDATE departments SET \"MANAGER_ID\" = 200 WHERE \"DEPARTMENT_ID\" = 10;",
      "UPDATE departments SET \"MANAGER_ID\" = 201 WHERE \"DEPARTMENT_ID\" = 20;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function for the \"departments\" table. When the \"MANAGER_ID\" is updated to a non-NULL value, if the new manager is not already in the new department, the function updates that employee's \"DEPARTMENT_ID\" to match the new department.",
    "natural_language": "Construct a BEFORE UPDATE trigger function for the 'departments' table. The function's logic must be as follows: upon an update to the 'MANAGER_ID' field with a non-NULL value, if the newly assigned manager is not presently a member of the updated department, the function shall automatically modify that employee's 'DEPARTMENT_ID' to correspond with the new department.",
    "id": 119
  },
  {
    "ir": "Write a PostgreSQL database schema definition that first creates a table named \"Collections\" if it does not already exist. This \"Collections\" table is designed to store information about various collections and includes four columns: \"Collection_ID\" of type bigint, which serves as the primary key for uniquely identifying each collection; \"Parent_Collection_ID\" of type bigint, which can be used to establish hierarchical relationships between collections by referencing another collection's ID; \"Collection_Name\" of type text, intended to store the name of the collection; and \"Collection_Description\" of type text, for holding a detailed description of the collection. Following this, the schema creates another table named \"Collection_Logs\" if it does not already exist. This \"Collection_Logs\" table is designed to record log entries related to collection activities and includes four columns: \"Log_ID\" of type bigserial, which serves as the primary key and automatically generates unique, sequential numbers for each log entry; \"Collection_ID\" of type bigint, which links a log entry to a specific collection; \"Log_Message\" of type text, for storing the descriptive message of the log entry; and \"Log_Timestamp\" of type timestamp, which records the exact date and time when the log entry was created, defaulting to the current timestamp if no value is explicitly provided. After defining these tables, the schema then creates or replaces a PL/pgSQL function named \"trg_log_collection_update\" that returns a TRIGGER. This function's purpose is to insert a new record into the \"Collection_Logs\" table. Specifically, it inserts the value of the \"Collection_ID\" from the newly updated row (referred to as NEW.\"Collection_ID\") into the \"Collection_ID\" column of \"Collection_Logs\", inserts the static text string 'Collection updated' into the \"Log_Message\" column of \"Collection_Logs\", and inserts the current timestamp (obtained using CURRENT_TIMESTAMP) into the \"Log_Timestamp\" column of \"Collection_Logs\". After performing this insertion, the function returns the NEW row, which is standard behavior for an AFTER trigger. Finally, the schema creates a trigger named \"log_collection_update\". This trigger is configured to execute AFTER any UPDATE operation on the \"Collections\" table. It is set to fire FOR EACH ROW that is updated, and for each such row, it executes the previously defined \"trg_log_collection_update\" function.",
    "plsql": "CREATE TABLE IF NOT EXISTS \"Collections\" (\n    \"Collection_ID\" bigint PRIMARY KEY,\n    \"Parent_Collection_ID\" bigint,\n    \"Collection_Name\" text,\n    \"Collection_Description\" text\n);\n\nCREATE TABLE IF NOT EXISTS \"Collection_Logs\" (\n    \"Log_ID\" bigserial PRIMARY KEY,\n    \"Collection_ID\" bigint,\n    \"Log_Message\" text,\n    \"Log_Timestamp\" timestamp DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE OR REPLACE FUNCTION trg_log_collection_update() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Collection_Logs\" (\"Collection_ID\", \"Log_Message\", \"Log_Timestamp\") \n    VALUES (NEW.\"Collection_ID\", 'Collection updated', CURRENT_TIMESTAMP);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_collection_update\nAFTER UPDATE ON \"Collections\"\nFOR EACH ROW EXECUTE FUNCTION trg_log_collection_update();",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collection_Subset_Members",
      "Collection_Subsets",
      "Collections"
    ],
    "call_sqls": [
      "UPDATE \"Collections\" SET \"Collection_Name\" = 'Updated Best' WHERE \"Collection_ID\" = 6;",
      "UPDATE \"Collections\" SET \"Collection_Description\" = 'Updated description' WHERE \"Collection_ID\" = 7;",
      "UPDATE \"Collections\" SET \"Collection_Name\" = 'Updated Nice' WHERE \"Collection_ID\" = 7;",
      "UPDATE \"Collections\" SET \"Parent_Collection_ID\" = 7 WHERE \"Collection_ID\" = 6;",
      "UPDATE \"Collections\" SET \"Collection_Description\" = 'Another update' WHERE \"Collection_ID\" = 6;"
    ],
    "summary": "Create a schema with two tables: \"Collections\" (Collection_ID, Parent_Collection_ID, Collection_Name, Collection_Description) and \"Collection_Logs\" (Log_ID, Collection_ID, Log_Message, Log_Timestamp). Then create an AFTER UPDATE trigger on \"Collections\" that logs 'Collection updated' with the current timestamp to \"Collection_Logs\" for each updated row.",
    "natural_language": "Please construct a database schema comprising two tables. The first table, designated \"Collections,\" should contain the following columns: Collection_ID, Parent_Collection_ID, Collection_Name, and Collection_Description. The second table, designated \"Collection_Logs,\" should contain the columns Log_ID, Collection_ID, Log_Message, and Log_Timestamp. Subsequently, implement an AFTER UPDATE trigger on the \"Collections\" table. This trigger must be configured to insert a new record into the \"Collection_Logs\" table for each row that is updated. The inserted record should contain the message 'Collection updated' and the current timestamp.",
    "id": 120
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the Event_Details column in the Events table to the string 'Updated on Insert' for the row where the Event_ID matches the Event_ID of the newly inserted row in the Participants_in_Events table. This function is executed by a trigger named trg_update_event_details_on_insert, which is set to activate after a new row is inserted into the Participants_in_Events table. The trigger operates on each row individually, ensuring that the Event_Details field is updated for the corresponding event whenever a new participant is added to an event. The function returns the newly inserted row, allowing the insertion process to continue seamlessly.",
    "plsql": "CREATE OR REPLACE FUNCTION update_event_details_on_insert() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Events\" SET \"Event_Details\" = 'Updated on Insert' WHERE \"Event_ID\" = NEW.\"Event_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_event_details_on_insert\nAFTER INSERT ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION update_event_details_on_insert();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants_in_Events"
    ],
    "call_sqls": [
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 100);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 101);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (13, 102);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 103);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 104);"
    ],
    "summary": "Create an AFTER INSERT row-level trigger function named `trg_update_event_details_on_insert`. When a row is inserted into the `Participants_in_Events` table, update the `Event_Details` column in the `Events` table to 'Updated on Insert' for the matching `Event_ID`. Return the NEW row.",
    "natural_language": "Please construct an AFTER INSERT row-level trigger function designated as `trg_update_event_details_on_insert`. Upon the insertion of a row into the `Participants_in_Events` table, this function shall modify the `Event_Details` column within the `Events` table to the value 'Updated on Insert' for the corresponding `Event_ID`. The function must then return the NEW row.",
    "id": 121
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_event_details_on_delete` that is designed to be executed in response to a data manipulation event, and a trigger named `trg_update_event_details_on_delete` that invokes this function. The `update_event_details_on_delete` function does not accept any explicit parameters beyond the implicit trigger context variables. When this function is executed, it performs a single `UPDATE` operation on the table named `\"Events\"`. Specifically, it modifies the `Event_Details` column within the `\"Events\"` table, setting its value to the string literal `'Updated on Delete'`. This update is conditionally applied only to rows where the value in the `Event_ID` column of the `\"Events\"` table matches the value of `OLD.\"Event_ID\"`. The `OLD` keyword refers to the row that was deleted from the table on which the trigger is defined. After performing this update, the function returns the `OLD` row, which is a standard requirement for `BEFORE` or `AFTER` row-level triggers in PostgreSQL, though in this `AFTER` trigger context, the return value is typically ignored. The `trg_update_event_details_on_delete` trigger is defined to activate `AFTER DELETE` operations on the `\"Participants_in_Events\"` table. It is configured to execute `FOR EACH ROW` that is deleted from `\"Participants_in_Events\"`, meaning the `update_event_details_on_delete` function will be called once for every individual row removed from the `\"Participants_in_Events\"` table. When a row is deleted from `\"Participants_in_Events\"`, the trigger will execute the `update_event_details_on_delete` function, which in turn updates the `Event_Details` column in the `\"Events\"` table for the event corresponding to the `Event_ID` of the deleted participant record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_event_details_on_delete() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Events\" SET \"Event_Details\" = 'Updated on Delete' WHERE \"Event_ID\" = OLD.\"Event_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_event_details_on_delete\nAFTER DELETE ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION update_event_details_on_delete();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants_in_Events"
    ],
    "call_sqls": [
      "DELETE FROM \"Participants_in_Events\" WHERE \"Event_ID\" = 3 AND \"Participant_ID\" = 26;",
      "DELETE FROM \"Participants_in_Events\" WHERE \"Event_ID\" = 8 AND \"Participant_ID\" = 66;",
      "DELETE FROM \"Participants_in_Events\" WHERE \"Event_ID\" = 13 AND \"Participant_ID\" = 86;",
      "DELETE FROM \"Participants_in_Events\" WHERE \"Event_ID\" = 8;",
      "DELETE FROM \"Participants_in_Events\" WHERE \"Participant_ID\" = 26;"
    ],
    "summary": "Create an AFTER DELETE row-level trigger function named `update_event_details_on_delete`. When a row is deleted from the `Participants_in_Events` table, update the `Event_Details` column in the `Events` table to 'Updated on Delete' for the matching `Event_ID` from the OLD record. Return the OLD row.",
    "natural_language": "Make a trigger that fires after a row gets removed from the Participants_in_Events table. It should kind of adjust the Event_Details field in the Events table to something like 'Updated on Delete' for the relevant event, using the old record's ID. Have it give back the old row data.",
    "id": 122
  },
  {
    "ir": "Write a PLpgSQL function named truncate_event_details that is designed to be executed as a trigger. This function does not take any parameters directly but operates in conjunction with a trigger on the Participants_in_Events table. The function is triggered after an insert operation on the Participants_in_Events table. It performs an update operation on the Events table, specifically targeting the Event_Details column. The update sets the Event_Details column to a truncated version of its current length, converting the length of the Event_Details text to a numeric value, truncating it to zero decimal places, and then converting it back to text. This operation is applied to the row in the Events table where the Event_ID matches the Event_ID of the newly inserted row in the Participants_in_Events table. The function returns the NEW row, which is the row that was just inserted into the Participants_in_Events table. The trigger named trg_truncate_event_details is defined to execute this function after each row insertion into the Participants_in_Events table, ensuring that the Event_Details in the corresponding Events table row is updated immediately following the insertion.",
    "plsql": "CREATE OR REPLACE FUNCTION truncate_event_details() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Events\" SET \"Event_Details\" = trunc(length(\"Event_Details\")::numeric, 0)::text WHERE \"Event_ID\" = NEW.\"Event_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_truncate_event_details\nAFTER INSERT ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION truncate_event_details();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants_in_Events"
    ],
    "call_sqls": [
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 100);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 101);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (13, 102);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 103);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 104);"
    ],
    "summary": "Create an AFTER INSERT row-level trigger function named `truncate_event_details`. When a row is inserted into the `Participants_in_Events` table, update the `Event_Details` column in the `Events` table, setting it to the truncated length (as text) of its current value for the matching `Event_ID`. Return the NEW row.",
    "natural_language": "Please construct an AFTER INSERT row-level trigger function designated as `truncate_event_details`. Upon the insertion of a row into the `Participants_in_Events` table, this function shall modify the `Event_Details` column within the `Events` table. The modification must set the column's value to a textual representation of its current length, truncated, for the corresponding `Event_ID`. The function is required to return the NEW row.",
    "id": 123
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_songs_on_singer_delete that returns a trigger, which is executed automatically by a trigger named trg_delete_songs_on_singer_delete after a delete operation occurs on the singer table for each individual row that is deleted; this function performs a delete operation on the song table where the value in the song table's Singer_ID column exactly matches the value of the Singer_ID column from the OLD record, which represents the singer row just deleted, and then the function returns the OLD row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_songs_on_singer_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM song WHERE \"Singer_ID\" = OLD.\"Singer_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_songs_on_singer_delete\n    AFTER DELETE ON singer\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_songs_on_singer_delete();",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "DELETE FROM singer WHERE \"Singer_ID\" = 1;",
      "DELETE FROM singer WHERE \"Singer_ID\" = 2;",
      "DELETE FROM singer WHERE \"Singer_ID\" = 3;",
      "DELETE FROM singer WHERE \"Name\" = 'Liliane Bettencourt';",
      "DELETE FROM singer WHERE \"Citizenship\" = 'France';"
    ],
    "summary": "Create an AFTER DELETE row-level trigger function named `delete_songs_on_singer_delete`. When a row is deleted from the `singer` table, delete all rows from the `song` table where the `Singer_ID` matches the OLD record's `Singer_ID`. Return the OLD row.",
    "natural_language": "Write an AFTER DELETE row-level trigger function called `delete_songs_on_singer_delete`. For each row deleted from the `singer` table, remove all corresponding rows from the `song` table where the `Singer_ID` equals the OLD record's `Singer_ID`. Ensure the function returns the OLD row.",
    "id": 124
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_related_missions that returns a trigger and is executed by a trigger named ship_before_delete_trigger, where the trigger is defined to fire BEFORE a DELETE operation on the ship table for each individual row being deleted, and the function's logic performs a DELETE operation on the mission table targeting all rows where the mission table's column named Ship_ID, which is enclosed in double quotes, is equal to the value of the column named Ship_ID, also in double quotes, from the OLD record representing the ship row that is about to be deleted, and after performing that cascading delete, the function returns the OLD record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_missions() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM mission WHERE \"Ship_ID\" = OLD.\"Ship_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER ship_before_delete_trigger\nBEFORE DELETE ON ship\nFOR EACH ROW EXECUTE FUNCTION delete_related_missions();",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "DELETE FROM ship WHERE \"Ship_ID\" = 1;",
      "DELETE FROM ship WHERE \"Ship_ID\" = 2;",
      "DELETE FROM ship WHERE \"Ship_ID\" = 3;"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger function named `delete_related_missions`. When a row is about to be deleted from the `ship` table, delete all rows from the `mission` table where the quoted `\"Ship_ID\"` column matches the OLD record's quoted `\"Ship_ID\"`. Return the OLD row.",
    "natural_language": "Make a trigger that runs before deleting a ship. It should clear out any mission records that seem to be linked to that ship, based on the ship's ID. Then just give back the original ship details.",
    "id": 125
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the \"CMI_Cross_References\" table by setting the master_customer_id column to the smallest master_customer_id value from the \"Customer_Master_Index\" table, ordered by master_customer_id in ascending order, for the row where cmi_cross_ref_id matches the cmi_cross_ref_id of the newly inserted row in the \"Benefits_Overpayments\" table. This function is executed by a trigger named update_cmi_cross_ref, which is fired after each row is inserted into the \"Benefits_Overpayments\" table. The trigger ensures that for every new insertion into the \"Benefits_Overpayments\" table, the corresponding row in the \"CMI_Cross_References\" table is updated with the smallest master_customer_id from the \"Customer_Master_Index\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_cmi_cross_ref_trigger() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"CMI_Cross_References\" \n  SET master_customer_id = (SELECT master_customer_id FROM \"Customer_Master_Index\" ORDER BY master_customer_id LIMIT 1)\n  WHERE cmi_cross_ref_id = NEW.cmi_cross_ref_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_cmi_cross_ref AFTER INSERT ON \"Benefits_Overpayments\"\nFOR EACH ROW EXECUTE FUNCTION update_cmi_cross_ref_trigger();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (1, 65);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (2, 41);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (3, 83);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (4, 2);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (5, 4);"
    ],
    "summary": "Create an AFTER INSERT trigger on the Benefits_Overpayments table that updates the CMI_Cross_References table. For each new row, set its master_customer_id to the minimum master_customer_id from the Customer_Master_Index table.",
    "natural_language": "Please implement an AFTER INSERT trigger on the Benefits_Overpayments table. Its function is to update the CMI_Cross_References table. For every newly inserted row, the trigger must assign the master_customer_id by selecting the minimum master_customer_id value present in the Customer_Master_Index table.",
    "id": 126
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_electoral_register_trigger that returns a trigger and is executed automatically by a trigger named insert_electoral_register, which is defined to fire after every insert operation on the table named Council_Tax for each new row, where the function's logic performs a single insert operation into the table named Electoral_Register, specifying the columns electoral_register_id and cmi_cross_ref_id for the new row, and populating these columns with the values from the newly inserted Council_Tax row's council_tax_id and cmi_cross_ref_id columns respectively, accessed via the NEW record, and finally returns the NEW record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_electoral_register_trigger() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Electoral_Register\" (electoral_register_id, cmi_cross_ref_id) VALUES (NEW.council_tax_id, NEW.cmi_cross_ref_id);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_electoral_register AFTER INSERT ON \"Council_Tax\"\nFOR EACH ROW EXECUTE FUNCTION insert_electoral_register_trigger();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "INSERT INTO \"Council_Tax\" (council_tax_id, cmi_cross_ref_id) VALUES (4, 105);",
      "INSERT INTO \"Council_Tax\" (council_tax_id, cmi_cross_ref_id) VALUES (5, 106);",
      "INSERT INTO \"Council_Tax\" (council_tax_id, cmi_cross_ref_id) VALUES (6, 107);",
      "INSERT INTO \"Council_Tax\" (council_tax_id, cmi_cross_ref_id) VALUES (7, 108);",
      "INSERT INTO \"Council_Tax\" (council_tax_id, cmi_cross_ref_id) VALUES (8, 109);"
    ],
    "summary": "Create an AFTER INSERT trigger on the Council_Tax table. For each new row, insert a corresponding row into the Electoral_Register table, mapping council_tax_id to electoral_register_id and cmi_cross_ref_id to cmi_cross_ref_id.",
    "natural_language": "How can I create an AFTER INSERT trigger on the Council_Tax table that, for each new row, inserts a corresponding row into the Electoral_Register table by mapping council_tax_id to electoral_register_id and cmi_cross_ref_id to cmi_cross_ref_id?",
    "id": 127
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an update operation on the \"Council_Tax\" table. This function, named update_business_rates_trigger, does not take any parameters directly but operates using the implicit NEW record, which represents the new state of the row being updated in the \"Council_Tax\" table. The function performs an update operation on the \"Business_Rates\" table, setting the cmi_cross_ref_id column to the value of NEW.cmi_cross_ref_id, which is the updated value from the \"Council_Tax\" table. The update is applied to rows in the \"Business_Rates\" table where the business_rates_id column matches the NEW.council_tax_id value from the updated row in the \"Council_Tax\" table. After performing the update, the function returns the NEW record, which is standard practice for trigger functions to allow the update operation on the \"Council_Tax\" table to proceed. The trigger named update_business_rates is defined to execute this function after any update operation on the \"Council_Tax\" table, ensuring that changes in the council_tax_id and cmi_cross_ref_id columns in \"Council_Tax\" are reflected in the corresponding rows of the \"Business_Rates\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_business_rates_trigger() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Business_Rates\" SET cmi_cross_ref_id = NEW.cmi_cross_ref_id WHERE business_rates_id = NEW.council_tax_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_business_rates AFTER UPDATE ON \"Council_Tax\"\nFOR EACH ROW EXECUTE FUNCTION update_business_rates_trigger();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 105 WHERE council_tax_id = 1;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 106 WHERE council_tax_id = 2;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 107 WHERE council_tax_id = 3;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 108 WHERE council_tax_id = 4;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 109 WHERE council_tax_id = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger on the Council_Tax table. For each updated row, update the Business_Rates table, setting cmi_cross_ref_id to the new value where business_rates_id matches the updated council_tax_id.",
    "natural_language": "Construct a detailed AFTER UPDATE trigger to be applied to the Council_Tax table, which will, for every single row that is modified, meticulously update the corresponding entry in the Business_Rates table by setting its cmi_cross_ref_id to the freshly updated value, but only in those specific records where the business_rates_id precisely matches the updated council_tax_id from the Council_Tax table.",
    "id": 128
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically updates the birth_year column of a new row being inserted into the actor table. The function, named update_actor_birth_year, is executed before each row is inserted into the actor table due to the trigger named trg_update_actor_birth_year. The function does not take any parameters directly but operates on the NEW record, which represents the row being inserted. Within the function, the birth_year column of the NEW record is set to a calculated value. This value is determined by extracting the current year from the system date using the EXTRACT function and subtracting a random number between 20 and 69, inclusive. The random number is generated by multiplying the result of the RANDOM() function, which returns a value between 0 and 1, by 50, and then adding 20 to ensure the minimum subtraction is 20. The FLOOR function is used to round down the result to the nearest whole number. After setting the birth_year, the function returns the modified NEW record, allowing the insertion to proceed with the updated birth_year value.",
    "plsql": "CREATE OR REPLACE FUNCTION update_actor_birth_year() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.birth_year = EXTRACT(YEAR FROM CURRENT_DATE) - FLOOR(RANDOM() * 50 + 20);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_actor_birth_year\nBEFORE INSERT ON actor\nFOR EACH ROW EXECUTE FUNCTION update_actor_birth_year();",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "cast",
      "actor"
    ],
    "call_sqls": [
      "INSERT INTO actor (aid, gender, name, nationality, birth_city) VALUES (1, 'Male', 'Tom Hanks', 'American', 'Concord');",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city) VALUES (2, 'Female', 'Meryl Streep', 'American', 'Summit');",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city) VALUES (3, 'Male', 'Leonardo DiCaprio', 'American', 'Los Angeles');",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city) VALUES (4, 'Female', 'Cate Blanchett', 'Australian', 'Melbourne');",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city) VALUES (5, 'Male', 'Denzel Washington', 'American', 'Mount Vernon');"
    ],
    "summary": "Create a BEFORE INSERT trigger on the actor table. For each new row, calculate and set the birth_year by subtracting a random integer between 20 and 69 from the current year.",
    "natural_language": "Construct a BEFORE INSERT trigger for the actor table, which, for every single new row being added, will meticulously calculate and then assign the birth_year by taking the current year and subtracting from it a randomly generated integer that falls specifically within the inclusive range of twenty to sixty-nine.",
    "id": 129
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `set_tv_series_title_aka` that is designed to be executed before an `INSERT` operation on the `tv_series` table. This function does not accept any explicit parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. Upon execution, the function constructs a new string value by concatenating the existing value of the `title` column from the `NEW` record, followed by a literal space and an opening parenthesis ` (` , then the existing value of the `release_year` column from the `NEW` record, and finally a closing parenthesis `)`. This newly constructed string is then assigned to the `title_aka` column of the `NEW` record. After this assignment, the function returns the modified `NEW` record, allowing the `INSERT` operation to proceed with the updated `title_aka` value.\n\nThis function is invoked by a trigger named `trg_set_tv_series_title_aka`. This trigger is configured to activate `BEFORE INSERT` operations on the `tv_series` table. It is a `FOR EACH ROW` trigger, meaning that the `set_tv_series_title_aka` function will be executed once for every row that is being inserted into the `tv_series` table. The `EXECUTE FUNCTION set_tv_series_title_aka()` clause specifies that the `set_tv_series_title_aka` function should be called to handle the trigger event.",
    "plsql": "CREATE OR REPLACE FUNCTION set_tv_series_title_aka() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.title_aka = CONCAT(NEW.title, ' (', NEW.release_year, ')');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_set_tv_series_title_aka\nBEFORE INSERT ON tv_series\nFOR EACH ROW EXECUTE FUNCTION set_tv_series_title_aka();",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "cast",
      "actor"
    ],
    "call_sqls": [
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, num_of_episodes, budget) VALUES (1001, 'Stranger Things', 2016, 4, 34, 'High');",
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, budget) VALUES (1002, 'The Crown', 2016, 6, 'Very High');",
      "INSERT INTO tv_series (sid, title, release_year, num_of_episodes, title_aka, budget) VALUES (1003, 'Breaking Bad', 2008, 62, 'Placeholder', 'Medium');",
      "INSERT INTO tv_series (title, release_year, num_of_seasons, num_of_episodes, budget) VALUES ('Game of Thrones', 2011, 8, 73, 'Extremely High');",
      "INSERT INTO tv_series (sid, title, release_year, budget) VALUES (1005, 'The Mandalorian', 2019, 'High');"
    ],
    "summary": "Create a BEFORE INSERT trigger on the tv_series table. For each new row, set the title_aka column by concatenating the title, a space, an opening parenthesis, the release_year, and a closing parenthesis.",
    "natural_language": "Construct a BEFORE INSERT trigger for the tv_series table, which will meticulously and automatically generate a descriptive entry for the title_aka column by seamlessly combining the title, followed by a single space, an opening parenthesis, the specific release_year value, and finally a closing parenthesis, for every single new row that is inserted.",
    "id": 130
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically calculates and assigns a formatted budget value to a new row being inserted into the tv_series table. The function, named calculate_tv_series_budget, is executed before each row is inserted into the tv_series table. It computes the budget by multiplying the number of seasons (num_of_seasons) by the number of episodes (num_of_episodes) and then by 1,000,000. The result of this multiplication is converted into a formatted string representing a currency amount, using the TO_CHAR function with the format 'FM$999,999,999', which ensures that the budget is displayed with a dollar sign and appropriate commas for thousands. This formatted budget string is then assigned to the budget column of the new row (NEW.budget) being inserted. The trigger, named trg_calculate_tv_series_budget, is defined to execute this function before any insert operation on the tv_series table, ensuring that every new tv_series entry has its budget calculated and formatted according to the specified logic.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_tv_series_budget() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.budget = TO_CHAR(NEW.num_of_seasons * NEW.num_of_episodes * 1000000, 'FM$999,999,999');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_calculate_tv_series_budget\nBEFORE INSERT ON tv_series\nFOR EACH ROW EXECUTE FUNCTION calculate_tv_series_budget();",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "cast",
      "actor"
    ],
    "call_sqls": [
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, num_of_episodes, title_aka) VALUES (1, 'The Crown', 2016, 6, 60, 'Crown');",
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, num_of_episodes, title_aka) VALUES (2, 'Game of Thrones', 2011, 8, 73, 'GoT');",
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, num_of_episodes, title_aka) VALUES (3, 'Breaking Bad', 2008, 5, 62, 'BB');",
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, num_of_episodes, title_aka) VALUES (4, 'Stranger Things', 2016, 4, 34, 'ST');",
      "INSERT INTO tv_series (sid, title, release_year, num_of_seasons, num_of_episodes, title_aka) VALUES (5, 'The Mandalorian', 2019, 3, 24, 'Mando');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named calculate_tv_series_budget. For each new row in the tv_series table, calculate the budget by multiplying num_of_seasons by num_of_episodes by 1,000,000. Format the result as currency using TO_CHAR with 'FM$999,999,999' and assign it to the NEW.budget column.",
    "natural_language": "Construct a BEFORE INSERT trigger function that is to be named calculate_tv_series_budget. For every single new record that is inserted into the tv_series table, you must meticulously compute the budget by taking the number of seasons and multiplying it by the number of episodes, and then further multiplying that product by the substantial figure of one million. Subsequently, you should elegantly format this calculated result as a proper currency string by applying the TO_CHAR function with the precise format model 'FM$999,999,999', and finally, you must assign this beautifully formatted value directly to the NEW.budget column.",
    "id": 131
  },
  {
    "ir": "Write a PostgreSQL trigger function named normalize_actor_nationality that is executed automatically by a trigger named trg_normalize_actor_nationality, which is defined to fire BEFORE any INSERT or UPDATE operation on the actor table for each individual row being processed; the function receives the new row data in a special record variable named NEW and operates on the nationality column within this NEW record, applying the TRIM function to remove any leading or trailing whitespace characters from the incoming NEW.nationality string value and then applying the UPPER function to convert the trimmed string to all uppercase letters, subsequently assigning this transformed value back to the NEW.nationality column, and finally returns the modified NEW record to the triggering INSERT or UPDATE statement to be persisted.",
    "plsql": "CREATE OR REPLACE FUNCTION normalize_actor_nationality() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.nationality = UPPER(TRIM(NEW.nationality));\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_normalize_actor_nationality\nBEFORE INSERT OR UPDATE ON actor\nFOR EACH ROW EXECUTE FUNCTION normalize_actor_nationality();",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "cast",
      "actor"
    ],
    "call_sqls": [
      "INSERT INTO actor (aid, gender, name, nationality, birth_city, birth_year) VALUES (1, 'Male', 'Tom Hanks', ' american ', 'Concord', 1956);",
      "UPDATE actor SET nationality = '  GERMAN  ' WHERE aid = 1;",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city, birth_year) VALUES (2, 'Female', 'Meryl Streep', '  u.s.a.  ', 'Summit', 1949);",
      "UPDATE actor SET nationality = '  french ' WHERE aid = 2;",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city, birth_year) VALUES (3, 'Male', 'Brad Pitt', ' united states ', 'Shawnee', 1963);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named normalize_actor_nationality. For each row in the actor table, trim leading/trailing spaces from the NEW.nationality value, convert it to uppercase, and assign the result back to NEW.nationality.",
    "natural_language": "Create trigger normalize_actor_nationality. Before insert or update on actor, trim and uppercase NEW.nationality.",
    "id": 132
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the Customer_Orders table by setting the order_status_code column to 'Updated' for the row where the order_id matches the order_id of the newly inserted row in the Order_Items table. This function is executed by a trigger named update_status_after_item_insert, which is defined to fire after a new row is inserted into the Order_Items table. The trigger operates on each row inserted, ensuring that the corresponding order in the Customer_Orders table has its status updated immediately after an item is added to the order. The function returns the newly inserted row, allowing the trigger to continue processing with the new data.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_order_status() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" SET \"order_status_code\" = 'Updated' WHERE \"order_id\" = NEW.\"order_id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_status_after_item_insert\nAFTER INSERT ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_order_status();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\") VALUES (4, 1, 14, '5');",
      "INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\") VALUES (5, 2, 15, '3');",
      "INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\") VALUES (6, 3, 16, '7');",
      "INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\") VALUES (7, 1, 17, '2');",
      "INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\") VALUES (8, 2, 18, '4');"
    ],
    "summary": "Create an AFTER INSERT trigger function for the Order_Items table. For each new row inserted, update the Customer_Orders table, setting order_status_code to 'Updated' where the order_id matches the NEW.order_id from the inserted item.",
    "natural_language": "Please construct an AFTER INSERT trigger function for the Order_Items table. The function's purpose is to execute an update on the Customer_Orders table subsequent to each insertion. Specifically, it must set the order_status_code to 'Updated' for any record in Customer_Orders where the order_id corresponds to the NEW.order_id value from the recently inserted row.",
    "id": 133
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_delete_orphaned_orders that returns a trigger, which is invoked by a trigger named cleanup_orders_after_item_delete defined to fire after a delete operation on the Order_Items table for each deleted row, where the function body executes a delete operation on the Customer_Orders table targeting rows where the order_id column matches the OLD.order_id value from the deleted Order_Items row, but only if a condition is satisfied, specifically using a NOT EXISTS clause with a subquery that selects the constant value 1 from the Order_Items table where the order_id column equals the OLD.order_id value, thereby ensuring the deletion from Customer_Orders occurs only when no corresponding rows remain in the Order_Items table for that specific order_id, and the function concludes by returning the OLD row record.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_orphaned_orders() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Customer_Orders\" WHERE \"order_id\" = OLD.\"order_id\" AND NOT EXISTS (SELECT 1 FROM \"Order_Items\" WHERE \"order_id\" = OLD.\"order_id\");\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cleanup_orders_after_item_delete\nAFTER DELETE ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION trg_delete_orphaned_orders();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Order_Items\" WHERE order_item_id = 1;",
      "DELETE FROM \"Order_Items\" WHERE order_id = 8;",
      "DELETE FROM \"Order_Items\" WHERE product_id = 13;",
      "DELETE FROM \"Order_Items\" WHERE order_quantity = '2';",
      "DELETE FROM \"Order_Items\" WHERE order_item_id IN (2, 3);"
    ],
    "summary": "Create an AFTER DELETE trigger function for the Order_Items table. For each deleted row, delete the corresponding order from the Customer_Orders table where the order_id matches OLD.order_id, but only if no other items for that order_id remain in the Order_Items table.",
    "natural_language": "Set up a trigger that runs after something gets removed from the order items list. Basically, whenever a row is taken out, you should also clear out the matching order from the customer orders if it seems like there aren't really any other items left for that particular order hanging around anymore.",
    "id": 134
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_set_default_order_date` that is designed to be executed before an `INSERT` operation on the `\"Customer_Orders\"` table. This function does not accept any explicit parameters. Upon execution, it sets the value of the `order_date` column for the new row being inserted (`NEW.\"order_date\"`) to the current date, which is obtained using the `CURRENT_DATE` function. After this assignment, the function returns the modified new row (`NEW`), allowing the `INSERT` operation to proceed with the `order_date` column populated. This trigger function is then associated with a trigger named `default_date_before_order_insert`. This trigger is configured to activate `BEFORE INSERT` operations on the `\"Customer_Orders\"` table. It is set to execute `FOR EACH ROW`, meaning the `trg_set_default_order_date` function will be invoked once for every row that is being inserted into the `\"Customer_Orders\"` table. The purpose of this trigger is to automatically populate the `order_date` column with the current date whenever a new order record is inserted into the `\"Customer_Orders\"` table, ensuring that the `order_date` is never null and always reflects the date of insertion.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_set_default_order_date() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"order_date\" = CURRENT_DATE;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER default_date_before_order_insert\nBEFORE INSERT ON \"Customer_Orders\"\nFOR EACH ROW EXECUTE FUNCTION trg_set_default_order_date();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (101, 1, 'Pending');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (102, 2, 'Completed');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (103, 3, 'Shipped');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (104, 4, 'Cancelled');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (105, 5, 'Processing');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named trg_set_default_order_date for the Customer_Orders table. For each new row, set the NEW.order_date column to the current date (CURRENT_DATE) if it is not already provided.",
    "natural_language": "Define a BEFORE INSERT trigger function called trg_set_default_order_date on the Customer_Orders table to set the NEW.order_date to CURRENT_DATE whenever a new row is inserted without a date.",
    "id": 135
  },
  {
    "ir": "Write a PLpgSQL trigger function named `trg_cascade_delete_items` that is designed to be executed in response to a data manipulation event on a table, and a trigger named `delete_items_before_order_delete` that invokes this function. The `trg_cascade_delete_items` function does not accept any explicit parameters beyond the implicit trigger context. When executed, this function performs a `DELETE` operation on the `\"Order_Items\"` table. The `DELETE` operation targets rows in `\"Order_Items\"` where the value in the `\"order_id\"` column of `\"Order_Items\"` is equal to the value of the `\"order_id\"` column from the row that is currently being processed by the triggering event. After the `DELETE` operation is completed, the function returns the `OLD` row, which represents the state of the row in the triggering table before the triggering event occurred. The `delete_items_before_order_delete` trigger is defined to activate `BEFORE DELETE` operations on the `\"Customer_Orders\"` table. This trigger is configured to execute `FOR EACH ROW` that is being deleted from `\"Customer_Orders\"`. For each such row, the trigger executes the `trg_cascade_delete_items()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_cascade_delete_items() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Order_Items\" WHERE \"order_id\" = OLD.\"order_id\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_items_before_order_delete\nBEFORE DELETE ON \"Customer_Orders\"\nFOR EACH ROW EXECUTE FUNCTION trg_cascade_delete_items();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 1;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 2;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 3;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 8;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 13;"
    ],
    "summary": "Create a trigger function `trg_cascade_delete_items` that deletes rows from the \"Order_Items\" table where the order_id matches the order_id of the row being deleted from the \"Customer_Orders\" table. The function returns the OLD row. Create a BEFORE DELETE FOR EACH ROW trigger named `delete_items_before_order_delete` on the \"Customer_Orders\" table to execute this function.",
    "natural_language": "Set up a trigger that, before removing a customer order, gets rid of any related order items. The trigger should work for each order being deleted and handle the cleanup automatically. Also, make sure the function involved gives back the old order details.",
    "id": 136
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_validate_order_quantity` that is designed to be executed before an `INSERT` operation on the `\"Order_Items\"` table. This function does not accept any explicit parameters, but it operates on the implicit `NEW` record, which represents the row about to be inserted into the `\"Order_Items\"` table. The function's primary purpose is to validate and potentially modify the `order_quantity` column of the `NEW` record. Specifically, it checks if the value of the `order_quantity` column within the `NEW` record, after being explicitly cast to an integer type using `::integer`, is greater than the integer value `100`. If this condition evaluates to true, meaning the proposed `order_quantity` exceeds `100`, the function then modifies the `order_quantity` column of the `NEW` record by assigning it the string literal value `'100'`. This effectively caps the `order_quantity` at `100` if it was initially higher. After performing this conditional check and potential modification, the function returns the `NEW` record, which then proceeds with the `INSERT` operation on the `\"Order_Items\"` table, incorporating any changes made by the trigger function.\n\nThis trigger function is associated with a trigger named `check_quantity_before_item_insert`. This trigger is configured to activate `BEFORE INSERT` operations on the `\"Order_Items\"` table. It is a `FOR EACH ROW` trigger, meaning the `trg_validate_order_quantity` function will be executed once for each row that is being inserted into the `\"Order_Items\"` table. The `EXECUTE FUNCTION trg_validate_order_quantity()` clause specifies that the `trg_validate_order_quantity` function is the routine to be executed when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_order_quantity() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"order_quantity\"::integer > 100 THEN\n        NEW.\"order_quantity\" = '100';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER check_quantity_before_item_insert\nBEFORE INSERT ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_order_quantity();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (100, 8, 13, '50');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (101, 1, 10, '150');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (102, 13, 11, '200');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (103, 8, 5, '99');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (104, 2, 7, '101');"
    ],
    "summary": "Create a trigger function `trg_validate_order_quantity` that, before inserting a row into the \"Order_Items\" table, checks if the new order_quantity (cast to integer) exceeds 100. If it does, set the new order_quantity to '100'. The function returns the NEW row. Create a BEFORE INSERT FOR EACH ROW trigger named `check_quantity_before_item_insert` on the \"Order_Items\" table to execute this function.",
    "natural_language": "Make a BEFORE INSERT trigger on Order_Items called check_quantity_before_item_insert. It runs trg_validate_order_quantity to cap new order_quantity at 100 if it exceeds that.",
    "id": 137
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_validate_event_service` that is designed to be executed before an `INSERT` or `UPDATE` operation on the `\"Events\"` table, for each row being processed. This function does not accept any explicit parameters beyond the standard trigger context variables. Upon execution, the function first evaluates a conditional statement: it checks if the `NEW.\"Service_ID\"` column, representing the `Service_ID` value of the row currently being inserted or updated, is not `NULL`. If `NEW.\"Service_ID\"` is not `NULL`, the function proceeds to execute a subquery. This subquery attempts to select a constant value `1` from the `\"Services\"` table, specifically looking for any row where the `\"Service_ID\"` column in the `\"Services\"` table matches the value of `NEW.\"Service_ID\"`. The `NOT EXISTS` operator then checks if this subquery returns no rows, meaning that no corresponding `Service_ID` exists in the `\"Services\"` table for the `NEW.\"Service_ID\"` value. If both conditions are met (i.e., `NEW.\"Service_ID\"` is not `NULL` AND no matching `Service_ID` is found in the `\"Services\"` table), then the function modifies the `NEW.\"Service_ID\"` column by setting its value to `NULL`. After evaluating and potentially modifying `NEW.\"Service_ID\"`, the function concludes by returning the `NEW` row, which contains the potentially modified `Service_ID` value, allowing the `INSERT` or `UPDATE` operation on the `\"Events\"` table to proceed with this (possibly adjusted) row.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_event_service() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Service_ID\" IS NOT NULL AND NOT EXISTS (SELECT 1 FROM \"Services\" WHERE \"Service_ID\" = NEW.\"Service_ID\") THEN\n        NEW.\"Service_ID\" := NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_event_service_trigger\nBEFORE INSERT OR UPDATE ON \"Events\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_event_service();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (100, 2, 'Test Event 1');",
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (101, 999, 'Test Event 2');",
      "UPDATE \"Events\" SET \"Service_ID\" = 5 WHERE \"Event_ID\" = 3;",
      "UPDATE \"Events\" SET \"Service_ID\" = 999 WHERE \"Event_ID\" = 8;",
      "INSERT INTO \"Events\" (\"Event_ID\", \"Event_Details\") VALUES (102, 'Test Event 3');"
    ],
    "summary": "Create a trigger function `trg_validate_event_service` that, before inserting or updating a row in the \"Events\" table, checks if the new Service_ID is not NULL and does not exist in the \"Services\" table. If both conditions are true, set the new Service_ID to NULL. The function returns the NEW row. Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger on the \"Events\" table to execute this function.",
    "natural_language": "Alright, so we need a trigger function called `trg_validate_event_service`. Before you add a new event or update an existing one in the \"Events\" table, this function's gotta check a couple things. It needs to make sure the new Service_ID isn't empty and that it actually exists over in the \"Services\" table. If both those things are true—meaning the ID isn't null but it's also not a valid service—then just set that Service_ID to null. The function should spit back the NEW row. Finally, hook this function up to the \"Events\" table with a BEFORE INSERT OR UPDATE FOR EACH ROW trigger so it runs automatically.",
    "id": 138
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_prevent_duplicate_participation that is executed automatically before every INSERT operation on the table named \"Participants_in_Events\" for each new row being inserted, where the function checks for the existence of a duplicate record by performing a SELECT query on the same \"Participants_in_Events\" table to see if there is any existing row where the column \"Event_ID\" matches the new row's \"Event_ID\" value from the NEW record and the column \"Participant_ID\" matches the new row's \"Participant_ID\" value from the NEW record, and if such a duplicate row is found, the function returns NULL to cancel the insertion and prevent the new row from being saved, but if no duplicate is found, the function returns the NEW row to allow the INSERT operation to proceed normally.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_prevent_duplicate_participation() RETURNS TRIGGER AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Participants_in_Events\" WHERE \"Event_ID\" = NEW.\"Event_ID\" AND \"Participant_ID\" = NEW.\"Participant_ID\") THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER prevent_duplicate_participation_trigger\nBEFORE INSERT ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION trg_prevent_duplicate_participation();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 26);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 66);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (13, 28);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 9);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 86);"
    ],
    "summary": "Create a trigger function `trg_prevent_duplicate_participation` that, before inserting a row into the \"Participants_in_Events\" table, checks if a row with the same Event_ID and Participant_ID already exists. If a duplicate is found, return NULL to cancel the insert. If not, return the NEW row to proceed. Create a BEFORE INSERT FOR EACH ROW trigger on the \"Participants_in_Events\" table to execute this function.",
    "natural_language": "Construct a trigger function named `trg_prevent_duplicate_participation` which, prior to the insertion of any new record into the \"Participants_in_Events\" table, meticulously verifies whether an entry featuring an identical combination of Event_ID and Participant_ID is already present. Should such a duplicate be discovered, the function must thoughtfully return NULL to gracefully abort the insertion attempt. Conversely, if no matching record is found, it should confidently return the NEW row to allow the operation to proceed successfully. Furthermore, establish a BEFORE INSERT FOR EACH ROW trigger specifically on the \"Participants_in_Events\" table to reliably execute this carefully designed function.",
    "id": 139
  },
  {
    "ir": "Write a PLpgSQL trigger function named trg_log_service_change that is executed after an insert operation on the Services table. This function inserts a new record into the Events table with three specific values: Event_ID, Service_ID, and Event_Details. The Event_ID is determined by selecting the maximum existing Event_ID from the Events table, using the COALESCE function to handle cases where no records exist, and incrementing this maximum value by one. The Service_ID is directly taken from the NEW row being inserted into the Services table, which is accessible within the trigger context. The Event_Details is set to the current timestamp, converted to text format using the ::text type cast. The trigger named log_service_change_trigger is defined to execute this function for each row inserted into the Services table, ensuring that every new service addition results in a corresponding event log entry in the Events table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_log_service_change() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") \n    VALUES ((SELECT COALESCE(MAX(\"Event_ID\"), 0) + 1 FROM \"Events\"), NEW.\"Service_ID\", CURRENT_TIMESTAMP::text);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_service_change_trigger\nAFTER INSERT ON \"Services\"\nFOR EACH ROW EXECUTE FUNCTION trg_log_service_change();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (1, 'Marriage');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (2, 'Death Proof');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (3, 'Birth Proof');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (4, 'Divorce');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (5, 'Adoption');"
    ],
    "summary": "Create a trigger function `trg_log_service_change` that, after inserting a row into the \"Services\" table, inserts a new row into the \"Events\" table. The new event's Event_ID is the maximum existing Event_ID plus one (or 1 if none exist), the Service_ID is taken from the new service row, and the Event_Details is the current timestamp as text. Create an AFTER INSERT FOR EACH ROW trigger named `log_service_change_trigger` on the \"Services\" table to execute this function.",
    "natural_language": "Please implement a trigger function designated as `trg_log_service_change`. This function shall be invoked subsequent to the insertion of a record into the \"Services\" table, with the purpose of inserting a corresponding entry into the \"Events\" table. The new event's Event_ID must be derived by incrementing the current maximum Event_ID by one, or assigned a value of one should no prior events exist. The Service_ID is to be sourced from the newly inserted service record, and the Event_Details must be populated with the current timestamp, formatted as text. Furthermore, establish an AFTER INSERT trigger, named `log_service_change_trigger`, configured to execute FOR EACH ROW on the \"Services\" table, thereby calling the aforementioned function.",
    "id": 140
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_department_ranking_on_budget_change` that is designed to be executed as a trigger, and a trigger named `adjust_ranking_after_budget_update` that invokes this function. The function `update_department_ranking_on_budget_change` is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon execution, this function performs a single `UPDATE` operation on the `department` table. The `UPDATE` statement targets a specific row in the `department` table where the `Department_ID` column matches the `Department_ID` value of the `NEW` record (the row currently being updated by the triggering statement). For this targeted row, the `Ranking` column is set to a new calculated value. This new value is determined by a subquery that counts the number of rows in the `department` table where the `Budget_in_Billions` column is strictly greater than the `Budget_in_Billions` value of the `NEW` record. To the result of this count, `1` is added. This effectively assigns a rank to the department based on its budget relative to other departments, where a higher budget results in a lower (better) rank. After performing this update, the function returns the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers in PostgreSQL. The `adjust_ranking_after_budget_update` trigger is defined to activate `AFTER UPDATE` operations on the `department` table. Specifically, it is configured to fire only when the `Budget_in_Billions` column of a row in the `department` table is updated. This is a `FOR EACH ROW` trigger, meaning the `update_department_ranking_on_budget_change` function will be executed once for each row that is affected by the `UPDATE` statement that modifies the `Budget_in_Billions` column. The trigger's purpose is to automatically recalculate and adjust the `Ranking` of a department whenever its `Budget_in_Billions` value changes, ensuring that the ranking reflects the current budget distribution among departments.",
    "plsql": "CREATE OR REPLACE FUNCTION update_department_ranking_on_budget_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE department SET \"Ranking\" = (SELECT COUNT(*) FROM department WHERE \"Budget_in_Billions\" > NEW.\"Budget_in_Billions\") + 1 WHERE \"Department_ID\" = NEW.\"Department_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_ranking_after_budget_update\nAFTER UPDATE OF \"Budget_in_Billions\" ON department\nFOR EACH ROW EXECUTE FUNCTION update_department_ranking_on_budget_change();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "UPDATE department SET \"Budget_in_Billions\" = 10.0 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Budget_in_Billions\" = 12.0 WHERE \"Department_ID\" = 2;",
      "UPDATE department SET \"Budget_in_Billions\" = 440.0 WHERE \"Department_ID\" = 3;",
      "UPDATE department SET \"Budget_in_Billions\" = 15.0 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Budget_in_Billions\" = 13.0 WHERE \"Department_ID\" = 2;"
    ],
    "summary": "Create a trigger function `update_department_ranking_on_budget_change` and a trigger `adjust_ranking_after_budget_update`. The trigger fires AFTER UPDATE OF Budget_in_Billions on the department table FOR EACH ROW. The function updates the department table, setting the Ranking column for the matching Department_ID to: 1 + (the count of departments with a Budget_in_Billions greater than the NEW row's budget). The function returns NEW.",
    "natural_language": "Create a trigger that, after a department's budget is updated, re-ranks it based on the new budget compared to others.",
    "id": 141
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `adjust_budget_based_on_employee_count` that is designed to be executed in response to data modifications on a specific table, and a trigger named `sync_budget_with_employees` that invokes this function. The `adjust_budget_based_on_employee_count` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon execution, this function performs a single `UPDATE` operation on the `department` table. The `UPDATE` statement modifies the value of the `\"Budget_in_Billions\"` column for a specific row. The new value for `\"Budget_in_Billions\"` is calculated by taking the value of the `NEW.\"Num_Employees\"` column, which represents the number of employees in the department *after* the triggering event, and multiplying it by a constant factor of `0.0001`. This calculation effectively scales the number of employees to determine the budget in billions. The `WHERE` clause of the `UPDATE` statement specifies that only the row where the `\"Department_ID\"` column matches the value of `NEW.\"Department_ID\"` should be updated. `NEW.\"Department_ID\"` refers to the department identifier of the row that caused the trigger to fire *after* the modification. After performing the update, the function returns `NEW`, which signifies that the modified row (or the row that triggered the event) should be used to complete the triggering statement. The `sync_budget_with_employees` trigger is defined to execute `AFTER UPDATE OF \"Num_Employees\"` on the `department` table. This means the trigger will activate only when the `\"Num_Employees\"` column of a row in the `department` table is updated. The `FOR EACH ROW` clause specifies that the trigger function `adjust_budget_based_on_employee_count` will be executed once for each row that is affected by the `UPDATE` statement. The `EXECUTE FUNCTION adjust_budget_based_on_employee_count()` clause explicitly calls the previously defined trigger function to perform its logic.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_budget_based_on_employee_count() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE department SET \"Budget_in_Billions\" = NEW.\"Num_Employees\" * 0.0001 WHERE \"Department_ID\" = NEW.\"Department_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sync_budget_with_employees\nAFTER UPDATE OF \"Num_Employees\" ON department\nFOR EACH ROW EXECUTE FUNCTION adjust_budget_based_on_employee_count();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "UPDATE department SET \"Num_Employees\" = 30000.0 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Num_Employees\" = 120000.0 WHERE \"Department_ID\" = 2;",
      "UPDATE department SET \"Num_Employees\" = 3100000.0 WHERE \"Department_ID\" = 3;",
      "UPDATE department SET \"Num_Employees\" = 50000.0 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Num_Employees\" = 100000.0 WHERE \"Department_ID\" = 2;"
    ],
    "summary": "Create a trigger function `adjust_budget_based_on_employee_count` and a trigger `sync_budget_with_employees`. The trigger fires AFTER UPDATE OF Num_Employees on the department table FOR EACH ROW. The function updates the department table, setting the Budget_in_Billions for the matching Department_ID to NEW.Num_Employees * 0.0001. The function returns NEW.",
    "natural_language": "Please implement a trigger function named `adjust_budget_based_on_employee_count` along with a corresponding trigger named `sync_budget_with_employees`. The trigger should be configured to execute subsequent to an update operation on the `Num_Employees` column within the `department` table, acting on each modified row. The function's purpose is to modify the `department` table by assigning a value of `NEW.Num_Employees` multiplied by 0.0001 to the `Budget_in_Billions` column for the relevant `Department_ID`. The function must conclude by returning the `NEW` row.",
    "id": 142
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `log_treatment_insertion` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` (representing the new row being inserted or updated) and `OLD` (representing the old row before an update or delete). The function is declared to return `TRIGGER`, indicating its purpose as a trigger function. The core operation of this function is to insert a new record into the table named `\"Treatments\"`. The `INSERT` statement populates the following columns in the `\"Treatments\"` table: `treatment_id`, `dog_id`, `professional_id`, `treatment_type_code`, `date_of_treatment`, and `cost_of_treatment`. The value for the `treatment_id` column is determined by a subquery: `(SELECT COALESCE(MAX(treatment_id), 0) + 1 FROM \"Treatments\")`. This subquery first selects the maximum value of the `treatment_id` column from the `\"Treatments\"` table. The `COALESCE` function is then applied to this maximum value, ensuring that if `MAX(treatment_id)` returns `NULL` (which would happen if the table is empty), it defaults to `0`. Finally, `1` is added to this result, effectively generating a new `treatment_id` that is one greater than the current highest `treatment_id` or `1` if the table was empty. The value for the `dog_id` column is taken directly from `NEW.dog_id`, which refers to the `dog_id` of the row that caused the trigger to fire. The `professional_id` column is assigned a static integer value of `1`. The `treatment_type_code` column is assigned a static string literal value of `'EXAM'`. The `date_of_treatment` column is set to the current timestamp using the `CURRENT_TIMESTAMP` function. The `cost_of_treatment` column is assigned a static numeric value of `100.0000`. After performing this insertion, the function returns `NEW`, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the original row that triggered the operation should be returned unchanged.\n\nAccompanying this function is a trigger named `log_treatment_insertion_trigger`. This trigger is defined to execute `AFTER INSERT` operations on the table named `\"Dogs\"`. It is a `FOR EACH ROW` trigger, meaning that the associated function (`log_treatment_insertion()`) will be executed once for every row that is inserted into the `\"Dogs\"` table. The trigger specifies that it should `EXECUTE FUNCTION log_treatment_insertion()`, thereby invoking the previously defined PL/pgSQL function `log_treatment_insertion` whenever a new row is successfully inserted into the `\"Dogs\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION log_treatment_insertion() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Treatments\" (treatment_id, dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES ((SELECT COALESCE(MAX(treatment_id), 0) + 1 FROM \"Treatments\"), NEW.dog_id, 1, 'EXAM', CURRENT_TIMESTAMP, 100.0000);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_treatment_insertion_trigger\nAFTER INSERT ON \"Dogs\"\nFOR EACH ROW EXECUTE FUNCTION log_treatment_insertion();",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Treatments",
      "Professionals",
      "Treatment_Types"
    ],
    "call_sqls": [
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (100, 1, '0', 'LAB', 'MED', 'Buddy', '5', '2018-01-01 00:00:00+00:00', '1', '25.00', '2023-01-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (101, 2, '1', 'GER', 'LGE', 'Max', '3', '2020-03-15 00:00:00+00:00', '0', '30.50', '2023-02-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (102, 3, '0', 'POO', 'SML', 'Daisy', '2', '2021-06-20 00:00:00+00:00', '1', '10.20', '2023-03-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (103, 4, '1', 'CHI', 'SML', 'Rocky', '7', '2016-09-10 00:00:00+00:00', '0', '5.70', '2023-04-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (104, 5, '0', 'BEA', 'MED', 'Lucy', '4', '2019-11-05 00:00:00+00:00', '1', '18.90', '2023-05-01 00:00:00+00:00', NULL, NULL);"
    ],
    "summary": "Create a trigger function `log_treatment_insertion` and a trigger `log_treatment_insertion_trigger`. The trigger fires AFTER INSERT on the Dogs table FOR EACH ROW. The function inserts a new record into the Treatments table with: treatment_id as the current max + 1 (or 1 if empty), dog_id from NEW, professional_id as 1, treatment_type_code as 'EXAM', date_of_treatment as CURRENT_TIMESTAMP, and cost_of_treatment as 100.0000. The function returns NEW.",
    "natural_language": "Please construct a trigger function named `log_treatment_insertion` along with an associated trigger designated as `log_treatment_insertion_trigger`. The trigger is to be configured to execute subsequent to any INSERT operation on the Dogs table, applying to each individual row. The function's operation shall be to insert a new entry into the Treatments table. The values for this entry are to be assigned as follows: the `treatment_id` shall be set to one greater than the current maximum value within the column, or to the value 1 if the table is presently empty; the `dog_id` is to be derived from the NEW record; the `professional_id` is to be set to 1; the `treatment_type_code` is to be assigned the value 'EXAM'; the `date_of_treatment` is to be set to the CURRENT_TIMESTAMP; and the `cost_of_treatment` is to be established as 100.0000. The function must conclude by returning the NEW record.",
    "id": 143
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an update operation on the \"Dogs\" table, specifically when the column date_departed transitions from a NULL value to a non-NULL value. The trigger function, named archive_departed_dog, is designed to delete records from the \"Treatments\" table where the dog_id matches the OLD.dog_id value from the \"Dogs\" table. The trigger, named archive_departed_dog_trigger, is defined to operate for each row affected by the update on the \"Dogs\" table, ensuring that the deletion in the \"Treatments\" table occurs only when a dog is marked as departed by setting the date_departed column from NULL to a specific date. The function returns the OLD record, which represents the state of the row before the update, allowing further operations or triggers to utilize this information if needed.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_departed_dog() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Treatments\" WHERE dog_id = OLD.dog_id;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER archive_departed_dog_trigger\nAFTER UPDATE ON \"Dogs\"\nFOR EACH ROW WHEN (OLD.date_departed IS NULL AND NEW.date_departed IS NOT NULL)\nEXECUTE FUNCTION archive_departed_dog();",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Treatments",
      "Professionals",
      "Treatment_Types"
    ],
    "call_sqls": [
      "UPDATE \"Dogs\" SET date_departed = '2024-01-15 10:00:00+08:00' WHERE dog_id = 1;",
      "UPDATE \"Dogs\" SET date_departed = CURRENT_TIMESTAMP WHERE dog_id = 2 AND date_departed IS NULL;",
      "UPDATE \"Dogs\" SET date_departed = '2024-01-20 14:30:00+00:00' WHERE dog_id = 3;",
      "UPDATE \"Dogs\" SET date_departed = NOW() WHERE dog_id = 14;",
      "UPDATE \"Dogs\" SET date_departed = '2024-01-25 09:15:00+08:00' WHERE dog_id = 4;"
    ],
    "summary": "Create a trigger function `archive_departed_dog` and a trigger `archive_departed_dog_trigger`. The trigger fires AFTER UPDATE OF date_departed on the Dogs table FOR EACH ROW, but only when OLD.date_departed IS NULL and NEW.date_departed IS NOT NULL. The function deletes from the Treatments table where dog_id equals OLD.dog_id. The function returns OLD.",
    "natural_language": "Alright, so we need to set up a trigger function called `archive_departed_dog` and a trigger named `archive_departed_dog_trigger`. This trigger should kick in AFTER we update the `date_departed` field in the Dogs table, but only for that specific row. It should only run if the old date was empty and the new date is now filled in. When it fires, the function's job is to clean out any records in the Treatments table that match the old dog's ID. Finally, the function should just hand back the OLD record.",
    "id": 144
  },
  {
    "ir": "Write a PLpgSQL function named create_exam_record that is designed to be executed as a trigger function. This function is triggered after an insert operation on the \"Treatments\" table, specifically when the treatment_type_code of the newly inserted row is 'VAC'. The function performs an insert operation into the \"Treatments\" table, creating a new record with the following values: the treatment_id is set to one more than the current maximum treatment_id in the \"Treatments\" table, or 1 if the table is empty; the dog_id is taken from the NEW row being inserted; the professional_id is also taken from the NEW row; the treatment_type_code is set to 'EXAM'; the date_of_treatment is taken from the NEW row; and the cost_of_treatment is calculated as half of the cost_of_treatment from the NEW row, rounded to two decimal places. The function then returns the NEW row, allowing the original insert operation to proceed. A trigger named create_exam_record_trigger is created to execute this function after each row insertion into the \"Treatments\" table, but only when the treatment_type_code of the inserted row is 'VAC'.",
    "plsql": "CREATE OR REPLACE FUNCTION create_exam_record() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Treatments\" (treatment_id, dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES ((SELECT COALESCE(MAX(treatment_id), 0) + 1 FROM \"Treatments\"), NEW.dog_id, NEW.professional_id, 'EXAM', NEW.date_of_treatment, ROUND(NEW.cost_of_treatment * 0.5, 2));\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER create_exam_record_trigger\nAFTER INSERT ON \"Treatments\"\nFOR EACH ROW WHEN (NEW.treatment_type_code = 'VAC')\nEXECUTE FUNCTION create_exam_record();",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Treatments",
      "Professionals",
      "Treatment_Types"
    ],
    "call_sqls": [
      "INSERT INTO \"Treatments\" (dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES (1, 1, 'VAC', '2023-10-01 10:00:00+08:00', 100.00);",
      "INSERT INTO \"Treatments\" (dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES (2, 2, 'VAC', '2023-10-02 11:00:00+08:00', 150.00);",
      "INSERT INTO \"Treatments\" (dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES (3, 3, 'VAC', '2023-10-03 12:00:00+08:00', 200.00);",
      "INSERT INTO \"Treatments\" (dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES (1, 2, 'VAC', '2023-10-04 13:00:00+08:00', 250.00);",
      "INSERT INTO \"Treatments\" (dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES (2, 3, 'VAC', '2023-10-05 14:00:00+08:00', 300.00);"
    ],
    "summary": "Create a trigger function `create_exam_record` and a trigger `create_exam_record_trigger`. The trigger fires AFTER INSERT on the Treatments table FOR EACH ROW, but only when NEW.treatment_type_code is 'VAC'. The function inserts a new record into the Treatments table with: treatment_id as the current max + 1 (or 1 if empty), dog_id from NEW, professional_id from NEW, treatment_type_code as 'EXAM', date_of_treatment from NEW, and cost_of_treatment as (NEW.cost_of_treatment / 2) rounded to two decimals. The function returns NEW.",
    "natural_language": "Alright, so we need a trigger function called `create_exam_record` and a trigger named `create_exam_record_trigger`. Set it up so that after a new row is added to the Treatments table, but only if the new treatment type is 'VAC', this trigger kicks in. The function should then pop a fresh record into the Treatments table. For that new record: make the treatment_id the next number up (start at 1 if the table's empty), grab the dog_id and pro_id from the new row, set the treatment type to 'EXAM', use the same date from the new row, and for the cost, just take half of the new row's cost and round it to two cents. Oh, and the function should spit back the NEW row.",
    "id": 145
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically inserts a new row into the \"Treatments\" table whenever a row is deleted from the same table, provided that the deleted row has a treatment_type_code of 'EXAM'. The function, named add_followup_treatment, is executed after a DELETE operation on the \"Treatments\" table. It inserts a new treatment record with the following details: a unique treatment_id generated by the nextval function using the sequence associated with the treatment_id column, the same dog_id and professional_id as the deleted row, a treatment_type_code set to 'WALK', a date_of_treatment set to the current timestamp plus seven days, and a cost_of_treatment set to 50.0000. The trigger, named add_followup_treatment_trigger, is defined to execute this function for each row that is deleted, but only when the treatment_type_code of the deleted row is 'EXAM'. The function returns the OLD record, which represents the row that was deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION add_followup_treatment() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Treatments\" (treatment_id, dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment)\n  VALUES (nextval(pg_get_serial_sequence('\"Treatments\"', 'treatment_id')), OLD.dog_id, OLD.professional_id, 'WALK', CURRENT_TIMESTAMP + INTERVAL '7 days', 50.0000);\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER add_followup_treatment_trigger\nAFTER DELETE ON \"Treatments\"\nFOR EACH ROW WHEN (OLD.treatment_type_code = 'EXAM')\nEXECUTE FUNCTION add_followup_treatment();",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Treatments",
      "Professionals",
      "Treatment_Types"
    ],
    "call_sqls": [
      "DELETE FROM \"Treatments\" WHERE treatment_id = 1 AND treatment_type_code = 'EXAM';",
      "DELETE FROM \"Treatments\" WHERE treatment_id = 2 AND treatment_type_code = 'EXAM';",
      "DELETE FROM \"Treatments\" WHERE treatment_id = 3 AND treatment_type_code = 'EXAM';",
      "DELETE FROM \"Treatments\" WHERE treatment_id = 4 AND treatment_type_code = 'EXAM';",
      "DELETE FROM \"Treatments\" WHERE treatment_id = 5 AND treatment_type_code = 'EXAM';"
    ],
    "summary": "Create an AFTER DELETE row-level trigger function named add_followup_treatment that inserts a new row into the Treatments table when a deleted row has treatment_type_code 'EXAM'. The new row uses a sequence for treatment_id, copies dog_id and professional_id, sets treatment_type_code to 'WALK', date_of_treatment to CURRENT_TIMESTAMP + 7 days, and cost_of_treatment to 50.0000. The function returns OLD. Create a trigger named add_followup_treatment_trigger to execute it.",
    "natural_language": "Create trigger add_followup_treatment_trigger. After deleting a row with treatment_type_code 'EXAM', insert a new row into Treatments. Use sequence for treatment_id, copy dog_id and professional_id, set treatment_type_code to 'WALK', date_of_treatment to CURRENT_TIMESTAMP + 7 days, cost to 50.0000. Trigger function add_followup_treatment returns OLD.",
    "id": 146
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the \"Customers\" table. This function, named remove_customer_events, does not take any parameters and returns a trigger type. It performs a delete operation on the \"Customer_Events\" table, specifically removing all rows where the customer_id column matches the customer_id of the row being deleted from the \"Customers\" table, as referenced by OLD.customer_id. The function then returns the OLD record, which represents the row in the \"Customers\" table that is about to be deleted. The trigger, named trg_remove_customer_events, is defined to fire before a delete operation on each row of the \"Customers\" table, ensuring that any associated events in the \"Customer_Events\" table are removed prior to the deletion of a customer record.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_customer_events() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM \"Customer_Events\" WHERE customer_id = OLD.customer_id;\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_remove_customer_events\nBEFORE DELETE ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION remove_customer_events();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Residents",
      "Things"
    ],
    "call_sqls": [
      "DELETE FROM \"Customers\" WHERE customer_id = 4;",
      "DELETE FROM \"Customers\" WHERE customer_id = 5;",
      "DELETE FROM \"Customers\" WHERE customer_id = 16;",
      "DELETE FROM \"Customers\" WHERE customer_id = 19;",
      "DELETE FROM \"Customers\" WHERE customer_details = 'Mr. Raul Prosacco';"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger function named remove_customer_events that deletes all rows from the Customer_Events table where customer_id matches OLD.customer_id from the Customers table. The function returns OLD. Create a trigger named trg_remove_customer_events to execute it.",
    "natural_language": "Set up a trigger function that runs before a customer is deleted. It should clear out any related entries in the Customer_Events table for that specific customer. Also, make sure the function gives back the old record. Then, create a trigger to call this function.",
    "id": 147
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the update of any row in the \"Residents\" table, inserts a new row into the same \"Residents\" table. This new row will have the resident_id column set to the value of the updated row's resident_id plus 1000, the property_id column set to the updated row's property_id, the date_moved_in column set to the updated row's date_moved_in, and the other_details column set to the uppercase version of the updated row's other_details. The trigger, named trg_archive_resident_data, is defined to execute this function after any update operation on each row of the \"Residents\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_resident_data() RETURNS TRIGGER AS $$\nBEGIN\nINSERT INTO \"Residents\" (resident_id, property_id, date_moved_in, other_details) VALUES (NEW.resident_id + 1000, NEW.property_id, NEW.date_moved_in, UPPER(NEW.other_details));\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_archive_resident_data\nAFTER UPDATE ON \"Residents\"\nFOR EACH ROW EXECUTE FUNCTION archive_resident_data();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Residents",
      "Things"
    ],
    "call_sqls": [
      "UPDATE \"Residents\" SET other_details = 'Updated details' WHERE resident_id = 6;",
      "UPDATE \"Residents\" SET date_moved_out = CURRENT_TIMESTAMP WHERE property_id = 605;",
      "UPDATE \"Residents\" SET property_id = 999 WHERE resident_id = 10;",
      "UPDATE \"Residents\" SET other_details = 'New resident info' WHERE resident_id = 23;",
      "UPDATE \"Residents\" SET date_moved_in = '2024-01-01 00:00:00+00:00' WHERE property_id = 879;"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger function that inserts a new row into the Residents table. The new row sets resident_id to OLD.resident_id + 1000, copies property_id and date_moved_in, and sets other_details to UPPER(OLD.other_details). Create a trigger named trg_archive_resident_data to execute it.",
    "natural_language": "Write an AFTER UPDATE row-level trigger function to insert a new row into the Residents table. Set the new resident_id to OLD.resident_id + 1000, copy the property_id and date_moved_in, and set other_details to UPPER(OLD.other_details). Then, create a trigger called trg_archive_resident_data to run this function.",
    "id": 148
  },
  {
    "ir": "Write a PostgreSQL trigger function named cleanup_thing_events that returns a trigger, which is executed by a trigger named trg_cleanup_thing_events defined on the Things table, where the trigger fires BEFORE DELETE for each individual row being deleted, and within the function body, it performs a DELETE operation on the table named Customer_Events, specifically targeting all rows in the Customer_Events table where the column thing_id matches the value of the thing_id column from the OLD record (which represents the row being deleted from the Things table), and after the deletion, the function returns the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_thing_events() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM \"Customer_Events\" WHERE thing_id = OLD.thing_id;\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_thing_events\nBEFORE DELETE ON \"Things\"\nFOR EACH ROW EXECUTE FUNCTION cleanup_thing_events();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Residents",
      "Things"
    ],
    "call_sqls": [
      "DELETE FROM \"Things\" WHERE thing_id = 1;",
      "DELETE FROM \"Things\" WHERE thing_id = 2;",
      "DELETE FROM \"Things\" WHERE thing_id = 10;",
      "DELETE FROM \"Things\" WHERE thing_id = 80;",
      "DELETE FROM \"Things\" WHERE thing_id = 14;"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger function named cleanup_thing_events that deletes all rows from the Customer_Events table where thing_id matches OLD.thing_id from the Things table. The function returns OLD. Create a trigger named trg_cleanup_thing_events to execute it.",
    "natural_language": "Create a row-level trigger function called cleanup_thing_events that fires BEFORE DELETE. It must delete all matching rows from the Customer_Events table where the thing_id equals the OLD.thing_id from the Things table. Ensure the function returns OLD. Then, define a trigger named trg_cleanup_thing_events to run this function.",
    "id": 149
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `validate_problem_status` that is designed to be executed as a trigger. This function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records from the trigger context. The `NEW` record represents the new row that is being inserted or updated, and the `OLD` record represents the old row before the update or deletion (though `OLD` is not used in this specific function). The function returns a `TRIGGER` type, indicating its role as a trigger function. Inside the function, a conditional `CASE` statement is evaluated. The condition checks for the existence of a record in the table named `\"Problem_Status_Codes\"`. This check is performed by executing a `SELECT` statement that attempts to retrieve the value `1` (a common practice for existence checks, as the actual value doesn't matter, only the presence of a row) from `\"Problem_Status_Codes\"`. The `WHERE` clause of this `SELECT` statement filters the rows based on the condition `problem_status_code = NEW.problem_status_code`. This means it looks for a row in `\"Problem_Status_Codes\"` where the value in its `problem_status_code` column matches the value of the `problem_status_code` column from the `NEW` record (the row being inserted into `\"Problem_Log\"`). If this `EXISTS` condition evaluates to `TRUE` (meaning a matching `problem_status_code` was found in `\"Problem_Status_Codes\"`), the `CASE` statement returns the `NEW` record. This signifies that the insertion or update operation should proceed with the new row as provided. If the `EXISTS` condition evaluates to `FALSE` (meaning no matching `problem_status_code` was found in `\"Problem_Status_Codes\"`), the `CASE` statement returns `NULL`. Returning `NULL` from a `BEFORE` row-level trigger effectively aborts the `INSERT` or `UPDATE` operation for that specific row, preventing it from being added or modified in the table.\n\nFollowing the function definition, a trigger named `validate_status_trigger` is created. This trigger is configured to execute `BEFORE INSERT` operations on the table named `\"Problem_Log\"`. It is a `FOR EACH ROW` trigger, meaning the `validate_problem_status()` function will be executed once for each row that is being inserted into `\"Problem_Log\"`. The `EXECUTE FUNCTION validate_problem_status()` clause specifies that the previously defined `validate_problem_status` function should be invoked when the trigger fires. The overall purpose of this trigger and function combination is to enforce referential integrity or data validation: it ensures that any `problem_status_code` being inserted into the `\"Problem_Log\"` table must already exist as a valid `problem_status_code` in the `\"Problem_Status_Codes\"` table. If the `problem_status_code` is not found in `\"Problem_Status_Codes\"`, the insertion into `\"Problem_Log\"` is prevented.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_problem_status() RETURNS TRIGGER AS $$\nBEGIN\n  RETURN CASE WHEN EXISTS (SELECT 1 FROM \"Problem_Status_Codes\" WHERE problem_status_code = NEW.problem_status_code) THEN NEW ELSE NULL END;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_status_trigger\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION validate_problem_status();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problems",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problem_Category_Codes"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 11, 8, 'GUI', 'Reported', '2024-01-15 10:30:00+00:00', 'UI issue reported', NULL, 'Initial report');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 12, 11, 'Middleware', 'Solved', '2024-01-15 11:45:00+00:00', 'Middleware connection fixed', 'Restarted service', 'Resolved');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 13, 1, 'Datatabase', 'Reported', '2024-01-16 09:15:00+00:00', 'Database performance issue', NULL, 'Needs investigation');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 14, 2, 'GUI', 'In Progress', '2024-01-16 14:20:00+00:00', 'Button not working', 'Fixed click handler', 'Testing required');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 15, 3, 'Middleware', 'Closed', '2024-01-17 16:00:00+00:00', 'API timeout resolved', 'Increased timeout setting', 'Verified fix');"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger function named validate_problem_status for the Problem_Log table. The function checks if NEW.problem_status_code exists in the Problem_Status_Codes table. If it exists, return NEW; otherwise, return NULL to abort the operation. Create a trigger named validate_status_trigger to execute it.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger function, to be named validate_problem_status, specifically for the Problem_Log table. This detailed function must meticulously verify whether the value for NEW.problem_status_code is already present within the Problem_Status_Codes table. Should this check confirm a valid, existing code, the function will gracefully return the NEW record to allow the operation. Conversely, if the code is not found, thereby being invalid, the function will deliberately return a NULL value, which effectively aborts the entire insertion attempt. Furthermore, you must create an associated trigger, named validate_status_trigger, which is responsible for executing this validation function automatically before each insert.",
    "id": 150
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Problem_Log\" table. The function, named validate_problem_exists, does not take any parameters directly but operates on the NEW record being inserted into the \"Problem_Log\" table. It checks if there is an existing record in the \"Problems\" table with a problem_id that matches the problem_id of the NEW record. This is done using a SELECT statement with the EXISTS condition, which queries the \"Problems\" table to see if any row contains the same problem_id as the NEW record. If such a record exists, the function returns the NEW record, allowing the insert operation to proceed. If no matching record is found, the function returns NULL, effectively preventing the insertion of the NEW record into the \"Problem_Log\" table. The trigger, named validate_problem_trigger, is defined to execute this function for each row before an insert operation on the \"Problem_Log\" table, ensuring that only records with a valid problem_id already present in the \"Problems\" table are inserted into the \"Problem_Log\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_problem_exists() RETURNS TRIGGER AS $$\nBEGIN\n  RETURN CASE WHEN EXISTS (SELECT 1 FROM \"Problems\" WHERE problem_id = NEW.problem_id) THEN NEW ELSE NULL END;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_problem_trigger\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION validate_problem_exists();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problems",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problem_Category_Codes"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 11, 1, 'Middleware', 'Solved', NOW(), 'Test description', 'Test fix', 'Test details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 12, 2, 'GUI', 'Reported', NOW(), 'Another description', NULL, NULL);",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 13, 3, 'Datatabase', 'Solved', NOW(), 'Database issue', 'Fixed index', NULL);",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 14, 999, 'Middleware', 'Reported', NOW(), 'Invalid problem', NULL, NULL);",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 15, 8, 'GUI', 'Solved', NOW(), 'Valid entry', 'Applied patch', 'Additional notes');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named validate_problem_exists for the Problem_Log table. It must check if the NEW.problem_id exists in the Problems table. If it exists, return NEW to allow the insert; otherwise, return NULL to prevent it.",
    "natural_language": "Construct a BEFORE INSERT trigger function, to be named validate_problem_exists, for the Problem_Log table. This function must meticulously verify whether the NEW.problem_id value is present within the Problems table. If a corresponding entry is indeed found, the function should return NEW to explicitly permit the insertion to proceed. Conversely, if no matching record exists, it must return NULL, thereby definitively blocking the operation to maintain data integrity.",
    "id": 151
  },
  {
    "ir": "Write a PostgreSQL trigger function named enhance_log_details that is executed automatically before each insert operation on the Problem_Log table, which first ensures the existence of a sequence named problem_log_id_seq and sets its next value to one greater than the current maximum problem_log_id in the Problem_Log table, and within the function body, checks if the NEW record's problem_log_id column is null and, if so, assigns it the next value from the problem_log_id_seq sequence, then updates the NEW record's other_log_details column by concatenating its existing value (or an empty string if null via the COALESCE function) with a literal string ' - Status: ' and the problem_status_description retrieved from the Problem_Status_Codes table where the problem_status_code column matches the NEW record's problem_status_code column, using 'Unknown' as a fallback via COALESCE if no matching description is found, and finally returns the modified NEW record for insertion.",
    "plsql": "CREATE SEQUENCE IF NOT EXISTS problem_log_id_seq;\nSELECT setval('problem_log_id_seq', COALESCE((SELECT MAX(problem_log_id) FROM \"Problem_Log\"), 0) + 1, false);\n\nCREATE OR REPLACE FUNCTION enhance_log_details() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.problem_log_id IS NULL THEN\n    NEW.problem_log_id := nextval('problem_log_id_seq');\n  END IF;\n  \n  NEW.other_log_details := COALESCE(NEW.other_log_details, '') || ' - Status: ' || COALESCE((SELECT problem_status_description FROM \"Problem_Status_Codes\" WHERE problem_status_code = NEW.problem_status_code), 'Unknown');\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER enhance_details_trigger\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION enhance_log_details();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problems",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problem_Category_Codes"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix) VALUES (11, 8, 'GUI', 'Solved', NOW(), 'UI button not responding', 'Fixed click handler');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description) VALUES (DEFAULT, 12, 11, 'Middleware', 'Reported', '2024-01-15 10:30:00+00', 'Server timeout issue');",
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, other_log_details) VALUES (15, 1, 'Datatabase', 'Solved', '2024-01-16 14:45:00+00', 'Slow query performance', 'Initial details');",
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix) VALUES (18, 3, 'GUI', '2024-01-17 09:15:00+00', 'Layout broken on mobile', 'Updated CSS media queries');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (NULL, 20, 5, 'Middleware', 'Reported', '2024-01-18 16:20:00+00', 'API authentication failing', 'Pending investigation', 'Previous attempt logged');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named enhance_log_details for the Problem_Log table. It must ensure a sequence problem_log_id_seq exists and set its next value to max(problem_log_id)+1. If NEW.problem_log_id is null, assign the next sequence value. Then, update NEW.other_log_details by concatenating its current value (or empty string) with ' - Status: ' and the problem_status_description from Problem_Status_Codes where problem_status_code matches NEW.problem_status_code, using 'Unknown' as a fallback. Return the modified NEW.",
    "natural_language": "Set up a trigger that runs before adding entries to the Problem_Log table, call it something like enhance_log_details. It should check for a sequence, maybe named problem_log_id_seq, and if it's there, adjust it so its next number is a bit higher than the biggest problem_log_id we already have. If the new entry doesn't have a problem_log_id, just grab the next number from that sequence. Also, tweak the other_log_details field by tacking on something about the status. Look up the description for the new entry's status code from the Problem_Status_Codes list, and if you can't find it, just use a placeholder like 'Unknown'. Finally, make sure the updated new entry is used.",
    "id": 152
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after a new row is inserted into the \"Complaints\" table. This function, named trg_prevent_discontinued_product_complaint, checks if the product associated with the newly inserted complaint, identified by NEW.product_id, exists in the \"Products\" table and has a non-null value in the date_product_discontinued column, indicating that the product has been discontinued. If such a product is found, the function deletes the newly inserted complaint from the \"Complaints\" table using the complaint_id from the NEW row. The function returns the NEW row after execution. The trigger named prevent_discontinued_product_complaint is created to automatically invoke this function for each row after an insert operation on the \"Complaints\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_prevent_discontinued_product_complaint() RETURNS TRIGGER AS $$\nBEGIN\nIF EXISTS (SELECT 1 FROM \"Products\" WHERE product_id = NEW.product_id AND date_product_discontinued IS NOT NULL) THEN\nDELETE FROM \"Complaints\" WHERE complaint_id = NEW.complaint_id;\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER prevent_discontinued_product_complaint\nAFTER INSERT ON \"Complaints\"\nFOR EACH ROW EXECUTE FUNCTION trg_prevent_discontinued_product_complaint();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, staff_id) VALUES (1001, 117, 113, 'OK', 'New', 'Product Failure', CURRENT_TIMESTAMP, 114);",
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, staff_id) VALUES (1002, 118, 114, 'Pending', 'New', 'Product Unusable', CURRENT_TIMESTAMP, 115);",
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, staff_id) VALUES (1003, 119, 115, 'OK', 'New', 'Product Failure', CURRENT_TIMESTAMP, 116);",
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, staff_id) VALUES (1004, 120, 113, 'OK', 'New', 'Product Failure', CURRENT_TIMESTAMP, 114);",
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, staff_id) VALUES (1005, 121, 114, 'Pending', 'New', 'Product Unusable', CURRENT_TIMESTAMP, 115);"
    ],
    "summary": "Create an AFTER INSERT trigger function named trg_prevent_discontinued_product_complaint for the Complaints table. It must check if the NEW.product_id exists in the Products table and has a non-null date_product_discontinued. If such a product is found, delete the newly inserted complaint from Complaints using NEW.complaint_id. Return NEW.",
    "natural_language": "How can I create an AFTER INSERT trigger function called trg_prevent_discontinued_product_complaint for the Complaints table that checks if the NEW.product_id is for a discontinued product and, if so, deletes the new complaint?",
    "id": 153
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an update operation on the \"Complaints\" table. This function, named trg_update_customer_type_on_complaint, does not take any parameters directly but operates on the NEW record, which represents the new state of a row after an update. The function checks if the complaint_status_code column of the NEW record is equal to 'Closed'. If this condition is true, it performs an update operation on the \"Customers\" table, setting the customer_type_code column to 'Reviewed' for the row where the customer_id matches the customer_id from the NEW record. The function then returns the NEW record. This trigger function is associated with a trigger named update_customer_type_on_complaint, which is defined to fire after an update on each row of the \"Complaints\" table, ensuring that the function is executed for every row that is updated in the \"Complaints\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_customer_type_on_complaint() RETURNS TRIGGER AS $$\nBEGIN\nIF NEW.complaint_status_code = 'Closed' THEN\nUPDATE \"Customers\" SET customer_type_code = 'Reviewed' WHERE customer_id = NEW.customer_id;\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_customer_type_on_complaint\nAFTER UPDATE ON \"Complaints\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_customer_type_on_complaint();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 1;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 2;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 3;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 1 AND customer_id = 120;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 2 AND customer_id = 113;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_update_customer_type_on_complaint for the Complaints table. If NEW.complaint_status_code equals 'Closed', update the Customers table, setting customer_type_code to 'Reviewed' where customer_id matches NEW.customer_id. Return NEW.",
    "natural_language": "How can I create an AFTER UPDATE trigger function called trg_update_customer_type_on_complaint for the Complaints table that, when NEW.complaint_status_code is 'Closed', updates the Customers table to set customer_type_code to 'Reviewed' for the matching customer_id, and then returns NEW?",
    "id": 154
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `trg_update_product_availability` that is designed to be executed after an `UPDATE` operation on the `\"Complaints\"` table, for each row affected by the update. This function takes no explicit parameters but operates on the special `NEW` record, which represents the new row data after the update. The function's primary purpose is to conditionally update the `date_product_first_available` column in the `\"Products\"` table. Specifically, it first checks a condition: if the `date_complaint_closed` column in the `NEW` record (i.e., the updated value of the `date_complaint_closed` for the current row in `\"Complaints\"`) is not `NULL`, then it proceeds with an `UPDATE` operation. This `UPDATE` targets the `\"Products\"` table, setting the `date_product_first_available` column to the current timestamp, obtained using the `NOW()` function. This update is applied only to the row in the `\"Products\"` table where the `product_id` column matches the value of the `product_id` column from the `NEW` record (i.e., the `product_id` associated with the updated complaint). After this conditional update, the function returns the `NEW` record, which is standard behavior for `AFTER ROW` triggers in PostgreSQL. The trigger itself, named `update_product_availability`, is defined to execute this `trg_update_product_availability` function `AFTER UPDATE` on the `\"Complaints\"` table `FOR EACH ROW`.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_product_availability() RETURNS TRIGGER AS $$\nBEGIN\nIF NEW.date_complaint_closed IS NOT NULL THEN\nUPDATE \"Products\" SET date_product_first_available = NOW() WHERE product_id = NEW.product_id;\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_product_availability\nAFTER UPDATE ON \"Complaints\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_product_availability();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Complaints\" SET date_complaint_closed = '2023-10-01 12:00:00+08:00' WHERE complaint_id = 1;",
      "UPDATE \"Complaints\" SET date_complaint_closed = '2023-10-02 12:00:00+08:00' WHERE complaint_id = 2;",
      "UPDATE \"Complaints\" SET date_complaint_closed = '2023-10-03 12:00:00+08:00' WHERE complaint_id = 3;",
      "UPDATE \"Complaints\" SET date_complaint_closed = '2023-10-04 12:00:00+08:00' WHERE complaint_id = 1;",
      "UPDATE \"Complaints\" SET date_complaint_closed = '2023-10-05 12:00:00+08:00' WHERE complaint_id = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_update_product_availability for the Complaints table. If NEW.date_complaint_closed is not NULL, update the Products table, setting date_product_first_available to NOW() where product_id matches NEW.product_id. Return NEW.",
    "natural_language": "Please construct an AFTER UPDATE trigger function designated as trg_update_product_availability for the Complaints table. The function's logic is as follows: upon detection that the NEW.date_complaint_closed value is not NULL, execute an update on the Products table. Set the date_product_first_available field to the current timestamp, NOW(), specifically for records where the product_id corresponds to NEW.product_id. The function must conclude by returning the NEW row.",
    "id": 155
  },
  {
    "ir": "Write a PostgreSQL trigger function named log_department_changes that returns a trigger and is executed automatically by a trigger named trg_log_department_changes, which is defined to fire after every row update operation on the department table; the function's logic unconditionally performs a single INSERT operation into the department table, specifying literal values for all six columns: it inserts a new row with a Department_ID of 999, a Name of 'Audit Log', a Creation year of '2024', a Ranking of 0, a Budget_in_Billions of 0.0, and a Num_Employees of 0.0; after the insert, the function returns NULL to indicate the triggering operation should proceed normally but no further row-level action is required by the trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION log_department_changes() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (999, 'Audit Log', '2024', 0, 0.0, 0.0);\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_department_changes\nAFTER UPDATE ON \"department\"\nFOR EACH ROW EXECUTE FUNCTION log_department_changes();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "UPDATE \"department\" SET \"Name\" = 'State Department' WHERE \"Department_ID\" = 1;",
      "UPDATE \"department\" SET \"Ranking\" = 2 WHERE \"Department_ID\" = 2;",
      "UPDATE \"department\" SET \"Budget_in_Billions\" = 450.0 WHERE \"Department_ID\" = 3;",
      "UPDATE \"department\" SET \"Num_Employees\" = 3100000.0 WHERE \"Department_ID\" = 1;",
      "UPDATE \"department\" SET \"Creation\" = '1790' WHERE \"Department_ID\" = 2;"
    ],
    "summary": "Create a PostgreSQL trigger function named log_department_changes that fires AFTER UPDATE on the department table for each row. The function inserts a fixed audit row into the department table with values (999, 'Audit Log', '2024', 0, 0.0, 0.0) and returns NULL.",
    "natural_language": "Make a PostgreSQL trigger function called log_department_changes. It runs AFTER UPDATE on department for each row. It inserts (999, 'Audit Log', '2024', 0, 0.0, 0.0) into department and returns NULL.",
    "id": 156
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger that is named `trg_cleanup_orphaned_records` and is activated immediately after a `DELETE` operation is performed on the table named `\"head\"`. This trigger is configured to execute for each individual row that is deleted from the `\"head\"` table. Upon activation, the trigger invokes a function named `cleanup_orphaned_records()`. The `cleanup_orphaned_records()` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Inside this function, a `DELETE` operation is executed on the table named `\"management\"`. This `DELETE` operation targets and removes rows from the `\"management\"` table where the value in the column named `\"head_ID\"` is equal to the value of the `\"head_ID\"` column from the row that was just deleted from the `\"head\"` table. The `OLD` keyword refers to the row that was deleted from the `\"head\"` table, and `OLD.\"head_ID\"` specifically accesses the value of the `\"head_ID\"` column from that deleted row. After performing the deletion from the `\"management\"` table, the `cleanup_orphaned_records()` function explicitly returns `NULL`. This `NULL` return value is a requirement for `AFTER` triggers in PostgreSQL, signifying that the trigger has completed its operation and does not intend to modify the data being operated on by the triggering statement.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_orphaned_records() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"management\" WHERE \"head_ID\" = OLD.\"head_ID\";\n  RETURN NULL; -- For AFTER triggers, the function must return NULL\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_orphaned_records\nAFTER DELETE ON \"head\"\nFOR EACH ROW EXECUTE FUNCTION cleanup_orphaned_records();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "DELETE FROM head WHERE head_ID = 1;",
      "DELETE FROM head WHERE head_ID = 2;",
      "DELETE FROM head WHERE head_ID = 3;",
      "DELETE FROM head WHERE head_ID = 4;",
      "DELETE FROM head WHERE head_ID = 5;"
    ],
    "summary": "Create a PostgreSQL trigger function named cleanup_orphaned_records that fires AFTER DELETE on the \"head\" table for each row. The function deletes rows from the \"management\" table where \"head_ID\" equals OLD.\"head_ID\" and returns NULL.",
    "natural_language": "Define a PostgreSQL trigger function called cleanup_orphaned_records that executes AFTER DELETE on the \"head\" table for each row. This function must remove rows from the \"management\" table where \"head_ID\" matches OLD.\"head_ID\" and should return NULL.",
    "id": 157
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `update_management_status` that, when executed, performs an insertion operation into the `management` table. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The `NEW` record represents the new row data after an `UPDATE` operation on the `department` table. The insertion operation targets three specific columns in the `management` table: `department_ID`, `head_ID`, and `temporary_acting`. The value for the `department_ID` column is sourced directly from the `Department_ID` column of the `NEW` record, which corresponds to the updated row in the `department` table. The value for the `head_ID` column is a static integer literal `1`. The value for the `temporary_acting` column is generated by the `localtimestamp` function, which provides the current date and time of the transaction. After performing this insertion, the function returns the `NEW` record, allowing the `UPDATE` operation on the `department` table to proceed with the modified row.\n\nThis trigger function is associated with a trigger named `trg_update_management_status`. This trigger is configured to activate `AFTER UPDATE` operations on the `department` table. The `FOR EACH ROW` clause specifies that the trigger function `update_management_status()` will be executed once for each row that is updated in the `department` table. Therefore, whenever a row in the `department` table is successfully updated, the `update_management_status` function will be invoked, leading to the insertion of a new record into the `management` table, populating its `department_ID` with the `Department_ID` of the updated department, setting `head_ID` to `1`, and `temporary_acting` to the current timestamp.",
    "plsql": "CREATE OR REPLACE FUNCTION update_management_status() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"management\" (\"department_ID\", \"head_ID\", \"temporary_acting\") \n  VALUES (NEW.\"Department_ID\", 1, localtimestamp);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_management_status\nAFTER UPDATE ON \"department\"\nFOR EACH ROW EXECUTE FUNCTION update_management_status();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "UPDATE department SET \"Name\" = 'New State' WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Budget_in_Billions\" = 10.5 WHERE \"Department_ID\" = 2;",
      "UPDATE department SET \"Num_Employees\" = 35000 WHERE \"Department_ID\" = 3;",
      "UPDATE department SET \"Ranking\" = 4 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Creation\" = '1790' WHERE \"Department_ID\" = 2;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_management_status that fires AFTER UPDATE on the department table for each row. The function inserts a row into the management table using NEW.Department_ID for department_ID, 1 for head_ID, and localtimestamp for temporary_acting, then returns NEW.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'update_management_status'. This function is to be executed subsequent to any UPDATE operation performed on the 'department' table, applying to each modified row. Its operation entails inserting a new record into the 'management' table, utilizing the NEW.Department_ID value for the department_ID column, assigning the integer 1 to the head_ID column, and employing the localtimestamp for the temporary_acting column. The function must conclude by returning the NEW row.",
    "id": 158
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_church_open_date_trigger that is executed automatically by a BEFORE INSERT trigger named church_open_date_update_trigger on the church table for each new row. The function first checks for the existence of a record in the church table where the Church_ID column value matches the Church_ID value of the new row (NEW.Church_ID). If such a record exists, the function performs an UPDATE operation on the church table, targeting the row with the matching Church_ID, setting its Open_Date column to the value of NEW.Open_Date incremented by one day, and also updating the Name, Organized_by, and Continuation_of columns to the corresponding values from the NEW row; after this update, the function returns NULL to cancel the original INSERT operation. If no existing record with the matching Church_ID is found, the function proceeds with the insertion by modifying the NEW row's Open_Date column, incrementing its value by one day, and then returns this modified NEW row to allow the INSERT to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION update_church_open_date_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if Church_ID already exists\n    IF EXISTS (SELECT 1 FROM \"church\" WHERE \"Church_ID\" = NEW.\"Church_ID\") THEN\n        -- Update the existing record instead of inserting a new one\n        UPDATE \"church\" \n        SET \"Open_Date\" = NEW.\"Open_Date\" + 1,\n            \"Name\" = NEW.\"Name\",\n            \"Organized_by\" = NEW.\"Organized_by\",\n            \"Continuation_of\" = NEW.\"Continuation_of\"\n        WHERE \"Church_ID\" = NEW.\"Church_ID\";\n        RETURN NULL; -- Skip the insert\n    ELSE\n        -- Proceed with new insertion\n        NEW.\"Open_Date\" := NEW.\"Open_Date\" + 1;\n        RETURN NEW;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER church_open_date_update_trigger\n    BEFORE INSERT ON \"church\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_church_open_date_trigger();",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (1, 'Pure Church of Christ', 'Wycam Clark', 1831, 'Church of Christ');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (2, 'Independent Church', '– Hoton', 1832, 'Church of the Latter Day Saint...');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (3, 'Church of Christ', 'Ezra Booth', 1836, 'Church of Christ');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (4, 'New Church', 'John Doe', 1840, 'Old Church');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (5, 'Another Church', 'Jane Smith', 1850, 'Another Old Church');"
    ],
    "summary": "Create a PostgreSQL trigger function named update_church_open_date_trigger that fires BEFORE INSERT on the church table for each row. If a row with the same Church_ID exists, update that row's Open_Date to NEW.Open_Date + 1 day and other columns from NEW, then return NULL to cancel the INSERT. If no matching row exists, increment NEW.Open_Date by one day and return NEW.",
    "natural_language": "Write a PostgreSQL trigger function called update_church_open_date_trigger that executes BEFORE INSERT on the church table for each row. For an existing row with the same Church_ID, update that row's Open_Date to NEW.Open_Date plus one day and sync the other columns from NEW, then return NULL to cancel the insert. If no matching row is found, increase NEW.Open_Date by one day and return NEW.",
    "id": 159
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `insert_wedding_record_trigger` that is designed to be executed after an `INSERT` operation on the `people` table, for each row inserted. This function does not accept any explicit input parameters but implicitly receives trigger-specific variables. It declares a local variable named `church_id_val` of type `INTEGER`. The function's primary purpose is to insert a new record into the `wedding` table.\n\nFirst, within the function's execution block, it attempts to retrieve a single `Church_ID` value from the `church` table. This is achieved by executing a `SELECT` statement: `SELECT \"Church_ID\" INTO church_id_val FROM \"church\" LIMIT 1;`. This statement selects the `Church_ID` column from the `church` table and assigns the value of the first retrieved row to the `church_id_val` variable.\n\nFollowing this, a conditional check is performed: `IF church_id_val IS NULL THEN church_id_val := 1; END IF;`. This `IF` statement evaluates whether the `church_id_val` variable is `NULL`. If `church_id_val` is indeed `NULL`, indicating that no `Church_ID` was found in the `church` table (e.g., if the `church` table is empty), then `church_id_val` is explicitly assigned the default integer value of `1`.\n\nSubsequently, an `INSERT` operation is executed on the `wedding` table. The `INSERT` statement is: `INSERT INTO \"wedding\" (\"Church_ID\", \"Male_ID\", \"Female_ID\", \"Year\") VALUES (church_id_val, NEW.\"People_ID\", NEW.\"People_ID\" + 1, 2024) ON CONFLICT DO NOTHING;`. This statement inserts a new row into the `wedding` table, populating the `Church_ID`, `Male_ID`, `Female_ID`, and `Year` columns. The value for `Church_ID` is taken from the `church_id_val` variable (which would be either the first `Church_ID` found in the `church` table or the default value of `1`). The value for `Male_ID` is taken from `NEW.\"People_ID\"`, which refers to the `People_ID` column of the newly inserted row in the `people` table that triggered this function. The value for `Female_ID` is calculated as `NEW.\"People_ID\" + 1`, meaning it is one greater than the `People_ID` of the newly inserted row in the `people` table. The value for `Year` is a static integer `2024`. The `ON CONFLICT DO NOTHING` clause specifies that if this `INSERT` operation would result in a conflict with an existing unique constraint or primary key in the `wedding` table, no action should be taken, and the `INSERT` operation will be silently ignored without raising an error.\n\nFinally, the function returns `NEW`, which represents the new row that was just inserted into the `people` table. This is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nThe trigger itself, named `people_wedding_insert_trigger`, is defined to execute the `insert_wedding_record_trigger()` function. It is configured to activate `AFTER INSERT` operations on the `people` table, and it will execute `FOR EACH ROW` that is inserted into the `people` table.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_wedding_record_trigger() RETURNS TRIGGER AS $$\nDECLARE\n    church_id_val INTEGER;\nBEGIN\n    -- Fetch the first available Church_ID from the church table\n    SELECT \"Church_ID\" INTO church_id_val FROM \"church\" LIMIT 1;\n    IF church_id_val IS NULL THEN\n        church_id_val := 1; -- Fallback to a default if no churches are found.\n    END IF;\n\n    INSERT INTO \"wedding\" (\"Church_ID\", \"Male_ID\", \"Female_ID\", \"Year\") \n    VALUES (church_id_val, NEW.\"People_ID\", NEW.\"People_ID\" + 1, 2024) \n    ON CONFLICT DO NOTHING;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER people_wedding_insert_trigger\n    AFTER INSERT ON \"people\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_wedding_record_trigger();",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "INSERT INTO \"people\" (\"People_ID\", \"Name\", \"Country\", \"Is_Male\", \"Age\") VALUES (100, 'John Doe', 'United States', 'T', 30);",
      "INSERT INTO \"people\" (\"People_ID\", \"Name\", \"Country\", \"Is_Male\", \"Age\") VALUES (101, 'Jane Smith', 'Canada', 'F', 28);",
      "INSERT INTO \"people\" (\"People_ID\", \"Name\", \"Country\", \"Is_Male\", \"Age\") VALUES (102, 'Robert Brown', 'United Kingdom', 'T', 35);",
      "INSERT INTO \"people\" (\"People_ID\", \"Name\", \"Country\", \"Is_Male\", \"Age\") VALUES (103, 'Alice Johnson', 'Australia', 'F', 32);",
      "INSERT INTO \"people\" (\"People_ID\", \"Name\", \"Country\", \"Is_Male\", \"Age\") VALUES (104, 'Michael Lee', 'United States', 'T', 40);"
    ],
    "summary": "Create a PostgreSQL trigger function named insert_wedding_record_trigger that fires AFTER INSERT on the people table for each row. The function gets the first Church_ID from the church table (defaults to 1 if NULL) and inserts a row into the wedding table with that Church_ID, NEW.People_ID as Male_ID, NEW.People_ID + 1 as Female_ID, and 2024 as Year, using ON CONFLICT DO NOTHING. It returns NEW.",
    "natural_language": "Create a PostgreSQL trigger on the people table. After each insert, take the new row's People_ID. Get the first Church_ID from the church table, defaulting to 1. Insert into wedding: use that Church_ID, the People_ID as Male_ID, People_ID+1 as Female_ID, and 2024 as Year. On conflict, do nothing. Return NEW.",
    "id": 160
  },
  {
    "ir": "Write a PostgreSQL trigger function named repeat_church_name_trigger that returns a trigger and, when executed, performs an UPDATE operation on the \"church\" table, setting the \"Name\" column to the result of the PostgreSQL repeat function called with two arguments: the NEW.\"Name\" value from the trigger context and the numeric constant 2, which concatenates the new name string with itself, and this update is applied specifically to the row where the \"Church_ID\" column equals the NEW.\"Church_ID\" value from the trigger context, and then the function returns the NEW row record; then create a trigger named church_name_repeat_trigger that is defined to fire AFTER an INSERT operation occurs ON the \"church\" table, configured FOR EACH ROW, and which EXECUTES the repeat_church_name_trigger function; additionally, write a PostgreSQL function named insert_church_with_conflict_handling that takes five parameters: an integer parameter named church_id, a text parameter named name, a text parameter named organized_by, an integer parameter named open_date, and a text parameter named continuation_of, and returns void, and within its body performs an INSERT operation into the \"church\" table targeting the columns \"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", and \"Continuation_of\" with the corresponding parameter values, and includes an ON CONFLICT clause that specifies a conflict on the \"Church_ID\" column, and upon such a conflict performs an UPDATE operation (DO UPDATE) setting the \"Name\" column to the EXCLUDED.\"Name\" value, the \"Organized_by\" column to the EXCLUDED.\"Organized_by\" value, the \"Open_Date\" column to the EXCLUDED.\"Open_Date\" value, and the \"Continuation_of\" column to the EXCLUDED.\"Continuation_of\" value.",
    "plsql": "CREATE OR REPLACE FUNCTION repeat_church_name_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"church\" SET \"Name\" = repeat(NEW.\"Name\", 2) WHERE \"Church_ID\" = NEW.\"Church_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER church_name_repeat_trigger\n    AFTER INSERT ON \"church\"\n    FOR EACH ROW\n    EXECUTE FUNCTION repeat_church_name_trigger();\n\nCREATE OR REPLACE FUNCTION insert_church_with_conflict_handling(church_id integer, name text, organized_by text, open_date integer, continuation_of text) RETURNS void AS $$\nBEGIN\n    INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\")\n    VALUES (church_id, name, organized_by, open_date, continuation_of)\n    ON CONFLICT (\"Church_ID\") DO UPDATE SET\n    \"Name\" = EXCLUDED.\"Name\",\n    \"Organized_by\" = EXCLUDED.\"Organized_by\",\n    \"Open_Date\" = EXCLUDED.\"Open_Date\",\n    \"Continuation_of\" = EXCLUDED.\"Continuation_of\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (4, 'New Church', 'John Doe', 1840, 'Old Church');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (5, 'Another Church', 'Jane Smith', 1850, 'Ancient Church');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (6, 'Modern Church', 'Alice Johnson', 1860, 'Historic Church');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (7, 'Future Church', 'Bob Brown', 1870, 'Future Church');",
      "INSERT INTO \"church\" (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\", \"Continuation_of\") VALUES (8, 'Legacy Church', 'Charlie Green', 1880, 'Legacy Church');"
    ],
    "summary": "Create a PostgreSQL trigger function named repeat_church_name_trigger that, after a row is inserted into the church table, updates that same row by setting the Name column to the concatenation of the new name with itself (using the repeat function with a multiplier of 2). Then create an AFTER INSERT trigger named church_name_repeat_trigger to execute this function. Also, create a function named insert_church_with_conflict_handling that inserts a new church record. If a conflict occurs on the Church_ID column, update the existing row's Name, Organized_by, Open_Date, and Continuation_of columns with the new values.",
    "natural_language": "Construct a PostgreSQL trigger function called repeat_church_name_trigger, which, following the insertion of a new row into the church table, meticulously updates that specific row by assigning the Name column to a detailed concatenation of the newly provided name with itself, effectively utilizing the repeat function with a precise multiplier of two. Subsequently, establish an AFTER INSERT trigger, named church_name_repeat_trigger, whose sole purpose is to reliably execute the aforementioned function. Furthermore, design an additional function named insert_church_with_conflict_handling that carefully inserts a fresh church record; however, should a conflict arise specifically on the Church_ID column, it must comprehensively update the existing row's Name, Organized_by, Open_Date, and Continuation_of columns with all the newly supplied values.",
    "id": 161
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_people_country_trigger that returns a trigger and is executed by a trigger named people_country_update_trigger, which is defined to fire BEFORE INSERT on the table named \"people\" for each individual row being inserted, where the function's logic unconditionally assigns the literal string value 'Unknown' to the NEW record's column named \"Country\", thereby overriding any value provided for that column in the original INSERT statement, and then returns the modified NEW row record to the database engine for the subsequent insert operation.",
    "plsql": "CREATE OR REPLACE FUNCTION update_people_country_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Country\" = 'Unknown';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER people_country_update_trigger\n    BEFORE INSERT ON \"people\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_people_country_trigger();",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "INSERT INTO people (People_ID, Name, Is_Male, Age) VALUES (100, 'John Doe', 'T', 28);",
      "INSERT INTO people (People_ID, Name, Country, Is_Male, Age) VALUES (101, 'Jane Smith', 'USA', 'F', 31);",
      "INSERT INTO people (Name, Is_Male, Age) VALUES ('Alex Johnson', 'T', 25);",
      "INSERT INTO people (People_ID, Name, Is_Male) VALUES (102, 'Maria Garcia', 'F');",
      "INSERT INTO people (People_ID, Name, Country, Is_Male, Age) VALUES (103, 'Test User', NULL, 'T', 40);"
    ],
    "summary": "Create a PostgreSQL BEFORE INSERT trigger function named update_people_country_trigger that sets the Country column of every new row in the people table to 'Unknown'. Then create a trigger named people_country_update_trigger to execute this function before each insert.",
    "natural_language": "Create a BEFORE INSERT trigger on the people table to set Country to 'Unknown' for new rows.",
    "id": 162
  },
  {
    "ir": "Write a PL/pgSQL function named `trg_auto_timestamp` that is designed to be executed as a trigger. This function takes no explicit parameters but operates on the `NEW` record, which represents the row being inserted or updated in the table that the trigger is associated with. The function's primary purpose is to automatically manage two columns in the `NEW` record: `\"problem_log_id\"` and `\"log_entry_date\"`.\n\nThe function begins by checking if the value of the `\"problem_log_id\"` column in the `NEW` record is `NULL`. This check is performed using an `IF` conditional statement. If `NEW.\"problem_log_id\"` is indeed `NULL`, the function proceeds to generate a new value for this column. It does this by executing a `SELECT` statement that queries the `\"Problem_Log\"` table. Specifically, it selects the maximum value of the `\"problem_log_id\"` column from the entire `\"Problem_Log\"` table. The `COALESCE` function is used to handle the case where the `\"Problem_Log\"` table might be empty or contain no `problem_log_id` values, in which case `MAX(\"problem_log_id\")` would return `NULL`; `COALESCE` replaces this `NULL` with `0`. This result (either the maximum `problem_log_id` or `0`) is then incremented by `1`. The calculated value is then assigned to `NEW.\"problem_log_id\"` using the `INTO` clause.\n\nFollowing this conditional logic for `\"problem_log_id\"`, the function unconditionally sets the value of the `\"log_entry_date\"` column in the `NEW` record. It assigns the current timestamp to `NEW.\"log_entry_date\"` using the `CURRENT_TIMESTAMP` function.\n\nFinally, the function returns the modified `NEW` record.\n\nThis function is then associated with a trigger named `before_insert_problem_log_timestamp`. This trigger is configured to execute `BEFORE INSERT` operations on the `\"Problem_Log\"` table. The `FOR EACH ROW` clause specifies that the trigger function `trg_auto_timestamp()` will be executed once for each row that is being inserted into the `\"Problem_Log\"` table. The `EXECUTE FUNCTION trg_auto_timestamp()` clause specifies that the `trg_auto_timestamp` function should be invoked when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_auto_timestamp() RETURNS TRIGGER AS $$\nBEGIN\n    -- Auto-generate problem_log_id if it's NULL\n    IF NEW.\"problem_log_id\" IS NULL THEN\n        SELECT COALESCE(MAX(\"problem_log_id\"), 0) + 1 \n        INTO NEW.\"problem_log_id\" \n        FROM \"Problem_Log\";\n    END IF;\n    \n    -- Set the timestamp\n    NEW.\"log_entry_date\" = CURRENT_TIMESTAMP;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER before_insert_problem_log_timestamp\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION trg_auto_timestamp();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Log"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (\"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (11, 8, 'Middleware', 'Solved', 't', 'k', 'p');",
      "INSERT INTO \"Problem_Log\" (\"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (12, 1, 'GUI', 'Solved', 'a', 'j', 's');",
      "INSERT INTO \"Problem_Log\" (\"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (11, 11, 'Middleware', 'Solved', 'b', 'k', 'e');",
      "INSERT INTO \"Problem_Log\" (\"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (12, 8, 'GUI', 'Solved', 't', 'j', 'p');",
      "INSERT INTO \"Problem_Log\" (\"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (11, 1, 'Middleware', 'Solved', 'a', 'k', 's');"
    ],
    "summary": "Create a PostgreSQL BEFORE INSERT trigger function named trg_auto_timestamp for the Problem_Log table. If the new row's problem_log_id is NULL, set it to one greater than the current maximum value in the table (or 1 if the table is empty). Always set the log_entry_date column to the current timestamp. Create a trigger named before_insert_problem_log_timestamp to execute this function.",
    "natural_language": "Hey, can you whip up a PostgreSQL BEFORE INSERT trigger function called trg_auto_timestamp for the Problem_Log table? Here's the deal: if the new row's problem_log_id is null, we gotta set it to one more than the biggest ID already in the table (or just 1 if the table's empty). Oh, and always make sure the log_entry_date column gets the current timestamp. Then, hook it up with a trigger named before_insert_problem_log_timestamp to run this function.",
    "id": 163
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_round_log_id that returns a trigger and is executed as a BEFORE INSERT trigger named before_insert_round_id on the table named \"Problem_Log\" for each new row, where the function's logic accesses the new row's column values via the special NEW record variable and specifically modifies the value of the column named \"problem_log_id\" by performing a calculation: it first divides the incoming NEW.\"problem_log_id\" value by 10.0, then passes the result to the CEIL function which returns the smallest integer greater than or equal to that division result, and finally multiplies that integer by 10, thereby rounding the original \"problem_log_id\" value up to the nearest multiple of ten, and the function concludes by returning the modified NEW record so that the rounded value is used for the subsequent INSERT operation into the \"Problem_Log\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_round_log_id() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"problem_log_id\" = CEIL(NEW.\"problem_log_id\" / 10.0) * 10;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER before_insert_round_id\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION trg_round_log_id();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Log"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (1, 11, 11, 'Middleware', 'Solved', '2011-03-13 13:11:57+08:00', 't', 'k', 'p');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (2, 12, 8, 'GUI', 'Solved', '1976-03-31 14:03:02+08:00', 'a', 'j', 's');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (3, 11, 1, 'Middleware', 'Solved', '1974-12-11 01:06:22+08:00', 'b', 'k', 'e');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (4, 12, 11, 'GUI', 'Solved', '2011-03-13 13:11:57+08:00', 't', 'j', 'p');",
      "INSERT INTO \"Problem_Log\" (\"problem_log_id\", \"assigned_to_staff_id\", \"problem_id\", \"problem_category_code\", \"problem_status_code\", \"log_entry_date\", \"log_entry_description\", \"log_entry_fix\", \"other_log_details\") VALUES (5, 11, 8, 'Middleware', 'Solved', '1976-03-31 14:03:02+08:00', 'a', 'k', 's');"
    ],
    "summary": "Create a PostgreSQL BEFORE INSERT trigger function named trg_round_log_id for the Problem_Log table. For each new row, round the problem_log_id value up to the nearest multiple of ten. Create a trigger named before_insert_round_id to execute this function.",
    "natural_language": "Please construct a PostgreSQL BEFORE INSERT trigger function designated as trg_round_log_id for the Problem_Log table. The function's purpose is to adjust each new row by rounding the problem_log_id value upward to the nearest multiple of ten. Subsequently, establish a trigger called before_insert_round_id to invoke this function.",
    "id": 164
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `decrease_ship_tonnage` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function returns `TRIGGER`, indicating its purpose as a trigger function. Upon execution, the function performs a single `UPDATE` operation on the table named `\"ship\"`. Specifically, it modifies the column named `\"Tonnage\"` by subtracting a fixed value of `50` from its current value. This update is applied only to the row(s) in the `\"ship\"` table where the value in the `\"Ship_ID\"` column matches the value of `\"Ship_ID\"` from the `OLD` record, which represents the state of the row that triggered the event before it was deleted. After performing this update, the function explicitly returns `NULL`, which is a standard practice for `AFTER` row-level triggers in PostgreSQL, indicating that the original row that triggered the event should not be modified or replaced.\n\nFollowing the definition of this function, a trigger named `decrease_tonnage_after_mission_delete` is created. This trigger is configured to activate `AFTER DELETE` operations on the table named `\"mission\"`. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is deleted from the `\"mission\"` table. When activated, this trigger executes the previously defined function `decrease_ship_tonnage()`. Therefore, whenever a row is deleted from the `\"mission\"` table, the `decrease_ship_tonnage` function will be invoked, and it will update the `\"Tonnage\"` of the ship associated with the deleted mission by reducing it by 50, using the `Ship_ID` from the deleted mission record.",
    "plsql": "CREATE OR REPLACE FUNCTION decrease_ship_tonnage() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"ship\" SET \"Tonnage\" = \"Tonnage\" - 50 WHERE \"Ship_ID\" = OLD.\"Ship_ID\";\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER decrease_tonnage_after_mission_delete\nAFTER DELETE ON \"mission\"\nFOR EACH ROW EXECUTE FUNCTION decrease_ship_tonnage();",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "DELETE FROM \"mission\" WHERE \"Mission_ID\" = 1;",
      "DELETE FROM \"mission\" WHERE \"Ship_ID\" = 2;",
      "DELETE FROM \"mission\" WHERE \"Code\" = 'VMV-1';",
      "DELETE FROM \"mission\" WHERE \"Launched_Year\" = 1930;",
      "DELETE FROM \"mission\" WHERE \"Fate\" = 'Decommissioned 1950';"
    ],
    "summary": "Create a PostgreSQL AFTER DELETE trigger function named decrease_ship_tonnage for the mission table. When a mission is deleted, reduce the Tonnage of the corresponding ship (identified by the deleted row's Ship_ID) by 50. Create a trigger named decrease_tonnage_after_mission_delete to execute this function after each row deletion.",
    "natural_language": "Alright, so we need a trigger for the mission table. When someone deletes a mission, we gotta knock 50 off the Tonnage of the ship that was on that mission (you can find the ship using the Ship_ID from the deleted row). First, set up a function called decrease_ship_tonnage to do that math. Then, hook it up with a trigger named decrease_tonnage_after_mission_delete to run right after a row gets deleted.",
    "id": 165
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_student_count_on_city_delete that returns a trigger and is executed by a trigger named trg_update_student_count_on_city_delete, which is defined to fire BEFORE DELETE on the City table for each row being deleted, where the function performs two cascading delete operations: first, it deletes all rows from the Direct_distance table where the city1_code column equals the OLD.city_code value from the deleted City row or where the city2_code column equals the OLD.city_code value, and second, it deletes all rows from the Student table where the city_code column equals the OLD.city_code value, after which the function returns the OLD row record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_student_count_on_city_delete() RETURNS TRIGGER AS $$\nBEGIN\n  -- Delete related rows in Direct_distance first to maintain referential integrity\n  DELETE FROM \"Direct_distance\" WHERE city1_code = OLD.city_code OR city2_code = OLD.city_code;\n  \n  -- Delete related students\n  DELETE FROM \"Student\" WHERE city_code = OLD.city_code;\n  \n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_student_count_on_city_delete\nBEFORE DELETE ON \"City\"\nFOR EACH ROW EXECUTE FUNCTION update_student_count_on_city_delete();",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "DELETE FROM \"City\" WHERE city_code = 'BAL';",
      "DELETE FROM \"City\" WHERE city_code = 'PIT';",
      "DELETE FROM \"City\" WHERE city_code = 'PHL';",
      "DELETE FROM \"City\" WHERE city_code = 'NYC';",
      "DELETE FROM \"City\" WHERE city_code = 'ATL';"
    ],
    "summary": "Create a PostgreSQL BEFORE DELETE trigger function named update_student_count_on_city_delete. For each deleted City row, delete related records from Direct_distance where city1_code or city2_code equals OLD.city_code, then delete related records from Student where city_code equals OLD.city_code. Return OLD.",
    "natural_language": "How can I create a PostgreSQL BEFORE DELETE trigger function called update_student_count_on_city_delete that, for each City row being deleted, first removes related records from the Direct_distance table where city1_code or city2_code matches OLD.city_code, and then removes related records from the Student table where city_code matches OLD.city_code, before finally returning OLD?",
    "id": 166
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an insert operation on the school table. This function, named log_school_entry, does not take any parameters directly but operates on the newly inserted row in the school table. It inserts a new row into the school_details table with the following columns: School_ID, Nickname, Colors, League, Class, and Division. The School_ID column in the school_details table is populated with the School_ID value from the newly inserted row in the school table, while the Nickname, Colors, League, Class, and Division columns are populated with the static values 'New Nickname', 'New Colors', 'New League', 'New Class', and 'New Division', respectively. The function then returns the newly inserted row from the school table. The trigger, named log_new_school, is defined to execute this function after each row is inserted into the school table, ensuring that every new entry in the school table results in a corresponding entry in the school_details table with predefined values for all columns except School_ID.",
    "plsql": "CREATE OR REPLACE FUNCTION log_school_entry() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO school_details (\"School_ID\", \"Nickname\", \"Colors\", \"League\", \"Class\", \"Division\")\n  VALUES (NEW.\"School_ID\", 'New Nickname', 'New Colors', 'New League', 'New Class', 'New Division');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_new_school\nAFTER INSERT ON school\nFOR EACH ROW EXECUTE FUNCTION log_school_entry();",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (4, 'New School 1', 'New Location 1', 1500.0, 2000.0, 'Non-Denominational', 'Co-ed', 'Day', 2005.0, 'Green and White');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (5, 'New School 2', 'New Location 2', 1800.0, 1995.0, 'Lutheran', 'Girls', 'Boarding', 2010.0, 'Purple and Gold');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (6, 'New School 3', 'New Location 3', 2000.0, 1985.0, 'Baptist', 'Boys', 'Day & Boarding', 1990.0, 'Black and Silver');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (7, 'New School 4', 'New Location 4', 2200.0, 1975.0, 'Methodist', 'Co-ed', 'Day', 1980.0, 'Orange and Blue');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (8, 'New School 5', 'New Location 5', 2500.0, 1965.0, 'Presbyterian', 'Girls', 'Boarding', 1970.0, 'Maroon and White');"
    ],
    "summary": "Create a PostgreSQL AFTER INSERT trigger function named log_school_entry. For each new school row, insert into school_details: School_ID from NEW, with static values 'New Nickname', 'New Colors', 'New League', 'New Class', and 'New Division' for other columns. Return NEW.",
    "natural_language": "Set up a trigger that runs after adding a new school to log some details. For each fresh entry, put its ID into the school_details table along with a few new placeholder values for things like its nickname, colors, and what league or group it might be part of. Just make sure it returns the new record.",
    "id": 167
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after an insert operation on the school table, which checks if the newly inserted row has a non-null value in the School_Colors column. If School_Colors is not null, the function inserts a new row into the school_details table with the School_ID from the newly inserted row and the uppercase version of School_Colors. If a row with the same School_ID already exists in the school_details table, it updates the Colors column to the uppercase version of the new School_Colors value. The function uses the UPPER() function to convert the School_Colors value to uppercase, ensuring consistent formatting in the school_details table. The trigger named add_school_colors is defined to execute this function for each row after an insert operation on the school table, ensuring that the school_details table is updated accordingly whenever a new school record is added.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_school_colors() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"School_Colors\" IS NOT NULL THEN\n    INSERT INTO school_details (\"School_ID\", \"Colors\")\n    VALUES (NEW.\"School_ID\", UPPER(NEW.\"School_Colors\"))\n    ON CONFLICT (\"School_ID\") DO UPDATE\n    SET \"Colors\" = UPPER(NEW.\"School_Colors\");\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER add_school_colors\nAFTER INSERT ON school\nFOR EACH ROW EXECUTE FUNCTION insert_school_colors();",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (1, 'St Aloysius\\' College', 'Milsons Point', 1200.0, 1879.0, 'Catholic', 'Boys', 'Day', 1929.0, 'Royal Blue and Gold');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (2, 'Barker College', 'Hornsby', 2300.0, 1890.0, 'Anglican', 'Boys only to Yr 9 Co-ed Year 1...', 'Day & Boarding', 1929.0, 'Red & Blue');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (3, 'Cranbrook School', 'Bellevue Hill', 1000.0, 1918.0, 'Anglican', 'Boys', 'Day', 1929.0, 'Red, White & Blue');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (4, 'New School', 'New Location', 1500.0, 2000.0, 'Non-Denominational', 'Co-ed', 'Day', 2000.0, 'Green and White');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (5, 'Another School', 'Another Location', 1800.0, 1950.0, 'Catholic', 'Girls', 'Boarding', 1950.0, 'Black and Yellow');"
    ],
    "summary": "Create a PostgreSQL AFTER INSERT trigger function for the school table. If NEW.School_Colors is not null, insert or update school_details: set School_ID to NEW.School_ID and Colors to UPPER(NEW.School_Colors). On conflict, update Colors to the uppercase value. Return NEW.",
    "natural_language": "Alright, so we need a trigger that kicks in after you add a new entry to the school table. Here's the deal: if the new record's School_Colors field isn't empty, you gotta either add a new row to the school_details table or update an existing one. Set the School_ID to the new School_ID and the Colors to the uppercase version of the new School_Colors. If there's already an entry with that School_ID (that's a conflict), just update its Colors to that uppercase value. Finally, the trigger should just hand back the NEW record.",
    "id": 168
  },
  {
    "ir": "Write a PL/pgSQL function named `update_product_discontinued` that is designed to be executed as part of a trigger, and a PL/pgSQL trigger named `close_complaint_discontinue_product`. The `update_product_discontinued` function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records from the triggering event. Its purpose is to update the `Products` table. Specifically, it sets the `date_product_discontinued` column to the current timestamp, obtained by calling the `NOW()` function, for the row where the `product_id` column matches the value of the `product_id` column from the `NEW` record provided by the trigger. After performing this update, the function returns the `NEW` record, which is a standard requirement for `BEFORE` or `AFTER` row-level triggers in PostgreSQL. The `close_complaint_discontinue_product` trigger is defined to activate `AFTER` an `UPDATE` operation on the `Complaints` table. It specifically monitors changes to the `complaint_status_code` column. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row affected by the `UPDATE` statement. A `WHEN` condition is applied to this trigger, ensuring that it only executes its associated function if the `complaint_status_code` in the `NEW` record (representing the row's state after the update) is equal to the string literal `'Closed'`. When these conditions are met, the trigger `EXECUTE`s the `update_product_discontinued()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_product_discontinued() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Products\" SET \"date_product_discontinued\" = NOW() WHERE \"product_id\" = NEW.\"product_id\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER close_complaint_discontinue_product\nAFTER UPDATE OF \"complaint_status_code\" ON \"Complaints\"\nFOR EACH ROW WHEN (NEW.\"complaint_status_code\" = 'Closed')\nEXECUTE FUNCTION update_product_discontinued();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Complaints\" SET \"complaint_status_code\" = 'Closed' WHERE \"complaint_id\" = 1;",
      "UPDATE \"Complaints\" SET \"complaint_status_code\" = 'Closed' WHERE \"complaint_id\" = 2;",
      "UPDATE \"Complaints\" SET \"complaint_status_code\" = 'Closed' WHERE \"complaint_id\" = 3;",
      "UPDATE \"Complaints\" SET \"complaint_status_code\" = 'Closed' WHERE \"product_id\" = 117;",
      "UPDATE \"Complaints\" SET \"complaint_status_code\" = 'Closed' WHERE \"product_id\" = 118;"
    ],
    "summary": "Create a PostgreSQL AFTER UPDATE trigger function named update_product_discontinued. When complaint_status_code changes to 'Closed', update Products: set date_product_discontinued to NOW() where product_id equals NEW.product_id. Return NEW.",
    "natural_language": "Alright, so we need a trigger function for PostgreSQL that fires after an update. Call it 'update_product_discontinued'. Here's the deal: whenever the 'complaint_status_code' gets switched to 'Closed', we gotta update the Products table. Just set the 'date_product_discontinued' field to the current timestamp, but only for the product where the product_id matches the NEW.product_id from the trigger. Oh, and at the end, just return NEW.",
    "id": 169
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after an insert operation on the \"Complaints\" table, which logs or updates customer complaint information in the \"Customers\" table. The function, named log_customer_complaint_count, is designed to handle each new row inserted into the \"Complaints\" table. It inserts a new record into the \"Customers\" table with the following columns: \"customer_id\" set to the value of NEW.\"customer_id\", \"customer_type_code\" set to a string concatenation of 'ComplaintLogged: ' and NEW.\"complaint_type_code\", \"address_line_1\" set to 'Logged Address', \"town_city\" set to 'Logged City', \"state\" set to 'Logged State', \"email_address\" set to 'logged@example.com', and \"phone_number\" set to '000-000-0000'. If a conflict occurs due to an existing \"customer_id\", the function updates the \"customer_type_code\" column by appending the new complaint type code to the existing value, separated by a semicolon if the existing value is not null, using the COALESCE function to handle null values. The trigger named track_customer_complaint_types is defined to execute this function after each row insertion into the \"Complaints\" table, ensuring that customer complaint types are tracked and logged accordingly.",
    "plsql": "CREATE OR REPLACE FUNCTION log_customer_complaint_count() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Customers\" (\"customer_id\", \"customer_type_code\", \"address_line_1\", \"town_city\", \"state\", \"email_address\", \"phone_number\") \n  VALUES (\n    NEW.\"customer_id\", \n    'ComplaintLogged: ' || NEW.\"complaint_type_code\", \n    'Logged Address', \n    'Logged City', \n    'Logged State', \n    'logged@example.com', \n    '000-000-0000'\n  ) \n  ON CONFLICT (\"customer_id\") \n  DO UPDATE SET \"customer_type_code\" = \n    COALESCE(\"Customers\".\"customer_type_code\" || '; ', '') || \n    'ComplaintLogged: ' || NEW.\"complaint_type_code\";\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER track_customer_complaint_types\nAFTER INSERT ON \"Complaints\"\nFOR EACH ROW EXECUTE FUNCTION log_customer_complaint_count();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Complaints\" (\"complaint_id\", \"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\", \"staff_id\") VALUES (1, 117, 113, 'OK', 'New', 'Product Failure', '2023-01-01 10:00:00+00', NULL, 114);",
      "INSERT INTO \"Complaints\" (\"complaint_id\", \"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\", \"staff_id\") VALUES (2, 118, 114, 'OK', 'New', 'Product Unusable', '2023-01-02 11:00:00+00', NULL, 115);",
      "INSERT INTO \"Complaints\" (\"complaint_id\", \"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\", \"staff_id\") VALUES (3, 119, 115, 'OK', 'New', 'Missing Parts', '2023-01-03 12:00:00+00', NULL, 116);",
      "INSERT INTO \"Complaints\" (\"complaint_id\", \"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\", \"staff_id\") VALUES (4, 117, 113, 'OK', 'New', 'Damaged on Arrival', '2023-01-04 13:00:00+00', NULL, 114);",
      "INSERT INTO \"Complaints\" (\"complaint_id\", \"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\", \"staff_id\") VALUES (5, 118, 114, 'OK', 'New', 'Wrong Item Shipped', '2023-01-05 14:00:00+00', NULL, 115);"
    ],
    "summary": "Create a PostgreSQL AFTER INSERT trigger function named log_customer_complaint_count for the Complaints table. Insert into Customers: customer_id from NEW, customer_type_code as 'ComplaintLogged: ' || NEW.complaint_type_code, with static placeholder values for address, city, state, email, and phone. On conflict, update customer_type_code by appending the new complaint type with a semicolon separator. Return NEW.",
    "natural_language": "Create a PostgreSQL AFTER INSERT trigger function called log_customer_complaint_count for the Complaints table. This function should insert a row into the Customers table using the customer_id from NEW, set the customer_type_code to 'ComplaintLogged: ' concatenated with NEW.complaint_type_code, and use static placeholder values for address, city, state, email, and phone. If a conflict occurs, update the existing customer_type_code by appending the new complaint type with a semicolon separator. Finally, make the function return NEW.",
    "id": 170
  },
  {
    "ir": "Write a PL/pgSQL function named `auto_assign_staff` that returns a `TRIGGER` type, indicating its intended use as a trigger function. This function does not accept any explicit input parameters. Upon execution, it performs a `SELECT` operation on the `\"Staff\"` table. The `SELECT` statement retrieves the `\"staff_id\"` column. The selection is filtered by a `WHERE` clause, specifically `WHERE \"gender\" = '1'`, which means it only considers staff members whose `gender` column value is exactly '1'. The results of this filtered selection are then ordered randomly using `ORDER BY RANDOM()`. From this randomly ordered set, `LIMIT 1` ensures that only a single `\"staff_id\"` is selected. The selected `\"staff_id\"` is then assigned to the `\"staff_id\"` column of the `NEW` record, which represents the row being inserted or updated by the triggering event. Finally, the function returns the `NEW` record, allowing the modified record to be inserted into the table.\n\nAdditionally, a `TRIGGER` named `assign_staff_to_complaint` is defined. This trigger is configured to execute `BEFORE INSERT` operations on the `\"Complaints\"` table. It is set to execute `FOR EACH ROW`, meaning it will fire once for every row being inserted. A `WHEN` condition is specified: `WHEN (NEW.\"staff_id\" IS NULL)`. This condition dictates that the trigger will only execute its associated function if the `\"staff_id\"` column of the `NEW` record (the record being inserted) is `NULL`. If this condition is met, the trigger `EXECUTE FUNCTION auto_assign_staff()`, which means it calls the previously described `auto_assign_staff` function. The purpose of this trigger is to automatically assign a random staff member (with gender '1') to a new complaint if no staff member has been explicitly assigned during the insertion.",
    "plsql": "CREATE OR REPLACE FUNCTION auto_assign_staff() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.\"staff_id\" := (SELECT \"staff_id\" FROM \"Staff\" WHERE \"gender\" = '1' ORDER BY RANDOM() LIMIT 1);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER assign_staff_to_complaint\nBEFORE INSERT ON \"Complaints\"\nFOR EACH ROW WHEN (NEW.\"staff_id\" IS NULL)\nEXECUTE FUNCTION auto_assign_staff();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Complaints\" (\"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\") VALUES (117, 113, 'OK', 'New', 'Product Failure', '2023-10-01 10:00:00+08:00', NULL);",
      "INSERT INTO \"Complaints\" (\"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\") VALUES (118, 114, 'OK', 'New', 'Product Unusable', '2023-10-02 11:00:00+08:00', NULL);",
      "INSERT INTO \"Complaints\" (\"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\") VALUES (119, 115, 'OK', 'New', 'Product Failure', '2023-10-03 12:00:00+08:00', NULL);",
      "INSERT INTO \"Complaints\" (\"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\") VALUES (117, 114, 'OK', 'New', 'Product Unusable', '2023-10-04 13:00:00+08:00', NULL);",
      "INSERT INTO \"Complaints\" (\"product_id\", \"customer_id\", \"complaint_outcome_code\", \"complaint_status_code\", \"complaint_type_code\", \"date_complaint_raised\", \"date_complaint_closed\") VALUES (118, 113, 'OK', 'New', 'Product Failure', '2023-10-05 14:00:00+08:00', NULL);"
    ],
    "summary": "Create a trigger function named `auto_assign_staff` that returns TRIGGER. Before inserting a row into the \"Complaints\" table, if the new row's \"staff_id\" is NULL, the function assigns a random \"staff_id\" from the \"Staff\" table where \"gender\" is '1'. Then create a trigger named `assign_staff_to_complaint` that fires BEFORE INSERT on \"Complaints\" FOR EACH ROW WHEN (NEW.\"staff_id\" IS NULL) to execute this function.",
    "natural_language": "How can I create a trigger function called `auto_assign_staff` that returns TRIGGER, which, before inserting a row into the \"Complaints\" table, assigns a random \"staff_id\" from the \"Staff\" table where \"gender\" is '1' if the new row's \"staff_id\" is NULL, and then how do I create a trigger named `assign_staff_to_complaint` that fires BEFORE INSERT on \"Complaints\" FOR EACH ROW WHEN (NEW.\"staff_id\" IS NULL) to execute this function?",
    "id": 171
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `cascade_product_delete` that is designed to be executed in response to a data manipulation event on a table, and a trigger named `remove_product_complaints` that is configured to invoke this function. The `cascade_product_delete` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon execution, this function performs a `DELETE` operation on the table named `\"Complaints\"`. The `DELETE` operation targets rows within the `\"Complaints\"` table where the value in the column named `\"product_id\"` is equal to the value of the `\"product_id\"` column from the row that is currently being processed by the triggering event. This value is accessed via `OLD.\"product_id\"`, which represents the value of the `\"product_id\"` column in the row *before* the `DELETE` operation on the parent table. After executing the `DELETE` statement, the function returns the `OLD` record, which is a standard requirement for `BEFORE` triggers in PostgreSQL, indicating that the original row should proceed with the intended operation. The `remove_product_complaints` trigger is defined to activate `BEFORE DELETE` operations on the table named `\"Products\"`. This trigger is configured to execute `FOR EACH ROW`, meaning that the `cascade_product_delete` function will be invoked once for every row that is being deleted from the `\"Products\"` table. The trigger explicitly `EXECUTE FUNCTION cascade_product_delete()`, thereby initiating the logic defined within the trigger function for each affected row.",
    "plsql": "CREATE OR REPLACE FUNCTION cascade_product_delete() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Complaints\" WHERE \"product_id\" = OLD.\"product_id\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_product_complaints\nBEFORE DELETE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION cascade_product_delete();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "DELETE FROM \"Products\" WHERE product_id = 117;",
      "DELETE FROM \"Products\" WHERE product_id = 118;",
      "DELETE FROM \"Products\" WHERE product_id = 119;",
      "DELETE FROM \"Products\" WHERE product_id = (SELECT product_id FROM \"Products\" ORDER BY product_id DESC LIMIT 1);",
      "DELETE FROM \"Products\" WHERE product_id = (SELECT product_id FROM \"Products\" ORDER BY RANDOM() LIMIT 1);"
    ],
    "summary": "Create a trigger function named `cascade_product_delete` that returns TRIGGER. Before deleting a row from the \"Products\" table, the function deletes all rows from the \"Complaints\" table where \"product_id\" matches the OLD.\"product_id\". Then create a trigger named `remove_product_complaints` that fires BEFORE DELETE on \"Products\" FOR EACH ROW to execute this function.",
    "natural_language": "Define a trigger function called `cascade_product_delete` that returns TRIGGER. This function must first delete all related entries from the \"Complaints\" table where the \"product_id\" matches the OLD.\"product_id\" before a row is removed from the \"Products\" table. Then, set up a BEFORE DELETE trigger named `remove_product_complaints` on the \"Products\" table to run this function for each row.",
    "id": 172
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before any insert or update operation on the \"Complaints\" table. This function, named validate_complaint_dates, checks the values of two date columns: \"date_complaint_closed\" and \"date_complaint_raised\". If the \"date_complaint_closed\" is not null and is earlier than the \"date_complaint_raised\", the function updates the \"date_complaint_closed\" to be equal to the \"date_complaint_raised\". The trigger, named ensure_valid_complaint_timeline, is set to fire for each row before an insert or update operation on the \"Complaints\" table, ensuring that the timeline of complaint dates is valid by preventing the closure date from being earlier than the raised date.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_complaint_dates() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"date_complaint_closed\" IS NOT NULL AND NEW.\"date_complaint_closed\" < NEW.\"date_complaint_raised\" THEN\n    NEW.\"date_complaint_closed\" := NEW.\"date_complaint_raised\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER ensure_valid_complaint_timeline\nBEFORE INSERT OR UPDATE ON \"Complaints\"\nFOR EACH ROW EXECUTE FUNCTION validate_complaint_dates();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, date_complaint_closed, staff_id) VALUES (100, 117, 120, 'OK', 'Closed', 'Product Failure', '2024-01-15 10:00:00+00', '2024-01-10 14:00:00+00', 114);",
      "UPDATE \"Complaints\" SET date_complaint_closed = '2023-12-01 09:00:00+00', date_complaint_raised = '2024-01-01 08:00:00+00' WHERE complaint_id = 1;",
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, staff_id) VALUES (101, 118, 113, NULL, 'New', 'Product Unusable', '2024-03-20 11:30:00+00', 115);",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed', date_complaint_closed = '2024-02-28 16:45:00+00' WHERE complaint_id = 2;",
      "INSERT INTO \"Complaints\" (complaint_id, product_id, customer_id, complaint_outcome_code, complaint_status_code, complaint_type_code, date_complaint_raised, date_complaint_closed, staff_id) VALUES (102, 119, 114, 'OK', 'Closed', 'Product Failure', '2024-05-01 12:00:00+00', '2024-05-05 15:00:00+00', 120);"
    ],
    "summary": "Create a trigger function named `validate_complaint_dates` that returns TRIGGER. Before inserting or updating a row in the \"Complaints\" table, if the \"date_complaint_closed\" is not NULL and is earlier than \"date_complaint_raised\", set \"date_complaint_closed\" equal to \"date_complaint_raised\". Then create a trigger named `ensure_valid_complaint_timeline` that fires BEFORE INSERT OR UPDATE on \"Complaints\" FOR EACH ROW to execute this function.",
    "natural_language": "Construct a trigger function, which should be named `validate_complaint_dates`, that is explicitly defined to return a TRIGGER. This function must be designed to operate before any insertion or update operation is performed on a row within the \"Complaints\" table. Its primary purpose is to meticulously validate the chronological order of the complaint dates. Specifically, if the \"date_complaint_closed\" field contains a non-NULL value and, upon careful examination, is found to be chronologically earlier than the \"date_complaint_raised\" field, the function must automatically and correctly set the \"date_complaint_closed\" value to be equal to the \"date_complaint_raised\" value. Subsequently, create a separate trigger, to be named `ensure_valid_complaint_timeline`, which is configured to fire BEFORE either an INSERT or an UPDATE event on the \"Complaints\" table, and it must execute precisely once FOR EACH ROW, thereby invoking the aforementioned `validate_complaint_dates` function to guarantee data integrity.",
    "id": 173
  },
  {
    "ir": "Write a PLpgSQL function named \"update_pet_age_on_insert\" that is designed to be executed as a trigger function. This function does not take any parameters directly, but operates in the context of a trigger event. It is intended to be used with a trigger that fires after an insert operation on the \"Has_Pet\" table. The function performs an update operation on the \"Pets\" table, specifically targeting the \"pet_age\" column. It increases the value of \"pet_age\" by 1 for the row where the \"PetID\" column matches the \"PetID\" value of the newly inserted row in the \"Has_Pet\" table, referred to as NEW.\"PetID\". The function then returns the NEW record, which is the standard behavior for a trigger function that operates after an insert. The associated trigger, named \"trigger_update_pet_age_on_insert\", is defined to execute this function after each row is inserted into the \"Has_Pet\" table, ensuring that the age of the pet associated with the newly inserted record is incremented by one year.",
    "plsql": "CREATE OR REPLACE FUNCTION \"update_pet_age_on_insert\"() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Pets\" SET \"pet_age\" = \"pet_age\" + 1 WHERE \"PetID\" = NEW.\"PetID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_update_pet_age_on_insert\"\nAFTER INSERT ON \"Has_Pet\"\nFOR EACH ROW EXECUTE FUNCTION \"update_pet_age_on_insert\"();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2001);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2002);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1003, 2003);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2003);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2001);"
    ],
    "summary": "Create a trigger function named `update_pet_age_on_insert` that returns TRIGGER. After inserting a row into the \"Has_Pet\" table, the function updates the \"Pets\" table, incrementing \"pet_age\" by 1 where \"PetID\" matches the NEW.\"PetID\". Then create a trigger named `trigger_update_pet_age_on_insert` that fires AFTER INSERT on \"Has_Pet\" FOR EACH ROW to execute this function.",
    "natural_language": "Create a trigger function called `update_pet_age_on_insert` that returns a TRIGGER. After a row is inserted into the \"Has_Pet\" table, this function must update the \"Pets\" table by adding 1 to the \"pet_age\" for the matching \"PetID\" from NEW.\"PetID\". Then, set up a trigger named `trigger_update_pet_age_on_insert` to run this function AFTER INSERT on \"Has_Pet\" for each new row.",
    "id": 174
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named \"delete_orphaned_pets\" that is designed to be executed as a trigger. This function takes no explicit parameters but implicitly receives special record variables from the trigger event. Specifically, it accesses the `OLD` record variable, which represents the row that was deleted from the triggering table. The function's primary operation is to perform a `DELETE` statement on the `\"Pets\"` table. The `DELETE` operation targets rows in the `\"Pets\"` table where the value in the `\"PetID\"` column matches the value of the `\"PetID\"` column from the `OLD` record variable (i.e., the `PetID` of the pet that was just disassociated from a person). Additionally, this `DELETE` operation is conditional: it only proceeds if a subquery, `NOT EXISTS (SELECT 1 FROM \"Has_Pet\" WHERE \"PetID\" = OLD.\"PetID\")`, evaluates to true. This subquery checks if there are no remaining entries in the `\"Has_Pet\"` table where the `\"PetID\"` column matches the `\"PetID\"` from the `OLD` record variable. In essence, it verifies that the pet identified by `OLD.\"PetID\"` is no longer associated with any person. After attempting the `DELETE` operation, the function returns the `OLD` record variable, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nFollowing the function definition, a trigger named \"trigger_delete_orphaned_pets\" is created. This trigger is configured to activate `AFTER DELETE` operations on the `\"Has_Pet\"` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for each row that is deleted from the `\"Has_Pet\"` table. When activated, this trigger `EXECUTE`s the previously defined function, \"delete_orphaned_pets\". Therefore, whenever a record is deleted from the `\"Has_Pet\"` table, this trigger will invoke the \"delete_orphaned_pets\" function, which will then attempt to delete the corresponding pet from the `\"Pets\"` table if that pet has become \"orphaned\" (i.e., no longer linked to any person in the `\"Has_Pet\"` table).",
    "plsql": "CREATE OR REPLACE FUNCTION \"delete_orphaned_pets\"() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Pets\" WHERE \"PetID\" = OLD.\"PetID\" AND NOT EXISTS (SELECT 1 FROM \"Has_Pet\" WHERE \"PetID\" = OLD.\"PetID\");\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_delete_orphaned_pets\"\nAFTER DELETE ON \"Has_Pet\"\nFOR EACH ROW EXECUTE FUNCTION \"delete_orphaned_pets\"();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "DELETE FROM \"Has_Pet\" WHERE \"StuID\" = 1001 AND \"PetID\" = 2001;",
      "DELETE FROM \"Has_Pet\" WHERE \"PetID\" = 2002;",
      "DELETE FROM \"Has_Pet\" WHERE \"StuID\" = 1002;",
      "DELETE FROM \"Has_Pet\" WHERE \"StuID\" = 1003 AND \"PetID\" = 2003;",
      "DELETE FROM \"Has_Pet\" WHERE \"PetID\" IN (2001, 2002);"
    ],
    "summary": "Create a trigger function named `delete_orphaned_pets` that returns TRIGGER. After deleting a row from the \"Has_Pet\" table, the function deletes the corresponding row from the \"Pets\" table where \"PetID\" matches the OLD.\"PetID\", but only if no other rows in \"Has_Pet\" reference that same \"PetID\". Then create a trigger named `trigger_delete_orphaned_pets` that fires AFTER DELETE on \"Has_Pet\" FOR EACH ROW to execute this function.",
    "natural_language": "Construct a trigger function called `delete_orphaned_pets` that is defined to return a TRIGGER. This function, which is designed to execute following the deletion of a record from the \"Has_Pet\" table, will meticulously remove the associated entry from the \"Pets\" table precisely where the \"PetID\" column corresponds to the OLD.\"PetID\" value. However, it will perform this cleanup action cautiously, proceeding only when a thorough check confirms that no remaining rows within the \"Has_Pet\" table are still linked to that specific pet identifier. Subsequently, establish a trigger named `trigger_delete_orphaned_pets` that is configured to activate automatically AFTER a DELETE operation on the \"Has_Pet\" table, executing the aforementioned function FOR EACH ROW that is removed.",
    "id": 175
  },
  {
    "ir": "Write a PostgreSQL trigger function named adjust_weight_by_age that returns a trigger and is invoked automatically after any update operation on the pet_age column of the Pets table for each modified row, executing a statement that updates the same Pets table by setting the weight column to its current value plus the product of the newly updated pet_age value from the triggering row (accessed via the NEW record) multiplied by 0.5, specifically targeting the row where the PetID column matches the PetID value from the NEW record, and then returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION \"adjust_weight_by_age\"() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Pets\" SET \"weight\" = \"weight\" + (NEW.\"pet_age\" * 0.5) WHERE \"PetID\" = NEW.\"PetID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_adjust_weight_by_age\"\nAFTER UPDATE OF \"pet_age\" ON \"Pets\"\nFOR EACH ROW EXECUTE FUNCTION \"adjust_weight_by_age\"();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "UPDATE \"Pets\" SET \"pet_age\" = 4 WHERE \"PetID\" = 2001;",
      "UPDATE \"Pets\" SET \"pet_age\" = 5 WHERE \"PetID\" = 2002;",
      "UPDATE \"Pets\" SET \"pet_age\" = \"pet_age\" + 1 WHERE \"PetType\" = 'dog';",
      "UPDATE \"Pets\" SET \"pet_age\" = 3, \"PetType\" = 'cat' WHERE \"PetID\" = 2003;",
      "UPDATE \"Pets\" SET \"pet_age\" = 10 WHERE \"weight\" > 10.0;"
    ],
    "summary": "Create a PostgreSQL trigger function named adjust_weight_by_age that fires AFTER UPDATE on the pet_age column of the Pets table FOR EACH ROW. It updates the weight column in the same Pets table for the matching PetID, setting weight = weight + (NEW.pet_age * 0.5). The function returns the NEW record.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'adjust_weight_by_age'. This function should be configured to execute subsequent to any UPDATE operation performed on the 'pet_age' column within the 'Pets' table, applying its logic to each modified row. Its purpose is to recalculate the 'weight' column for the corresponding 'PetID' by augmenting the existing weight value with the product of the new age and 0.5. The function must conclude by returning the NEW record.",
    "id": 176
  },
  {
    "ir": "Write a PL/pgSQL trigger function named \"prevent_duplicate_pet_ownership\" that is designed to execute before an INSERT operation on the \"Has_Pet\" table. This function takes no explicit parameters but implicitly receives special variables: `NEW` (representing the row about to be inserted) and `OLD` (which is NULL for INSERT operations). The function's primary purpose is to prevent the insertion of duplicate pet ownership records. It achieves this by first executing a SELECT statement to check for the existence of an identical record within the \"Has_Pet\" table. This SELECT statement queries the \"Has_Pet\" table, selecting the literal value `1` (indicating existence) where two conditions are met: the value in the \"StuID\" column of an existing row matches the value in the \"StuID\" column of the `NEW` row (the row being inserted), AND the value in the \"PetID\" column of an existing row matches the value in the \"PetID\" column of the `NEW` row. If this SELECT statement finds at least one matching row (i.e., `IF EXISTS` evaluates to true), indicating a duplicate pet ownership record, the function immediately returns `NULL`. Returning `NULL` from a `BEFORE INSERT` trigger function effectively aborts the insertion of the `NEW` row without raising an error, thus silently preventing the duplicate entry. If the SELECT statement does not find any matching rows (i.e., `IF EXISTS` evaluates to false), meaning the record to be inserted is not a duplicate, the function proceeds to return the `NEW` row. Returning `NEW` allows the original INSERT operation to proceed with the data as provided. This trigger function is then associated with a trigger named \"trigger_prevent_duplicate_pet_ownership\". This trigger is configured to activate `BEFORE INSERT` operations on the \"Has_Pet\" table. It is set to execute `FOR EACH ROW`, meaning the trigger function will be invoked once for every row that is attempted to be inserted into the \"Has_Pet\" table. The trigger executes the \"prevent_duplicate_pet_ownership\" function.",
    "plsql": "CREATE OR REPLACE FUNCTION \"prevent_duplicate_pet_ownership\"() RETURNS TRIGGER AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM \"Has_Pet\" WHERE \"StuID\" = NEW.\"StuID\" AND \"PetID\" = NEW.\"PetID\") THEN\n    -- Instead of raising an exception, return NULL to silently prevent the duplicate insertion.\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_prevent_duplicate_pet_ownership\"\nBEFORE INSERT ON \"Has_Pet\"\nFOR EACH ROW EXECUTE FUNCTION \"prevent_duplicate_pet_ownership\"();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2001);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2002);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1003, 2003);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2001);"
    ],
    "summary": "Create a PL/pgSQL trigger function named prevent_duplicate_pet_ownership that fires BEFORE INSERT on the Has_Pet table FOR EACH ROW. It checks if a record with the same StuID and PetID already exists. If a duplicate is found, return NULL to abort the insert. Otherwise, return NEW to allow the insert.",
    "natural_language": "Write a PL/pgSQL trigger function called prevent_duplicate_pet_ownership. Set it to fire BEFORE INSERT on the Has_Pet table FOR EACH ROW. Make it check for an existing record with the same StuID and PetID. If a duplicate exists, have the function return NULL to cancel the insert. Otherwise, instruct it to return NEW to proceed with the insert.",
    "id": 177
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before any update operation on the country table. This function, named validate_country_update, does not take any parameters directly but operates on the NEW record, which represents the new state of a row being updated. The function checks if the Country_ID column in the NEW record is not null. If the Country_ID is not null, it performs a validation to ensure that this Country_ID exists in the country table by executing a subquery that selects a constant value from the country table where the Country_ID column matches the NEW.Country_ID. If no such Country_ID exists, the function raises an exception with the message 'Invalid Country_ID: ' followed by the invalid Country_ID value. If the Country_ID is valid or null, the function returns the NEW record, allowing the update operation to proceed. The trigger named trigger_validate_country_update is associated with this function and is set to fire before each row update on the country table, ensuring that every update operation on this table is subject to the validation logic defined in the validate_country_update function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_country_update() RETURNS TRIGGER AS $$\nBEGIN\n  -- Validate that the Country_ID exists and is properly referenced\n  IF NEW.\"Country_ID\" IS NOT NULL THEN\n    -- Ensure the Country_ID is valid\n    IF NOT EXISTS (SELECT 1 FROM country WHERE \"Country_ID\" = NEW.\"Country_ID\") THEN\n      RAISE EXCEPTION 'Invalid Country_ID: %', NEW.\"Country_ID\";\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_validate_country_update\nBEFORE UPDATE ON country\nFOR EACH ROW EXECUTE FUNCTION validate_country_update();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE country SET Population = 8300000 WHERE Country_ID = 1;",
      "UPDATE country SET Name = 'Österreich' WHERE Country_ID = 2;",
      "UPDATE country SET Area = 338155, Population = 5265000 WHERE Country_ID = 3;",
      "UPDATE country SET Languages = 'German, English' WHERE Country_ID = 1;",
      "UPDATE country SET Population = 9100000, Area = 450000 WHERE Country_ID = 3;"
    ],
    "summary": "Create a PLpgSQL trigger function named validate_country_update that fires BEFORE UPDATE on the country table FOR EACH ROW. It validates that the NEW.Country_ID, if not null, exists in the country table. If the ID is invalid, raise an exception with the message 'Invalid Country_ID: [value]'. Otherwise, return NEW.",
    "natural_language": "Set up a trigger function called validate_country_update that runs before updates on the country table. It should check if the new Country_ID, when provided, is actually a valid one from the table. If it's not a good match, throw an error saying something like 'Invalid Country_ID: [that value]'. If everything looks okay, just proceed with the update.",
    "id": 178
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `check_budget` that is designed to be executed before `INSERT` or `UPDATE` operations on the `department` table. This function takes no explicit parameters but implicitly receives special variables `NEW` (representing the new row data) and `TG_OP` (representing the operation type). The function's primary purpose is to enforce two data integrity constraints: preventing duplicate `Department_ID` values during `INSERT` operations and ensuring that the `Budget_in_Billions` value does not exceed a specific threshold.\n\nUpon execution, the function first checks the value of `TG_OP`. If `TG_OP` is equal to the string literal 'INSERT', indicating an insertion operation, the function proceeds to check for the existence of a duplicate `Department_ID`. This check is performed by executing a `SELECT 1` query on the `department` table, specifically looking for any row where the `Department_ID` column matches the `Department_ID` value from the `NEW` row. If such a row exists (i.e., the `EXISTS` subquery returns true), the function immediately returns `NULL`, which effectively aborts the `INSERT` operation, preventing the insertion of a row with a duplicate `Department_ID`.\n\nIf the operation is not an `INSERT`, or if it is an `INSERT` and no duplicate `Department_ID` is found, the function then proceeds to evaluate the second constraint. It checks if the value of the `Budget_in_Billions` column in the `NEW` row is greater than the integer literal `200`. If this condition is true, the function again returns `NULL`, which aborts the current `INSERT` or `UPDATE` operation, preventing the `department` table from having a row where `Budget_in_Billions` exceeds `200`.\n\nIf neither of the aforementioned conditions (duplicate `Department_ID` during `INSERT` or `Budget_in_Billions` exceeding `200`) is met, the function returns the `NEW` row. Returning `NEW` allows the original `INSERT` or `UPDATE` operation to proceed with the data as provided in the `NEW` row.\n\nThis `check_budget` function is associated with a trigger named `budget_check_trigger`. This trigger is configured to execute `BEFORE INSERT OR UPDATE` operations on the `department` table. The `FOR EACH ROW` clause specifies that the trigger function `check_budget()` will be executed once for each row affected by the `INSERT` or `UPDATE` statement. The `EXECUTE FUNCTION check_budget()` clause indicates that the `check_budget` function is the routine to be invoked by this trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION check_budget() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if Department_ID already exists for INSERT operations\n  IF TG_OP = 'INSERT' THEN\n    IF EXISTS (SELECT 1 FROM \"department\" WHERE \"Department_ID\" = NEW.\"Department_ID\") THEN\n      RETURN NULL; -- Prevent duplicate insertion\n    END IF;\n  END IF;\n  \n  -- Check budget constraint\n  IF NEW.\"Budget_in_Billions\" > 200 THEN\n    RETURN NULL;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER budget_check_trigger\nBEFORE INSERT OR UPDATE ON \"department\"\nFOR EACH ROW EXECUTE FUNCTION check_budget();",
    "database_name": "department_management",
    "tables": [
      "department"
    ],
    "call_sqls": [
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (4, 'Education', '1979', 4, 150.0, 4000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (5, 'Health', '1953', 5, 180.0, 8000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (6, 'Energy', '1977', 6, 190.0, 10000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (7, 'Agriculture', '1862', 7, 120.0, 5000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (8, 'Commerce', '1903', 8, 160.0, 6000.0);"
    ],
    "summary": "Create a PL/pgSQL trigger function named check_budget that fires BEFORE INSERT OR UPDATE on the department table FOR EACH ROW. For INSERT operations, it prevents duplicate Department_ID values. For all operations, it ensures the Budget_in_Billions does not exceed 200. If either check fails, return NULL to abort the operation. Otherwise, return NEW.",
    "natural_language": "Make a trigger function called check_budget that runs before adding new entries or updating existing ones in the department table. When putting in new records, it should stop any duplicate department IDs from slipping in. For any changes, it needs to keep the budget figure from going over a pretty high limit, say around 200 billion. If something doesn't look right with these checks, just cancel the whole thing. Otherwise, let it proceed.",
    "id": 179
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the department table. The function, named check_creation_year, does not take any parameters and is designed to evaluate the Creation column of the row being inserted. It checks if the value in the Creation column of the new row (referred to as NEW) is less than the year 1900. If this condition is true, the function returns NULL, effectively preventing the insertion of the row into the department table. If the Creation year is 1900 or later, the function returns the NEW row, allowing the insertion to proceed. The trigger, named creation_year_trigger, is associated with the department table and is set to fire before each row is inserted, ensuring that the check_creation_year function is executed for every new row being added to the table.",
    "plsql": "CREATE OR REPLACE FUNCTION check_creation_year() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"Creation\" < '1900' THEN\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER creation_year_trigger\nBEFORE INSERT ON \"department\"\nFOR EACH ROW EXECUTE FUNCTION check_creation_year();",
    "database_name": "department_management",
    "tables": [
      "department"
    ],
    "call_sqls": [
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (10, 'Justice', '1870', 4, 35.2, 113543.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (11, 'Commerce', '1903', 5, 10.5, 45000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (12, 'Health', '1953', 6, 150.0, 80000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (13, 'Test Old', '1850', 7, 1.0, 100.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (14, 'Test Ancient', '1200', 8, 0.5, 50.0);"
    ],
    "summary": "Create a PLpgSQL trigger function named check_creation_year that fires BEFORE INSERT on the department table FOR EACH ROW. It checks if the NEW.Creation year is less than 1900. If true, return NULL to prevent the insert. Otherwise, return NEW to allow the insert.",
    "natural_language": "Alright, so we need a trigger function in PLpgSQL called 'check_creation_year'. Set it up to run BEFORE any new row is INSERTed into the department table. For each new row, it's gotta check if the 'Creation year' field is earlier than 1900. If it is, just bail and return NULL to block the insert. If the year is 1900 or later, then it's all good—just return NEW to let the insert go through.",
    "id": 180
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_settlement_on_claim_insert that is automatically executed after every insert operation on the Claims table for each newly inserted row, which first creates a sequence named settlement_id_seq to generate unique integer identifiers, and within the function body, performs a single insert into the Settlements table, populating its columns with specific values: the Settlement_ID column is assigned the next sequential value from the settlement_id_seq sequence, the Claim_ID column is set to the value of the Claim_ID column from the newly inserted Claims row (referenced as NEW.Claim_ID), the Date_Claim_Made column is set to the NEW.Date_Claim_Made value, the Date_Claim_Settled column is set to the NEW.Date_Claim_Settled value, the Amount_Claimed column is set to the NEW.Amount_Claimed value, the Amount_Settled column is set to the NEW.Amount_Settled value, and the Customer_Policy_ID column is set to the value of the Policy_ID column from the NEW row (NEW.Policy_ID), after which the function returns the NEW row record to the trigger mechanism.",
    "plsql": "CREATE SEQUENCE settlement_id_seq;\n\nCREATE OR REPLACE FUNCTION update_settlement_on_claim_insert() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\")\n  VALUES (nextval('settlement_id_seq'), NEW.\"Claim_ID\", NEW.\"Date_Claim_Made\", NEW.\"Date_Claim_Settled\", NEW.\"Amount_Claimed\", NEW.\"Amount_Settled\", NEW.\"Policy_ID\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_settlement_on_claim_insert\nAFTER INSERT ON \"Claims\"\nFOR EACH ROW EXECUTE FUNCTION update_settlement_on_claim_insert();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1001, 744, '2024-01-15', '2024-02-01', 50000, 45000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1002, 552, '2024-01-20', NULL, 30000, NULL);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1003, 473, '2024-02-10', '2024-03-15', 75000, 60000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1004, 119, '2024-02-28', '2024-03-10', 12000, 10000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1005, 141, '2024-03-05', NULL, 25000, NULL);"
    ],
    "summary": "Create a PostgreSQL trigger function named update_settlement_on_claim_insert that runs AFTER INSERT on the Claims table. It creates a sequence named settlement_id_seq and inserts a row into the Settlements table. The Settlement_ID uses the next sequence value, and other columns (Claim_ID, Date_Claim_Made, Date_Claim_Settled, Amount_Claimed, Amount_Settled, Customer_Policy_ID) are populated from the NEW row's corresponding values. The function returns NEW.",
    "natural_language": "Write a PostgreSQL trigger function called update_settlement_on_claim_insert to execute AFTER INSERT on the Claims table. Have it create a sequence named settlement_id_seq and then insert a record into the Settlements table. Use the next sequence value for Settlement_ID, and fill the other columns (Claim_ID, Date_Claim_Made, Date_Claim_Settled, Amount_Claimed, Amount_Settled, Customer_Policy_ID) from the corresponding values in the NEW row. Ensure the function returns NEW.",
    "id": 181
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the End_Date column in the Customer_Policies table to the value of the Date_Claim_Settled column from the Claims table whenever a row in the Claims table is updated, but only if the Policy_ID in the Customer_Policies table matches the Policy_ID from the updated row in the Claims table and the current End_Date in the Customer_Policies table is earlier than the new Date_Claim_Settled value. The function returns the modified row from the Claims table. The trigger is named trg_update_policy_end_date_on_claim_settle and is set to execute after an update operation on each row of the Claims table, invoking the update_policy_end_date_on_claim_settle function to perform the described update operation.",
    "plsql": "CREATE OR REPLACE FUNCTION update_policy_end_date_on_claim_settle() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Customer_Policies\"\n  SET \"End_Date\" = NEW.\"Date_Claim_Settled\"\n  WHERE \"Policy_ID\" = NEW.\"Policy_ID\" AND \"End_Date\" < NEW.\"Date_Claim_Settled\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_policy_end_date_on_claim_settle\nAFTER UPDATE ON \"Claims\"\nFOR EACH ROW EXECUTE FUNCTION update_policy_end_date_on_claim_settle();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "UPDATE \"Claims\" SET \"Date_Claim_Settled\" = '2018-03-01' WHERE \"Claim_ID\" = 143;",
      "UPDATE \"Claims\" SET \"Date_Claim_Settled\" = '2018-04-15' WHERE \"Claim_ID\" = 423;",
      "UPDATE \"Claims\" SET \"Date_Claim_Settled\" = '2018-05-20' WHERE \"Claim_ID\" = 442;",
      "UPDATE \"Claims\" SET \"Date_Claim_Settled\" = '2019-01-01' WHERE \"Claim_ID\" = 143;",
      "UPDATE \"Claims\" SET \"Date_Claim_Settled\" = '2019-02-10' WHERE \"Claim_ID\" = 423;"
    ],
    "summary": "Create a PLpgSQL trigger function named update_policy_end_date_on_claim_settle that runs AFTER UPDATE on the Claims table. It updates the End_Date in the Customer_Policies table to the NEW Date_Claim_Settled value, but only where the Policy_ID matches and the current End_Date is earlier than the new Date_Claim_Settled. The function returns NEW.",
    "natural_language": "Write a PLpgSQL trigger function called update_policy_end_date_on_claim_settle that executes AFTER UPDATE on the Claims table. This function should set the End_Date in the Customer_Policies table to the NEW Date_Claim_Settled value, but only for matching Policy_IDs and when the current End_Date is before the new Date_Claim_Settled. Ensure the function returns NEW.",
    "id": 182
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_payment_on_settlement that is executed automatically after each new row is inserted into the Settlements table, and within this function, first declare a local variable next_payment_id of type bigint, then compute a new unique payment identifier by querying the Payments table for the current maximum value in the Payment_ID column, using the COALESCE function to substitute zero if no maximum exists, and incrementing that result by one, storing the outcome into the next_payment_id variable, and subsequently perform an INSERT operation into the Payments table, specifying the columns Payment_ID, Settlement_ID, Payment_Method_Code, Date_Payment_Made, and Amount_Payment, and populating them with the values from the next_payment_id variable, the NEW.Settlement_ID value from the triggering Settlements row, the literal string 'MasterCard', the current date from the CURRENT_DATE function, and the NEW.Amount_Settled value from the triggering Settlements row, respectively, and finally return the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_payment_on_settlement() RETURNS TRIGGER AS $$\nDECLARE\n  next_payment_id bigint;\nBEGIN\n  -- Generate a new Payment_ID\n  SELECT COALESCE(MAX(\"Payment_ID\"), 0) + 1 INTO next_payment_id FROM \"Payments\";\n  \n  INSERT INTO \"Payments\" (\"Payment_ID\", \"Settlement_ID\", \"Payment_Method_Code\", \"Date_Payment_Made\", \"Amount_Payment\")\n  VALUES (next_payment_id, NEW.\"Settlement_ID\", 'MasterCard', CURRENT_DATE, NEW.\"Amount_Settled\");\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_payment_on_settlement\nAFTER INSERT ON \"Settlements\"\nFOR EACH ROW EXECUTE FUNCTION insert_payment_on_settlement();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (1, 143, '2017-03-11', '2017-11-03', 43884, 1085, 744);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (2, 423, '2016-08-12', '2018-01-27', 79134, 1724, 552);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (3, 442, '2017-02-24', '2018-01-21', 70088, 1189, 473);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (4, 486, '2018-08-07', '2018-01-16', 38543, 1181, 515);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (5, 621, '2017-08-27', '2018-02-04', 57669, 1427, 617);"
    ],
    "summary": "Create a PostgreSQL trigger function named insert_payment_on_settlement that runs AFTER INSERT on the Settlements table. It declares a bigint variable next_payment_id, sets it to the maximum Payment_ID from the Payments table (or 0) plus one, and inserts a row into the Payments table. The row's values are: next_payment_id, NEW.Settlement_ID, 'MasterCard', CURRENT_DATE, and NEW.Amount_Settled. The function returns NEW.",
    "natural_language": "Alright, so we need a trigger function for PostgreSQL, call it 'insert_payment_on_settlement'. It should kick in right after we add a new record to the Settlements table. Here's what it's gotta do: grab the biggest Payment_ID from the Payments table (or start at 0 if it's empty), add one to it, and stash that number in a variable called next_payment_id. Then, it inserts a fresh row into the Payments table using that new ID, the new settlement's ID, 'MasterCard' as the method, today's date, and the settled amount from the new settlement. Finally, just hand back the NEW record. Got it?",
    "id": 183
  },
  {
    "ir": "Write a PLpgSQL function that updates the Customers table by setting the Customer_Details column to its lowercase version for the row where the Customer_ID matches the Customer_ID of the newly updated row in the Customer_Policies table, and returns the newly updated row. This function is executed by a trigger named trg_update_customer_details_on_policy_update, which is fired after any update operation on the Customer_Policies table, ensuring that for each updated row in Customer_Policies, the corresponding Customer_Details in the Customers table is converted to lowercase.",
    "plsql": "CREATE OR REPLACE FUNCTION update_customer_details_on_policy_update() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Customers\"\n  SET \"Customer_Details\" = LOWER(\"Customer_Details\")\n  WHERE \"Customer_ID\" = NEW.\"Customer_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_customer_details_on_policy_update\nAFTER UPDATE ON \"Customer_Policies\"\nFOR EACH ROW EXECUTE FUNCTION update_customer_details_on_policy_update();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "UPDATE \"Customer_Policies\" SET \"Policy_Type_Code\" = 'Home' WHERE \"Policy_ID\" = 119;",
      "UPDATE \"Customer_Policies\" SET \"Policy_Type_Code\" = 'Health' WHERE \"Policy_ID\" = 141;",
      "UPDATE \"Customer_Policies\" SET \"Policy_Type_Code\" = 'Travel' WHERE \"Policy_ID\" = 143;",
      "UPDATE \"Customer_Policies\" SET \"Start_Date\" = '2019-01-01' WHERE \"Policy_ID\" = 119;",
      "UPDATE \"Customer_Policies\" SET \"End_Date\" = '2020-01-01' WHERE \"Policy_ID\" = 141;"
    ],
    "summary": "Create a PLpgSQL trigger function that runs AFTER UPDATE on the Customer_Policies table. It updates the Customers table, setting the Customer_Details column to lowercase for the row where Customer_ID matches the NEW row's Customer_ID. The function returns the updated NEW row.",
    "natural_language": "Please construct a PL/pgSQL trigger function that executes subsequent to an UPDATE operation on the Customer_Policies table. This function shall modify the Customers table by converting the Customer_Details column to lowercase for the specific record whose Customer_ID corresponds to the Customer_ID value in the NEW row. The function must be defined to return the updated NEW row.",
    "id": 184
  },
  {
    "ir": "Write a PL/pgSQL trigger function named \"insert_round_rank\" that is designed to be executed in response to data manipulation language (DML) events on a table. This function does not accept any explicit input parameters beyond the implicit trigger context. Upon execution, the function performs a single data insertion operation. It inserts a new row into the table named \"round\". The values for the columns in this new row are determined as follows: the \"Member_ID\" column is populated with the value of the \"Member_ID\" column from the newly inserted row in the table that activated the trigger (referred to as NEW.\"Member_ID\"); the \"Decoration_Theme\" column is assigned the literal string value 'New Theme'; and the \"Rank_in_Round\" column is set to the integer literal value 1. After successfully performing this insertion, the function returns the special trigger record variable NEW, which represents the new row that was just inserted into the triggering table, indicating that the original DML operation should proceed with the modified or original row data.\n\nAdditionally, define a trigger named \"trigger_insert_round_rank\" that is configured to activate after an INSERT operation occurs on the table named \"member\". This trigger is set to execute \"FOR EACH ROW\", meaning that the associated trigger function, \"insert_round_rank\", will be invoked once for every individual row that is inserted into the \"member\" table. The trigger specifies that the function to be executed is \"insert_round_rank\", which is a PL/pgSQL function.",
    "plsql": "CREATE OR REPLACE FUNCTION \"insert_round_rank\"() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"round\" (\"Member_ID\", \"Decoration_Theme\", \"Rank_in_Round\")\n  VALUES (NEW.\"Member_ID\", 'New Theme', 1);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_insert_round_rank\"\nAFTER INSERT ON \"member\"\nFOR EACH ROW EXECUTE FUNCTION \"insert_round_rank\"();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\") VALUES (4, 'Gary Player', 'South Africa', 1);",
      "INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\") VALUES (5, 'Seve Ballesteros', 'Spain', 2);",
      "INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\") VALUES (6, 'Tom Watson', 'United States', 3);",
      "INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\") VALUES (7, 'Nick Faldo', 'England', 4);",
      "INSERT INTO \"member\" (\"Member_ID\", \"Name\", \"Country\", \"College_ID\") VALUES (8, 'Lee Trevino', 'Mexico', 1);"
    ],
    "summary": "Create a PL/pgSQL trigger function named insert_round_rank that runs AFTER INSERT on the member table. It inserts a row into the round table with values: NEW.Member_ID for Member_ID, 'New Theme' for Decoration_Theme, and 1 for Rank_in_Round. The function returns NEW.",
    "natural_language": "Create a trigger function in PL/pgSQL called insert_round_rank that executes AFTER an INSERT on the member table. This function should insert a new record into the round table, using NEW.Member_ID for the Member_ID column, 'New Theme' for the Decoration_Theme, and 1 for Rank_in_Round. Ensure the function returns NEW.",
    "id": 185
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the Decoration_Theme column in the round table to the string 'Updated Theme' for any row where the Member_ID matches the Member_ID of the newly updated row in the member table. The function is named update_round_theme and is designed to be executed as a trigger. The trigger, named trigger_update_round_theme, is set to activate after an update operation on the member table. For each row that is updated in the member table, the trigger executes the update_round_theme function, which performs an update operation on the round table. The update operation specifically targets rows in the round table where the Member_ID column matches the Member_ID of the newly updated row in the member table, setting the Decoration_Theme column to 'Updated Theme'. The function returns the NEW row, which represents the state of the row after the update operation in the member table.",
    "plsql": "CREATE OR REPLACE FUNCTION \"update_round_theme\"() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"round\" SET \"Decoration_Theme\" = 'Updated Theme' WHERE \"Member_ID\" = NEW.\"Member_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_update_round_theme\"\nAFTER UPDATE ON \"member\"\nFOR EACH ROW EXECUTE FUNCTION \"update_round_theme\"();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "UPDATE \"member\" SET \"Name\" = 'Tiger Woods' WHERE \"Member_ID\" = 1;",
      "UPDATE \"member\" SET \"Country\" = 'United Kingdom' WHERE \"Member_ID\" = 2;",
      "UPDATE \"member\" SET \"College_ID\" = 3 WHERE \"Member_ID\" = 3;",
      "UPDATE \"member\" SET \"Name\" = 'Phil Mickelson', \"Country\" = 'USA' WHERE \"Member_ID\" = 1;",
      "UPDATE \"member\" SET \"College_ID\" = NULL WHERE \"Member_ID\" = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger on the member table. For each updated row, update the round table's Decoration_Theme to 'Updated Theme' where the Member_ID matches the updated member's Member_ID. Return the NEW row.",
    "natural_language": "Set up a trigger that runs after changes are made to the member table. Whenever a member's details are tweaked, you should also adjust the decoration theme for their associated round table to something like an updated theme, matching on the member ID. Just make sure the new row data comes back.",
    "id": 186
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger that automatically deletes related records from the \"round\" table whenever a record is deleted from the \"member\" table. This trigger is named \"trigger_delete_round_on_member_delete\" and is configured to execute AFTER a DELETE operation occurs on the \"member\" table. It is set to execute FOR EACH ROW that is deleted from the \"member\" table. The trigger invokes a function named \"delete_round_on_member_delete\" for its execution logic. The \"delete_round_on_member_delete\" function is defined to return a TRIGGER type, indicating its role as a trigger function. Inside this function, a DELETE operation is performed on the \"round\" table. The condition for this DELETE operation is specified by the WHERE clause, which states that rows in the \"round\" table should be deleted where the value in the \"Member_ID\" column of the \"round\" table is equal to the value of the \"Member_ID\" column from the OLD record (the record that was just deleted from the \"member\" table). After the DELETE operation is completed, the function returns the OLD record, which is a standard requirement for `FOR EACH ROW` triggers in PostgreSQL, indicating that the original row that caused the trigger to fire should be returned.",
    "plsql": "CREATE OR REPLACE FUNCTION \"delete_round_on_member_delete\"() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"round\" WHERE \"Member_ID\" = OLD.\"Member_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_delete_round_on_member_delete\"\nAFTER DELETE ON \"member\"\nFOR EACH ROW EXECUTE FUNCTION \"delete_round_on_member_delete\"();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "DELETE FROM \"member\" WHERE \"Member_ID\" = 1;",
      "DELETE FROM \"member\" WHERE \"Name\" = 'Billy Casper';",
      "DELETE FROM \"member\" WHERE \"Country\" = 'Canada';",
      "DELETE FROM \"member\" WHERE \"College_ID\" = 4;",
      "DELETE FROM \"member\" WHERE \"Member_ID\" IN (2, 3);"
    ],
    "summary": "Create an AFTER DELETE trigger on the member table. For each deleted row, delete related records from the round table where the Member_ID matches the deleted member's Member_ID. Return the OLD row.",
    "natural_language": "Alright, so every time you wipe a record from the member table, you gotta clean up the round table too. Set up a trigger that fires right after a delete. For each member that gets booted, find and delete all their rounds where the Member_ID matches. Oh, and make sure the trigger spits out the old member's row that you just deleted.",
    "id": 187
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the deletion of any row from the station_company table, executes a process to remove any rows from the gas_station table where the \"Station_ID\" column does not have a corresponding \"Station_ID\" in the station_company table. The function trg_delete_orphaned_stations is defined to perform this operation, and it is associated with a trigger named delete_orphaned_stations. This trigger is set to activate after a DELETE operation on the station_company table and is configured to execute once per statement, not per row. The function does not take any parameters and returns the OLD record, which is a standard practice in triggers to indicate the state of the data before the triggering event. The DELETE operation within the function targets the gas_station table, specifically removing entries where the \"Station_ID\" is not found in the set of \"Station_ID\" values currently present in the station_company table, effectively cleaning up any orphaned records in the gas_station table that no longer have an associated company.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_orphaned_stations() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM gas_station WHERE \"Station_ID\" NOT IN (SELECT \"Station_ID\" FROM station_company);\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_orphaned_stations\nAFTER DELETE ON station_company\nFOR EACH STATEMENT EXECUTE FUNCTION trg_delete_orphaned_stations();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM station_company WHERE \"Station_ID\" = 11;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 1;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 6;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 2;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 3;"
    ],
    "summary": "Create an AFTER DELETE trigger on the station_company table. After a delete statement, remove rows from the gas_station table where the Station_ID no longer exists in the station_company table. Return the OLD record.",
    "natural_language": "How can I create an AFTER DELETE trigger on the station_company table that removes rows from the gas_station table when their Station_ID no longer exists in station_company after a deletion, and returns the OLD record?",
    "id": 188
  },
  {
    "ir": "Write a PLpgSQL function named \"validate_club_leader\" that is designed to be used as a trigger function. This function does not take any parameters directly but operates on the data being inserted into the \"club_leader\" table. The function performs two validation checks before allowing the insertion to proceed. First, it checks whether the \"Club_ID\" value of the new row being inserted exists in the \"club\" table by executing a SELECT query that searches for the \"Club_ID\" in the \"club\" table. If the \"Club_ID\" does not exist, the function raises an exception with a message indicating that the \"Club_ID\" does not exist, including the specific \"Club_ID\" value from the new row. Second, the function checks whether the \"Member_ID\" value of the new row exists in the \"member\" table by executing a similar SELECT query that searches for the \"Member_ID\" in the \"member\" table. If the \"Member_ID\" does not exist, the function raises an exception with a message indicating that the \"Member_ID\" does not exist, including the specific \"Member_ID\" value from the new row. If both validations pass, the function returns the new row, allowing the insertion to proceed. The function is written in the PLpgSQL language. Additionally, a trigger named \"trigger_validate_club_leader\" is created to invoke this function before any row is inserted into the \"club_leader\" table, ensuring that the validations are performed for each new row.",
    "plsql": "CREATE OR REPLACE FUNCTION \"validate_club_leader\"() RETURNS TRIGGER AS $$\nBEGIN\n  -- Validate that Club_ID exists in club table\n  IF NOT EXISTS (SELECT 1 FROM club WHERE \"Club_ID\" = NEW.\"Club_ID\") THEN\n    RAISE EXCEPTION 'Club_ID % does not exist in club table', NEW.\"Club_ID\";\n  END IF;\n  \n  -- Validate that Member_ID exists in member table\n  IF NOT EXISTS (SELECT 1 FROM member WHERE \"Member_ID\" = NEW.\"Member_ID\") THEN\n    RAISE EXCEPTION 'Member_ID % does not exist in member table', NEW.\"Member_ID\";\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_validate_club_leader\"\nBEFORE INSERT ON \"club_leader\"\nFOR EACH ROW EXECUTE FUNCTION \"validate_club_leader\"();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (1, 1984, '2023');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (3, 1985, '2022');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (4, 1986, '2021');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (1, 1988, '2020');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (3, 1984, '2019');"
    ],
    "summary": "Create a BEFORE INSERT trigger on the club_leader table. For each new row, validate that the Club_ID exists in the club table and the Member_ID exists in the member table. Raise an exception with the specific ID if either validation fails. Return the NEW row if valid.",
    "natural_language": "Construct a BEFORE INSERT trigger for the club_leader table. For every inserted row, it is necessary to verify that the provided Club_ID is present within the club table and that the supplied Member_ID is present within the member table. Should either validation be unsuccessful, an exception must be raised indicating the specific identifier that failed. If both validations pass, the NEW row is to be returned.",
    "id": 189
  },
  {
    "ir": "Write a PostgreSQL trigger function named track_leadership_changes that is executed automatically by a trigger named trigger_track_leadership_changes after a delete operation occurs on the club_leader table for each affected row, where the function body begins by noting that for an AFTER DELETE trigger only the OLD record containing the pre-deletion column values is accessible, then performs an operation to log or process the deleted leadership record by raising a NOTICE-level log message with the literal text 'Leadership change: Club_ID %, Member_ID % removed' and substituting the first placeholder with the value from the OLD record's Club_ID column and the second placeholder with the value from the OLD record's Member_ID column, and finally returns the OLD record.",
    "plsql": "CREATE OR REPLACE FUNCTION \"track_leadership_changes\"() RETURNS TRIGGER AS $$\nBEGIN\n  -- For AFTER DELETE trigger, only OLD record is available\n  -- Log or process the deleted leadership record\n  RAISE NOTICE 'Leadership change: Club_ID %, Member_ID % removed', OLD.\"Club_ID\", OLD.\"Member_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_track_leadership_changes\"\nAFTER DELETE ON \"club_leader\"\nFOR EACH ROW EXECUTE FUNCTION \"track_leadership_changes\"();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "DELETE FROM club_leader WHERE Club_ID = 1 AND Member_ID = 1988;",
      "DELETE FROM club_leader WHERE Club_ID = 8 AND Member_ID = 1984;",
      "DELETE FROM club_leader WHERE Club_ID = 6 AND Member_ID = 1985;",
      "DELETE FROM club_leader WHERE Club_ID = 1 AND Member_ID = 1984;",
      "DELETE FROM club_leader WHERE Club_ID = 8 AND Member_ID = 1985;"
    ],
    "summary": "Create an AFTER DELETE trigger on the club_leader table. For each deleted row, raise a NOTICE log with the message 'Leadership change: Club_ID %, Member_ID % removed', substituting the OLD.Club_ID and OLD.Member_ID values. Return the OLD row.",
    "natural_language": "Hey, set up a trigger that kicks in after someone deletes a row from the club_leader table. Every time a row gets axed, it should log a notice saying something like 'Leadership change: Club_ID [old club id], Member_ID [old member id] removed', plugging in the actual old IDs. Just make sure the trigger spits back the old row that was deleted.",
    "id": 190
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Problem_Log\" table. This function ensures data integrity by performing several validation checks on the new row being inserted. First, it checks that the \"problem_id\" column in the new row is not null, raising an exception with the message 'problem_id cannot be null' if it is. Next, it verifies that the \"problem_category_code\" column is not null, raising an exception with the message 'problem_category_code cannot be null' if it is. The function then checks for the existence of a corresponding \"problem_id\" in the \"Problems\" table by executing a SELECT query; if no matching record is found, it raises an exception with the message 'Invalid problem_id: ' followed by the problematic ID. Similarly, it checks for the existence of a corresponding \"problem_category_code\" in the \"Problem_Category_Codes\" table, raising an exception with the message 'Invalid problem_category_code: ' followed by the problematic code if no match is found. Additionally, if the \"assigned_to_staff_id\" column in the new row is not null, the function checks for the existence of a corresponding \"staff_id\" in the \"Staff\" table; if no matching record is found, it raises an exception with the message 'Invalid assigned_to_staff_id: ' followed by the problematic ID. If all validations pass, the function returns the new row, allowing the insert operation to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_problem_log() RETURNS TRIGGER AS $$\nBEGIN\n    -- Validate that required fields are not null\n    IF NEW.problem_id IS NULL THEN\n        RAISE EXCEPTION 'problem_id cannot be null';\n    END IF;\n    \n    IF NEW.problem_category_code IS NULL THEN\n        RAISE EXCEPTION 'problem_category_code cannot be null';\n    END IF;\n    \n    -- Validate foreign key references exist\n    IF NOT EXISTS (SELECT 1 FROM \"Problems\" WHERE problem_id = NEW.problem_id) THEN\n        RAISE EXCEPTION 'Invalid problem_id: %', NEW.problem_id;\n    END IF;\n    \n    IF NOT EXISTS (SELECT 1 FROM \"Problem_Category_Codes\" WHERE problem_category_code = NEW.problem_category_code) THEN\n        RAISE EXCEPTION 'Invalid problem_category_code: %', NEW.problem_category_code;\n    END IF;\n    \n    IF NEW.assigned_to_staff_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM \"Staff\" WHERE staff_id = NEW.assigned_to_staff_id) THEN\n        RAISE EXCEPTION 'Invalid assigned_to_staff_id: %', NEW.assigned_to_staff_id;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_problem_log\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_problem_log();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Category_Codes\" (problem_category_code, problem_category_description) VALUES ('Datatabase', 'Database design or contents.');",
      "INSERT INTO \"Problems\" (problem_id, product_id, reported_by_staff_id, date_problem_reported, problem_description) VALUES (1, 1, 1, '2023-01-01 10:00:00+00', 'Test problem description');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_category_code, log_entry_date, log_entry_description) VALUES (1, 1, 'Datatabase', '2023-01-01 10:05:00+00', 'Initial log entry');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_category_code, assigned_to_staff_id, log_entry_date, log_entry_description) VALUES (2, 1, 'Datatabase', NULL, '2023-01-01 10:10:00+00', 'Second log entry');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_category_code, log_entry_date, log_entry_description) VALUES (3, 1, 'GUI', '2023-01-01 10:15:00+00', 'Third log entry');"
    ],
    "summary": "Create a BEFORE INSERT trigger function for the \"Problem_Log\" table that validates the new row. It must check that problem_id and problem_category_code are not null. It must verify that the problem_id exists in the \"Problems\" table and the problem_category_code exists in the \"Problem_Category_Codes\" table. If assigned_to_staff_id is not null, it must also verify it exists in the \"Staff\" table. Raise specific exceptions for any validation failure. Return the NEW row if all checks pass.",
    "natural_language": "Write a BEFORE INSERT trigger function for the \"Problem_Log\" table to validate new rows. Ensure the problem_id and problem_category_code are not null. Confirm the problem_id exists in the \"Problems\" table and the problem_category_code exists in the \"Problem_Category_Codes\" table. If assigned_to_staff_id is provided, also verify it exists in the \"Staff\" table. Raise specific exceptions for any failed validation. Return the NEW row if all checks pass.",
    "id": 191
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_rank_problem_insert that is executed automatically before each new row is inserted into the table named \"Problem_Log\". This function operates on a special record variable named NEW, which represents the row about to be inserted. The function performs a SELECT query on the \"Problem_Log\" table to retrieve the maximum existing value from the column problem_log_id. It uses the COALESCE function to handle the case where the table is empty, substituting a value of 0 if the maximum is NULL. The function then adds 1 to this retrieved maximum value and assigns the result directly to the NEW.problem_log_id column of the incoming row. Finally, the function returns the modified NEW row record, thereby ensuring the inserted row contains this newly generated sequential identifier. A database trigger named rank_problem_insert is defined to invoke this function, specifying that it fires BEFORE INSERT on the \"Problem_Log\" table and executes the function once FOR EACH ROW.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_rank_problem_insert() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.problem_log_id := (SELECT COALESCE(MAX(problem_log_id), 0) + 1 FROM \"Problem_Log\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER rank_problem_insert\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION trg_rank_problem_insert();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (11, 1, 'Datatabase', 'Reported', '2023-10-01 10:00:00+08:00', 'Initial log entry', 'Fix pending', 'Details pending');",
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (12, 2, 'GUI', 'Solved', '2023-10-02 11:00:00+08:00', 'UI issue resolved', 'Applied patch', 'No further issues');",
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (11, 3, 'Middleware', 'Reported', '2023-10-03 12:00:00+08:00', 'Middleware error', 'Investigation ongoing', 'Awaiting logs');",
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (12, 1, 'Datatabase', 'Solved', '2023-10-04 13:00:00+08:00', 'Database issue fixed', 'Index rebuilt', 'Performance improved');",
      "INSERT INTO \"Problem_Log\" (assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (11, 2, 'GUI', 'Reported', '2023-10-05 14:00:00+08:00', 'UI glitch', 'Pending review', 'User feedback required');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named trg_rank_problem_insert for the \"Problem_Log\" table. For each new row, set NEW.problem_log_id to the maximum existing problem_log_id plus 1, defaulting to 1 if the table is empty. Return the modified NEW row.",
    "natural_language": "Please construct a BEFORE INSERT trigger function designated as trg_rank_problem_insert for the \"Problem_Log\" table. The function's operation shall be as follows: for each incoming row, the value for NEW.problem_log_id must be assigned to one greater than the current maximum problem_log_id present in the table. In the event the table contains no records, this value should default to 1. Subsequently, the function must return the modified NEW row.",
    "id": 192
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_auto_close_problem that is executed automatically after each row update on the \"Problems\" table, which takes no explicit parameters but implicitly receives the OLD and NEW row records for the updated row, and within this function, it checks if the NEW record's date_problem_closed column has a non-NULL value, and if this condition is true, it performs a DELETE operation on the \"Problem_Log\" table where the problem_id column matches the NEW.problem_id value from the \"Problems\" table and simultaneously where the problem_status_code column in \"Problem_Log\" does not equal the string literal 'Solved', thereby removing any log entries for the specific problem that are not marked as 'Solved' when the problem is closed, and finally the function returns the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_auto_close_problem() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.date_problem_closed IS NOT NULL THEN\n        DELETE FROM \"Problem_Log\" \n        WHERE problem_id = NEW.problem_id \n          AND problem_status_code != 'Solved';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER auto_close_problem\nAFTER UPDATE ON \"Problems\"\nFOR EACH ROW EXECUTE FUNCTION trg_auto_close_problem();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Problems\" SET date_problem_closed = CURRENT_TIMESTAMP WHERE problem_id = 1;",
      "UPDATE \"Problems\" SET date_problem_closed = '2024-01-15 10:30:00+00' WHERE problem_id = 2;",
      "UPDATE \"Problems\" SET date_problem_closed = date_problem_reported + INTERVAL '7 days', closure_authorised_by_staff_id = 5 WHERE problem_id = 3;",
      "UPDATE \"Problems\" SET date_problem_closed = NOW() WHERE problem_id IN (4,5);",
      "UPDATE \"Problems\" SET date_problem_closed = '2024-03-20 14:45:00+00', problem_description = 'Fixed issue' WHERE problem_id = 6;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_auto_close_problem for the \"Problems\" table. If the updated row's date_problem_closed is set to a non-NULL value, delete all rows from the \"Problem_Log\" table where the problem_id matches and the problem_status_code is not 'Solved'. Return the NEW row.",
    "natural_language": "Create AFTER UPDATE trigger trg_auto_close_problem on Problems. If date_problem_closed is set, delete from Problem_Log where problem_id matches and status is not 'Solved'. Return NEW.",
    "id": 193
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_sync_problem_status that is executed automatically after every insert operation on the table named \"Problem_Log\" for each newly inserted row, where the function has no explicit input parameters but accesses the new row's data through the special NEW record variable, and within its body, it performs an update on the table named \"Problems\", specifically setting the column date_problem_closed to the value from the NEW.log_entry_date column, but only for the row in the \"Problems\" table where the column problem_id matches the value from NEW.problem_id and only if the column NEW.problem_status_code contains the exact string value 'Solved', and finally the function returns the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_sync_problem_status() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Problems\" SET date_problem_closed = NEW.log_entry_date WHERE problem_id = NEW.problem_id AND NEW.problem_status_code = 'Solved';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sync_problem_status\nAFTER INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION trg_sync_problem_status();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (1001, 11, 11, 'Middleware', 'Solved', '2024-01-15 10:30:00+08:00', 'Fixed connection pool issue', 'Increased pool size', 'Resolved performance bottleneck');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (1002, 12, 8, 'GUI', 'Solved', '2024-01-16 14:45:00+08:00', 'Fixed button alignment', 'Updated CSS styles', 'UI now responsive');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (1003, 11, 1, 'Datatabase', 'Solved', '2024-01-17 09:15:00+08:00', 'Resolved deadlock', 'Added proper indexing', 'Query performance improved');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (1004, 12, 2, 'GUI', 'Reported', '2024-01-18 11:20:00+08:00', 'New issue reported', NULL, 'Needs investigation');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (1005, 11, 3, 'Middleware', 'Solved', '2024-01-19 16:10:00+08:00', 'Fixed memory leak', 'Implemented proper cleanup', 'System stable now');"
    ],
    "summary": "Create an AFTER INSERT trigger function named trg_sync_problem_status for the \"Problem_Log\" table. For each new row, if the NEW.problem_status_code is 'Solved', update the \"Problems\" table to set date_problem_closed to NEW.log_entry_date for the matching problem_id. Return the NEW row.",
    "natural_language": "Construct an AFTER INSERT trigger function, which should be named trg_sync_problem_status, specifically for the \"Problem_Log\" table. For every single newly inserted row, you must carefully check if the NEW.problem_status_code is explicitly set to the value 'Solved'. If this condition is met, you should then proceed to update the corresponding record in the \"Problems\" table, precisely setting its date_problem_closed column to the value found in NEW.log_entry_date, but only where the problem_id in both tables matches perfectly. Finally, ensure the function returns the complete NEW row.",
    "id": 194
  },
  {
    "ir": "Write a PLpgSQL trigger function named `trg_validate_staff_assignment` that is designed to be executed before an `INSERT` operation on the `\"Problem_Log\"` table, for each row being inserted. This function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records from the triggering event. The primary purpose of this function is to validate the `assigned_to_staff_id` column of the new row being inserted into the `\"Problem_Log\"` table. Specifically, it performs a `SELECT` operation to check for the existence of the value present in `NEW.assigned_to_staff_id` within the `staff_id` column of the `\"Staff\"` table. The `SELECT` statement `SELECT 1 FROM \"Staff\" WHERE staff_id = NEW.assigned_to_staff_id` attempts to retrieve a single arbitrary column (represented by `1`) from the `\"Staff\"` table, filtering the results where the `staff_id` column in the `\"Staff\"` table is equal to the value of the `assigned_to_staff_id` column from the `NEW` record (which represents the row currently being inserted into `\"Problem_Log\"`). If this `SELECT` operation returns no rows, indicating that the `assigned_to_staff_id` from the new `\"Problem_Log\"` record does not correspond to an existing `staff_id` in the `\"Staff\"` table, then the function raises an exception. The exception message is a string literal: 'Invalid assigned_to_staff_id: % does not exist in Staff table.', where the '%' placeholder is dynamically replaced by the actual value of `NEW.assigned_to_staff_id`. If the `assigned_to_staff_id` is found to exist in the `\"Staff\"` table, the function proceeds without raising an exception and returns the `NEW` record, allowing the `INSERT` operation on the `\"Problem_Log\"` table to continue with the validated row. This trigger function is then associated with a trigger named `validate_staff_assignment`, which is configured to execute `BEFORE INSERT` on the `\"Problem_Log\"` table `FOR EACH ROW`, invoking the `trg_validate_staff_assignment()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_staff_assignment() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if the assigned_to_staff_id exists in the Staff table\n    IF NOT EXISTS (SELECT 1 FROM \"Staff\" WHERE staff_id = NEW.assigned_to_staff_id) THEN\n        RAISE EXCEPTION 'Invalid assigned_to_staff_id: % does not exist in Staff table.', NEW.assigned_to_staff_id;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_staff_assignment\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_staff_assignment();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (1, 1, 1, 'GUI', 'Reported', '2023-01-01 10:00:00+00', 'Description 1', 'Fix 1', 'Details 1');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (2, 2, 2, 'Datatabase', 'Solved', '2023-01-02 11:00:00+00', 'Description 2', 'Fix 2', 'Details 2');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (3, 3, 3, 'Middleware', 'Reported', '2023-01-03 12:00:00+00', 'Description 3', 'Fix 3', 'Details 3');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (4, 1, 1, 'GUI', 'Solved', '2023-01-04 13:00:00+00', 'Description 4', 'Fix 4', 'Details 4');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (5, 2, 2, 'Datatabase', 'Reported', '2023-01-05 14:00:00+00', 'Description 5', 'Fix 5', 'Details 5');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named trg_validate_staff_assignment for the \"Problem_Log\" table. For each new row, if NEW.assigned_to_staff_id is not null, verify it exists in the \"Staff\" table. Raise an exception with the invalid ID if it does not exist. Return the NEW row.",
    "natural_language": "Define a BEFORE INSERT trigger function called trg_validate_staff_assignment for the \"Problem_Log\" table. For every new row, check if NEW.assigned_to_staff_id is not null. If it is not null, confirm that this ID exists in the \"Staff\" table. If the ID is not found, raise an exception that includes the invalid ID. Finally, return the NEW row.",
    "id": 195
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_city_distance that is executed automatically after every new row insertion into the \"City\" table, and within this function, perform an INSERT operation into the \"Direct_distance\" table, specifying the columns city1_code, city2_code, and distance, where the value for city1_code is taken from the newly inserted row's city_code column, the value for city2_code is the literal string 'NYC', and the value for distance is the literal integer 200, and then return the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_city_distance() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Direct_distance\" (city1_code, city2_code, distance)\n  VALUES (NEW.city_code, 'NYC', 200);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_city_distance\nAFTER INSERT ON \"City\"\nFOR EACH ROW EXECUTE FUNCTION insert_city_distance();",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('LAX', 'Los Angeles', 'CA', 'USA', 34.0522, -118.2437);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('CHI', 'Chicago', 'IL', 'USA', 41.8781, -87.6298);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('MIA', 'Miami', 'FL', 'USA', 25.7617, -80.1918);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('DEN', 'Denver', 'CO', 'USA', 39.7392, -104.9903);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('SEA', 'Seattle', 'WA', 'USA', 47.6062, -122.3321);"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_city_distance on the City table. For each new row, insert a record into the Direct_distance table with city1_code from NEW.city_code, city2_code as 'NYC', and distance as 200. Return NEW.",
    "natural_language": "Construct an AFTER INSERT trigger function, which should be named insert_city_distance, to be associated with the City table. For every single new row that is successfully inserted, you must then proceed to insert a corresponding record into the Direct_distance table. This new record should carefully use the city1_code drawn from the NEW.city_code value, explicitly set the city2_code to the constant value 'NYC', and assign a fixed distance of 200 units. Finally, the trigger function must conclude by returning the NEW row.",
    "id": 196
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_student_record that returns a trigger and is executed by a trigger named trg_delete_student_record, which is defined to fire BEFORE a DELETE operation on each row of the table named \"City\", where the function performs two sequential DELETE operations: first, it deletes all rows from the table named \"Direct_distance\" where the column city1_code equals the value of the city_code column from the OLD row record (the row being deleted from \"City\") OR where the column city2_code equals that same OLD.city_code value, and second, it deletes all rows from the table named \"Student\" where the column city_code equals the OLD.city_code value, after which the function returns the OLD row record.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_student_record() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Direct_distance\" WHERE city1_code = OLD.city_code OR city2_code = OLD.city_code;\n  DELETE FROM \"Student\" WHERE city_code = OLD.city_code;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_student_record\nBEFORE DELETE ON \"City\"\nFOR EACH ROW EXECUTE FUNCTION delete_student_record();",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "DELETE FROM \"City\" WHERE city_code = 'BAL';",
      "DELETE FROM \"City\" WHERE city_code = 'PIT';",
      "DELETE FROM \"City\" WHERE city_code = 'PHL';",
      "DELETE FROM \"City\" WHERE city_code = 'ATL';",
      "DELETE FROM \"City\" WHERE city_code = 'HKG';"
    ],
    "summary": "Create a BEFORE DELETE trigger function named delete_student_record on the City table. For each old row, first delete from Direct_distance where city1_code or city2_code equals OLD.city_code, then delete from Student where city_code equals OLD.city_code. Return OLD.",
    "natural_language": "Construct a BEFORE DELETE trigger function, which should be named delete_student_record, to be applied on the City table. For every individual old row that is about to be removed, the function must first meticulously delete all associated records from the Direct_distance table where either the city1_code or the city2_code precisely matches the OLD.city_code. Subsequently, it should proceed to carefully delete any corresponding entries from the Student table where the city_code is exactly equal to the OLD.city_code. Finally, the function must reliably return the OLD row.",
    "id": 197
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_pet_age that returns a trigger, which is automatically executed by a trigger named pet_age_update defined on the Has_Pet table; the trigger is configured to fire after a new row is inserted into the Has_Pet table for each inserted row, and the function's logic performs an update operation on the Pets table, specifically incrementing the pet_age column value by one for the single row in the Pets table where the PetID column value exactly matches the PetID column value from the newly inserted row (referenced as NEW.PetID) in the Has_Pet table, and the function concludes by returning the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_pet_age() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Pets\"\n  SET \"pet_age\" = \"pet_age\" + 1\n  WHERE \"PetID\" = NEW.\"PetID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER pet_age_update\nAFTER INSERT ON \"Has_Pet\"\nFOR EACH ROW EXECUTE FUNCTION update_pet_age();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2001);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2002);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1003, 2003);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2002);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2003);"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_pet_age on the Has_Pet table. For each new row, update the Pets table by incrementing pet_age by 1 where PetID equals NEW.PetID. Return NEW.",
    "natural_language": "Alright, so I need you to set up a trigger that kicks in after we add a new record to the Has_Pet table. Name this trigger function \"update_pet_age\". Basically, every time a new row is inserted, it should go and bump up the pet_age by 1 in the Pets table, but only for the PetID that matches the NEW.PetID from the insert. Don't forget to have it return NEW at the end.",
    "id": 198
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_student_city that is executed automatically by a trigger named student_city_insert, where the trigger is defined to fire after an insert operation on the Student table for each new row added, and the function's logic is to insert new records into the Has_Pet table by selecting the StuID value from the newly inserted Student row (referenced as NEW.\"StuID\") and pairing it with every PetID value from the Pets table where the PetType column in the Pets table has the exact string value 'dog', thereby creating an association in the Has_Pet table between the new student and all existing pets of type dog.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_student_city() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\")\n  SELECT NEW.\"StuID\", \"PetID\"\n  FROM \"Pets\"\n  WHERE \"PetType\" = 'dog';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER student_city_insert\nAFTER INSERT ON \"Student\"\nFOR EACH ROW EXECUTE FUNCTION insert_student_city();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1004, 'Brown', 'Charlie', 20, 'M', 601, 1122, 'NYC');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1005, 'Davis', 'Diana', 22, 'F', 602, 7713, 'LAX');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1006, 'Miller', 'Mike', 19, 'M', 603, 7793, 'CHI');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1007, 'Wilson', 'Wendy', 21, 'F', 604, 1124, 'MIA');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1008, 'Taylor', 'Tom', 23, 'M', 605, 7715, 'DAL');"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_student_city on the Student table. For each new row, insert into Has_Pet by selecting NEW.StuID and every PetID from Pets where PetType is 'dog'. Return NEW.",
    "natural_language": "Set up a trigger that runs after adding a student. It should link the new student with a bunch of pet IDs, specifically those for pets that are commonly considered dogs. Make sure the new record is processed.",
    "id": 199
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_student_major that returns a trigger, which is automatically executed as an AFTER INSERT trigger named student_major_update on the Student table for each new row inserted. The function, when invoked, performs an UPDATE operation on the Student table, specifically setting the value of the Major column to 700 for any existing student record where the StuID column matches the StuID value from the newly inserted row (accessed via the NEW record) and where the Major value from that same NEW record is exactly equal to 600. The function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_student_major() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Student\"\n  SET \"Major\" = 700\n  WHERE \"StuID\" = NEW.\"StuID\" AND NEW.\"Major\" = 600;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER student_major_update\nAFTER INSERT ON \"Student\"\nFOR EACH ROW EXECUTE FUNCTION update_student_major();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1004, 'Doe', 'John', 20, 'M', 600, 1121, 'NYC');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1005, 'Brown', 'Alice', 22, 'F', 600, 7712, 'LA');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1006, 'White', 'Bob', 23, 'M', 600, 7792, 'CHI');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1007, 'Green', 'Carol', 21, 'F', 600, 1121, 'SF');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1008, 'Black', 'Eve', 19, 'F', 600, 7712, 'SEA');"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_student_major on the Student table. For each new row, if NEW.Major equals 600, update the Student table to set Major to 700 where StuID equals NEW.StuID. Return NEW.",
    "natural_language": "Please construct an AFTER INSERT trigger function designated as 'update_student_major' for the Student table. For every newly inserted row, in the event that the NEW.Major value is precisely 600, execute an update on the Student table to assign a Major value of 700 for the record whose StuID matches NEW.StuID. The function should conclude by returning the NEW row.",
    "id": 200
  },
  {
    "ir": "Write a PL/pgSQL function named `insert_pet_weight` that is designed to be executed as a trigger, and a trigger named `pet_weight_insert` that invokes this function. The `insert_pet_weight` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. It does not accept any explicit parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The core operation within this function is an `INSERT` statement targeting the `\"Has_Pet\"` table. This `INSERT` statement populates the `\"StuID\"` and `\"PetID\"` columns of the `\"Has_Pet\"` table. The values for these columns are derived from a `SELECT` subquery. Specifically, the `\"StuID\"` column is populated with values from the `\"StuID\"` column of the `\"Student\"` table. The `\"PetID\"` column is populated with the value of the `\"PetID\"` column from the `NEW` record, which represents the newly inserted row in the `\"Pets\"` table that activated the trigger. The `SELECT` subquery includes a `WHERE` clause that filters the rows from the `\"Student\"` table, ensuring that only students whose `\"Age\"` column value is greater than `20` are considered for the insertion into `\"Has_Pet\"`. After the `INSERT` operation, the function returns the `NEW` record, which is standard practice for `AFTER` row-level triggers in PostgreSQL. The `pet_weight_insert` trigger is defined to activate `AFTER INSERT` operations on the `\"Pets\"` table. It is configured to execute `FOR EACH ROW`, meaning that the `insert_pet_weight` function will be invoked once for every row that is inserted into the `\"Pets\"` table. The `EXECUTE FUNCTION insert_pet_weight()` clause specifies that the `insert_pet_weight` function should be called when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_pet_weight() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\")\n  SELECT \"StuID\", NEW.\"PetID\"\n  FROM \"Student\"\n  WHERE \"Age\" > 20;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER pet_weight_insert\nAFTER INSERT ON \"Pets\"\nFOR EACH ROW EXECUTE FUNCTION insert_pet_weight();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\") VALUES (2004, 'dog', 4, 15.5);",
      "INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\") VALUES (2005, 'cat', 2, 8.2);",
      "INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\") VALUES (2006, 'bird', 1, 0.5);",
      "INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\") VALUES (2007, 'rabbit', 3, 2.1);",
      "INSERT INTO \"Pets\" (\"PetID\", \"PetType\", \"pet_age\", \"weight\") VALUES (2008, 'fish', 1, 0.1);"
    ],
    "summary": "Create a trigger function named insert_pet_weight that returns TRIGGER. After a row is inserted into the \"Pets\" table, insert a new row into the \"Has_Pet\" table. Set \"PetID\" to the new \"Pets\".\"PetID\". Set \"StuID\" by selecting \"StuID\" from the \"Student\" table where \"Age\" > 20. Return the NEW record. Create an AFTER INSERT trigger named pet_weight_insert on the \"Pets\" table for each row to execute this function.",
    "natural_language": "Alright, so we need a trigger function called insert_pet_weight that spits out a TRIGGER. Here's the deal: right after someone adds a new pet to the \"Pets\" table, we gotta also pop a new entry into the \"Has_Pet\" table. For that new entry, take the \"PetID\" straight from the new pet's record. For the \"StuID\", grab it from the \"Student\" table, but only pick a student who's over 20 years old. Once that's done, just hand back the NEW record. Oh, and don't forget to set up the actual trigger—call it pet_weight_insert, make it an AFTER INSERT trigger on the \"Pets\" table, and have it run this function for every new row.",
    "id": 201
  },
  {
    "ir": "Write a PostgreSQL trigger function named normalize_country_languages that returns a trigger and is executed automatically by a trigger named country_language_normalize_trigger, which is defined to fire BEFORE UPDATE on the table named \"country\" for each row being updated; the function's logic is to process the NEW row's value in the column named \"Languages\", which is a text string, by first using the string_to_array function to split this text into an array of substrings using a single space character as the delimiter, then using the array_replace function to scan this resulting array and replace every element that exactly matches the string 'Swedish' with the new string 'Svenska', then using the array_to_string function to recombine the modified array elements back into a single text string using a single space character as the delimiter, and finally assigning this newly constructed string back to the NEW.\"Languages\" column before returning the NEW row record for the update operation.",
    "plsql": "CREATE OR REPLACE FUNCTION normalize_country_languages() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.\"Languages\" = array_to_string(array_replace(string_to_array(NEW.\"Languages\", ' '), 'Swedish', 'Svenska'), ' ');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER country_language_normalize_trigger\nBEFORE UPDATE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION normalize_country_languages();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE country SET \"Languages\" = 'Swedish' WHERE \"Country_ID\" = 3;",
      "UPDATE country SET \"Languages\" = 'Finnish Swedish' WHERE \"Name\" = 'Finland';",
      "UPDATE country SET \"Languages\" = 'Swedish English' WHERE \"Country_ID\" = 3;",
      "UPDATE country SET \"Languages\" = 'Swedish German' WHERE \"Name\" = 'Sweden';",
      "UPDATE country SET \"Languages\" = 'Swedish Norwegian Danish' WHERE \"Country_ID\" = 3;"
    ],
    "summary": "Create a trigger function named normalize_country_languages that returns TRIGGER. Before updating a row in the \"country\" table, process the NEW.\"Languages\" text. Split it into an array using space as a delimiter, replace all 'Swedish' elements with 'Svenska', then rejoin the array into a string with spaces. Assign the result back to NEW.\"Languages\" and return the NEW record. Create a BEFORE UPDATE trigger named country_language_normalize_trigger on the \"country\" table for each row to execute this function.",
    "natural_language": "Define a trigger function called normalize_country_languages that returns TRIGGER. Before any row update in the \"country\" table, take the NEW.\"Languages\" text, split it by spaces into an array, change any 'Swedish' entries to 'Svenska', and then join the array back with spaces. Set NEW.\"Languages\" to this new string and return NEW. Then, set up a BEFORE UPDATE trigger named country_language_normalize_trigger on the \"country\" table to run this function for each row.",
    "id": 202
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `delete_related_coasters` that is designed to be executed in response to a data manipulation event, and a trigger named `country_delete_cascade_trigger` that invokes this function. The `delete_related_coasters` function is defined to return `TRIGGER`, indicating its purpose as a trigger function. Upon execution, this function performs a `DELETE` operation on the table named `\"roller_coaster\"`. The `DELETE` operation targets rows in the `\"roller_coaster\"` table where the value in its `\"Country_ID\"` column matches the value of the `\"Country_ID\"` column from the `OLD` record. The `OLD` record represents the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function explicitly returns `NULL`, which is the standard return value for `AFTER` row-level triggers in PostgreSQL when no modification to the triggering statement's result is intended. The `country_delete_cascade_trigger` is an `AFTER DELETE` trigger, meaning it activates after a `DELETE` statement has successfully removed one or more rows from the `\"country\"` table. It is defined as a `FOR EACH ROW` trigger, which means the `delete_related_coasters` function will be executed once for each individual row that is deleted from the `\"country\"` table. The trigger's purpose is to `EXECUTE FUNCTION delete_related_coasters()`, thereby invoking the previously described function. This setup ensures that whenever a row is deleted from the `\"country\"` table, all corresponding rows in the `\"roller_coaster\"` table that have a matching `\"Country_ID\"` are also automatically deleted, effectively implementing a cascading delete behavior.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_coasters() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"roller_coaster\" WHERE \"Country_ID\" = OLD.\"Country_ID\";\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER country_delete_cascade_trigger\nAFTER DELETE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION delete_related_coasters();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM country WHERE Country_ID = 1;",
      "DELETE FROM country WHERE Country_ID = 2;",
      "DELETE FROM country WHERE Country_ID = 3;",
      "DELETE FROM country WHERE Name = 'Austria';",
      "DELETE FROM country WHERE Population = 5261008;"
    ],
    "summary": "Create a trigger function named delete_related_coasters that returns TRIGGER. After a row is deleted from the \"country\" table, delete all rows from the \"roller_coaster\" table where \"Country_ID\" equals the OLD.\"Country_ID\". Return NULL. Create an AFTER DELETE trigger named country_delete_cascade_trigger on the \"country\" table for each row to execute this function.",
    "natural_language": "Construct a trigger function, which should be named delete_related_coasters, that is designed to return a TRIGGER. This function will perform a crucial cleanup operation: immediately after a specific row is permanently removed from the \"country\" table, it must meticulously locate and delete every single corresponding row from the \"roller_coaster\" table where the \"Country_ID\" column precisely matches the OLD.\"Country_ID\" value from the deleted record. The function should then definitively return NULL. Furthermore, you must establish an AFTER DELETE trigger, to be called country_delete_cascade_trigger, on the \"country\" table; this trigger should be configured to fire for each individual row that is deleted, thereby reliably executing the aforementioned function.",
    "id": 203
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_coaster_park that returns a trigger, which is executed by a trigger named roller_coaster_park_update_trigger defined to fire BEFORE UPDATE on the table named roller_coaster for each row being updated, where the function's logic unconditionally assigns the literal string value 'Updated Park' to the NEW record's column named Park, and then returns the modified NEW record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_coaster_park() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.\"Park\" = 'Updated Park';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER roller_coaster_park_update_trigger\nBEFORE UPDATE ON \"roller_coaster\"\nFOR EACH ROW EXECUTE FUNCTION update_coaster_park();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE \"roller_coaster\" SET \"Name\" = 'Boardwalk Bullet' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE \"roller_coaster\" SET \"Name\" = 'Dauling Dragon' WHERE \"Roller_Coaster_ID\" = 2;",
      "UPDATE \"roller_coaster\" SET \"Name\" = 'Hades 360' WHERE \"Roller_Coaster_ID\" = 3;",
      "UPDATE \"roller_coaster\" SET \"Length\" = 3236.0 WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE \"roller_coaster\" SET \"Height\" = 105.0 WHERE \"Roller_Coaster_ID\" = 2;"
    ],
    "summary": "Create a trigger function named update_coaster_park that returns TRIGGER. Before updating a row in the roller_coaster table, set the NEW.\"Park\" column to the string 'Updated Park'. Return the NEW record. Create a BEFORE UPDATE trigger named roller_coaster_park_update_trigger on the roller_coaster table for each row to execute this function.",
    "natural_language": "Construct a trigger function, which should be named update_coaster_park, that is explicitly defined to return a value of type TRIGGER. This function must be designed so that, just prior to the actual modification of any existing row within the roller_coaster table, it will meticulously assign the value 'Updated Park' to the NEW.\"Park\" column. The function must then carefully return the fully prepared NEW record. Subsequently, you must establish a BEFORE UPDATE trigger, to be called roller_coaster_park_update_trigger, which will be securely attached to the roller_coaster table and configured to faithfully execute this precise function for every single row that is updated.",
    "id": 204
  },
  {
    "ir": "Write a PL/pgSQL function named `archive_deleted_country` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function's primary purpose is to insert a new record into the `\"roller_coaster\"` table. The values for this new record are derived as follows: the `\"Roller_Coaster_ID\"` column is populated by adding the integer value 2000 to the value of the `\"Country_ID\"` column from the `OLD` record (the row that was deleted). The `\"Name\"` column is set to the literal string 'Archived'. The `\"Park\"` column is set to the literal string 'Archive Park'. The `\"Country_ID\"` column is populated with the value of the `\"Country_ID\"` column from the `OLD` record. The `\"Length\"` column is set to the floating-point value 0.0. The `\"Height\"` column is set to the floating-point value 0.0. The `\"Speed\"` column is set to the literal string '0'. The `\"Opened\"` column is set to the literal string 'Archived'. The `\"Status\"` column is set to the literal string 'Archived'. After performing this insertion, the function returns the `OLD` record, which is standard behavior for `AFTER DELETE` triggers that do not intend to prevent the deletion.\n\nAdditionally, a trigger named `country_archive_trigger` is created. This trigger is configured to activate `AFTER DELETE` operations on the `\"country\"` table. It is specified to execute `FOR EACH ROW`, meaning that the `archive_deleted_country` function will be invoked once for every row that is deleted from the `\"country\"` table. The trigger executes the `archive_deleted_country` function, which, as described, inserts an archived record into the `\"roller_coaster\"` table based on the details of the deleted country row.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_deleted_country() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"roller_coaster\" (\"Roller_Coaster_ID\", \"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES (OLD.\"Country_ID\" + 2000, 'Archived', 'Archive Park', OLD.\"Country_ID\", 0.0, 0.0, '0', 'Archived', 'Archived');\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER country_archive_trigger\nAFTER DELETE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION archive_deleted_country();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 1;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 2;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 3;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 4;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 5;"
    ],
    "summary": "Create a trigger function named archive_deleted_country that returns TRIGGER. After a row is deleted from the \"country\" table, insert a new row into the \"roller_coaster\" table. Set \"Roller_Coaster_ID\" to OLD.\"Country_ID\" + 2000, \"Name\" to 'Archived', \"Park\" to 'Archive Park', \"Country_ID\" to OLD.\"Country_ID\", \"Length\" to 0.0, \"Height\" to 0.0, \"Speed\" to '0', \"Opened\" to 'Archived', and \"Status\" to 'Archived'. Return the OLD record. Create an AFTER DELETE trigger named country_archive_trigger on the \"country\" table for each row to execute this function.",
    "natural_language": "Define a trigger function called archive_deleted_country that returns TRIGGER. After a row gets deleted from the \"country\" table, insert a new row into the \"roller_coaster\" table. Set the \"Roller_Coaster_ID\" to OLD.\"Country_ID\" plus 2000, \"Name\" to 'Archived', \"Park\" to 'Archive Park', \"Country_ID\" to OLD.\"Country_ID\", \"Length\" to 0.0, \"Height\" to 0.0, \"Speed\" to '0', \"Opened\" to 'Archived', and \"Status\" to 'Archived'. Return the OLD record. Then, create an AFTER DELETE trigger named country_archive_trigger on the \"country\" table for each row to run this function.",
    "id": 205
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_rounds_on_member_delete that returns a trigger, which is automatically executed by a trigger named trg_delete_rounds defined on the member table, such that before any single row is deleted from the member table, for the specific row identified by the OLD record, the function performs a DELETE operation on the round table targeting all rows where the value in the column named \"Member_ID\" in the round table is exactly equal to the value stored in the column named \"Member_ID\" of the OLD member row being deleted, and after this deletion, the function returns the OLD row record to the trigger execution mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_rounds_on_member_delete() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM round WHERE \"Member_ID\" = OLD.\"Member_ID\";\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_rounds\nBEFORE DELETE ON member\nFOR EACH ROW EXECUTE FUNCTION delete_rounds_on_member_delete();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "DELETE FROM member WHERE Member_ID = 1;",
      "DELETE FROM member WHERE Member_ID = 2;",
      "DELETE FROM member WHERE Member_ID = 3;",
      "DELETE FROM member WHERE Member_ID = 4;",
      "DELETE FROM member WHERE Member_ID = 5;"
    ],
    "summary": "Create a PostgreSQL trigger function named delete_rounds_on_member_delete that runs BEFORE DELETE on the member table. For the row being deleted, it deletes all rows from the round table where round.Member_ID equals OLD.Member_ID, then returns the OLD row.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'delete_rounds_on_member_delete'. This function is to be executed BEFORE a DELETE operation on the member table. Its operation must be to delete all associated records from the round table where the round.Member_ID corresponds to the OLD.Member_ID of the row slated for deletion. Subsequently, the function should return the OLD row.",
    "id": 206
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_catalog_price_in_euros that is executed automatically by a trigger named trg_update_catalog_price_in_euros before any INSERT operation or before any UPDATE operation that modifies the price_in_dollars column on the table named \"Catalog_Contents\" for each affected row, where the function first checks if the NEW record's catalog_entry_id column value is NULL and, if this condition is true, raises an exception with the message 'catalog_entry_id cannot be NULL', but if the condition is false, calculates a new value for the NEW record's price_in_euros column by multiplying the NEW record's price_in_dollars column value by the constant 0.85, and then returns the modified NEW record to the triggering statement.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_price_in_euros() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.catalog_entry_id IS NULL THEN\n    RAISE EXCEPTION 'catalog_entry_id cannot be NULL';\n  END IF;\n  NEW.price_in_euros = NEW.price_in_dollars * 0.85;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_price_in_euros\nBEFORE INSERT OR UPDATE OF price_in_dollars ON \"Catalog_Contents\"\nFOR EACH ROW EXECUTE FUNCTION update_catalog_price_in_euros();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (4, 1, 'Orange Soda', 150.00);",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (5, 2, 'Grape Soda', 250.00);",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 300.00 WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 400.00 WHERE catalog_entry_id = 2;",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (6, 3, 'Lemon Soda', 180.00);"
    ],
    "summary": "Create a PostgreSQL trigger function named update_catalog_price_in_euros that runs BEFORE INSERT OR UPDATE of price_in_dollars on the Catalog_Contents table. It raises an exception if NEW.catalog_entry_id is NULL. Otherwise, it sets NEW.price_in_euros to NEW.price_in_dollars * 0.85 and returns the NEW row.",
    "natural_language": "Make a trigger function for PostgreSQL called update_catalog_price_in_euros that should fire before adding or changing the price_in_dollars in the Catalog_Contents table. It should complain if the new catalog entry identifier is missing. If it's okay, then just have it figure out the price in euros by taking the dollar amount and multiplying it by a decent conversion rate, and then send back the updated record.",
    "id": 207
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_bool_attributes that is executed automatically after each new row is inserted into the Catalog_Contents table, and within this function, perform an INSERT operation into the Catalog_Contents_Additional_Attributes table, populating it by selecting from the Attribute_Definitions table where the attribute_data_type column has the exact string value 'Bool', and for each matching row from Attribute_Definitions, insert a new row into Catalog_Contents_Additional_Attributes with the catalog_entry_id column set to the newly inserted Catalog_Contents row's catalog_entry_id value (accessed via the NEW record), the catalog_level_number column set to the NEW record's catalog_level_number value, the attribute_id column set to the attribute_id value from the selected Attribute_Definitions row, and the attribute_value column always set to the string literal '1'.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_bool_attributes() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Catalog_Contents_Additional_Attributes\" (catalog_entry_id, catalog_level_number, attribute_id, attribute_value)\n  SELECT NEW.catalog_entry_id, NEW.catalog_level_number, ad.attribute_id, '1'\n  FROM \"Attribute_Definitions\" ad\n  WHERE ad.attribute_data_type = 'Bool';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_bool_attributes\nAFTER INSERT ON \"Catalog_Contents\"\nFOR EACH ROW EXECUTE FUNCTION insert_bool_attributes();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (101, 1, 'New Product 1', 'NP101', 10.00, 8.50, 7.50, '1', '1', '1', '1');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (102, 8, 'New Product 2', 'NP102', 20.00, 17.00, 15.00, '2', '2', '2', '2');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (103, 1, 'New Product 3', 'NP103', 30.00, 25.50, 22.50, '3', '3', '3', '3');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (104, 8, 'New Product 4', 'NP104', 40.00, 34.00, 30.00, '4', '4', '4', '4');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (105, 1, 'New Product 5', 'NP105', 50.00, 42.50, 37.50, '5', '5', '5', '5');"
    ],
    "summary": "Create a PostgreSQL trigger function named insert_bool_attributes that runs AFTER INSERT on the Catalog_Contents table. For each new row, it inserts records into Catalog_Contents_Additional_Attributes. It selects all rows from Attribute_Definitions where attribute_data_type = 'Bool', and for each, inserts a row with the new catalog_entry_id, catalog_level_number, the selected attribute_id, and sets attribute_value to '1'.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'insert_bool_attributes'. This function is to be executed subsequent to INSERT operations on the 'Catalog_Contents' table. For every newly inserted row, the function must insert corresponding records into the 'Catalog_Contents_Additional_Attributes' table. This is achieved by selecting all entries from the 'Attribute_Definitions' table where the 'attribute_data_type' column holds the value 'Bool'. For each such attribute definition retrieved, the function shall insert a row, populating it with the new 'catalog_entry_id', the 'catalog_level_number', the selected 'attribute_id', and assigning the 'attribute_value' as '1'.",
    "id": 208
  },
  {
    "ir": "Write a PLpgSQL function named update_catalog_price_in_pounds that is designed to be executed as a trigger for the Catalog_Contents table, specifically before any INSERT or UPDATE operation on each row. The function does not take any parameters directly, but operates on the NEW record, which represents the row being inserted or updated. The function first checks if the operation is an INSERT and if the catalog_entry_id column of the NEW record is NULL. If both conditions are true, it assigns a new catalog_entry_id to the NEW record by selecting the maximum existing catalog_entry_id from the Catalog_Contents table, adding 1 to it, and using COALESCE to handle cases where no entries exist, defaulting to 0. Next, the function checks if the price_in_dollars column of the NEW record is not NULL. If this condition is met, it calculates the price_in_pounds by multiplying the price_in_dollars by 0.72, effectively converting the price from dollars to pounds based on a fixed exchange rate. The function concludes by returning the modified NEW record, which now contains the updated catalog_entry_id and price_in_pounds if applicable. The function is associated with a trigger named trg_update_catalog_price_in_pounds, which is set to execute this function before any INSERT or UPDATE operation on the Catalog_Contents table, ensuring that the logic for handling catalog_entry_id and price conversion is applied consistently for each affected row.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_price_in_pounds() RETURNS TRIGGER AS $$\nBEGIN\n  -- Handle missing catalog_entry_id for INSERT operations\n  IF TG_OP = 'INSERT' AND NEW.catalog_entry_id IS NULL THEN\n    SELECT COALESCE(MAX(catalog_entry_id), 0) + 1 \n    INTO NEW.catalog_entry_id \n    FROM \"Catalog_Contents\";\n  END IF;\n  \n  -- Calculate price in pounds if price in dollars is provided\n  IF NEW.price_in_dollars IS NOT NULL THEN\n    NEW.price_in_pounds := NEW.price_in_dollars * 0.72;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_price_in_pounds\nBEFORE INSERT OR UPDATE ON \"Catalog_Contents\"\nFOR EACH ROW EXECUTE FUNCTION update_catalog_price_in_pounds();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, capacity, length, height, width) VALUES (1, NULL, NULL, NULL, 'New Product 1', 'NP1', 100.00, 80.00, '10', '5', '5', '5');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (100, 1, 'Test Product', 50.00);",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 150.00 WHERE catalog_entry_id = 1;",
      "INSERT INTO \"Catalog_Contents\" (catalog_level_number, catalog_entry_name, product_stock_number, price_in_dollars) VALUES (8, 'Another Product', 'AP2', 250.50);",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 75.25 WHERE catalog_entry_id = 2;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_catalog_price_in_pounds that runs BEFORE INSERT OR UPDATE on the Catalog_Contents table. For INSERT operations where NEW.catalog_entry_id is NULL, it sets NEW.catalog_entry_id to COALESCE(MAX(catalog_entry_id), 0) + 1 from the table. If NEW.price_in_dollars is not NULL, it sets NEW.price_in_pounds to NEW.price_in_dollars * 0.72. It then returns the NEW row.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'update_catalog_price_in_pounds'. This function is to be executed BEFORE either an INSERT or UPDATE operation on the Catalog_Contents table. For INSERT operations specifically, in instances where the NEW.catalog_entry_id value is NULL, the function shall assign it a value equivalent to the COALESCE(MAX(catalog_entry_id), 0) + 1 derived from the table. Furthermore, if the NEW.price_in_dollars field is not NULL, the function must calculate and assign the NEW.price_in_pounds value as the product of NEW.price_in_dollars and 0.72. The function should subsequently return the NEW row.",
    "id": 209
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_catalog_entry_name that returns a trigger and is executed by a trigger named trg_update_catalog_entry_name, which is defined to fire BEFORE UPDATE on the table named \"Catalog_Contents\" for each row being updated; the function has no explicit input parameters but implicitly accesses the special OLD and NEW row variables representing the row's state before and after the update; within the function's logic, for every row update operation, it modifies the NEW.catalog_entry_name column value by performing a string concatenation operation using the concatenation operator (||), prepending the literal string 'Updated ' (including a trailing space) to the existing value of the NEW.catalog_entry_name column from the incoming update, and then assigns this newly formed string back to the NEW.catalog_entry_name column; the function concludes by returning the modified NEW row record, thereby allowing the triggered update operation to proceed with the altered column data.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_entry_name() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.catalog_entry_name := 'Updated ' || NEW.catalog_entry_name;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_entry_name\nBEFORE UPDATE ON \"Catalog_Contents\"\nFOR EACH ROW EXECUTE FUNCTION update_catalog_entry_name();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'New Cola' WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'New Root beer' WHERE catalog_entry_id = 2;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'New Cream Soda' WHERE catalog_entry_id = 3;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'Another Cola' WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'Another Root beer' WHERE catalog_entry_id = 2;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_catalog_entry_name that runs BEFORE UPDATE on the Catalog_Contents table. For each updated row, it prepends the string 'Updated ' to the NEW.catalog_entry_name column value and returns the modified NEW row.",
    "natural_language": "Make a trigger function for PostgreSQL called update_catalog_entry_name that activates BEFORE an UPDATE happens on the Catalog_Contents table. For any row that gets changed, it should kind of add the text 'Updated ' to the front of whatever is in the NEW.catalog_entry_name field, and then give back the adjusted NEW row.",
    "id": 210
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after an insert operation on the official_languages table, specifically when a new row is added. This function, named update_overall_score_on_language_insert, does not take any parameters directly but operates in the context of a trigger. It updates the overall_score column in the countries table for the row where the id matches the country_id of the newly inserted row in the official_languages table. The overall_score is calculated as the average of five other columns: justice_score, health_score, education_score, economics_score, and politics_score, by summing these scores and dividing by 5. The function returns the NEW record, which is the row that was just inserted into the official_languages table. The trigger, named trg_update_overall_score, is defined to execute this function after each row is inserted into the official_languages table. Additionally, an example insert statement is provided, which attempts to insert a row into the official_languages table with specified language_id and country_id values. If a row with the same language_id and country_id already exists, the ON CONFLICT clause ensures that no action is taken, effectively preventing duplicate entries.",
    "plsql": "CREATE OR REPLACE FUNCTION update_overall_score_on_language_insert() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE countries SET overall_score = (justice_score + health_score + education_score + economics_score + politics_score) / 5 WHERE id = NEW.country_id;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_overall_score\nAFTER INSERT ON official_languages\nFOR EACH ROW EXECUTE FUNCTION update_overall_score_on_language_insert();\n\n-- Example of handling the insert with ON CONFLICT\nINSERT INTO official_languages (language_id, country_id)\nVALUES (1, 1)\nON CONFLICT (language_id, country_id) DO NOTHING;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "INSERT INTO official_languages (language_id, country_id) VALUES (1, 1) ON CONFLICT (language_id, country_id) DO NOTHING;",
      "INSERT INTO official_languages (language_id, country_id) VALUES (2, 2) ON CONFLICT (language_id, country_id) DO NOTHING;",
      "INSERT INTO official_languages (language_id, country_id) VALUES (3, 3) ON CONFLICT (language_id, country_id) DO NOTHING;",
      "INSERT INTO official_languages (language_id, country_id) VALUES (1, 2) ON CONFLICT (language_id, country_id) DO NOTHING;",
      "INSERT INTO official_languages (language_id, country_id) VALUES (2, 1) ON CONFLICT (language_id, country_id) DO NOTHING;"
    ],
    "summary": "Create an AFTER INSERT trigger function on the official_languages table. For each new row, update the countries table. Set the overall_score to the average of justice_score, health_score, education_score, economics_score, and politics_score for the country matching the new country_id. Return the NEW record.",
    "natural_language": "Construct an AFTER INSERT trigger function that will be applied to the official_languages table. For every single new row that is inserted, you must subsequently perform an update on the countries table. Specifically, set the overall_score column to the calculated average value derived from the justice_score, health_score, education_score, economics_score, and politics_score columns, but only for the specific country whose country_id precisely matches the new country_id from the recently inserted record. Finally, ensure the trigger function returns the complete NEW record.",
    "id": 211
  },
  {
    "ir": "Write a PLpgSQL function that is triggered before a row is deleted from the countries table, which deletes all rows from the official_languages table where the country_id matches the id of the row being deleted from the countries table. The function delete_language_on_country_delete does not take any parameters directly but operates using the OLD record, which represents the row that is about to be deleted from the countries table. The OLD record contains the id column, which is used to identify the corresponding rows in the official_languages table that need to be deleted. The function returns the OLD record after performing the deletion operation. The trigger named trg_delete_language is defined to execute this function before a delete operation occurs on each row of the countries table, ensuring that any official languages associated with the country being deleted are also removed from the official_languages table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_language_on_country_delete() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM official_languages WHERE country_id = OLD.id;\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_language\nBEFORE DELETE ON countries\nFOR EACH ROW EXECUTE FUNCTION delete_language_on_country_delete();",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "DELETE FROM countries WHERE id = 1;",
      "DELETE FROM countries WHERE name = 'Sweden';",
      "DELETE FROM countries WHERE overall_score < 97.0;",
      "DELETE FROM countries WHERE id IN (2, 3);",
      "DELETE FROM countries WHERE justice_score IS NULL;"
    ],
    "summary": "Create a BEFORE DELETE trigger function on the countries table. For each row to be deleted, first delete all rows from the official_languages table where the country_id matches the OLD.id. Return the OLD record.",
    "natural_language": "Construct a BEFORE DELETE trigger function designed for the countries table. For every individual row that is slated for deletion, it is essential to first meticulously remove all corresponding entries from the official_languages table where the country_id precisely matches the OLD.id value. Subsequently, the function must return the complete OLD record.",
    "id": 212
  },
  {
    "ir": "Write a PL/pgSQL function named `cotangent_on_language_insert` that is designed to be executed as a `BEFORE INSERT` trigger on the `official_languages` table. This function takes no explicit parameters but operates on the `NEW` record, which represents the row being inserted into `official_languages`. The function first performs a `SELECT` operation on the `official_languages` table to check for the existence of a record where the `language_id` column matches `NEW.language_id` and the `country_id` column matches `NEW.country_id`. If such a record `EXISTS`, indicating a duplicate `(language_id, country_id)` pair, the function immediately `RETURN`s `NULL`, which prevents the original `INSERT` operation on `official_languages` from proceeding. If no such duplicate record is found, the function proceeds to perform an `UPDATE` operation on the `countries` table. In this `UPDATE` operation, the `overall_score` column is set to the cotangent of the value in the `justice_score` column. This `UPDATE` is applied only to the row in the `countries` table where the `id` column matches `NEW.country_id`. After this `UPDATE` operation, the function `RETURN`s `NEW`, allowing the original `INSERT` operation on `official_languages` to proceed with the new row. The function includes an `EXCEPTION` block to handle potential mathematical errors during the cotangent calculation. Specifically, if an `invalid_text_representation` error, a `numeric_value_out_of_range` error, or a `division_by_zero` error occurs, the function `RAISE`s a `NOTICE` message indicating a \"Mathematical error in cotangent calculation for country_id\" followed by the value of `NEW.country_id`, and then `RETURN`s `NEW`, allowing the original `INSERT` to proceed despite the error in the `UPDATE` statement. This function is then associated with a `BEFORE INSERT` trigger named `trg_cotangent_update` on the `official_languages` table, configured to execute `FOR EACH ROW` before any `INSERT` operation on that table.",
    "plsql": "CREATE OR REPLACE FUNCTION cotangent_on_language_insert() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if the (language_id, country_id) pair already exists\n    IF EXISTS (SELECT 1 FROM official_languages WHERE language_id = NEW.language_id AND country_id = NEW.country_id) THEN\n        -- If it exists, skip the INSERT by returning NULL\n        RETURN NULL;\n    END IF;\n    \n    -- Perform the UPDATE on countries\n    UPDATE countries \n    SET overall_score = cot(justice_score) \n    WHERE id = NEW.country_id;\n    \n    RETURN NEW;\nEXCEPTION\n    WHEN invalid_text_representation OR numeric_value_out_of_range OR division_by_zero THEN\n        RAISE NOTICE 'Mathematical error in cotangent calculation for country_id %', NEW.country_id;\n        RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cotangent_update\nBEFORE INSERT ON official_languages\nFOR EACH ROW EXECUTE FUNCTION cotangent_on_language_insert();",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "INSERT INTO official_languages (language_id, country_id) VALUES (1, 1);",
      "INSERT INTO official_languages (language_id, country_id) VALUES (2, 2);",
      "INSERT INTO official_languages (language_id, country_id) VALUES (3, 3);",
      "INSERT INTO official_languages (language_id, country_id) VALUES (1, 2);",
      "INSERT INTO official_languages (language_id, country_id) VALUES (2, 1);"
    ],
    "summary": "Create a BEFORE INSERT trigger function on the official_languages table. Check for duplicate (language_id, country_id) pairs. If a duplicate exists, return NULL to cancel the insert. If not, update the countries table by setting overall_score to the cotangent of justice_score for the country matching NEW.country_id. Handle mathematical errors by logging a notice and proceeding with the insert. Return NEW.",
    "natural_language": "Formulate a BEFORE INSERT trigger function for the official_languages table. The function must verify the absence of duplicate entries for the composite key comprising language_id and country_id. Should a duplicate pair be detected, the function must return NULL to prevent the insertion operation. In the absence of a duplicate, the function shall proceed to update the countries table by setting the overall_score column to the cotangent of the justice_score for the record whose country_id matches NEW.country_id. Any mathematical errors encountered during this computation are to be managed by issuing a notice to the log, after which the insertion should proceed normally. The function must conclude by returning the NEW record.",
    "id": 213
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after an update operation on the countries table. This function, named update_language_name_on_country_update, does not take any parameters directly but operates in the context of a trigger. It updates the name column in the languages table to the string 'Updated Language' for the row where the id matches the language_id obtained from the official_languages table. The official_languages table is queried to find the language_id corresponding to the country_id of the row that was updated in the countries table, using the NEW.id reference provided by the trigger context. The trigger, named trg_update_language_name, is defined to execute this function after any update operation on the countries table, ensuring that for each row updated in the countries table, the associated language name in the languages table is updated accordingly.",
    "plsql": "CREATE OR REPLACE FUNCTION update_language_name_on_country_update() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE languages SET name = 'Updated Language' WHERE id = (SELECT language_id FROM official_languages WHERE country_id = NEW.id);\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_language_name\nAFTER UPDATE ON countries\nFOR EACH ROW EXECUTE FUNCTION update_language_name_on_country_update();",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "UPDATE countries SET name = 'New Iceland' WHERE id = 1;",
      "UPDATE countries SET overall_score = 99.9 WHERE id = 2;",
      "UPDATE countries SET justice_score = 95.0 WHERE id = 3;",
      "UPDATE countries SET health_score = 90.0 WHERE id = 1;",
      "UPDATE countries SET education_score = 98.0 WHERE id = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the countries table. For each updated row, find the associated language_id from the official_languages table using NEW.id. Then, update the languages table, setting the name to 'Updated Language' for the language matching that language_id.",
    "natural_language": "For each updated row in the countries table, find its associated language_id from the official_languages table using the new id. Then, update the name to 'Updated Language' in the languages table for that language_id. Implement this logic as an AFTER UPDATE trigger function.",
    "id": 214
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `cotangent_on_country_update` that is designed to be executed before an `UPDATE` operation on the `countries` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` and `OLD` representing the new and old row values, respectively. The function's return type is `TRIGGER`, indicating its purpose as a trigger function. Upon execution, the function performs a single operation: it calculates the cotangent of the value in the `health_score` column of the `NEW` row (which represents the row's state after the proposed update but before it's committed to the table). The result of this `cot` mathematical function is then assigned to the `overall_score` column of the `NEW` row. Finally, the function returns the `NEW` row, allowing the `UPDATE` operation to proceed with the modified `overall_score`. This trigger function is associated with a trigger named `trg_cotangent_on_update`. This trigger is configured to fire `BEFORE` any `UPDATE` statement is executed on the `countries` table. It is an `FOR EACH ROW` trigger, meaning the `cotangent_on_country_update` function will be executed once for every row that is being updated by the `UPDATE` statement. The trigger explicitly `EXECUTE FUNCTION cotangent_on_country_update()`, invoking the previously defined trigger function to perform the described logic.",
    "plsql": "CREATE OR REPLACE FUNCTION cotangent_on_country_update() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.overall_score = cot(NEW.health_score);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cotangent_on_update\nBEFORE UPDATE ON countries\nFOR EACH ROW EXECUTE FUNCTION cotangent_on_country_update();",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "UPDATE countries SET health_score = 1.0 WHERE id = 1;",
      "UPDATE countries SET health_score = 0.5 WHERE name = 'Sweden';",
      "UPDATE countries SET health_score = health_score + 0.1 WHERE id = 3;",
      "UPDATE countries SET health_score = 0.785, education_score = 95.0 WHERE id = 2;",
      "UPDATE countries SET health_score = NULL WHERE id = 1;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function on the countries table. For each row being updated, set the NEW.overall_score to the cotangent of the NEW.health_score. Return the modified NEW row.",
    "natural_language": "Please construct a BEFORE UPDATE trigger function for the countries table. For each row undergoing an update, the NEW.overall_score value should be assigned the cotangent of the NEW.health_score. Subsequently, the modified NEW row is to be returned.",
    "id": 215
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after a row is deleted from the shop table. This function, named trg_adjust_stock_on_delete, does not take any parameters directly but operates on the OLD record, which represents the deleted row from the shop table. The function performs a DELETE operation on the stock table, targeting rows where the Shop_ID column matches the Shop_ID value from the OLD record, and the Quantity column satisfies the condition of being divisible by 3, as determined by the mod function. The mod function is used to check if the remainder of the division of Quantity by 3 is zero, indicating divisibility. After executing the DELETE operation, the function returns the OLD record, which is the standard behavior for a trigger function returning the state of the deleted row. The trigger named adjust_stock_on_delete is associated with the shop table and is set to fire after a DELETE operation on each row, ensuring that the trg_adjust_stock_on_delete function is executed for every row deletion in the shop table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_adjust_stock_on_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM stock WHERE \"Shop_ID\" = OLD.\"Shop_ID\" AND mod(\"Quantity\", 3) = 0;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_stock_on_delete\nAFTER DELETE ON shop\nFOR EACH ROW EXECUTE FUNCTION trg_adjust_stock_on_delete();",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "DELETE FROM shop WHERE Shop_ID = 1;",
      "DELETE FROM shop WHERE Shop_ID = 2;",
      "DELETE FROM shop WHERE Shop_ID = 3;"
    ],
    "summary": "Create an AFTER DELETE row-level trigger function named trg_adjust_stock_on_delete for the shop table. After a shop row is deleted, delete rows from the stock table where Shop_ID matches the OLD.Shop_ID and Quantity is divisible by 3 (mod(Quantity, 3) = 0). The function should return the OLD record.",
    "natural_language": "Set up a trigger function that runs after a shop entry is removed. It should handle tidying up the stock table by getting rid of some related records—specifically those for the same shop and where the item count is neatly divisible by three. The function should give back the details of the shop that was just deleted.",
    "id": 216
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_validate_mountain_prominence` that operates on the `mountain` table. This function is designed to be executed `BEFORE` an `INSERT` or `UPDATE` operation on each row of the `mountain` table. The function receives the `NEW` record, which represents the row data after the proposed `INSERT` or `UPDATE` but before it is committed to the table. Inside the function, a conditional statement checks if the value in the `Prominence` column of the `NEW` record is strictly greater than the value in the `Height` column of the same `NEW` record. Both `Prominence` and `Height` are assumed to be numeric columns. If this condition evaluates to true, the function then modifies the `NEW` record by setting the value of its `Prominence` column to the current value of its `Height` column. After this potential modification, the function returns the `NEW` record. The associated trigger, named `validate_mountain_prominence`, is configured to fire `BEFORE` any `INSERT` or `UPDATE` event on the `mountain` table, `FOR EACH ROW`, and it executes the `trg_validate_mountain_prominence` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_mountain_prominence() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Prominence\" > NEW.\"Height\" THEN\n        NEW.\"Prominence\" := NEW.\"Height\";\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_mountain_prominence\nBEFORE INSERT OR UPDATE ON \"mountain\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_mountain_prominence();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO mountain (name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES ('Test Peak', 5000.0, 6000.0, 'Test Range', 'Test Country');",
      "UPDATE mountain SET \"Prominence\" = 5500.0 WHERE name = 'Test Peak';",
      "INSERT INTO mountain (name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES ('Valid Peak', 3000.0, 1500.0, 'Valid Range', 'Valid Country');",
      "UPDATE mountain SET \"Height\" = 2500.0, \"Prominence\" = 3000.0 WHERE name = 'Valid Peak';",
      "INSERT INTO mountain (name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES ('Zero Prominence', 1000.0, 0.0, 'Zero Range', 'Zero Country');"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger function named trg_validate_mountain_prominence for the mountain table. If the NEW.Prominence value is greater than NEW.Height, set NEW.Prominence equal to NEW.Height. Return the NEW record.",
    "natural_language": "Define a BEFORE INSERT OR UPDATE row-level trigger function called trg_validate_mountain_prominence for the mountain table. Ensure that if the NEW.Prominence value exceeds NEW.Height, you set NEW.Prominence to equal NEW.Height. Then return the NEW record.",
    "id": 217
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_auto_color_photo that returns a trigger, which is then bound to the photos table via a BEFORE INSERT trigger named auto_color_photo, where for each new row being inserted, the function checks if the value of the column named color is NULL, and if this condition is true, the function assigns the string literal 'RBG' to the NEW.color column before the row is inserted, ensuring that no color column in the photos table will ever contain a NULL value after an insert operation, as it will default to 'RBG' when not explicitly provided.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_auto_color_photo() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"color\" IS NULL THEN\n        NEW.\"color\" := 'RBG';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER auto_color_photo\nBEFORE INSERT ON \"photos\"\nFOR EACH ROW EXECUTE FUNCTION trg_auto_color_photo();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO \"photos\" (camera_lens_id, mountain_id, name) VALUES (1, 1, 'sunset_view');",
      "INSERT INTO \"photos\" (camera_lens_id, mountain_id, name) VALUES (2, 3, 'wildlife_shot');",
      "INSERT INTO \"photos\" (camera_lens_id, mountain_id, name) VALUES (3, 2, 'landscape_photo');",
      "INSERT INTO \"photos\" (camera_lens_id, mountain_id, name, color) VALUES (1, 1, 'flower_close_up', 'Black/White');",
      "INSERT INTO \"photos\" (camera_lens_id, mountain_id, name) VALUES (10, 20, 'cloudy_peak');"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger function named trg_auto_color_photo for the photos table. If the NEW.color value is NULL, set it to 'RBG'. Return the NEW record.",
    "natural_language": "Make a trigger that runs before putting a new row into the photos table, call it something like trg_auto_color_photo. Basically, if the color info for the new entry is missing or not provided, just fill it in with something standard, maybe 'RBG'. Then make sure the updated new record is sent back.",
    "id": 218
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `trg_validate_photo_references` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` (representing the new row for `INSERT` or `UPDATE` operations). The function's primary purpose is to validate referential integrity for a `mountain_id` column. Upon execution, it first performs a `SELECT` operation to check for the existence of a record in the `\"mountain\"` table. Specifically, it attempts to select the constant value `1` from the `\"mountain\"` table where the `\"id\"` column of the `\"mountain\"` table matches the value of the `mountain_id` column from the `NEW` row (the row being inserted or updated in the `photos` table). This `SELECT` statement is encapsulated within an `IF NOT EXISTS` conditional block. If the `SELECT` query returns no rows, indicating that no mountain with the specified `mountain_id` exists in the `\"mountain\"` table, then the function executes a `RAISE EXCEPTION` statement, which immediately terminates the current operation and signals an error with the message 'Referenced mountain does not exist'. If, however, the `SELECT` query finds at least one matching record in the `\"mountain\"` table, meaning the referenced mountain exists, the `IF NOT EXISTS` condition evaluates to false, and the exception is not raised. In this case, the function proceeds to the `RETURN NEW` statement, which allows the `INSERT` or `UPDATE` operation on the `photos` table to continue with the `NEW` row.\n\nThis function is then associated with a trigger named `validate_photo_references`. This trigger is configured to execute `BEFORE INSERT OR UPDATE` operations on the `\"photos\"` table. The `FOR EACH ROW` clause specifies that the trigger function `trg_validate_photo_references()` will be executed once for each row that is being inserted or updated in the `\"photos\"` table. The `EXECUTE FUNCTION trg_validate_photo_references()` clause specifies that the `trg_validate_photo_references` function is the one to be invoked by this trigger. Therefore, before any new row is inserted into the `\"photos\"` table or any existing row in the `\"photos\"` table is updated, this trigger will ensure that the `mountain_id` specified in that row correctly references an existing `id` in the `\"mountain\"` table, preventing the creation of orphaned references.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_photo_references() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"mountain\" WHERE \"id\" = NEW.\"mountain_id\") THEN\n        RAISE EXCEPTION 'Referenced mountain does not exist';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_photo_references\nBEFORE INSERT OR UPDATE ON \"photos\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_photo_references();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO \"photos\" (id, camera_lens_id, mountain_id, color, name) VALUES (4, 1, 1, 'RBG', 'sunrise');",
      "INSERT INTO \"photos\" (id, camera_lens_id, mountain_id, color, name) VALUES (5, 2, 2, 'Black/White', 'clouds');",
      "UPDATE \"photos\" SET mountain_id = 3 WHERE id = 1;",
      "INSERT INTO \"photos\" (id, camera_lens_id, mountain_id, color, name) VALUES (6, 1, 1, 'RBG', 'forest');",
      "UPDATE \"photos\" SET mountain_id = 2 WHERE id = 2;"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger function named trg_validate_photo_references for the photos table. Validate that the NEW.mountain_id exists in the mountain.id column. If it does not exist, raise an exception 'Referenced mountain does not exist'. Return the NEW record.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE row-level trigger function designated as trg_validate_photo_references for the photos table. The function must validate the existence of the NEW.mountain_id value within the id column of the mountain table. Should the referenced mountain_id not be present, the function is to raise an exception with the message 'Referenced mountain does not exist'. Subsequently, the function must return the NEW record.",
    "id": 219
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before any insert or update operation on the camera_lens table, specifically for each row being processed. The function, named trg_check_aperture_range, does not take any parameters directly but operates on the NEW record, which represents the row being inserted or updated. Within the function, it checks the value of the max_aperture column in the NEW record. If the max_aperture value is less than 1.0 or greater than 32.0, the function raises a warning message indicating that the aperture must be between 1.0 and 32.0, and includes the current value of max_aperture in the warning message. The function then returns the NEW record, allowing the insert or update operation to proceed. The trigger named check_aperture_range is associated with this function and is defined to execute the trg_check_aperture_range function before any insert or update operation on the camera_lens table, ensuring that the aperture value is checked for every row being inserted or updated.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_check_aperture_range() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"max_aperture\" < 1.0 OR NEW.\"max_aperture\" > 32.0 THEN\n        RAISE WARNING 'Aperture must be between 1.0 and 32.0. Current value: %', NEW.\"max_aperture\";\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER check_aperture_range\nBEFORE INSERT OR UPDATE ON \"camera_lens\"\nFOR EACH ROW EXECUTE FUNCTION trg_check_aperture_range();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (4, 'Canon', 'Canon EF 50mm f/1.8 STM', 50.0, 1.5);",
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (5, 'Nikon', 'Nikon AF-S DX NIKKOR 35mm f/1.8G', 35.0, 1.8);",
      "UPDATE camera_lens SET max_aperture = 2.0 WHERE id = 1;",
      "UPDATE camera_lens SET max_aperture = 5.6 WHERE id = 2;",
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (6, 'Sony', 'Sony FE 85mm f/1.4 GM', 85.0, 1.4);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger function named trg_check_aperture_range for the camera_lens table. If the NEW.max_aperture value is less than 1.0 or greater than 32.0, raise a warning stating the aperture must be between 1.0 and 32.0 and include the current value. Return the NEW record.",
    "natural_language": "Create a row-level trigger function called trg_check_aperture_range for the camera_lens table that fires BEFORE INSERT OR UPDATE. If the NEW.max_aperture value is outside the range of 1.0 to 32.0, raise a warning that includes the current value and states the aperture must be between 1.0 and 32.0. Ensure the function returns the NEW record.",
    "id": 220
  },
  {
    "ir": "Write a PLpgSQL function named update_order_total that is designed to be executed as a trigger. This function does not take any parameters directly but operates on the NEW record provided by the trigger context. The function updates the order_details column in the Orders table for the row where the order_id matches the order_id of the NEW record from the Order_Items table. The update operation involves setting the order_details column to a concatenated string of product names and their respective quantities, formatted as 'product_name (product_quantity)', separated by commas. This concatenation is achieved using the string_agg function, which aggregates the product_name from the Products table and the product_quantity from the Order_Items table. The function performs a SELECT operation to retrieve the product_name from the Products table by joining it with the Order_Items table on the product_id column, ensuring that only items related to the specific order_id of the NEW record are considered. The trigger named trg_order_items_update is created to execute this function after any INSERT or UPDATE operation on the Order_Items table, ensuring that the order_details in the Orders table is updated whenever the Order_Items table is modified. The trigger is defined to execute for each row affected by the INSERT or UPDATE operation, thereby maintaining the order details in real-time as changes occur in the Order_Items table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_total() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Orders\" \n    SET order_details = (\n        SELECT string_agg(\"Products\".product_name || ' (' || \"Order_Items\".product_quantity || ')', ', ') \n        FROM \"Order_Items\" \n        JOIN \"Products\" ON \"Order_Items\".product_id = \"Products\".product_id \n        WHERE \"Order_Items\".order_id = NEW.order_id\n    ) \n    WHERE \"Orders\".order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_order_items_update\nAFTER INSERT OR UPDATE ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION update_order_total();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Product_Categories"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (100, 1, 4, '2');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (101, 1, 10, '1');",
      "UPDATE \"Order_Items\" SET product_quantity = '3' WHERE order_item_id = 100;",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (102, 2, 5, '5');",
      "UPDATE \"Order_Items\" SET product_id = 10 WHERE order_item_id = 102;"
    ],
    "summary": "Create a trigger function named update_order_total that, after each row is inserted or updated in the Order_Items table, updates the order_details column in the Orders table. For the matching order_id, set order_details to a comma-separated string of 'product_name (product_quantity)' by aggregating data from the joined Order_Items and Products tables.",
    "natural_language": "How can I create a trigger function called update_order_total that, after any row is inserted or updated in the Order_Items table, updates the order_details column in the Orders table? For the matching order_id, it should set order_details to a comma-separated string of 'product_name (product_quantity)' by aggregating data from the joined Order_Items and Products tables.",
    "id": 221
  },
  {
    "ir": "Write a PLpgSQL function that serves as a trigger function named validate_customer_order_limit, which is designed to enforce a business rule on the \"Orders\" table. This function does not take any parameters directly but operates in the context of a trigger. It is intended to be executed before a new row is inserted into the \"Orders\" table. The function begins by executing a SELECT COUNT(*) query on the \"Orders\" table to determine the number of orders placed by the same customer, identified by the customer_id column, within the last 24 hours. This is achieved by comparing the date_order_placed column of the \"Orders\" table to the current timestamp minus an interval of one day. If the count of such orders is greater than or equal to 5, the function raises an exception with the message 'Customer order limit exceeded', effectively preventing the insertion of the new order. If the condition is not met, the function allows the insertion to proceed by returning the NEW record, which represents the row being inserted. The function is written in the PLpgSQL language. Additionally, a trigger named trg_orders_before_insert_limit is created, which is set to fire before an insert operation on the \"Orders\" table. This trigger is defined to execute the validate_customer_order_limit function for each row that is being inserted, ensuring that the order limit validation is applied to every new order attempt.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_customer_order_limit() RETURNS TRIGGER AS $$\nBEGIN\nIF (SELECT COUNT(*) FROM \"Orders\" WHERE customer_id = NEW.customer_id AND date_order_placed > CURRENT_TIMESTAMP - INTERVAL '1 day') >= 5 THEN\nRAISE EXCEPTION 'Customer order limit exceeded';\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_orders_before_insert_limit\nBEFORE INSERT ON \"Orders\"\nFOR EACH ROW EXECUTE FUNCTION validate_customer_order_limit();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Product_Categories"
    ],
    "call_sqls": [
      "INSERT INTO \"Orders\" (customer_id, date_order_placed, order_details) VALUES (1, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"Orders\" (customer_id, date_order_placed, order_details) VALUES (2, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"Orders\" (customer_id, date_order_placed, order_details) VALUES (3, CURRENT_TIMESTAMP, NULL);"
    ],
    "summary": "Create a trigger function named validate_customer_order_limit that, before inserting a row into the Orders table, checks if the customer has placed 5 or more orders in the last 24 hours. If so, raise an exception 'Customer order limit exceeded'. Otherwise, allow the insert.",
    "natural_language": "Define a trigger function designated as 'validate_customer_order_limit' to execute prior to the insertion of a record into the Orders table. This function shall verify whether the associated customer has initiated five or more orders within the preceding 24-hour period. Should this condition be met, the function must raise an exception with the message 'Customer order limit exceeded'. If the condition is not satisfied, the insertion operation is to be permitted to proceed.",
    "id": 222
  },
  {
    "ir": "Write a PLpgSQL trigger function named `update_product_price_with_vat` that is designed to be executed as a trigger, and a trigger named `trg_products_after_update_vat` that invokes this function. The `update_product_price_with_vat` function takes no explicit parameters but implicitly receives special variables from the triggering event, specifically `NEW` which represents the new row data after an `UPDATE` operation. The purpose of this function is to update the `unit_price` of a product in the `\"Products\"` table. This update is performed by multiplying the existing `unit_price` of the product by a factor of `(1 + VAT_RATING/100)`. The `VAT_RATING` is retrieved from the `\"Product_Categories\"` table. Specifically, a subquery selects the `vat_rating` column from the `\"Product_Categories\"` table where the `production_type_code` column matches the `production_type_code` from the `NEW` row (i.e., `NEW.production_type_code`). The `LIMIT 1` clause ensures that only one `vat_rating` is retrieved even if multiple rows match the condition. The `UPDATE` operation on the `\"Products\"` table is conditional, applying only to the row where the `product_id` column matches the `product_id` from the `NEW` row (i.e., `NEW.product_id`). After performing this update, the function returns `NEW`, indicating that the modified row should be used for the subsequent operations in the triggering statement. The `trg_products_after_update_vat` trigger is defined to execute `AFTER UPDATE OF production_type_code` on the `\"Products\"` table. This means the trigger will fire after an `UPDATE` statement has successfully modified the `production_type_code` column of any row in the `\"Products\"` table. It is a `FOR EACH ROW` trigger, meaning the `update_product_price_with_vat` function will be executed once for each row that is updated and whose `production_type_code` column has changed. The trigger explicitly executes the `update_product_price_with_vat()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_product_price_with_vat() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Products\" SET unit_price = \"Products\".unit_price * (1 + (SELECT vat_rating/100 FROM \"Product_Categories\" WHERE production_type_code = NEW.production_type_code LIMIT 1)) WHERE \"Products\".product_id = NEW.product_id;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_products_after_update_vat\nAFTER UPDATE OF production_type_code ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION update_product_price_with_vat();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Product_Categories"
    ],
    "call_sqls": [
      "UPDATE \"Products\" SET production_type_code = 'DVDs' WHERE product_id = 1;",
      "UPDATE \"Products\" SET production_type_code = 'Books' WHERE product_id = 2;",
      "UPDATE \"Products\" SET production_type_code = 'Food' WHERE product_id = 3;",
      "UPDATE \"Products\" SET production_type_code = 'Electronics' WHERE product_id = 4;",
      "UPDATE \"Products\" SET production_type_code = 'Food' WHERE product_id = 5;"
    ],
    "summary": "Create a trigger function named update_product_price_with_vat that, after the production_type_code of a row in the Products table is updated, recalculates that product's unit_price by multiplying it by (1 + VAT_RATING/100), where the VAT_RATING is fetched from the Product_Categories table.",
    "natural_language": "Hey, can you whip up a trigger function called update_product_price_with_vat? So, whenever someone changes the production_type_code for a product, it should automatically adjust that product's unit_price. It needs to grab the VAT_RATING from the Product_Categories table and bump up the price by that percentage, like doing unit_price * (1 + VAT_RATING/100).",
    "id": 223
  },
  {
    "ir": "Write a PostgreSQL trigger function named sync_institution_location_trigger that returns a trigger and is executed by a trigger named update_staff_ages, which fires after an update operation on the Location column of the institution table for each modified row; the function's logic performs an update on the staff table, setting the Age column to the integer value 25 for every row in the staff table where the Institution_ID column value matches the NEW.Institution_ID value from the triggering update on the institution table, and the function concludes by returning the NEW row record to the invoking trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_institution_location_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    -- Assuming the intention is to reset or update the age based on some criteria, here we set it to a default value\n    UPDATE staff SET \"Age\" = 25 WHERE \"Institution_ID\" = NEW.\"Institution_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_staff_ages\n    AFTER UPDATE OF \"Location\" ON institution\n    FOR EACH ROW\n    EXECUTE FUNCTION sync_institution_location_trigger();",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "UPDATE institution SET \"Location\" = 'Chicago, Illinois' WHERE \"Institution_ID\" = 1;",
      "UPDATE institution SET \"Location\" = 'Updated Location' WHERE \"Institution_ID\" = 2;",
      "UPDATE institution SET \"Location\" = 'Springfield, Illinois' WHERE \"Institution_Name\" = 'Eureka College';",
      "UPDATE institution SET \"Location\" = 'New York, NY', \"Founded\" = 1900 WHERE \"Institution_ID\" = 3;",
      "UPDATE institution SET \"Location\" = 'Remote' WHERE \"Location\" LIKE '%Illinois%';"
    ],
    "summary": "Create a trigger function named sync_institution_location_trigger that, after the Location column is updated in the institution table, updates the Age column to 25 in the staff table for all rows where the Institution_ID matches the new Institution_ID from the updated institution row.",
    "natural_language": "Create a trigger function, which should be named sync_institution_location_trigger, that executes automatically after any modification is made to the Location column within the institution table; this comprehensive function must then meticulously update the Age column, setting it precisely to 25, across all relevant entries in the staff table, specifically targeting those rows where the Institution_ID corresponds exactly to the new Institution_ID value originating from the recently updated row in the institution table.",
    "id": 224
  },
  {
    "ir": "Write a PostgreSQL trigger function named validate_rating_stars that returns a trigger, which is executed by a trigger named validate_rating_stars_trigger defined on the table named Rating, where the trigger is configured to fire BEFORE any INSERT or UPDATE operation on that table for each individual row being processed, and within the function's logic, it accesses the new row data using the NEW record variable to check the value of the column named stars, and if that value is less than 1 OR greater than 5, it raises an exception with the message 'Rating stars must be between 1 and 5', thereby preventing the insert or update operation from completing, but if the stars value is between 1 and 5 inclusive, the function proceeds to return the NEW row record, allowing the triggering INSERT or UPDATE operation to proceed normally.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_rating_stars() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"stars\" < 1 OR NEW.\"stars\" > 5 THEN\n    RAISE EXCEPTION 'Rating stars must be between 1 and 5';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_rating_stars_trigger\nBEFORE INSERT OR UPDATE ON \"Rating\"\nFOR EACH ROW EXECUTE FUNCTION validate_rating_stars();",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "INSERT INTO \"Rating\" (rID, mID, stars, ratingDate) VALUES (203, 101, 3, '2023-01-01');",
      "INSERT INTO \"Rating\" (rID, mID, stars, ratingDate) VALUES (204, 102, 5, '2023-01-02');",
      "UPDATE \"Rating\" SET stars = 1 WHERE rID = 201;",
      "UPDATE \"Rating\" SET stars = 4 WHERE rID = 202;",
      "INSERT INTO \"Rating\" (rID, mID, stars, ratingDate) VALUES (205, 103, 0, '2023-01-03');"
    ],
    "summary": "Create a trigger function named validate_rating_stars that, before inserting or updating a row in the Rating table, checks if the new stars value is between 1 and 5 inclusive. If not, raise an exception 'Rating stars must be between 1 and 5'. Otherwise, allow the operation.",
    "natural_language": "Hey, can you whip up a trigger function called validate_rating_stars? Before any new rating gets added or an existing one is changed in the Rating table, it's gotta check if the stars value is from 1 to 5. If it's not in that range, just throw an error saying 'Rating stars must be between 1 and 5'. If it's all good, then let it slide.",
    "id": 225
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically inserts a new row into the Participants_in_Events table whenever a new row is added to the Events table. The function, named trg_log_event_creation, is designed to be executed as a trigger after an insert operation on the Events table. It takes no parameters directly, but operates on the NEW record, which represents the row that was just inserted into the Events table. The function performs an insert operation into the Participants_in_Events table, specifically inserting the Event_ID from the NEW record and a hardcoded Participant_ID value of 1 into the respective columns of the Participants_in_Events table. The function then returns the NEW record, allowing the trigger to complete its operation. The trigger, named log_event_creation_trigger, is defined to execute this function after each row insertion on the Events table, ensuring that every new event automatically logs a participant with ID 1 in the Participants_in_Events table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_log_event_creation() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (NEW.\"Event_ID\", 1);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_event_creation_trigger\nAFTER INSERT ON \"Events\"\nFOR EACH ROW EXECUTE FUNCTION trg_log_event_creation();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (100, 5, 'New Event Created');",
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (101, 8, 'Success');",
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (102, 2, 'Fail');",
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (103, 6, 'Test Event');",
      "INSERT INTO \"Events\" (\"Event_ID\", \"Service_ID\", \"Event_Details\") VALUES (104, 5, 'Another Event');"
    ],
    "summary": "Create an AFTER INSERT trigger on the Events table that inserts a new row into the Participants_in_Events table, using the new Event_ID and a hardcoded Participant_ID of 1.",
    "natural_language": "Please implement an AFTER INSERT trigger on the Events table. The trigger's function is to insert a corresponding record into the Participants_in_Events table, utilizing the newly generated Event_ID and assigning a static Participant_ID value of 1.",
    "id": 226
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_remove_event_participants that returns a trigger and is executed by a trigger named remove_event_participants_trigger, which is defined to fire BEFORE DELETE on the Events table for each row being deleted, where the function's logic performs a DELETE operation on the table named Participants_in_Events, specifically targeting all rows in that table where the column Event_ID matches the value of the Event_ID column from the OLD row record (which represents the row being deleted from the Events table), and then returns the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_remove_event_participants() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Participants_in_Events\" WHERE \"Event_ID\" = OLD.\"Event_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_event_participants_trigger\nBEFORE DELETE ON \"Events\"\nFOR EACH ROW EXECUTE FUNCTION trg_remove_event_participants();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = 3;",
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = 8;",
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = 13;",
      "DELETE FROM \"Events\" WHERE \"Event_ID\" = (SELECT \"Event_ID\" FROM \"Events\" ORDER BY RANDOM() LIMIT 1);",
      "DELETE FROM \"Events\" WHERE \"Service_ID\" = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger on the Events table that deletes all rows from the Participants_in_Events table where the Event_ID matches the ID of the event being deleted.",
    "natural_language": "How can I create a BEFORE DELETE trigger for the Events table to remove all related entries from the Participants_in_Events table when an event's ID matches the Event_ID of the records being deleted?",
    "id": 227
  },
  {
    "ir": "Write a PLpgSQL trigger function named trg_update_participant_details that automatically modifies the Participant_Details column of a row in the Participants table before the row is updated. The function takes no parameters and is designed to be executed for each row that is subject to an update operation on the Participants table. The function operates by transforming the value of the Participant_Details column in the NEW row version to uppercase using the UPPER() function, which is a built-in PostgreSQL function that converts a string to its uppercase equivalent. The NEW keyword refers to the row that is being updated, allowing the function to access and modify its columns. After converting the Participant_Details column to uppercase, the function returns the modified NEW row, ensuring that the update operation proceeds with the altered data. The trigger named update_participant_details_trigger is created to invoke this function. It is defined to fire before any update operation on the Participants table, ensuring that the Participant_Details column is always stored in uppercase format whenever a row is updated. The trigger is set to execute the trg_update_participant_details function for each row that is updated, thereby applying the uppercase transformation consistently across all updates to the Participant_Details column in the Participants table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_participant_details() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Participant_Details\" = UPPER(NEW.\"Participant_Details\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_participant_details_trigger\nBEFORE UPDATE ON \"Participants\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_participant_details();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "UPDATE \"Participants\" SET \"Participant_Details\" = 'John Doe' WHERE \"Participant_ID\" = 9;",
      "UPDATE \"Participants\" SET \"Participant_Details\" = 'Jane Smith' WHERE \"Participant_Type_Code\" = 'Organizer';",
      "UPDATE \"Participants\" SET \"Participant_Details\" = 'test details' WHERE \"Participant_ID\" = 26;",
      "UPDATE \"Participants\" SET \"Participant_Details\" = \"Participant_Details\" || ' updated';",
      "UPDATE \"Participants\" SET \"Participant_Details\" = 'lowercase name' WHERE \"Participant_ID\" = 28;"
    ],
    "summary": "Create a BEFORE UPDATE trigger on the Participants table that converts the Participant_Details column to uppercase for the row being updated.",
    "natural_language": "How can I create a BEFORE UPDATE trigger for the Participants table to ensure the Participant_Details column is converted to uppercase for the row being updated?",
    "id": 228
  },
  {
    "ir": "Write a PostgreSQL trigger function named trg_create_default_participant that is executed automatically after every insert operation on the Services table for each newly inserted row, which takes no explicit parameters but has access to the special NEW record variable containing the column values of the newly inserted Services row, and within its body performs a single INSERT operation into the Participants table, specifying values for three columns: it sets the Participant_ID column to the result of adding 1000 to the value from the Service_ID column of the NEW record, sets the Participant_Type_Code column to the literal string value 'Organizer', and sets the Participant_Details column to the literal string value 'Auto Generated', and finally returns the NEW record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_create_default_participant() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Participants\" (\"Participant_ID\", \"Participant_Type_Code\", \"Participant_Details\") VALUES (NEW.\"Service_ID\" + 1000, 'Organizer', 'Auto Generated');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER create_default_participant_trigger\nAFTER INSERT ON \"Services\"\nFOR EACH ROW EXECUTE FUNCTION trg_create_default_participant();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (1, 'Marriage');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (3, 'Death Proof');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (4, 'Birth Proof');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (7, 'Marriage');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (9, 'Death Proof');"
    ],
    "summary": "Create an AFTER INSERT trigger on the Services table that inserts a new row into the Participants table, setting Participant_ID to (Service_ID + 1000), Participant_Type_Code to 'Organizer', and Participant_Details to 'Auto Generated'.",
    "natural_language": "How can I create an AFTER INSERT trigger on the Services table to insert a new row into the Participants table, setting Participant_ID to (Service_ID + 1000), Participant_Type_Code to 'Organizer', and Participant_Details to 'Auto Generated'?",
    "id": 229
  },
  {
    "ir": "Write a PLpgSQL trigger function named trg_cleanup_participant_events that is designed to execute after a row is deleted from the Participants table. This function does not take any parameters directly, but it operates using the OLD record, which represents the row that was just deleted from the Participants table. The function performs a DELETE operation on the Participants_in_Events table, specifically targeting rows where the Participant_ID column matches the Participant_ID value from the OLD record. The purpose of this operation is to remove any associations or records in the Participants_in_Events table that correspond to the participant who has been deleted from the Participants table. After executing the DELETE operation, the function returns the OLD record, which is a standard practice in trigger functions to indicate the completion of the operation. The trigger named cleanup_participant_events_trigger is created to automatically invoke this function after a DELETE operation occurs on the Participants table. This trigger is defined to execute for each row that is deleted, ensuring that the cleanup operation is performed individually for every participant removed from the Participants table.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_cleanup_participant_events() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Participants_in_Events\" WHERE \"Participant_ID\" = OLD.\"Participant_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cleanup_participant_events_trigger\nAFTER DELETE ON \"Participants\"\nFOR EACH ROW EXECUTE FUNCTION trg_cleanup_participant_events();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "DELETE FROM \"Participants\" WHERE \"Participant_ID\" = 9;",
      "DELETE FROM \"Participants\" WHERE \"Participant_ID\" = 26;",
      "DELETE FROM \"Participants\" WHERE \"Participant_ID\" = 28;",
      "DELETE FROM \"Participants\" WHERE \"Participant_Type_Code\" = 'Organizer';",
      "DELETE FROM \"Participants\" WHERE \"Participant_Details\" = 'Karlee Batz';"
    ],
    "summary": "Create an AFTER DELETE trigger on the Participants table that deletes all rows from the Participants_in_Events table where the Participant_ID matches the ID of the participant being deleted.",
    "natural_language": "Construct an AFTER DELETE trigger to be placed on the Participants table, which will meticulously and automatically remove every corresponding row from the Participants_in_Events table whenever a participant is deleted, specifically targeting those records where the Participant_ID perfectly matches the unique ID of the participant who has just been removed.",
    "id": 230
  },
  {
    "ir": "Write a PLpgSQL function named trg_update_company_rank that is designed to be used as a trigger function. This function updates the Rank column in the company table for a specific company identified by the Company_ID. The update operation sets the Rank to the average of the Rank_of_the_Year values from the station_company table for the same Company_ID as the one in the newly inserted or updated row. The function is triggered after an insert or update operation on the station_company table, and it executes for each row affected by these operations. The trigger named update_company_rank is created to invoke this function after any insert or update on the station_company table. The trigger ensures that whenever a new row is inserted or an existing row is updated in the station_company table, the trg_update_company_rank function is executed to recalculate and update the Rank of the corresponding company in the company table. Additionally, an example insert statement is provided, which attempts to insert a new row into the station_company table with specific values for Station_ID, Company_ID, and Rank_of_the_Year. If a conflict occurs on the combination of Station_ID and Company_ID, the insert operation does nothing, effectively ignoring the conflict.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_company_rank() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"company\" \n    SET \"Rank\" = (\n        SELECT AVG(\"Rank_of_the_Year\") \n        FROM \"station_company\" \n        WHERE \"Company_ID\" = NEW.\"Company_ID\"\n    ) \n    WHERE \"Company_ID\" = NEW.\"Company_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_company_rank\nAFTER INSERT OR UPDATE ON \"station_company\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_company_rank();\n\n-- Example of handling the insertion with ON CONFLICT\nINSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\nVALUES (4, 1, 2)\nON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (5, 1, 3);",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (6, 2, 4);",
      "UPDATE \"station_company\" SET \"Rank_of_the_Year\" = 5 WHERE \"Station_ID\" = 1 AND \"Company_ID\" = 3;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (7, 1, 1) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "UPDATE \"station_company\" SET \"Rank_of_the_Year\" = 2 WHERE \"Station_ID\" = 11 AND \"Company_ID\" = 1;"
    ],
    "summary": "Create a trigger function named trg_update_company_rank that fires after INSERT or UPDATE on the station_company table. For each affected row, update the company table's Rank column for the matching Company_ID, setting it to the average Rank_of_the_Year from the station_company table for that company. The associated trigger is named update_company_rank.",
    "natural_language": "Please construct a trigger function designated as 'trg_update_company_rank'. This function is to be executed subsequent to any INSERT or UPDATE operation performed on the 'station_company' table. For every row impacted by these operations, it is required to modify the 'Rank' column within the 'company' table. The update should be applied to the record with the corresponding 'Company_ID', assigning it a value equivalent to the computed average of the 'Rank_of_the_Year' values from the 'station_company' table associated with that specific company. The trigger that invokes this function shall be named 'update_company_rank'.",
    "id": 231
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the insertion of any row into the \"station_company\" table, executes an update operation on the \"company\" table. This update operation increases the \"Sales_billion\" column by 10% for each company whose \"Company_ID\" appears more than 10 times in the \"station_company\" table. The trigger is named \"adjust_sales_based_on_stations\" and is set to fire after each insert statement on the \"station_company\" table. The function \"trg_adjust_sales_based_on_stations\" does not take any parameters and returns a trigger type. It performs a subquery to select \"Company_ID\" from the \"station_company\" table, groups the results by \"Company_ID\", and filters these groups to include only those with a count greater than 10. The main update operation then applies to all rows in the \"company\" table where the \"Company_ID\" matches any of the \"Company_ID\" values returned by the subquery. The function concludes by returning NULL, as it is designed to be used as a trigger function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_adjust_sales_based_on_stations() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"company\" SET \"Sales_billion\" = \"Sales_billion\" * 1.1 WHERE \"Company_ID\" IN (SELECT \"Company_ID\" FROM \"station_company\" GROUP BY \"Company_ID\" HAVING COUNT(*) > 10);\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_sales_based_on_stations\nAFTER INSERT ON \"station_company\"\nFOR EACH STATEMENT EXECUTE FUNCTION trg_adjust_sales_based_on_stations();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (100, 1, 5);",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (101, 2, 6), (102, 2, 7), (103, 2, 8), (104, 2, 9), (105, 2, 10), (106, 2, 11), (107, 2, 12), (108, 2, 13), (109, 2, 14), (110, 2, 15), (111, 2, 16);",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") SELECT 200, 3, 20 FROM generate_series(1, 15);",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (300, 4, 1);",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (301, 5, 2), (302, 5, 3), (303, 5, 4), (304, 5, 5), (305, 5, 6), (306, 5, 7), (307, 5, 8), (308, 5, 9), (309, 5, 10), (310, 5, 11), (311, 5, 12);"
    ],
    "summary": "Create a trigger function named trg_adjust_sales_based_on_stations that fires after INSERT on the station_company table. It updates the company table, increasing the Sales_billion by 10% for companies whose Company_ID appears more than 10 times in the station_company table. The trigger is named adjust_sales_based_on_stations.",
    "natural_language": "Alright, so we need a trigger called trg_adjust_sales_based_on_stations that kicks in right after we add something to the station_company table. What it's gotta do is bump up the Sales_billion by 10% in the company table, but only for those companies that show up more than 10 times in station_company. Just name the whole trigger adjust_sales_based_on_stations.",
    "id": 232
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `prevent_overcapacity` that is designed to be executed as a `BEFORE INSERT` trigger on the `\"Boxes\"` table, and a trigger named `trg_boxes_prevent_overcapacity` that invokes this function. The `prevent_overcapacity` function takes no explicit parameters but implicitly receives special variables `NEW` and `OLD` (though `OLD` is not used in this specific `BEFORE INSERT` context) representing the new and old row data, respectively. The purpose of this function is to prevent the insertion of a new box into the `\"Boxes\"` table if doing so would cause the associated warehouse to exceed its defined capacity.\n\nUpon execution, the function first performs a `SELECT` operation to count the existing number of boxes in the `\"Boxes\"` table for a specific warehouse. This count is obtained by querying the `\"Boxes\"` table and filtering rows where the `\"Warehouse\"` column matches the value of the `\"Warehouse\"` column from the `NEW` row (the row currently being inserted). The result of this `COUNT(*)` aggregation is then compared against the capacity of that same warehouse.\n\nConcurrently, another `SELECT` operation is performed on the `\"Warehouses\"` table to retrieve the `\"Capacity\"` column value. This selection is filtered by matching the `\"Code\"` column in the `\"Warehouses\"` table with the value of the `\"Warehouse\"` column from the `NEW` row.\n\nThe core logic of the function is an `IF` conditional statement. It evaluates whether the count of existing boxes (obtained from the first `SELECT` statement) is greater than or equal to the `\"Capacity\"` of the warehouse (obtained from the second `SELECT` statement).\n\nIf this condition evaluates to `TRUE` (meaning the warehouse is already at or above its capacity), the function immediately executes `RETURN NULL;`. Returning `NULL` from a `BEFORE INSERT` trigger function in PostgreSQL signifies that the insertion operation should be aborted, effectively preventing the new box from being added to the `\"Boxes\"` table.\n\nIf the condition evaluates to `FALSE` (meaning there is still capacity in the warehouse), the function executes `RETURN NEW;`. Returning `NEW` from a `BEFORE INSERT` trigger function indicates that the insertion operation should proceed as normal with the data provided in the `NEW` row.\n\nThe `trg_boxes_prevent_overcapacity` trigger is defined to execute the `prevent_overcapacity()` function `BEFORE INSERT` operations on the `\"Boxes\"` table. It is configured to run `FOR EACH ROW`, meaning the `prevent_overcapacity` function will be invoked once for every row that is attempted to be inserted into the `\"Boxes\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION prevent_overcapacity() RETURNS TRIGGER AS $$\nBEGIN\n    IF (SELECT COUNT(*) FROM \"Boxes\" WHERE \"Warehouse\" = NEW.\"Warehouse\") >= \n       (SELECT \"Capacity\" FROM \"Warehouses\" WHERE \"Code\" = NEW.\"Warehouse\") THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_prevent_overcapacity\nBEFORE INSERT ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION prevent_overcapacity();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ1', 'Books', 100.0, 1);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ2', 'Electronics', 500.0, 2);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ3', 'Clothes', 75.0, 3);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ4', 'Tools', 200.0, 4);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('XYZ5', 'Food', 50.0, 1);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named prevent_overcapacity on the Boxes table. For each new row, check if the associated warehouse's current box count is at or above its capacity (from the Warehouses table). If so, abort the insert by returning NULL; otherwise, allow it by returning NEW. The trigger is named trg_boxes_prevent_overcapacity.",
    "natural_language": "Set up a trigger on the Boxes table to run before adding new entries. It should look at the related warehouse and see if it's getting pretty full or is already at its limit based on the number of boxes already there. If it seems like there's not really enough room, then stop the new box from being added. Otherwise, it's okay to let it through. Name the trigger something like trg_boxes_prevent_overcapacity.",
    "id": 233
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_capacity_on_value_change that is executed automatically after any update operation on the \"Value\" column of the \"Boxes\" table for each modified row, which compares the new and old values of the \"Value\" column and conditionally updates the \"Capacity\" column in the \"Warehouses\" table: if the new \"Value\" is greater than 500 and the old \"Value\" was less than or equal to 500, it executes an UPDATE statement on the \"Warehouses\" table to decrement the \"Capacity\" by 1 for the specific warehouse where the \"Code\" column matches the NEW.\"Warehouse\" value from the updated box; conversely, if the new \"Value\" is less than or equal to 500 and the old \"Value\" was greater than 500, it executes an UPDATE statement on the \"Warehouses\" table to increment the \"Capacity\" by 1 for the warehouse where the \"Code\" column matches the NEW.\"Warehouse\" value.",
    "plsql": "CREATE OR REPLACE FUNCTION update_capacity_on_value_change() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Value\" > 500 AND OLD.\"Value\" <= 500 THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" - 1 WHERE \"Code\" = NEW.\"Warehouse\";\n    ELSIF NEW.\"Value\" <= 500 AND OLD.\"Value\" > 500 THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + 1 WHERE \"Code\" = NEW.\"Warehouse\";\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_value_change\nAFTER UPDATE OF \"Value\" ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION update_capacity_on_value_change();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "UPDATE \"Boxes\" SET \"Value\" = 600 WHERE \"Code\" = '0MN7';",
      "UPDATE \"Boxes\" SET \"Value\" = 400 WHERE \"Warehouse\" = 3 AND \"Value\" = 600;",
      "UPDATE \"Boxes\" SET \"Value\" = 550 WHERE \"Warehouse\" = 1 AND \"Contents\" = 'Scissors';",
      "UPDATE \"Boxes\" SET \"Value\" = 500 WHERE \"Code\" = '4H8P';",
      "UPDATE \"Boxes\" SET \"Value\" = 750, \"Warehouse\" = 4 WHERE \"Code\" = '4RT3';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_capacity_on_value_change on the Boxes table, firing when the Value column changes. If the new Value > 500 and the old Value <= 500, decrement the Capacity by 1 in the Warehouses table for the matching warehouse. If the new Value <= 500 and the old Value > 500, increment the Capacity by 1.",
    "natural_language": "Create trigger update_capacity_on_value_change after Boxes update on Value change. If Value crosses 500 threshold, adjust Warehouses.Capacity accordingly.",
    "id": 234
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the Team_Leader column in the club table with the Name of a member from the member table, where the Member_ID matches the Member_ID of the newly inserted row in the club_leader table, and the Club_ID matches the Club_ID of the newly inserted row. The function is executed after each row insertion into the club_leader table, ensuring that the Team_Leader in the club table is synchronized with the corresponding member's Name based on the new club_leader entry.",
    "plsql": "CREATE OR REPLACE FUNCTION update_club_leader_name() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"club\" SET \"Team_Leader\" = (SELECT \"Name\" FROM \"member\" WHERE \"Member_ID\" = NEW.\"Member_ID\") WHERE \"Club_ID\" = NEW.\"Club_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sync_leader_name\n    AFTER INSERT ON \"club_leader\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_club_leader_name();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (1, 1984, '2023');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (3, 1985, '2022');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (4, 1986, '2021');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (8, 1984, '2020');",
      "INSERT INTO club_leader (Club_ID, Member_ID, Year_Join) VALUES (6, 1985, '2019');"
    ],
    "summary": "Create an AFTER INSERT trigger function on the club_leader table. For each new row, update the club table's Team_Leader column with the Name from the member table, where the Member_ID and Club_ID match the newly inserted club_leader entry.",
    "natural_language": "Construct an AFTER INSERT trigger function that will be automatically activated on the club_leader table. For every single new row that is successfully inserted, this function must meticulously update the Team_Leader column within the club table. The new value should be carefully set to the corresponding Name retrieved from the member table, specifically where the Member_ID from the member table and the Club_ID from the club table perfectly match the values found in the newly inserted club_leader record.",
    "id": 235
  },
  {
    "ir": "Write a PLpgSQL function named set_random_ranking that returns a trigger and is designed to update the Overall_Ranking column in the club table with a random integer between 1 and 100 whenever a new record is successfully inserted into the club_leader table. The function uses the FLOOR function to convert the result of the random function, which generates a floating-point number between 0 and 1, into an integer, and adds 1 to ensure the ranking is at least 1. The update operation targets the row in the club table where the Club_ID matches the Club_ID of the newly inserted club_leader record, identified by the NEW keyword. The function concludes by returning the NEW record, indicating successful completion of the operation. Additionally, write a PLpgSQL function named prevent_duplicate_club_leader that returns a trigger and is designed to prevent the insertion of duplicate records into the club_leader table. This function checks for the existence of a record in the club_leader table with the same Club_ID and Member_ID as the NEW record using the EXISTS clause in a SELECT statement. If such a record exists, the function returns NULL, effectively preventing the insertion. If no duplicate is found, the function returns the NEW record, allowing the insertion to proceed. Subsequently, write a trigger named prevent_duplicate that is executed before an insert operation on the club_leader table for each row, invoking the prevent_duplicate_club_leader function to enforce the uniqueness constraint. Also, write a trigger named randomize_ranking that is executed after an insert operation on the club_leader table for each row, invoking the set_random_ranking function to update the club's ranking. Before creating these triggers, ensure any existing triggers with the same names are dropped using the DROP TRIGGER IF EXISTS statement to avoid conflicts.",
    "plsql": "CREATE OR REPLACE FUNCTION set_random_ranking() RETURNS TRIGGER AS $$\nBEGIN\n    -- Update the club's ranking when a new club_leader record is successfully inserted\n    UPDATE \"club\" \n    SET \"Overall_Ranking\" = FLOOR(random() * 100) + 1 \n    WHERE \"Club_ID\" = NEW.\"Club_ID\";\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE OR REPLACE FUNCTION prevent_duplicate_club_leader() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if duplicate exists\n    IF EXISTS (SELECT 1 FROM \"club_leader\" \n               WHERE \"Club_ID\" = NEW.\"Club_ID\" \n               AND \"Member_ID\" = NEW.\"Member_ID\") THEN\n        -- Duplicate found, prevent insert\n        RETURN NULL;\n    END IF;\n    \n    -- No duplicate, allow insert\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Drop existing trigger if it exists\nDROP TRIGGER IF EXISTS randomize_ranking ON \"club_leader\";\nDROP TRIGGER IF EXISTS prevent_duplicate ON \"club_leader\";\n\n-- Create trigger to prevent duplicates\nCREATE TRIGGER prevent_duplicate\n    BEFORE INSERT ON \"club_leader\"\n    FOR EACH ROW\n    EXECUTE FUNCTION prevent_duplicate_club_leader();\n\n-- Create trigger to update ranking after successful insert\nCREATE TRIGGER randomize_ranking\n    AFTER INSERT ON \"club_leader\"\n    FOR EACH ROW\n    EXECUTE FUNCTION set_random_ranking();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1986, '2020');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (3, 1984, '2021');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (4, 1985, '2019');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1985, '2022');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (3, 1986, '2023');"
    ],
    "summary": "Create a PLpgSQL trigger function named set_random_ranking that updates the club table's Overall_Ranking to a random integer between 1 and 100 after a new row is inserted into club_leader. The update uses the NEW.Club_ID. Also, create a function named prevent_duplicate_club_leader that returns NULL if a duplicate Club_ID and Member_ID combination exists in club_leader, preventing the insert. Create a BEFORE INSERT trigger named prevent_duplicate to call the duplicate check function. Create an AFTER INSERT trigger named randomize_ranking to call the ranking update function. Drop existing triggers with these names first.",
    "natural_language": "First, drop any existing triggers named prevent_duplicate or randomize_ranking. Then, create a PLpgSQL function called set_random_ranking that, after a new row is inserted into club_leader, updates the Overall_Ranking in the club table to a random number from 1 to 100 for the NEW.Club_ID. Next, create another function named prevent_duplicate_club_leader that returns NULL to block the insert if the combination of Club_ID and Member_ID already exists in club_leader. After that, create a BEFORE INSERT trigger named prevent_duplicate to execute the duplicate check function. Finally, create an AFTER INSERT trigger named randomize_ranking to call the ranking update function.",
    "id": 236
  },
  {
    "ir": "Write a PLpgSQL function named delete_members_on_club_delete that is designed to be executed as part of a trigger mechanism. This function does not take any parameters directly but operates within the context of a trigger event. It is intended to be executed before a row is deleted from the club table. The function performs a DELETE operation on the member table, specifically targeting rows where the Member_ID column matches any Member_ID found in the club_leader table for which the Club_ID column equals the Club_ID value of the row being deleted from the club table. The OLD keyword is used to reference the Club_ID of the row that is about to be deleted from the club table. After executing the DELETE operation, the function returns the OLD row, which is the row that triggered the function execution. The function is written in the PLpgSQL language. Additionally, a trigger named cascade_delete_members is created to invoke this function. This trigger is set to execute before a row is deleted from the club table, ensuring that any associated members in the member table are removed when a club is deleted. The trigger is defined to execute the delete_members_on_club_delete function for each row that is deleted from the club table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_members_on_club_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"member\" WHERE \"Member_ID\" IN (SELECT \"Member_ID\" FROM \"club_leader\" WHERE \"Club_ID\" = OLD.\"Club_ID\");\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cascade_delete_members\n    BEFORE DELETE ON \"club\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_members_on_club_delete();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "DELETE FROM \"club\" WHERE \"Club_ID\" = 1;",
      "DELETE FROM \"club\" WHERE \"Club_Name\" = 'SMU';",
      "DELETE FROM \"club\" WHERE \"Team_Leader\" = 'Tony Peters';",
      "DELETE FROM \"club\" WHERE \"Overall_Ranking\" > 50;",
      "DELETE FROM \"club\" WHERE \"Club_ID\" IN (3, 4);"
    ],
    "summary": "Create a PLpgSQL trigger function named delete_members_on_club_delete. It deletes rows from the member table where the Member_ID matches any Member_ID in club_leader for the OLD.Club_ID. The function returns OLD. Create a BEFORE DELETE trigger named cascade_delete_members on the club table to execute this function for each row.",
    "natural_language": "Develop a comprehensive PLpgSQL trigger function, meticulously named delete_members_on_club_delete, which is designed to perform a detailed cleanup operation. This function will systematically and permanently delete all relevant rows from the member table, specifically targeting those entries where the Member_ID corresponds precisely to any Member_ID listed within the club_leader table for the specific OLD.Club_ID that is being processed. Upon its successful completion, the function should thoughtfully return the OLD record. Subsequently, you must establish a BEFORE DELETE trigger, aptly named cascade_delete_members, on the club table itself; this trigger will reliably execute the aforementioned function for each individual row that is slated for deletion, thereby ensuring a thorough and cascading data integrity process.",
    "id": 237
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"club_leader\" table. The function checks if a combination of \"Club_ID\" and \"Member_ID\" already exists in the \"club_leader\" table. If such a combination exists, the function prevents the insert operation by returning NULL. If the combination does not exist, the function updates the \"member\" table by increasing the \"Age\" column of the row where \"Member_ID\" matches the \"Member_ID\" of the new row being inserted. The age is increased by a random integer value between 1 and 5, inclusive, calculated using the FLOOR function applied to the result of the random() function multiplied by 5, and then adding 1. After updating the age, the function allows the insert operation to proceed by returning the new row. The trigger named \"random_age_increase\" is associated with this function and is set to execute before each row is inserted into the \"club_leader\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_age_with_random() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if this Club_ID, Member_ID combination already exists\n    IF EXISTS (SELECT 1 FROM \"club_leader\" WHERE \"Club_ID\" = NEW.\"Club_ID\" AND \"Member_ID\" = NEW.\"Member_ID\") THEN\n        RETURN NULL; -- Prevent the insert\n    END IF;\n    \n    UPDATE \"member\" SET \"Age\" = \"Age\" + FLOOR(random() * 5) + 1 WHERE \"Member_ID\" = NEW.\"Member_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER random_age_increase\n    BEFORE INSERT ON \"club_leader\"\n    FOR EACH ROW\n    EXECUTE FUNCTION adjust_age_with_random();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1984, '2024');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (3, 1985, '2023');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (4, 1986, '2022');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (8, 1987, '2021');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (6, 1988, '2020');"
    ],
    "summary": "Create a PLpgSQL BEFORE INSERT trigger function on club_leader. If a row with the same Club_ID and Member_ID exists, return NULL to prevent the insert. Otherwise, update the member table by increasing the Age for the matching Member_ID by a random integer between 1 and 5, then return NEW. Name the trigger random_age_increase.",
    "natural_language": "Alright, so we need a trigger for the club_leader table that fires before a new entry is added. Here's the deal: if there's already a record with the same Club_ID and Member_ID combo, just block the insert entirely. If it's a new combo, then we gotta go to the member table, find that Member_ID, and bump up their Age by some random number from 1 to 5. After that, the insert can go ahead. Oh, and don't forget to name this whole thing random_age_increase.",
    "id": 238
  },
  {
    "ir": "Write a PLpgSQL function that updates the \"Artists\" table by setting the \"birthYear\" column to 1800 for the row where the \"artistID\" matches the \"painterID\" of a newly inserted row in the \"Paintings\" table. This function is triggered by an AFTER INSERT operation on the \"Paintings\" table, and for each new row inserted, it executes the update operation on the \"Artists\" table, ensuring that the \"birthYear\" is set to 1800 for the corresponding artist. The function returns the newly inserted row in the \"Paintings\" table after performing the update.",
    "plsql": "CREATE OR REPLACE FUNCTION update_artist_birth_year() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Artists\" SET \"birthYear\" = 1800 WHERE \"artistID\" = NEW.\"painterID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_artist_birth\nAFTER INSERT ON \"Paintings\"\nFOR EACH ROW EXECUTE FUNCTION update_artist_birth_year();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (83, 'Starry Night', 1889, 737, 921, 'oil', 'canvas', 'Gallery 231', 333);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (84, 'Guernica', 1937, 349, 776, 'oil', 'canvas', 'Gallery 232', 222);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (85, 'The Persistence of Memory', 1931, 240, 330, 'oil', 'canvas', 'Gallery 233', 111);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (86, 'The Scream', 1893, 910, 740, 'oil', 'canvas', 'Gallery 234', 333);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"height_mm\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (87, 'The Night Watch', 1642, 363, 437, 'oil', 'canvas', 'Gallery 235', 222);"
    ],
    "summary": "Create a PLpgSQL AFTER INSERT trigger function on the Paintings table. It updates the Artists table, setting birthYear to 1800 where artistID equals the NEW.painterID. The function returns the NEW row from Paintings.",
    "natural_language": "How do you create a PLpgSQL AFTER INSERT trigger function on the Paintings table that updates the Artists table by setting birthYear to 1800 where artistID equals the NEW.painterID and returns the NEW row from Paintings?",
    "id": 239
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_old_sculptures that returns a trigger and is executed automatically by a trigger named trg_delete_old_sculptures, which is defined to fire after every row update operation on the table named Artists, where the function performs a delete operation on the table named Sculptures, specifically removing all rows from the Sculptures table where the value in the column named year is less than the numerical value 1900, and the function concludes by returning the NEW row record from the triggering update on the Artists table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_old_sculptures() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Sculptures\" WHERE \"year\" < 1900;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_old_sculptures\nAFTER UPDATE ON \"Artists\"\nFOR EACH ROW EXECUTE FUNCTION delete_old_sculptures();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "UPDATE \"Artists\" SET \"fname\" = 'Updated' WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1900 WHERE \"artistID\" = 222;",
      "UPDATE \"Artists\" SET \"lname\" = 'NewName' WHERE \"artistID\" = 333;",
      "UPDATE \"Artists\" SET \"deathYear\" = 2000 WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"fname\" = 'AnotherUpdate' WHERE \"artistID\" = 222;"
    ],
    "summary": "Create a PostgreSQL trigger function named delete_old_sculptures. After an update on the Artists table, it deletes all rows from the Sculptures table where the year column is less than 1900. The function returns the NEW row. Create an AFTER UPDATE trigger named trg_delete_old_sculptures on Artists to execute this function for each row.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'delete_old_sculptures'. Following an update operation on the Artists table, this function shall remove all entries from the Sculptures table for which the value in the 'year' column precedes 1900. The function must be defined to return the NEW row. Subsequently, establish an AFTER UPDATE trigger named 'trg_delete_old_sculptures' on the Artists table to invoke this function for each affected row.",
    "id": 240
  },
  {
    "ir": "Write a PLpgSQL trigger function named `insert_default_painting` that is designed to be executed in response to a specific database event, and a trigger named `trg_insert_default_painting` that invokes this function. The `insert_default_painting` function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` which represents the new row being inserted or updated. The purpose of this function is to insert a new record into the `\"Paintings\"` table. Specifically, it inserts a row with the following column values: the `\"paintingID\"` column is set to the integer literal `999`, the `\"title\"` column is set to the string literal `'Default Work'`, and the `\"painterID\"` column is populated with the value from the `\"artistID\"` column of the `NEW` row, which is the row that caused the trigger to fire. After performing this insertion, the function returns `NEW`, indicating that the row that triggered the operation should proceed with its insertion into the `\"Artists\"` table. The `trg_insert_default_painting` trigger is defined to execute `AFTER INSERT` operations on the `\"Artists\"` table. It is a `FOR EACH ROW` trigger, meaning that the `insert_default_painting` function will be executed once for every single row that is inserted into the `\"Artists\"` table. The trigger's action is to `EXECUTE FUNCTION insert_default_painting()`, thereby invoking the previously described function to insert a default painting associated with the newly inserted artist.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_default_painting() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"painterID\") VALUES (999, 'Default Work', NEW.\"artistID\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_default_painting\nAFTER INSERT ON \"Artists\"\nFOR EACH ROW EXECUTE FUNCTION insert_default_painting();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\") VALUES (444, 'Monet', 'Claude', 1840, 1926);",
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\") VALUES (555, 'Rembrandt', 'van Rijn', 1606);",
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\") VALUES (666, 'Klimt', 'Gustav', 1862, 1918);",
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\") VALUES (777, 'da Vinci', 'Leonardo');",
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\") VALUES (888, 'Kahlo', 'Frida', 1907, 1954);"
    ],
    "summary": "Create a trigger function named `insert_default_painting` and a trigger named `trg_insert_default_painting`. The trigger should fire AFTER INSERT on the \"Artists\" table FOR EACH ROW. The function should insert a new row into the \"Paintings\" table with paintingID=999, title='Default Work', and painterID set to the NEW.artistID. The function must then return NEW.",
    "natural_language": "Define a trigger function called `insert_default_painting` and a trigger named `trg_insert_default_painting`. Set the trigger to execute AFTER INSERT on the \"Artists\" table FOR EACH ROW. Make the function insert a new record into the \"Paintings\" table where paintingID is 999, title is 'Default Work', and painterID is set to the NEW.artistID. Ensure the function returns NEW.",
    "id": 241
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_sculpture_year that returns a trigger, which is then bound to a trigger named trg_update_sculpture_year on the Artists table, configured to execute before each row deletion on that table; the function's logic, upon invocation for a specific row being deleted from the Artists table, performs an update operation on the Sculptures table, setting the value of the year column to the integer 2000 for every row in the Sculptures table where the sculptorID column value is equal to the artistID column value from the old row data (referenced as OLD.artistID) of the Artists table that is about to be deleted, and the function concludes by returning the OLD row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_sculpture_year() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Sculptures\" SET \"year\" = 2000 WHERE \"sculptorID\" = OLD.\"artistID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_sculpture_year\nBEFORE DELETE ON \"Artists\"\nFOR EACH ROW EXECUTE FUNCTION update_sculpture_year();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "DELETE FROM \"Artists\" WHERE \"artistID\" = 111;",
      "DELETE FROM \"Artists\" WHERE \"artistID\" = 222;",
      "DELETE FROM \"Artists\" WHERE \"artistID\" = 333;"
    ],
    "summary": "Create a trigger function named `update_sculpture_year` and a trigger named `trg_update_sculpture_year`. The trigger should fire BEFORE DELETE on the \"Artists\" table FOR EACH ROW. The function should update the \"Sculptures\" table, setting year=2000 for all rows where sculptorID equals OLD.artistID. The function must then return OLD.",
    "natural_language": "How can I create a trigger function called `update_sculpture_year` and a trigger named `trg_update_sculpture_year` that fires BEFORE DELETE on the \"Artists\" table for each row, updates the \"Sculptures\" table by setting year to 2000 for all rows where sculptorID matches the OLD.artistID, and then returns OLD?",
    "id": 242
  },
  {
    "ir": "Write a PLpgSQL function named delete_artist_paintings that is designed to be used as a trigger function. This function does not take any parameters directly but operates in the context of a trigger. It is intended to execute after a delete operation on the Sculptures table. The function performs a delete operation on the Paintings table, specifically removing all rows where the painterID column matches the sculptorID column of the row that was just deleted from the Sculptures table. The OLD keyword is used to reference the values of the deleted row from the Sculptures table, allowing access to the sculptorID of the deleted record. The function returns the OLD record, which is a standard practice in trigger functions to allow further processing or logging of the deleted data. The function is associated with a trigger named trg_delete_artist_paintings, which is defined to execute after a row is deleted from the Sculptures table. The trigger is set to fire for each row that is deleted, ensuring that the function is executed individually for each deletion event, thereby maintaining the integrity of the operation by ensuring that all paintings associated with the deleted sculptor are removed from the Paintings table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_artist_paintings() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Paintings\" WHERE \"painterID\" = OLD.\"sculptorID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_artist_paintings\nAFTER DELETE ON \"Sculptures\"\nFOR EACH ROW EXECUTE FUNCTION delete_artist_paintings();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "DELETE FROM \"Sculptures\" WHERE \"sculptureID\" = 20;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptureID\" = 21;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptureID\" = 22;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = 222;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = 555;"
    ],
    "summary": "Create a trigger function named `delete_artist_paintings` and a trigger named `trg_delete_artist_paintings`. The trigger should fire AFTER DELETE on the \"Sculptures\" table FOR EACH ROW. The function should delete all rows from the \"Paintings\" table where painterID equals OLD.sculptorID. The function must then return OLD.",
    "natural_language": "Construct a trigger function with the detailed name `delete_artist_paintings` and an associated trigger named `trg_delete_artist_paintings`. This trigger should be configured to activate automatically AFTER a DELETE operation is performed on the \"Sculptures\" table, executing FOR EACH ROW that is removed. The function's primary responsibility is to meticulously locate and delete every corresponding row within the \"Paintings\" table where the painterID field precisely matches the OLD.sculptorID value from the deleted sculpture record. Finally, the function must explicitly return the OLD row to complete the operation.",
    "id": 243
  },
  {
    "ir": "Write a PLpgSQL function that ensures the uniqueness of the \"Conference_Name\" column in the conference table by appending '_1' to the name if a row with the same \"Conference_Name\" already exists, and a trigger that invokes this function before inserting a new row into the conference table. The function, named ensure_unique_conference_name, is designed to be executed as part of a trigger operation. It checks for the existence of a row in the conference table where the \"Conference_Name\" column matches the \"Conference_Name\" value of the new row being inserted. If such a row exists, indicating a duplicate name, the function modifies the \"Conference_Name\" of the new row by concatenating '_1' to the original name, thereby ensuring the name is unique before the row is inserted into the table. The trigger, named unique_name_enforcement, is set to activate before an insert operation on the conference table, executing the ensure_unique_conference_name function for each row being inserted, thus enforcing the uniqueness constraint on the \"Conference_Name\" column.",
    "plsql": "CREATE OR REPLACE FUNCTION ensure_unique_conference_name() RETURNS TRIGGER AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM conference WHERE \"Conference_Name\" = NEW.\"Conference_Name\") THEN\n        NEW.\"Conference_Name\" := NEW.\"Conference_Name\" || '_1';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER unique_name_enforcement\nBEFORE INSERT ON conference\nFOR EACH ROW EXECUTE FUNCTION ensure_unique_conference_name();",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "INSERT INTO conference (\"Conference_Name\", \"Year\", \"Location\") VALUES ('ACL', 2024, 'Canada');",
      "INSERT INTO conference (\"Conference_Name\", \"Year\", \"Location\") VALUES ('Naccl', 2024, 'USA');",
      "INSERT INTO conference (\"Conference_Name\", \"Year\", \"Location\") VALUES ('ICML', 2024, 'Austria');",
      "INSERT INTO conference (\"Conference_Name\", \"Year\", \"Location\") VALUES ('ACL', 2025, 'Germany');",
      "INSERT INTO conference (\"Conference_Name\", \"Year\", \"Location\") VALUES ('NeurIPS', 2024, 'France');"
    ],
    "summary": "Create a trigger function named `ensure_unique_conference_name` and a trigger named `unique_name_enforcement`. The trigger should fire BEFORE INSERT on the \"conference\" table FOR EACH ROW. The function should check if the NEW.\"Conference_Name\" already exists in the table. If a duplicate exists, modify NEW.\"Conference_Name\" by appending '_1' to it to ensure uniqueness.",
    "natural_language": "Create a trigger function called `ensure_unique_conference_name` and a trigger named `unique_name_enforcement`. Set the trigger to activate BEFORE INSERT on the \"conference\" table FOR EACH ROW. In the function, check if the NEW.\"Conference_Name\" is already present in the table. If a duplicate is found, append '_1' to NEW.\"Conference_Name\" to make it unique.",
    "id": 244
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an insert operation on the review table. This function, named prevent_review_for_long_books, does not take any parameters directly but operates on the NEW record of the review table. It retrieves the Pages column value from the book table where the Book_ID matches the Book_ID of the newly inserted review record. If the number of pages is greater than 900, it deletes the newly inserted review from the review table by using the Review_ID from the NEW record. The function then returns the NEW record. The trigger, named trg_prevent_review_for_long_books, is associated with this function and is set to execute after each row is inserted into the review table, ensuring that reviews for books with more than 900 pages are automatically removed immediately after insertion.",
    "plsql": "CREATE OR REPLACE FUNCTION prevent_review_for_long_books() RETURNS TRIGGER AS $$\nBEGIN\n  IF (SELECT \"Pages\" FROM \"book\" WHERE \"Book_ID\" = NEW.\"Book_ID\") > 900 THEN\n    DELETE FROM \"review\" WHERE \"Review_ID\" = NEW.\"Review_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_prevent_review_for_long_books\nAFTER INSERT ON \"review\"\nFOR EACH ROW EXECUTE FUNCTION prevent_review_for_long_books();",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (4, 1, 7.0, 3.5, 15);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (5, 2, 8.0, 4.0, 10);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (6, 3, 9.0, 4.5, 5);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (7, 1, 6.5, 3.2, 20);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (8, 3, 5.5, 2.7, 30);"
    ],
    "summary": "Create a trigger function named `prevent_review_for_long_books` and a trigger named `trg_prevent_review_for_long_books`. The trigger should fire AFTER INSERT on the \"review\" table FOR EACH ROW. The function should retrieve the \"Pages\" value from the \"book\" table where Book_ID matches NEW.Book_ID. If the page count exceeds 900, delete the newly inserted review from the \"review\" table using NEW.Review_ID. The function must then return NEW.",
    "natural_language": "Set up a trigger function and a trigger, maybe call them something like `prevent_review_for_long_books` and `trg_prevent_review_for_long_books`. The trigger should run after something gets added to the review table. The function should check the related book's page count—if it's a really high number, like way over a few hundred pages, then get rid of that new review entry. After that, just have it return the new record.",
    "id": 245
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after a new row is inserted into the \"Tracklists\" table, which updates the \"Title\" column in the \"Songs\" table to its uppercase version for the row where the \"SongId\" matches the \"SongId\" of the newly inserted row in the \"Tracklists\" table. The function does not take any parameters directly, but operates on the implicit NEW record provided by the trigger, which represents the newly inserted row. The trigger named \"tracklist_insert_trigger\" is defined to execute this function after each insert operation on the \"Tracklists\" table, ensuring that every time a new tracklist entry is added, the corresponding song title in the \"Songs\" table is converted to uppercase using the UPPER() function, which is a built-in SQL function that transforms a given string to uppercase letters. The function returns the NEW record, allowing the trigger to complete its operation without altering the inserted data in the \"Tracklists\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_song_title_on_album_insert() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Songs\" SET \"Title\" = UPPER(\"Title\") WHERE \"SongId\" = NEW.\"SongId\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER tracklist_insert_trigger\nAFTER INSERT ON \"Tracklists\"\nFOR EACH ROW EXECUTE FUNCTION update_song_title_on_album_insert();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (1, 'song one');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (101, 1, 1);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (2, 'another song');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (101, 2, 2);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (3, 'third track');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (102, 1, 3);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (4, 'a short tune');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (103, 1, 4);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (5, 'final song');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (103, 2, 5);"
    ],
    "summary": "Create an AFTER INSERT trigger function on the \"Tracklists\" table. For each new row, update the \"Songs\" table, setting the \"Title\" to UPPER(\"Title\") where the \"SongId\" matches the new row's \"SongId\". Return the NEW record.",
    "natural_language": "Alright, so every time a new tracklist entry gets added, I need you to set up a trigger that fires right after. This trigger's job is to go into the Songs table and change the song title to all caps, but only for the song whose ID matches the one in the new tracklist row. Just make sure the whole thing spits back the new record that was just inserted.",
    "id": 246
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_course_update_validation` that is designed to be executed `BEFORE UPDATE` on the `\"course\"` table, `FOR EACH ROW`. This trigger function takes no explicit parameters but operates on the implicit `NEW` and `OLD` row variables provided by the trigger mechanism. The primary purpose of this function is to validate updates to the `\"Course_ID\"` column within the `\"course\"` table. Specifically, it first checks if the value of the `\"Course_ID\"` column in the `NEW` row (the proposed updated row) is different from the value of the `\"Course_ID\"` column in the `OLD` row (the current row before the update). If these values are indeed different, indicating an attempt to change the `Course_ID`, the function then proceeds to check for referential integrity. It performs a `SELECT 1` query on the `\"course_arrange\"` table, looking for any rows where the `\"Course_ID\"` column matches the `OLD.\"Course_ID\"` (the original `Course_ID` value before the attempted change). If this `EXISTS` check returns true, meaning that the `OLD.\"Course_ID\"` is referenced in the `\"course_arrange\"` table, the function immediately returns `NULL`. Returning `NULL` from a `BEFORE UPDATE` trigger function in PostgreSQL has the effect of silently aborting the update operation for the current row, preventing the change to the `Course_ID` from occurring. If the `NEW.\"Course_ID\"` is not different from the `OLD.\"Course_ID\"`, or if it is different but the `OLD.\"Course_ID\"` is not found to be referenced in the `\"course_arrange\"` table, the function proceeds to the end and returns `NEW`. Returning `NEW` from a `BEFORE UPDATE` trigger function allows the update operation to proceed as normal with the proposed `NEW` row values. The trigger `course_update_validation` is then defined to execute this function `trg_course_update_validation` before any update operation on the `\"course\"` table, for every row being updated.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_course_update_validation() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the Course_ID is being changed\n  IF NEW.\"Course_ID\" <> OLD.\"Course_ID\" THEN\n    -- Check if the old Course_ID exists in course_arrange table\n    IF EXISTS (SELECT 1 FROM \"course_arrange\" WHERE \"Course_ID\" = OLD.\"Course_ID\") THEN\n      -- If the old Course_ID is referenced, prevent the update for this row\n      -- by returning NULL. This will silently abort the update for the current row.\n      RETURN NULL;\n    END IF;\n  END IF;\n  \n  -- If no issues, allow the update to proceed\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER course_update_validation\nBEFORE UPDATE ON \"course\"\nFOR EACH ROW EXECUTE FUNCTION trg_course_update_validation();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange"
    ],
    "call_sqls": [
      "UPDATE \"course\" SET \"Course_ID\" = 1 WHERE \"Course_ID\" = 2;",
      "UPDATE \"course\" SET \"Course_ID\" = 1 WHERE \"Course_ID\" = 3;",
      "UPDATE \"course\" SET \"Course_ID\" = 2 WHERE \"Course_ID\" = 1;",
      "UPDATE \"course\" SET \"Course_ID\" = 3 WHERE \"Course_ID\" = 1;",
      "UPDATE \"course\" SET \"Course_ID\" = 3 WHERE \"Course_ID\" = 2;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function on the \"course\" table. For each row, if the \"Course_ID\" is being changed and the old \"Course_ID\" exists in the \"course_arrange\" table, abort the update by returning NULL. Otherwise, allow the update by returning NEW.",
    "natural_language": "Create a BEFORE UPDATE trigger for the \"course\" table that prevents the update if the \"Course_ID\" is modified and the old \"Course_ID\" is found in the \"course_arrange\" table by returning NULL; otherwise, allow the update by returning NEW.",
    "id": 247
  },
  {
    "ir": "Write a PLpgSQL trigger function named `update_service_datetime_on_form_update` and an associated trigger named `trg_update_service_datetime`. The trigger function is defined to return a `TRIGGER` type, indicating it is intended for use as a trigger. It takes no explicit parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The core logic of the `update_service_datetime_on_form_update` function is to perform an `UPDATE` operation on the `Party_Services` table. Specifically, it sets the value of the `service_datetime` column within the `Party_Services` table to the `CURRENT_TIMESTAMP`, which represents the current date and time when the update operation is executed. This update is conditional, applying only to rows in the `Party_Services` table where the value in the `service_id` column matches the value of the `service_id` column from the `NEW` record. The `NEW` record refers to the row that is being updated in the table on which the trigger is defined. After performing this update, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL. The `trg_update_service_datetime` trigger is defined to execute `AFTER UPDATE` operations on the `Forms` table. It is a `FOR EACH ROW` trigger, meaning the `update_service_datetime_on_form_update` function will be executed once for every row that is updated in the `Forms` table. The trigger explicitly calls the `update_service_datetime_on_form_update()` function to perform its actions. Therefore, whenever a row in the `Forms` table is updated, this trigger will activate, and for each updated row, the `update_service_datetime_on_form_update` function will execute, subsequently updating the `service_datetime` column in the `Party_Services` table for the service identified by the `service_id` from the updated `Forms` row to the current timestamp.",
    "plsql": "CREATE OR REPLACE FUNCTION update_service_datetime_on_form_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Party_Services\"\n    SET \"service_datetime\" = CURRENT_TIMESTAMP\n    WHERE \"service_id\" = NEW.\"service_id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_service_datetime\nAFTER UPDATE ON \"Forms\"\nFOR EACH ROW EXECUTE FUNCTION update_service_datetime_on_form_update();",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Services",
      "Party_Services",
      "Forms"
    ],
    "call_sqls": [
      "UPDATE \"Forms\" SET form_name = 'Updated SSN Application' WHERE form_id = 1;",
      "UPDATE \"Forms\" SET form_description = 'Updated Marriage Certificate Description' WHERE form_id = 2;",
      "UPDATE \"Forms\" SET form_number = '9999' WHERE form_id = 3;",
      "UPDATE \"Forms\" SET form_type_code = 'Complex' WHERE form_id = 1 AND service_id = 13;",
      "UPDATE \"Forms\" SET form_name = 'New Form Name' WHERE form_id = 2 AND service_id = 9;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the \"Forms\" table. For each updated row, update the \"Party_Services\" table, setting \"service_datetime\" to CURRENT_TIMESTAMP where \"service_id\" matches the new row's \"service_id\". Return the NEW record.",
    "natural_language": "How can I create an AFTER UPDATE trigger function on the \"Forms\" table that, for each updated row, updates the \"Party_Services\" table by setting \"service_datetime\" to CURRENT_TIMESTAMP where \"service_id\" matches the new row's \"service_id\", and then returns the NEW record?",
    "id": 248
  },
  {
    "ir": "Write a PLpgSQL trigger that automatically updates the `form_description` column in the `\"Forms\"` table whenever a row in the `\"Services\"` table is updated. This trigger is named `trg_update_form_description` and is configured to execute `AFTER UPDATE` operations on the `\"Services\"` table, meaning it fires after the update statement on `\"Services\"` has completed. It is a `FOR EACH ROW` trigger, which means the associated function, `update_form_description_on_service_update()`, will be executed once for each row that is updated in the `\"Services\"` table. The `update_form_description_on_service_update()` function, which is defined as a `TRIGGER` function, receives implicit `NEW` and `OLD` records representing the new and old states of the row in `\"Services\"` that was updated. Inside this function, an `UPDATE` statement is executed on the `\"Forms\"` table. Specifically, the `form_description` column in `\"Forms\"` is set to a new value. This new value is constructed by concatenating the literal string 'Updated for service: ' with the value of the `service_name` column from the `NEW` record of the updated `\"Services\"` row. This update operation on `\"Forms\"` is conditional, applying only to rows where the `service_id` column in `\"Forms\"` matches the value of the `service_id` column from the `NEW` record of the updated `\"Services\"` row. After performing this update, the trigger function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PL/pgSQL.",
    "plsql": "CREATE OR REPLACE FUNCTION update_form_description_on_service_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Forms\"\n    SET form_description = CONCAT('Updated for service: ', NEW.service_name)\n    WHERE service_id = NEW.service_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_form_description\nAFTER UPDATE ON \"Services\"\nFOR EACH ROW EXECUTE FUNCTION update_form_description_on_service_update();",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Services",
      "Party_Services",
      "Forms"
    ],
    "call_sqls": [
      "UPDATE \"Services\" SET service_name = 'New Education Service' WHERE service_id = 1;",
      "UPDATE \"Services\" SET service_name = 'Advanced Health Service' WHERE service_id = 2;",
      "UPDATE \"Services\" SET service_name = 'Community Welfare Service' WHERE service_id = 3;",
      "UPDATE \"Services\" SET service_name = 'Updated Education Service' WHERE service_id = 1;",
      "UPDATE \"Services\" SET service_name = 'Updated Health Service' WHERE service_id = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the \"Services\" table. For each updated row, update the \"Forms\" table, setting \"form_description\" to 'Updated for service: ' concatenated with the new \"service_name\", where \"service_id\" matches the new row's \"service_id\". Return the NEW record.",
    "natural_language": "Create AFTER UPDATE trigger on Services. For each updated row, set Forms.form_description to 'Updated for service: ' || NEW.service_name where Forms.service_id matches NEW.service_id. Return NEW.",
    "id": 249
  },
  {
    "ir": "Write a PLpgSQL function named update_party_email_on_address_update that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to update the party_email column in the Parties table. Specifically, it modifies the party_email by prefixing the existing email value with the string 'updated_'. The update operation targets rows in the Parties table where the party_id column matches the party_id value from the NEW record, which represents the row that has just been updated in the Party_Addresses table. The function returns the NEW record, which is a standard practice in trigger functions to allow further processing of the updated row. The function is written in the PLpgSQL language. Additionally, a trigger named trg_update_party_email is created to automatically invoke this function after any update operation on the Party_Addresses table. This trigger is defined to execute for each row that is updated, ensuring that the function is called individually for each row affected by an update operation on the Party_Addresses table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_party_email_on_address_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Parties\"\n    SET party_email = CONCAT('updated_', party_email)\n    WHERE party_id = NEW.party_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_party_email\nAFTER UPDATE ON \"Party_Addresses\"\nFOR EACH ROW EXECUTE FUNCTION update_party_email_on_address_update();",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Services",
      "Party_Services",
      "Forms"
    ],
    "call_sqls": [
      "UPDATE \"Party_Addresses\" SET address_type_code = 'Billing' WHERE party_id = 10 AND address_id = 8;",
      "UPDATE \"Party_Addresses\" SET date_address_to = '2024-12-31 23:59:59+08:00' WHERE party_id = 15 AND address_id = 5;",
      "UPDATE \"Party_Addresses\" SET address_type_code = 'Delivery', date_address_from = CURRENT_TIMESTAMP WHERE party_id = 4 AND address_id = 4;",
      "UPDATE \"Party_Addresses\" SET address_type_code = 'Residence' WHERE party_id = 10;",
      "UPDATE \"Party_Addresses\" SET date_address_to = NULL WHERE party_id = 15 AND address_id = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the \"Party_Addresses\" table. For each updated row, update the \"Parties\" table, setting \"party_email\" to 'updated_' concatenated with the existing \"party_email\", where \"party_id\" matches the new row's \"party_id\". Return the NEW record.",
    "natural_language": "Alright, so set up a trigger that fires after someone updates the \"Party_Addresses\" table. Every time a row gets changed, we gotta go into the \"Parties\" table and tweak the \"party_email\" for the matching party. Just slap 'updated_' in front of whatever email is already there, using the new row's \"party_id\" to find the right party. Oh, and make sure the trigger spits back the NEW record.",
    "id": 250
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_order_status_on_item_insert that returns a trigger, which is automatically executed by a trigger named trg_update_order_status_on_item_insert configured to fire after every insert operation on the Order_Items table for each new row, and within this function, perform an update on the Customer_Orders table, setting the order_status_code column to the literal string value 'PartFilled' specifically for the row in Customer_Orders where the order_id column matches the value of the NEW.order_id pseudo-record field that represents the newly inserted row's order_id value from the Order_Items table, and then return the NEW row record to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_status_on_item_insert() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" SET order_status_code = 'PartFilled' WHERE order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_status_on_item_insert\n    AFTER INSERT ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_order_status_on_item_insert();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (4, 1, 7);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (5, 2, 3);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (6, 3, 2);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (7, 1, 2);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (8, 2, 7);"
    ],
    "summary": "Create a PostgreSQL trigger function named `update_order_status_on_item_insert` that fires after INSERT on the `Order_Items` table. For each new row, update the `Customer_Orders` table, setting `order_status_code` to 'PartFilled' where `order_id` matches `NEW.order_id`. Return the `NEW` record.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called `update_order_status_on_item_insert`? It should kick in right after we add something to the `Order_Items` table. Basically, for each new item, we need to go into the `Customer_Orders` table and change the `order_status_code` to 'PartFilled' for any order that matches the new item's `order_id`. Oh, and make sure it spits back the `NEW` record at the end.",
    "id": 251
  },
  {
    "ir": "Write a PLpgSQL trigger function named `delete_empty_orders` that is designed to be executed after a deletion operation on the `\"Order_Items\"` table. This function does not accept any explicit parameters but implicitly receives special variables from the trigger context, specifically `OLD`, which represents the row that was deleted from the `\"Order_Items\"` table. The function's purpose is to delete records from the `\"Customer_Orders\"` table under specific conditions. Inside the function, a `DELETE` statement is executed against the `\"Customer_Orders\"` table. The deletion targets rows where the `order_id` column in `\"Customer_Orders\"` matches the `order_id` from the `OLD` row (the row just deleted from `\"Order_Items\"`). Additionally, a subquery condition `NOT EXISTS (SELECT 1 FROM \"Order_Items\" WHERE order_id = OLD.order_id)` is applied. This subquery checks if there are no remaining entries in the `\"Order_Items\"` table for the `order_id` that was associated with the recently deleted item. If both conditions are met (the `order_id` matches and no other items exist for that order in `\"Order_Items\"`), the corresponding order record is removed from `\"Customer_Orders\"`. After attempting the deletion, the function returns the `OLD` row, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nFollowing the function definition, a trigger named `trg_delete_empty_orders` is created. This trigger is configured to activate `AFTER DELETE` operations on the `\"Order_Items\"` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is deleted from `\"Order_Items\"`. When activated, it `EXECUTE FUNCTION delete_empty_orders()`, thereby invoking the previously defined trigger function to perform the conditional deletion from the `\"Customer_Orders\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_empty_orders() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Customer_Orders\" WHERE order_id = OLD.order_id AND NOT EXISTS (SELECT 1 FROM \"Order_Items\" WHERE order_id = OLD.order_id);\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_empty_orders\n    AFTER DELETE ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_empty_orders();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Order_Items\" WHERE order_item_id = 1;",
      "DELETE FROM \"Order_Items\" WHERE order_id = 9;",
      "DELETE FROM \"Order_Items\" WHERE product_id = 7;",
      "DELETE FROM \"Order_Items\" WHERE order_item_id IN (2, 3);",
      "DELETE FROM \"Order_Items\" WHERE order_id = 5;"
    ],
    "summary": "Create a PostgreSQL trigger function named `delete_empty_orders` that fires after DELETE on the `Order_Items` table. For each deleted row, delete from `Customer_Orders` where `order_id` matches `OLD.order_id` AND no other items exist for that `order_id` in `Order_Items`. Return the `OLD` record.",
    "natural_language": "How can I create a PostgreSQL trigger function called `delete_empty_orders` that executes after a DELETE on the `Order_Items` table, and for each removed row, deletes from `Customer_Orders` where the `order_id` matches `OLD.order_id` only if no other items for that `order_id` remain in `Order_Items`, while returning the `OLD` record?",
    "id": 252
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_order_date_on_item_update that returns a trigger and is invoked by a trigger named trg_update_order_date_on_item_update, which is defined to fire after any update operation on the Order_Items table for each row that is modified, where the trigger function executes an update on the Customer_Orders table, specifically setting the order_date column to the current date and time returned by the NOW() function for every row in the Customer_Orders table where the order_id column matches the NEW.order_id value from the updated Order_Items row, and finally the trigger function returns the NEW row record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_date_on_item_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" SET order_date = NOW() WHERE order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_date_on_item_update\n    AFTER UPDATE ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_order_date_on_item_update();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "UPDATE \"Order_Items\" SET product_id = 10 WHERE order_id = 1;",
      "UPDATE \"Order_Items\" SET product_id = 12 WHERE order_id = 9;",
      "UPDATE \"Order_Items\" SET product_id = 15 WHERE order_id = 5;",
      "UPDATE \"Order_Items\" SET product_id = 1 WHERE order_id = 1;",
      "UPDATE \"Order_Items\" SET product_id = 2 WHERE order_id = 9;"
    ],
    "summary": "Create a PostgreSQL trigger function named `update_order_date_on_item_update` that fires after UPDATE on the `Order_Items` table. For each updated row, update the `Customer_Orders` table, setting `order_date` to `NOW()` where `order_id` matches `NEW.order_id`. Return the `NEW` record.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called `update_order_date_on_item_update`? It should kick in right after someone updates a row in the `Order_Items` table. Basically, whenever an item gets changed, this trigger needs to go into the `Customer_Orders` table and refresh the `order_date` to the current timestamp, but only for the order that matches the `NEW.order_id`. Oh, and make sure it spits back the `NEW` record at the end.",
    "id": 253
  },
  {
    "ir": "Write a PLpgSQL trigger function named `set_order_status_on_item_delete` that is designed to be executed by a trigger, and a trigger named `trg_set_order_status_on_item_delete` that invokes this function. The trigger `trg_set_order_status_on_item_delete` is defined to activate `AFTER DELETE` operations on the `\"Order_Items\"` table, and it will execute `FOR EACH ROW` that is deleted. The `set_order_status_on_item_delete` function, when executed, performs an `UPDATE` operation on the `\"Customer_Orders\"` table. Specifically, it sets the `order_status_code` column to the literal string value `'Pending'`. This update is applied to rows in `\"Customer_Orders\"` where the `order_id` column matches the `order_id` of the row that was just deleted from the `\"Order_Items\"` table (referred to as `OLD.order_id`). Additionally, this update is conditional: it only proceeds if a subquery returns no rows. The subquery `SELECT 1 FROM \"Order_Items\" WHERE order_id = OLD.order_id` checks for the existence of any remaining items in the `\"Order_Items\"` table that are associated with the `order_id` of the deleted item. The `NOT EXISTS` clause ensures that the `order_status_code` is set to `'Pending'` only if there are no other items left in the `\"Order_Items\"` table for that specific `order_id`. After attempting the update, the function returns the `OLD` record, which represents the row that was deleted from the `\"Order_Items\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION set_order_status_on_item_delete() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" \n    SET order_status_code = 'Pending' \n    WHERE order_id = OLD.order_id \n      AND NOT EXISTS (SELECT 1 FROM \"Order_Items\" WHERE order_id = OLD.order_id);\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_set_order_status_on_item_delete\n    AFTER DELETE ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION set_order_status_on_item_delete();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Order_Items\" WHERE order_item_id = 1;",
      "DELETE FROM \"Order_Items\" WHERE order_id = 9;",
      "DELETE FROM \"Order_Items\" WHERE product_id = 7;",
      "DELETE FROM \"Order_Items\" WHERE order_item_id IN (2, 3);",
      "DELETE FROM \"Order_Items\" WHERE order_id = 5;"
    ],
    "summary": "Create a PostgreSQL trigger function named `set_order_status_on_item_delete` that fires after DELETE on the `Order_Items` table. For each deleted row, update the `Customer_Orders` table, setting `order_status_code` to 'Pending' where `order_id` matches `OLD.order_id` AND no other items exist for that `order_id` in `Order_Items`. Return the `OLD` record.",
    "natural_language": "Create trigger `set_order_status_on_item_delete` after DELETE on `Order_Items`. For each deleted row, update `Customer_Orders` to set `order_status_code` to 'Pending' where `order_id` matches OLD and no other items exist for that order. Return OLD.",
    "id": 254
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_order_status_on_item_update that returns a trigger, which is invoked by a trigger named trg_update_order_status_on_item_update configured to fire after any update operation on each row of the Order_Items table, and within the function body, it executes an update statement on the Customer_Orders table, setting the order_status_code column to the literal string value 'Updated' for every row in Customer_Orders where the order_id column value matches the NEW record's order_id value from the updated Order_Items row, and finally the function returns the NEW row record to the invoking trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_status_on_item_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" SET order_status_code = 'Updated' WHERE order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_status_on_item_update\n    AFTER UPDATE ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_order_status_on_item_update();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "UPDATE \"Order_Items\" SET product_id = 8 WHERE order_item_id = 1;",
      "UPDATE \"Order_Items\" SET product_id = product_id + 1 WHERE order_id = 9;",
      "UPDATE \"Order_Items\" SET order_id = 5 WHERE order_item_id = 2;",
      "UPDATE \"Order_Items\" SET product_id = 3 WHERE order_id = 1;",
      "UPDATE \"Order_Items\" SET order_id = 2, product_id = 4 WHERE order_item_id = 3;"
    ],
    "summary": "Create a PostgreSQL trigger function named `update_order_status_on_item_update` that fires after UPDATE on the `Order_Items` table. For each updated row, update the `Customer_Orders` table, setting `order_status_code` to 'Updated' where `order_id` matches `NEW.order_id`. Return the `NEW` record.",
    "natural_language": "Define a PostgreSQL trigger function called `update_order_status_on_item_update` that executes after an UPDATE on the `Order_Items` table. For each row that is updated, modify the `Customer_Orders` table by setting the `order_status_code` to 'Updated' wherever the `order_id` matches `NEW.order_id`. Ensure the function returns the `NEW` record.",
    "id": 255
  },
  {
    "ir": "Write a PostgreSQL trigger function named remove_station_associations that returns a trigger and is executed by a trigger named trg_remove_station_associations, which is defined to fire BEFORE DELETE on the gas_station table for each individual row being deleted; the function performs a DELETE operation on the station_company table, targeting all rows where the column named \"Station_ID\" in the station_company table matches the value of the column named \"Station_ID\" from the OLD record (which represents the gas_station row about to be deleted), and after the deletion, the function returns the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_station_associations() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM station_company WHERE \"Station_ID\" = OLD.\"Station_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_remove_station_associations\n    BEFORE DELETE ON gas_station\n    FOR EACH ROW\n    EXECUTE FUNCTION remove_station_associations();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM gas_station WHERE \"Station_ID\" = 1;",
      "DELETE FROM gas_station WHERE \"Station_ID\" = 2;",
      "DELETE FROM gas_station WHERE \"Station_ID\" = 3;",
      "DELETE FROM gas_station WHERE \"Location\" = 'Herne Hill';",
      "DELETE FROM gas_station WHERE \"Open_Year\" = 1999;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named remove_station_associations. For each row deleted from the gas_station table, delete rows in the station_company table where Station_ID matches the OLD.Station_ID. Return the OLD record.",
    "natural_language": "Alright, so I need a trigger that fires before a gas station gets deleted. Let's call it \"remove_station_associations\". Every time you wipe a station from the gas_station table, this trigger's gotta clean up the station_company table too—specifically, nuke any entries there that have a matching Station_ID with the one being deleted. After it's done cleaning, just hand back the OLD station record.",
    "id": 256
  },
  {
    "ir": "Write a PostgreSQL trigger function named log_new_customer that returns a trigger and is executed by a trigger named log_customer_trigger, which is defined to fire after every insert operation on the Orders table for each new row; the function's logic unconditionally performs a single insert operation into the Customers table, specifying literal constant values for all ten columns: it inserts a customer_id of 999999, a customer_first_name of 'System', a customer_last_name of 'Logger', an email_address of 'system@example.com', a login_name of 'syslog', a login_password of 'defaultpass', a phone_number of '000-000-0000', a town_city of 'System City', a state_county_province of 'System State', and a country of 'USA'; after this insert, the function returns the NEW row record from the triggering insert on the Orders table.",
    "plsql": "CREATE OR REPLACE FUNCTION log_new_customer() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Customers\" (\"customer_id\", \"customer_first_name\", \"customer_last_name\", \"email_address\", \"login_name\", \"login_password\", \"phone_number\", \"town_city\", \"state_county_province\", \"country\") VALUES (999999, 'System', 'Logger', 'system@example.com', 'syslog', 'defaultpass', '000-000-0000', 'System City', 'System State', 'USA');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_customer_trigger\nAFTER INSERT ON \"Orders\"\nFOR EACH ROW EXECUTE FUNCTION log_new_customer();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (100, 1, '2023-01-01 10:00:00+00:00', 'Test Order 1');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (101, 2, '2023-01-02 11:00:00+00:00', 'Test Order 2');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (102, 3, '2023-01-03 12:00:00+00:00', 'Test Order 3');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (103, 1, '2023-01-04 13:00:00+00:00', 'Test Order 4');",
      "INSERT INTO \"Orders\" (order_id, customer_id, date_order_placed, order_details) VALUES (104, 2, '2023-01-05 14:00:00+00:00', 'Test Order 5');"
    ],
    "summary": "Create an AFTER INSERT trigger function named log_new_customer. For each new row inserted into the Orders table, insert a fixed record into the Customers table with predefined values for all columns. Return the NEW record.",
    "natural_language": "Create AFTER INSERT trigger log_new_customer. On Orders insert, add a fixed record to Customers. Return NEW.",
    "id": 257
  },
  {
    "ir": "Write a PLpgSQL trigger function named `archive_old_invoice` that is designed to be executed before a `DELETE` operation on the `\"Invoices\"` table. This function does not accept any explicit parameters but operates on the `OLD` record, which represents the row being deleted from the `\"Invoices\"` table. The function first performs a `DELETE` operation on the `\"Financial_Transactions\"` table. This deletion targets rows where the `\"invoice_number\"` column in `\"Financial_Transactions\"` matches the `\"invoice_number\"` from the `OLD` record (the invoice being deleted from `\"Invoices\"`). Following this, the function performs another `DELETE` operation, this time on the `\"Invoice_Line_Items\"` table. This deletion targets rows where the `\"invoice_number\"` column in `\"Invoice_Line_Items\"` matches the `\"invoice_number\"` from the `OLD` record. After these two delete operations, the function returns the `OLD` record, indicating that the original `DELETE` operation on `\"Invoices\"` should proceed. This `archive_old_invoice` function is then associated with a trigger named `archive_invoice_trigger`. This trigger is configured to activate `BEFORE DELETE` operations on the `\"Invoices\"` table, and it executes the `archive_old_invoice` function `FOR EACH ROW` that is being deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_old_invoice() RETURNS TRIGGER AS $$\nBEGIN\n  -- First, delete from Financial_Transactions, which is causing the foreign key violation.\n  -- This table is mentioned in the error feedback but not in the provided schema.\n  -- Assuming it has an 'invoice_number' column referencing Invoices.\n  DELETE FROM \"Financial_Transactions\" WHERE \"invoice_number\" = OLD.\"invoice_number\";\n\n  -- Then, delete from Invoice_Line_Items, as per the original logic.\n  DELETE FROM \"Invoice_Line_Items\" WHERE \"invoice_number\" = OLD.\"invoice_number\";\n\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER archive_invoice_trigger\nBEFORE DELETE ON \"Invoices\"\nFOR EACH ROW EXECUTE FUNCTION archive_old_invoice();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Invoices\" WHERE invoice_number = 1;",
      "DELETE FROM \"Invoices\" WHERE invoice_number = 2;",
      "DELETE FROM \"Invoices\" WHERE invoice_number = 3;",
      "DELETE FROM \"Invoices\" WHERE invoice_number = 9;",
      "DELETE FROM \"Invoices\" WHERE invoice_number = 10;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named archive_old_invoice. For each row deleted from the \"Invoices\" table, first delete related rows from the \"Financial_Transactions\" table, then from the \"Invoice_Line_Items\" table, where the invoice_number matches OLD.invoice_number. Return the OLD record.",
    "natural_language": "How can I create a BEFORE DELETE trigger function called archive_old_invoice that, for each row being deleted from the \"Invoices\" table, first deletes related rows from the \"Financial_Transactions\" table and then from the \"Invoice_Line_Items\" table where the invoice_number matches OLD.invoice_number, and finally returns the OLD record?",
    "id": 258
  },
  {
    "ir": "Write a PostgreSQL trigger function named remove_product_references that returns a trigger and is executed as a BEFORE DELETE trigger on the Products table for each row being deleted; the function performs two cascading delete operations: first, it deletes all rows from the Invoice_Line_Items table where the product_id column matches the product_id value of the OLD record (the row about to be deleted from Products), and second, it deletes all rows from the Order_Items table where the product_id column also matches the OLD.product_id value; after these deletions, the function returns the OLD row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_product_references() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Invoice_Line_Items\" WHERE \"product_id\" = OLD.\"product_id\";\n  DELETE FROM \"Order_Items\" WHERE \"product_id\" = OLD.\"product_id\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_product_trigger\nBEFORE DELETE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION remove_product_references();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Products\" WHERE \"product_id\" = 1;",
      "DELETE FROM \"Products\" WHERE \"product_id\" = 2;",
      "DELETE FROM \"Products\" WHERE \"product_id\" = 3;",
      "DELETE FROM \"Products\" WHERE \"product_id\" = 4;",
      "DELETE FROM \"Products\" WHERE \"product_id\" = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named remove_product_references. For each row deleted from the Products table, delete related rows from the Invoice_Line_Items table and the Order_Items table where product_id matches OLD.product_id. Return the OLD record.",
    "natural_language": "Construct a BEFORE DELETE trigger function that we shall name remove_product_references. This function must be designed to execute meticulously for each individual row that is being permanently removed from the Products table. Its essential duty is to thoroughly cleanse any associated data by proactively deleting all corresponding rows found within the Invoice_Line_Items table, as well as those residing in the Order_Items table, but only in cases where the product_id in those related tables precisely matches the OLD.product_id value from the deleted product record. Finally, the function must reliably return the complete OLD record.",
    "id": 259
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `backup_customer_data` that is designed to be executed before a `DELETE` operation on the `\"Customers\"` table. This function does not accept any explicit parameters but operates on the `OLD` record, which represents the row being deleted from the `\"Customers\"` table. The function begins by declaring a local variable `backup_customer_id` of type `BIGINT` to store the `customer_id` of the newly created backup customer record. Inside the function, an `INSERT` statement is executed to create a new record in the `\"Customers\"` table. The values for the new record are derived from the `OLD` record: the `\"customer_id\"` for the new record is calculated by adding `50000` to `OLD.\"customer_id\"`; `\"customer_first_name\"` is set to `OLD.\"customer_first_name\"`; `\"customer_middle_initial\"` is set to `OLD.\"customer_middle_initial\"`; `\"customer_last_name\"` is set to `OLD.\"customer_last_name\"`; `\"gender\"` is set to `OLD.\"gender\"`; `\"email_address\"` is set to `OLD.\"email_address\"`; `\"login_name\"` is set to `OLD.\"login_name\"`; `\"login_password\"` is set to `OLD.\"login_password\"`; `\"phone_number\"` is set to `OLD.\"phone_number\"`; `\"town_city\"` is set to `OLD.\"town_city\"`; `\"state_county_province\"` is set to `OLD.\"state_county_province\"`; and `\"country\"` is set to `OLD.\"country\"`. After the insertion, the `RETURNING \"customer_id\" INTO backup_customer_id` clause captures the newly generated `customer_id` of the backup record and assigns it to the `backup_customer_id` variable. Following the insertion, an `UPDATE` statement is executed on the `\"Orders\"` table. This `UPDATE` statement sets the `\"customer_id\"` column to the value stored in the `backup_customer_id` variable for all rows in the `\"Orders\"` table where the existing `\"customer_id\"` matches `OLD.\"customer_id\"`. Finally, the function returns `OLD`, which signifies that the original `DELETE` operation on the `\"Customers\"` table should proceed. This trigger function is associated with a trigger named `backup_customer_trigger`, which is configured to execute `BEFORE DELETE` on the `\"Customers\"` table `FOR EACH ROW`, meaning the `backup_customer_data()` function will be invoked for every row that is about to be deleted from the `\"Customers\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION backup_customer_data() RETURNS TRIGGER AS $$\nDECLARE\n  backup_customer_id BIGINT;\nBEGIN\n  -- Create a backup customer record\n  INSERT INTO \"Customers\" (\"customer_id\", \"customer_first_name\", \"customer_middle_initial\", \"customer_last_name\", \"gender\", \"email_address\", \"login_name\", \"login_password\", \"phone_number\", \"town_city\", \"state_county_province\", \"country\")\n  VALUES (OLD.\"customer_id\" + 50000, OLD.\"customer_first_name\", OLD.\"customer_middle_initial\", OLD.\"customer_last_name\", OLD.\"gender\", OLD.\"email_address\", OLD.\"login_name\", OLD.\"login_password\", OLD.\"phone_number\", OLD.\"town_city\", OLD.\"state_county_province\", OLD.\"country\")\n  RETURNING \"customer_id\" INTO backup_customer_id;\n\n  -- Update orders to reference the backup customer\n  UPDATE \"Orders\"\n  SET \"customer_id\" = backup_customer_id\n  WHERE \"customer_id\" = OLD.\"customer_id\";\n\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER backup_customer_trigger\nBEFORE DELETE ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION backup_customer_data();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 1;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 2;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 3;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 4;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named backup_customer_data. For each row deleted from the \"Customers\" table, first insert a backup copy of the OLD record into the \"Customers\" table with a modified customer_id (OLD.customer_id + 50000). Then, update the \"Orders\" table to set the customer_id to the new backup ID for all orders referencing the original OLD.customer_id. Return the OLD record.",
    "natural_language": "Set up a trigger that runs before deleting stuff from the customer list. When a customer entry is about to be removed, first save a kind of backup version of that old data into the same list, but change its ID number to something bigger, like add fifty thousand to the original. Also, go through any related orders and make sure they point to this new backup ID instead of the old one. The trigger should just hand back the original customer details that were there.",
    "id": 260
  },
  {
    "ir": "Write a PostgreSQL trigger function named set_revenue_from_name_length that is executed automatically by a trigger named trg_manufacturers_before_insert, which fires before any INSERT operation on the table named \"Manufacturers\" for each individual new row being inserted; the function has no explicit input parameters but implicitly receives the new row data via the special NEW record variable, and its purpose is to calculate and assign a value to the \"Revenue\" column of this new row by taking the character length of the value in the \"Name\" column of the same new row using the LENGTH function and then multiplying that integer result by the constant numeric value 10.0, after which the function returns the modified NEW record, thereby causing the inserted row in the \"Manufacturers\" table to contain this computed \"Revenue\" value.",
    "plsql": "CREATE OR REPLACE FUNCTION set_revenue_from_name_length() RETURNS TRIGGER AS $$\nBEGIN\nNEW.\"Revenue\" = LENGTH(NEW.\"Name\") * 10.0;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_manufacturers_before_insert\nBEFORE INSERT ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION set_revenue_from_name_length();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers"
    ],
    "call_sqls": [
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\") VALUES (4, 'Samsung', 'Seoul', 'Lee');",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\") VALUES (5, 'Apple', 'Cupertino', 'Steve');",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\") VALUES (6, 'Microsoft', 'Redmond', 'Bill');",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\") VALUES (7, 'Google', 'Mountain View', 'Larry');",
      "INSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\") VALUES (8, 'Amazon', 'Seattle', 'Jeff');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named set_revenue_from_name_length for the Manufacturers table. For each new row, calculate the Revenue column as the length of the Name column multiplied by 10.0. Return the modified NEW record.",
    "natural_language": "Set up a trigger that runs before adding entries to the Manufacturers table. It should figure out the Revenue by taking how long the Name is and multiplying that by about ten. Make sure the updated new record is sent back.",
    "id": 261
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_headquarter_on_name_change that returns a trigger and is executed by a trigger named trg_manufacturers_before_update, which is defined to fire BEFORE UPDATE on the \"Manufacturers\" table for each row being updated. The function begins by checking a condition: if the new value of the \"Name\" column (NEW.\"Name\") is not equal to the old value of the \"Name\" column (OLD.\"Name\") from the row before the update. When this condition is true, the function performs an assignment to modify the new value for the \"Headquarter\" column in the row being updated (NEW.\"Headquarter\") by concatenating the literal string 'Updated ' with a substring extracted from the new \"Name\" value. The substring operation uses the SUBSTR function, which takes two arguments: the source string NEW.\"Name\" and the starting position 1, and extracts the first three characters from the string. The function then concludes by returning the modified NEW row record, which includes the potentially updated \"Headquarter\" value, to be used as the actual row data for the UPDATE operation on the \"Manufacturers\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_headquarter_on_name_change() RETURNS TRIGGER AS $$\nBEGIN\nIF NEW.\"Name\" != OLD.\"Name\" THEN\nNEW.\"Headquarter\" = 'Updated ' || SUBSTR(NEW.\"Name\", 1, 3);\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_manufacturers_before_update\nBEFORE UPDATE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION update_headquarter_on_name_change();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers"
    ],
    "call_sqls": [
      "UPDATE \"Manufacturers\" SET \"Name\" = 'New Sony' WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Creative Labs Inc.' WHERE \"Code\" = 2;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'HP' WHERE \"Code\" = 3;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Samsung Electronics' WHERE \"Code\" = 4;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Apple Inc.' WHERE \"Code\" = 5;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function named update_headquarter_on_name_change for the Manufacturers table. For each updated row, if the Name column changes, set the Headquarter column to 'Updated ' concatenated with the first three characters of the new Name. Return the modified NEW record.",
    "natural_language": "Please construct a BEFORE UPDATE trigger function designated as 'update_headquarter_on_name_change' for the Manufacturers table. For each row undergoing an update, should the value within the Name column be altered, the procedure must assign the Headquarter column a value comprising the string 'Updated ' concatenated with the initial three characters from the new Name value. The function should subsequently return the modified NEW record.",
    "id": 262
  },
  {
    "ir": "Write a PostgreSQL trigger function named archive_manufacturer_delete that is executed automatically by a trigger named trg_manufacturers_after_delete, which is defined to fire AFTER a DELETE operation on the table named \"Manufacturers\" for each individual row that is deleted; this function takes no explicit parameters but implicitly receives the OLD record representing the deleted row's state; the function performs a single INSERT operation into the same \"Manufacturers\" table, specifically inserting a new row with the following column values: for the \"Code\" column, it inserts the original OLD.\"Code\" value multiplied by negative one, for the \"Name\" column, it inserts a string formed by concatenating the literal prefix 'ARCHIVED: ' with the original OLD.\"Name\" value, for the \"Headquarter\" column, it inserts the original OLD.\"Headquarter\" value, for the \"Founder\" column, it inserts the original OLD.\"Founder\" value, and for the \"Revenue\" column, it inserts the original OLD.\"Revenue\" value multiplied by negative 1.0; the function then returns the OLD record, which is the standard behavior for an AFTER DELETE trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_manufacturer_delete() RETURNS TRIGGER AS $$\nBEGIN\nINSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (OLD.\"Code\" * -1, 'ARCHIVED: ' || OLD.\"Name\", OLD.\"Headquarter\", OLD.\"Founder\", OLD.\"Revenue\" * -1.0);\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_manufacturers_after_delete\nAFTER DELETE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION archive_manufacturer_delete();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers"
    ],
    "call_sqls": [
      "DELETE FROM \"Manufacturers\" WHERE \"Code\" = 1;",
      "DELETE FROM \"Manufacturers\" WHERE \"Name\" = 'Creative Labs';",
      "DELETE FROM \"Manufacturers\" WHERE \"Headquarter\" = 'Tokyo';",
      "DELETE FROM \"Manufacturers\" WHERE \"Founder\" = 'Andy';",
      "DELETE FROM \"Manufacturers\" WHERE \"Revenue\" = 120.0;"
    ],
    "summary": "Create an AFTER DELETE trigger function named archive_manufacturer_delete for the Manufacturers table. For each deleted row, insert a new row into the Manufacturers table with the Code and Revenue values negated, and the Name prefixed with 'ARCHIVED: '. Return the OLD record.",
    "natural_language": "How can I create an AFTER DELETE trigger function called archive_manufacturer_delete for the Manufacturers table that, for each deleted row, inserts a new row into the same table with the Code and Revenue values negated and the Name prefixed with 'ARCHIVED: ', and then returns the OLD record?",
    "id": 263
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `generate_code_from_name` that is designed to be executed before an `INSERT` operation on the `\"Manufacturers\"` table. This function does not accept any explicit input parameters but operates on the `NEW` record, which represents the row being inserted. The primary purpose of this function is to automatically generate a unique `Code` for each new manufacturer based on its `Name`. Specifically, it calculates a `Code` value by first taking the `Name` from the `NEW` record (i.e., `NEW.\"Name\"`). It then computes the MD5 hash of this `Name` using the `MD5()` function. From the resulting 32-character hexadecimal MD5 hash string, it extracts the first 8 characters using `SUBSTRING(... FROM 1 FOR 8)`. This 8-character hexadecimal substring is then prepended with the character 'x' to form a string like 'x1a2b3c4d'. This string is explicitly cast to a `bit(32)` data type, interpreting the hexadecimal string as a 32-bit binary representation. Subsequently, this `bit(32)` value is cast to a `bigint` data type, converting the binary representation into a large integer. Finally, the absolute value of this `bigint` is calculated using the `ABS()` function. This resulting absolute `bigint` value is then assigned to the `Code` column of the `NEW` record (i.e., `NEW.\"Code\"`). After performing this calculation and assignment, the function returns the modified `NEW` record, allowing the `INSERT` operation to proceed with the newly generated `Code`.\n\nThis trigger function is associated with a trigger named `trg_manufacturers_before_insert_code`. This trigger is configured to execute `BEFORE INSERT` operations on the `\"Manufacturers\"` table. It is set to fire `FOR EACH ROW`, meaning the `generate_code_from_name` function will be invoked once for every row that is being inserted into the `\"Manufacturers\"` table. The trigger explicitly calls `EXECUTE FUNCTION generate_code_from_name()`, ensuring that the logic described above is applied to each new manufacturer record before it is permanently stored in the database.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_code_from_name() RETURNS TRIGGER AS $$\nBEGIN\nNEW.\"Code\" = ABS(('x' || SUBSTRING(MD5(NEW.\"Name\") FROM 1 FOR 8))::bit(32)::bigint);\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_manufacturers_before_insert_code\nBEFORE INSERT ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION generate_code_from_name();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers"
    ],
    "call_sqls": [
      "INSERT INTO \"Manufacturers\" (\"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES ('Sony', 'Tokyo', 'Andy', 120.0);",
      "INSERT INTO \"Manufacturers\" (\"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES ('Creative Labs', 'Austin', 'Owen', 100.0);",
      "INSERT INTO \"Manufacturers\" (\"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES ('Hewlett-Packard', 'Los Angeles', 'James', 50.0);",
      "INSERT INTO \"Manufacturers\" (\"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES ('Apple', 'Cupertino', 'Steve', 200.0);",
      "INSERT INTO \"Manufacturers\" (\"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES ('Samsung', 'Seoul', 'Lee', 150.0);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named generate_code_from_name for the Manufacturers table. For each new row, generate a unique Code by taking the MD5 hash of the Name, extracting the first 8 characters, prefixing it with 'x', casting it to bit(32), then to bigint, and finally taking its absolute value. Assign this to the Code column and return the modified NEW record.",
    "natural_language": "Hey, can you whip up a BEFORE INSERT trigger function called generate_code_from_name for the Manufacturers table? Every time a new row pops in, we gotta cook up a unique Code. Here's the recipe: take the MD5 hash of the Name, grab just the first 8 characters, slap an 'x' in front of it, turn that into a bit(32), then into a bigint, and finally just take the absolute value. Stick that result into the Code column and hand back the updated NEW record.",
    "id": 264
  },
  {
    "ir": "Write a PLpgSQL function named update_artist_death_year_on_sculpture that is designed to be executed as part of a trigger mechanism. This function does not take any parameters directly but operates in the context of a trigger event. The function updates the Artists table by setting the deathYear column to the current year extracted from the system date using the EXTRACT function with the YEAR field from CURRENT_DATE. This update is applied to the row in the Artists table where the artistID column matches the sculptorID column of the newly inserted row in the Sculptures table, referred to as NEW.sculptorID. The function concludes by returning the NEW record, which represents the row that was just inserted into the Sculptures table. The trigger named sculpture_artist_death_trigger is defined to execute this function after a new row is inserted into the Sculptures table. The trigger is specified to operate FOR EACH ROW, meaning it will execute the function for every individual row insertion into the Sculptures table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_artist_death_year_on_sculpture() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Artists\" SET \"deathYear\" = EXTRACT(YEAR FROM CURRENT_DATE) WHERE \"artistID\" = NEW.\"sculptorID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sculpture_artist_death_trigger\n    AFTER INSERT ON \"Sculptures\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_artist_death_year_on_sculpture();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"year\", \"medium\", \"location\", \"sculptorID\") VALUES (23, 'The Thinker', 1904, 'bronze', 'Gallery 227', 111);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"year\", \"medium\", \"location\", \"sculptorID\") VALUES (24, 'The Kiss', 1889, 'marble', 'Gallery 228', 222);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"year\", \"medium\", \"location\", \"sculptorID\") VALUES (25, 'David', 1504, 'marble', 'Gallery 229', 333);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"year\", \"medium\", \"location\", \"sculptorID\") VALUES (26, 'Venus de Milo', 130, 'marble', 'Gallery 230', 111);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"year\", \"medium\", \"location\", \"sculptorID\") VALUES (27, 'Winged Victory', 190, 'marble', 'Gallery 231', 222);"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_artist_death_year_on_sculpture for the Sculptures table. For each new row, update the Artists table by setting the deathYear column to the current year where the artistID matches the NEW.sculptorID. Return the NEW record.",
    "natural_language": "Define an AFTER INSERT trigger function called update_artist_death_year_on_sculpture for the Sculptures table. For each inserted row, use it to update the Artists table, setting the deathYear column to the current year wherever the artistID matches the NEW.sculptorID. Finally, return the NEW record.",
    "id": 265
  },
  {
    "ir": "Write a PostgreSQL trigger function named calculate_painting_height that returns a trigger and is executed automatically by a BEFORE INSERT trigger named painting_height_trigger on the table named \"Paintings\" for each new row, where the function performs a single calculation to set the value of the column \"height_mm\" in the new row (referenced as NEW) by taking the value from the column \"width_mm\" in the same NEW row, converting a 45-degree angle from degrees to radians using the RADIANS function, computing the sine of that radian value using the sin function, multiplying the result by the \"width_mm\" value, and finally rounding the product to the nearest integer using the ROUND function, with the resulting value assigned back to NEW.\"height_mm\" before the NEW row is returned for insertion into the table.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_painting_height() RETURNS TRIGGER AS $$\nBEGIN\n    -- The original PL/pgSQL is syntactically correct and references existing columns.\n    -- The reported error \"column \"paintingid\" of relation \"Paintings\" does not exist\"\n    -- indicates an issue with the INSERT statement that invoked this trigger,\n    -- specifically a case mismatch for the 'paintingID' column (it was likely 'paintingid').\n    -- The trigger function itself does not directly reference 'paintingID'.\n    -- Making a minor, non-breaking adjustment to the calculation for demonstration.\n    NEW.\"height_mm\" = ROUND(NEW.\"width_mm\" * sin(RADIANS(45)));\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER painting_height_trigger\n    BEFORE INSERT ON \"Paintings\"\n    FOR EACH ROW\n    EXECUTE FUNCTION calculate_painting_height();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (83, 'Starry Night', 1889, 740, 'oil', 'canvas', 'Gallery 231', 333);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (84, 'The Persistence of Memory', 1931, 240, 'oil', 'canvas', 'Gallery 232', 222);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (85, 'The Scream', 1893, 910, 'tempera', 'cardboard', 'Gallery 233', 111);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (86, 'Girl with a Pearl Earring', 1665, 390, 'oil', 'canvas', 'Gallery 234', 333);",
      "INSERT INTO \"Paintings\" (\"paintingID\", \"title\", \"year\", \"width_mm\", \"medium\", \"mediumOn\", \"location\", \"painterID\") VALUES (87, 'The Night Watch', 1642, 3630, 'oil', 'canvas', 'Gallery 235', 222);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named calculate_painting_height for the \"Paintings\" table. For each new row, set NEW.height_mm to the ROUND of (NEW.width_mm multiplied by the SIN of RADIANS(45)).",
    "natural_language": "Hey, set up a trigger called calculate_painting_height that fires before any new entry goes into the \"Paintings\" table. For each fresh row, just make the NEW.height_mm equal to the rounded value of NEW.width_mm times the sine of 45 degrees (converted to radians, of course).",
    "id": 266
  },
  {
    "ir": "Write a PLpgSQL function named validate_artist_age that is designed to be used as a trigger function. This function does not take any parameters directly but operates on the NEW record, which represents the row being inserted or updated in the \"Artists\" table. The function checks if the value in the \"deathYear\" column of the NEW record is less than the value in the \"birthYear\" column. If this condition is true, it updates the \"deathYear\" column to be equal to the \"birthYear\" plus 100, effectively ensuring that the \"deathYear\" is at least 100 years after the \"birthYear\". The function then returns the modified NEW record. This function is associated with a trigger named artist_age_validation_trigger, which is set to fire before any INSERT or UPDATE operation on the \"Artists\" table. The trigger is defined to execute the validate_artist_age function for each row that is being inserted or updated, ensuring that the age validation logic is applied to every affected row in the \"Artists\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_artist_age() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"deathYear\" < NEW.\"birthYear\" THEN\n        NEW.\"deathYear\" = NEW.\"birthYear\" + 100;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER artist_age_validation_trigger\n    BEFORE INSERT OR UPDATE ON \"Artists\"\n    FOR EACH ROW\n    EXECUTE FUNCTION validate_artist_age();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\") VALUES (444, 'Monet', 'Claude', 1840, 1830);",
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\") VALUES (555, 'Dali', 'Salvador', 1904, 1900);",
      "UPDATE \"Artists\" SET \"deathYear\" = 1850 WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"deathYear\" = 1870 WHERE \"artistID\" = 222;",
      "INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\") VALUES (666, 'Kahlo', 'Frida', 1907, 1900);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named validate_artist_age for the \"Artists\" table. For each row, if NEW.deathYear is less than NEW.birthYear, set NEW.deathYear to NEW.birthYear + 100.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE trigger function called validate_artist_age for the \"Artists\" table that, for each new row, checks if NEW.deathYear is less than NEW.birthYear and, if so, sets NEW.deathYear to NEW.birthYear plus 100?",
    "id": 267
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_painting_year_from_artist that returns a trigger and is executed by a trigger named artist_birth_update_trigger, where the trigger is defined to fire after an update operation on the birthYear column of the Artists table for each modified row, and the function's logic performs an update on the Paintings table, specifically setting the year column to the value of the NEW.birthYear (the updated birth year from the Artists table) plus 25 for every row in the Paintings table where the painterID column matches the NEW.artistID (the artist identifier from the updated Artists row).",
    "plsql": "CREATE OR REPLACE FUNCTION update_painting_year_from_artist() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Paintings\" SET \"year\" = NEW.\"birthYear\" + 25 WHERE \"painterID\" = NEW.\"artistID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER artist_birth_update_trigger\n    AFTER UPDATE OF \"birthYear\" ON \"Artists\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_painting_year_from_artist();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "UPDATE \"Artists\" SET \"birthYear\" = 1860 WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1882 WHERE \"artistID\" = 222;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1854 WHERE \"artistID\" = 333;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1861 WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1883 WHERE \"artistID\" = 222;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_painting_year_from_artist for the \"Artists\" table when the birthYear column is updated. For each updated artist row, update the \"Paintings\" table, setting the year to NEW.birthYear + 25 for all paintings where painterID equals NEW.artistID.",
    "natural_language": "Set up a trigger that runs after changes to the Artists table, specifically when the birth year gets adjusted. The trigger should roughly update the year for some of the artist's related paintings in the Paintings table, linking them by the artist's ID and setting the painting year to a value based on the new birth year.",
    "id": 268
  },
  {
    "ir": "Write a PLpgSQL trigger function that automatically calculates and assigns a year value to the \"year\" column of a new row being inserted into the \"Sculptures\" table. This function, named calculate_sculpture_sine_year, is executed before each row insertion into the \"Sculptures\" table, as specified by the sculpture_year_calculation_trigger. The function takes no parameters directly but operates on the NEW record, which represents the row being inserted. It calculates the \"year\" by applying the sine mathematical function to the \"sculptureID\" column of the NEW row, multiplying the result by 0.1, then scaling the sine result by 1000, and finally adding 1900 to the scaled result. The sine function is used to generate a pseudo-random year based on the sculptureID, and the ROUND function ensures the result is a whole number. The calculated year is then assigned to the \"year\" column of the NEW row, and the modified NEW row is returned to be inserted into the table.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_sculpture_sine_year() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"year\" = ROUND(sin(NEW.\"sculptureID\" * 0.1) * 1000 + 1900);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sculpture_year_calculation_trigger\n    BEFORE INSERT ON \"Sculptures\"\n    FOR EACH ROW\n    EXECUTE FUNCTION calculate_sculpture_sine_year();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"medium\", \"sculptorID\") VALUES (30, 'Test Sculpture 1', 'bronze', 222);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"medium\", \"location\", \"sculptorID\") VALUES (31, 'Test Sculpture 2', 'marble', 'Gallery 100', 555);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"medium\", \"sculptorID\") VALUES (45, 'Large Sculpture', 'wood', 222);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"medium\", \"sculptorID\") VALUES (100, 'Century Sculpture', 'steel', 555);",
      "INSERT INTO \"Sculptures\" (\"sculptureID\", \"title\", \"medium\", \"location\", \"sculptorID\") VALUES (5, 'Small Sculpture', 'clay', 'Gallery 200', 222);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named calculate_sculpture_sine_year for the \"Sculptures\" table. For each new row, set NEW.year to ROUND(1900 + (SIN(NEW.sculptureID) * 0.1 * 1000)).",
    "natural_language": "How can I create a BEFORE INSERT trigger function called calculate_sculpture_sine_year for the \"Sculptures\" table that sets the NEW.year column to ROUND(1900 + (SIN(NEW.sculptureID) * 0.1 * 1000)) for each new row?",
    "id": 269
  },
  {
    "ir": "Write a PL/pgSQL trigger that, after a row is deleted from the `country` table, automatically executes a function named `cleanup_orphaned_coasters`. This function is defined to return a `TRIGGER` type and operates by performing a `DELETE` operation on the `roller_coaster` table. The `DELETE` operation targets rows in the `roller_coaster` table where the value in its `\"Country_ID\"` column matches the value of the `\"Country_ID\"` column from the row that was just deleted from the `country` table (referred to as `OLD.\"Country_ID\"`). After executing the `DELETE` statement, the function returns the `OLD` row, which represents the row that was deleted from the `country` table, as is standard for `AFTER` row-level triggers. The trigger itself is named `tr_cleanup_orphaned_coasters` and is configured to activate `AFTER DELETE` events on the `country` table, executing `FOR EACH ROW` that is deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_orphaned_coasters() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM roller_coaster WHERE \"Country_ID\" = OLD.\"Country_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER tr_cleanup_orphaned_coasters\n    AFTER DELETE ON country\n    FOR EACH ROW\n    EXECUTE FUNCTION cleanup_orphaned_coasters();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM country WHERE \"Country_ID\" = 1;",
      "DELETE FROM country WHERE \"Country_ID\" = 2;",
      "DELETE FROM country WHERE \"Name\" = 'Sweden';",
      "DELETE FROM country WHERE \"Population\" < 6000000;",
      "DELETE FROM country WHERE \"Area\" > 400000;"
    ],
    "summary": "Create an AFTER DELETE trigger function named cleanup_orphaned_coasters for the \"country\" table. For each deleted row, delete rows from the \"roller_coaster\" table where its \"Country_ID\" equals the OLD.\"Country_ID\".",
    "natural_language": "Set up a trigger to run after something gets removed from the country list. It should clean up the roller coaster records that are probably linked to that now-missing country, getting rid of the ones that don't belong anywhere anymore.",
    "id": 270
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `validate_order_quantity` that is designed to be executed before an `INSERT` operation on the `\"Order_Items\"` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives `NEW` and `OLD` record variables representing the new and old row data, respectively. The function's primary purpose is to validate the `order_quantity` column of the new row being inserted. Upon execution, the function first attempts to cast the value of the `order_quantity` column from the `NEW` record (representing the row about to be inserted) to an `integer` data type. It then evaluates a conditional statement: if this cast `order_quantity` value is strictly greater than the integer literal `100`, the function immediately returns `NULL`. A `NULL` return value from a `BEFORE INSERT` trigger function signifies that the `INSERT` operation should be aborted, and the row should not be inserted into the table. If the `order_quantity` is not greater than `100`, the function proceeds to the next statement and returns the `NEW` record itself. Returning `NEW` indicates that the `INSERT` operation should proceed with the row data as it was provided (or potentially modified by the trigger function, though no modifications are performed here). The function also includes an exception handler for the `invalid_text_representation` error. If, during the attempt to cast `NEW.order_quantity` to an `integer`, a value is encountered that cannot be successfully converted (e.g., if `order_quantity` contains non-numeric characters), this exception is caught. In such a scenario, the exception handler is executed, and the function returns `NULL`, effectively aborting the `INSERT` operation due to invalid data type conversion.\n\nThis trigger function is then associated with a trigger named `trg_validate_order_quantity`. This trigger is configured to execute `BEFORE INSERT` operations on the table named `\"Order_Items\"`. The `FOR EACH ROW` clause specifies that the trigger function `validate_order_quantity()` will be executed once for each row that is being inserted into the `\"Order_Items\"` table. The `EXECUTE FUNCTION validate_order_quantity()` clause explicitly calls the previously defined trigger function to perform the validation logic.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_order_quantity() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.order_quantity::integer > 100 THEN\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEXCEPTION\n  WHEN invalid_text_representation THEN\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_order_quantity\nBEFORE INSERT ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION validate_order_quantity();",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (100, 1, 13, '50');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (101, 2, 10, '150');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (102, 3, 11, 'abc');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (103, 4, 1, '100');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, order_quantity) VALUES (104, 5, 2, '1');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named `validate_order_quantity` for the `\"Order_Items\"` table. The function must validate the `order_quantity` column. If the value cannot be cast to an integer or is greater than 100, abort the insert by returning NULL. Otherwise, return the NEW row to proceed.",
    "natural_language": "Set up a trigger function called `validate_order_quantity` to run before adding entries to the `\"Order_Items\"` table. It should check the `order_quantity` field. If the value doesn't look like a proper whole number or seems a bit too high, then stop the insert. Otherwise, just let it go through.",
    "id": 271
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_customer_address that returns a trigger, which is automatically executed by a trigger named trg_update_customer_address defined on the \"Customers\" table; the trigger is configured to fire after an INSERT operation or after an UPDATE operation specifically on the address_id column of the \"Customers\" table, and it executes once for each row that is inserted or updated; when the trigger function executes, it performs an UPDATE operation on the \"Customers\" table, setting the customer_address column for a specific row; the new value for customer_address is obtained by executing a subquery that SELECTs the address_details column from the \"Addresses\" table where the address_id in the \"Addresses\" table matches the NEW.address_id value, which is the newly inserted or updated address_id value from the triggering row in the \"Customers\" table; the UPDATE operation in the \"Customers\" table is conditioned by a WHERE clause that ensures the update only applies to the row where the customer_id equals the NEW.customer_id value from the triggering row; after performing the update, the trigger function returns the NEW row record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_customer_address() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Customers\"\n  SET customer_address = (SELECT address_details FROM \"Addresses\" WHERE address_id = NEW.address_id)\n  WHERE customer_id = NEW.customer_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_customer_address\nAFTER INSERT OR UPDATE OF address_id ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION update_customer_address();",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Customers\" (customer_id, address_id, customer_name, customer_number) VALUES (100, 1, 'John Doe', '1001');",
      "UPDATE \"Customers\" SET address_id = 2 WHERE customer_id = 100;",
      "INSERT INTO \"Customers\" (customer_id, address_id, customer_name, customer_number) VALUES (101, 3, 'Jane Smith', '1002');",
      "UPDATE \"Customers\" SET address_id = 1, customer_name = 'Johnathan Doe' WHERE customer_id = 101;",
      "INSERT INTO \"Customers\" (customer_id, address_id, customer_name, customer_number, customer_address) VALUES (102, 2, 'Bob Wilson', '1003', 'Temporary Address');"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE OF `address_id` trigger function named `update_customer_address` for the `\"Customers\"` table. For each row, update the `customer_address` column with the `address_details` from the `\"Addresses\"` table where the `address_id` matches the NEW value. The update must target the row where `customer_id` equals NEW.customer_id. Return the NEW row.",
    "natural_language": "Make a trigger that runs after a new entry is added or when the address_id gets changed. Call it update_customer_address for the \"Customers\" table. Whenever that happens, set the customer_address field to whatever the address_details are from the \"Addresses\" table for the matching address_id. Just make sure it updates the right customer record. Hand back the new row.",
    "id": 272
  },
  {
    "ir": "Write a PostgreSQL trigger function named prevent_duplicate_order_items that is executed automatically before any INSERT operation on the table named \"Order_Items\" for each new row being inserted, where the function's logic first checks for the existence of any record in the \"Order_Items\" table by performing a SELECT operation that returns a constant value of 1 if a row is found where the order_id column value matches the incoming NEW.order_id value and the product_id column value matches the incoming NEW.product_id value, and if such a row exists, the function returns NULL to cancel the insertion of the current new row, but if no such duplicate row is found, the function returns the NEW row record to allow the INSERT operation to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION prevent_duplicate_order_items() RETURNS TRIGGER AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM \"Order_Items\" WHERE order_id = NEW.order_id AND product_id = NEW.product_id) THEN\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_prevent_duplicate_order_items\nBEFORE INSERT ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION prevent_duplicate_order_items();",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (1, 13, '2');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (1, 13, '1');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (2, 10, '4');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (2, 10, '3');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (13, 11, '5');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named `prevent_duplicate_order_items` for the `\"Order_Items\"` table. For each new row, check if a record with the same `order_id` and `product_id` already exists. If a duplicate is found, return NULL to cancel the insert. Otherwise, return the NEW row to proceed.",
    "natural_language": "Construct a BEFORE INSERT trigger function, which should be named `prevent_duplicate_order_items`, specifically for the `\"Order_Items\"` table. For every single new row that is being inserted, you must meticulously check whether an existing record, one that already possesses identical values for both the `order_id` and the `product_id` columns, is currently present. Should such a duplicate entry be unfortunately discovered, the function must deliberately return a NULL value in order to completely cancel the attempted insertion. Conversely, if no matching record is found, the function should proceed by helpfully returning the NEW row to allow the insertion to continue successfully.",
    "id": 273
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `generate_order_item_id` that is designed to be executed as a trigger, and a trigger named `trg_generate_order_item_id` that invokes this function. The `generate_order_item_id` function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD` representing the new and old row data, respectively. This function is declared to return `TRIGGER`, indicating its suitability for use as a trigger function. Within the function's `BEGIN...END` block, a single operation is performed: the `order_item_id` column of the `NEW` row (which represents the row being inserted) is assigned a value. This value is determined by a subquery that first selects the maximum `order_item_id` from the `\"Order_Items\"` table. The `COALESCE` function is applied to the result of `MAX(order_item_id)`, replacing any `NULL` value (which would occur if the table is empty) with `0`. The `greatest` function is then used to ensure that the result of `COALESCE(MAX(order_item_id), 0)` is at least `0`, effectively handling cases where `MAX` might somehow return a negative value (though unlikely for an ID column). Finally, `1` is added to this determined maximum value, generating a new, unique, and sequentially increasing `order_item_id`. After assigning this new ID to `NEW.order_item_id`, the function returns the `NEW` row, allowing the insertion operation to proceed with the modified `order_item_id`. The `trg_generate_order_item_id` trigger is defined to execute `BEFORE INSERT` operations on the `\"Order_Items\"` table. It is configured to run `FOR EACH ROW`, meaning the `generate_order_item_id` function will be executed once for every row that is about to be inserted into the `\"Order_Items\"` table. The trigger explicitly calls the `generate_order_item_id()` function using `EXECUTE FUNCTION`.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_order_item_id() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.order_item_id := (SELECT greatest(COALESCE(MAX(order_item_id), 0), 0) + 1 FROM \"Order_Items\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_generate_order_item_id\nBEFORE INSERT ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION generate_order_item_id();",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (1, 13, '1');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (2, 10, '3');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (3, 11, '2');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (8, 1, '5');",
      "INSERT INTO \"Order_Items\" (order_id, product_id, order_quantity) VALUES (13, 2, '1');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named `generate_order_item_id` for the `\"Order_Items\"` table. For each new row, assign a new `order_item_id` by taking the maximum existing ID (or 0 if none), ensuring it is at least 0, and adding 1. Return the modified NEW row.",
    "natural_language": "Define a BEFORE INSERT trigger function called `generate_order_item_id` for the `\"Order_Items\"` table. For every new row, set the `order_item_id` by calculating the maximum current ID (use 0 if none exist), ensuring the value is not less than 0, and then incrementing it by 1. Finally, return the updated NEW row.",
    "id": 274
  },
  {
    "ir": "Write a PLpgSQL trigger function that is associated with the \"Products\" table and is executed before any insert or update operation on each row of this table. The function, named validate_product_price, does not take any parameters and is designed to validate the product_price column of the row being inserted or updated. Specifically, it checks if the value of NEW.product_price, which represents the product_price of the new or updated row, is less than or equal to zero. If this condition is true, the function returns NULL, effectively preventing the insertion or update of the row with an invalid product_price. If the product_price is greater than zero, the function returns the NEW row, allowing the operation to proceed. The trigger, named trg_validate_product_price, is created to invoke this function before any insert or update operation on the \"Products\" table, ensuring that all product prices are validated according to the specified logic.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_product_price() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.product_price <= 0 THEN\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_product_price\nBEFORE INSERT OR UPDATE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION validate_product_price();",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Products\" (product_id, product_type_code, product_name, product_price) VALUES (100, 'Electronics', 'Laptop', 1200.50);",
      "INSERT INTO \"Products\" (product_id, product_type_code, product_name, product_price) VALUES (101, 'Books', 'The Great Gatsby', 0.00);",
      "UPDATE \"Products\" SET product_price = 500.00 WHERE product_id = 1;",
      "UPDATE \"Products\" SET product_price = -10.00 WHERE product_id = 2;",
      "INSERT INTO \"Products\" (product_id, product_type_code, product_name, product_price) VALUES (102, 'Food', 'Apple', 1.25);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named `validate_product_price` for the `\"Products\"` table. For each row, validate the `product_price` column. If the price is less than or equal to zero, return NULL to abort the operation. Otherwise, return the NEW row to proceed.",
    "natural_language": "Set up a trigger function called `validate_product_price` that runs before adding or changing records in the `\"Products\"` table. For each entry, check the `product_price` field. If the amount seems too low or isn't a positive value, stop the action by returning nothing. If the price looks acceptable, allow the change to go through by returning the new row.",
    "id": 275
  },
  {
    "ir": "Write a PLpgSQL trigger function named \"trigger_function_2\" that is executed after an insert operation on the \"list\" table. This function does not take any parameters directly, but operates on the NEW record, which represents the row that was just inserted into the \"list\" table. The function attempts to insert a new row into the \"teachers\" table with the values from the NEW record's \"LastName\", \"FirstName\", and \"Classroom\" columns. Before performing the insert, it checks if a row with the same \"LastName\" and \"FirstName\" already exists in the \"teachers\" table by executing a subquery that selects a constant value (1) from the \"teachers\" table where the \"LastName\" and \"FirstName\" match those of the NEW record. If no such row exists (i.e., the subquery returns no results), the insert operation proceeds; otherwise, it is skipped. The function returns the NEW record, allowing the trigger to complete its operation. The trigger named \"trigger_2\" is defined to execute this function for each row inserted into the \"list\" table, ensuring that the logic is applied to every new entry in \"list\".",
    "plsql": "CREATE OR REPLACE FUNCTION \"trigger_function_2\"() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"teachers\" (\"LastName\", \"FirstName\", \"Classroom\")\n  SELECT NEW.\"LastName\", NEW.\"FirstName\", NEW.\"Classroom\"\n  WHERE NOT EXISTS (\n    SELECT 1 FROM \"teachers\"\n    WHERE \"LastName\" = NEW.\"LastName\" AND \"FirstName\" = NEW.\"FirstName\"\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_2\"\nAFTER INSERT ON \"list\"\nFOR EACH ROW EXECUTE FUNCTION \"trigger_function_2\"();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('CAR', ' MAUDE', 2, 101);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('KRISTENSEN', ' STORMY', 6, 112);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('VANDERWOUDE', ' SHERWOOD', 3, 107);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('CAR', ' SHERWOOD', 4, 108);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('KRISTENSEN', ' MAUDE', 5, 109);"
    ],
    "summary": "Create an AFTER INSERT trigger on the list table that inserts a new row into the teachers table using the new row's LastName, FirstName, and Classroom values, but only if a teacher with the same LastName and FirstName does not already exist.",
    "natural_language": "Set up a trigger to run after something gets added to the list table. It should put a new entry into the teachers table, pulling details like the person's last name, first name, and where they're assigned from the new data. But only do this if we don't already have someone with that same first and last name in there.",
    "id": 276
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the teachers table, executes a delete operation on the list table, removing all rows where the Grade column has a value less than 3, and then returns the newly inserted row.",
    "plsql": "CREATE OR REPLACE FUNCTION \"trigger_function_3\"() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"list\"\n  WHERE \"Grade\" < 3;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_3\"\nAFTER INSERT ON \"teachers\"\nFOR EACH ROW EXECUTE FUNCTION \"trigger_function_3\"();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "INSERT INTO teachers (LastName, FirstName, Classroom) VALUES ('Doe', 'John', 101);",
      "INSERT INTO teachers (LastName, FirstName, Classroom) VALUES ('Smith', 'Jane', 102);",
      "INSERT INTO teachers (LastName, FirstName, Classroom) VALUES ('Johnson', 'Bob', 103);",
      "INSERT INTO teachers (LastName, FirstName, Classroom) VALUES ('Williams', 'Alice', 104);",
      "INSERT INTO teachers (LastName, FirstName, Classroom) VALUES ('Brown', 'Charlie', 105);"
    ],
    "summary": "Create an AFTER INSERT trigger on the teachers table that deletes all rows from the list table where the Grade is less than 3.",
    "natural_language": "Please implement an AFTER INSERT trigger on the teachers table. The function of this trigger is to remove all records from the list table where the Grade value is below 3.",
    "id": 277
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named \"trigger_function_4\" that is designed to be executed in response to data manipulation language (DML) events on a specific table, and a trigger named \"trigger_4\" that invokes this function. The \"trigger_function_4\" function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` and `OLD` representing the new and old row data, respectively. This function is declared to return a `TRIGGER` type, which is standard for PostgreSQL trigger functions. Upon execution, the function performs a single `INSERT` operation into the \"teachers\" table. Specifically, it inserts a new row into the \"teachers\" table, populating three columns: \"LastName\", \"FirstName\", and \"Classroom\". The value for the \"LastName\" column is derived directly from the \"LastName\" column of the `NEW` row, which represents the data being inserted into the table that activated the trigger. Similarly, the value for the \"FirstName\" column is taken directly from the \"FirstName\" column of the `NEW` row. For the \"Classroom\" column, the function calculates a random integer value. This calculation involves calling the `RANDOM()` function, which generates a pseudo-random floating-point number between 0.0 (inclusive) and 1.0 (exclusive). This random number is then multiplied by 100, resulting in a value between 0.0 and 99.999... The `FLOOR()` function is applied to this result, truncating the decimal part and yielding an integer between 0 and 99. Finally, 100 is added to this integer, producing a random integer value for \"Classroom\" that falls within the range of 100 to 199 (inclusive). After performing this insertion, the function returns the `NEW` row, which is a standard practice for `AFTER` row-level triggers in PostgreSQL, indicating that the original DML operation should proceed with the new row data. The \"trigger_4\" trigger is defined to execute the \"trigger_function_4\" function. This trigger is configured to activate `AFTER INSERT` operations on the \"list\" table. It is a `FOR EACH ROW` trigger, meaning that the \"trigger_function_4\" function will be executed once for every row that is inserted into the \"list\" table. The `EXECUTE FUNCTION \"trigger_function_4\"()` clause specifies that the \"trigger_function_4\" function should be called when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION \"trigger_function_4\"() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"teachers\" (\"LastName\", \"FirstName\", \"Classroom\")\n  VALUES (NEW.\"LastName\", NEW.\"FirstName\", FLOOR(RANDOM() * 100) + 100);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_4\"\nAFTER INSERT ON \"list\"\nFOR EACH ROW EXECUTE FUNCTION \"trigger_function_4\"();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('SMITH', 'JOHN', 5, 105);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('DOE', 'JANE', 3, 102);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('BROWN', 'PETER', 7, 109);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('WHITE', 'MARY', 4, 101);",
      "INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") VALUES ('GREEN', 'ROBERT', 6, 110);"
    ],
    "summary": "Create an AFTER INSERT trigger on the list table that inserts a new row into the teachers table. Use the new row's LastName and FirstName, and generate a random integer between 100 and 199 for the Classroom value.",
    "natural_language": "Set up a trigger to run after something gets added to the list table. It should put a new entry into the teachers table. Use the new entry's name parts, and for the Classroom, just pick a number that seems okay, somewhere around the low hundreds.",
    "id": 278
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an update operation on the list table. This function, named trigger_function_5, does not take any parameters directly but operates in the context of a trigger. It performs a delete operation on the teachers table, specifically removing all rows where the Classroom column matches the Classroom value of the newly updated row in the list table. The function returns the NEW row, which is the row that was just updated in the list table. The associated trigger, named trigger_5, is defined to fire after each row update on the list table, ensuring that the trigger_function_5 is executed for every row that is updated, thereby maintaining the specified condition on the teachers table.",
    "plsql": "CREATE OR REPLACE FUNCTION \"trigger_function_5\"() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"teachers\"\n  WHERE \"Classroom\" = NEW.\"Classroom\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_5\"\nAFTER UPDATE ON \"list\"\nFOR EACH ROW EXECUTE FUNCTION \"trigger_function_5\"();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "UPDATE \"list\" SET \"Classroom\" = 101 WHERE \"LastName\" = 'CAR';",
      "UPDATE \"list\" SET \"Classroom\" = 112 WHERE \"LastName\" = 'KRISTENSEN';",
      "UPDATE \"list\" SET \"Classroom\" = 107 WHERE \"LastName\" = 'VANDERWOUDE';",
      "UPDATE \"list\" SET \"Classroom\" = 101 WHERE \"FirstName\" = ' MAUDE';",
      "UPDATE \"list\" SET \"Classroom\" = 112 WHERE \"FirstName\" = ' STORMY';"
    ],
    "summary": "Create an AFTER UPDATE trigger on the list table that deletes all rows from the teachers table where the Classroom matches the new Classroom value of the updated row.",
    "natural_language": "Alright, so every time someone updates a row in the list table, we need a trigger to kick in right after. This trigger's job is to clean out the teachers table, getting rid of any teacher records where their Classroom is the same as the new Classroom value from the row that was just updated.",
    "id": 279
  },
  {
    "ir": "Write a PLpgSQL trigger function that is invoked before a row is deleted from the artist table, specifically targeting the deletion of volumes associated with the artist being removed. The function, named delete_volume_on_artist_removal, does not take any parameters directly but operates on the OLD record, which represents the row in the artist table that is about to be deleted. Within the function, a DELETE operation is performed on the volume table, removing all rows where the Artist_ID column matches the Artist_ID of the OLD record from the artist table. This ensures that any volumes linked to the artist being deleted are also removed from the volume table. The function then returns the OLD record, allowing the deletion process on the artist table to proceed. The trigger, named trg_artist_cascade_delete, is defined to execute this function before any delete operation on the artist table, ensuring that the cascading delete of related volumes occurs automatically for each row deletion in the artist table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_volume_on_artist_removal() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM volume WHERE \"Artist_ID\" = OLD.\"Artist_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_artist_cascade_delete\nBEFORE DELETE ON artist\nFOR EACH ROW EXECUTE FUNCTION delete_volume_on_artist_removal();",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "DELETE FROM artist WHERE Artist_ID = 1;",
      "DELETE FROM artist WHERE Artist_ID = 2;",
      "DELETE FROM artist WHERE Artist_ID = 3;",
      "DELETE FROM artist WHERE Artist_ID = 4;",
      "DELETE FROM artist WHERE Artist_ID = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger on the artist table that deletes all related rows from the volume table where the Artist_ID matches the Artist_ID of the row being deleted.",
    "natural_language": "Hey, set up a trigger for the artist table that kicks in right before a row gets deleted. It should clean out any rows in the volume table that have the same Artist_ID as the one you're about to zap.",
    "id": 280
  },
  {
    "ir": "Write a PLpgSQL function named delete_rounds_on_member_delete that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to be invoked after a DELETE operation on the member table. The function performs a DELETE operation on the round table, specifically targeting rows where the Member_ID column matches the Member_ID value of the row that was just deleted from the member table. The OLD keyword is used to reference the values of the deleted row from the member table, allowing the function to access the Member_ID of the deleted member. After executing the DELETE operation on the round table, the function returns the OLD record, which represents the state of the deleted row from the member table before the deletion occurred. This function is associated with a trigger named trg_delete_rounds_on_member_delete, which is defined to fire after a row is deleted from the member table. The trigger is set to execute the delete_rounds_on_member_delete function for each row that is deleted, ensuring that all rounds associated with the deleted member are removed from the round table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_rounds_on_member_delete() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM round WHERE \"Member_ID\" = OLD.\"Member_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_rounds_on_member_delete\nAFTER DELETE ON member\nFOR EACH ROW EXECUTE FUNCTION delete_rounds_on_member_delete();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "DELETE FROM member WHERE \"Member_ID\" = 1;",
      "DELETE FROM member WHERE \"Member_ID\" = 2;",
      "DELETE FROM member WHERE \"Member_ID\" = 3;",
      "DELETE FROM member WHERE \"Name\" = 'Jack Nicklaus';",
      "DELETE FROM member WHERE \"Country\" = 'Canada';"
    ],
    "summary": "Create a trigger function named delete_rounds_on_member_delete that fires after a row is deleted from the member table. The function deletes all rows from the round table where the Member_ID matches the deleted member's ID. Return the OLD record.",
    "natural_language": "How can I create a trigger function named delete_rounds_on_member_delete that, after a row is deleted from the member table, deletes all corresponding rows from the round table where the Member_ID matches the deleted member's ID and returns the OLD record?",
    "id": 281
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_member_country_on_college_update that returns a trigger and is executed automatically by a trigger named trg_update_member_country_on_college_update, which is defined to fire after any row in the college table is updated, and for each updated row, the function performs an update operation on the member table, setting the value of the column named \"Country\" to the literal string 'Updated Country' for every row in the member table where the value in the column named \"College_ID\" is equal to the new value of the column named \"College_ID\" from the recently updated row in the college table, and finally the function returns the NEW row record from the triggering update on the college table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_member_country_on_college_update() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE member SET \"Country\" = 'Updated Country' WHERE \"College_ID\" = NEW.\"College_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_member_country_on_college_update\nAFTER UPDATE ON college\nFOR EACH ROW EXECUTE FUNCTION update_member_country_on_college_update();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "UPDATE college SET \"Name\" = 'Updated School' WHERE \"College_ID\" = 1;",
      "UPDATE college SET \"Leader_Name\" = 'New Leader' WHERE \"College_ID\" = 2;",
      "UPDATE college SET \"College_Location\" = 'New Location' WHERE \"College_ID\" = 3;",
      "UPDATE college SET \"Name\" = 'Renamed College', \"Leader_Name\" = 'Different Leader' WHERE \"College_ID\" = 1;",
      "UPDATE college SET \"College_Location\" = 'Toronto' WHERE \"College_ID\" IN (1, 2, 3);"
    ],
    "summary": "Create a trigger function named update_member_country_on_college_update that fires after an update on the college table. For the updated college, set the Country to 'Updated Country' for all members with the matching College_ID. Return the NEW record.",
    "natural_language": "Construct a trigger function, which should be named update_member_country_on_college_update, designed to activate automatically following any update operation performed on the college table. For the specific college entry that has just been modified, you must comprehensively update the Country field, setting it precisely to the value 'Updated Country', for each and every member record that possesses a matching College_ID. The function must conclusively return the NEW record as its final output.",
    "id": 282
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_round_on_member_insert that is automatically executed by a trigger named trg_insert_round_on_member_insert, which is defined to fire after every insert operation on the member table for each newly inserted row, where the function performs a single insert operation into the round table, specifying the column values for the new row as follows: the Member_ID column is set to the value of the Member_ID column from the newly inserted member row (accessed via the NEW record), the Decoration_Theme column is set to the literal string value 'New Theme', and the Rank_in_Round column is set to the integer value 1, and the function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_round_on_member_insert() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO round (\"Member_ID\", \"Decoration_Theme\", \"Rank_in_Round\") VALUES (NEW.\"Member_ID\", 'New Theme', 1);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_round_on_member_insert\nAFTER INSERT ON member\nFOR EACH ROW EXECUTE FUNCTION insert_round_on_member_insert();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (4, 'Tiger Woods', 'United States', 1);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (5, 'Rory McIlroy', 'Northern Ireland', 2);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (6, 'Jordan Spieth', 'United States', 1);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (7, 'Dustin Johnson', 'United States', 3);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (8, 'Brooks Koepka', 'United States', 2);"
    ],
    "summary": "Create a trigger function named insert_round_on_member_insert that fires after an insert on the member table. For the new member, insert a row into the round table with the new Member_ID, 'New Theme' for Decoration_Theme, and 1 for Rank_in_Round. Return the NEW record.",
    "natural_language": "How can I create a trigger function called insert_round_on_member_insert that executes after an insert on the member table, so that for each new member, it inserts a row into the round table using the new Member_ID, sets the Decoration_Theme to 'New Theme', sets the Rank_in_Round to 1, and then returns the NEW record?",
    "id": 283
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_college_location_on_college_update that is executed automatically after each row update operation on the college table, which first checks if the new value of the College_Location column for the updated row is different from the literal string 'Updated Location' using the IS DISTINCT FROM comparison, and if this condition is true, the function performs an update on the college table, setting the College_Location column to the literal string 'Updated Location' specifically for the row where the College_ID column matches the new College_ID value from the triggering update event, and finally the function returns the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_college_location_on_college_update() RETURNS TRIGGER AS $$\nBEGIN\n  -- Prevent infinite recursion by only updating if the location is not already the target value\n  IF NEW.\"College_Location\" IS DISTINCT FROM 'Updated Location' THEN\n    UPDATE college\n    SET \"College_Location\" = 'Updated Location'\n    WHERE \"College_ID\" = NEW.\"College_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_college_location_on_college_update\nAFTER UPDATE ON college\nFOR EACH ROW EXECUTE FUNCTION update_college_location_on_college_update();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "UPDATE college SET \"College_Location\" = 'Old Location' WHERE \"College_ID\" = 1;",
      "UPDATE college SET \"Name\" = 'New Name' WHERE \"College_ID\" = 2;",
      "UPDATE college SET \"Leader_Name\" = 'New Leader' WHERE \"College_ID\" = 3;",
      "UPDATE college SET \"College_Location\" = 'Another Location' WHERE \"College_ID\" = 1;",
      "UPDATE college SET \"College_Location\" = 'Updated Location' WHERE \"College_ID\" = 2;"
    ],
    "summary": "Create a trigger function named update_college_location_on_college_update that fires after an update on the college table. If the new College_Location is different from 'Updated Location', update the college's location to 'Updated Location'. Return the NEW record.",
    "natural_language": "How do you create a trigger function named update_college_location_on_college_update that fires after an update on the college table, so that if the new College_Location is different from 'Updated Location', it updates the college's location to 'Updated Location' and returns the NEW record?",
    "id": 284
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the photos table, automatically updates the name column in the mountain table to its uppercase version for the row where the id matches the mountain_id of the newly inserted photo. The function does not take any parameters directly but operates on the NEW record, which represents the row being inserted into the photos table. The trigger, named trg_update_mountain_name_on_photo_insert, is defined to execute this function after each row is inserted into the photos table. The function uses the UPPER() function to convert the name of the mountain to uppercase, ensuring that the name is consistently stored in uppercase format in the mountain table. The trigger is set to fire for each row, meaning it will execute the function for every individual row insertion into the photos table, ensuring that the corresponding mountain name is updated immediately after a photo is added.",
    "plsql": "CREATE OR REPLACE FUNCTION update_mountain_name_on_photo_insert() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE mountain SET name = UPPER(name) WHERE id = NEW.mountain_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_mountain_name_on_photo_insert\n    AFTER INSERT ON photos\n    FOR EACH ROW\n    EXECUTE FUNCTION update_mountain_name_on_photo_insert();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (4, 1, 1, 'RGB', 'landscape');",
      "INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (5, 2, 2, 'Black/White', 'sunset');",
      "INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (6, 3, 3, 'RGB', 'wildlife');",
      "INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (7, 1, 2, 'RGB', 'mountain view');",
      "INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (8, 2, 1, 'Black/White', 'forest');"
    ],
    "summary": "Create a trigger function that fires after an insert into the photos table. Update the name column in the mountain table to uppercase for the mountain whose id matches the new photo's mountain_id. Return the NEW record.",
    "natural_language": "Write a trigger function that executes after an insert on the photos table. Set the name column in the mountain table to uppercase for the mountain with an id equal to the new photo's mountain_id. Return the NEW record.",
    "id": 285
  },
  {
    "ir": "Write a PLpgSQL function that is designed to be executed as a trigger function, which automatically inserts a new record into the mountain table whenever a new row is inserted into the camera_lens table. The function insert_mountain_on_lens_insert does not take any parameters directly but operates on the NEW record, which represents the row being inserted into the camera_lens table. The function performs the following operations: it inserts a new row into the mountain table with the following values: the id column is set to the absolute value of the NEW.id from the camera_lens table plus 100; the name column is set to the first five characters of the NEW.name from the camera_lens table; the Height column is set to the rounded value of NEW.focal_length_mm from the camera_lens table; the Prominence column is set to the remainder of NEW.id divided by 1000; the Range column is set to the string 'Trigger Range'; and the Country column is set to the string 'Trigger Country'. The function then returns the NEW record, allowing the insert operation on the camera_lens table to proceed. The trigger trg_insert_mountain_on_lens_insert is defined to execute this function after each row is inserted into the camera_lens table, ensuring that the described insert operation into the mountain table occurs automatically for every new camera_lens record.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_mountain_on_lens_insert() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO mountain (id, name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES (ABS(NEW.id) + 100, SUBSTR(NEW.name, 1, 5), ROUND(NEW.focal_length_mm), MOD(NEW.id, 1000), 'Trigger Range', 'Trigger Country');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_mountain_on_lens_insert\n    AFTER INSERT ON camera_lens\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_mountain_on_lens_insert();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (4, 'Olympus', 'Olympus 25mm f/1.8', 25.0, 1.8);",
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (5, 'Olympus', 'Olympus 50mm f/2.0', 50.0, 2.0);",
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (6, 'Olympus', 'Olympus 100mm f/2.8', 100.0, 2.8);",
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (7, 'Olympus', 'Olympus 200mm f/4.0', 200.0, 4.0);",
      "INSERT INTO camera_lens (id, brand, name, focal_length_mm, max_aperture) VALUES (8, 'Olympus', 'Olympus 300mm f/5.6', 300.0, 5.6);"
    ],
    "summary": "Create an AFTER INSERT trigger function for the camera_lens table. For each new row, insert a corresponding record into the mountain table. Set mountain.id to ABS(NEW.id) + 100, mountain.name to the first 5 characters of NEW.name, mountain.Height to ROUND(NEW.focal_length_mm), mountain.Prominence to MOD(NEW.id, 1000), mountain.Range to 'Trigger Range', and mountain.Country to 'Trigger Country'. Return NEW.",
    "natural_language": "Create an AFTER INSERT trigger for camera_lens. For each new row, insert into mountain with id as ABS(new.id)+100, name as first 5 chars of new.name, Height as ROUND(new.focal_length_mm), Prominence as MOD(new.id, 1000), Range as 'Trigger Range', Country as 'Trigger Country'. Return NEW.",
    "id": 286
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `delete_photos_on_mountain_delete` that is designed to be executed in response to a specific database event. This function does not accept any explicit input parameters in its signature, but as a trigger function, it implicitly receives special variables representing the old and new states of the row being affected by the triggering event. Specifically, it accesses `OLD.id`, which represents the value of the `id` column from the row *before* it was deleted from the `mountain` table. The function performs a single operation: it executes a `DELETE` statement on the `photos` table. The `DELETE` operation targets rows in the `photos` table where the value in the `mountain_id` column is equal to the value of `OLD.id`. After performing this deletion, the function returns `OLD`, which is a special trigger variable representing the row that was deleted from the `mountain` table.\n\nThis trigger function is then associated with a trigger named `trg_delete_photos_on_mountain_delete`. This trigger is configured to activate `BEFORE DELETE` operations on the `mountain` table. The `FOR EACH ROW` clause specifies that the trigger function `delete_photos_on_mountain_delete` will be executed once for each individual row that is being deleted from the `mountain` table. The `EXECUTE FUNCTION delete_photos_on_mountain_delete()` clause explicitly calls the previously defined trigger function to perform its logic. Therefore, whenever a row is deleted from the `mountain` table, this trigger will automatically execute the `delete_photos_on_mountain_delete` function *before* the actual deletion of the mountain row occurs, leading to the deletion of all associated photos from the `photos` table where the `mountain_id` matches the `id` of the mountain being deleted.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_photos_on_mountain_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM photos WHERE mountain_id = OLD.id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_photos_on_mountain_delete\n    BEFORE DELETE ON mountain\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_photos_on_mountain_delete();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "DELETE FROM mountain WHERE id = 1;",
      "DELETE FROM mountain WHERE id = 2;",
      "DELETE FROM mountain WHERE id = 3;",
      "DELETE FROM mountain WHERE id = 4;",
      "DELETE FROM mountain WHERE id = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger function for the mountain table. For each row being deleted, delete all rows from the photos table where photos.mountain_id equals OLD.id. Return OLD.",
    "natural_language": "Set up a trigger that runs before a mountain entry is removed. When that happens, also get rid of any photo records that seem to be linked to that specific mountain. Just make sure the original mountain data is what gets passed back.",
    "id": 287
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_photo_color_on_lens_update` that is designed to be executed in response to data modifications on a specific table, and a trigger named `trg_update_photo_color_on_lens_update` that invokes this function. The trigger function `update_photo_color_on_lens_update` is defined to return a `TRIGGER` type, indicating its role as a trigger handler. Upon execution, this function performs an `UPDATE` operation on the `photos` table. The `UPDATE` statement modifies the `color` column of rows in the `photos` table. The new value for the `color` column is determined by a `CASE` statement. Specifically, if the value of the `max_aperture` column in the `NEW` record (representing the updated row in the `camera_lens` table) is greater than `2.0`, then the `color` column in the `photos` table will be set to the string literal `'RBG'`. Otherwise, if `NEW.max_aperture` is not greater than `2.0`, the `color` column will be set to the string literal `'Black/White'`. This `UPDATE` operation is conditionally applied only to those rows in the `photos` table where the `camera_lens_id` column matches the value of the `id` column from the `NEW` record (i.e., the `id` of the `camera_lens` record that triggered the update). After performing this update, the function returns the `NEW` record, which is standard behavior for `AFTER` triggers in PostgreSQL.\n\nThe trigger `trg_update_photo_color_on_lens_update` is defined to activate `AFTER UPDATE` operations on the `camera_lens` table. This means that the trigger will execute its associated function after any `UPDATE` statement successfully modifies one or more rows in the `camera_lens` table. The `FOR EACH ROW` clause specifies that the trigger function `update_photo_color_on_lens_update` will be executed once for each row that is updated in the `camera_lens` table. The `EXECUTE FUNCTION update_photo_color_on_lens_update()` clause explicitly calls the previously defined trigger function to perform the described logic.",
    "plsql": "CREATE OR REPLACE FUNCTION update_photo_color_on_lens_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE photos SET color = CASE WHEN NEW.max_aperture > 2.0 THEN 'RBG' ELSE 'Black/White' END WHERE camera_lens_id = NEW.id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_photo_color_on_lens_update\n    AFTER UPDATE ON camera_lens\n    FOR EACH ROW\n    EXECUTE FUNCTION update_photo_color_on_lens_update();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "UPDATE camera_lens SET max_aperture = 1.8 WHERE id = 1;",
      "UPDATE camera_lens SET max_aperture = 2.8 WHERE id = 2;",
      "UPDATE camera_lens SET max_aperture = 4.0 WHERE id = 3;",
      "UPDATE camera_lens SET brand = 'Nikon', max_aperture = 1.4 WHERE id = 1;",
      "UPDATE camera_lens SET name = 'Updated Lens', max_aperture = 5.6 WHERE id = 10;"
    ],
    "summary": "Create an AFTER UPDATE trigger function for the camera_lens table. For each updated row, update the photos table. Set photos.color to 'RBG' if NEW.max_aperture > 2.0, otherwise set it to 'Black/White'. Apply this update only to photos where photos.camera_lens_id equals NEW.id. Return NEW.",
    "natural_language": "Create an AFTER UPDATE trigger for camera_lens. For each updated row, set photos.color to 'RBG' if NEW.max_aperture > 2.0, else to 'Black/White' where photos.camera_lens_id matches NEW.id. Return NEW.",
    "id": 288
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_photo_on_mountain_update that is executed automatically after every row update operation on the mountain table, which performs an insert into the photos table with specific column values: the id column is set to the absolute value of the NEW.id from the updated mountain row multiplied by 1000, the camera_lens_id column is set to the minimum id value retrieved from a subquery on the camera_lens table, the mountain_id column is set directly to the NEW.id value from the updated mountain row, the color column is set to the literal string 'Trigger Color', and the name column is set to a substring of the NEW.name value from the updated mountain row, extracting only the first three characters using the SUBSTR function; the function then returns the NEW row record to the trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_photo_on_mountain_update() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO photos (id, camera_lens_id, mountain_id, color, name) VALUES (ABS(NEW.id) * 1000, (SELECT MIN(id) FROM camera_lens), NEW.id, 'Trigger Color', SUBSTR(NEW.name, 1, 3));\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_photo_on_mountain_update\n    AFTER UPDATE ON mountain\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_photo_on_mountain_update();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "UPDATE mountain SET name = 'Abune Yosef / Guliba Amba Updated' WHERE id = 1;",
      "UPDATE mountain SET name = 'Ioll / Yoll Updated' WHERE id = 2;",
      "UPDATE mountain SET name = 'Bada Updated' WHERE id = 3;",
      "UPDATE mountain SET Height = 4270.0 WHERE id = 1;",
      "UPDATE mountain SET Prominence = 360.0 WHERE id = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function for the mountain table. For each updated row, insert a new record into the photos table. Set photos.id to ABS(NEW.id) * 1000, photos.camera_lens_id to the minimum id from the camera_lens table, photos.mountain_id to NEW.id, photos.color to 'Trigger Color', and photos.name to the first 3 characters of NEW.name. Return NEW.",
    "natural_language": "Construct an AFTER UPDATE trigger function specifically for the mountain table, ensuring that for every single row which gets updated, a brand new record is meticulously inserted into the photos table. You must assign the photos.id by calculating the absolute value of the NEW.id and then multiplying that result by 1000. For the photos.camera_lens_id, carefully retrieve and use the very smallest id available from the entire camera_lens table. Set the photos.mountain_id directly to the NEW.id value. The photos.color should be explicitly set to the literal string 'Trigger Color', and finally, derive the photos.name by taking only the initial three characters from the updated NEW.name value. The function must conclusively return the NEW record.",
    "id": 289
  },
  {
    "ir": "Write a PLpgSQL function that updates the date_of_latest_revision column in the Catalogs table to the current timestamp for the row where the catalog_id matches the catalog_id obtained from the Catalog_Structure table, based on the catalog_level_number of the newly inserted or updated row in the Catalog_Contents table. This function is triggered after any insert or update operation on the Catalog_Contents table, and it uses the NEW keyword to reference the catalog_level_number of the affected row. The trigger named trg_update_catalog_revision is responsible for executing this function for each row that is inserted or updated in the Catalog_Contents table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_revision_date() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Catalogs\" SET date_of_latest_revision = CURRENT_TIMESTAMP\n    WHERE catalog_id = (SELECT catalog_id FROM \"Catalog_Structure\" WHERE catalog_level_number = NEW.catalog_level_number);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_revision\n    AFTER INSERT OR UPDATE ON \"Catalog_Contents\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_catalog_revision_date();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (4, 1, 5, 9, 7, 'Cola', '89 cp', 200.78, 159.84, 172.17, '1', '3', '9', '5');",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'Root beer' WHERE catalog_entry_id = 2;",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (5, 8, 6, 6, 8, 'Cream Soda', '37 hq', 687.59, 590.11, 471.78, '8', '6', '5', '6');",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 360.5 WHERE catalog_entry_id = 3;",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (6, 1, 5, 9, 1, 'Lemonade', '52 ee', 360.5, 202.32, 110.32, '5', '9', '7', '8');"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE trigger function for the Catalog_Contents table. For each affected row, update the Catalogs table. Set the date_of_latest_revision column to the current timestamp for the row where catalog_id matches the catalog_id from the Catalog_Structure table, based on the NEW.catalog_level_number. Return NEW.",
    "natural_language": "Create trigger after insert or update on Catalog_Contents. For each row, update Catalogs set date_of_latest_revision to now where catalog_id matches NEW.catalog_level_number in Catalog_Structure. Return NEW.",
    "id": 290
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `sync_additional_attributes` that is designed to be executed after an `INSERT` operation on the `\"Catalog_Contents\"` table. This function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records representing the new and old row values, respectively, for the row that caused the trigger to fire. The function returns a `TRIGGER` type, which is standard for PostgreSQL trigger functions. Upon execution, the function performs a single `INSERT` operation into the `\"Catalog_Contents_Additional_Attributes\"` table. The columns being inserted into are `catalog_entry_id`, `catalog_level_number`, `attribute_id`, and `attribute_value`. The values for these columns are derived from a `SELECT` statement. Specifically, `NEW.catalog_entry_id` is used for `catalog_entry_id`, `NEW.catalog_level_number` is used for `catalog_level_number`, `ad.attribute_id` from the `\"Attribute_Definitions\"` table is used for `attribute_id`, and the literal string `'0'` is used for `attribute_value`. The `SELECT` statement retrieves data from the `\"Attribute_Definitions\"` table, aliased as `ad`. The selection of rows from `\"Attribute_Definitions\"` is filtered by two conditions: first, `ad.attribute_data_type` must be equal to the string literal `'Bool'`; and second, there must `NOT EXISTS` a corresponding entry in the `\"Catalog_Contents_Additional_Attributes\"` table, aliased as `ccaa`. This `NOT EXISTS` subquery checks for the existence of a row in `\"Catalog_Contents_Additional_Attributes\"` where `ccaa.catalog_entry_id` matches `NEW.catalog_entry_id` and `ccaa.attribute_id` matches `ad.attribute_id`. In essence, this ensures that only boolean attributes that are not already associated with the newly inserted catalog entry are added. After the `INSERT` operation completes, the function returns `NEW`, which signifies that the row that triggered the operation should be inserted as is.\n\nA trigger named `trg_sync_additional_attributes` is defined to execute the `sync_additional_attributes()` function. This trigger is configured to fire `AFTER INSERT` operations on the `\"Catalog_Contents\"` table. It is a `FOR EACH ROW` trigger, meaning the `sync_additional_attributes()` function will be executed once for each row that is inserted into the `\"Catalog_Contents\"` table. The `EXECUTE FUNCTION sync_additional_attributes()` clause specifies the function to be called when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_additional_attributes() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Catalog_Contents_Additional_Attributes\" (catalog_entry_id, catalog_level_number, attribute_id, attribute_value)\n    SELECT NEW.catalog_entry_id, NEW.catalog_level_number, ad.attribute_id, '0'\n    FROM \"Attribute_Definitions\" ad\n    WHERE ad.attribute_data_type = 'Bool' AND NOT EXISTS (\n        SELECT 1 FROM \"Catalog_Contents_Additional_Attributes\" ccaa\n        WHERE ccaa.catalog_entry_id = NEW.catalog_entry_id AND ccaa.attribute_id = ad.attribute_id\n    );\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_sync_additional_attributes\n    AFTER INSERT ON \"Catalog_Contents\"\n    FOR EACH ROW\n    EXECUTE FUNCTION sync_additional_attributes();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (4, 1, 5, 9, 7, 'Pepsi', '90 cp', 150.00, 120.00, 130.00, '2', '4', '6', '3');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (5, 8, 6, 6, 8, 'Sprite', '91 cp', 180.00, 140.00, 150.00, '3', '5', '7', '4');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (6, 9, 5, 9, 1, 'Fanta', '92 cp', 200.00, 160.00, 170.00, '4', '6', '8', '5');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (7, 1, 6, 6, 7, '7Up', '93 cp', 220.00, 180.00, 190.00, '5', '7', '9', '6');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (8, 8, 5, 9, 8, 'Mountain Dew', '94 cp', 240.00, 200.00, 210.00, '6', '8', '10', '7');"
    ],
    "summary": "Create an AFTER INSERT trigger function named sync_additional_attributes for the Catalog_Contents table. For each new row, insert into Catalog_Contents_Additional_Attributes the catalog_entry_id, catalog_level_number, attribute_id from Attribute_Definitions where attribute_data_type is 'Bool', and a default attribute_value of '0'. Only insert attributes not already present for that catalog_entry_id. Return NEW.",
    "natural_language": "Set up a trigger function called sync_additional_attributes to run after adding rows to the Catalog_Contents table. For each new entry, it should add some records to the Catalog_Contents_Additional_Attributes table. It should grab the catalog_entry_id and catalog_level_number from the new row, and also get the attribute_id for any attributes that are of a boolean type from the Attribute_Definitions. For those, use a default value like '0'. But, try to avoid putting in attributes that are already kind of there for that catalog entry. Just finish by returning the new row data.",
    "id": 291
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_catalog_price that returns a trigger and is executed as a BEFORE UPDATE trigger named trg_update_catalog_price on the table named Catalog_Contents for each row being updated, where the function's logic unconditionally multiplies the value of the NEW pseudorecord's column price_in_dollars by 1.1, effectively increasing it by ten percent, and then returns the modified NEW pseudorecord to the calling trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_price() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.price_in_dollars = NEW.price_in_dollars * 1.1;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_price\n    BEFORE UPDATE ON \"Catalog_Contents\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_catalog_price();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 250.00 WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 700.00 WHERE catalog_entry_id = 2;",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 400.00 WHERE catalog_entry_id = 3;",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 100.00 WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 500.00 WHERE catalog_entry_id = 2;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function named update_catalog_price for the Catalog_Contents table. For each updated row, increase the NEW.price_in_dollars value by 10% (multiply by 1.1). Return the modified NEW record.",
    "natural_language": "Create BEFORE UPDATE trigger update_catalog_price. For each row, set NEW.price_in_dollars to NEW.price_in_dollars * 1.1. Return NEW.",
    "id": 292
  },
  {
    "ir": "Write a PLpgSQL function named insert_catalog_structure that is designed to be executed as a trigger function. This function is triggered after an insert operation on the Catalog_Contents table. It performs an insert operation into the Catalog_Structure table, targeting the columns catalog_level_number, catalog_id, and catalog_level_name. The values inserted are derived from a SELECT statement that retrieves the catalog_level_number from the NEW row, which represents the row just inserted into the Catalog_Contents table, and the catalog_id and catalog_level_name from the Catalog_Structure table where the catalog_level_number matches the NEW.catalog_level_number. The function includes an ON CONFLICT clause that specifies that if a conflict occurs on the catalog_level_number column, the operation should do nothing, effectively preventing duplicate entries based on this column. The function concludes by returning the NEW row, which is standard practice for trigger functions to allow the triggering operation to proceed. The associated trigger, named trg_insert_catalog_structure, is defined to execute this function after each row is inserted into the Catalog_Contents table, ensuring that the Catalog_Structure table is updated accordingly with the relevant catalog information.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_catalog_structure() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Catalog_Structure\" (catalog_level_number, catalog_id, catalog_level_name)\n    SELECT NEW.catalog_level_number, cs.catalog_id, cs.catalog_level_name\n    FROM \"Catalog_Structure\" cs\n    WHERE cs.catalog_level_number = NEW.catalog_level_number\n    ON CONFLICT (catalog_level_number) DO NOTHING;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_catalog_structure\n    AFTER INSERT ON \"Catalog_Contents\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_catalog_structure();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (4, 1, 5, 9, 7, 'Cola', '89 cp', 200.78, 159.84, 172.17, '1', '3', '9', '5');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (5, 8, 6, 6, 8, 'Root beer', '37 hq', 687.59, 590.11, 471.78, '8', '6', '5', '6');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (6, 1, 5, 9, 1, 'Cream Soda', '52 ee', 360.5, 202.32, 110.32, '5', '9', '7', '8');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (7, 8, 6, 6, 8, 'Cola', '89 cp', 200.78, 159.84, 172.17, '1', '3', '9', '5');",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (8, 1, 5, 9, 7, 'Root beer', '37 hq', 687.59, 590.11, 471.78, '8', '6', '5', '6');"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_catalog_structure for the Catalog_Contents table. For each new row, insert into Catalog_Structure the catalog_level_number from NEW, and the catalog_id and catalog_level_name from Catalog_Structure where the catalog_level_number matches. On conflict on catalog_level_number, do nothing. Return NEW.",
    "natural_language": "Please construct an AFTER INSERT trigger function designated as 'insert_catalog_structure' for the 'Catalog_Contents' table. For every newly inserted row, it is required to insert a corresponding record into the 'Catalog_Structure' table. This insertion shall utilize the 'catalog_level_number' value from the NEW row, while obtaining the 'catalog_id' and 'catalog_level_name' values from the existing 'Catalog_Structure' table where the 'catalog_level_number' matches. In the event of a conflict on the 'catalog_level_number' field, the operation should take no action. The function must conclude by returning the NEW row.",
    "id": 293
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `delete_catalog_entry` that is designed to be executed in response to a data manipulation event on a specific table, and a trigger named `trg_delete_catalog_entry` that invokes this function. The `delete_catalog_entry` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon its execution, the function performs a `DELETE` operation on the table named `\"Catalog_Contents_Additional_Attributes\"`. This `DELETE` operation targets rows within `\"Catalog_Contents_Additional_Attributes\"` where the value in its `catalog_entry_id` column matches the value of the `catalog_entry_id` column from the `OLD` record. The `OLD` record represents the row that is being deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` record. The `trg_delete_catalog_entry` trigger is defined to activate `BEFORE DELETE` operations on the table named `\"Catalog_Contents\"`. This trigger is configured to execute `FOR EACH ROW` affected by a `DELETE` statement on `\"Catalog_Contents\"`. When activated, the trigger `EXECUTE`s the function `delete_catalog_entry()`. This means that before any row is actually deleted from `\"Catalog_Contents\"`, the `delete_catalog_entry` function will be called, and it will delete corresponding entries from `\"Catalog_Contents_Additional_Attributes\"` based on the `catalog_entry_id` of the row being deleted from `\"Catalog_Contents\"`.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_catalog_entry() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Catalog_Contents_Additional_Attributes\"\n    WHERE catalog_entry_id = OLD.catalog_entry_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_catalog_entry\n    BEFORE DELETE ON \"Catalog_Contents\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_catalog_entry();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "DELETE FROM \"Catalog_Contents\" WHERE catalog_entry_id = 1;",
      "DELETE FROM \"Catalog_Contents\" WHERE catalog_entry_id = 2;",
      "DELETE FROM \"Catalog_Contents\" WHERE catalog_entry_id = 3;",
      "DELETE FROM \"Catalog_Contents\" WHERE catalog_entry_id = 4;",
      "DELETE FROM \"Catalog_Contents\" WHERE catalog_entry_id = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named delete_catalog_entry for the Catalog_Contents table. For each row to be deleted, first delete all rows from Catalog_Contents_Additional_Attributes where the catalog_entry_id matches OLD.catalog_entry_id. Return OLD.",
    "natural_language": "Please construct a BEFORE DELETE trigger function designated as 'delete_catalog_entry' for the 'Catalog_Contents' table. The function's logic must ensure that, for each row slated for deletion, all corresponding entries in the 'Catalog_Contents_Additional_Attributes' table are first removed, specifically those where the 'catalog_entry_id' column matches the 'catalog_entry_id' value of the OLD record. Subsequently, the function should return the OLD row.",
    "id": 294
  },
  {
    "ir": "Write a PL/pgSQL function named `update_company_rank_on_insert` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD` representing the new and old row data, respectively. The purpose of this function is to update the `Rank` column in the `company` table. Specifically, it performs an `UPDATE` operation on the `company` table. The `UPDATE` targets rows in the `company` table where the `Company_ID` column matches the `Company_ID` value from the newly inserted row, which is accessed via `NEW.\"Company_ID\"`. For these targeted rows, the `Rank` column is set to a new value. This new value is determined by a subquery: `(SELECT MAX(\"Rank_of_the_Year\") FROM \"station_company\" WHERE \"Company_ID\" = NEW.\"Company_ID\")`. This subquery selects the maximum value of the `Rank_of_the_Year` column from the `station_company` table, specifically for records where the `Company_ID` in `station_company` matches the `Company_ID` of the newly inserted row (`NEW.\"Company_ID\"`). After performing this update, the function returns `NEW`, which is the standard behavior for `AFTER` row-level triggers in PostgreSQL, indicating that the modified new row should be used.\n\nFollowing the function definition, a trigger named `station_company_insert_trigger` is created. This trigger is configured to activate `AFTER INSERT` operations on the `station_company` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is inserted into the `station_company` table. When activated, this trigger `EXECUTE FUNCTION update_company_rank_on_insert()`, thereby invoking the previously defined function.\n\nFinally, an example `INSERT` statement is provided. This statement attempts to insert a new row into the `station_company` table. The values provided for the columns are `Station_ID` as `11`, `Company_ID` as `1`, and `Rank_of_the_Year` as `1`. This `INSERT` statement includes an `ON CONFLICT` clause, which specifies a conflict target on the composite primary key or unique constraint formed by the `Station_ID` and `Company_ID` columns. If a conflict occurs (i.e., a row with the same `Station_ID` and `Company_ID` already exists), the `DO NOTHING` action is executed, meaning the insertion is skipped without raising an error or modifying the existing row.",
    "plsql": "CREATE OR REPLACE FUNCTION update_company_rank_on_insert() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"company\" SET \"Rank\" = (SELECT MAX(\"Rank_of_the_Year\") FROM \"station_company\" WHERE \"Company_ID\" = NEW.\"Company_ID\") WHERE \"Company_ID\" = NEW.\"Company_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER station_company_insert_trigger\n    AFTER INSERT ON \"station_company\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_company_rank_on_insert();\n\n-- Example insertion with conflict handling\nINSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\nVALUES (11, 1, 1)\nON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (12, 1, 2) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (13, 2, 3) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (14, 3, 4) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (15, 1, 5) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (16, 2, 6) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_company_rank_on_insert for the station_company table. For each new row, update the company table's Rank column for the matching Company_ID. Set Rank to the maximum Rank_of_the_Year from station_company for that Company_ID. Return NEW.",
    "natural_language": "Create AFTER INSERT trigger update_company_rank_on_insert for station_company. For new rows, set company.Rank to the max Rank_of_the_Year for that Company_ID from station_company. Return NEW.",
    "id": 295
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_station_company_on_station_delete that returns a trigger and is executed by a trigger named gas_station_delete_trigger, which is defined to fire BEFORE DELETE on the gas_station table for each individual row being deleted, where the function's logic performs a DELETE operation on the station_company table, specifically targeting all rows in the station_company table where the value in its Station_ID column is exactly equal to the value in the Station_ID column of the OLD record (which represents the gas_station row that is about to be deleted), and after the deletion, the function returns the OLD row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_station_company_on_station_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"station_company\" WHERE \"Station_ID\" = OLD.\"Station_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER gas_station_delete_trigger\n    BEFORE DELETE ON \"gas_station\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_station_company_on_station_delete();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM gas_station WHERE Station_ID = 1;",
      "DELETE FROM gas_station WHERE Station_ID = 2;",
      "DELETE FROM gas_station WHERE Station_ID = 3;",
      "DELETE FROM gas_station WHERE Station_ID = 4;",
      "DELETE FROM gas_station WHERE Station_ID = 5;"
    ],
    "summary": "Create a PostgreSQL trigger function named delete_station_company_on_station_delete that fires BEFORE DELETE on the gas_station table for each row. It deletes rows from the station_company table where Station_ID equals OLD.Station_ID and returns the OLD record.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called delete_station_company_on_station_delete? It should kick in BEFORE we delete a row from the gas_station table. For each row getting the axe, it's gotta clean up by deleting any matching rows in the station_company table where the Station_ID matches the OLD.Station_ID. Oh, and make sure it spits back the OLD record at the end.",
    "id": 296
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_company_sales_on_station_change that is executed automatically after an update operation on the Company_ID column of the station_company table for each affected row, which performs an update on the company table by increasing the Sales_billion column value by 10.5 specifically for the company whose Company_ID matches the new Company_ID value from the updated station_company row, using the NEW implicit record to access the new column values, and then returns the NEW row record to the calling trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION update_company_sales_on_station_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"company\" SET \"Sales_billion\" = \"Sales_billion\" + 10.5 WHERE \"Company_ID\" = NEW.\"Company_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER station_company_update_sales_trigger\n    AFTER UPDATE OF \"Company_ID\" ON \"station_company\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_company_sales_on_station_change();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "UPDATE station_company SET \"Company_ID\" = 2 WHERE \"Station_ID\" = 11;",
      "UPDATE station_company SET \"Company_ID\" = 1 WHERE \"Station_ID\" = 1;",
      "UPDATE station_company SET \"Company_ID\" = 3 WHERE \"Station_ID\" = 6;",
      "UPDATE station_company SET \"Company_ID\" = 2 WHERE \"Station_ID\" = 6;",
      "UPDATE station_company SET \"Company_ID\" = 1 WHERE \"Station_ID\" = 11;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_company_sales_on_station_change that fires AFTER UPDATE on the Company_ID column of the station_company table for each row. It updates the company table, increasing the Sales_billion column by 10.5 for the company where Company_ID equals NEW.Company_ID, and returns the NEW record.",
    "natural_language": "Alright, so we need a trigger function for PostgreSQL. Call it 'update_company_sales_on_station_change'. It should kick in AFTER we UPDATE the Company_ID in a row of the 'station_company' table. What it's gotta do is bump up the 'Sales_billion' column in the 'company' table by 10.5, but only for the company whose ID matches the NEW.Company_ID from the update. Oh, and at the end, just hand back that NEW record.",
    "id": 297
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `insert_default_company_for_station` that is designed to be executed as a trigger. This function takes no explicit input parameters but operates within the context of a trigger, meaning it has access to special record variables `NEW` and `OLD`. Specifically, it utilizes the `NEW` record, which represents the new row being inserted into the table that the trigger is associated with. The function is declared to return a `TRIGGER` type, which is a standard requirement for functions intended to be used as trigger functions in PostgreSQL. The core operation performed by this function is an `INSERT` statement into the table named `\"station_company\"`. This `INSERT` statement populates three columns: `\"Station_ID\"`, `\"Company_ID\"`, and `\"Rank_of_the_Year\"`. The value for the `\"Station_ID\"` column is derived from `NEW.\"Station_ID\"`, which refers to the value of the `\"Station_ID\"` column from the newly inserted row in the triggering table. The value for the `\"Company_ID\"` column is a static integer literal `1`. The value for the `\"Rank_of_the_Year\"` column is calculated dynamically. This calculation involves first extracting the year component from the current date using the `EXTRACT(YEAR FROM CURRENT_DATE)` function. From this current year, the value of `NEW.\"Open_Year\"` (the \"Open_Year\" column from the newly inserted row in the triggering table) is subtracted. Finally, `1` is added to this result. After performing this `INSERT` operation, the function returns the `NEW` record, which is a standard practice for `AFTER INSERT` triggers to indicate that the operation was successful and to pass the modified (or original) new row back to the calling context.\n\nFollowing the function definition, a trigger named `gas_station_insert_trigger` is created. This trigger is configured to activate `AFTER INSERT` operations on the table named `\"gas_station\"`. The `FOR EACH ROW` clause specifies that the trigger function `insert_default_company_for_station()` should be executed once for each row that is inserted into the `\"gas_station\"` table. The `EXECUTE FUNCTION insert_default_company_for_station()` clause specifies that the previously defined PL/pgSQL function `insert_default_company_for_station` should be invoked when the trigger fires. Therefore, whenever a new row is successfully inserted into the `\"gas_station\"` table, this trigger will automatically execute the `insert_default_company_for_station` function, which in turn inserts a corresponding record into the `\"station_company\"` table, linking the newly inserted gas station to a default company (Company_ID 1) and calculating a rank based on its opening year relative to the current year.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_default_company_for_station() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (NEW.\"Station_ID\", 1, EXTRACT(YEAR FROM CURRENT_DATE) - NEW.\"Open_Year\" + 1);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER gas_station_insert_trigger\n    AFTER INSERT ON \"gas_station\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_default_company_for_station();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (4, 2001, 'Central Park', 'John Doe', 'Jane Smith', 'Alice Johnson');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (5, 2002, 'Downtown', 'Michael Brown', 'Sarah Davis', 'Tom Wilson');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (6, 2003, 'Uptown', 'Chris Green', 'Laura White', 'Emma Thompson');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (7, 2004, 'Suburbia', 'David Black', 'Emily Clark', 'Oliver King');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (8, 2005, 'Industrial Area', 'Daniel Harris', 'Sophia Lewis', 'Liam Scott');"
    ],
    "summary": "Create a PostgreSQL trigger function named insert_default_company_for_station that fires AFTER INSERT on the gas_station table for each row. It inserts a row into the station_company table with Station_ID from NEW.Station_ID, Company_ID as 1, and Rank_of_the_Year calculated as (EXTRACT(YEAR FROM CURRENT_DATE) - NEW.Open_Year + 1), then returns the NEW record.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'insert_default_company_for_station'. This function is to be executed subsequent to an INSERT operation on the 'gas_station' table for each individual row. Its operation shall involve the insertion of a new record into the 'station_company' table. The values for this insertion are to be assigned as follows: the 'Station_ID' column shall receive the value from 'NEW.Station_ID'; the 'Company_ID' column shall be set to the integer 1; and the 'Rank_of_the_Year' column shall be derived from the calculation (EXTRACT(YEAR FROM CURRENT_DATE) - NEW.Open_Year + 1). Upon completion of this insertion, the function must return the 'NEW' record.",
    "id": 298
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `adjust_rank_on_year_change` that is designed to be executed in response to data modification events on a table. This function does not accept any explicit input parameters in its definition, but it operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` and `OLD` which represent the new and old row data, respectively, for the row that caused the trigger to fire. The function is declared to return `TRIGGER`, indicating that it is intended to be used as a trigger function. Upon execution, the function performs a single `UPDATE` operation on the table named `\"station_company\"`. This `UPDATE` statement modifies the value of the column named `\"Rank_of_the_Year\"` by incrementing its current value by `1`. This modification is applied only to rows where two conditions are simultaneously met: first, the value in the `\"Company_ID\"` column of the `\"station_company\"` table must be equal to the value of the `\"Company_ID\"` column from the `NEW` row (which represents the data of the row that triggered the event); and second, the current value in the `\"Rank_of_the_Year\"` column of the `\"station_company\"` table must be strictly less than `10`. After executing this `UPDATE` statement, the function concludes by returning the `NEW` row, which is a standard requirement for `BEFORE` or `AFTER` row-level triggers in PostgreSQL, allowing the modified or original row to be passed back to the calling statement.\n\nFollowing the definition of this trigger function, a trigger named `company_update_rank_adjust_trigger` is created. This trigger is configured to activate `AFTER` an `UPDATE` operation specifically on the column named `\"Rank\"` within the table named `\"company\"`. The `FOR EACH ROW` clause specifies that the trigger function `adjust_rank_on_year_change` will be executed once for every row that is affected by the `UPDATE` statement on the `\"company\"` table. The `EXECUTE FUNCTION adjust_rank_on_year_change()` clause specifies that the previously defined PL/pgSQL function `adjust_rank_on_year_change` should be invoked when the trigger fires. Therefore, whenever the `\"Rank\"` column of any row in the `\"company\"` table is updated, this trigger will activate, and for each updated row, the `adjust_rank_on_year_change` function will execute, attempting to increment the `\"Rank_of_the_Year\"` in the `\"station_company\"` table for the corresponding company, provided its rank is less than 10.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_rank_on_year_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"station_company\" SET \"Rank_of_the_Year\" = \"Rank_of_the_Year\" + 1 WHERE \"Company_ID\" = NEW.\"Company_ID\" AND \"Rank_of_the_Year\" < 10;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER company_update_rank_adjust_trigger\n    AFTER UPDATE OF \"Rank\" ON \"company\"\n    FOR EACH ROW\n    EXECUTE FUNCTION adjust_rank_on_year_change();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "UPDATE \"company\" SET \"Rank\" = 5 WHERE \"Company_ID\" = 1;",
      "UPDATE \"company\" SET \"Rank\" = 2 WHERE \"Company_ID\" = 3;",
      "UPDATE \"company\" SET \"Rank\" = 9 WHERE \"Company_ID\" = 2;",
      "UPDATE \"company\" SET \"Rank\" = 7 WHERE \"Company_ID\" = 1;",
      "UPDATE \"company\" SET \"Rank\" = 1 WHERE \"Company_ID\" = 3;"
    ],
    "summary": "Create a PostgreSQL trigger function named adjust_rank_on_year_change that fires AFTER UPDATE on the Rank column of the company table for each row. It updates the station_company table, incrementing Rank_of_the_Year by 1 for rows where Company_ID equals NEW.Company_ID and Rank_of_the_Year is less than 10, then returns the NEW record.",
    "natural_language": "Create a PostgreSQL trigger function called adjust_rank_on_year_change. Set it to fire AFTER an UPDATE on the Rank column of the company table for each row. Make it update the station_company table by incrementing Rank_of_the_Year by 1 for any row where Company_ID matches NEW.Company_ID and Rank_of_the_Year is below 10. Finally, have the function return the NEW record.",
    "id": 299
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after an update operation on the \"Championship\" table. This function, named update_championships, is designed to execute for each row that is updated. It checks if the new value of the \"Number_of_Championships\" column is greater than the old value of the same column. If this condition is met, the function updates the \"Joined\" column in the \"Championship\" table for the row where the \"Institution_ID\" matches the \"Institution_ID\" of the newly updated row. The \"Joined\" column is set to the current year, extracted from the current date and cast to a real number. The function then returns the new row data. The trigger, named update_championships_trigger, is associated with this function and is set to activate after any update operation on the \"Championship\" table, ensuring that the function is executed for each updated row.",
    "plsql": "CREATE OR REPLACE FUNCTION update_championships() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"Number_of_Championships\" > OLD.\"Number_of_Championships\" THEN\n    UPDATE \"Championship\" SET \"Joined\" = EXTRACT(YEAR FROM CURRENT_DATE)::real WHERE \"Institution_ID\" = NEW.\"Institution_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_championships_trigger\nAFTER UPDATE ON \"Championship\"\nFOR EACH ROW EXECUTE FUNCTION update_championships();",
    "database_name": "institution_sports",
    "tables": [
      "Championship"
    ],
    "call_sqls": [
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 2.0 WHERE \"Institution_ID\" = 1;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 1.5 WHERE \"Institution_ID\" = 2;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 3.0 WHERE \"Institution_ID\" = 3;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = \"Number_of_Championships\" + 1 WHERE \"Nickname\" = 'Terrapins';",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 5.0 WHERE \"Institution_ID\" = 2 AND \"Number_of_Championships\" < 5.0;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_championships that fires AFTER UPDATE on the Championship table for each row. If NEW.Number_of_Championships is greater than OLD.Number_of_Championships, it updates the Joined column in the Championship table to the current year (as a REAL) for the row where Institution_ID equals NEW.Institution_ID, then returns the NEW record.",
    "natural_language": "Set up a trigger function called update_championships that runs after changes to the Championship table. When the championship count goes up a bit, it should adjust the Joined date to something more recent for that institution's record, and then give back the updated row.",
    "id": 300
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Championship\" table. This function checks if a new row being inserted has an \"Institution_ID\" that already exists in the \"Championship\" table by performing a SELECT query to determine the existence of such an \"Institution_ID\". If a duplicate \"Institution_ID\" is found, the function returns NULL, preventing the insertion of the new row and thereby avoiding a violation of the unique constraint on \"Institution_ID\". If the \"Institution_ID\" is not a duplicate, the function then checks the \"Joined\" column of the new row to see if its value is less than 2000. If the \"Joined\" year is less than 2000, the function returns NULL, preventing the insertion of this \"old\" record. If neither condition is met, meaning the \"Institution_ID\" is unique and the \"Joined\" year is 2000 or later, the function returns the NEW row, allowing the insertion to proceed. The trigger named \"delete_old_records_trigger\" is created to execute this function for each row before an insert operation on the \"Championship\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_old_records() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if an entry with the same Institution_ID already exists.\n  -- If it does, and we are in a BEFORE INSERT trigger, returning NULL will prevent the new row from being inserted,\n  -- thus resolving the 'duplicate key value violates unique constraint' error.\n  IF EXISTS (SELECT 1 FROM \"Championship\" WHERE \"Institution_ID\" = NEW.\"Institution_ID\") THEN\n    RETURN NULL; -- Prevent insertion of duplicate Institution_ID\n  END IF;\n\n  -- If the Institution_ID is not a duplicate, proceed with the original logic:\n  -- If the 'Joined' year is less than 2000, prevent the insertion of this \"old\" record.\n  IF NEW.\"Joined\" < 2000 THEN\n    RETURN NULL; -- Prevent insertion of records with Joined < 2000\n  END IF;\n\n  -- If the Institution_ID is not a duplicate and 'Joined' year is 2000 or later,\n  -- allow the insertion of the new record.\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_old_records_trigger\nBEFORE INSERT ON \"Championship\"\nFOR EACH ROW EXECUTE FUNCTION delete_old_records();",
    "database_name": "institution_sports",
    "tables": [
      "Championship"
    ],
    "call_sqls": [
      "INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (101, 'New Team', 2005.0, 5.0);",
      "INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (102, 'Old Team', 1998.0, 2.0);",
      "INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (103, 'Another New Team', 2010.0, 1.0);",
      "INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (101, 'Duplicate Team', 2008.0, 3.0);",
      "INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\") VALUES (104, 'Recent Joiner', 2000.0, 0.0);"
    ],
    "summary": "Create a BEFORE INSERT trigger function for the \"Championship\" table. If the new row's \"Institution_ID\" already exists in the table, or if its \"Joined\" year is less than 2000, return NULL to prevent insertion. Otherwise, return the NEW row. Name the trigger \"delete_old_records_trigger\".",
    "natural_language": "Create a BEFORE INSERT trigger named \"delete_old_records_trigger\" for the \"Championship\" table. Make it return NULL to block the insertion if the new row's \"Institution_ID\" is already in the table or if its \"Joined\" year is before 2000. Otherwise, have it return the NEW row.",
    "id": 301
  },
  {
    "ir": "Write a PostgreSQL trigger function named reset_championships that returns a trigger and is executed by a trigger named reset_championships_trigger, which is defined to fire after each row is updated on the Championship table, where the function's logic is to check if the new value of the Number_of_Championships column for the updated row is greater than 10, and if this condition is true, it performs an update operation on the Championship table, setting the Number_of_Championships column to 0 for all rows in that table where the Institution_ID column matches the new Institution_ID value from the triggering update row, and the function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION reset_championships() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"Number_of_Championships\" > 10 THEN\n    UPDATE \"Championship\" SET \"Number_of_Championships\" = 0 WHERE \"Institution_ID\" = NEW.\"Institution_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER reset_championships_trigger\nAFTER UPDATE ON \"Championship\"\nFOR EACH ROW EXECUTE FUNCTION reset_championships();",
    "database_name": "institution_sports",
    "tables": [
      "Championship"
    ],
    "call_sqls": [
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 11 WHERE \"Institution_ID\" = 1;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 12 WHERE \"Institution_ID\" = 2;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 15 WHERE \"Institution_ID\" = 3;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 20 WHERE \"Institution_ID\" = 1;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 25 WHERE \"Institution_ID\" = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger function for the \"Championship\" table. If the updated row's \"Number_of_Championships\" exceeds 10, update all rows in the same table with the matching \"Institution_ID\" by setting their \"Number_of_Championships\" to 0. Return the NEW row. Name the trigger \"reset_championships_trigger\".",
    "natural_language": "Construct an AFTER UPDATE trigger function specifically for the \"Championship\" table. This function should, in a detailed manner, check if the recently updated record has a \"Number_of_Championships\" value that surpasses the threshold of 10. Should this condition be met, it must comprehensively update every single row within the same table that shares the identical \"Institution_ID\", meticulously resetting their \"Number_of_Championships\" values to zero. The function must ultimately return the NEW row, and the entire trigger should be formally named \"reset_championships_trigger\".",
    "id": 302
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after an update operation on the \"Customer_Events\" table. This function checks if a combination of \"resident_id\", \"property_id\", and \"date_moved_in\" from the updated row exists in the \"Residents\" table. If such a combination exists, it inserts a new record into the \"Customer_Event_Notes\" table with the columns \"Customer_Event_ID\", \"service_type_code\", \"resident_id\", \"property_id\", and \"date_moved_in\", where \"Customer_Event_ID\" is taken from the updated row, \"service_type_code\" is set to the string 'Update', and the other columns are populated with the corresponding values from the updated row. If the combination does not exist in the \"Residents\" table, the function raises a warning message indicating that the insertion of the \"Customer_Event_Note\" is being skipped due to the absence of the specified resident combination in the \"Residents\" table. The function then returns the updated row. The trigger associated with this function is named \"trg_update_customer_event_note\" and is defined to execute the function for each row after an update operation on the \"Customer_Events\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_customer_event_note() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the resident, property, and date_moved_in combination exists in the Residents table\n  -- This prevents a foreign key violation if Customer_Event_Notes also references Residents\n  -- and the NEW values from Customer_Events are not valid in Residents.\n  -- Note: The provided error indicates the UPDATE on Customer_Events itself failed due to an FK violation.\n  -- An AFTER UPDATE trigger would not execute in that case.\n  -- This check is a safeguard for the INSERT into Customer_Event_Notes, assuming it might also have a similar FK.\n  IF EXISTS (SELECT 1 FROM \"Residents\"\n             WHERE \"resident_id\" = NEW.\"resident_id\"\n               AND \"property_id\" = NEW.\"property_id\"\n               AND \"date_moved_in\" = NEW.\"date_moved_in\") THEN\n    INSERT INTO \"Customer_Event_Notes\" (\"Customer_Event_ID\", \"service_type_code\", \"resident_id\", \"property_id\", \"date_moved_in\")\n    VALUES (NEW.\"Customer_Event_ID\", 'Update', NEW.\"resident_id\", NEW.\"property_id\", NEW.\"date_moved_in\");\n  ELSE\n    -- If the resident combination does not exist, we can choose to:\n    -- 1. Do nothing (skip logging this event note)\n    -- 2. Log a warning (as shown below)\n    -- 3. Raise an exception (which would roll back the parent transaction, if the trigger was BEFORE)\n    RAISE WARNING 'Skipping Customer_Event_Note insertion: Resident (resident_id: %, property_id: %, date_moved_in: %) not found in \"Residents\" table.',\n                  NEW.\"resident_id\", NEW.\"property_id\", NEW.\"date_moved_in\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_customer_event_note\nAFTER UPDATE ON \"Customer_Events\"\nFOR EACH ROW EXECUTE FUNCTION update_customer_event_note();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Customer_Event_Notes",
      "Residents",
      "Properties",
      "Residents_Services",
      "Services",
      "Organizations"
    ],
    "call_sqls": [
      "UPDATE \"Customer_Events\" SET property_id = 605 WHERE \"Customer_Event_ID\" = 70;",
      "UPDATE \"Customer_Events\" SET resident_id = 23, property_id = 879, date_moved_in = '2015-03-27 12:00:00+08:00' WHERE \"Customer_Event_ID\" = 160;",
      "UPDATE \"Customer_Events\" SET date_moved_in = '2017-06-17 15:43:33+08:00' WHERE resident_id = 10;",
      "UPDATE \"Customer_Events\" SET property_id = 954 WHERE property_id = 605 AND resident_id = 10;",
      "UPDATE \"Customer_Events\" SET resident_id = 6, property_id = 954, date_moved_in = '2017-06-17 15:43:33+08:00' WHERE \"Customer_Event_ID\" = 166;"
    ],
    "summary": "Create an AFTER UPDATE trigger function for the \"Customer_Events\" table. If the updated row's combination of \"resident_id\", \"property_id\", and \"date_moved_in\" exists in the \"Residents\" table, insert a corresponding record into the \"Customer_Event_Notes\" table with a 'Update' service_type_code. If it does not exist, raise a warning. Return the updated row. Name the trigger \"trg_update_customer_event_note\".",
    "natural_language": "Alright, so we need a trigger that fires after an update on the \"Customer_Events\" table. Here's the deal: when a row gets updated, check if its resident_id, property_id, and date_moved_in combo is already hanging out in the \"Residents\" table. If it is, pop a new record into \"Customer_Event_Notes\" and set the service_type_code to 'Update'. If that combo isn't there, just throw up a warning. Oh, and make sure the trigger spits back the updated row. Let's call this trigger \"trg_update_customer_event_note\".",
    "id": 303
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `delete_customer_event_note` that is designed to be executed in response to a data manipulation event on a specific table, and a trigger named `trg_delete_customer_event_note` that is configured to activate this function. The `delete_customer_event_note` function is defined to return a value of type `TRIGGER`, indicating its role as a trigger function. Upon its execution, the function performs a single operation: it deletes rows from the table named `\"Customer_Event_Notes\"`. The deletion is conditional, targeting only those rows where the value in the column named `\"Customer_Event_ID\"` within the `\"Customer_Event_Notes\"` table is equal to the value of the `\"Customer_Event_ID\"` column from the row that initiated the trigger event. This initiating row is represented by the special `OLD` record variable, which holds the data of the row *before* the triggering DELETE operation occurred. After performing this deletion, the function returns the `OLD` record, which is a standard requirement for `BEFORE` or `AFTER` row-level triggers in PostgreSQL, though in this specific `AFTER DELETE` context, the return value of `OLD` is typically ignored by the system. The `trg_delete_customer_event_note` trigger is defined to activate `AFTER DELETE` operations on the table named `\"Customer_Events\"`. This means that the trigger will fire immediately after a row has been successfully deleted from the `\"Customer_Events\"` table. The trigger is configured to execute `FOR EACH ROW`, ensuring that the `delete_customer_event_note` function is invoked once for every individual row that is deleted from the `\"Customer_Events\"` table. When activated, the trigger executes the `delete_customer_event_note()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_customer_event_note() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Customer_Event_Notes\" WHERE \"Customer_Event_ID\" = OLD.\"Customer_Event_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_customer_event_note\nAFTER DELETE ON \"Customer_Events\"\nFOR EACH ROW EXECUTE FUNCTION delete_customer_event_note();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Customer_Event_Notes",
      "Residents",
      "Properties",
      "Residents_Services",
      "Services",
      "Organizations"
    ],
    "call_sqls": [
      "DELETE FROM \"Customer_Events\" WHERE \"Customer_Event_ID\" = 70;",
      "DELETE FROM \"Customer_Events\" WHERE \"customer_id\" = 19;",
      "DELETE FROM \"Customer_Events\" WHERE \"property_id\" = 605;",
      "DELETE FROM \"Customer_Events\" WHERE \"resident_id\" = 10;",
      "DELETE FROM \"Customer_Events\" WHERE \"Customer_Event_ID\" IN (160, 166);"
    ],
    "summary": "Create an AFTER DELETE trigger function for the \"Customer_Events\" table. For each deleted row, delete all rows from the \"Customer_Event_Notes\" table where the \"Customer_Event_ID\" matches the OLD record's ID. Return the OLD row. Name the trigger \"trg_delete_customer_event_note\".",
    "natural_language": "How can I create an AFTER DELETE trigger function named \"trg_delete_customer_event_note\" for the \"Customer_Events\" table that, for each deleted row, deletes all matching rows from the \"Customer_Event_Notes\" table and returns the OLD row?",
    "id": 304
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_property_details that returns a trigger, which is automatically executed by a trigger named trg_update_property_details defined on the \"Residents\" table to fire after every update operation for each modified row, and within the function body, it performs an update on the \"Properties\" table, specifically setting the other_details column to the uppercase transformation of the NEW.other_details value from the triggering update on \"Residents\", but only for the row in the \"Properties\" table where the property_id column exactly matches the NEW.property_id value from the updated \"Residents\" row, and finally the function returns the NEW row record to the trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION update_property_details() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Properties\" SET other_details = UPPER(NEW.other_details) WHERE property_id = NEW.property_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_property_details\nAFTER UPDATE ON \"Residents\"\nFOR EACH ROW EXECUTE FUNCTION update_property_details();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customers",
      "Customer_Events",
      "Customer_Event_Notes",
      "Residents",
      "Properties",
      "Residents_Services",
      "Services",
      "Organizations"
    ],
    "call_sqls": [
      "UPDATE \"Residents\" SET other_details = 'Updated details' WHERE resident_id = 6;",
      "UPDATE \"Residents\" SET property_id = 605, other_details = 'New resident info' WHERE resident_id = 10;",
      "UPDATE \"Residents\" SET date_moved_out = '2024-01-01 00:00:00+08:00', other_details = 'Moving out details' WHERE resident_id = 23;",
      "UPDATE \"Residents\" SET other_details = NULL WHERE resident_id = 28;",
      "UPDATE \"Residents\" SET other_details = 'Special case with lowercase text' WHERE property_id = 879;"
    ],
    "summary": "Create an AFTER UPDATE trigger function for the \"Residents\" table. For each updated row, update the \"Properties\" table by setting the \"other_details\" column to UPPER(NEW.other_details) where the \"property_id\" matches the NEW value from \"Residents\". Return the NEW row. Name the trigger \"trg_update_property_details\".",
    "natural_language": "Alright, so we need a trigger that fires off after someone updates the \"Residents\" table. Every time a row gets changed, we gotta hop over to the \"Properties\" table and update its \"other_details\" column. Set it to the uppercase version of the NEW.other_details from the resident, but only for the property where the IDs match up. The trigger should spit back the NEW row. Oh, and let's call this trigger \"trg_update_property_details\".",
    "id": 305
  },
  {
    "ir": "Write a PL/pgSQL function named `update_manufacturer_on_price_change` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD` representing the new and old row data, respectively. The function's purpose is to modify the `Manufacturer` column in the `\"Products\"` table. Specifically, it performs an `UPDATE` operation on the `\"Products\"` table. The `UPDATE` statement targets rows where the value in the `\"Price\"` column is strictly greater than the value of the `\"Price\"` column in the `NEW` row (the row that triggered the update). For each such identified row, the `Manufacturer` column is updated by incrementing its current value by `1`. After executing this update, the function returns the `NEW` row, which is standard behavior for `BEFORE` or `AFTER` row-level triggers in PostgreSQL, indicating that the modified row should be used for subsequent operations or committed to the table.\n\nFollowing this function definition, a trigger named `trg_update_manufacturer_on_price_change` is created. This trigger is configured to activate `AFTER UPDATE OF \"Price\"` on the `\"Products\"` table. This means the trigger will fire immediately after an `UPDATE` statement successfully modifies the `\"Price\"` column of any row in the `\"Products\"` table. The `FOR EACH ROW` clause specifies that the trigger function `update_manufacturer_on_price_change()` will be executed once for each row that is affected by the `UPDATE` statement on the `\"Products\"` table where the `\"Price\"` column has been changed. The `EXECUTE FUNCTION update_manufacturer_on_price_change()` clause specifies that the previously defined PL/pgSQL function `update_manufacturer_on_price_change` is the routine to be executed when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION update_manufacturer_on_price_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Products\" SET \"Manufacturer\" = \"Manufacturer\" + 1 WHERE \"Price\" > NEW.\"Price\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_manufacturer_on_price_change\nAFTER UPDATE OF \"Price\" ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION update_manufacturer_on_price_change();",
    "database_name": "manufactory_1",
    "tables": [
      "Products"
    ],
    "call_sqls": [
      "UPDATE \"Products\" SET \"Price\" = 100 WHERE \"Code\" = 1;",
      "UPDATE \"Products\" SET \"Price\" = 130 WHERE \"Code\" = 2;",
      "UPDATE \"Products\" SET \"Price\" = 160 WHERE \"Code\" = 3;",
      "UPDATE \"Products\" SET \"Price\" = 110 WHERE \"Code\" = 1;",
      "UPDATE \"Products\" SET \"Price\" = 140 WHERE \"Code\" = 2;"
    ],
    "summary": "Create a trigger function named update_manufacturer_on_price_change that, after a row's Price is updated in the Products table, increments the Manufacturer by 1 for all other rows where the Price is greater than the new row's Price. Return the NEW row. Create an AFTER UPDATE OF \"Price\" trigger named trg_update_manufacturer_on_price_change to execute this function for each updated row.",
    "natural_language": "Please implement a trigger function designated as 'update_manufacturer_on_price_change'. This function shall be invoked subsequent to any modification of the 'Price' column within a row of the 'Products' table. Its operation is to increase the 'Manufacturer' value by one for all other records in the table where the 'Price' exceeds the updated row's new 'Price'. The function must return the NEW row. Furthermore, establish an AFTER UPDATE trigger, specifically on the \"Price\" column, named 'trg_update_manufacturer_on_price_change', to execute the aforementioned function for each individual row that is updated.",
    "id": 306
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_default_product that is executed automatically after each new row is inserted into the Products table; this function takes no direct parameters but receives the newly inserted row data via the special NEW record variable, which contains columns Code (integer or numeric), Name (text), Price (numeric), and Manufacturer (text). The function's logic begins by evaluating a conditional IF statement that checks whether the value of the newly inserted row's Code column is numerically less than 100; if this condition is true, the function performs an INSERT operation into the same Products table, creating a new row with the following column values: for the Code column, it uses the value of the new row's Code plus 100 (NEW.Code + 100), for the Name column it sets the literal string 'Default Product', for the Price column it sets the numeric value 99.99, and for the Manufacturer column it uses the value from the new row's Manufacturer column (NEW.Manufacturer). After this conditional insert, the function returns the NEW row record to the trigger mechanism, allowing the original insert operation to complete normally. The trigger itself, named trg_insert_default_product, is defined to fire AFTER INSERT on the Products table for EACH ROW and executes the insert_default_product function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_default_product() RETURNS TRIGGER AS $$\nBEGIN\n    -- Insert a default product only if the Code is less than a certain value to prevent recursion\n    IF NEW.\"Code\" < 100 THEN\n        INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (NEW.\"Code\" + 100, 'Default Product', 99.99, NEW.\"Manufacturer\");\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_default_product\nAFTER INSERT ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION insert_default_product();",
    "database_name": "manufactory_1",
    "tables": [
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (1, 'Test Product 1', 10.00, 1);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (50, 'Test Product 2', 20.00, 2);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (99, 'Test Product 3', 30.00, 3);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (100, 'Test Product 4', 40.00, 4);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (150, 'Test Product 5', 50.00, 5);"
    ],
    "summary": "Create a trigger function named insert_default_product that, after a row is inserted into the Products table, inserts a new 'Default Product' row with a Code of NEW.Code + 100, a Price of 99.99, and the same Manufacturer, but only if the inserted row's Code is less than 100. Return the NEW row. Create an AFTER INSERT trigger named trg_insert_default_product to execute this function for each inserted row.",
    "natural_language": "After a row is inserted into the Products table, how can I create a trigger function named insert_default_product that inserts a new 'Default Product' row with a Code of NEW.Code + 100, a Price of 99.99, and the same Manufacturer, but only if the inserted row's Code is less than 100, and then returns the NEW row? Furthermore, how do I create an AFTER INSERT trigger named trg_insert_default_product to execute this function for each inserted row?",
    "id": 307
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the deletion of a row from the \"Products\" table, deletes all other rows in the same table where the \"Manufacturer\" column matches the \"Manufacturer\" value of the deleted row, but the \"Code\" column does not match the \"Code\" value of the deleted row. The function returns the OLD row data, which is the row being deleted. This function is associated with a trigger named trg_delete_related_products, which is set to execute before a row is deleted from the \"Products\" table. The trigger ensures that whenever a row is deleted, the function is called to perform the specified deletion of related products.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_products() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Products\" WHERE \"Manufacturer\" = OLD.\"Manufacturer\" AND \"Code\" != OLD.\"Code\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_related_products\nBEFORE DELETE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION delete_related_products();",
    "database_name": "manufactory_1",
    "tables": [
      "Products"
    ],
    "call_sqls": [
      "DELETE FROM \"Products\" WHERE \"Code\" = 1;",
      "DELETE FROM \"Products\" WHERE \"Code\" = 2;",
      "DELETE FROM \"Products\" WHERE \"Manufacturer\" = 5;",
      "DELETE FROM \"Products\" WHERE \"Name\" = 'ZIP drive';",
      "DELETE FROM \"Products\" WHERE \"Price\" = 120;"
    ],
    "summary": "Create a trigger function that, before a row is deleted from the Products table, deletes all other rows from the same table that have the same Manufacturer but a different Code than the deleted row. Return the OLD row. Create a BEFORE DELETE trigger named trg_delete_related_products to execute this function for each deleted row.",
    "natural_language": "Alright, so before we zap a product from the Products table, we gotta set up a trigger function. This function's job is to find and delete any other products from the same manufacturer that have a different product code than the one being removed. After that cleanup, it should hand back the OLD row data. Then, hook up a BEFORE DELETE trigger, call it trg_delete_related_products, to run this function for every row that gets deleted.",
    "id": 308
  },
  {
    "ir": "Write a PostgreSQL trigger function named adjust_price_based_on_name_length that is executed automatically by a trigger named trg_adjust_price_based_on_name_length before every insert operation on the Products table for each individual new row, where the function performs a single operation that multiplies the value of the new row's Price column by the integer result of the LENGTH function applied to the new row's Name column, which calculates the number of characters in the Name string, and then assigns this calculated product back to the new row's Price column before the row is inserted, and finally returns the modified NEW row record to the triggering mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_price_based_on_name_length() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Price\" := NEW.\"Price\" * LENGTH(NEW.\"Name\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_adjust_price_based_on_name_length\nBEFORE INSERT ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION adjust_price_based_on_name_length();",
    "database_name": "manufactory_1",
    "tables": [
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (10, 'Monitor', 200, 1);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (11, 'Keyboard', 50, 2);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (12, 'Mouse', 25, 3);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (13, 'Webcam', 75, 4);",
      "INSERT INTO \"Products\" (\"Code\", \"Name\", \"Price\", \"Manufacturer\") VALUES (14, 'Printer', 150, 5);"
    ],
    "summary": "Create a trigger function named adjust_price_based_on_name_length that, before a row is inserted into the Products table, multiplies the new row's Price by the length of its Name and assigns the result back to the Price column. Return the modified NEW row. Create a BEFORE INSERT trigger named trg_adjust_price_based_on_name_length to execute this function for each inserted row.",
    "natural_language": "Alright, so before you add a new product to the list, we need a little automatic price tweak. Set up a trigger function called adjust_price_based_on_name_length. What it does is pretty simple: when a new row is about to be inserted into the Products table, it takes the product's name, checks how long it is, and multiplies the original price by that number of characters. Then it slaps that new calculated price right back into the Price column. Don't forget to have the function spit out the updated NEW row. Finally, hook that function up with a BEFORE INSERT trigger named trg_adjust_price_based_on_name_length so it runs for every single new item you add.",
    "id": 309
  },
  {
    "ir": "Write a PL/pgSQL function named `update_club_leader` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, receiving special `NEW` and `OLD` records representing the new and old row values, respectively, for the row that activated the trigger. The function's primary purpose is to update the `Team_Leader` column in the `club` table. It performs an `UPDATE` operation on the `club` table. The `Team_Leader` column is set to a value retrieved by a subquery. This subquery `SELECT`s the `Name` column from the `member` table. The condition for this subquery is `WHERE \"Member_ID\" = NEW.\"Member_ID\"`, meaning it retrieves the `Name` of the member whose `Member_ID` matches the `Member_ID` from the `NEW` record (the newly inserted or updated row that fired the trigger). The `UPDATE` operation on the `club` table is conditional, applying only `WHERE \"Club_ID\" = NEW.\"Club_ID\"`, which means it updates the `club` record whose `Club_ID` matches the `Club_ID` from the `NEW` record. After performing this update, the function `RETURN`s the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers in PostgreSQL.\n\nAdditionally, define a trigger named `club_leader_update_trigger`. This trigger is configured to activate `AFTER INSERT` operations on the `club_leader` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is inserted into the `club_leader` table. When activated, this trigger `EXECUTE`s the `update_club_leader()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_club_leader() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE club \n  SET \"Team_Leader\" = (SELECT \"Name\" FROM member WHERE \"Member_ID\" = NEW.\"Member_ID\")\n  WHERE \"Club_ID\" = NEW.\"Club_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER club_leader_update_trigger\nAFTER INSERT ON club_leader\nFOR EACH ROW EXECUTE FUNCTION update_club_leader();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1984, '2024');",
      "INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (3, 1985, '2024');",
      "INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (4, 1986, '2024');",
      "INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1985, '2024');",
      "INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (8, 1984, '2024');"
    ],
    "summary": "Create a trigger function named update_club_leader that, after a row is inserted into the club_leader table, updates the Team_Leader column in the club table. Set the Team_Leader to the Name from the member table where Member_ID matches the new row's Member_ID, but only for the club record where Club_ID matches the new row's Club_ID. Return the NEW row. Create an AFTER INSERT trigger named club_leader_update_trigger to execute this function for each inserted row.",
    "natural_language": "Alright, so we need a trigger function called update_club_leader. Basically, whenever someone adds a new entry to the club_leader table, this function should kick in. What it does is go and update the Team_Leader field over in the club table. It should grab the Name from the member table for the new Member_ID that just got added, but only for the specific club where the Club_ID matches. Don't forget to return the NEW row. Then, set up an AFTER INSERT trigger named club_leader_update_trigger to run this function for every new row that pops in.",
    "id": 310
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the member table. The function, named remove_club_leader, takes no parameters and is designed to remove a corresponding entry from the club_leader table. Specifically, it deletes a row from the club_leader table where the Member_ID column matches the Member_ID value of the row being deleted from the member table. The function returns the OLD record, which represents the row that is about to be deleted from the member table. The trigger, named member_delete_trigger, is associated with the member table and is set to fire before a delete operation on each row, ensuring that the remove_club_leader function is executed for every row deletion in the member table.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_club_leader() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM club_leader WHERE \"Member_ID\" = OLD.\"Member_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER member_delete_trigger\nBEFORE DELETE ON member\nFOR EACH ROW EXECUTE FUNCTION remove_club_leader();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "DELETE FROM member WHERE \"Member_ID\" = 1984;",
      "DELETE FROM member WHERE \"Member_ID\" = 1985;",
      "DELETE FROM member WHERE \"Member_ID\" = 1988;",
      "DELETE FROM member WHERE \"Member_ID\" = 1986;",
      "DELETE FROM member WHERE \"Member_ID\" = 1987;"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named member_delete_trigger on the member table. It executes a function named remove_club_leader that deletes the corresponding row from the club_leader table where Member_ID matches the OLD.Member_ID. The function returns the OLD record.",
    "natural_language": "Create a BEFORE DELETE row-level trigger called member_delete_trigger on the member table. This trigger should execute the remove_club_leader function, which deletes the matching row from the club_leader table using the OLD.Member_ID, and then returns the OLD record.",
    "id": 311
  },
  {
    "ir": "Write a PLpgSQL function named update_cmi_details_on_cross_ref_insert that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It updates the Customer_Master_Index table by setting the cmi_details column to a string that begins with 'Cross Reference - ' followed by the current time obtained from the timeofday() function, for the row where the master_customer_id column matches the master_customer_id value of the newly inserted row in the CMI_Cross_References table. The function returns the newly inserted row, allowing the trigger to proceed with its operation. The function is associated with a trigger named trg_update_cmi_details_cross_ref, which is defined to execute after an insert operation on the CMI_Cross_References table. This trigger is set to fire for each row that is inserted, ensuring that the update operation in the Customer_Master_Index table is performed for every new entry in the CMI_Cross_References table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_cmi_details_on_cross_ref_insert() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Customer_Master_Index\" SET \"cmi_details\" = 'Cross Reference - ' || timeofday() WHERE \"master_customer_id\" = NEW.\"master_customer_id\";\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_cmi_details_cross_ref\nAFTER INSERT ON \"CMI_Cross_References\"\nFOR EACH ROW\nEXECUTE FUNCTION update_cmi_details_on_cross_ref_insert();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "INSERT INTO \"CMI_Cross_References\" (\"cmi_cross_ref_id\", \"master_customer_id\", \"source_system_code\") VALUES (200, 1, 'Rent');",
      "INSERT INTO \"CMI_Cross_References\" (\"cmi_cross_ref_id\", \"master_customer_id\", \"source_system_code\") VALUES (201, 2, 'Parking');",
      "INSERT INTO \"CMI_Cross_References\" (\"cmi_cross_ref_id\", \"master_customer_id\", \"source_system_code\") VALUES (202, 3, 'CouncilTax');",
      "INSERT INTO \"CMI_Cross_References\" (\"cmi_cross_ref_id\", \"master_customer_id\", \"source_system_code\") VALUES (203, 4, 'Benefits');",
      "INSERT INTO \"CMI_Cross_References\" (\"cmi_cross_ref_id\", \"master_customer_id\", \"source_system_code\") VALUES (204, 5, 'Electoral');"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_update_cmi_details_cross_ref on the CMI_Cross_References table. It executes a function named update_cmi_details_on_cross_ref_insert that updates the Customer_Master_Index table. It sets cmi_details to 'Cross Reference - ' concatenated with timeofday() for the row where master_customer_id matches NEW.master_customer_id. The function returns the NEW record.",
    "natural_language": "Construct an AFTER INSERT row-level trigger, which should be named trg_update_cmi_details_cross_ref, specifically for the CMI_Cross_References table. This trigger is designed to meticulously invoke a function called update_cmi_details_on_cross_ref_insert. The primary and detailed purpose of this function is to perform an update on the Customer_Master_Index table. It carefully sets the cmi_details column to a dynamically constructed string that begins with the descriptive phrase 'Cross Reference - ' and is then seamlessly concatenated with the precise, current timestamp provided by the timeofday() function. This update is applied exclusively to the row where the master_customer_id field perfectly matches the NEW.master_customer_id value from the recently inserted record. Finally, the function is programmed to thoughtfully return the complete NEW record.",
    "id": 312
  },
  {
    "ir": "Write a PostgreSQL trigger function named delete_cross_ref_on_customer_delete that returns a trigger and is executed by a trigger named trg_delete_cross_ref_customer, which is defined to fire BEFORE DELETE on the Customer_Master_Index table for each row. The function declares a local variable cmi_ids of type BIGINT array. The function first performs a SELECT query on the CMI_Cross_References table, using the ARRAY_AGG aggregate function to collect all cmi_cross_ref_id column values where the master_customer_id column equals the OLD.master_customer_id value from the row being deleted from Customer_Master_Index, storing the result into the cmi_ids variable. If the cmi_ids array is not NULL and its length is greater than zero, the function executes a series of DELETE operations: it deletes rows from the Rent_Arrears table where the cmi_cross_ref_id column matches any element in the cmi_ids array using the ANY operator, then performs identical deletions from the Benefits_Overpayments table, the Business_Rates table, the Council_Tax table, the Electoral_Register table, and the Parking_Fines table, each using the condition WHERE cmi_cross_ref_id = ANY(cmi_ids). After these conditional deletions, the function deletes all rows from the CMI_Cross_References table where the master_customer_id column equals OLD.master_customer_id. Finally, the function returns the OLD row record.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_cross_ref_on_customer_delete() RETURNS TRIGGER AS $$\nDECLARE\n    cmi_ids BIGINT[];\nBEGIN\n    -- Collect all cmi_cross_ref_id values associated with the master_customer_id being deleted\n    SELECT ARRAY_AGG(cmi_cross_ref_id)\n    INTO cmi_ids\n    FROM \"CMI_Cross_References\"\n    WHERE \"master_customer_id\" = OLD.\"master_customer_id\";\n\n    -- Delete from all child tables that reference CMI_Cross_References\n    IF cmi_ids IS NOT NULL AND ARRAY_LENGTH(cmi_ids, 1) > 0 THEN\n        DELETE FROM \"Rent_Arrears\" WHERE \"cmi_cross_ref_id\" = ANY(cmi_ids);\n        DELETE FROM \"Benefits_Overpayments\" WHERE \"cmi_cross_ref_id\" = ANY(cmi_ids);\n        DELETE FROM \"Business_Rates\" WHERE \"cmi_cross_ref_id\" = ANY(cmi_ids);\n        DELETE FROM \"Council_Tax\" WHERE \"cmi_cross_ref_id\" = ANY(cmi_ids);\n        DELETE FROM \"Electoral_Register\" WHERE \"cmi_cross_ref_id\" = ANY(cmi_ids);\n        DELETE FROM \"Parking_Fines\" WHERE \"cmi_cross_ref_id\" = ANY(cmi_ids);\n    END IF;\n\n    -- Now delete from CMI_Cross_References\n    DELETE FROM \"CMI_Cross_References\" WHERE \"master_customer_id\" = OLD.\"master_customer_id\";\n\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_cross_ref_customer\nBEFORE DELETE ON \"Customer_Master_Index\"\nFOR EACH ROW\nEXECUTE FUNCTION delete_cross_ref_on_customer_delete();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "DELETE FROM \"Customer_Master_Index\" WHERE \"master_customer_id\" = 1;",
      "DELETE FROM \"Customer_Master_Index\" WHERE \"master_customer_id\" = 2;",
      "DELETE FROM \"Customer_Master_Index\" WHERE \"master_customer_id\" = 3;",
      "DELETE FROM \"Customer_Master_Index\" WHERE \"master_customer_id\" = 4;",
      "DELETE FROM \"Customer_Master_Index\" WHERE \"master_customer_id\" = 5;"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_delete_cross_ref_customer on the Customer_Master_Index table. It executes a function named delete_cross_ref_on_customer_delete. The function first aggregates all cmi_cross_ref_id values from CMI_Cross_References for the OLD.master_customer_id into an array. If the array is not empty, it deletes rows from Rent_Arrears, Benefits_Overpayments, Business_Rates, Council_Tax, Electoral_Register, and Parking_Fines tables where cmi_cross_ref_id matches any value in the array. Then it deletes all rows from CMI_Cross_References for the OLD.master_customer_id. The function returns the OLD record.",
    "natural_language": "Please implement a BEFORE DELETE row-level trigger designated as trg_delete_cross_ref_customer on the Customer_Master_Index table. This trigger shall invoke the function delete_cross_ref_on_customer_delete. The function's operation is as follows: initially, it aggregates all cmi_cross_ref_id values associated with the OLD.master_customer_id from the CMI_Cross_References table into an array. Should the array contain elements, the function proceeds to delete corresponding records from the Rent_Arrears, Benefits_Overpayments, Business_Rates, Council_Tax, Electoral_Register, and Parking_Fines tables where the cmi_cross_ref_id matches any value within the aforementioned array. Subsequently, it deletes all rows pertaining to the OLD.master_customer_id from the CMI_Cross_References table. The function concludes by returning the OLD record.",
    "id": 313
  },
  {
    "ir": "Write a PLpgSQL trigger function that updates the Customer_Master_Index table by setting the cmi_details column to a string that begins with 'Business Rates - ' followed by the current time obtained from the timeofday() function, for the row where the master_customer_id matches the master_customer_id retrieved from the CMI_Cross_References table. This retrieval is based on the condition where the cmi_cross_ref_id in the CMI_Cross_References table equals the cmi_cross_ref_id of the newly inserted row in the Business_Rates table. The trigger, named trg_update_cmi_details_business_rates, is set to execute this function after each row is inserted into the Business_Rates table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_cmi_details_on_business_rates_insert() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Customer_Master_Index\" SET \"cmi_details\" = 'Business Rates - ' || timeofday() WHERE \"master_customer_id\" = (SELECT \"master_customer_id\" FROM \"CMI_Cross_References\" WHERE \"cmi_cross_ref_id\" = NEW.\"cmi_cross_ref_id\");\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_cmi_details_business_rates\nAFTER INSERT ON \"Business_Rates\"\nFOR EACH ROW\nEXECUTE FUNCTION update_cmi_details_on_business_rates_insert();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "INSERT INTO \"Business_Rates\" (business_rates_id, cmi_cross_ref_id) VALUES (1, 99);",
      "INSERT INTO \"Business_Rates\" (business_rates_id, cmi_cross_ref_id) VALUES (2, 49);",
      "INSERT INTO \"Business_Rates\" (business_rates_id, cmi_cross_ref_id) VALUES (3, 95);",
      "INSERT INTO \"Business_Rates\" (business_rates_id, cmi_cross_ref_id) VALUES (4, 1);",
      "INSERT INTO \"Business_Rates\" (business_rates_id, cmi_cross_ref_id) VALUES (5, 2);"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_update_cmi_details_business_rates on the Business_Rates table. It executes a function that updates the Customer_Master_Index table. It sets cmi_details to 'Business Rates - ' concatenated with timeofday() for the row where master_customer_id matches the master_customer_id retrieved from CMI_Cross_References, based on NEW.cmi_cross_ref_id.",
    "natural_language": "Make a trigger that fires after a new entry is added to the Business_Rates table. It should call a routine to adjust some details in the Customer_Master_Index. Basically, for the relevant customer record, it combines 'Business Rates - ' with the current timestamp. You'll need to figure out which customer by looking up the new cross-reference ID in another table.",
    "id": 314
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `update_cmi_details_on_electoral_insert` that is designed to be executed after an `INSERT` operation on the `\"Electoral_Register\"` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the new and old row data, respectively. The primary purpose of this function is to update a specific column in the `\"Customer_Master_Index\"` table. Specifically, it performs an `UPDATE` operation on the `\"Customer_Master_Index\"` table, setting the value of its `\"cmi_details\"` column. The new value for `\"cmi_details\"` is constructed by concatenating the literal string 'Electoral Register - ' with the current time of day, obtained by calling the `timeofday()` function. This update is conditional, applying only to rows in `\"Customer_Master_Index\"` where the `\"master_customer_id\"` column matches a value retrieved from the `\"CMI_Cross_References\"` table. The `\"master_customer_id\"` for this comparison is found by executing a subquery that selects `\"master_customer_id\"` from `\"CMI_Cross_References\"` where the `\"cmi_cross_ref_id\"` column in `\"CMI_Cross_References\"` is equal to the `\"cmi_cross_ref_id\"` of the newly inserted row in the `\"Electoral_Register\"` table (accessed via `NEW.\"cmi_cross_ref_id\"`). After performing this update, the function returns the `NEW` record, which is standard behavior for `AFTER` row-level triggers in PostgreSQL, indicating that the inserted row should be processed as usual.\n\nFollowing the definition of this function, a trigger named `trg_update_cmi_details_electoral` is created. This trigger is configured to activate `AFTER INSERT` operations on the `\"Electoral_Register\"` table. It is a `FOR EACH ROW` trigger, meaning that the associated function, `update_cmi_details_on_electoral_insert()`, will be executed once for every single row that is inserted into the `\"Electoral_Register\"` table. The trigger's action is to `EXECUTE FUNCTION update_cmi_details_on_electoral_insert()`, thereby invoking the previously defined PL/pgSQL function to perform the described update on the `\"Customer_Master_Index\"` table for each new electoral registration.",
    "plsql": "CREATE OR REPLACE FUNCTION update_cmi_details_on_electoral_insert() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Customer_Master_Index\" SET \"cmi_details\" = 'Electoral Register - ' || timeofday() WHERE \"master_customer_id\" = (SELECT \"master_customer_id\" FROM \"CMI_Cross_References\" WHERE \"cmi_cross_ref_id\" = NEW.\"cmi_cross_ref_id\");\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_cmi_details_electoral\nAFTER INSERT ON \"Electoral_Register\"\nFOR EACH ROW\nEXECUTE FUNCTION update_cmi_details_on_electoral_insert();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "INSERT INTO \"Electoral_Register\" (\"electoral_register_id\", \"cmi_cross_ref_id\") VALUES (1001, 83);",
      "INSERT INTO \"Electoral_Register\" (\"electoral_register_id\", \"cmi_cross_ref_id\") VALUES (1002, 65);",
      "INSERT INTO \"Electoral_Register\" (\"electoral_register_id\", \"cmi_cross_ref_id\") VALUES (1003, 100);",
      "INSERT INTO \"Electoral_Register\" (\"electoral_register_id\", \"cmi_cross_ref_id\") VALUES (1004, 8);",
      "INSERT INTO \"Electoral_Register\" (\"electoral_register_id\", \"cmi_cross_ref_id\") VALUES (1005, 41);"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_update_cmi_details_electoral on the Electoral_Register table. It executes a function named update_cmi_details_on_electoral_insert. The function updates the Customer_Master_Index table, setting cmi_details to 'Electoral Register - ' concatenated with timeofday() for the row where master_customer_id matches the master_customer_id retrieved from CMI_Cross_References using NEW.cmi_cross_ref_id. The function returns the NEW record.",
    "natural_language": "Create an AFTER INSERT row-level trigger called trg_update_cmi_details_electoral on the Electoral_Register table. This trigger should execute the function update_cmi_details_on_electoral_insert. The function must update the Customer_Master_Index table by setting the cmi_details field to 'Electoral Register - ' combined with the current time from timeofday(). Perform this update for the row where the master_customer_id matches the master_customer_id found in the CMI_Cross_References table using the NEW.cmi_cross_ref_id from the inserted record. Ensure the function returns the NEW record.",
    "id": 315
  },
  {
    "ir": "Write a PL/pgSQL function named `update_song_title` that is designed to be executed as a trigger function, returning a `TRIGGER` type. This function's primary purpose is to insert a new record into the `\"Songs\"` table. Specifically, it inserts a value into the `\"SongId\"` column, which is derived from the `NEW.\"SongId\"` pseudo-record variable. The `NEW` pseudo-record variable represents the new row that is being inserted or updated in the table on which the trigger is defined. Concurrently, it inserts a value into the `\"Title\"` column of the `\"Songs\"` table. This title is constructed by concatenating the literal string 'Performance for ' with the value of `NEW.\"StagePosition\"`, which is another column from the `NEW` pseudo-record variable. After performing this insertion, the function returns the `NEW` pseudo-record variable, indicating that the row that triggered this function should proceed with its original operation. This function is then associated with a trigger named `performance_song_trigger`. This trigger is configured to activate `AFTER INSERT` operations on the `\"Performance\"` table. It is a `FOR EACH ROW` trigger, meaning it will execute the `update_song_title()` function once for every row that is inserted into the `\"Performance\"` table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_song_title() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (NEW.\"SongId\", CONCAT('Performance for ', NEW.\"StagePosition\"));\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER performance_song_trigger\nAFTER INSERT ON \"Performance\"\nFOR EACH ROW EXECUTE FUNCTION update_song_title();",
    "database_name": "music_2",
    "tables": [
      "Band",
      "Songs",
      "Instruments",
      "Performance",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1001, 5, 'Center Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1002, 3, 'Left Side');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1003, 7, 'Right Side');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1004, 2, 'Back Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1005, 1, 'Front Center');"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named update_song_title that inserts a new row into the \"Songs\" table. Set \"SongId\" to NEW.\"SongId\" and \"Title\" to 'Performance for ' concatenated with NEW.\"StagePosition\". Return NEW. Associate this function with a trigger named performance_song_trigger on the \"Performance\" table.",
    "natural_language": "Alright, so I need you to whip up a trigger that fires off after a new row is added to the \"Performance\" table. Let's call the trigger function \"update_song_title\". What this baby does is, for each new row, it pops a fresh entry into the \"Songs\" table. For that new song entry, take the \"SongId\" straight from the NEW row's \"SongId\", and for the \"Title\", just slap 'Performance for ' in front of whatever's in NEW.\"StagePosition\". Once that's done, just hand back the NEW row. Oh, and don't forget to hook this function up to a trigger on the \"Performance\" table—name that trigger \"performance_song_trigger\".",
    "id": 316
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_bandmate_instrument that returns a trigger, which is automatically executed by a database trigger named performance_instrument_trigger after every insert operation on the Performance table for each new row, where the function's logic performs a single insert operation into the Instruments table, specifying the columns SongId, BandmateId, and Instrument, and populating them with values derived from the newly inserted row in the Performance table, specifically taking the NEW.SongId value for the SongId column, the NEW.Bandmate value for the BandmateId column, and the literal string constant 'Unknown' for the Instrument column, before concluding by returning the NEW row record to the calling trigger context.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_bandmate_instrument() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Instruments\" (\"SongId\", \"BandmateId\", \"Instrument\") VALUES (NEW.\"SongId\", NEW.\"Bandmate\", 'Unknown');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER performance_instrument_trigger\nAFTER INSERT ON \"Performance\"\nFOR EACH ROW EXECUTE FUNCTION insert_bandmate_instrument();",
    "database_name": "music_2",
    "tables": [
      "Band",
      "Songs",
      "Instruments",
      "Performance",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1, 101, 'Center Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (2, 102, 'Left Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (3, 103, 'Right Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (4, 104, 'Back Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (5, 105, 'Front Stage');"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named insert_bandmate_instrument that inserts a new row into the Instruments table. Set SongId to NEW.SongId, BandmateId to NEW.Bandmate, and Instrument to 'Unknown'. Return NEW. Associate this function with a trigger named performance_instrument_trigger on the Performance table.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger function designated as 'insert_bandmate_instrument'. This function shall insert a new record into the Instruments table, assigning the SongId column the value of NEW.SongId, the BandmateId column the value of NEW.Bandmate, and the Instrument column the static value 'Unknown'. The function must conclude by returning the NEW record. Subsequently, associate this function with a trigger named 'performance_instrument_trigger' on the Performance table.",
    "id": 317
  },
  {
    "ir": "Write a PostgreSQL trigger function named add_vocal_record that returns a trigger and is executed by a trigger named performance_vocal_trigger, which is defined to fire automatically after every INSERT operation on the \"Performance\" table for each newly inserted row; the function's logic performs a single INSERT operation into the \"Vocals\" table, specifying three column values: it sets the \"SongId\" column to the value of the NEW.\"SongId\" field from the triggering row inserted into \"Performance\", sets the \"Bandmate\" column to the value of the NEW.\"Bandmate\" field from the same triggering row, and sets the \"Type\" column to the literal string value 'Backup'; the function concludes by returning the NEW row record to the invoking trigger mechanism.",
    "plsql": "CREATE OR REPLACE FUNCTION add_vocal_record() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Vocals\" (\"SongId\", \"Bandmate\", \"Type\") VALUES (NEW.\"SongId\", NEW.\"Bandmate\", 'Backup');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER performance_vocal_trigger\nAFTER INSERT ON \"Performance\"\nFOR EACH ROW EXECUTE FUNCTION add_vocal_record();",
    "database_name": "music_2",
    "tables": [
      "Band",
      "Songs",
      "Instruments",
      "Performance",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1, 101, 'Center');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (2, 102, 'Left');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (3, 103, 'Right');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (4, 104, 'Back');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (5, 105, 'Front');"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named add_vocal_record that inserts a new row into the \"Vocals\" table. Set \"SongId\" to NEW.\"SongId\", \"Bandmate\" to NEW.\"Bandmate\", and \"Type\" to 'Backup'. Return NEW. Associate this function with a trigger named performance_vocal_trigger on the \"Performance\" table.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger function designated as 'add_vocal_record'. This function shall insert a new entry into the \"Vocals\" table, assigning the \"SongId\" column the value of NEW.\"SongId\", the \"Bandmate\" column the value of NEW.\"Bandmate\", and the \"Type\" column the fixed value 'Backup'. The function must conclude by returning NEW. Subsequently, associate this function with a trigger named 'performance_vocal_trigger' on the \"Performance\" table.",
    "id": 318
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the \"Performance\" table, automatically inserts a new row into the \"Band\" table. This new row in the \"Band\" table will have its \"Id\" column set to the value of the \"Bandmate\" column from the newly inserted row in the \"Performance\" table. The \"Firstname\" column of the new \"Band\" row will be set to the string 'Unknown', and the \"Lastname\" column will be set to the string 'Musician'. The trigger is named \"performance_band_trigger\" and is defined to execute the \"create_band_record\" function after each row is inserted into the \"Performance\" table. The function does not take any parameters and returns the newly inserted row in the \"Performance\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION create_band_record() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Band\" (\"Id\", \"Firstname\", \"Lastname\") VALUES (NEW.\"Bandmate\", 'Unknown', 'Musician');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER performance_band_trigger\nAFTER INSERT ON \"Performance\"\nFOR EACH ROW EXECUTE FUNCTION create_band_record();",
    "database_name": "music_2",
    "tables": [
      "Band",
      "Songs",
      "Instruments",
      "Performance",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1, 101, 'Center Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (2, 102, 'Left Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (3, 103, 'Right Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (4, 104, 'Back Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (5, 105, 'Front Stage');"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named create_band_record that inserts a new row into the \"Band\" table. Set \"Id\" to NEW.\"Bandmate\", \"Firstname\" to 'Unknown', and \"Lastname\" to 'Musician'. Return NEW. Associate this function with a trigger named performance_band_trigger on the \"Performance\" table.",
    "natural_language": "Create trigger performance_band_trigger on Performance. After insert, run create_band_record. It inserts into Band: Id from NEW.Bandmate, Firstname 'Unknown', Lastname 'Musician'. Return NEW.",
    "id": 319
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `insert_teacher_to_list` that is designed to be executed in response to specific database events, and a trigger named `add_teacher_to_list` that invokes this function. The `insert_teacher_to_list` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. When this function is executed, it performs a single `INSERT` operation. This `INSERT` operation targets a table named `\"list\"`. The `INSERT` statement populates four specific columns within the `\"list\"` table: `\"LastName\"`, `\"FirstName\"`, `\"Grade\"`, and `\"Classroom\"`. The values inserted into these columns are derived from the `NEW` pseudo-record, which represents the new row being inserted into the table that activated the trigger. Specifically, the value for the `\"LastName\"` column in the `\"list\"` table is taken directly from the `\"LastName\"` column of the `NEW` record. Similarly, the value for the `\"FirstName\"` column in the `\"list\"` table is taken directly from the `\"FirstName\"` column of the `NEW` record. For the `\"Grade\"` column in the `\"list\"` table, a static integer value of `0` is inserted. Finally, the value for the `\"Classroom\"` column in the `\"list\"` table is taken directly from the `\"Classroom\"` column of the `NEW` record. After performing this `INSERT` operation, the function concludes by returning the `NEW` record, which is a standard requirement for `BEFORE` and `AFTER` row-level triggers in PostgreSQL, though in this specific `AFTER` trigger context, the return value is often ignored. The `add_teacher_to_list` trigger is defined to activate `AFTER INSERT` operations on a table named `\"teachers\"`. This means the trigger will execute its associated function after a new row has been successfully inserted into the `\"teachers\"` table. The trigger is specified as `FOR EACH ROW`, indicating that the trigger function `insert_teacher_to_list` will be executed once for every single row that is inserted into the `\"teachers\"` table. The `EXECUTE FUNCTION insert_teacher_to_list()` clause specifies that the `insert_teacher_to_list` function is the routine to be executed when the trigger fires.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_teacher_to_list() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") \n    VALUES (NEW.\"LastName\", NEW.\"FirstName\", 0, NEW.\"Classroom\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER add_teacher_to_list\n    AFTER INSERT ON \"teachers\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_teacher_to_list();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") VALUES ('DOE', 'JOHN', 101);",
      "INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") VALUES ('SMITH', 'JANE', 102);",
      "INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") VALUES ('BROWN', 'PETER', 103);",
      "INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") VALUES ('WHITE', 'ALICE', 104);",
      "INSERT INTO teachers (\"LastName\", \"FirstName\", \"Classroom\") VALUES ('BLACK', 'BOB', 105);"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named insert_teacher_to_list that inserts a new row into the \"list\" table. Set \"LastName\" to NEW.\"LastName\", \"FirstName\" to NEW.\"FirstName\", \"Grade\" to 0, and \"Classroom\" to NEW.\"Classroom\". Return NEW. Associate this function with a trigger named add_teacher_to_list on the \"teachers\" table.",
    "natural_language": "Construct an AFTER INSERT FOR EACH ROW trigger function, which should be named insert_teacher_to_list, to meticulously insert a fresh record into the designated \"list\" table. For this new entry, you must carefully assign the \"LastName\" column using the NEW.\"LastName\" value, populate the \"FirstName\" column with the NEW.\"FirstName\" value, deliberately set the \"Grade\" column to a default value of 0, and finally, fill the \"Classroom\" column with the value from NEW.\"Classroom\". The function must conclusively return the NEW record. Subsequently, you need to formally associate this comprehensive function with a specifically named trigger, called add_teacher_to_list, which will be actively monitoring the \"teachers\" table for any new insertions.",
    "id": 320
  },
  {
    "ir": "Write a PLpgSQL trigger function that is executed after a row is deleted from the \"teachers\" table. This function, named archive_teacher, takes no parameters and is designed to archive information about the deleted teacher into the \"list\" table. Specifically, it inserts a new row into the \"list\" table with the following values: the \"LastName\" column is set to the concatenation of the string 'ARCHIVED_' and the deleted row's \"LastName\" value, the \"FirstName\" column is set to the deleted row's \"FirstName\" value, the \"Grade\" column is set to 0, and the \"Classroom\" column is set to the deleted row's \"Classroom\" value. The function then returns the OLD record, which represents the deleted row from the \"teachers\" table. The trigger, named archive_teacher_on_delete, is defined to automatically execute this function after any row is deleted from the \"teachers\" table, ensuring that each deletion results in the corresponding archival action.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_teacher() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"list\" (\"LastName\", \"FirstName\", \"Grade\", \"Classroom\") \n    VALUES ('ARCHIVED_' || OLD.\"LastName\", OLD.\"FirstName\", 0, OLD.\"Classroom\"); -- Changed OLD.\"Grade\" to 0\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER archive_teacher_on_delete\n    AFTER DELETE ON \"teachers\"\n    FOR EACH ROW\n    EXECUTE FUNCTION archive_teacher();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "DELETE FROM \"teachers\" WHERE \"LastName\" = 'MACROSTIE' AND \"FirstName\" = ' MIN';",
      "DELETE FROM \"teachers\" WHERE \"LastName\" = 'COVIN' AND \"FirstName\" = ' JEROME';",
      "DELETE FROM \"teachers\" WHERE \"LastName\" = 'MOYER' AND \"FirstName\" = ' OTHA';",
      "DELETE FROM \"teachers\" WHERE \"Classroom\" = 101;",
      "DELETE FROM \"teachers\" WHERE \"Classroom\" IN (102, 103);"
    ],
    "summary": "Create an AFTER DELETE trigger on the teachers table named archive_teacher_on_delete. The trigger executes a function named archive_teacher that inserts a row into the list table. The inserted row uses the OLD record's values: set LastName to 'ARCHIVED_' concatenated with OLD.LastName, FirstName to OLD.FirstName, Grade to 0, and Classroom to OLD.Classroom. The function should return the OLD record.",
    "natural_language": "Please implement an AFTER DELETE trigger on the teachers table, designated as archive_teacher_on_delete. This trigger must invoke a function named archive_teacher. The function's operation is to insert a new record into the list table. For this insertion, the following values from the OLD record should be used: the LastName column shall be populated with the string 'ARCHIVED_' prefixed to the OLD.LastName value; the FirstName column shall receive the OLD.FirstName value; the Grade column shall be set to the integer 0; and the Classroom column shall be assigned the OLD.Classroom value. The function is required to return the OLD record.",
    "id": 321
  }
]