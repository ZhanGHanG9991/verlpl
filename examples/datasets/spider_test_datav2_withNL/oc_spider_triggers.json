[
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_architect_update` that is activated `AFTER` an `UPDATE` operation is performed on the `ARCHITECT` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `ARCHITECT` table. Upon activation, the trigger evaluates the `GENDER` column of the newly updated row, referenced as `:NEW.GENDER`.\n\nThe trigger's logic proceeds as follows:\n1. **Conditional Branch 1 (Female Gender):** If the value of `:NEW.GENDER` is exactly equal to the string literal `'female'` (case-sensitive comparison), then an `UPDATE` statement is executed on the `BRIDGE` table. This `UPDATE` statement sets the `NAME` column of the `BRIDGE` table to the string literal `'Updated Bridge'`. The `WHERE` clause of this `UPDATE` statement specifies that only rows in the `BRIDGE` table where the `ARCHITECT_ID` column matches the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`) will be affected.\n\n2. **Conditional Branch 2 (Male Gender):** If the first condition is not met (i.e., `:NEW.GENDER` is not `'female'`), the trigger then checks if the value of `:NEW.GENDER` is exactly equal to the string literal `'male'` (case-sensitive comparison). If this condition is true, then an `UPDATE` statement is executed on the `MILL` table. This `UPDATE` statement sets the `TYPE` column of the `MILL` table to the string literal `'Updated Type'`. The `WHERE` clause of this `UPDATE` statement specifies that only rows in the `MILL` table where the `ARCHITECT_ID` column matches the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`) will be affected.\n\n3. **Conditional Branch 3 (Other Genders):** If neither of the preceding conditions is met (i.e., `:NEW.GENDER` is neither `'female'` nor `'male'`), then an `INSERT` statement is executed to add a new row into the `MILL` table. The values for the columns in the new row are provided as follows:\n    * `ARCHITECT_ID`: Set to the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`).\n    * `ID`: Set to a randomly generated integer value. This value is obtained by calling the `DBMS_RANDOM.VALUE` function, which generates a random number between 1000 (inclusive) and 2000 (exclusive). The `FLOOR` function is then applied to this random number to round it down to the nearest whole integer.\n    * `LOCATION`: Set to the string literal `'Unknown'`.\n    * `NAME`: Set to the string literal `'New Mill'`.\n    * `TYPE`: Set to the string literal `'Type A'`.\n    * `BUILT_YEAR`: Set to the integer literal `2023`.\n    * `NOTES`: Set to the string literal `'Notes'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_architect_update\nAFTER UPDATE ON ARCHITECT\nFOR EACH ROW\nBEGIN\n  IF :NEW.GENDER = 'female' THEN\n    UPDATE BRIDGE SET NAME = 'Updated Bridge' WHERE ARCHITECT_ID = :NEW.ID;\n  ELSIF :NEW.GENDER = 'male' THEN\n    UPDATE MILL SET TYPE = 'Updated Type' WHERE ARCHITECT_ID = :NEW.ID;\n  ELSE\n    INSERT INTO MILL (ARCHITECT_ID, ID, LOCATION, NAME, TYPE, BUILT_YEAR, NOTES)\n    VALUES (:NEW.ID, FLOOR(DBMS_RANDOM.VALUE(1000, 2000)), 'Unknown', 'New Mill', 'Type A', 2023, 'Notes');\n  END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "UPDATE ARCHITECT SET GENDER = 'female' WHERE ID = '1'",
      "UPDATE ARCHITECT SET GENDER = 'male' WHERE ID = '2'",
      "UPDATE ARCHITECT SET GENDER = 'unknown' WHERE ID = '3'",
      "UPDATE ARCHITECT SET GENDER = 'female' WHERE ID = '4'",
      "UPDATE ARCHITECT SET GENDER = 'male' WHERE ID = '5'"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_architect_update on the ARCHITECT table. If :NEW.GENDER is 'female', update the BRIDGE table's NAME to 'Updated Bridge' where ARCHITECT_ID = :NEW.ID. If :NEW.GENDER is 'male', update the MILL table's TYPE to 'Updated Type' where ARCHITECT_ID = :NEW.ID. Otherwise, insert a new row into the MILL table with ARCHITECT_ID = :NEW.ID, a random ID between 1000 and 2000, LOCATION as 'Unknown', NAME as 'New Mill', TYPE as 'Type A', BUILT_YEAR as 2023, and NOTES as 'Notes'.",
    "natural_language": "Alright, so set up a trigger called trg_architect_update on the ARCHITECT table that fires after each row gets updated. Here's the deal: if the new gender is 'female', then go ahead and change the NAME in the BRIDGE table to 'Updated Bridge' for any rows where the ARCHITECT_ID matches the new ID. If the new gender is 'male', then update the TYPE in the MILL table to 'Updated Type' where the ARCHITECT_ID matches. For any other gender, just pop a fresh row into the MILL table. For that new row, use the new ID for ARCHITECT_ID, whip up a random ID between 1000 and 2000, set LOCATION to 'Unknown', NAME to 'New Mill', TYPE to 'Type A', BUILT_YEAR to 2023, and NOTES to 'Notes'.",
    "id": 1
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `book_pages_check` that is designed to execute automatically before an `INSERT` operation or an `UPDATE` operation on the `PAGES` column of the `BOOK` table. This trigger is a `FOR EACH ROW` trigger, meaning it will execute once for each row affected by the `INSERT` or `UPDATE` statement. The trigger includes a `WHEN` clause, `(NEW.PAGES IS NOT NULL)`, which specifies a condition that must be true for the trigger body to execute; specifically, the value of the `PAGES` column in the new or updated row (`:NEW.PAGES`) must not be `NULL`. Inside the trigger's `BEGIN...END` block, there is a conditional statement (`IF :NEW.PAGES < 1 THEN`) that checks if the value of the `PAGES` column in the new or updated row (`:NEW.PAGES`) is less than the numeric literal `1`. If this condition evaluates to `TRUE`, the trigger will invoke the `RAISE_APPLICATION_ERROR` procedure, which is a built-in Oracle PL/SQL procedure used to raise a user-defined error. This procedure is called with two arguments: the error number `-20003` (a negative integer within the range -20000 to -20999, indicating a user-defined error) and the error message string `'Pages must be greater than zero'`. This action effectively prevents the `INSERT` or `UPDATE` operation from completing if the `PAGES` value is less than `1`, enforcing a business rule that the number of pages in a book must be a positive integer.",
    "plsql": "CREATE OR REPLACE TRIGGER book_pages_check\nBEFORE INSERT OR UPDATE OF PAGES ON BOOK\nFOR EACH ROW\nWHEN (NEW.PAGES IS NOT NULL)\nBEGIN\n    IF :NEW.PAGES < 1 THEN\n        RAISE_APPLICATION_ERROR(-20003, 'Pages must be greater than zero');\n    END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "INSERT INTO BOOK (BOOK_ID, TITLE, TYPE, PAGES, CHAPTERS, AUDIO, RELEASE) VALUES (4, 'The Winds of Winter', 'Novel', 800, 80, '40h 00m', 'TBD')",
      "INSERT INTO BOOK (BOOK_ID, TITLE, TYPE, PAGES, CHAPTERS, AUDIO, RELEASE) VALUES (5, 'A Dream of Spring', 'Novel', 900, 90, '45h 00m', 'TBD')",
      "UPDATE BOOK SET PAGES = 750 WHERE BOOK_ID = 1",
      "UPDATE BOOK SET PAGES = 1000 WHERE BOOK_ID = 3",
      "INSERT INTO BOOK (BOOK_ID, TITLE, TYPE, PAGES, CHAPTERS, AUDIO, RELEASE) VALUES (6, 'Invalid Book', 'Novel', 0, 10, '5h 00m', '2023')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named book_pages_check on the BOOK table for the PAGES column, with a WHEN condition (NEW.PAGES IS NOT NULL). If :NEW.PAGES < 1, raise application error -20003 with message 'Pages must be greater than zero'.",
    "natural_language": "How do you create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named book_pages_check on the BOOK table for the PAGES column, with a WHEN condition of NEW.PAGES IS NOT NULL, so that if :NEW.PAGES is less than 1, it raises application error -20003 with the message 'Pages must be greater than zero'?",
    "id": 2
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_conference_participation` that is activated `AFTER` an `INSERT` operation occurs on the `CONFERENCE_PARTICIPATION` table. This trigger is defined to execute `FOR EACH ROW` that is inserted into the `CONFERENCE_PARTICIPATION` table. Upon activation for each inserted row, the trigger performs a single `INSERT` operation into the `STAFF` table. The `INSERT` statement populates the `STAFF` table with specific values for its columns: the `STAFF_ID` column is populated with the value of the `STAFF_ID` column from the newly inserted row in the `CONFERENCE_PARTICIPATION` table, referenced as `:NEW.STAFF_ID`; the `NAME` column is populated with the literal string value 'New Staff'; the `AGE` column is populated with the literal numeric value 30; the `NATIONALITY` column is populated with the literal string value 'Unknown'; and the `INSTITUTION_ID` column is populated with the literal numeric value 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_conference_participation\nAFTER INSERT ON CONFERENCE_PARTICIPATION\nFOR EACH ROW\nBEGIN\n  INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID)\n  VALUES (:NEW.STAFF_ID, 'New Staff', 30, 'Unknown', 1);\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE) VALUES (1, 100, 'Speaker')",
      "INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE) VALUES (2, 101, 'Attendee')",
      "INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE) VALUES (3, 102, 'Sponsor')",
      "INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE) VALUES (1, 103, 'Organizer')",
      "INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE) VALUES (2, 104, 'Presenter')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_conference_participation on the CONFERENCE_PARTICIPATION table. For each inserted row, insert into the STAFF table with STAFF_ID = :NEW.STAFF_ID, NAME = 'New Staff', AGE = 30, NATIONALITY = 'Unknown', and INSTITUTION_ID = 1.",
    "natural_language": "Set up a trigger on the CONFERENCE_PARTICIPATION table that runs after new entries are added. For each new record, it should also put a corresponding entry into the STAFF table. Use the new record's staff ID for the STAFF_ID, and for the other details, just fill in some reasonable default values like a generic name, a typical age, a placeholder nationality, and a common institution ID.",
    "id": 3
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_conference_year that is defined to fire automatically after any row in the CONFERENCE table is updated, and for each individual row that is updated, the trigger executes a single UPDATE operation on the INSTITUTION table, setting the value of the FOUNDED column to the new value of the YEAR column from the updated CONFERENCE row, but only for the specific row in the INSTITUTION table where the INSTITUTION_ID column has a value of exactly 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_conference_year\nAFTER UPDATE ON CONFERENCE\nFOR EACH ROW\nBEGIN\n  UPDATE INSTITUTION SET FOUNDED = :NEW.YEAR WHERE INSTITUTION_ID = 1;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE CONFERENCE SET YEAR = 2024 WHERE CONFERENCE_ID = 1",
      "UPDATE CONFERENCE SET YEAR = 2025, LOCATION = 'Germany' WHERE CONFERENCE_NAME = 'ACL'",
      "UPDATE CONFERENCE SET YEAR = YEAR + 1 WHERE YEAR = 2003",
      "UPDATE CONFERENCE SET YEAR = 2030 WHERE CONFERENCE_ID = 2",
      "UPDATE CONFERENCE SET LOCATION = 'France', YEAR = 2026 WHERE CONFERENCE_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_conference_year on the CONFERENCE table. For each updated row, update the INSTITUTION table's FOUNDED column to :NEW.YEAR where INSTITUTION_ID = 1.",
    "natural_language": "Set up a trigger on the CONFERENCE table that runs after updates. For each row that gets changed, it should adjust the FOUNDED date in the INSTITUTION table for a certain main institution to match the new conference year.",
    "id": 4
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_staff that is executed automatically after a DELETE operation is performed on the STAFF table. This trigger operates for each row affected by the DELETE statement. Within the trigger's body, it performs a DELETE operation on the CONFERENCE_PARTICIPATION table, specifically targeting rows where the STAFF_ID column matches the value of the STAFF_ID column from the deleted row in the STAFF table, which is accessed using the :OLD prefix to refer to the old values of the row being deleted. The purpose of this trigger is to ensure that any records in the CONFERENCE_PARTICIPATION table associated with the deleted staff member are also removed, maintaining referential integrity between the STAFF and CONFERENCE_PARTICIPATION tables by eliminating orphaned records that no longer have a corresponding staff member in the STAFF table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_staff\nAFTER DELETE ON STAFF\nFOR EACH ROW\nBEGIN\n  DELETE FROM CONFERENCE_PARTICIPATION WHERE STAFF_ID = :OLD.STAFF_ID;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "DELETE FROM STAFF WHERE STAFF_ID = 1",
      "DELETE FROM STAFF WHERE STAFF_ID = 2",
      "DELETE FROM STAFF WHERE STAFF_ID = 3",
      "DELETE FROM STAFF WHERE NAME = 'Bobby Jackson'",
      "DELETE FROM STAFF WHERE INSTITUTION_ID = 1"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_delete_staff on the STAFF table. For each deleted row, delete from the CONFERENCE_PARTICIPATION table where STAFF_ID = :OLD.STAFF_ID to maintain referential integrity.",
    "natural_language": "Construct an AFTER DELETE FOR EACH ROW trigger, which should be named trg_delete_staff, on the STAFF table. For every single row that is subsequently removed, it is essential to meticulously delete any corresponding entries from the CONFERENCE_PARTICIPATION table precisely where the STAFF_ID matches the :OLD.STAFF_ID value, thereby ensuring that referential integrity is consistently and reliably maintained.",
    "id": 5
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_institution` that is activated `AFTER` an `INSERT` operation occurs on the `INSTITUTION` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `INSTITUTION` table. The trigger declares a local PL/SQL variable named `v_max_conference_id` of data type `NUMBER` to temporarily store a calculated maximum conference identifier. Upon activation, the trigger first executes a `SELECT` statement to retrieve the maximum value from the `CONFERENCE_ID` column of the `CONFERENCE` table. It uses the `NVL` function to handle cases where no rows exist in the `CONFERENCE` table or `CONFERENCE_ID` is `NULL`, in which case `0` is used as the default value. This retrieved maximum value (or `0` if no rows or `NULL`s are found) is then incremented by `1` to generate a new, unique `CONFERENCE_ID`. The result of this calculation is stored into the `v_max_conference_id` variable. Subsequently, the trigger performs an `INSERT` operation into the `CONFERENCE` table. It inserts a new row with the following column values: the `CONFERENCE_ID` column is populated with the value stored in `v_max_conference_id`; the `CONFERENCE_NAME` column is set to the literal string `'New Conference'`; the `YEAR` column is set to the literal numeric value `2023`; and the `LOCATION` column is populated with the value of the `LOCATION` column from the newly inserted row in the `INSTITUTION` table, which is referenced using the `:NEW.LOCATION` pseudorecord.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_institution\nAFTER INSERT ON INSTITUTION\nFOR EACH ROW\nDECLARE\n  v_max_conference_id NUMBER;\nBEGIN\n  SELECT NVL(MAX(CONFERENCE_ID), 0) + 1 \n  INTO v_max_conference_id \n  FROM CONFERENCE;\n  \n  INSERT INTO CONFERENCE (CONFERENCE_ID, CONFERENCE_NAME, YEAR, LOCATION)\n  VALUES (v_max_conference_id, 'New Conference', 2023, :NEW.LOCATION);\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO INSTITUTION (INSTITUTION_ID, INSTITUTION_NAME, LOCATION, FOUNDED) VALUES (4, 'University of Chicago', 'Chicago, Illinois', 1890)",
      "INSERT INTO INSTITUTION (INSTITUTION_ID, INSTITUTION_NAME, LOCATION, FOUNDED) VALUES (5, 'Northwestern University', 'Evanston, Illinois', 1851)",
      "INSERT INTO INSTITUTION (INSTITUTION_ID, INSTITUTION_NAME, LOCATION, FOUNDED) VALUES (6, 'DePaul University', 'Chicago, Illinois', 1898)",
      "INSERT INTO INSTITUTION (INSTITUTION_ID, INSTITUTION_NAME, LOCATION, FOUNDED) VALUES (7, 'Loyola University Chicago', 'Chicago, Illinois', 1870)",
      "INSERT INTO INSTITUTION (INSTITUTION_ID, INSTITUTION_NAME, LOCATION, FOUNDED) VALUES (8, 'Southern Illinois University', 'Carbondale, Illinois', 1869)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_institution on the INSTITUTION table. It calculates a new CONFERENCE_ID by taking the maximum existing CONFERENCE_ID from the CONFERENCE table (defaulting to 0 if none exist) and adding 1. It then inserts a new row into the CONFERENCE table using this new ID, the string 'New Conference' for CONFERENCE_NAME, the number 2023 for YEAR, and the :NEW.LOCATION value for LOCATION.",
    "natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger called trg_insert_institution on the INSTITUTION table that calculates a new CONFERENCE_ID by adding 1 to the highest existing CONFERENCE_ID from the CONFERENCE table (or uses 0 if none exist), and then inserts a new row into the CONFERENCE table with this new ID, 'New Conference' as the CONFERENCE_NAME, 2023 as the YEAR, and the :NEW.LOCATION value for LOCATION?",
    "id": 6
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_staff_age that is defined to fire automatically after any row in the STAFF table is updated, executing once for each row that is modified, and within its body performs an update operation on the CONFERENCE_PARTICIPATION table, specifically setting the ROLE column to the literal string value 'Updated Role' for every row in that table where the STAFF_ID column matches the new value of the STAFF_ID column from the updated row in the STAFF table, which is accessed via the :NEW.STAFF_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_staff_age\nAFTER UPDATE ON STAFF\nFOR EACH ROW\nBEGIN\n  UPDATE CONFERENCE_PARTICIPATION SET ROLE = 'Updated Role' WHERE STAFF_ID = :NEW.STAFF_ID;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE STAFF SET AGE = 25 WHERE STAFF_ID = 1",
      "UPDATE STAFF SET AGE = AGE + 1 WHERE STAFF_ID = 2",
      "UPDATE STAFF SET NATIONALITY = 'United Kingdom', AGE = 43 WHERE STAFF_ID = 3",
      "UPDATE STAFF SET INSTITUTION_ID = 2 WHERE STAFF_ID = 4",
      "UPDATE STAFF SET NAME = 'Robert Jackson' WHERE STAFF_ID = 1"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_staff_age on the STAFF table. For each updated staff row, it updates the CONFERENCE_PARTICIPATION table, setting the ROLE column to 'Updated Role' for all rows where the STAFF_ID matches the :NEW.STAFF_ID from the updated staff row.",
    "natural_language": "Make an AFTER UPDATE trigger trg_update_staff_age on STAFF. When a staff row updates, set ROLE to 'Updated Role' in CONFERENCE_PARTICIPATION for matching STAFF_ID.",
    "id": 7
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_orders_before_insert that fires automatically before each row is inserted into the ORDERS table, declaring local variables v_customer_exists of type NUMBER and v_max_order_id of type NUMBER, then performing a SELECT COUNT(*) query from the CUSTOMERS table into v_customer_exists where the CUSTOMER_ID column equals the new incoming :NEW.CUSTOMER_ID value, and if v_customer_exists equals zero, the trigger sets the :NEW.CUSTOMER_ID to NULL, otherwise it executes a SELECT NVL(MAX(ORDER_ID), 0) + 1 query from the ORDERS table into v_max_order_id, and if the incoming :NEW.ORDER_ID is NULL, the trigger assigns the calculated v_max_order_id value to :NEW.ORDER_ID, and if the incoming :NEW.DATE_ORDER_PLACED is NULL, the trigger assigns the current date and time formatted as 'YYYY-MM-DD HH24:MI:SS' by using the TO_CHAR function on the CURRENT_TIMESTAMP value to :NEW.DATE_ORDER_PLACED.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_orders_before_insert\nBEFORE INSERT ON ORDERS\nFOR EACH ROW\nDECLARE\n    v_customer_exists NUMBER;\n    v_max_order_id NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_customer_exists\n    FROM CUSTOMERS\n    WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n\n    IF v_customer_exists = 0 THEN\n        :NEW.CUSTOMER_ID := NULL;\n    ELSE\n        SELECT NVL(MAX(ORDER_ID), 0) + 1\n        INTO v_max_order_id\n        FROM ORDERS;\n        \n        IF :NEW.ORDER_ID IS NULL THEN\n            :NEW.ORDER_ID := v_max_order_id;\n        END IF;\n        \n        IF :NEW.DATE_ORDER_PLACED IS NULL THEN\n            :NEW.DATE_ORDER_PLACED := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');\n        END IF;\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "INVOICES"
    ],
    "call_sqls": [
      "INSERT INTO ORDERS (CUSTOMER_ID, ORDER_DETAILS) VALUES (1, 'Order details for customer 1')",
      "INSERT INTO ORDERS (CUSTOMER_ID, ORDER_DETAILS) VALUES (5, 'Order details for customer 5')",
      "INSERT INTO ORDERS (CUSTOMER_ID, ORDER_DETAILS) VALUES (7, 'Order details for customer 7')",
      "INSERT INTO ORDERS (CUSTOMER_ID, ORDER_DETAILS) VALUES (1, 'Another order for customer 1')",
      "INSERT INTO ORDERS (CUSTOMER_ID, ORDER_DETAILS) VALUES (5, 'Another order for customer 5')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_orders_before_insert on the ORDERS table. It checks if the :NEW.CUSTOMER_ID exists in the CUSTOMERS table. If not, it sets :NEW.CUSTOMER_ID to NULL. If the customer exists, it calculates a new ORDER_ID (maximum existing +1, defaulting to 1) if :NEW.ORDER_ID is NULL. It also sets :NEW.DATE_ORDER_PLACED to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' if it is NULL.",
    "natural_language": "Create a BEFORE INSERT FOR EACH ROW trigger called trg_orders_before_insert on the ORDERS table. For each new row, first verify that the :NEW.CUSTOMER_ID exists in the CUSTOMERS table. If it does not exist, set :NEW.CUSTOMER_ID to NULL. If the customer does exist, then check if :NEW.ORDER_ID is NULL; if it is, calculate a new ORDER_ID by taking the maximum existing value plus one, defaulting to 1 if no orders exist. Also, if :NEW.DATE_ORDER_PLACED is NULL, set it to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 8
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_invoices_after_order that is executed after a new row is inserted into the ORDERS table. This trigger operates for each row that is inserted. It declares two local variables: v_invoice_count of type NUMBER to store the count of invoices associated with the newly inserted order, and v_new_invoice_number of type NUMBER to store the new invoice number to be generated. The trigger begins by executing a SELECT statement to count the number of rows in the INVOICES table where the ORDER_ID column matches the ORDER_ID of the newly inserted row in the ORDERS table, storing this count in the v_invoice_count variable. It then checks if v_invoice_count is equal to 0, indicating that there are no existing invoices for the new order. If this condition is true, it executes another SELECT statement to determine the maximum value of the INVOICE_NUMBER column in the INVOICES table, using the NVL function to return 0 if no rows exist, and adds 1 to this maximum value to generate a new invoice number, storing the result in the v_new_invoice_number variable. Subsequently, it performs an INSERT operation into the INVOICES table, inserting a new row with the INVOICE_NUMBER set to v_new_invoice_number, the ORDER_ID set to the ORDER_ID of the newly inserted row in the ORDERS table, and the INVOICE_DATE set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_invoices_after_order\nAFTER INSERT ON ORDERS\nFOR EACH ROW\nDECLARE\n    v_invoice_count NUMBER;\n    v_new_invoice_number NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_invoice_count\n    FROM INVOICES\n    WHERE ORDER_ID = :NEW.ORDER_ID;\n\n    IF v_invoice_count = 0 THEN\n        SELECT NVL(MAX(INVOICE_NUMBER), 0) + 1\n        INTO v_new_invoice_number\n        FROM INVOICES;\n        \n        INSERT INTO INVOICES (INVOICE_NUMBER, ORDER_ID, INVOICE_DATE)\n        VALUES (v_new_invoice_number, :NEW.ORDER_ID, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "INVOICES"
    ],
    "call_sqls": [
      "INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, DATE_ORDER_PLACED, ORDER_DETAILS) VALUES (1, 1, '2023-01-01 10:00:00', 'Order details for order 1')",
      "INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, DATE_ORDER_PLACED, ORDER_DETAILS) VALUES (2, 5, '2023-01-02 11:00:00', 'Order details for order 2')",
      "INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, DATE_ORDER_PLACED, ORDER_DETAILS) VALUES (3, 7, '2023-01-03 12:00:00', 'Order details for order 3')",
      "INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, DATE_ORDER_PLACED, ORDER_DETAILS) VALUES (4, 1, '2023-01-04 13:00:00', 'Order details for order 4')",
      "INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, DATE_ORDER_PLACED, ORDER_DETAILS) VALUES (5, 5, '2023-01-05 14:00:00', 'Order details for order 5')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_invoices_after_order on the ORDERS table. It checks if an invoice already exists for the new order. If no invoice exists (count is 0), it generates a new INVOICE_NUMBER (maximum existing +1, defaulting to 1) and inserts a new row into the INVOICES table with this number, the new order's ORDER_ID, and the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Create a trigger named trg_invoices_after_order on the ORDERS table that fires after each row is inserted. Make it check for an existing invoice for the new order. If none is found, generate a new invoice number by taking the maximum existing number and adding one, or use 1 as the default. Then, insert a new row into the INVOICES table with this invoice number, the new order's ORDER_ID, and the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 9
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_orders_after_update` that is activated `AFTER` any `UPDATE` operation is performed on the `ORDERS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `ORDERS` table.\n\nUpon activation for a specific updated row, the trigger first declares a local numeric variable named `v_invoice_exists` to store a count. It then executes a `SELECT` statement to count the number of existing records in the `INVOICES` table. This count is performed by checking the `ORDER_ID` column in the `INVOICES` table against the `ORDER_ID` value of the row that was just updated in the `ORDERS` table. The `:NEW.ORDER_ID` pseudo-record refers to the `ORDER_ID` value of the row in the `ORDERS` table *after* the update operation. The result of this count is stored in the `v_invoice_exists` variable.\n\nFollowing this, the trigger evaluates a conditional `IF` statement. If the value of `v_invoice_exists` is equal to `0`, indicating that no invoice currently exists for the updated order, the trigger proceeds to `INSERT` a new record into the `INVOICES` table. For this new record, the `INVOICE_NUMBER` column is populated by first selecting the maximum existing `INVOICE_NUMBER` from the `INVOICES` table, using the `NVL` function to treat a `NULL` result (if no invoices exist yet) as `0`, and then adding `1` to this value. The `ORDER_ID` column of the new invoice record is set to the `ORDER_ID` of the updated order, again using `:NEW.ORDER_ID`. The `INVOICE_DATE` column is populated with the current timestamp, formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format, using the `TO_CHAR` function with `CURRENT_TIMESTAMP`.\n\nIf the `IF` condition is false, meaning `v_invoice_exists` is not equal to `0` (i.e., one or more invoices already exist for the updated order), the trigger executes an `UPDATE` statement on the `INVOICES` table. This `UPDATE` statement sets the `INVOICE_DATE` column to the current timestamp, formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format, using the `TO_CHAR` function with `CURRENT_TIMESTAMP`. This update is applied to all records in the `INVOICES` table where the `ORDER_ID` matches the `ORDER_ID` of the row that was just updated in the `ORDERS` table, specified by `:NEW.ORDER_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_orders_after_update\nAFTER UPDATE ON ORDERS\nFOR EACH ROW\nDECLARE\n    v_invoice_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_invoice_exists\n    FROM INVOICES\n    WHERE ORDER_ID = :NEW.ORDER_ID;\n\n    IF v_invoice_exists = 0 THEN\n        INSERT INTO INVOICES (INVOICE_NUMBER, ORDER_ID, INVOICE_DATE)\n        VALUES ((SELECT NVL(MAX(INVOICE_NUMBER), 0) + 1 FROM INVOICES), :NEW.ORDER_ID, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSE\n        UPDATE INVOICES\n        SET INVOICE_DATE = TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE ORDER_ID = :NEW.ORDER_ID;\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "INVOICES"
    ],
    "call_sqls": [
      "UPDATE ORDERS SET ORDER_DETAILS = 'Updated details for order 1' WHERE ORDER_ID = 1",
      "UPDATE ORDERS SET CUSTOMER_ID = 5 WHERE ORDER_ID = 2",
      "UPDATE ORDERS SET DATE_ORDER_PLACED = '2023-01-01 10:00:00' WHERE ORDER_ID = 3",
      "UPDATE ORDERS SET ORDER_DETAILS = 'Another update for order 1' WHERE ORDER_ID = 1",
      "UPDATE ORDERS SET CUSTOMER_ID = 10, DATE_ORDER_PLACED = '2023-02-15 14:30:00' WHERE ORDER_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_orders_after_update on the ORDERS table. It checks if an invoice exists for the updated order. If no invoice exists, it inserts a new invoice with a generated INVOICE_NUMBER (max existing +1, default 1), the order's ID, and the current timestamp. If an invoice already exists, it updates the INVOICE_DATE to the current timestamp for all invoices linked to that order.",
    "natural_language": "Please construct an AFTER UPDATE FOR EACH ROW trigger designated as trg_orders_after_update on the ORDERS table. The trigger's function is to verify the existence of an invoice corresponding to the updated order. Should no invoice be present, the procedure is to insert a new invoice record. This record shall contain a generated INVOICE_NUMBER, derived by incrementing the maximum existing value by one, with a default commencement at one, alongside the order's ID and the current timestamp. Conversely, if an invoice record is already associated with the order, the procedure will update the INVOICE_DATE to the current timestamp for all invoices linked to that specific order.",
    "id": 10
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_customers_after_insert that activates after a new row is inserted into the CUSTOMERS table. This trigger operates for each row inserted and begins by declaring a local variable v_order_count of type NUMBER. It then executes a SELECT statement to count the number of rows in the ORDERS table where the CUSTOMER_ID column matches the CUSTOMER_ID of the newly inserted row in the CUSTOMERS table, storing the result in v_order_count. The trigger then evaluates an IF condition to check if v_order_count equals zero, indicating that there are no existing orders for the new customer. If true, it performs an INSERT operation into the ORDERS table, adding a new row with ORDER_ID set to one more than the current maximum ORDER_ID in the ORDERS table, CUSTOMER_ID set to the CUSTOMER_ID of the newly inserted customer, and DATE_ORDER_PLACED set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'. If v_order_count is not zero, indicating that there are existing orders for the customer, the trigger executes an UPDATE operation on the ORDERS table, setting the DATE_ORDER_PLACED column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' for all rows where CUSTOMER_ID matches the CUSTOMER_ID of the newly inserted customer.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customers_after_insert\nAFTER INSERT ON CUSTOMERS\nFOR EACH ROW\nDECLARE\n    v_order_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_order_count\n    FROM ORDERS\n    WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n\n    IF v_order_count = 0 THEN\n        INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, DATE_ORDER_PLACED)\n        VALUES ((SELECT NVL(MAX(ORDER_ID), 0) + 1 FROM ORDERS), :NEW.CUSTOMER_ID, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSE\n        UPDATE ORDERS\n        SET DATE_ORDER_PLACED = TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "INVOICES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_FIRST_NAME, CUSTOMER_LAST_NAME, EMAIL_ADDRESS, LOGIN_NAME, LOGIN_PASSWORD, PHONE_NUMBER, TOWN_CITY, STATE_COUNTY_PROVINCE, COUNTRY) VALUES (100, 'John', 'Doe', 'john.doe@example.com', 'johndoe', 'password123', '123-456-7890', 'Anytown', 'Anystate', 'USA')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_FIRST_NAME, CUSTOMER_LAST_NAME, EMAIL_ADDRESS, LOGIN_NAME, LOGIN_PASSWORD, PHONE_NUMBER, TOWN_CITY, STATE_COUNTY_PROVINCE, COUNTRY) VALUES (101, 'Jane', 'Smith', 'jane.smith@example.com', 'janesmith', 'password456', '098-765-4321', 'Otherville', 'Otherstate', 'USA')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_FIRST_NAME, CUSTOMER_LAST_NAME, EMAIL_ADDRESS, LOGIN_NAME, LOGIN_PASSWORD, PHONE_NUMBER, TOWN_CITY, STATE_COUNTY_PROVINCE, COUNTRY) VALUES (102, 'Peter', 'Jones', 'peter.jones@example.com', 'peterj', 'securepass', '111-222-3333', 'Smalltown', 'Smallstate', 'USA')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_FIRST_NAME, CUSTOMER_LAST_NAME, EMAIL_ADDRESS, LOGIN_NAME, LOGIN_PASSWORD, PHONE_NUMBER, TOWN_CITY, STATE_COUNTY_PROVINCE, COUNTRY) VALUES (103, 'Alice', 'Williams', 'alice.w@example.com', 'alicew', 'mypassword', '444-555-6666', 'Bigcity', 'Bigstate', 'USA')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_FIRST_NAME, CUSTOMER_LAST_NAME, EMAIL_ADDRESS, LOGIN_NAME, LOGIN_PASSWORD, PHONE_NUMBER, TOWN_CITY, STATE_COUNTY_PROVINCE, COUNTRY) VALUES (104, 'Bob', 'Brown', 'bob.b@example.com', 'bobb', 'secretpass', '777-888-9999', 'Metropolis', 'Metropolstate', 'USA')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_customers_after_insert on the CUSTOMERS table. For each new customer, count their existing orders. If the count is zero, insert a new order with an ID one greater than the current max, using the new customer's ID and the current timestamp. If orders exist, update all existing orders for that customer to have the current timestamp.",
    "natural_language": "Construct a detailed AFTER INSERT row-level trigger, to be named trg_customers_after_insert, specifically for the CUSTOMERS table. This trigger should, for each freshly inserted customer record, meticulously calculate the total number of orders that customer already possesses. In the precise scenario where this count is determined to be exactly zero, the trigger must proceed to insert a brand new order for that customer. This new order should be assigned an ID which is carefully derived by incrementing the current maximum order ID by one, while also incorporating the new customer's unique identifier and accurately capturing the exact current timestamp. Conversely, if the investigation reveals that the customer already has one or more existing orders, then the trigger must comprehensively update every single one of those orders, systematically setting their timestamps to reflect the precise current moment.",
    "id": 11
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_actual_order_products that is defined to fire automatically after a new row is inserted into the ACTUAL_ORDERS table, executing once for each inserted row. The trigger performs a single INSERT operation into the ACTUAL_ORDER_PRODUCTS table. For the newly inserted row in ACTUAL_ORDERS, identified by the bind variable :NEW.ACTUAL_ORDER_ID, the trigger inserts five new rows into ACTUAL_ORDER_PRODUCTS. It generates these rows by using a subquery that selects from the DUAL table, employing the CONNECT BY LEVEL clause to generate a sequence of five numbers (1, 2, 3, 4, 5) via the pseudocolumn LEVEL, aliasing this result as PRODUCT_ID. For each of these five generated PRODUCT_ID values, a corresponding row is inserted into ACTUAL_ORDER_PRODUCTS, populating the ACTUAL_ORDER_ID column with the value from :NEW.ACTUAL_ORDER_ID and the PRODUCT_ID column with the generated sequential number.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_actual_order_products\nAFTER INSERT ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  INSERT INTO ACTUAL_ORDER_PRODUCTS (ACTUAL_ORDER_ID, PRODUCT_ID)\n  SELECT :NEW.ACTUAL_ORDER_ID, PRODUCT_ID\n  FROM (SELECT LEVEL AS PRODUCT_ID FROM DUAL CONNECT BY LEVEL <= 5);\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (4, 'Success', 9, '2018-03-03 12:00:00')",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (5, 'Cancel', 10, '2018-03-04 13:00:00')",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (6, 'Success', 11, '2018-03-05 14:00:00')",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (7, 'Cancel', 12, '2018-03-06 15:00:00')",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (8, 'Success', 13, '2018-03-07 16:00:00')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_actual_order_products on the ACTUAL_ORDERS table. For each new order, insert five rows into the ACTUAL_ORDER_PRODUCTS table, using the new order's ID and sequential product IDs from 1 to 5.",
    "natural_language": "Alright, so I need you to set up a trigger called trg_insert_actual_order_products on the ACTUAL_ORDERS table. It's gotta fire after a new order is inserted. For every fresh order, just pop five entries into the ACTUAL_ORDER_PRODUCTS table. Use the new order's ID and slap on product IDs from 1 straight through to 5.",
    "id": 12
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_actual_order_products` that is activated `AFTER` a `DELETE` operation occurs on the `ACTUAL_ORDERS` table. This trigger is configured to execute `FOR EACH ROW` that is deleted from the `ACTUAL_ORDERS` table. Upon activation, for each row that has been deleted from the `ACTUAL_ORDERS` table, the trigger performs a `DELETE` operation on the `ACTUAL_ORDER_PRODUCTS` table. The `DELETE` operation on the `ACTUAL_ORDER_PRODUCTS` table is conditional, targeting only those rows where the value in the `ACTUAL_ORDER_ID` column of the `ACTUAL_ORDER_PRODUCTS` table is equal to the value of the `ACTUAL_ORDER_ID` column from the row that was just deleted from the `ACTUAL_ORDERS` table. The `:OLD.ACTUAL_ORDER_ID` refers to the value of the `ACTUAL_ORDER_ID` column in the row of the `ACTUAL_ORDERS` table that existed *before* the `DELETE` operation was performed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_actual_order_products\nAFTER DELETE ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  DELETE FROM ACTUAL_ORDER_PRODUCTS\n  WHERE ACTUAL_ORDER_ID = :OLD.ACTUAL_ORDER_ID;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 1",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 2",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 3",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 8",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 15"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_actual_order_products on the ACTUAL_ORDERS table. For each deleted order, delete all related rows from the ACTUAL_ORDER_PRODUCTS table where the ACTUAL_ORDER_ID matches the deleted order's ID.",
    "natural_language": "Set up a trigger on the ACTUAL_ORDERS table that runs after rows are removed. It should clean up the related entries in the ACTUAL_ORDER_PRODUCTS table, getting rid of the ones that seem to be linked to the deleted orders.",
    "id": 13
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_order_status` that is configured to execute `BEFORE` any `UPDATE` operation is performed on the `ACTUAL_ORDERS` table. This trigger is defined to execute `FOR EACH ROW` that is affected by the `UPDATE` statement, meaning its logic will be applied individually to each row being updated. The trigger's execution begins with an `IF` conditional statement. This condition evaluates whether the value of the `ORDER_STATUS_CODE` column in the `NEW` pseudo-record (which represents the data of the row *after* the update operation) is exactly equal to the string literal `'Cancel'`. If this condition evaluates to `TRUE`, then a `DELETE` operation is performed. This `DELETE` operation targets the `ACTUAL_ORDER_PRODUCTS` table. The rows to be deleted from `ACTUAL_ORDER_PRODUCTS` are determined by a `WHERE` clause, which specifies that only those rows where the value of the `ACTUAL_ORDER_ID` column in `ACTUAL_ORDER_PRODUCTS` is equal to the value of the `ACTUAL_ORDER_ID` column in the `NEW` pseudo-record (representing the updated order's ID) will be removed. The `IF` statement concludes, and then the trigger's execution block ends.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_order_status\nBEFORE UPDATE ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  IF :NEW.ORDER_STATUS_CODE = 'Cancel' THEN\n    DELETE FROM ACTUAL_ORDER_PRODUCTS\n    WHERE ACTUAL_ORDER_ID = :NEW.ACTUAL_ORDER_ID;\n  END IF;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Cancel' WHERE ACTUAL_ORDER_ID = 1",
      "UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Cancel' WHERE ACTUAL_ORDER_ID = 2",
      "UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Cancel' WHERE ACTUAL_ORDER_ID = 3",
      "UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Cancel' WHERE ACTUAL_ORDER_ID = 8",
      "UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Cancel' WHERE ACTUAL_ORDER_ID = 15"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_update_order_status on the ACTUAL_ORDERS table. If the updated ORDER_STATUS_CODE is 'Cancel', delete all rows from the ACTUAL_ORDER_PRODUCTS table where the ACTUAL_ORDER_ID matches the updated order's ID.",
    "natural_language": "Make a BEFORE UPDATE trigger trg_update_order_status on ACTUAL_ORDERS. If ORDER_STATUS_CODE becomes 'Cancel', delete matching rows from ACTUAL_ORDER_PRODUCTS.",
    "id": 14
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_order_date that is defined to fire BEFORE INSERT on the ACTUAL_ORDERS table for EACH ROW, and within its execution block, it assigns a value to the :NEW.ACTUAL_ORDER_DATE column by calling the TO_CHAR function with two arguments: the first argument is the SYSDATE function which returns the current date and time from the database server, and the second argument is the format model string 'YYYY-MM-DD HH24:MI:SS', which converts the date and time into a character string representing the year, month, day, hour in 24-hour format, minute, and second.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_order_date\nBEFORE INSERT ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  :NEW.ACTUAL_ORDER_DATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (101, 'Success', 10)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (102, 'Cancel', 11)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (103, 'Success', 12)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (104, 'Pending', 13)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (105, 'Success', 14)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_insert_order_date on the ACTUAL_ORDERS table. For each new row, set the ACTUAL_ORDER_DATE column to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger, which should be named trg_insert_order_date, specifically for the ACTUAL_ORDERS table. For every single new row that is being inserted, you must meticulously ensure that the ACTUAL_ORDER_DATE column is automatically populated with the precise current system date and time, which should be carefully formatted in the detailed pattern of 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 15
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_check_order_date`. This trigger is configured to execute `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `ACTUAL_ORDERS` table. The trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row affected by the `INSERT` or `UPDATE` statement. The trigger's execution block begins by evaluating a conditional statement. This condition checks if the value of the `ACTUAL_ORDER_DATE` column in the `NEW` pseudo-record (which represents the data of the row as it will be after the `INSERT` or `UPDATE` operation) `IS NULL`. If this condition evaluates to `TRUE`, indicating that the `ACTUAL_ORDER_DATE` for the current row is not provided or is explicitly set to `NULL`, then the trigger proceeds to execute the statement within the `IF` block. Inside this `IF` block, the `ACTUAL_ORDER_DATE` column of the `NEW` pseudo-record is assigned a value. This value is generated by calling the `TO_CHAR` function. The `TO_CHAR` function converts the current system date and time, obtained by the `SYSDATE` function, into a character string. The format model used for this conversion is `'YYYY-MM-DD HH24:MI:SS'`, which specifies the year with four digits, the month with two digits, the day of the month with two digits, the hour in 24-hour format with two digits, the minute with two digits, and the second with two digits, all separated by hyphens, spaces, and colons as indicated. This effectively sets the `ACTUAL_ORDER_DATE` to the current system timestamp formatted as a string if it was initially `NULL`. If the initial condition (`:NEW.ACTUAL_ORDER_DATE IS NULL`) evaluates to `FALSE`, meaning the `ACTUAL_ORDER_DATE` is already provided and is not `NULL`, then the statements within the `IF` block are skipped, and no modification is made to the `ACTUAL_ORDER_DATE` column by this trigger. The trigger's execution concludes after this conditional logic.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_order_date\nBEFORE INSERT OR UPDATE ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  IF :NEW.ACTUAL_ORDER_DATE IS NULL THEN\n    :NEW.ACTUAL_ORDER_DATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\n  END IF;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (1, 'Success', 8, NULL)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (2, 'Cancel', 15)",
      "UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Pending', ACTUAL_ORDER_DATE = NULL WHERE ACTUAL_ORDER_ID = 1",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (3, 'Shipped', 4, '2023-01-01 10:00:00')",
      "UPDATE ACTUAL_ORDERS SET ACTUAL_ORDER_DATE = NULL WHERE ACTUAL_ORDER_ID = 3"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_check_order_date on the ACTUAL_ORDERS table. If the new ACTUAL_ORDER_DATE is NULL, set it to the current system timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Set up a BEFORE INSERT OR UPDATE FOR EACH ROW trigger called trg_check_order_date on the ACTUAL_ORDERS table. For any new row, if the ACTUAL_ORDER_DATE is NULL, assign it the current system timestamp in the format 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 16
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_party_address` that is activated `AFTER` an `INSERT` operation occurs on the `PARTY_ADDRESSES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `PARTY_ADDRESSES` table. Upon activation, for each newly inserted row in `PARTY_ADDRESSES`, the trigger performs an `INSERT` operation into the `ADDRESSES` table. The `INSERT` statement populates the following columns in the `ADDRESSES` table: `ADDRESS_ID`, `LINE_1_NUMBER_BUILDING`, `TOWN_CITY`, `ZIP_POSTCODE`, `STATE_PROVINCE_COUNTY`, and `COUNTRY`. The value for the `ADDRESS_ID` column is taken from the `ADDRESS_ID` column of the newly inserted row in `PARTY_ADDRESSES`, referenced as `:NEW.ADDRESS_ID`. The `LINE_1_NUMBER_BUILDING` column is populated with the literal string `'New Building'`. The `TOWN_CITY` column is populated with the literal string `'New City'`. The `ZIP_POSTCODE` column is populated with the literal string `'00000'`. The `STATE_PROVINCE_COUNTY` column is populated with the literal string `'New State'`. The `COUNTRY` column is populated with the literal string `'New Country'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_party_address\nAFTER INSERT ON PARTY_ADDRESSES\nFOR EACH ROW\nBEGIN\n  INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, TOWN_CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY)\n  VALUES (:NEW.ADDRESS_ID, 'New Building', 'New City', '00000', 'New State', 'New Country');\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "INSERT INTO PARTY_ADDRESSES (PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, DATE_ADDRESS_TO) VALUES (11, 9, '2023-10-01 10:00:00', 'Residence', '2025-10-01 10:00:00')",
      "INSERT INTO PARTY_ADDRESSES (PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, DATE_ADDRESS_TO) VALUES (12, 10, '2023-10-02 11:00:00', 'Billing', '2025-10-02 11:00:00')",
      "INSERT INTO PARTY_ADDRESSES (PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, DATE_ADDRESS_TO) VALUES (13, 11, '2023-10-03 12:00:00', 'Delivery', '2025-10-03 12:00:00')",
      "INSERT INTO PARTY_ADDRESSES (PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, DATE_ADDRESS_TO) VALUES (14, 12, '2023-10-04 13:00:00', 'Residence', '2025-10-04 13:00:00')",
      "INSERT INTO PARTY_ADDRESSES (PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, DATE_ADDRESS_TO) VALUES (15, 13, '2023-10-05 14:00:00', 'Billing', '2025-10-05 14:00:00')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_party_address on the PARTY_ADDRESSES table. For each inserted row, insert a corresponding record into the ADDRESSES table using the new ADDRESS_ID and static values: 'New Building', 'New City', '00000', 'New State', 'New Country'.",
    "natural_language": "Create trigger trg_insert_party_address on PARTY_ADDRESSES after insert. For each new row, insert into ADDRESSES using the new ADDRESS_ID with static values 'New Building', 'New City', '00000', 'New State', 'New Country'.",
    "id": 17
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_party_form` that is activated automatically after a `DELETE` statement is executed on the `PARTY_FORMS` table. This trigger is defined to execute for `EACH ROW` that is affected by the `DELETE` operation. Upon activation for each deleted row, the trigger performs a `DELETE` operation on the `PARTIES` table. The `DELETE` operation on the `PARTIES` table is conditional, targeting only those rows where the value in the `PARTY_ID` column of the `PARTIES` table is equal to the value of the `PARTY_ID` column from the row that was just deleted from the `PARTY_FORMS` table. The `:OLD.PARTY_ID` refers to the value of the `PARTY_ID` column in the row that existed in the `PARTY_FORMS` table immediately before it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_party_form\nAFTER DELETE ON PARTY_FORMS\nFOR EACH ROW\nBEGIN\n  DELETE FROM PARTIES WHERE PARTY_ID = :OLD.PARTY_ID;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "DELETE FROM PARTY_FORMS WHERE PARTY_ID = 2",
      "DELETE FROM PARTY_FORMS WHERE PARTY_ID = 15",
      "DELETE FROM PARTY_FORMS WHERE PARTY_ID = 8",
      "DELETE FROM PARTY_FORMS WHERE FORM_ID = 4",
      "DELETE FROM PARTY_FORMS WHERE PARTY_ID = 1 AND FORM_ID = 5"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_delete_party_form on the PARTY_FORMS table. For each deleted row, delete from the PARTIES table where PARTY_ID equals the old PARTY_ID from the deleted row.",
    "natural_language": "Construct an AFTER DELETE FOR EACH ROW trigger, which should be named trg_delete_party_form, on the PARTY_FORMS table. This detailed trigger must be configured so that, for every single row which is deleted, it subsequently and automatically performs a deletion from the PARTIES table, specifically targeting those records where the PARTY_ID column precisely matches the old PARTY_ID value originating from the recently deleted row.",
    "id": 18
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_party_form` that is defined to execute automatically after an `INSERT` operation is performed on the `PARTY_FORMS` table. This trigger is configured to fire `FOR EACH ROW` that is inserted into the `PARTY_FORMS` table, meaning its logic will execute once for every individual row affected by the `INSERT` statement. Upon activation, the trigger performs a single `INSERT` operation into the `PARTIES` table. The `INSERT` statement populates four specific columns in the `PARTIES` table: `PARTY_ID`, `PAYMENT_METHOD_CODE`, `PARTY_PHONE`, and `PARTY_EMAIL`. The value for the `PARTY_ID` column in the `PARTIES` table is sourced directly from the `PARTY_ID` column of the newly inserted row in the `PARTY_FORMS` table, referenced using the `:NEW.PARTY_ID` pseudorecord variable. The `PAYMENT_METHOD_CODE` column in the `PARTIES` table is assigned a static string literal value of `'New Method'`. The `PARTY_PHONE` column in the `PARTIES` table is assigned a static string literal value of `'000-000-0000'`. The `PARTY_EMAIL` column in the `PARTIES` table is constructed by first concatenating the value from the `FORM_STATUS_CODE` column of the newly inserted row in the `PARTY_FORMS` table (referenced as `:NEW.FORM_STATUS_CODE`) with the string literal `'@example.com'`, and then applying the `RTRIM` function to the resulting concatenated string. The `RTRIM` function removes any trailing spaces from the concatenated string before it is inserted into the `PARTY_EMAIL` column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_party_form\nAFTER INSERT ON PARTY_FORMS\nFOR EACH ROW\nBEGIN\n  INSERT INTO PARTIES (PARTY_ID, PAYMENT_METHOD_CODE, PARTY_PHONE, PARTY_EMAIL)\n  VALUES (:NEW.PARTY_ID, 'New Method', '000-000-0000', RTRIM(:NEW.FORM_STATUS_CODE || '@example.com'));\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED) VALUES (1, 6, '2023-10-01 10:00:00', 'Completed', '2023-10-02 10:00:00')",
      "INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED) VALUES (3, 7, '2023-10-03 11:00:00', 'Partially Completed', '2023-10-04 11:00:00')",
      "INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED) VALUES (4, 8, '2023-10-05 12:00:00', 'Completed', '2023-10-06 12:00:00')",
      "INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED) VALUES (5, 9, '2023-10-07 13:00:00', 'Partially Completed', '2023-10-08 13:00:00')",
      "INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED) VALUES (6, 10, '2023-10-09 14:00:00', 'Completed', '2023-10-10 14:00:00')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_party_form on the PARTY_FORMS table. For each inserted row, insert a record into the PARTIES table using the new PARTY_ID, static values 'New Method' and '000-000-0000' for PAYMENT_METHOD_CODE and PARTY_PHONE, and an email constructed by concatenating RTRIM(new FORM_STATUS_CODE) with '@example.com' for PARTY_EMAIL.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger designated as 'trg_insert_party_form' on the PARTY_FORMS table. For every row inserted, it is required to insert a corresponding record into the PARTIES table. This record shall utilize the newly inserted PARTY_ID, assign the static values 'New Method' and '000-000-0000' to the PAYMENT_METHOD_CODE and PARTY_PHONE columns respectively, and populate the PARTY_EMAIL column with an address formed by concatenating the RTRIM function applied to the new FORM_STATUS_CODE with the domain '@example.com'.",
    "id": 19
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_party_address that is executed after an update operation on the PARTY_ADDRESSES table for each row affected by the update. The trigger performs a delete operation on the ADDRESSES table, specifically removing the row where the ADDRESS_ID column matches the value of the ADDRESS_ID column in the newly updated row of the PARTY_ADDRESSES table. The trigger uses the :NEW pseudorecord to access the value of the ADDRESS_ID from the updated row in the PARTY_ADDRESSES table. There are no conditional statements or function calls involved in this trigger; it simply deletes the corresponding address record based on the updated address ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_party_address\nAFTER UPDATE ON PARTY_ADDRESSES\nFOR EACH ROW\nBEGIN\n  DELETE FROM ADDRESSES WHERE ADDRESS_ID = :NEW.ADDRESS_ID;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "UPDATE PARTY_ADDRESSES SET DATE_ADDRESS_TO = '2023-01-01 00:00:00' WHERE PARTY_ID = 10 AND ADDRESS_ID = 8",
      "UPDATE PARTY_ADDRESSES SET ADDRESS_TYPE_CODE = 'Archived' WHERE PARTY_ID = 15 AND ADDRESS_ID = 5",
      "UPDATE PARTY_ADDRESSES SET DATE_ADDRESS_FROM = '2010-01-01 00:00:00' WHERE PARTY_ID = 4 AND ADDRESS_ID = 4",
      "UPDATE PARTY_ADDRESSES SET DATE_ADDRESS_TO = '2024-01-01 00:00:00' WHERE PARTY_ID = 10 AND ADDRESS_ID = 8",
      "UPDATE PARTY_ADDRESSES SET ADDRESS_TYPE_CODE = 'Previous' WHERE PARTY_ID = 15 AND ADDRESS_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_party_address on the PARTY_ADDRESSES table. For each updated row, delete from the ADDRESSES table where ADDRESS_ID equals the new ADDRESS_ID from the updated row.",
    "natural_language": "Construct a detailed AFTER UPDATE FOR EACH ROW trigger, which should be named trg_update_party_address, specifically for the PARTY_ADDRESSES table. For every individual row that is updated, this trigger must meticulously execute a deletion from the ADDRESSES table, targeting precisely those records where the ADDRESS_ID matches the new ADDRESS_ID value originating from the recently updated row.",
    "id": 20
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_address that is executed automatically after a new row is inserted into the ADDRESSES table. This trigger operates for each row that is inserted. Within the trigger's body, an INSERT operation is performed on the PARTY_ADDRESSES table. The INSERT statement adds a new row with specific values into the PARTY_ADDRESSES table. The columns being inserted into are PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, and DATE_ADDRESS_TO. The PARTY_ID column is assigned a constant value of 1. The ADDRESS_ID column is assigned the value from the newly inserted row in the ADDRESSES table, accessed using the :NEW pseudo-record, specifically :NEW.ADDRESS_ID. The DATE_ADDRESS_FROM column is assigned a fixed date value of '2023-01-01'. The ADDRESS_TYPE_CODE column is assigned a string value of 'New Type'. The DATE_ADDRESS_TO column is assigned a fixed date value of '2023-12-31'. This trigger does not perform any conditional checks or logic flow alterations; it simply inserts a row into the PARTY_ADDRESSES table with predetermined values whenever a new row is added to the ADDRESSES table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_address\nAFTER INSERT ON ADDRESSES\nFOR EACH ROW\nBEGIN\n  INSERT INTO PARTY_ADDRESSES (PARTY_ID, ADDRESS_ID, DATE_ADDRESS_FROM, ADDRESS_TYPE_CODE, DATE_ADDRESS_TO)\n  VALUES (1, :NEW.ADDRESS_ID, '2023-01-01', 'New Type', '2023-12-31');\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, TOWN_CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY) VALUES (100, '123 Main St', 'Springfield', '62701', 'Illinois', 'USA')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, TOWN_CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY) VALUES (101, '456 Oak Ave', 'Shelbyville', '62565', 'Illinois', 'USA')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, TOWN_CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY) VALUES (102, '789 Pine Rd', 'Capital City', '63301', 'Missouri', 'USA')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, TOWN_CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY) VALUES (103, '321 Elm Blvd', 'Cypress Creek', '60007', 'Florida', 'USA')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, TOWN_CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY) VALUES (104, '654 Maple Ln', 'Ogdenville', '13421', 'New York', 'USA')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_address on the ADDRESSES table. For each new row, insert a corresponding row into the PARTY_ADDRESSES table with the following values: PARTY_ID = 1, ADDRESS_ID = :NEW.ADDRESS_ID, DATE_ADDRESS_FROM = '2023-01-01', ADDRESS_TYPE_CODE = 'New Type', and DATE_ADDRESS_TO = '2023-12-31'.",
    "natural_language": "How can I create an AFTER INSERT row-level trigger named trg_insert_address on the ADDRESSES table so that for each new row, it inserts a corresponding row into the PARTY_ADDRESSES table with PARTY_ID set to 1, ADDRESS_ID set to the new ADDRESS_ID, DATE_ADDRESS_FROM set to '2023-01-01', ADDRESS_TYPE_CODE set to 'New Type', and DATE_ADDRESS_TO set to '2023-12-31'?",
    "id": 21
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_enrolment_date that fires before each row is inserted into the STUDENT_COURSE_ENROLMENT table, declaring a local variable v_reg_date of type VARCHAR2 with a maximum length of 255 characters, and within its execution block, it performs a SELECT query on the STUDENTS table to retrieve the DATE_OF_REGISTRATION column value for the specific STUDENT_ID that matches the new STUDENT_ID value being inserted (referenced as :NEW.STUDENT_ID), storing the result into the v_reg_date variable, then it compares the new DATE_OF_ENROLMENT value (referenced as :NEW.DATE_OF_ENROLMENT) to the retrieved v_reg_date value by converting both strings to date types using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS', and if the converted new enrolment date is found to be earlier than the converted registration date, it updates the :NEW.DATE_OF_ENROLMENT value within the trigger to be equal to the v_reg_date string value, thereby ensuring the enrolment date in the inserted row is not set to a date prior to the student's registration date.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_enrolment_date\nBEFORE INSERT ON STUDENT_COURSE_ENROLMENT\nFOR EACH ROW\nDECLARE\n    v_reg_date VARCHAR2(255);\nBEGIN\n    SELECT DATE_OF_REGISTRATION INTO v_reg_date FROM STUDENTS WHERE STUDENT_ID = :NEW.STUDENT_ID;\n    IF TO_DATE(:NEW.DATE_OF_ENROLMENT, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(v_reg_date, 'YYYY-MM-DD HH24:MI:SS') THEN\n        :NEW.DATE_OF_ENROLMENT := v_reg_date;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENTS"
    ],
    "call_sqls": [
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (100, 1, 2, '2014-01-01 10:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (101, 2, 1, '2015-07-01 12:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (102, 3, 3, '2015-10-12 09:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (103, 1, 1, '2015-07-23 14:30:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (104, 2, 2, '2015-07-03 08:45:00', NULL)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_check_enrolment_date on the STUDENT_COURSE_ENROLMENT table. For each new row, retrieve the student's registration date. If the new enrolment date (converted from VARCHAR2) is earlier than the registration date, set the :NEW.DATE_OF_ENROLMENT to the registration date string.",
    "natural_language": "How can I create a BEFORE INSERT row-level trigger named trg_check_enrolment_date on the STUDENT_COURSE_ENROLMENT table that, for each new row, retrieves the student's registration date and, if the new enrolment date (converted from VARCHAR2) is earlier, sets the :NEW.DATE_OF_ENROLMENT to the registration date string?",
    "id": 22
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_logon_date that is executed after an insert operation on the STUDENT_COURSE_ENROLMENT table for each row affected by the insert. The trigger declares a local variable v_current_logon of type VARCHAR2 with a maximum length of 255 characters. The trigger begins by selecting the DATE_OF_LATEST_LOGON column from the STUDENTS table into the v_current_logon variable for the row where the STUDENT_ID column matches the STUDENT_ID value of the newly inserted row in the STUDENT_COURSE_ENROLMENT table, referenced as :NEW.STUDENT_ID. The trigger then compares the DATE_OF_ENROLMENT value from the newly inserted row, converted from VARCHAR2 to DATE using the TO_DATE function with the format 'YYYY-MM-DD HH24:MI:SS', against the v_current_logon value, also converted to DATE using the same format. If the converted DATE_OF_ENROLMENT is greater than the converted v_current_logon, the trigger updates the STUDENTS table by setting the DATE_OF_LATEST_LOGON column to the DATE_OF_ENROLMENT value from the newly inserted row for the row where STUDENT_ID matches :NEW.STUDENT_ID. The trigger includes an exception handler for the NO_DATA_FOUND exception, which occurs if no matching STUDENT_ID is found in the STUDENTS table, and in this case, the trigger does nothing.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_logon_date\nAFTER INSERT ON STUDENT_COURSE_ENROLMENT\nFOR EACH ROW\nDECLARE\n    v_current_logon VARCHAR2(255);\nBEGIN\n    -- Get the current DATE_OF_LATEST_LOGON for the student\n    SELECT DATE_OF_LATEST_LOGON INTO v_current_logon\n    FROM STUDENTS\n    WHERE STUDENT_ID = :NEW.STUDENT_ID;\n    \n    -- Compare dates after converting VARCHAR2 to DATE\n    IF TO_DATE(:NEW.DATE_OF_ENROLMENT, 'YYYY-MM-DD HH24:MI:SS') > \n       TO_DATE(v_current_logon, 'YYYY-MM-DD HH24:MI:SS') THEN\n        UPDATE STUDENTS \n        SET DATE_OF_LATEST_LOGON = :NEW.DATE_OF_ENROLMENT \n        WHERE STUDENT_ID = :NEW.STUDENT_ID;\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        NULL; -- Student doesn't exist, do nothing\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENTS"
    ],
    "call_sqls": [
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (100, 1, 1, '2018-01-01 10:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (101, 2, 2, '2018-02-01 11:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (102, 3, 3, '2018-03-01 12:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (103, 1, 2, '2017-05-01 09:00:00', NULL)",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (104, 2, 1, '2017-06-01 10:00:00', NULL)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_update_logon_date on the STUDENT_COURSE_ENROLMENT table. For each new row, retrieve the student's latest logon date. If the new enrolment date (converted from VARCHAR2) is later than the latest logon date, update the STUDENTS table to set DATE_OF_LATEST_LOGON to the new enrolment date. Handle NO_DATA_FOUND by doing nothing.",
    "natural_language": "Create trigger trg_update_logon_date on STUDENT_COURSE_ENROLMENT. After each insert, if the new enrolment date is later than the student's latest logon, update STUDENTS.DATE_OF_LATEST_LOGON. Ignore NO_DATA_FOUND.",
    "id": 23
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_check_course_author` that is activated immediately prior to an `INSERT` operation being performed on the `COURSES` table. This trigger operates `FOR EACH ROW` being inserted. Within the trigger's execution block, a local numeric variable named `v_author_exists` is declared to store a count. The trigger then executes a `SELECT` statement to count the number of rows in the `STUDENTS` table where the `STUDENT_ID` column matches the value of the `AUTHOR_ID` column of the new row being inserted into the `COURSES` table (referenced as `:NEW.AUTHOR_ID`). The result of this count operation is stored in the `v_author_exists` variable. Following this, a conditional `IF` statement evaluates whether the value of `v_author_exists` is equal to `0`. If this condition is true, indicating that no matching `STUDENT_ID` was found in the `STUDENTS` table for the `AUTHOR_ID` provided in the new `COURSES` row, then the `AUTHOR_ID` column of the new row being inserted (referenced as `:NEW.AUTHOR_ID`) is explicitly set to `NULL`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_course_author\nBEFORE INSERT ON COURSES\nFOR EACH ROW\nDECLARE\n    v_author_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_author_exists FROM STUDENTS WHERE STUDENT_ID = :NEW.AUTHOR_ID;\n    IF v_author_exists = 0 THEN\n        :NEW.AUTHOR_ID := NULL;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENTS"
    ],
    "call_sqls": [
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (1, 1, 1, 'database', 'database')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (2, 2, 1, 'advanced database', 'advanced database')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (3, 3, 1, 'operating system', 'operating system')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (4, 99, 1, 'non-existent author course', 'This course should have a NULL author_id')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (5, NULL, 1, 'course with no author', 'This course has no author specified')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_check_course_author on the COURSES table. For each new row, check if the AUTHOR_ID exists in the STUDENTS table. If it does not exist, set :NEW.AUTHOR_ID to NULL.",
    "natural_language": "Create a row-level trigger called trg_check_course_author for the COURSES table to fire BEFORE INSERT. For each inserted row, verify the AUTHOR_ID against the STUDENTS table. Set the :NEW.AUTHOR_ID to NULL if the ID is not found.",
    "id": 24
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_course_description that is executed before any update operation on the COURSES table. This trigger operates on each row that is being updated. It checks the value of the COURSE_DESCRIPTION column in the new version of the row, referred to as :NEW.COURSE_DESCRIPTION. If this new value is NULL, the trigger assigns the string 'No description available' to the COURSE_DESCRIPTION column of the new row. This ensures that after the update operation, the COURSE_DESCRIPTION column will not contain a NULL value, but instead will have a default description if no specific description is provided.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_course_description\nBEFORE UPDATE ON COURSES\nFOR EACH ROW\nBEGIN\n    IF :NEW.COURSE_DESCRIPTION IS NULL THEN\n        :NEW.COURSE_DESCRIPTION := 'No description available';\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENTS"
    ],
    "call_sqls": [
      "UPDATE COURSES SET COURSE_DESCRIPTION = NULL WHERE COURSE_ID = 1",
      "UPDATE COURSES SET COURSE_DESCRIPTION = 'Updated description', COURSE_NAME = 'Database Fundamentals' WHERE COURSE_ID = 2",
      "UPDATE COURSES SET COURSE_DESCRIPTION = NULL, AUTHOR_ID = 10 WHERE COURSE_ID = 3",
      "UPDATE COURSES SET COURSE_NAME = 'Advanced OS' WHERE COURSE_ID = 4",
      "UPDATE COURSES SET COURSE_DESCRIPTION = '' WHERE COURSE_ID = 5"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_update_course_description on the COURSES table. For each row being updated, if the new COURSE_DESCRIPTION (:NEW.COURSE_DESCRIPTION) is NULL, set it to 'No description available'.",
    "natural_language": "Set up a BEFORE UPDATE row-level trigger called trg_update_course_description on the COURSES table. For each updated row, if the new COURSE_DESCRIPTION is NULL, assign it the value 'No description available'.",
    "id": 25
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_company_assets that executes automatically before any INSERT operation or UPDATE operation is performed on the COMPANY table, for each individual row being processed. The trigger uses the special NEW pseudorecord to access the incoming column values for the row. It first checks a condition on the NEW.ASSETS_BILLION column: if the new ASSETS_BILLION value is less than 0, the trigger immediately raises a custom application error with error code -20005 and the message 'Assets cannot be negative', which stops the execution of the triggering INSERT or UPDATE statement. If the first condition is false, the trigger proceeds to a second condition: it checks if the NEW.PROFITS_BILLION column value is greater than the NEW.ASSETS_BILLION column value. If this condition is true, the trigger raises a different custom application error with error code -20006 and the message 'Profits cannot exceed assets', again preventing the completion of the triggering DML operation. If neither condition is met, the trigger ends without error, allowing the INSERT or UPDATE to proceed normally.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_company_assets\nBEFORE INSERT OR UPDATE ON COMPANY\nFOR EACH ROW\nBEGIN\n  IF :NEW.ASSETS_BILLION < 0 THEN\n    RAISE_APPLICATION_ERROR(-20005, 'Assets cannot be negative');\n  ELSIF :NEW.PROFITS_BILLION > :NEW.ASSETS_BILLION THEN\n    RAISE_APPLICATION_ERROR(-20006, 'Profits cannot exceed assets');\n  END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (4, 2, 'BP', 'UK', 'Oil and gas', 240.0, 20.0, 250.0, 300.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (5, 5, 'Toyota', 'Japan', 'Automotive', 275.0, 15.0, 300.0, 350.0)",
      "UPDATE COMPANY SET PROFITS_BILLION = 25.0 WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET ASSETS_BILLION = 500.0 WHERE COMPANY_ID = 2",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (6, 6, 'Volkswagen', 'Germany', 'Automotive', 300.0, 18.0, 320.0, 400.0)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_validate_company_assets on the COMPANY table. Raise application error -20005 with message 'Assets cannot be negative' if NEW.ASSETS_BILLION < 0. Otherwise, raise error -20006 with message 'Profits cannot exceed assets' if NEW.PROFITS_BILLION > NEW.ASSETS_BILLION.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_validate_company_assets on the COMPANY table that raises application error -20005 with the message 'Assets cannot be negative' if NEW.ASSETS_BILLION is less than 0, and otherwise raises error -20006 with the message 'Profits cannot exceed assets' if NEW.PROFITS_BILLION is greater than NEW.ASSETS_BILLION?",
    "id": 26
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_check_company_sales` that is activated `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `COMPANY` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row affected by the `INSERT` or `UPDATE` statement. The primary purpose of this trigger is to enforce data integrity constraints on the `SALES_BILLION` and `PROFITS_BILLION` columns of the `COMPANY` table. Upon activation, the trigger first evaluates a conditional statement: `IF :NEW.SALES_BILLION IS NULL`. This condition checks if the value proposed for the `SALES_BILLION` column in the new or updated row (represented by `:NEW.SALES_BILLION`, which is of a numeric data type, likely `NUMBER` or `FLOAT`) is `NULL`. If this condition evaluates to `TRUE`, indicating that the `SALES_BILLION` value is indeed `NULL`, the trigger immediately executes the `RAISE_APPLICATION_ERROR` procedure. This procedure is called with two parameters: an error number `-20007` (a user-defined error number within the range -20000 to -20999) and an error message string `'Sales cannot be null'`. This action prevents the `INSERT` or `UPDATE` operation from completing and returns the specified error to the calling application. If the first condition (`:NEW.SALES_BILLION IS NULL`) evaluates to `FALSE`, the trigger proceeds to evaluate a second conditional statement: `ELSIF :NEW.SALES_BILLION < :NEW.PROFITS_BILLION`. This condition compares the value proposed for the `SALES_BILLION` column (a numeric data type) with the value proposed for the `PROFITS_BILLION` column (also a numeric data type, represented by `:NEW.PROFITS_BILLION`) in the new or updated row. If this second condition evaluates to `TRUE`, indicating that the `SALES_BILLION` value is less than the `PROFITS_BILLION` value, the trigger again executes the `RAISE_APPLICATION_ERROR` procedure. This time, it is called with the error number `-20008` and the error message string `'Sales must be greater than profits'`. This action also prevents the `INSERT` or `UPDATE` operation from completing and returns the specified error to the calling application. If both conditions evaluate to `FALSE`, meaning `SALES_BILLION` is not `NULL` and `SALES_BILLION` is not less than `PROFITS_BILLION`, the trigger completes its execution without raising an error, allowing the `INSERT` or `UPDATE` operation on the `COMPANY` table to proceed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_company_sales\nBEFORE INSERT OR UPDATE ON COMPANY\nFOR EACH ROW\nBEGIN\n  IF :NEW.SALES_BILLION IS NULL THEN\n    RAISE_APPLICATION_ERROR(-20007, 'Sales cannot be null');\n  ELSIF :NEW.SALES_BILLION < :NEW.PROFITS_BILLION THEN\n    RAISE_APPLICATION_ERROR(-20008, 'Sales must be greater than profits');\n  END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (100, 100, 'Test Corp', 'USA', 'Technology', 50.0, 30.0, 200.0, 150.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION) VALUES (101, 101, 'Bad Corp', 'USA', 'Technology', NULL, 10.0)",
      "UPDATE COMPANY SET SALES_BILLION = 60.0, PROFITS_BILLION = 70.0 WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET SALES_BILLION = NULL WHERE COMPANY_ID = 2",
      "INSERT INTO COMPANY (COMPANY_ID, COMPANY, SALES_BILLION, PROFITS_BILLION) VALUES (102, 'Another Corp', 25.0, 26.0)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_check_company_sales on the COMPANY table. Raise application error -20007 with message 'Sales cannot be null' if NEW.SALES_BILLION IS NULL. Otherwise, raise error -20008 with message 'Sales must be greater than profits' if NEW.SALES_BILLION < NEW.PROFITS_BILLION.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE FOR EACH ROW trigger, designated as trg_check_company_sales, for the COMPANY table. This trigger should enforce the following validations: if the NEW.SALES_BILLION value is NULL, an application error numbered -20007 with the message 'Sales cannot be null' must be raised. Conversely, if the NEW.SALES_BILLION value is less than the NEW.PROFITS_BILLION value, an application error numbered -20008 with the message 'Sales must be greater than profits' should be raised.",
    "id": 27
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_move_dates that fires before any update operation on the DATE_MOVED_IN column of the RESIDENTS table for each affected row, and within its execution block, it first declares three local variables: v_customer_count of type NUMBER, v_property_type of type VARCHAR2 with a length of 255, and v_max_event_id of type NUMBER; then it performs a sequence of operations starting with a SELECT statement that counts rows from the CUSTOMER_EVENTS table where the RESIDENT_ID column equals the new RESIDENT_ID value from the triggering row and the PROPERTY_ID column equals the new PROPERTY_ID value, storing the result into v_customer_count, followed by a SELECT statement that retrieves the PROPERTY_TYPE_CODE column from the PROPERTIES table for the row where PROPERTY_ID equals the new PROPERTY_ID value, storing the result into v_property_type, and then a SELECT statement that uses the NVL function to find the maximum value of the CUSTOMER_EVENT_ID column from the CUSTOMER_EVENTS table, returning 0 if the maximum is null, and stores this into v_max_event_id; after these queries, it evaluates a conditional IF-ELSIF-ELSIF-ELSE block where if v_customer_count equals 0, it executes an INSERT statement into the CUSTOMER_EVENTS table, specifying columns CUSTOMER_EVENT_ID with value v_max_event_id plus 1, CUSTOMER_ID with value 1, DATE_MOVED_IN with the new DATE_MOVED_IN value, PROPERTY_ID with the new PROPERTY_ID value, RESIDENT_ID with the new RESIDENT_ID value, and THING_ID with value 1, but if v_customer_count is not 0 and v_property_type equals the string 'house', it executes an UPDATE statement on the CUSTOMER_EVENTS table, setting the DATE_MOVED_IN column to the new DATE_MOVED_IN value for rows where the RESIDENT_ID column equals the new RESIDENT_ID value and the PROPERTY_ID column equals the new PROPERTY_ID value, but if v_customer_count is not 0 and v_property_type equals the string 'apartment', it executes a DELETE statement on the CUSTOMER_EVENTS table for rows where the RESIDENT_ID column equals the new RESIDENT_ID value and the PROPERTY_ID column equals the new PROPERTY_ID value and the DATE_MOVED_IN column equals the old DATE_MOVED_IN value from before the update, and for any other case where the preceding conditions are false, it executes an INSERT statement into the CUSTOMER_EVENTS table, specifying columns CUSTOMER_EVENT_ID with value v_max_event_id plus 2, CUSTOMER_ID with value 2, DATE_MOVED_IN with the new DATE_MOVED_IN value, PROPERTY_ID with the new PROPERTY_ID value, RESIDENT_ID with the new RESIDENT_ID value, and THING_ID with value 2.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_move_dates\nBEFORE UPDATE OF DATE_MOVED_IN ON RESIDENTS\nFOR EACH ROW\nDECLARE\n    v_customer_count NUMBER;\n    v_property_type VARCHAR2(255);\n    v_max_event_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID;\n    SELECT PROPERTY_TYPE_CODE INTO v_property_type FROM PROPERTIES WHERE PROPERTY_ID = :NEW.PROPERTY_ID;\n    SELECT NVL(MAX(CUSTOMER_EVENT_ID), 0) INTO v_max_event_id FROM CUSTOMER_EVENTS;\n    IF v_customer_count = 0 THEN\n        INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (v_max_event_id + 1, 1, :NEW.DATE_MOVED_IN, :NEW.PROPERTY_ID, :NEW.RESIDENT_ID, 1);\n    ELSIF v_property_type = 'house' THEN\n        UPDATE CUSTOMER_EVENTS SET DATE_MOVED_IN = :NEW.DATE_MOVED_IN WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID;\n    ELSIF v_property_type = 'apartment' THEN\n        DELETE FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID AND DATE_MOVED_IN = :OLD.DATE_MOVED_IN;\n    ELSE\n        INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (v_max_event_id + 2, 2, :NEW.DATE_MOVED_IN, :NEW.PROPERTY_ID, :NEW.RESIDENT_ID, 2);\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-01-15 10:00:00' WHERE RESIDENT_ID = 10 AND PROPERTY_ID = 605 AND DATE_MOVED_IN = '2015-03-27 12:00:00'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-02-01 09:30:00' WHERE RESIDENT_ID = 23 AND PROPERTY_ID = 879 AND DATE_MOVED_IN = '2017-06-17 15:43:33'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-03-10 14:15:00' WHERE RESIDENT_ID = 28 AND PROPERTY_ID = 629 AND DATE_MOVED_IN = '2017-11-14 06:28:48'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-04-20 16:45:00' WHERE RESIDENT_ID = 6 AND PROPERTY_ID = 954 AND DATE_MOVED_IN = '2017-12-18 03:46:04'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-05-05 11:20:00' WHERE RESIDENT_ID = 10 AND PROPERTY_ID = 605 AND DATE_MOVED_IN = '2024-01-15 10:00:00'"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_sync_move_dates on the RESIDENTS table when DATE_MOVED_IN is updated. Declare variables for count, property type, and max event ID. Query CUSTOMER_EVENTS and PROPERTIES tables. If count = 0, insert a new event with ID = max+1, CUSTOMER_ID=1, THING_ID=1. Else if property type is 'house', update DATE_MOVED_IN in existing events. Else if property type is 'apartment', delete events with old DATE_MOVED_IN. Otherwise, insert a new event with ID = max+2, CUSTOMER_ID=2, THING_ID=2.",
    "natural_language": "Alright, so we need a trigger called trg_sync_move_dates that fires off before any update to a row in the RESIDENTS table, specifically when the DATE_MOVED_IN field gets changed. Gotta set up some variables to hold a count, the property type, and the highest event ID we've got. Then, we'll have to check some stuff in the CUSTOMER_EVENTS and PROPERTIES tables. If the count comes back as zero, we just add a brand new event, making its ID one more than the max, and set CUSTOMER_ID and THING_ID to 1. If the count isn't zero, we check the property type. If it's a 'house', we go ahead and update the DATE_MOVED_IN in the existing events. If it's an 'apartment', we gotta delete any events that still have the old move-in date. And if it's anything else, we just insert another new event, this time with an ID of max+2 and CUSTOMER_ID and THING_ID set to 2.",
    "id": 28
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_actor_age_calc that fires automatically before any row is inserted into the ACTOR table, and for each new row, it declares a local variable v_max_id of type NUMBER, then checks if the new value for the ACTOR_ID column is NULL, and if it is, the trigger queries the ACTOR table to find the current maximum ACTOR_ID value, uses the NVL function to return 0 if no maximum is found, adds 1 to that result, stores it in v_max_id, and assigns this calculated value to the :NEW.ACTOR_ID column for the row being inserted; subsequently, the trigger checks if the new value for the AGE column is NULL, and if it is, the trigger assigns a default value of 1 to the :NEW.AGE column for the row being inserted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_actor_age_calc\nBEFORE INSERT ON ACTOR\nFOR EACH ROW\nDECLARE\n  v_max_id NUMBER;\nBEGIN\n  -- Ensure ACTOR_ID is unique if not provided\n  IF :NEW.ACTOR_ID IS NULL THEN\n    SELECT NVL(MAX(ACTOR_ID), 0) + 1 INTO v_max_id FROM ACTOR;\n    :NEW.ACTOR_ID := v_max_id;\n  END IF;\n  \n  -- Set default age if not provided\n  IF :NEW.AGE IS NULL THEN\n    :NEW.AGE := 1;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "INSERT INTO ACTOR (NAME, MUSICAL_ID, CHARACTER, DURATION, AGE) VALUES ('New Actor 1', 1, 'Character 1', '2020-', 30)",
      "INSERT INTO ACTOR (NAME, MUSICAL_ID, CHARACTER, DURATION) VALUES ('New Actor 2', 2, 'Character 2', '2021-')",
      "INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION, AGE) VALUES (100, 'New Actor 3', 1, 'Character 3', '2022-', 25)",
      "INSERT INTO ACTOR (NAME, MUSICAL_ID, CHARACTER, DURATION, AGE) VALUES ('New Actor 4', 2, 'Character 4', '2023-', NULL)",
      "INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION) VALUES (NULL, 'New Actor 5', 1, 'Character 5', '2024-')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_actor_age_calc on the ACTOR table. If NEW.ACTOR_ID IS NULL, set it to MAX(ACTOR_ID)+1 (default 0). If NEW.AGE IS NULL, set it to 1.",
    "natural_language": "Construct a BEFORE INSERT FOR EACH ROW trigger, which should be named trg_actor_age_calc, to be placed on the ACTOR table. This trigger must first check if the NEW.ACTOR_ID value is NULL; if this condition is met, it should be automatically set to the maximum existing ACTOR_ID value incremented by one, defaulting to 0 if no prior IDs exist. Subsequently, it should also verify if the NEW.AGE value is NULL and, in that specific case, assign it a default value of 1.",
    "id": 29
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named update_book_pages_trg that is automatically executed after any row in the REVIEW table is updated, but only when the specific column RATING is modified. For each individual REVIEW row affected by such an update, the trigger performs an UPDATE operation on the BOOK table. This update increases the value in the PAGES column of the BOOK table by exactly 10 for the single BOOK row where the BOOK_ID column value matches the new BOOK_ID value from the updated REVIEW row, which is accessed via the :NEW.BOOK_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER update_book_pages_trg\nAFTER UPDATE OF RATING ON REVIEW\nFOR EACH ROW\nBEGIN\n    UPDATE BOOK\n    SET PAGES = PAGES + 10\n    WHERE BOOK_ID = :NEW.BOOK_ID;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "UPDATE REVIEW SET RATING = 7.5 WHERE BOOK_ID = 1",
      "UPDATE REVIEW SET RATING = 8.2 WHERE REVIEW_ID = 2",
      "UPDATE REVIEW SET RATING = RATING + 1 WHERE BOOK_ID = 3",
      "UPDATE REVIEW SET RATING = 9.0, READERS_IN_MILLION = 3.5 WHERE BOOK_ID = 2",
      "UPDATE REVIEW SET RATING = 4.5 WHERE BOOK_ID = 4"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named update_book_pages_trg on the REVIEW table when RATING is updated. Update the BOOK table, increasing PAGES by 10 where BOOK_ID = NEW.BOOK_ID.",
    "natural_language": "When the RATING in the REVIEW table is updated, what trigger should be created to increase the PAGES by 10 in the BOOK table for the corresponding BOOK_ID?",
    "id": 30
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_stock_quantity_ceil` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `STOCK` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will execute once for every row that is being inserted into the `STOCK` table.\n\nUpon activation, the trigger declares a local PL/SQL variable named `v_avg_quantity` of data type `NUMBER`.\n\nThe trigger then proceeds to execute a `SELECT` statement. This `SELECT` statement calculates the `AVG` (average) of all existing values in the `QUANTITY` column of the `STOCK` table. The result of this average calculation is then passed to the `CEIL` function. The `CEIL` function, also known as the ceiling function, returns the smallest integer greater than or equal to the numeric expression provided. In this case, it rounds the calculated average quantity up to the nearest whole number. The final rounded-up average quantity is then stored into the previously declared local variable `v_avg_quantity`.\n\nFollowing the calculation and assignment, the trigger modifies the value of the `QUANTITY` column for the `NEW` row that is currently being inserted. Specifically, it assigns the value stored in `v_avg_quantity` to the `QUANTITY` column of the `:NEW` record. The `:NEW` pseudorecord represents the row data as it will be after the `INSERT` operation completes. This effectively overrides any `QUANTITY` value that might have been provided in the original `INSERT` statement with the calculated ceiling of the average quantity from the `STOCK` table at the time of the trigger's execution.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_stock_quantity_ceil\nBEFORE INSERT ON STOCK\nFOR EACH ROW\nDECLARE\n    v_avg_quantity NUMBER;\nBEGIN\n    SELECT CEIL(AVG(QUANTITY)) INTO v_avg_quantity FROM STOCK;\n    :NEW.QUANTITY := v_avg_quantity;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (1, 6, 50)",
      "INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (2, 6, 75)",
      "INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (3, 6, 90)",
      "INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (1, 6, 120)",
      "INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (2, 6, 130)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_stock_quantity_ceil on the STOCK table. For each new row, set its QUANTITY column to the ceiling of the average QUANTITY from all existing rows in the STOCK table.",
    "natural_language": "Set up a BEFORE INSERT FOR EACH ROW trigger called trg_stock_quantity_ceil on the STOCK table to set each new row's QUANTITY to the ceiling of the average QUANTITY from all current rows.",
    "id": 31
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_shop_location_agg that is executed after an update operation on the SHOP table. This trigger does not take any parameters. Within the trigger, declare a local variable v_location_count of type NUMBER to store the count of distinct locations. Perform a SELECT statement to count the number of distinct values in the LOCATION column of the SHOP table and store this count in the v_location_count variable. Then, execute an INSERT statement to add a new row into the STOCK table, setting the SHOP_ID, DEVICE_ID, and QUANTITY columns all to the value of v_location_count. The trigger does not include any conditional logic or function calls, and it operates solely based on the update event on the SHOP table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_shop_location_agg\nAFTER UPDATE ON SHOP\nDECLARE\n    v_location_count NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT LOCATION) INTO v_location_count FROM SHOP;\n    INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (v_location_count, v_location_count, v_location_count);\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "UPDATE SHOP SET SHOP_NAME = 'Dinas Device' WHERE SHOP_ID = 1",
      "UPDATE SHOP SET LOCATION = 'Cymmer' WHERE SHOP_ID = 2",
      "UPDATE SHOP SET OPEN_DATE = '15 July' WHERE SHOP_ID = 3",
      "UPDATE SHOP SET OPEN_YEAR = 2014 WHERE SHOP_ID = 1",
      "UPDATE SHOP SET SHOP_NAME = 'Best Buy' WHERE SHOP_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE trigger named trg_shop_location_agg on the SHOP table. After an update, count the distinct LOCATION values from SHOP, then insert a new row into the STOCK table where SHOP_ID, DEVICE_ID, and QUANTITY are all set to that count.",
    "natural_language": "How can I create an AFTER UPDATE trigger called trg_shop_location_agg on the SHOP table so that, after an update, it counts the distinct LOCATION values from SHOP and then inserts a new row into the STOCK table with SHOP_ID, DEVICE_ID, and QUANTITY all set to that count?",
    "id": 32
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_customer_payment_check that is executed before an insert operation on the CUSTOMER_PAYMENTS table for each row. The trigger begins by declaring three local variables: v_customer_status of type VARCHAR2(255), v_amount_outstanding of type NUMBER, and v_max_lesson_id of type NUMBER. The trigger first attempts to select the CUSTOMER_STATUS_CODE and AMOUNT_OUTSTANDING from the CUSTOMERS table where the CUSTOMER_ID matches the :NEW.CUSTOMER_ID, which is the ID of the customer associated with the new payment record being inserted. These values are stored into the variables v_customer_status and v_amount_outstanding, respectively. If no matching customer record is found, the trigger raises an application error with code -20001 and the message 'Customer ID does not exist'. Next, the trigger evaluates the customer status and outstanding amount. If v_customer_status equals 'Bad Customer', no further action is taken. If v_amount_outstanding is greater than or equal to :NEW.AMOUNT_PAYMENT, indicating the payment does not exceed the outstanding amount, no further action is taken. If the payment exceeds the outstanding amount, the trigger calculates the next lesson ID by selecting the maximum LESSON_ID from the LESSONS table, adding 1 to it, and storing the result in v_max_lesson_id. The trigger then inserts a new record into the LESSONS table with the following values: LESSON_ID set to v_max_lesson_id, CUSTOMER_ID set to :NEW.CUSTOMER_ID, LESSON_STATUS_CODE set to 'Cancelled', STAFF_ID set to 1, VEHICLE_ID set to 1, LESSON_DATE set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS', LESSON_TIME set to '10', and PRICE set to 100. If any other error occurs during the execution of the trigger, it raises an application error with code -20002 and a message that includes the error description from SQLERRM.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customer_payment_check\nBEFORE INSERT ON CUSTOMER_PAYMENTS\nFOR EACH ROW\nDECLARE\n    v_customer_status VARCHAR2(255);\n    v_amount_outstanding NUMBER;\n    v_max_lesson_id NUMBER;\nBEGIN\n    -- Handle case where customer doesn't exist\n    BEGIN\n        SELECT CUSTOMER_STATUS_CODE, AMOUNT_OUTSTANDING \n        INTO v_customer_status, v_amount_outstanding \n        FROM CUSTOMERS \n        WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            RAISE_APPLICATION_ERROR(-20001, 'Customer ID does not exist');\n    END;\n    \n    -- Process payment based on customer status and outstanding amount\n    IF v_customer_status = 'Bad Customer' THEN\n        -- For bad customers, we might want to just log the payment without additional actions\n        NULL;\n    ELSIF v_amount_outstanding >= :NEW.AMOUNT_PAYMENT THEN\n        -- Payment reduces outstanding amount - this should be done in AFTER trigger\n        -- to avoid mutating table issues, but keeping logic here as requested\n        NULL;\n    ELSE\n        -- Payment exceeds outstanding amount - could schedule a lesson\n        -- Get next lesson ID manually since sequence doesn't exist\n        SELECT NVL(MAX(LESSON_ID), 0) + 1 INTO v_max_lesson_id FROM LESSONS;\n        \n        -- Note: This INSERT in a BEFORE trigger on CUSTOMER_PAYMENTS could cause issues\n        -- Better design would use AFTER trigger or separate procedure\n        INSERT INTO LESSONS (\n            LESSON_ID, \n            CUSTOMER_ID, \n            LESSON_STATUS_CODE, \n            STAFF_ID, \n            VEHICLE_ID, \n            LESSON_DATE, \n            LESSON_TIME, \n            PRICE\n        ) VALUES (\n            v_max_lesson_id, \n            :NEW.CUSTOMER_ID, \n            'Cancelled', \n            1, \n            1, \n            TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), \n            '10', \n            100\n        );\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE_APPLICATION_ERROR(-20002, 'Error in payment trigger: ' || SQLERRM);\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-10-01 10:00:00', 'Direct Debit', 200)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (3, '2023-10-02 11:00:00', 'Direct Debit', 5000)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (4, '2023-10-03 12:00:00', 'Direct Debit', 10000)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-10-04 13:00:00', 'Direct Debit', 300)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (3, '2023-10-05 14:00:00', 'Direct Debit', 1000)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_customer_payment_check on the CUSTOMER_PAYMENTS table. For each new payment, fetch the customer's status and outstanding amount. If the customer doesn't exist, raise an error. If the customer status is 'Bad Customer' or the payment amount is less than or equal to the outstanding amount, do nothing. If the payment exceeds the outstanding amount, insert a new 'Cancelled' lesson record for that customer with a generated LESSON_ID, STAFF_ID=1, VEHICLE_ID=1, and PRICE=100. Handle other errors with a generic error message.",
    "natural_language": "Please construct a BEFORE INSERT FOR EACH ROW trigger, designated as trg_customer_payment_check, for the CUSTOMER_PAYMENTS table. For every newly inserted payment record, it is necessary to retrieve the associated customer's status and outstanding amount. Should the corresponding customer not exist within the database, an error must be raised. In the event that the customer's status is identified as 'Bad Customer' or if the payment amount is less than or equal to the outstanding amount, no further action is required. However, if the payment amount exceeds the outstanding amount, a new lesson record with a status of 'Cancelled' must be inserted for that customer. This record should possess a generated LESSON_ID, with STAFF_ID set to 1, VEHICLE_ID set to 1, and PRICE set to 100. Any other unforeseen errors should be managed by presenting a generic error message.",
    "id": 33
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT OR UPDATE` row-level trigger named `trg_lesson_vehicle_check` on the `LESSONS` table. This trigger executes after an `INSERT` operation or an `UPDATE` operation on any row in the `LESSONS` table. It declares two local variables: `v_vehicle_details` of type `VARCHAR2(255)` to store vehicle details and `v_staff_count` of type `NUMBER` to store the count of staff members.\n\nThe trigger's execution begins by checking if the `VEHICLE_ID` column in the newly inserted or updated row (`:NEW.VEHICLE_ID`) is not `NULL`.\nIf `:NEW.VEHICLE_ID` is not `NULL`, it attempts to select the `VEHICLE_DETAILS` column from the `VEHICLES` table into the `v_vehicle_details` variable, specifically for the row where the `VEHICLE_ID` column matches `:NEW.VEHICLE_ID`.\nIf this `SELECT` statement results in `NO_DATA_FOUND` (meaning no vehicle with the specified `VEHICLE_ID` exists), it catches this exception and sets `v_vehicle_details` to `NULL`.\nIf `:NEW.VEHICLE_ID` is `NULL`, it directly sets `v_vehicle_details` to `NULL`.\n\nNext, it checks if the `STAFF_ID` column in the newly inserted or updated row (`:NEW.STAFF_ID`) is not `NULL`.\nIf `:NEW.STAFF_ID` is not `NULL`, it counts the number of rows in the `STAFF` table where the `STAFF_ID` column matches `:NEW.STAFF_ID` and stores this count in the `v_staff_count` variable.\nIf `:NEW.STAFF_ID` is `NULL`, it sets `v_staff_count` to `0`.\n\nFollowing these data retrieval and preparation steps, the trigger proceeds with a series of conditional logic checks:\n\n1.  It first checks if the `v_vehicle_details` variable is equal to the string literal `'Car'`.\n    If this condition is true, it updates the `VEHICLES` table, setting the `VEHICLE_DETAILS` column to the string literal `'Used Car'` for the row where the `VEHICLE_ID` column matches `:NEW.VEHICLE_ID`.\n\n2.  If the first condition is false, it then checks if `v_staff_count` is equal to `0` AND `:NEW.STAFF_ID` is not `NULL`.\n    If this combined condition is true, it inserts a new row into the `STAFF` table. The `STAFF_ID` column is set to `:NEW.STAFF_ID`, `STAFF_ADDRESS_ID` is set to `1`, `NICKNAME` is set to `'auto_gen'`, `FIRST_NAME` is set to `'Auto'`, `MIDDLE_NAME` is set to `'Gen'`, `LAST_NAME` is set to `'Staff'`, `DATE_OF_BIRTH` is set to the timestamp `'2000-01-01 00:00:00'`, `DATE_JOINED_STAFF` is set to the timestamp `'2000-01-01 00:00:00'`, and `DATE_LEFT_STAFF` is set to `NULL`.\n\n3.  If both the first and second conditions are false, it then checks if `:NEW.VEHICLE_ID` is not `NULL` AND `v_vehicle_details` is not `NULL`.\n    If this combined condition is true, it deletes rows from the `VEHICLES` table where the `VEHICLE_ID` column matches `:NEW.VEHICLE_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_lesson_vehicle_check\nAFTER INSERT OR UPDATE ON LESSONS\nFOR EACH ROW\nDECLARE\n    v_vehicle_details VARCHAR2(255);\n    v_staff_count NUMBER;\nBEGIN\n    -- Handle potential NULL or non-existent VEHICLE_ID\n    IF :NEW.VEHICLE_ID IS NOT NULL THEN\n        BEGIN\n            SELECT VEHICLE_DETAILS INTO v_vehicle_details \n            FROM VEHICLES \n            WHERE VEHICLE_ID = :NEW.VEHICLE_ID;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_vehicle_details := NULL;\n        END;\n    ELSE\n        v_vehicle_details := NULL;\n    END IF;\n    \n    -- Check if STAFF_ID exists\n    IF :NEW.STAFF_ID IS NOT NULL THEN\n        SELECT COUNT(*) INTO v_staff_count \n        FROM STAFF \n        WHERE STAFF_ID = :NEW.STAFF_ID;\n    ELSE\n        v_staff_count := 0;\n    END IF;\n    \n    -- Conditional logic with proper NULL handling\n    IF v_vehicle_details = 'Car' THEN\n        UPDATE VEHICLES \n        SET VEHICLE_DETAILS = 'Used Car' \n        WHERE VEHICLE_ID = :NEW.VEHICLE_ID;\n    ELSIF v_staff_count = 0 AND :NEW.STAFF_ID IS NOT NULL THEN\n        INSERT INTO STAFF (STAFF_ID, STAFF_ADDRESS_ID, NICKNAME, FIRST_NAME, MIDDLE_NAME, LAST_NAME, DATE_OF_BIRTH, DATE_JOINED_STAFF, DATE_LEFT_STAFF) \n        VALUES (:NEW.STAFF_ID, 1, 'auto_gen', 'Auto', 'Gen', 'Staff', '2000-01-01 00:00:00', '2000-01-01 00:00:00', NULL);\n    ELSIF :NEW.VEHICLE_ID IS NOT NULL AND v_vehicle_details IS NOT NULL THEN\n        DELETE FROM VEHICLES \n        WHERE VEHICLE_ID = :NEW.VEHICLE_ID;\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, LESSON_STATUS_CODE, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (100, 1, 'Scheduled', 1, 1, '2023-01-01', '10:00', 50)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, LESSON_STATUS_CODE, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (101, 2, 'Scheduled', 999, NULL, '2023-01-02', '11:00', 60)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, LESSON_STATUS_CODE, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (102, 3, 'Scheduled', 2, 2, '2023-01-03', '12:00', 70)",
      "UPDATE LESSONS SET VEHICLE_ID = 3 WHERE LESSON_ID = 100",
      "UPDATE LESSONS SET STAFF_ID = 998 WHERE LESSON_ID = 101"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE FOR EACH ROW trigger named trg_lesson_vehicle_check on the LESSONS table. For each new or updated row, retrieve vehicle details if VEHICLE_ID is not null, and count staff if STAFF_ID is not null. If vehicle details are 'Car', update that vehicle's details to 'Used Car'. If the staff count is 0 and STAFF_ID is not null, insert a new auto-generated staff record. If VEHICLE_ID is not null and vehicle details are not null (but not 'Car'), delete that vehicle record.",
    "natural_language": "Please construct an AFTER INSERT OR UPDATE FOR EACH ROW trigger, designated as trg_lesson_vehicle_check, on the LESSONS table. For each newly inserted or modified row, it is required to fetch the associated vehicle details, provided the VEHICLE_ID is not null, and to calculate the count of staff members if the STAFF_ID is not null. Should the retrieved vehicle details be identified as 'Car', the corresponding vehicle record must be updated to reflect the status 'Used Car'. In the event that the staff count is determined to be zero while a STAFF_ID is present, a new staff record with auto-generated identifiers should be inserted. Furthermore, if a VEHICLE_ID is present and the associated vehicle details are not null, yet are not equivalent to 'Car', the pertinent vehicle record is to be deleted.",
    "id": 34
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_customer_status_update that fires after each row is updated on the CUSTOMERS table, declaring a local variable v_payment_count of type NUMBER and v_hex_raw of type RAW(100), and then performs a SELECT COUNT(*) query from the CUSTOMER_PAYMENTS table into v_payment_count where the CUSTOMER_ID column equals the new CUSTOMER_ID value from the updated row, and if v_payment_count is greater than 5, it assigns the hexadecimal string 'FF' converted to a raw value to v_hex_raw using the HEXTORAW function and executes an UPDATE statement on the CUSTOMERS table to set the CUSTOMER_STATUS_CODE column to the literal value 'VIP' for the row where CUSTOMER_ID equals the new CUSTOMER_ID value, but if the first condition is not met and the new AMOUNT_OUTSTANDING column value from the updated row is greater than 10000, it executes a DELETE statement on the LESSONS table for all rows where the CUSTOMER_ID column equals the new CUSTOMER_ID value, and if neither condition is true, it executes an INSERT statement into the CUSTOMER_PAYMENTS table specifying columns CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, and AMOUNT_PAYMENT with corresponding values being the new CUSTOMER_ID, the current system date from SYSDATE, the literal string 'Credit Card', and the numeric literal 100.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customer_status_update\nAFTER UPDATE ON CUSTOMERS\nFOR EACH ROW\nDECLARE\n    v_payment_count NUMBER;\n    v_hex_raw RAW(100);\nBEGIN\n    SELECT COUNT(*) INTO v_payment_count FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    IF v_payment_count > 5 THEN\n        v_hex_raw := HEXTORAW('FF');\n        UPDATE CUSTOMERS SET CUSTOMER_STATUS_CODE = 'VIP' WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    ELSIF :NEW.AMOUNT_OUTSTANDING > 10000 THEN\n        DELETE FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    ELSE\n        INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (:NEW.CUSTOMER_ID, SYSDATE, 'Credit Card', 100);\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 5000 WHERE CUSTOMER_ID = 1",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 15000 WHERE CUSTOMER_ID = 3",
      "UPDATE CUSTOMERS SET CUSTOMER_STATUS_CODE = 'Good Customer' WHERE CUSTOMER_ID = 4",
      "UPDATE CUSTOMERS SET FIRST_NAME = 'UpdatedName' WHERE CUSTOMER_ID = 6",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 200, CUSTOMER_STATUS_CODE = 'Active' WHERE CUSTOMER_ID = 8"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_customer_status_update on the CUSTOMERS table. For each updated row, count the customer's payments. If the count is greater than 5, convert 'FF' to RAW and update the customer's status to 'VIP'. Else, if the new AMOUNT_OUTSTANDING is greater than 10000, delete all lessons for that customer. Otherwise, insert a new payment record for the customer with 100 units paid via 'Credit Card'.",
    "natural_language": "Construct an AFTER UPDATE FOR EACH ROW trigger, which should be named trg_customer_status_update, on the CUSTOMERS table. For every individual row that has been updated, meticulously calculate the total number of payments associated with that specific customer. Should this detailed count exceed the threshold of five, it is necessary to convert the 'FF' value to RAW and subsequently update the customer's status designation to the privileged 'VIP' category. Alternatively, if the new AMOUNT_OUTSTANDING figure is discovered to be greater than 10000, then proceed to comprehensively delete every single lesson record pertaining to that particular customer. In all other remaining scenarios, you must carefully insert a brand new payment record for the customer, specifying an amount of 100 units that were settled using the 'Credit Card' payment method.",
    "id": 35
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_vehicle_status_check that fires for DELETE operations on the VEHICLES table, which first declares a record type vehicle_rec with fields vehicle_id of type NUMBER, vehicle_details of type VARCHAR2(255), and lesson_count of type NUMBER, then declares a nested table type vehicle_list of that record type, and initializes a global collection variable g_vehicles of that type; the trigger's BEFORE EACH ROW section, for each row being deleted, selects the count of related records from the LESSONS table where the LESSONS.VEHICLE_ID column equals the :OLD.VEHICLE_ID value from the deleted VEHICLES row, stores this count in a local variable v_lesson_count, extends the global collection g_vehicles, and populates the new collection element with the :OLD.VEHICLE_ID, :OLD.VEHICLE_DETAILS, and the calculated v_lesson_count, then conditionally deletes all rows from the LESSONS table where LESSONS.VEHICLE_ID equals :OLD.VEHICLE_ID if the v_lesson_count is zero and the :OLD.VEHICLE_DETAILS is not equal to the string 'Truck'; the trigger's AFTER STATEMENT section then iterates through all elements in the populated g_vehicles collection, and for each element, if the stored lesson_count is greater than zero, it inserts a new row into the VEHICLES table with the stored vehicle_id and the string 'Archived' for the VEHICLE_DETAILS column, else if the stored vehicle_details equals the string 'Truck', it inserts a new row into the VEHICLES table with the stored vehicle_id and the string 'Old Truck' for the VEHICLE_DETAILS column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_vehicle_status_check\nFOR DELETE ON VEHICLES\nCOMPOUND TRIGGER\n\n    TYPE vehicle_rec IS RECORD (\n        vehicle_id NUMBER,\n        vehicle_details VARCHAR2(255),\n        lesson_count NUMBER\n    );\n    \n    TYPE vehicle_list IS TABLE OF vehicle_rec;\n    g_vehicles vehicle_list := vehicle_list();\n    \nBEFORE EACH ROW IS\n    v_lesson_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_lesson_count FROM LESSONS WHERE VEHICLE_ID = :OLD.VEHICLE_ID;\n    \n    g_vehicles.EXTEND;\n    g_vehicles(g_vehicles.LAST).vehicle_id := :OLD.VEHICLE_ID;\n    g_vehicles(g_vehicles.LAST).vehicle_details := :OLD.VEHICLE_DETAILS;\n    g_vehicles(g_vehicles.LAST).lesson_count := v_lesson_count;\n    \n    IF v_lesson_count = 0 AND :OLD.VEHICLE_DETAILS != 'Truck' THEN\n        DELETE FROM LESSONS WHERE VEHICLE_ID = :OLD.VEHICLE_ID;\n    END IF;\nEND BEFORE EACH ROW;\n\nAFTER STATEMENT IS\nBEGIN\n    FOR i IN 1..g_vehicles.COUNT LOOP\n        IF g_vehicles(i).lesson_count > 0 THEN\n            INSERT INTO VEHICLES (VEHICLE_ID, VEHICLE_DETAILS) \n            VALUES (g_vehicles(i).vehicle_id, 'Archived');\n        ELSIF g_vehicles(i).vehicle_details = 'Truck' THEN\n            INSERT INTO VEHICLES (VEHICLE_ID, VEHICLE_DETAILS) \n            VALUES (g_vehicles(i).vehicle_id, 'Old Truck');\n        END IF;\n    END LOOP;\nEND AFTER STATEMENT;\n\nEND trg_vehicle_status_check;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 1 AND VEHICLE_DETAILS = 'Van'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 2 AND VEHICLE_DETAILS = 'Truck'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 3 AND VEHICLE_DETAILS = 'Car'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 4 AND VEHICLE_DETAILS = 'Motorcycle'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 5 AND VEHICLE_DETAILS = 'Truck'"
    ],
    "summary": "Create a compound trigger named trg_vehicle_status_check for DELETE operations on the VEHICLES table. Declare a record type with vehicle_id, vehicle_details, and lesson_count fields, and a nested table type of that record. Initialize a global collection variable of that type. In the BEFORE EACH ROW section, for each deleted row, count related records in the LESSONS table. Store the count, extend the global collection, and populate it with the old vehicle data and the count. If the count is zero and the old vehicle_details is not 'Truck', delete related records from the LESSONS table. In the AFTER STATEMENT section, iterate through the collection. If lesson_count > 0, insert a new row into VEHICLES with the old vehicle_id and 'Archived' details. If vehicle_details equals 'Truck', insert a new row with the old vehicle_id and 'Old Truck' details.",
    "natural_language": "Set up a trigger for deletions on the VEHICLES table, maybe call it something like trg_vehicle_status_check. You'll need to define a record type with fields for the vehicle ID, its details, and a count of related lessons, and then a nested table based on that. Have a global collection variable ready. Before each row is deleted, check how many lessons are tied to that vehicle and stash the old vehicle info along with that count in the collection. If there aren't any lessons and the vehicle wasn't a Truck, go ahead and clear out any related lesson records. After the whole delete is done, look through the saved data. For entries with some lessons, put a new row back into VEHICLES marking it as 'Archived'. If the original details were for a Truck, add a new row calling it an 'Old Truck'.",
    "id": 36
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_company_rank_avg` that is activated `AFTER` any `INSERT`, `UPDATE`, or `DELETE` operation on the `STATION_COMPANY` table. This trigger declares a local numeric variable `v_avg_rank` to store the calculated average rank, and another local numeric variable `v_company_id` to hold the identifier of a company. It also defines a cursor named `c_companies` which is designed to select all `DISTINCT` `COMPANY_ID` values from the `STATION_COMPANY` table. Upon activation, the trigger first `OPEN`s the `c_companies` cursor. It then enters a `LOOP` to process each distinct company. Inside the loop, it `FETCH`es the next `COMPANY_ID` from `c_companies` into the `v_company_id` variable. The loop `EXIT`s `WHEN` `c_companies%NOTFOUND` becomes true, indicating that no more rows are available in the cursor. For each `v_company_id` fetched, the trigger executes a `SELECT` statement to calculate the `AVG` (average) of the `RANK_OF_THE_YEAR` column from the `STATION_COMPANY` table, specifically for rows where the `COMPANY_ID` matches the current `v_company_id`, and stores this average value into the `v_avg_rank` variable. Subsequently, it performs an `UPDATE` operation on the `COMPANY` table, setting the `RANK` column to the `ROUND`ed value of `v_avg_rank`, for the row where the `COMPANY_ID` matches the current `v_company_id`. After iterating through all distinct companies, the trigger `CLOSE`s the `c_companies` cursor.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_rank_avg\nAFTER INSERT OR UPDATE OR DELETE ON STATION_COMPANY\nDECLARE\n    v_avg_rank NUMBER;\n    v_company_id NUMBER;\n    CURSOR c_companies IS SELECT DISTINCT COMPANY_ID FROM STATION_COMPANY;\nBEGIN\n    OPEN c_companies;\n    LOOP\n        FETCH c_companies INTO v_company_id;\n        EXIT WHEN c_companies%NOTFOUND;\n        SELECT AVG(RANK_OF_THE_YEAR) INTO v_avg_rank FROM STATION_COMPANY WHERE COMPANY_ID = v_company_id;\n        UPDATE COMPANY SET RANK = ROUND(v_avg_rank) WHERE COMPANY_ID = v_company_id;\n    END LOOP;\n    CLOSE c_companies;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (1, 1, 5)",
      "UPDATE STATION_COMPANY SET RANK_OF_THE_YEAR = 3 WHERE STATION_ID = 1 AND COMPANY_ID = 1",
      "DELETE FROM STATION_COMPANY WHERE STATION_ID = 1 AND COMPANY_ID = 1",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (2, 1, 2)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (3, 2, 1)"
    ],
    "summary": "Create a trigger named trg_company_rank_avg that fires AFTER INSERT, UPDATE, or DELETE on the STATION_COMPANY table. Declare variables for average rank and company ID. Define a cursor to select distinct COMPANY_ID values. Open the cursor, loop through each company ID, calculate the average RANK_OF_THE_YEAR for that company, and update the RANK column in the COMPANY table with the rounded average. Close the cursor after processing all companies.",
    "natural_language": "Alright, so we need a trigger called trg_company_rank_avg that kicks in AFTER we INSERT, UPDATE, or DELETE stuff in the STATION_COMPANY table. Gotta set up some variables to hold the average rank and a company ID. Then, grab a cursor to pick out all the unique COMPANY_IDs. Open that cursor, loop through each company ID one by one, figure out the average RANK_OF_THE_YEAR for that specific company, and use it to update the RANK column in the COMPANY tablejust round that average first. Don't forget to close the cursor once you're done looping through all the companies.",
    "id": 37
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_station_year_update that fires automatically after any row in the GAS_STATION table is updated specifically on its OPEN_YEAR column; for each updated row, the trigger first deletes all records from the STATION_COMPANY table where the STATION_COMPANY.STATION_ID column matches the old STATION_ID value from the GAS_STATION row before the update, referenced as :OLD.STATION_ID, and then immediately inserts a single new record into the STATION_COMPANY table, populating the STATION_ID column with the new STATION_ID value from the updated GAS_STATION row referenced as :NEW.STATION_ID, populating the COMPANY_ID column with the result of the arithmetic expression MOD(:NEW.STATION_ID, 10) + 1 which calculates the remainder of the new station ID divided by 10 and then adds 1, and populating the RANK_OF_THE_YEAR column with the result of the arithmetic expression ABS(:NEW.OPEN_YEAR - 2000) which calculates the absolute difference between the newly updated OPEN_YEAR value and the base year 2000.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_station_year_update\nAFTER UPDATE OF OPEN_YEAR ON GAS_STATION\nFOR EACH ROW\nBEGIN\n    DELETE FROM STATION_COMPANY WHERE STATION_ID = :OLD.STATION_ID;\n    INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR)\n    VALUES (:NEW.STATION_ID, MOD(:NEW.STATION_ID, 10) + 1, ABS(:NEW.OPEN_YEAR - 2000));\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "UPDATE GAS_STATION SET OPEN_YEAR = 2005 WHERE STATION_ID = 1",
      "UPDATE GAS_STATION SET OPEN_YEAR = 1995 WHERE STATION_ID = 2",
      "UPDATE GAS_STATION SET OPEN_YEAR = 2010 WHERE STATION_ID = 3",
      "UPDATE GAS_STATION SET OPEN_YEAR = 2020 WHERE STATION_ID = 10",
      "UPDATE GAS_STATION SET OPEN_YEAR = 1988 WHERE STATION_ID = 15"
    ],
    "summary": "Create a trigger named trg_station_year_update that fires AFTER UPDATE on the OPEN_YEAR column of the GAS_STATION table. For each updated row, delete records from STATION_COMPANY where STATION_ID matches the old value. Then insert a new record into STATION_COMPANY with the new STATION_ID, a COMPANY_ID calculated as MOD(:NEW.STATION_ID, 10) + 1, and a RANK_OF_THE_YEAR calculated as ABS(:NEW.OPEN_YEAR - 2000).",
    "natural_language": "Set up a trigger called trg_station_year_update that goes off after someone changes the OPEN_YEAR in the GAS_STATION table. Whenever that happens, get rid of the entries in STATION_COMPANY linked to the old station ID. Then, put in a fresh record there using the new station ID, a company ID figured out from the new station number, and a yearly rank based on how far the new open year is from the turn of the century.",
    "id": 38
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_company_sales_adjust` that is configured to execute `BEFORE` any `INSERT` operation is performed on the `COMPANY` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its body will execute once for every row that is being inserted into the `COMPANY` table. Within the trigger's execution block, the following operations are performed: First, the value of the `SALES_BILLION` column for the `NEW` row being inserted into the `COMPANY` table is updated by multiplying its current value by `1.1`. This effectively increases the `SALES_BILLION` value by 10%. Second, an `UPDATE` statement is executed on the `GAS_STATION` table. This `UPDATE` statement sets the value of the `LOCATION` column to its `UPPERCASE` equivalent for all rows in the `GAS_STATION` table where the `STATION_ID` column matches the result of the `MOD` (modulo) operation performed on the `COMPANY_ID` of the `NEW` row being inserted into the `COMPANY` table and the integer `100`. The `MOD` function returns the remainder of the division of `NEW.COMPANY_ID` by `100`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_sales_adjust\nBEFORE INSERT ON COMPANY\nFOR EACH ROW\nBEGIN\n    :NEW.SALES_BILLION := :NEW.SALES_BILLION * 1.1;\n    UPDATE GAS_STATION SET LOCATION = UPPER(LOCATION) WHERE STATION_ID = MOD(:NEW.COMPANY_ID, 100);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (101, 5, 'New Company 1', 'USA', 'Tech', 100.0, 10.0, 50.0, 200.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (202, 6, 'New Company 2', 'Germany', 'Automotive', 200.0, 20.0, 100.0, 300.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (303, 7, 'New Company 3', 'Japan', 'Electronics', 150.0, 15.0, 75.0, 250.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (404, 8, 'New Company 4', 'China', 'Manufacturing', 250.0, 25.0, 125.0, 350.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (505, 9, 'New Company 5', 'UK', 'Finance', 120.0, 12.0, 60.0, 220.0)"
    ],
    "summary": "Create a trigger named trg_company_sales_adjust that fires BEFORE INSERT on the COMPANY table for each row. Increase the new row's SALES_BILLION value by 10%. Then update the GAS_STATION table, setting the LOCATION to uppercase for all rows where STATION_ID equals MOD(:NEW.COMPANY_ID, 100).",
    "natural_language": "Before inserting into COMPANY, trigger trg_company_sales_adjust raises new SALES_BILLION by 10% and uppercases GAS_STATION.LOCATION where STATION_ID matches MOD(:NEW.COMPANY_ID, 100).",
    "id": 39
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_company_industry_agg that is executed after an update operation on the MAIN_INDUSTRY column of the COMPANY table. This trigger performs several operations: first, it declares three variables, v_max_sales, v_min_profits, and v_company_id, all of type NUMBER, to store the maximum sales, minimum profits, and maximum company ID, respectively. It then selects the maximum value from the SALES_BILLION column of the COMPANY table into the v_max_sales variable, and the minimum value from the PROFITS_BILLION column into the v_min_profits variable. Additionally, it retrieves the maximum value from the COMPANY_ID column into the v_company_id variable. Following these selections, the trigger updates the COMPANY table by increasing the MARKET_VALUE column by the result of the expression (v_max_sales - v_min_profits) / 10 for all rows where the SALES_BILLION value is greater than half of v_max_sales. Subsequently, the trigger inserts new records into the STATION_COMPANY table by selecting the STATION_ID from the GAS_STATION table and using the previously determined v_company_id and the ceiling value of v_max_sales divided by 100 as the RANK_OF_THE_YEAR. This insertion only occurs for gas stations that opened after the year 2000 and do not already have an entry in the STATION_COMPANY table with the same STATION_ID and COMPANY_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_industry_agg\nAFTER UPDATE OF MAIN_INDUSTRY ON COMPANY\nDECLARE\n    v_max_sales NUMBER;\n    v_min_profits NUMBER;\n    v_company_id NUMBER; -- Declare a variable to hold the MAX(COMPANY_ID)\nBEGIN\n    SELECT MAX(SALES_BILLION) INTO v_max_sales FROM COMPANY;\n    SELECT MIN(PROFITS_BILLION) INTO v_min_profits FROM COMPANY;\n    SELECT MAX(COMPANY_ID) INTO v_company_id FROM COMPANY; -- Get the company_id once\n\n    UPDATE COMPANY SET MARKET_VALUE = MARKET_VALUE + (v_max_sales - v_min_profits) / 10 WHERE SALES_BILLION > v_max_sales * 0.5;\n\n    INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR)\n    SELECT gs.STATION_ID, v_company_id, CEIL(v_max_sales/100)\n    FROM GAS_STATION gs\n    WHERE gs.OPEN_YEAR > 2000\n      AND NOT EXISTS (\n        SELECT 1\n        FROM STATION_COMPANY sc\n        WHERE sc.STATION_ID = gs.STATION_ID\n          AND sc.COMPANY_ID = v_company_id\n      );\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Renewable Energy' WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Technology' WHERE COMPANY_ID = 2",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Finance' WHERE COMPANY_ID = 3",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Healthcare' WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Automotive' WHERE COMPANY_ID = 2"
    ],
    "summary": "Create a trigger named trg_company_industry_agg that fires AFTER UPDATE on the MAIN_INDUSTRY column of the COMPANY table. Declare variables to store the maximum SALES_BILLION, minimum PROFITS_BILLION, and maximum COMPANY_ID. Select these values into the variables. Update the COMPANY table, increasing the MARKET_VALUE by (max_sales - min_profits) / 10 for rows where SALES_BILLION > half of the maximum sales. Insert new records into the STATION_COMPANY table by selecting STATION_ID from GAS_STATION where OPEN_YEAR > 2000, using the maximum company ID and the ceiling of (max_sales / 100) as RANK_OF_THE_YEAR, only for stations not already existing in STATION_COMPANY with the same IDs.",
    "natural_language": "Construct a trigger designated as trg_company_industry_agg, which is to be executed subsequent to an update operation on the MAIN_INDUSTRY column within the COMPANY table. It is necessary to declare variables for the purpose of storing the highest SALES_BILLION value, the lowest PROFITS_BILLION value, and the highest COMPANY_ID value. These aggregate values should be selected into their respective variables. Subsequently, perform an update on the COMPANY table, wherein the MARKET_VALUE is incremented by the quotient of (maximum sales minus minimum profits) divided by ten. This adjustment is to be applied exclusively to those rows where the SALES_BILLION figure exceeds fifty percent of the identified maximum sales. Furthermore, insert new records into the STATION_COMPANY table. This insertion should involve selecting the STATION_ID from the GAS_STATION table for stations established after the year 2000. Utilize the maximum company ID and the ceiling value of (maximum sales divided by one hundred) for the RANK_OF_THE_YEAR column. This operation must ensure that stations with identifiers already present in the STATION_COMPANY table are not duplicated.",
    "id": 40
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_country_population that is defined to fire automatically before any INSERT or UPDATE operation is committed to the COUNTRY table, executing once for each row being modified. The trigger declares a local variable v_coaster_count of type NUMBER. For each affected row, the trigger performs a SELECT statement that counts all rows in the ROLLER_COASTER table where the COUNTRY_ID column matches the new COUNTRY_ID value (referenced as :NEW.COUNTRY_ID) from the triggering row in the COUNTRY table, storing the result into v_coaster_count. Following this query, the trigger uses an IF-ELSIF-ELSE conditional block to modify the new POPULATION value (referenced as :NEW.POPULATION) for the row in the COUNTRY table. If v_coaster_count is greater than 5, it increases the :NEW.POPULATION by 1000. If v_coaster_count is between 1 and 5 inclusive, it increases the :NEW.POPULATION by 500. If v_coaster_count is 0, it increases the :NEW.POPULATION by 100.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_country_population\nBEFORE INSERT OR UPDATE ON COUNTRY\nFOR EACH ROW\nDECLARE\n    v_coaster_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_coaster_count FROM ROLLER_COASTER WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n    IF v_coaster_count > 5 THEN\n        :NEW.POPULATION := :NEW.POPULATION + 1000;\n    ELSIF v_coaster_count BETWEEN 1 AND 5 THEN\n        :NEW.POPULATION := :NEW.POPULATION + 500;\n    ELSE\n        :NEW.POPULATION := :NEW.POPULATION + 100;\n    END IF;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'Norway', 5370000, 385207, 'Norwegian')",
      "UPDATE COUNTRY SET POPULATION = 5400000 WHERE COUNTRY_ID = 1",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (5, 'Denmark', 5830000, 42933, 'Danish')",
      "UPDATE COUNTRY SET POPULATION = 5300000 WHERE COUNTRY_ID = 2",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'Iceland', 364000, 103000, 'Icelandic')"
    ],
    "summary": "Create a trigger named trg_check_country_population that fires before each row insert or update on the COUNTRY table. For each row, count the roller coasters for the new country ID. If the count is greater than 5, increase the new population by 1000. If the count is between 1 and 5, increase it by 500. If the count is 0, increase it by 100.",
    "natural_language": "Construct a trigger designated as trg_check_country_population, which is to be executed prior to each row insertion or update operation on the COUNTRY table. For every row processed, ascertain the quantity of roller coasters associated with the new country identifier. Should this count exceed five, augment the new population value by one thousand. In the event the count falls within the inclusive range of one to five, increase the population by five hundred. If the count is determined to be zero, then increase the population by one hundred.",
    "id": 41
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_roller_coaster_status that is defined to fire automatically before any update operation that modifies the STATUS column on the ROLLER_COASTER table, executing once for each row being updated. The trigger declares a local variable v_country_population of type NUMBER. For each row, the trigger executes a SELECT statement to query the POPULATION column from the COUNTRY table, retrieving the value where the COUNTRY_ID in the COUNTRY table matches the new value of the COUNTRY_ID column from the updated row in the ROLLER_COASTER table, which is referenced as :NEW.COUNTRY_ID, and stores the result into the v_country_population variable. The trigger then uses an IF-ELSIF-ELSE conditional block to evaluate the retrieved population value: if v_country_population is greater than 10000000, it assigns the string literal 'High Demand' to the :NEW.STATUS pseudorecord column; else if v_country_population is between 5000000 and 10000000 inclusive, it assigns the string literal 'Moderate Demand' to :NEW.STATUS; otherwise, for any population value less than 5000000, it assigns the string literal 'Low Demand' to :NEW.STATUS.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_roller_coaster_status\nBEFORE UPDATE OF STATUS ON ROLLER_COASTER\nFOR EACH ROW\nDECLARE\n    v_country_population NUMBER;\nBEGIN\n    SELECT POPULATION INTO v_country_population FROM COUNTRY WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n    IF v_country_population > 10000000 THEN\n        :NEW.STATUS := 'High Demand';\n    ELSIF v_country_population BETWEEN 5000000 AND 10000000 THEN\n        :NEW.STATUS := 'Moderate Demand';\n    ELSE\n        :NEW.STATUS := 'Low Demand';\n    END IF;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "UPDATE ROLLER_COASTER SET STATUS = 'Operating' WHERE ROLLER_COASTER_ID = 1",
      "UPDATE ROLLER_COASTER SET STATUS = 'Maintenance' WHERE ROLLER_COASTER_ID = 2",
      "UPDATE ROLLER_COASTER SET STATUS = 'Closed' WHERE ROLLER_COASTER_ID = 3",
      "UPDATE ROLLER_COASTER SET STATUS = 'Testing' WHERE ROLLER_COASTER_ID = 1 AND COUNTRY_ID = 1",
      "UPDATE ROLLER_COASTER SET STATUS = 'Open' WHERE ROLLER_COASTER_ID = 2 AND COUNTRY_ID = 2"
    ],
    "summary": "Create a trigger named trg_update_roller_coaster_status that fires before each row update on the ROLLER_COASTER table when the STATUS column is modified. For each row, get the population of the new country ID. If the population is greater than 10,000,000, set the new status to 'High Demand'. If the population is between 5,000,000 and 10,000,000, set it to 'Moderate Demand'. Otherwise, set it to 'Low Demand'.",
    "natural_language": "Set up a trigger called trg_update_roller_coaster_status to run before any row in the ROLLER_COASTER table is updated, specifically when its STATUS changes. For the updated entry, check the population linked to the new country. If that population is quite large, mark the status as 'High Demand'. If the population is just moderately sized, use 'Moderate Demand'. For smaller populations, the status should be set to 'Low Demand'.",
    "id": 42
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_worth_update that activates after an update to the NET_WORTH_MILLIONS column in the SINGER table for each row affected. The trigger declares two local variables: v_year of type NUMBER to store the current year extracted from the system date, and v_count of type NUMBER to store the count of songs associated with the singer whose net worth has been updated. It retrieves the count of songs from the SONG table where the SINGER_ID matches the updated row's SINGER_ID using a SELECT COUNT(*) statement and stores the result in v_count. The trigger then evaluates the updated NET_WORTH_MILLIONS value using conditional logic. If the updated net worth exceeds 50 million and the singer has one or more songs (v_count > 0), it appends '_GOLD' to the TITLE of each song associated with the singer by executing an UPDATE statement on the SONG table. If the net worth is less than 10 million and the singer has songs, it appends '_BRONZE' to the TITLE of each song. If the net worth is between 10 and 50 million inclusive and the singer has songs, it appends '_SILVER' to the TITLE of each song. If none of these conditions are met, specifically if the singer has no songs or the net worth does not fall within the specified ranges, it deletes songs from the SONG table where the SINGER_ID matches the updated row's SINGER_ID and the SALES column value is less than 1000, using a DELETE statement.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_worth_update\nAFTER UPDATE OF NET_WORTH_MILLIONS ON SINGER\nFOR EACH ROW\nDECLARE\n    v_year NUMBER;\n    v_count NUMBER;\nBEGIN\n    v_year := EXTRACT(YEAR FROM CURRENT_DATE);\n    SELECT COUNT(*) INTO v_count FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID;\n    IF :NEW.NET_WORTH_MILLIONS > 50 AND v_count > 0 THEN\n        UPDATE SONG SET TITLE = TITLE || '_GOLD' WHERE SINGER_ID = :NEW.SINGER_ID;\n    ELSIF :NEW.NET_WORTH_MILLIONS < 10 AND v_count > 0 THEN\n        UPDATE SONG SET TITLE = TITLE || '_BRONZE' WHERE SINGER_ID = :NEW.SINGER_ID;\n    ELSIF :NEW.NET_WORTH_MILLIONS BETWEEN 10 AND 50 AND v_count > 0 THEN\n        UPDATE SONG SET TITLE = TITLE || '_SILVER' WHERE SINGER_ID = :NEW.SINGER_ID;\n    ELSE\n        DELETE FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID AND SALES < 1000;\n    END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 60 WHERE SINGER_ID = 1",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 5 WHERE SINGER_ID = 2",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 25 WHERE SINGER_ID = 3",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 70 WHERE SINGER_ID = 4",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 8 WHERE SINGER_ID = 5"
    ],
    "summary": "Create a trigger named trg_singer_worth_update that fires after each row update on the SINGER table's NET_WORTH_MILLIONS column. For each row, count the singer's songs. If the new net worth is greater than 50 million and the song count is greater than 0, append '_GOLD' to all their song titles. If the net worth is less than 10 million and there are songs, append '_BRONZE'. If the net worth is between 10 and 50 million and there are songs, append '_SILVER'. Otherwise, if the conditions are not met, delete the singer's songs where sales are less than 1000.",
    "natural_language": "Construct a trigger, which should be named trg_singer_worth_update, that is meticulously designed to activate automatically after each individual row is updated specifically within the NET_WORTH_MILLIONS column of the SINGER table. For every updated singer record, you must first calculate the total number of songs associated with that particular artist. Subsequently, if the newly entered net worth figure substantially exceeds 50 million and, concurrently, the artist's song count is confirmed to be greater than zero, then you are required to systematically append the suffix '_GOLD' to the title of every single one of their songs. Conversely, if the net worth regrettably falls below 10 million while the artist still has songs listed, you must instead attach the suffix '_BRONZE' to all their song titles. In the scenario where the net worth is determined to be comfortably situated between 10 and 50 million inclusive and there are indeed songs present, the appropriate suffix to append becomes '_SILVER'. Finally, in all other cases where none of the aforementioned detailed conditions are satisfactorily met, you must proceed to delete any and all of that singer's songs for which the recorded sales are unfortunately less than 1000 units.",
    "id": 43
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_title_transform that fires automatically before each row is inserted into the SONG table, and within its execution block, it first declares two local variables v_citizenship as a VARCHAR2 with a maximum length of 255 characters and v_birth_year as a NUMBER, then it performs a SELECT query on the SINGER table to retrieve the CITIZENSHIP and BIRTH_YEAR columns for the specific singer whose SINGER_ID matches the new :NEW.SINGER_ID value from the incoming SONG row, storing the results into the v_citizenship and v_birth_year variables, then it calculates a modulo result by performing the MOD function on the new :NEW.SONG_ID value with a divisor of 4 and stores this result in the v_mod_result variable, then it evaluates a series of conditional IF-ELSIF-ELSE statements: if the retrieved v_citizenship equals the string literal 'United States' and the retrieved v_birth_year is greater than 1950, it transforms the new :NEW.TITLE column value by applying the UPPER function to convert the entire title string to uppercase; otherwise, if the v_citizenship equals 'France' and the calculated v_mod_result equals 0, it appends the suffix '_FR' to the new :NEW.TITLE using the concatenation operator; otherwise, if the v_birth_year is less than 1940 or the v_mod_result equals 1, it truncates the new :NEW.TITLE to only its first 10 characters using the SUBSTR function with a start position of 1 and a length of 10; if none of the previous conditions are met, it appends an underscore followed by the string representation of the v_birth_year value to the new :NEW.TITLE, converting the number to a character string using the TO_CHAR function.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_title_transform\nBEFORE INSERT ON SONG\nFOR EACH ROW\nDECLARE\n    v_citizenship VARCHAR2(255);\n    v_birth_year NUMBER;\n    v_mod_result NUMBER;\nBEGIN\n    SELECT CITIZENSHIP, BIRTH_YEAR INTO v_citizenship, v_birth_year FROM SINGER WHERE SINGER_ID = :NEW.SINGER_ID;\n    v_mod_result := MOD(:NEW.SONG_ID, 4);\n    IF v_citizenship = 'United States' AND v_birth_year > 1950 THEN\n        :NEW.TITLE := UPPER(:NEW.TITLE);\n    ELSIF v_citizenship = 'France' AND v_mod_result = 0 THEN\n        :NEW.TITLE := :NEW.TITLE || '_FR';\n    ELSIF v_birth_year < 1940 OR v_mod_result = 1 THEN\n        :NEW.TITLE := SUBSTR(:NEW.TITLE, 1, 10);\n    ELSE\n        :NEW.TITLE := :NEW.TITLE || '_' || TO_CHAR(v_birth_year);\n    END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION) VALUES (1, 'My Song 1', 1, 100000, 1)",
      "INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION) VALUES (2, 'My Song 2', 2, 200000, 2)",
      "INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION) VALUES (3, 'My Song 3', 1, 300000, 3)",
      "INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION) VALUES (4, 'My Song 4', 2, 400000, 4)",
      "INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION) VALUES (5, 'My Song 5', 1, 500000, 5)"
    ],
    "summary": "Create a trigger named trg_song_title_transform that fires before each row insert on the SONG table. For each row, get the singer's citizenship and birth year. Calculate the new song ID modulo 4. If the singer is from the United States and born after 1950, convert the new title to uppercase. Else if the singer is from France and the modulo result is 0, append '_FR' to the title. Else if the singer was born before 1940 or the modulo result is 1, truncate the title to 10 characters. Otherwise, append an underscore and the birth year to the title.",
    "natural_language": "Before inserting into SONG, trigger trg_song_title_transform modifies the title based on singer citizenship, birth year, and new song ID modulo 4.",
    "id": 44
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_citizenship_check that fires before each row of the SONG table is updated specifically when the SINGER_ID column is modified, declaring local variables v_old_citizenship and v_new_citizenship as VARCHAR2(255) and v_old_worth and v_new_worth as NUMBER, then performing two SELECT statements: the first query retrieves the CITIZENSHIP and NET_WORTH_MILLIONS columns from the SINGER table into v_old_citizenship and v_old_worth where the SINGER_ID matches the :OLD.SINGER_ID value from the triggering row, and the second query retrieves the same columns from the SINGER table into v_new_citizenship and v_new_worth where the SINGER_ID matches the :NEW.SINGER_ID value, subsequently executing a conditional IF-ELSIF-ELSIF-ELSE block where, if v_old_citizenship is not equal to v_new_citizenship and v_new_worth is greater than v_old_worth, it appends the string '_UPGRADE' to the :NEW.TITLE column value; else if v_old_citizenship is equal to v_new_citizenship and v_new_worth is less than v_old_worth, it appends the string '_DOWN' to the :NEW.TITLE column value; else if v_new_citizenship is exactly the string 'France' and v_old_citizenship is not 'France', it updates the :NEW.SALES column by multiplying its original value by 0.9 and applying the ROUND function to the result; otherwise, in the final ELSE case, it sets the :NEW.HIGHEST_POSITION column to NULL and increases the :NEW.SALES column value by 1000.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_citizenship_check\nBEFORE UPDATE OF SINGER_ID ON SONG\nFOR EACH ROW\nDECLARE\n    v_old_citizenship VARCHAR2(255);\n    v_new_citizenship VARCHAR2(255);\n    v_old_worth NUMBER;\n    v_new_worth NUMBER;\nBEGIN\n    SELECT CITIZENSHIP, NET_WORTH_MILLIONS INTO v_old_citizenship, v_old_worth FROM SINGER WHERE SINGER_ID = :OLD.SINGER_ID;\n    SELECT CITIZENSHIP, NET_WORTH_MILLIONS INTO v_new_citizenship, v_new_worth FROM SINGER WHERE SINGER_ID = :NEW.SINGER_ID;\n    IF v_old_citizenship != v_new_citizenship AND v_new_worth > v_old_worth THEN\n        :NEW.TITLE := :NEW.TITLE || '_UPGRADE';\n    ELSIF v_old_citizenship = v_new_citizenship AND v_new_worth < v_old_worth THEN\n        :NEW.TITLE := :NEW.TITLE || '_DOWN';\n    ELSIF v_new_citizenship = 'France' AND v_old_citizenship != 'France' THEN\n        :NEW.SALES := ROUND(:NEW.SALES * 0.9);\n    ELSE\n        :NEW.HIGHEST_POSITION := NULL;\n        :NEW.SALES := :NEW.SALES + 1000;\n    END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SONG SET SINGER_ID = 2 WHERE SONG_ID = 3",
      "UPDATE SONG SET SINGER_ID = 1 WHERE SONG_ID = 4",
      "UPDATE SONG SET SINGER_ID = 3 WHERE SONG_ID = 5",
      "UPDATE SONG SET SINGER_ID = 2 WHERE SINGER_ID = 4",
      "UPDATE SONG SET SINGER_ID = 1 WHERE TITLE = 'Yeah'"
    ],
    "summary": "Create a trigger named trg_song_citizenship_check that fires before each row update on the SONG table when the SINGER_ID column is modified. For each row, get the citizenship and net worth for both the old and new singer IDs. If the citizenship changed and the new net worth is greater, append '_UPGRADE' to the new title. Else if the citizenship is the same and the new net worth is lower, append '_DOWN' to the title. Else if the new citizenship is France and the old was not, multiply the new sales by 0.9 and round it. Otherwise, set the new highest position to NULL and increase the new sales by 1000.",
    "natural_language": "Before an update to a row in the SONG table, if the SINGER_ID is changed, what actions should the trigger 'trg_song_citizenship_check' take regarding the song's title, sales, and highest position based on the old and new singer's citizenship and net worth?",
    "id": 45
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_problem_log_insert that fires automatically before each row insertion into the PROBLEM_LOG table, and within its execution block, it first declares three local VARCHAR2 variables: v_status_desc with a maximum length of 255 characters, v_category_desc with a maximum length of 255 characters, and v_staff_name with a maximum length of 255 characters; then it performs a SELECT operation on the PROBLEM_STATUS_CODES table to retrieve the PROBLEM_STATUS_DESCRIPTION column value where the PROBLEM_STATUS_CODE column matches the new incoming PROBLEM_STATUS_CODE value from the :NEW pseudorecord for the insert, and stores this result into the v_status_desc variable; next, it performs another SELECT operation on the PROBLEM_CATEGORY_CODES table to retrieve the PROBLEM_CATEGORY_DESCRIPTION column value where the PROBLEM_CATEGORY_CODE column matches the new incoming PROBLEM_CATEGORY_CODE value from the :NEW pseudorecord, storing this result into the v_category_desc variable; following these lookups, the trigger evaluates a conditional IF statement: if the retrieved v_status_desc value is exactly the string 'Solved', then it executes a SELECT statement on the STAFF table to concatenate the STAFF_FIRST_NAME column, a single space, and the STAFF_LAST_NAME column using the concatenation operator (||), where the STAFF_ID column equals the new incoming ASSIGNED_TO_STAFF_ID value from the :NEW pseudorecord, and stores this concatenated full name into the v_staff_name variable, after which it assigns a value to the new incoming LOG_ENTRY_DESCRIPTION field in the :NEW pseudorecord by concatenating the string 'Solved by ' with the v_staff_name variable; if the first condition is not met, the trigger checks an ELSIF condition: if the v_status_desc value is exactly the string 'Reported', then it assigns a value to the new incoming LOG_ENTRY_DESCRIPTION field by concatenating the string 'Reported - ' with the v_category_desc variable; if neither the IF nor the ELSIF condition is true, the trigger executes an ELSE block that assigns a value to the new incoming LOG_ENTRY_DESCRIPTION field by concatenating the string 'Status: ', the v_status_desc variable, the string ' - Category: ', and the v_category_desc variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_log_insert\nBEFORE INSERT ON PROBLEM_LOG\nFOR EACH ROW\nDECLARE\n    v_status_desc VARCHAR2(255);\n    v_category_desc VARCHAR2(255);\n    v_staff_name VARCHAR2(255);\nBEGIN\n    SELECT PROBLEM_STATUS_DESCRIPTION INTO v_status_desc\n    FROM PROBLEM_STATUS_CODES\n    WHERE PROBLEM_STATUS_CODE = :NEW.PROBLEM_STATUS_CODE;\n\n    SELECT PROBLEM_CATEGORY_DESCRIPTION INTO v_category_desc\n    FROM PROBLEM_CATEGORY_CODES\n    WHERE PROBLEM_CATEGORY_CODE = :NEW.PROBLEM_CATEGORY_CODE;\n\n    IF v_status_desc = 'Solved' THEN\n        SELECT STAFF_FIRST_NAME || ' ' || STAFF_LAST_NAME INTO v_staff_name\n        FROM STAFF\n        WHERE STAFF_ID = :NEW.ASSIGNED_TO_STAFF_ID;\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Solved by ' || v_staff_name;\n    ELSIF v_status_desc = 'Reported' THEN\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Reported - ' || v_category_desc;\n    ELSE\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Status: ' || v_status_desc || ' - Category: ' || v_category_desc;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_CATEGORY_CODE, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE) VALUES (100, 11, 11, 'Middleware', 'Solved', '2024-01-15 10:30:00')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_CATEGORY_CODE, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE) VALUES (101, 12, 8, 'GUI', 'Reported', '2024-01-15 11:00:00')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_CATEGORY_CODE, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE) VALUES (102, NULL, 1, 'Datatabase', 'In Progress', '2024-01-15 11:30:00')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_CATEGORY_CODE, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE) VALUES (103, 1, 2, 'Middleware', 'Solved', '2024-01-15 12:00:00')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_CATEGORY_CODE, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE) VALUES (104, NULL, 3, 'GUI', 'Reported', '2024-01-15 12:30:00')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_problem_log_insert on the PROBLEM_LOG table. For each new row, retrieve the status description from PROBLEM_STATUS_CODES and category description from PROBLEM_CATEGORY_CODES. If the status is 'Solved', retrieve the assigned staff's full name from the STAFF table and set LOG_ENTRY_DESCRIPTION to 'Solved by [staff name]'. If the status is 'Reported', set LOG_ENTRY_DESCRIPTION to 'Reported - [category description]'. Otherwise, set it to 'Status: [status description] - Category: [category description]'.",
    "natural_language": "Create trigger trg_problem_log_insert on PROBLEM_LOG. Before insert, set LOG_ENTRY_DESCRIPTION based on status and category codes. If status is 'Solved', use staff name. If 'Reported', use category. Otherwise, use both.",
    "id": 46
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_problem_category_update that fires before any update operation on the PROBLEM_LOG table, specifically when the PROBLEM_CATEGORY_CODE column is being modified, and executes once for each row being updated. The trigger declares two local VARCHAR2 variables, v_old_category_desc and v_new_category_desc, each with a maximum length of 255 characters. For the row being updated, the trigger first queries the PROBLEM_CATEGORY_CODES table to retrieve the PROBLEM_CATEGORY_DESCRIPTION associated with the original PROBLEM_CATEGORY_CODE value, which is accessed via the :OLD.PROBLEM_CATEGORY_CODE pseudorecord, and stores this description in the v_old_category_desc variable. It then queries the same PROBLEM_CATEGORY_CODES table again to retrieve the PROBLEM_CATEGORY_DESCRIPTION associated with the new PROBLEM_CATEGORY_CODE value, which is accessed via the :NEW.PROBLEM_CATEGORY_CODE pseudorecord, and stores this description in the v_new_category_desc variable. The trigger then compares the two retrieved description strings using an IF statement: if v_old_category_desc is not equal to v_new_category_desc, it constructs a string by concatenating the literal 'Category changed from ', the value of v_old_category_desc, the literal ' to ', and the value of v_new_category_desc, and assigns this resulting string to the :NEW.LOG_ENTRY_DESCRIPTION column of the row being updated in the PROBLEM_LOG table; otherwise, if the descriptions are equal, it constructs a string by concatenating the literal 'Category remains ' and the value of v_new_category_desc, and assigns this resulting string to the :NEW.LOG_ENTRY_DESCRIPTION column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_category_update\nBEFORE UPDATE OF PROBLEM_CATEGORY_CODE ON PROBLEM_LOG\nFOR EACH ROW\nDECLARE\n    v_old_category_desc VARCHAR2(255);\n    v_new_category_desc VARCHAR2(255);\nBEGIN\n    SELECT PROBLEM_CATEGORY_DESCRIPTION INTO v_old_category_desc\n    FROM PROBLEM_CATEGORY_CODES\n    WHERE PROBLEM_CATEGORY_CODE = :OLD.PROBLEM_CATEGORY_CODE;\n\n    SELECT PROBLEM_CATEGORY_DESCRIPTION INTO v_new_category_desc\n    FROM PROBLEM_CATEGORY_CODES\n    WHERE PROBLEM_CATEGORY_CODE = :NEW.PROBLEM_CATEGORY_CODE;\n\n    IF v_old_category_desc != v_new_category_desc THEN\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Category changed from ' || v_old_category_desc || ' to ' || v_new_category_desc;\n    ELSE\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Category remains ' || v_new_category_desc;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'GUI' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'Middleware' WHERE PROBLEM_LOG_ID = 2 AND PROBLEM_CATEGORY_CODE = 'GUI'",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'Datatabase' WHERE PROBLEM_LOG_ID = 3",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'GUI' WHERE PROBLEM_ID = 11",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'Datatabase' WHERE PROBLEM_CATEGORY_CODE = 'Middleware'"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_problem_category_update on the PROBLEM_LOG table that fires when PROBLEM_CATEGORY_CODE changes. For each updated row, retrieve the old and new category descriptions from PROBLEM_CATEGORY_CODES. If descriptions differ, set LOG_ENTRY_DESCRIPTION to 'Category changed from [old description] to [new description]'. Otherwise, set it to 'Category remains [new description]'.",
    "natural_language": "Construct a BEFORE UPDATE row-level trigger, which you should name trg_problem_category_update, specifically for the PROBLEM_LOG table; this trigger must activate precisely when the value within the PROBLEM_CATEGORY_CODE column is modified. For every individual row that undergoes an update, you must carefully fetch both the previous and the updated category descriptions directly from the PROBLEM_CATEGORY_CODES reference table. In the event that these two retrieved descriptions are not identical, you are to populate the LOG_ENTRY_DESCRIPTION field with a detailed message stating 'Category changed from [old description] to [new description]'. Conversely, if the descriptions are exactly the same, you should instead set that field to a message reading 'Category remains [new description]'.",
    "id": 47
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_problem_status_update that fires before any update operation on the PROBLEM_LOG table, specifically when the PROBLEM_STATUS_CODE column is being updated, and executes once for each row being updated, declaring two local variables v_old_status_desc and v_new_status_desc, each of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT operation on the PROBLEM_STATUS_CODES table to retrieve the PROBLEM_STATUS_DESCRIPTION column value corresponding to the old PROBLEM_STATUS_CODE value from the :OLD pseudorecord and stores it into v_old_status_desc, followed by another SELECT operation on the PROBLEM_STATUS_CODES table to retrieve the PROBLEM_STATUS_DESCRIPTION column value corresponding to the new PROBLEM_STATUS_CODE value from the :NEW pseudorecord and stores it into v_new_status_desc, then evaluates a conditional IF statement comparing v_old_status_desc and v_new_status_desc for inequality, and if they are not equal, constructs a string by concatenating the literal 'Status changed from ', the value of v_old_status_desc, the literal ' to ', and the value of v_new_status_desc, and assigns this resulting string to the LOG_ENTRY_DESCRIPTION column of the :NEW pseudorecord for the PROBLEM_LOG table row, but if the values are equal, constructs a string by concatenating the literal 'Status remains ' and the value of v_new_status_desc and assigns this resulting string to the LOG_ENTRY_DESCRIPTION column of the :NEW pseudorecord.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_status_update\nBEFORE UPDATE OF PROBLEM_STATUS_CODE ON PROBLEM_LOG\nFOR EACH ROW\nDECLARE\n    v_old_status_desc VARCHAR2(255);\n    v_new_status_desc VARCHAR2(255);\nBEGIN\n    SELECT PROBLEM_STATUS_DESCRIPTION INTO v_old_status_desc\n    FROM PROBLEM_STATUS_CODES\n    WHERE PROBLEM_STATUS_CODE = :OLD.PROBLEM_STATUS_CODE;\n\n    SELECT PROBLEM_STATUS_DESCRIPTION INTO v_new_status_desc\n    FROM PROBLEM_STATUS_CODES\n    WHERE PROBLEM_STATUS_CODE = :NEW.PROBLEM_STATUS_CODE;\n\n    IF v_old_status_desc != v_new_status_desc THEN\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Status changed from ' || v_old_status_desc || ' to ' || v_new_status_desc;\n    ELSE\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Status remains ' || v_new_status_desc;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Reported' WHERE PROBLEM_LOG_ID = 2",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_ID = 11",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Reported', LOG_ENTRY_DATE = SYSDATE WHERE PROBLEM_LOG_ID = 3",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved', PROBLEM_CATEGORY_CODE = 'GUI' WHERE PROBLEM_LOG_ID = 4"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_problem_status_update on the PROBLEM_LOG table that fires when PROBLEM_STATUS_CODE changes. For each updated row, retrieve the old and new status descriptions from PROBLEM_STATUS_CODES. If descriptions differ, set LOG_ENTRY_DESCRIPTION to 'Status changed from [old description] to [new description]'. Otherwise, set it to 'Status remains [new description]'.",
    "natural_language": "Please construct a BEFORE UPDATE row-level trigger designated as trg_problem_status_update on the PROBLEM_LOG table. This trigger should be activated specifically when the PROBLEM_STATUS_CODE column is modified. For each affected row, it is necessary to obtain the descriptions corresponding to the previous and updated status values from the PROBLEM_STATUS_CODES reference table. Subsequently, if the two descriptions are not identical, the LOG_ENTRY_DESCRIPTION field must be populated with the text 'Status changed from [old description] to [new description]'. Conversely, if the descriptions are the same, the field should be set to 'Status remains [new description]'.",
    "id": 48
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_problem_report_insert` that automatically executes before a new row is inserted into the `PROBLEMS` table. This trigger declares two local `VARCHAR2` variables: `v_reporter_name` and `v_product_name`, both capable of storing up to 255 characters. The trigger first retrieves the full name of the staff member who reported the problem by concatenating the `STAFF_FIRST_NAME` and `STAFF_LAST_NAME` columns from the `STAFF` table, where the `STAFF_ID` in the `STAFF` table matches the `REPORTED_BY_STAFF_ID` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.REPORTED_BY_STAFF_ID`), and stores this concatenated name into the `v_reporter_name` variable. Next, it retrieves the `PRODUCT_NAME` from the `PRODUCT` table, where the `PRODUCT_ID` in the `PRODUCT` table matches the `PRODUCT_ID` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.PRODUCT_ID`), and stores this product name into the `v_product_name` variable. Following these retrievals, the trigger evaluates a conditional statement: if the `DATE_PROBLEM_REPORTED` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.DATE_PROBLEM_REPORTED`) is not null, then it proceeds to insert a new record into the `PROBLEM_LOG` table. For this insertion, the `PROBLEM_LOG_ID` column is populated by selecting the maximum existing `PROBLEM_LOG_ID` from the `PROBLEM_LOG` table, using `COALESCE` to default to 0 if no records exist, and then adding 1 to that value. The `PROBLEM_ID` column is populated with the `PROBLEM_ID` from the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.PROBLEM_ID`). The `PROBLEM_STATUS_CODE` column is set to the literal string 'Reported'. The `LOG_ENTRY_DATE` column is populated with the `DATE_PROBLEM_REPORTED` from the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.DATE_PROBLEM_REPORTED`). Finally, the `LOG_ENTRY_DESCRIPTION` column is populated with a concatenated string formed by the literal 'Problem reported by ', followed by the value of the `v_reporter_name` variable, followed by the literal ' for product ', and then followed by the value of the `v_product_name` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_report_insert\nBEFORE INSERT ON PROBLEMS\nFOR EACH ROW\nDECLARE\n    v_reporter_name VARCHAR2(255);\n    v_product_name VARCHAR2(255);\nBEGIN\n    SELECT STAFF_FIRST_NAME || ' ' || STAFF_LAST_NAME INTO v_reporter_name\n    FROM STAFF\n    WHERE STAFF_ID = :NEW.REPORTED_BY_STAFF_ID;\n\n    SELECT PRODUCT_NAME INTO v_product_name\n    FROM PRODUCT\n    WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n\n    IF :NEW.DATE_PROBLEM_REPORTED IS NOT NULL THEN\n        INSERT INTO PROBLEM_LOG (\n            PROBLEM_LOG_ID,\n            PROBLEM_ID,\n            PROBLEM_STATUS_CODE,\n            LOG_ENTRY_DATE,\n            LOG_ENTRY_DESCRIPTION\n        ) VALUES (\n            (SELECT COALESCE(MAX(PROBLEM_LOG_ID), 0) + 1 FROM PROBLEM_LOG),\n            :NEW.PROBLEM_ID,\n            'Reported',\n            :NEW.DATE_PROBLEM_REPORTED,\n            'Problem reported by ' || v_reporter_name || ' for product ' || v_product_name\n        );\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (1, 1, 1, '2023-01-15 10:00:00', 'Login issue')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (2, 2, 2, '2023-01-16 11:30:00', 'Payment gateway error')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (3, 3, 3, '2023-01-17 14:00:00', 'Broken link on homepage')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (4, 1, 2, '2023-01-18 09:15:00', 'Slow loading times')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (5, 3, 1, '2023-01-19 16:45:00', 'Incorrect data display')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_problem_report_insert on the PROBLEMS table. For each new row, retrieve the reporter's full name from STAFF and product name from PRODUCT. If DATE_PROBLEM_REPORTED is not null, insert a record into PROBLEM_LOG with a generated PROBLEM_LOG_ID, the new PROBLEM_ID, status 'Reported', the report date, and description 'Problem reported by [reporter name] for product [product name]'.",
    "natural_language": "Define a BEFORE INSERT row-level trigger called trg_problem_report_insert for the PROBLEMS table. For every inserted row, fetch the reporter's full name from the STAFF table and the product name from the PRODUCT table. If DATE_PROBLEM_REPORTED is provided, then insert a new entry into the PROBLEM_LOG table. This entry should include an auto-generated PROBLEM_LOG_ID, the new PROBLEM_ID, the status 'Reported', the report date, and a description formatted as 'Problem reported by [reporter name] for product [product name]'.",
    "id": 49
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_member_cascade` that is activated `AFTER` a `DELETE` operation is performed on the `MEMBER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is deleted from the `MEMBER` table. Upon activation, for each row that has been deleted from the `MEMBER` table, the trigger performs a `DELETE` operation on the `CLUB_LEADER` table. The `DELETE` operation on the `CLUB_LEADER` table is conditional: it removes all rows from `CLUB_LEADER` where the value in the `MEMBER_ID` column of the `CLUB_LEADER` table is equal to the value of the `MEMBER_ID` column from the row that was just deleted from the `MEMBER` table. The `:OLD.MEMBER_ID` pseudo-record variable refers to the value of the `MEMBER_ID` column in the row of the `MEMBER` table *before* it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_member_cascade\nAFTER DELETE ON MEMBER\nFOR EACH ROW\nBEGIN\n  DELETE FROM CLUB_LEADER WHERE MEMBER_ID = :OLD.MEMBER_ID;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1984",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1985",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1986",
      "DELETE FROM MEMBER WHERE NAME = 'Wally Lewis'",
      "DELETE FROM MEMBER WHERE AGE > 20"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_member_cascade on the MEMBER table. For each deleted row, delete all records from the CLUB_LEADER table where MEMBER_ID equals the deleted member's MEMBER_ID.",
    "natural_language": "How can I create an AFTER DELETE row-level trigger called trg_delete_member_cascade on the MEMBER table to delete all related records from the CLUB_LEADER table for each removed member?",
    "id": 50
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_after_update_club_leader` that is activated `AFTER` an `UPDATE` operation occurs on the `CLUB_LEADER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `CLUB_LEADER` table. Upon activation, the trigger performs a `MERGE` operation on the `CLUB` table, aliased as `c`. The `MERGE` statement uses a subquery as its `USING` clause, aliased as `src`. This subquery selects two columns: `CLUB_ID` from the newly updated row in `CLUB_LEADER` (referenced as `:NEW.CLUB_ID`) and `NAME` from the `MEMBER` table, aliased as `m`. The `NAME` column from `MEMBER` is aliased as `TEAM_LEADER_NAME` within the subquery. The selection from `MEMBER` is filtered by a `WHERE` clause, `m.MEMBER_ID = :NEW.MEMBER_ID`, which matches the `MEMBER_ID` from the newly updated row in `CLUB_LEADER` to the `MEMBER_ID` in the `MEMBER` table. The `MERGE` operation's `ON` clause specifies the join condition between the target `CLUB` table (`c`) and the source subquery (`src`) as `c.CLUB_ID = src.CLUB_ID`.\n\nIf a row in the `CLUB` table `MATCHED` the `src` subquery based on the `CLUB_ID` condition, the trigger executes an `UPDATE` operation on the `CLUB` table. This `UPDATE` sets the `TEAM_LEADER` column of the matched `CLUB` row (`c.TEAM_LEADER`) to the value of `TEAM_LEADER_NAME` obtained from the `src` subquery (`src.TEAM_LEADER_NAME`).\n\nIf a row in the `CLUB` table did `NOT MATCH` any row from the `src` subquery based on the `CLUB_ID` condition, the trigger executes an `INSERT` operation into the `CLUB` table. This `INSERT` populates three columns: `CLUB_ID`, `TEAM_LEADER`, and `CLUB_NAME`. The values inserted are `src.CLUB_ID` for `CLUB_ID`, `src.TEAM_LEADER_NAME` for `TEAM_LEADER`, and the literal string `'AutoCreated'` for `CLUB_NAME`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_update_club_leader\nAFTER UPDATE ON CLUB_LEADER\nFOR EACH ROW\nBEGIN\n  MERGE INTO CLUB c\n  USING (SELECT :NEW.CLUB_ID AS CLUB_ID, m.NAME AS TEAM_LEADER_NAME\n         FROM MEMBER m\n         WHERE m.MEMBER_ID = :NEW.MEMBER_ID) src\n  ON (c.CLUB_ID = src.CLUB_ID)\n  WHEN MATCHED THEN\n    UPDATE SET c.TEAM_LEADER = src.TEAM_LEADER_NAME\n  WHEN NOT MATCHED THEN\n    INSERT (c.CLUB_ID, c.TEAM_LEADER, c.CLUB_NAME)\n    VALUES (src.CLUB_ID, src.TEAM_LEADER_NAME, 'AutoCreated');\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE CLUB_LEADER SET MEMBER_ID = 1984 WHERE CLUB_ID = 1 AND MEMBER_ID = 1988",
      "UPDATE CLUB_LEADER SET MEMBER_ID = 1985 WHERE CLUB_ID = 8 AND MEMBER_ID = 1984",
      "UPDATE CLUB_LEADER SET MEMBER_ID = 1986 WHERE CLUB_ID = 6 AND MEMBER_ID = 1985",
      "UPDATE CLUB_LEADER SET YEAR_JOIN = '2019' WHERE CLUB_ID = 1 AND MEMBER_ID = 1988",
      "UPDATE CLUB_LEADER SET MEMBER_ID = 1984, YEAR_JOIN = '2020' WHERE CLUB_ID = 1 AND MEMBER_ID = 1988"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_after_update_club_leader on CLUB_LEADER table. When a row is updated, merge data into CLUB table using :NEW.CLUB_ID and the corresponding MEMBER.NAME as TEAM_LEADER_NAME. If CLUB_ID matches, update CLUB.TEAM_LEADER. If no match, insert new CLUB row with CLUB_ID, TEAM_LEADER, and 'AutoCreated' as CLUB_NAME.",
    "natural_language": "Create a trigger named trg_after_update_club_leader on the CLUB_LEADER table that fires after each row update. For each updated row, merge the data into the CLUB table. Use the :NEW.CLUB_ID and the corresponding MEMBER.NAME as TEAM_LEADER_NAME. If the CLUB_ID matches an existing record, update the CLUB.TEAM_LEADER. If there is no match, insert a new row into CLUB with the CLUB_ID, TEAM_LEADER, and set CLUB_NAME to 'AutoCreated'.",
    "id": 51
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_compound_insert that is executed before an insert operation on the CLUB_LEADER table for each row being inserted. The trigger declares two local variables: v_leader_name of type VARCHAR2(255) and v_club_ranking of type NUMBER. The trigger performs a SELECT operation to retrieve the NAME column from the MEMBER table where the MEMBER_ID matches the MEMBER_ID of the new row being inserted into the CLUB_LEADER table, storing the result in the v_leader_name variable. If no matching MEMBER_ID is found, the NO_DATA_FOUND exception is caught, and v_leader_name is set to NULL. Subsequently, the trigger performs another SELECT operation to retrieve the OVERALL_RANKING column from the CLUB table where the CLUB_ID matches the CLUB_ID of the new row being inserted into the CLUB_LEADER table, storing the result in the v_club_ranking variable. The YEAR_JOIN column of the new row is then set to the string representation of v_club_ranking using the TO_CHAR function. If no matching CLUB_ID is found, the NO_DATA_FOUND exception is caught, and the YEAR_JOIN column is set to NULL.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_compound_insert\nBEFORE INSERT ON CLUB_LEADER\nFOR EACH ROW\nDECLARE\n  v_leader_name VARCHAR2(255);\n  v_club_ranking NUMBER;\nBEGIN\n  BEGIN\n    SELECT NAME INTO v_leader_name FROM MEMBER WHERE MEMBER_ID = :NEW.MEMBER_ID;\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n      v_leader_name := NULL;\n  END;\n  \n  BEGIN\n    SELECT OVERALL_RANKING INTO v_club_ranking FROM CLUB WHERE CLUB_ID = :NEW.CLUB_ID;\n    :NEW.YEAR_JOIN := TO_CHAR(v_club_ranking);\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n      :NEW.YEAR_JOIN := NULL;\n  END;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID) VALUES (1, 1984)",
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID) VALUES (3, 1985)",
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID) VALUES (4, 1986)",
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID) VALUES (1, 1985)",
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID) VALUES (3, 1984)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_compound_insert on CLUB_LEADER table. For each new row, get MEMBER.NAME using :NEW.MEMBER_ID and store in v_leader_name. Get CLUB.OVERALL_RANKING using :NEW.CLUB_ID and store in v_club_ranking. Set :NEW.YEAR_JOIN to TO_CHAR(v_club_ranking). Handle NO_DATA_FOUND exceptions by setting variables to NULL.",
    "natural_language": "Create trigger trg_compound_insert on CLUB_LEADER before insert. For each row, fetch MEMBER.NAME via :NEW.MEMBER_ID into v_leader_name and CLUB.OVERALL_RANKING via :NEW.CLUB_ID into v_club_ranking. Set :NEW.YEAR_JOIN to TO_CHAR(v_club_ranking). On NO_DATA_FOUND, set variables to NULL.",
    "id": 52
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_member_country that executes automatically before any row insertion operation on the ROUND table, and for each new row being inserted, it declares a local variable v_country of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the MEMBER table to retrieve the value of the COUNTRY column for the specific row where the MEMBER_ID column matches the value of the :NEW.MEMBER_ID bind variable from the new ROUND row, storing the result into the v_country variable, and subsequently checks a conditional IF statement to see if the retrieved v_country value is exactly equal to the string literal 'Canada', and if this condition is true, it modifies the :NEW.DECORATION_THEME bind variable for the new ROUND row by prepending the string 'Canadian ' followed by a space to its existing value, effectively updating the DECORATION_THEME column for the row about to be inserted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_member_country\nBEFORE INSERT ON ROUND\nFOR EACH ROW\nDECLARE\n    v_country VARCHAR2(255);\nBEGIN\n    SELECT COUNTRY INTO v_country FROM MEMBER WHERE MEMBER_ID = :NEW.MEMBER_ID;\n    IF v_country = 'Canada' THEN\n        :NEW.DECORATION_THEME := 'Canadian ' || :NEW.DECORATION_THEME;\n    END IF;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (2, 1, 'Walk on the Moon', 1)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (3, 2, 'Soft Dream', 2)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (4, 3, 'Dark Nights', 4)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (5, 1, 'Starry Night', 3)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (6, 2, 'Sunny Day', 5)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_validate_member_country on ROUND table. For each new row, get MEMBER.COUNTRY using :NEW.MEMBER_ID. If the country is 'Canada', prepend 'Canadian ' to :NEW.DECORATION_THEME.",
    "natural_language": "Make a BEFORE INSERT FOR EACH ROW trigger called trg_validate_member_country on ROUND. For new rows, if the member's country from MEMBER is 'Canada', add 'Canadian ' to :NEW.DECORATION_THEME.",
    "id": 53
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_audit_round_insert that is defined to execute automatically after a new row is inserted into the ROUND table, which declares a local variable v_total_rounds of type NUMBER, then performs a SELECT COUNT(*) operation on the ROUND table to retrieve the total number of rows currently in that table and stores the result into the variable v_total_rounds, and subsequently performs an INSERT operation into the MEMBER table, specifying values for the columns MEMBER_ID, NAME, COUNTRY, and COLLEGE_ID, where the MEMBER_ID value is calculated by adding 1000 to the value stored in v_total_rounds, the NAME column is set to the literal string 'Audit User', the COUNTRY column is set to the literal string 'Audit', and the COLLEGE_ID column is explicitly set to NULL.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_audit_round_insert\nAFTER INSERT ON ROUND\nDECLARE\n    v_total_rounds NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_rounds FROM ROUND;\n    INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) \n    VALUES (v_total_rounds + 1000, 'Audit User', 'Audit', NULL);\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (2, 1, 'Ocean Breeze', 3)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (3, 2, 'Forest Green', 1)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (4, 3, 'Sunset Glow', 2)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (5, 1, 'Winter Frost', 5)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (6, 2, 'Desert Sand', 4)"
    ],
    "summary": "Create an AFTER INSERT trigger named trg_audit_round_insert on ROUND table. After each insert, count total rows in ROUND table and insert a new row into MEMBER table with MEMBER_ID as (1000 + total count), NAME as 'Audit User', COUNTRY as 'Audit', and COLLEGE_ID as NULL.",
    "natural_language": "Alright, so we need to set up a trigger called trg_audit_round_insert for the ROUND table that fires off after any new row is added. When it runs, it should figure out how many rows are in ROUND, then pop a new record into the MEMBER table. For that new member, make the MEMBER_ID 1000 plus that total count, set the NAME to 'Audit User', the COUNTRY to 'Audit', and just leave COLLEGE_ID blank (null).",
    "id": 54
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_prevent_duplicate_rank` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `ROUND` table, and it executes `FOR EACH ROW` being inserted. This trigger declares a local numeric variable named `v_exists` to store a count. The trigger's execution block begins by performing a `SELECT` operation to `COUNT` the number of rows in the `ROUND` table where the value in the `RANK_IN_ROUND` column is equal to the value of the `RANK_IN_ROUND` column of the new row being inserted, which is referenced by `:NEW.RANK_IN_ROUND`. The result of this `COUNT` operation is then stored into the `v_exists` variable. Following this, a conditional `IF` statement checks if the value stored in `v_exists` is `GREATER THAN 0`. If this condition evaluates to `TRUE`, indicating that a row with the same `RANK_IN_ROUND` already exists in the `ROUND` table, then the `RANK_IN_ROUND` column of the new row being inserted, referenced by `:NEW.RANK_IN_ROUND`, is modified by adding `100` to its current value. The trigger then concludes its execution.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_prevent_duplicate_rank\nBEFORE INSERT ON ROUND\nFOR EACH ROW\nDECLARE\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM ROUND WHERE RANK_IN_ROUND = :NEW.RANK_IN_ROUND;\n    IF v_exists > 0 THEN\n        :NEW.RANK_IN_ROUND := :NEW.RANK_IN_ROUND + 100;\n    END IF;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (1, 1, 'Walk on the Moon', 1)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (2, 2, 'Soft Dream', 1)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (3, 10, 'Dark Nights', 2)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (4, 1, 'New Theme', 2)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (5, 2, 'Another Theme', 3)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_prevent_duplicate_rank on ROUND table. For each new row, check if RANK_IN_ROUND already exists in ROUND table. If duplicate exists, add 100 to :NEW.RANK_IN_ROUND.",
    "natural_language": "Alright, so we need a trigger that fires before a new row gets added to the ROUND table. Call it 'trg_prevent_duplicate_rank'. For every new entry, it's gotta check if that RANK_IN_ROUND number is already taken in the table. If it finds a copy, just bump up the new row's rank by 100.",
    "id": 55
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE UPDATE` row-level trigger named `trg_update_round_theme` that is automatically executed on the `MEMBER` table. This trigger is activated for each individual row that is being updated in the `MEMBER` table. Upon activation, the trigger evaluates a conditional statement: it checks if the value of the `COUNTRY` column in the new version of the row (`:NEW.COUNTRY`) is not equal to the value of the `COUNTRY` column in the old version of the row (`:OLD.COUNTRY`). If this condition is true, meaning the `COUNTRY` column has been changed during the update operation, the trigger then performs an `UPDATE` operation on the `ROUND` table. Specifically, it sets the value of the `DECORATION_THEME` column in the `ROUND` table to a concatenated string. This string is formed by taking the value of the `COUNTRY` column from the new version of the `MEMBER` row (`:NEW.COUNTRY`) and appending the literal string ' Theme' to it. This `UPDATE` operation on the `ROUND` table is applied only to those rows where the `MEMBER_ID` column in the `ROUND` table matches the value of the `MEMBER_ID` column from the new version of the `MEMBER` row (`:NEW.MEMBER_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_round_theme\nBEFORE UPDATE ON MEMBER\nFOR EACH ROW\nBEGIN\n    IF :NEW.COUNTRY != :OLD.COUNTRY THEN\n        UPDATE ROUND SET DECORATION_THEME = :NEW.COUNTRY || ' Theme' \n        WHERE MEMBER_ID = :NEW.MEMBER_ID;\n    END IF;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "UPDATE MEMBER SET COUNTRY = 'Canada' WHERE MEMBER_ID = 1",
      "UPDATE MEMBER SET COUNTRY = 'United States' WHERE MEMBER_ID = 2",
      "UPDATE MEMBER SET COUNTRY = 'Mexico', NAME = 'Tiger Woods' WHERE MEMBER_ID = 3",
      "UPDATE MEMBER SET COUNTRY = 'Australia' WHERE MEMBER_ID = 10",
      "UPDATE MEMBER SET COUNTRY = 'Japan', COLLEGE_ID = 2 WHERE MEMBER_ID = 5"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_update_round_theme on the MEMBER table. When a row's COUNTRY value changes, update the ROUND table's DECORATION_THEME to :NEW.COUNTRY concatenated with ' Theme' for rows where ROUND.MEMBER_ID equals :NEW.MEMBER_ID.",
    "natural_language": "Please construct a BEFORE UPDATE row-level trigger designated as trg_update_round_theme for the MEMBER table. The trigger's function is to, upon modification of a row's COUNTRY value, execute an update on the DECORATION_THEME column within the ROUND table. The update should set the theme to the concatenation of the new COUNTRY value, accessed via :NEW.COUNTRY, and the string ' Theme'. This operation is to be applied specifically to those rows in the ROUND table where the ROUND.MEMBER_ID matches the :NEW.MEMBER_ID from the updated MEMBER record.",
    "id": 56
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_maintain_college_consistency` that is activated `BEFORE` any `DELETE` operation is performed on the `COLLEGE` table. This trigger is configured to execute `FOR EACH ROW` that is being deleted from the `COLLEGE` table. Upon activation, the trigger executes a `BEGIN` block containing two sequential `DELETE` statements. The `FIRST` operation is a `DELETE` statement targeting records in the `ROUND` table. This `DELETE` statement removes rows from the `ROUND` table where the `MEMBER_ID` column's value is present `IN` the result set of a subquery. The subquery `SELECT`s the `MEMBER_ID` column from the `MEMBER` table, filtering these `MEMBER` records where the `COLLEGE_ID` column matches the `COLLEGE_ID` of the `OLD` record (the record currently being deleted) from the `COLLEGE` table. This effectively deletes all `ROUND` records associated with members belonging to the college being deleted. The `THEN` `SECOND` operation is another `DELETE` statement, this time targeting records in the `MEMBER` table. This `DELETE` statement removes rows from the `MEMBER` table where the `COLLEGE_ID` column matches the `COLLEGE_ID` of the `OLD` record (the record currently being deleted) from the `COLLEGE` table. This effectively deletes all `MEMBER` records associated with the college being deleted. The trigger concludes its execution after these two `DELETE` operations.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_college_consistency\nBEFORE DELETE ON COLLEGE\nFOR EACH ROW\nBEGIN\n    -- First, delete dependent records from ROUND table\n    DELETE FROM ROUND\n    WHERE MEMBER_ID IN (SELECT MEMBER_ID FROM MEMBER WHERE COLLEGE_ID = :OLD.COLLEGE_ID);\n\n    -- Then, delete dependent records from MEMBER table\n    DELETE FROM MEMBER WHERE COLLEGE_ID = :OLD.COLLEGE_ID;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 1",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 2",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 3",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 4",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_maintain_college_consistency on the COLLEGE table. When a college is deleted, first delete all ROUND records for members belonging to that college, then delete all MEMBER records for that college.",
    "natural_language": "Set up a trigger on the COLLEGE table that runs before deletions. When a college gets removed, it should first clear out the round records for people from that college, and then also get rid of the member entries for that college. Make sure the trigger handles this cleanup properly.",
    "id": 57
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_cross_ref_complex that is executed after an INSERT or UPDATE operation on the CMI_CROSS_REFERENCES table for each row affected. The trigger declares three local variables: v_detail_exists, v_tax_exists, and v_months_elapsed, all of type NUMBER. It first performs a SELECT COUNT(*) query to check if there are any entries in the CUSTOMER_MASTER_INDEX table where the MASTER_CUSTOMER_ID matches the MASTER_CUSTOMER_ID of the newly inserted or updated row, storing the result in v_detail_exists. Next, it performs another SELECT COUNT(*) query to determine if there are any entries in the COUNCIL_TAX table where the CMI_CROSS_REF_ID matches the CMI_CROSS_REF_ID of the new or updated row, storing the result in v_tax_exists. The trigger then calculates the number of months elapsed since January 1, 2022, using the MONTHS_BETWEEN function with SYSDATE and stores this value in v_months_elapsed. The trigger contains a conditional logic block: if v_detail_exists equals 0 and v_months_elapsed is less than 30, it inserts a new row into the CUSTOMER_MASTER_INDEX table with the MASTER_CUSTOMER_ID from the new row and a CMI_DETAILS value generated by concatenating the string 'Generated_' with the SOURCE_SYSTEM_CODE from the new row. If the first condition is not met but v_tax_exists is greater than 0, it deletes rows from the COUNCIL_TAX table where the CMI_CROSS_REF_ID matches the new row's CMI_CROSS_REF_ID. If neither of the previous conditions is met, it inserts a new row into the COUNCIL_TAX table with a COUNCIL_TAX_ID calculated as ten times the CMI_CROSS_REF_ID from the new row and the CMI_CROSS_REF_ID from the new row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_cross_ref_complex\nAFTER INSERT OR UPDATE ON CMI_CROSS_REFERENCES\nFOR EACH ROW\nDECLARE\n    v_detail_exists NUMBER;\n    v_tax_exists NUMBER;\n    v_months_elapsed NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_detail_exists FROM CUSTOMER_MASTER_INDEX WHERE MASTER_CUSTOMER_ID = :NEW.MASTER_CUSTOMER_ID;\n    \n    SELECT COUNT(*) INTO v_tax_exists FROM COUNCIL_TAX WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\n    \n    v_months_elapsed := MONTHS_BETWEEN(SYSDATE, TO_DATE('2022-01-01', 'YYYY-MM-DD'));\n    \n    IF v_detail_exists = 0 AND v_months_elapsed < 30 THEN\n        INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (:NEW.MASTER_CUSTOMER_ID, 'Generated_' || :NEW.SOURCE_SYSTEM_CODE);\n    ELSIF v_tax_exists > 0 THEN\n        DELETE FROM COUNCIL_TAX WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\n    ELSE\n        INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (:NEW.CMI_CROSS_REF_ID * 10, :NEW.CMI_CROSS_REF_ID);\n    END IF;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX"
    ],
    "call_sqls": [
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (1, 100, 'Rent')",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (2, 101, 'Parking')",
      "UPDATE CMI_CROSS_REFERENCES SET SOURCE_SYSTEM_CODE = 'UpdateTest' WHERE CMI_CROSS_REF_ID = 1",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (3, 1, 'Rent')",
      "UPDATE CMI_CROSS_REFERENCES SET MASTER_CUSTOMER_ID = 2 WHERE CMI_CROSS_REF_ID = 3"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE row-level trigger named trg_cross_ref_complex on the CMI_CROSS_REFERENCES table. Check if the MASTER_CUSTOMER_ID exists in CUSTOMER_MASTER_INDEX and if the CMI_CROSS_REF_ID exists in COUNCIL_TAX. Calculate months since Jan 1, 2022. If no detail exists and months < 30, insert into CUSTOMER_MASTER_INDEX. Else if tax exists, delete from COUNCIL_TAX. Otherwise, insert into COUNCIL_TAX with COUNCIL_TAX_ID as 10 times CMI_CROSS_REF_ID.",
    "natural_language": "How can I create an AFTER INSERT OR UPDATE row-level trigger named trg_cross_ref_complex on the CMI_CROSS_REFERENCES table that checks for the existence of MASTER_CUSTOMER_ID in CUSTOMER_MASTER_INDEX and CMI_CROSS_REF_ID in COUNCIL_TAX, calculates the months since January 1, 2022, and then, if no detail exists and the months are less than 30, inserts into CUSTOMER_MASTER_INDEX, or else if the tax exists, deletes from COUNCIL_TAX, or otherwise inserts into COUNCIL_TAX with COUNCIL_TAX_ID set to 10 times the CMI_CROSS_REF_ID?",
    "id": 58
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_tax_validation that fires before each row is inserted into the COUNCIL_TAX table, declaring local variables v_master_id of type NUMBER, v_source_code of type VARCHAR2 with a length of 255, and v_month_check of type NUMBER. The trigger begins by selecting the MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE columns from the CMI_CROSS_REFERENCES table into the variables v_master_id and v_source_code, using a condition where the CMI_CROSS_REF_ID column in CMI_CROSS_REFERENCES matches the new value of the CMI_CROSS_REF_ID column being inserted into COUNCIL_TAX, represented by the bind variable :NEW.CMI_CROSS_REF_ID. It then calculates the variable v_month_check by calling the MONTHS_BETWEEN function with two arguments: the first argument is a date constructed by converting the string '2024-12-31' to a DATE type using the TO_DATE function with the format model 'YYYY-MM-DD', and the second argument is the current system date returned by the SYSDATE function. Following this, the trigger executes a conditional IF statement: if the value of v_source_code is exactly equal to the string 'Rent' and the calculated v_month_check is greater than 6, it performs an INSERT operation into the CMI_CROSS_REFERENCES table, specifying values for the columns CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, and SOURCE_SYSTEM_CODE, where the CMI_CROSS_REF_ID value is the new :NEW.CMI_CROSS_REF_ID value plus 5000, the MASTER_CUSTOMER_ID is the selected v_master_id, and the SOURCE_SYSTEM_CODE is the string 'Tax_Linked'. If the first condition is not met, the trigger checks an ELSIF condition where v_source_code is exactly equal to the string 'Parking', and if true, it executes a DELETE operation on the CUSTOMER_MASTER_INDEX table, removing any row where the MASTER_CUSTOMER_ID column equals the selected v_master_id. If neither the IF nor the ELSIF condition is satisfied, the trigger executes an ELSE block containing an INSERT operation into the CUSTOMER_MASTER_INDEX table, providing values for the MASTER_CUSTOMER_ID and CMI_DETAILS columns, where MASTER_CUSTOMER_ID is the selected v_master_id value increased by 200 and CMI_DETAILS is the string 'Alternate_Record'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_tax_validation\nBEFORE INSERT ON COUNCIL_TAX\nFOR EACH ROW\nDECLARE\n    v_master_id NUMBER;\n    v_source_code VARCHAR2(255);\n    v_month_check NUMBER;\nBEGIN\n    SELECT MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE INTO v_master_id, v_source_code\n    FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\n    \n    v_month_check := MONTHS_BETWEEN(TO_DATE('2024-12-31', 'YYYY-MM-DD'), SYSDATE);\n    \n    IF v_source_code = 'Rent' AND v_month_check > 6 THEN\n        INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (:NEW.CMI_CROSS_REF_ID + 5000, v_master_id, 'Tax_Linked');\n    ELSIF v_source_code = 'Parking' THEN\n        DELETE FROM CUSTOMER_MASTER_INDEX WHERE MASTER_CUSTOMER_ID = v_master_id;\n    ELSE\n        INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (v_master_id + 200, 'Alternate_Record');\n    END IF;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX"
    ],
    "call_sqls": [
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (101, 1, 'Rent');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (1, 101)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (102, 2, 'Parking');\nINSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (2, 'Test Customer');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (2, 102)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (103, 3, 'Other');\nINSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (3, 'Another Customer');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (3, 103)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (104, 4, 'Rent');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (4, 104)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (105, 5, 'Parking');\nINSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (5, 'Yet Another Customer');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (5, 105)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_tax_validation on the COUNCIL_TAX table. Retrieve MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE from CMI_CROSS_REFERENCES using the new CMI_CROSS_REF_ID. Calculate months until Dec 31, 2024. If source is 'Rent' and months > 6, insert into CMI_CROSS_REFERENCES with ID+5000 and 'Tax_Linked'. Else if source is 'Parking', delete from CUSTOMER_MASTER_INDEX. Otherwise, insert into CUSTOMER_MASTER_INDEX with MASTER_CUSTOMER_ID+200 and 'Alternate_Record'.",
    "natural_language": "Create a BEFORE INSERT row-level trigger called trg_tax_validation for the COUNCIL_TAX table. For each new row, use the new CMI_CROSS_REF_ID to get the MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE from CMI_CROSS_REFERENCES. Then, calculate the number of months remaining until December 31, 2024. If the source system is 'Rent' and the months calculated are greater than 6, insert a new record into CMI_CROSS_REFERENCES using the original ID plus 5000 and with 'Tax_Linked' as the source. However, if the source is 'Parking', delete the corresponding record from CUSTOMER_MASTER_INDEX. For any other source, insert a new record into CUSTOMER_MASTER_INDEX using the MASTER_CUSTOMER_ID plus 200 and with 'Alternate_Record' as the source.",
    "id": 59
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named photos_before_insert_upper_color that is executed before a new row is inserted into the PHOTOS table. This trigger operates on each row individually. It first converts the COLOR column value of the new row to uppercase using the UPPER() function, ensuring that the color is stored consistently in uppercase format. Next, it checks if the ID column of the new row is NULL. If the ID is NULL, the trigger calculates the maximum existing ID value in the PHOTOS table using the SELECT statement with the MAX() function, adds 1 to this maximum value, and assigns the result to the ID column of the new row, thereby generating a unique ID. If the ID is not NULL, the trigger checks for the existence of this ID in the PHOTOS table by counting the number of rows with the same ID using the COUNT() function. If the count is greater than zero, indicating that the ID already exists, the trigger again calculates the maximum ID value, adds 1, and assigns this new value to the ID column of the new row to ensure uniqueness. The trigger uses local variables v_max_id and v_count to store intermediate results during these operations.",
    "plsql": "CREATE OR REPLACE TRIGGER photos_before_insert_upper_color\nBEFORE INSERT ON PHOTOS\nFOR EACH ROW\nDECLARE\n    v_max_id NUMBER;\nBEGIN\n    -- Convert color to uppercase\n    :NEW.COLOR := UPPER(:NEW.COLOR);\n    \n    -- Handle ID generation if NULL or ensure uniqueness\n    IF :NEW.ID IS NULL THEN\n        SELECT NVL(MAX(ID), 0) + 1 INTO v_max_id FROM PHOTOS;\n        :NEW.ID := v_max_id;\n    ELSE\n        -- Check if ID already exists and generate new one if needed\n        DECLARE\n            v_count NUMBER;\n        BEGIN\n            SELECT COUNT(*) INTO v_count FROM PHOTOS WHERE ID = :NEW.ID;\n            IF v_count > 0 THEN\n                SELECT NVL(MAX(ID), 0) + 1 INTO v_max_id FROM PHOTOS;\n                :NEW.ID := v_max_id;\n            END IF;\n        END;\n    END IF;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "PHOTOS"
    ],
    "call_sqls": [
      "INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME) VALUES (NULL, 5, 15, 'red', 'sunset')",
      "INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME) VALUES (5, 8, 22, 'blue', 'lake')",
      "INSERT INTO PHOTOS (CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME) VALUES (3, 10, 'green', 'forest')",
      "INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME) VALUES (2, 12, 5, 'yellow', 'field')",
      "INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME) VALUES (100, 1, 30, 'purple', 'dawn')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named photos_before_insert_upper_color on the PHOTOS table. Convert the COLOR value to uppercase. If ID is NULL or already exists in the table, generate a new unique ID by finding the maximum existing ID and adding 1.",
    "natural_language": "Please implement a BEFORE INSERT row-level trigger designated as photos_before_insert_upper_color for the PHOTOS table. The trigger's function is to convert the COLOR value to uppercase. Furthermore, should the ID value be NULL or if it already exists within the table, a new unique ID must be generated by incrementing the maximum existing ID value by one.",
    "id": 60
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is executed before an update operation on the photos table, specifically for each row that is being updated. The trigger modifies the NAME column of the row being updated by truncating its value to a maximum length of 50 characters. This is achieved by using the SUBSTR function, which extracts a substring from the NAME column starting at the first character and extending up to the 50th character. The result of this operation is then assigned back to the NAME column of the new version of the row, denoted by :NEW.NAME, ensuring that the updated NAME value does not exceed 50 characters in length.",
    "plsql": "CREATE OR REPLACE TRIGGER photos_before_update_trim_name\nBEFORE UPDATE ON photos\nFOR EACH ROW\nBEGIN\n   :NEW.NAME := SUBSTR(:NEW.NAME, 1, 50);\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "PHOTOS"
    ],
    "call_sqls": [
      "UPDATE photos SET name = 'A very long photo name that definitely exceeds fifty characters in total length' WHERE id = 1",
      "UPDATE photos SET name = 'Sunset over the mountain range with a beautiful reflection in the lake' WHERE id = 2",
      "UPDATE photos SET name = name || ' - additional descriptive text to make it longer' WHERE id = 4",
      "UPDATE photos SET name = 'Test', color = 'RGB' WHERE mountain_id = 20",
      "UPDATE photos SET name = 'A' WHERE camera_lens_id = 10"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger on the PHOTOS table. For each updated row, truncate the :NEW.NAME value to a maximum of 50 characters.",
    "natural_language": "How can I create a BEFORE UPDATE row-level trigger for the PHOTOS table that truncates the :NEW.NAME value to 50 characters for each updated row?",
    "id": 61
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named photos_after_update_cleanup that is executed automatically after any update operation on the photos table. This trigger performs a delete operation on the same photos table, specifically removing any rows where the length of the value in the NAME column is less than 3 characters. The trigger does not take any parameters, and its sole purpose is to enforce a data integrity rule by ensuring that all entries in the photos table have a NAME column value with a minimum length of 3 characters. The LENGTH function is used to determine the number of characters in the NAME column for each row, and any row that does not meet the specified length condition is deleted from the table.",
    "plsql": "CREATE OR REPLACE TRIGGER photos_after_update_cleanup\nAFTER UPDATE ON photos\nBEGIN\n   DELETE FROM photos WHERE LENGTH(NAME) < 3;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "PHOTOS"
    ],
    "call_sqls": [
      "UPDATE photos SET name = 'ab' WHERE id = 1",
      "UPDATE photos SET color = 'RGB' WHERE mountain_id = 20",
      "UPDATE photos SET camera_lens_id = 5 WHERE name = 'grass'",
      "UPDATE photos SET name = 'x' WHERE id = 2",
      "UPDATE photos SET color = 'CMYK', name = 'y' WHERE id = 4"
    ],
    "summary": "Create an AFTER UPDATE statement-level trigger named PHOTOS_AFTER_UPDATE_CLEANUP on the PHOTOS table. After an update, delete any rows from PHOTOS where the LENGTH of the NAME column is less than 3.",
    "natural_language": "Alright, so we need a trigger that fires off after someone updates the PHOTOS table. Let's call it PHOTOS_AFTER_UPDATE_CLEANUP. Basically, right after any update happens, it should clean house by getting rid of any photo entries where the name's too shortlike, if the NAME is less than 3 characters long, just zap that row.",
    "id": 62
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_pet_age_weight_audit that fires after each row is updated on the PETS table, specifically when the PET_AGE or WEIGHT columns are modified. The trigger declares local variables v_pet_type as a VARCHAR2 to hold the new PETTYPE value and v_age_diff as a NUMBER to store the absolute difference between the new and old PET_AGE values. The trigger logic begins by assigning :NEW.PETTYPE to v_pet_type and calculating the absolute value of :NEW.PET_AGE minus :OLD.PET_AGE into v_age_diff. It then evaluates a series of conditional statements: if the pet type is 'dog' and the new WEIGHT is greater than 30, it executes a DELETE operation on the HAS_PET table, removing rows where the PETID matches the new PETID and the associated STUID belongs to a STUDENT with an AGE less than 20. Otherwise, if the pet type is 'cat' and the new PET_AGE is greater than 10, it executes an UPDATE operation on the STUDENT table, increasing the MAJOR column value by 100 for any student whose STUID is associated with the updated pet's PETID in the HAS_PET table. Otherwise, if the calculated age difference v_age_diff is greater than 5, it executes an INSERT operation into the HAS_PET table, adding a new row with the updated pet's PETID and the STUID of a single arbitrary student selected by the ROWNUM = 1 condition from the STUDENT table. If none of these conditions are met, the trigger performs a NULL operation to avoid mutating the PETS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_pet_age_weight_audit\nAFTER UPDATE OF PET_AGE, WEIGHT ON PETS\nFOR EACH ROW\nDECLARE\n    v_pet_type VARCHAR2(255);\n    v_age_diff NUMBER;\nBEGIN\n    v_pet_type := :NEW.PETTYPE;\n    v_age_diff := ABS(:NEW.PET_AGE - :OLD.PET_AGE);\n    IF v_pet_type = 'dog' AND :NEW.WEIGHT > 30 THEN\n        DELETE FROM HAS_PET WHERE PETID = :NEW.PETID AND STUID IN \n            (SELECT STUID FROM STUDENT WHERE AGE < 20);\n    ELSIF v_pet_type = 'cat' AND :NEW.PET_AGE > 10 THEN\n        UPDATE STUDENT SET MAJOR = MAJOR + 100 WHERE STUID IN \n            (SELECT STUID FROM HAS_PET WHERE PETID = :NEW.PETID);\n    ELSIF v_age_diff > 5 THEN\n        INSERT INTO HAS_PET (STUID, PETID) \n        SELECT STUID, :NEW.PETID FROM STUDENT WHERE ROWNUM = 1;\n    ELSE\n        NULL; -- Avoid mutating PETS table\n    END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "UPDATE PETS SET PET_AGE = 8, WEIGHT = 35 WHERE PETID = 2001",
      "UPDATE PETS SET PET_AGE = 12, WEIGHT = 9 WHERE PETID = 2002",
      "UPDATE PETS SET PET_AGE = 15, WEIGHT = 25 WHERE PETID = 2003",
      "UPDATE PETS SET PET_AGE = 10 WHERE PETID = 2001",
      "UPDATE PETS SET WEIGHT = 40 WHERE PETID = 2002"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_PET_AGE_WEIGHT_AUDIT on the PETS table for updates to PET_AGE or WEIGHT. If PETTYPE is 'dog' and new WEIGHT > 30, delete from HAS_PET where PETID matches and the linked STUDENT.AGE < 20. Else if PETTYPE is 'cat' and new PET_AGE > 10, update STUDENT.MAJOR by adding 100 for students linked via HAS_PET. Else if the absolute difference between new and old PET_AGE > 5, insert a new row into HAS_PET using the updated PETID and an arbitrary student's STUID. Otherwise, do nothing.",
    "natural_language": "Create a row-level trigger named TRG_PET_AGE_WEIGHT_AUDIT that fires AFTER UPDATE on the PETS table. Make it activate only when PET_AGE or WEIGHT is updated. For each updated row, check the following conditions and execute the corresponding action: If PETTYPE is 'dog' and the new WEIGHT exceeds 30, delete any records from the HAS_PET table where the PETID matches and the linked STUDENT's AGE is under 20. Otherwise, if PETTYPE is 'cat' and the new PET_AGE is greater than 10, update the STUDENT table by adding 100 to the MAJOR field for all students linked through HAS_PET. Otherwise, if the absolute difference between the new and old PET_AGE values is more than 5, insert a new row into HAS_PET using the updated PETID and the STUID of an arbitrary student. If none of these conditions are met, have the trigger take no action.",
    "id": 63
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_enrollment_check that fires after each row is updated in the SCHOOL table, and for each updated row, it first declares two local NUMBER variables v_player_count and v_detail_exists, then executes a SELECT COUNT(*) query on the PLAYER table where the SCHOOL_ID column equals the new SCHOOL_ID value from the updated row, storing the result in v_player_count, and executes another SELECT COUNT(*) query on the SCHOOL_DETAILS table where the SCHOOL_ID column equals the new SCHOOL_ID value, storing the result in v_detail_exists, then enters a conditional block where if the new ENROLLMENT column value from the updated row is greater than 2000, it checks if v_detail_exists equals 0, and if true, performs an INSERT into the SCHOOL_DETAILS table, specifying the new SCHOOL_ID value for the SCHOOL_ID column and the literal string 'Champions' for the NICKNAME column, but if v_detail_exists is not 0, it performs an UPDATE on the SCHOOL_DETAILS table, setting the NICKNAME column to 'Champions' for the row where the SCHOOL_ID column equals the new SCHOOL_ID value; otherwise, if the new ENROLLMENT is not greater than 2000, it checks if v_player_count is greater than 5, and if true, performs a DELETE from the SCHOOL_PERFORMANCE table for any row where the SCHOOL_ID column equals the new SCHOOL_ID value; otherwise, if v_player_count is not greater than 5, it checks if v_detail_exists equals 0, and if true, performs an INSERT into the SCHOOL_PERFORMANCE table, specifying the new SCHOOL_ID value for the SCHOOL_ID column and the literal string '2024-25' for the SCHOOL_YEAR column; otherwise, if none of the previous conditions are met, it performs an UPDATE on the SCHOOL_DETAILS table, setting the LEAGUE column to the literal string 'Premier' for the row where the SCHOOL_ID column equals the new SCHOOL_ID value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_enrollment_check\nAFTER UPDATE ON SCHOOL\nFOR EACH ROW\nDECLARE\n    v_player_count NUMBER;\n    v_detail_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_player_count FROM PLAYER WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    SELECT COUNT(*) INTO v_detail_exists FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    \n    IF :NEW.ENROLLMENT > 2000 THEN\n        IF v_detail_exists = 0 THEN\n            INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME) VALUES (:NEW.SCHOOL_ID, 'Champions');\n        ELSE\n            UPDATE SCHOOL_DETAILS SET NICKNAME = 'Champions' WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n        END IF;\n    ELSIF v_player_count > 5 THEN\n        DELETE FROM SCHOOL_PERFORMANCE WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    ELSIF v_detail_exists = 0 THEN\n        INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR) VALUES (:NEW.SCHOOL_ID, '2024-25');\n    ELSE\n        UPDATE SCHOOL_DETAILS SET LEAGUE = 'Premier' WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "UPDATE SCHOOL SET ENROLLMENT = 2500 WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET ENROLLMENT = 1500 WHERE SCHOOL_ID = 3",
      "UPDATE SCHOOL SET ENROLLMENT = 2100 WHERE SCHOOL_ID = 4",
      "UPDATE SCHOOL SET ENROLLMENT = 1800 WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET ENROLLMENT = 2200 WHERE SCHOOL_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_SCHOOL_ENROLLMENT_CHECK on the SCHOOL table. For each updated row, count players for the new SCHOOL_ID and check if SCHOOL_DETAILS exists for it. If new ENROLLMENT > 2000, insert or update SCHOOL_DETAILS.NICKNAME to 'Champions'. If ENROLLMENT <= 2000 and player count > 5, delete from SCHOOL_PERFORMANCE for that SCHOOL_ID. If ENROLLMENT <= 2000 and player count <= 5 and no details exist, insert into SCHOOL_PERFORMANCE. Otherwise, update SCHOOL_DETAILS.LEAGUE to 'Premier'.",
    "natural_language": "Create trigger TRG_SCHOOL_ENROLLMENT_CHECK on SCHOOL after update. For each row: count players for new SCHOOL_ID, check for SCHOOL_DETAILS. If ENROLLMENT > 2000, set SCHOOL_DETAILS.NICKNAME to 'Champions'. If ENROLLMENT <= 2000 and player count > 5, delete from SCHOOL_PERFORMANCE for that SCHOOL_ID. If ENROLLMENT <= 2000, player count <= 5, and no details exist, insert into SCHOOL_PERFORMANCE. Else, update SCHOOL_DETAILS.LEAGUE to 'Premier'.",
    "id": 64
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_details_sync that fires before each row is deleted from the SCHOOL_DETAILS table, and for each row being deleted, it declares two local NUMBER variables v_school_enrollment and v_performance_count, then retrieves the ENROLLMENT value from the SCHOOL table for the SCHOOL_ID matching the old row's SCHOOL_ID into v_school_enrollment, and also counts the number of rows in the SCHOOL_PERFORMANCE table for the same SCHOOL_ID into v_performance_count, then evaluates a conditional logic block: if the old row's DIVISION column equals the string 'Division 1', it updates the SCHOOL table by setting the ENROLLMENT column for that SCHOOL_ID to the result of rounding the retrieved v_school_enrollment multiplied by 1.1; otherwise, if the retrieved v_school_enrollment is less than 1500, it deletes all rows from the SCHOOL_PERFORMANCE table where the SCHOOL_ID matches the old row's SCHOOL_ID; otherwise, if the counted v_performance_count is greater than 2, it inserts a new row into the SCHOOL_PERFORMANCE table with the old SCHOOL_ID and a SCHOOL_YEAR value of 'Archive'; otherwise, for any other case, it deletes a single row from the PLAYER table where the SCHOOL_ID matches the old row's SCHOOL_ID and the ROWNUM pseudo-column equals 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_details_sync\nBEFORE DELETE ON SCHOOL_DETAILS\nFOR EACH ROW\nDECLARE\n    v_school_enrollment NUMBER;\n    v_performance_count NUMBER;\nBEGIN\n    SELECT ENROLLMENT INTO v_school_enrollment FROM SCHOOL WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    SELECT COUNT(*) INTO v_performance_count FROM SCHOOL_PERFORMANCE WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    \n    IF :OLD.DIVISION = 'Division 1' THEN\n        UPDATE SCHOOL SET ENROLLMENT = ROUND(v_school_enrollment * 1.1) WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    ELSIF v_school_enrollment < 1500 THEN\n        DELETE FROM SCHOOL_PERFORMANCE WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    ELSIF v_performance_count > 2 THEN\n        INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR) VALUES (:OLD.SCHOOL_ID, 'Archive');\n    ELSE\n        DELETE FROM PLAYER WHERE SCHOOL_ID = :OLD.SCHOOL_ID AND ROWNUM = 1;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 1",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 2",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 3",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 4",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_SCHOOL_DETAILS_SYNC on the SCHOOL_DETAILS table. For each deleted row, get the school's ENROLLMENT and count its SCHOOL_PERFORMANCE records. If the old DIVISION is 'Division 1', update SCHOOL.ENROLLMENT by increasing it 10%. Else if the enrollment < 1500, delete from SCHOOL_PERFORMANCE for that SCHOOL_ID. Else if the performance count > 2, insert an 'Archive' record into SCHOOL_PERFORMANCE. Otherwise, delete one arbitrary row from PLAYER for that SCHOOL_ID.",
    "natural_language": "Create trigger TRG_SCHOOL_DETAILS_SYNC. On SCHOOL_DETAILS row delete: if old DIVISION is 'Division 1', increase SCHOOL.ENROLLMENT by 10%. Else if ENROLLMENT < 1500, delete SCHOOL_PERFORMANCE for that SCHOOL_ID. Else if SCHOOL_PERFORMANCE count > 2, insert 'Archive' record. Otherwise, delete one PLAYER row for that SCHOOL_ID.",
    "id": 65
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT FOR EACH ROW` trigger named `trg_performance_audit` that is activated on the `SCHOOL_PERFORMANCE` table. This trigger executes a block of code for each row that is newly inserted into the `SCHOOL_PERFORMANCE` table. The trigger declares three local numeric variables: `v_school_founded` to store the founding year of a school, `v_player_avg_age` to store the average age of players associated with a school, and `v_school_exists` which is declared but not used in the provided code.\n\nUpon activation for each new row, the trigger first attempts to retrieve the `FOUNDED` column value from the `SCHOOL` table into the `v_school_founded` variable. This retrieval is based on matching the `SCHOOL_ID` column in the `SCHOOL` table with the `SCHOOL_ID` of the newly inserted row, referenced as `:NEW.SCHOOL_ID`. A `NO_DATA_FOUND` exception handler is included for this `SELECT` statement; if no matching school is found, `v_school_founded` is explicitly set to `NULL`.\n\nNext, the trigger attempts to calculate the rounded average of the `AGE` column for all players associated with the school identified by `:NEW.SCHOOL_ID` from the `PLAYER` table. This rounded average is then stored in the `v_player_avg_age` variable. Similar to the previous `SELECT` statement, a `NO_DATA_FOUND` exception handler is present; if no players are found for the given `SCHOOL_ID`, `v_player_avg_age` is set to `NULL`.\n\nFollowing these data retrievals, the trigger proceeds with a series of conditional operations:\n\n1.  **First Condition:** It checks if the value of `v_school_founded` is less than `1920`.\n    *   If this condition is true, a `MERGE` statement is executed on the `SCHOOL_DETAILS` table, aliased as `sd`.\n    *   The `MERGE` statement uses a subquery `(SELECT :NEW.SCHOOL_ID AS SCHOOL_ID, 'Historic' AS CLASS FROM DUAL)` as its source, aliased as `src`. This source provides the `SCHOOL_ID` from the newly inserted row and a literal string `'Historic'` for the `CLASS` column.\n    *   The `MERGE` operation matches rows in `SCHOOL_DETAILS` with the source based on `sd.SCHOOL_ID = src.SCHOOL_ID`.\n    *   If a match is found (`WHEN MATCHED THEN`), the `CLASS` column of the matched row in `SCHOOL_DETAILS` is updated to the `CLASS` value from the source (`src.CLASS`, which is `'Historic'`).\n    *   If no match is found (`WHEN NOT MATCHED THEN`), a new row is inserted into `SCHOOL_DETAILS` with the following values: `SCHOOL_ID` from `src.SCHOOL_ID`, `NICKNAME` set to the literal string `'Default'`, `COLORS` set to the literal string `'Default Colors'`, `LEAGUE` set to the literal string `'Default League'`, `CLASS` set to `src.CLASS` (which is `'Historic'`), and `DIVISION` set to the literal string `'Default Division'`.\n\n2.  **Second Condition (ELSIF):** If the first condition (`v_school_founded < 1920`) is false, the trigger then checks if `v_player_avg_age` is greater than `16`.\n    *   If this condition is true, an `UPDATE` statement is executed on the `SCHOOL` table. The `SCHOOL_COLORS` column is set to the literal string `'Gold and Silver'` for the row where `SCHOOL_ID` matches `:NEW.SCHOOL_ID`.\n\n3.  **Third Condition (ELSIF):** If both the first and second conditions are false, the trigger checks if the `SCHOOL_YEAR` column of the newly inserted row (`:NEW.SCHOOL_YEAR`) starts with the string `'2024%'` (using the `LIKE` operator).\n    *   If this condition is true, a `DELETE` statement is executed on the `SCHOOL_DETAILS` table. Rows are deleted where `SCHOOL_ID` matches `:NEW.SCHOOL_ID` AND the `CLASS` column is equal to the literal string `'Flight B'`.\n\n4.  **Else Block:** If none of the preceding conditions are met, the trigger executes an `UPDATE` statement on the `PLAYER` table.\n    *   The `TEAM` column is set to the literal string `'Academy Team'`.\n    *   This update applies to a specific player identified by two conditions: `SCHOOL_ID` must match `:NEW.SCHOOL_ID`, AND `PLAYER_ID` must be equal to the minimum `PLAYER_ID` found in the `PLAYER` table for that specific `SCHOOL_ID` (determined by a subquery `(SELECT MIN(PLAYER_ID) FROM PLAYER WHERE SCHOOL_ID = :NEW.SCHOOL_ID)`).\n\nFinally, the entire trigger block is wrapped in an `EXCEPTION WHEN OTHERS THEN NULL;` block, which catches any unhandled exceptions that might occur during the trigger's execution and simply ignores them without performing any specific error logging or handling.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_performance_audit\nAFTER INSERT ON SCHOOL_PERFORMANCE\nFOR EACH ROW\nDECLARE\n    v_school_founded NUMBER;\n    v_player_avg_age NUMBER;\n    v_school_exists NUMBER;\nBEGIN\n    -- Handle potential NO_DATA_FOUND exceptions\n    BEGIN\n        SELECT FOUNDED INTO v_school_founded FROM SCHOOL WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_school_founded := NULL;\n    END;\n    \n    BEGIN\n        SELECT ROUND(AVG(AGE)) INTO v_player_avg_age FROM PLAYER WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_player_avg_age := NULL;\n    END;\n    \n    IF v_school_founded < 1920 THEN\n        -- Use MERGE to handle insert or update for SCHOOL_DETAILS\n        MERGE INTO SCHOOL_DETAILS sd\n        USING (SELECT :NEW.SCHOOL_ID AS SCHOOL_ID, 'Historic' AS CLASS FROM DUAL) src\n        ON (sd.SCHOOL_ID = src.SCHOOL_ID)\n        WHEN MATCHED THEN\n            UPDATE SET sd.CLASS = src.CLASS\n        WHEN NOT MATCHED THEN\n            INSERT (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION)\n            VALUES (src.SCHOOL_ID, 'Default', 'Default Colors', 'Default League', src.CLASS, 'Default Division');\n    ELSIF v_player_avg_age > 16 THEN\n        UPDATE SCHOOL SET SCHOOL_COLORS = 'Gold and Silver' WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    ELSIF :NEW.SCHOOL_YEAR LIKE '2024%' THEN\n        DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID AND CLASS = 'Flight B';\n    ELSE\n        UPDATE PLAYER SET TEAM = 'Academy Team' \n        WHERE SCHOOL_ID = :NEW.SCHOOL_ID \n        AND PLAYER_ID = (SELECT MIN(PLAYER_ID) FROM PLAYER WHERE SCHOOL_ID = :NEW.SCHOOL_ID);\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Log error or handle appropriately\n        NULL;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (2, '1900-01', 'TestA', 'TestAA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (3, '2023-24', 'TestA', 'TestAA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (4, '2024-25', 'TestA', 'TestAA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (1, '2022-23', 'TestA', 'TestAA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (2, '2024-25', 'TestA', 'TestAA')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_performance_audit on the SCHOOL_PERFORMANCE table. For each new row, retrieve the school's founding year and the average player age, handling NO_DATA_FOUND by setting values to NULL. Then, if the founding year is before 1920, MERGE a 'Historic' CLASS into SCHOOL_DETAILS. Else if the average age is over 16, update the school's colors to 'Gold and Silver'. Else if the new SCHOOL_YEAR starts with '2024%', delete 'Flight B' records from SCHOOL_DETAILS. Otherwise, update the player with the minimum ID for that school to 'Academy Team'. Handle all other exceptions by ignoring them.",
    "natural_language": "Construct an AFTER INSERT FOR EACH ROW trigger, which should be named trg_performance_audit, specifically for the SCHOOL_PERFORMANCE table. For every single newly inserted row, meticulously retrieve the founding year of the school along with the calculated average age of its players; should a NO_DATA_FOUND exception occur during this retrieval, gracefully handle it by setting both of these values to NULL. Subsequently, if the retrieved founding year is determined to be earlier than the year 1920, you must perform a MERGE operation to insert a 'Historic' CLASS record into the SCHOOL_DETAILS table. Alternatively, if the first condition is not met but the computed average player age is found to be greater than 16, then proceed to update the school's official colors to a distinguished 'Gold and Silver'. In the event that neither of the previous conditions applies, yet the new SCHOOL_YEAR value begins with the prefix '2024', you are instructed to delete any and all records associated with 'Flight B' from the SCHOOL_DETAILS table. Finally, if none of the aforementioned scenarios are true, the trigger should update the designation of the player who possesses the minimum ID for that particular school to 'Academy Team'. It is imperative that all other unforeseen exceptions are comprehensively handled by simply ignoring them without raising an error.",
    "id": 66
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_player_position_mgmt that fires for DELETE operations on the PLAYER table, which first declares a record type with fields player_id of type NUMBER, school_id of type NUMBER, and position of type VARCHAR2(255), and a nested table type of that record, then instantiates a global collection variable g_deleted_players of that nested table type; within its AFTER EACH ROW section, it extends the global collection and populates the next element with the OLD.PLAYER_ID, OLD.SCHOOL_ID, and OLD.POSITION values from the currently deleted row; within its AFTER STATEMENT section, it declares local variables v_remaining_players of type NUMBER, v_school_type of type VARCHAR2(255), and v_school_found of type BOOLEAN, then loops through each record stored in the g_deleted_players collection, and for each iteration, it selects the COUNT of remaining players from the PLAYER table where the SCHOOL_ID equals the current record's school_id into v_remaining_players, then uses a nested block with exception handling to attempt to select the DAY_OR_BOARDING column from the SCHOOL table where SCHOOL_ID equals the current record's school_id into v_school_type, setting v_school_found to TRUE if successful, or catching the NO_DATA_FOUND exception to set v_school_found to FALSE and v_school_type to NULL; then, based on a conditional logic chain, if the current record's position field equals the string 'First Baseman', it deletes a single row from the SCHOOL_PERFORMANCE table where SCHOOL_ID equals the current record's school_id using ROWNUM = 1; otherwise, if v_remaining_players equals 0, it updates the SCHOOL table by setting the ENROLLMENT column to 0 for the row where SCHOOL_ID equals the current record's school_id; otherwise, if v_school_found is TRUE and v_school_type equals the string 'Day & Boarding', it uses a nested block to attempt to insert a new row into the SCHOOL_DETAILS table with SCHOOL_ID set to the current record's school_id and DIVISION set to 'Alumni', catching the DUP_VAL_ON_INDEX exception to instead update the existing SCHOOL_DETAILS row for that SCHOOL_ID by setting its DIVISION column to 'Alumni'; otherwise, if v_school_found is TRUE, it uses another nested block to attempt to update the SCHOOL_DETAILS table by setting the COLORS column to 'Memorial Colors' for the row where SCHOOL_ID equals the current record's school_id, catching the NO_DATA_FOUND exception to take no action; after processing all records in the collection, the trigger deletes all elements from the g_deleted_players collection.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_player_position_mgmt\nFOR DELETE ON PLAYER\nCOMPOUND TRIGGER\n    TYPE deleted_player_rec IS RECORD (\n        player_id NUMBER,\n        school_id NUMBER,\n        position VARCHAR2(255)\n    );\n    TYPE deleted_players_t IS TABLE OF deleted_player_rec;\n    g_deleted_players deleted_players_t := deleted_players_t();\n    \n    AFTER EACH ROW IS\n    BEGIN\n        g_deleted_players.EXTEND;\n        g_deleted_players(g_deleted_players.COUNT).player_id := :OLD.PLAYER_ID;\n        g_deleted_players(g_deleted_players.COUNT).school_id := :OLD.SCHOOL_ID;\n        g_deleted_players(g_deleted_players.COUNT).position := :OLD.POSITION;\n    END AFTER EACH ROW;\n    \n    AFTER STATEMENT IS\n        v_remaining_players NUMBER;\n        v_school_type VARCHAR2(255);\n        v_school_found BOOLEAN;\n    BEGIN\n        FOR i IN 1..g_deleted_players.COUNT LOOP\n            -- Get remaining players count for this school\n            SELECT COUNT(*) INTO v_remaining_players \n            FROM PLAYER \n            WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n            \n            -- Get school type with exception handling\n            BEGIN\n                SELECT DAY_OR_BOARDING INTO v_school_type \n                FROM SCHOOL \n                WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n                v_school_found := TRUE;\n            EXCEPTION\n                WHEN NO_DATA_FOUND THEN\n                    v_school_found := FALSE;\n                    v_school_type := NULL;\n            END;\n            \n            -- Execute logic based on conditions\n            IF g_deleted_players(i).position = 'First Baseman' THEN\n                DELETE FROM SCHOOL_PERFORMANCE \n                WHERE SCHOOL_ID = g_deleted_players(i).school_id AND ROWNUM = 1;\n            ELSIF v_remaining_players = 0 THEN\n                UPDATE SCHOOL SET ENROLLMENT = 0 \n                WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n            ELSIF v_school_found AND v_school_type = 'Day & Boarding' THEN\n                BEGIN\n                    INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, DIVISION) \n                    VALUES (g_deleted_players(i).school_id, 'Alumni');\n                EXCEPTION\n                    WHEN DUP_VAL_ON_INDEX THEN\n                        UPDATE SCHOOL_DETAILS SET DIVISION = 'Alumni'\n                        WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n                END;\n            ELSIF v_school_found THEN\n                BEGIN\n                    UPDATE SCHOOL_DETAILS SET COLORS = 'Memorial Colors' \n                    WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n                EXCEPTION\n                    WHEN NO_DATA_FOUND THEN\n                        NULL; -- SCHOOL_DETAILS record doesn't exist\n                END;\n            END IF;\n        END LOOP;\n        \n        g_deleted_players.DELETE;\n    END AFTER STATEMENT;\nEND trg_player_position_mgmt;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM PLAYER WHERE PLAYER_ID = 1",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 2",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 3",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 4",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 5"
    ],
    "summary": "Create a compound trigger named trg_player_position_mgmt for DELETE on the PLAYER table. Declare a global collection to store deleted player records. In the AFTER EACH ROW section, add the OLD values to the collection. In the AFTER STATEMENT section, for each deleted player: get the count of remaining players and try to fetch the school type. If the player's position was 'First Baseman', delete one related SCHOOL_PERFORMANCE row. Else if no players remain, set the school's enrollment to 0. Else if the school type is 'Day & Boarding', insert or update an 'Alumni' DIVISION in SCHOOL_DETAILS. Else if the school exists, attempt to update its SCHOOL_DETAILS colors to 'Memorial Colors'. Finally, clear the collection.",
    "natural_language": "Create a compound trigger called trg_player_position_mgmt for DELETE operations on the PLAYER table. First, declare a global collection to hold deleted player records. In the AFTER EACH ROW section, store the OLD row values into this collection. Then, in the AFTER STATEMENT section, process each deleted player: count the remaining players and try to get the school type. If the player's position was 'First Baseman', delete one corresponding row from SCHOOL_PERFORMANCE. Otherwise, if no players are left, set the school's enrollment to 0. Alternatively, if the school type is 'Day & Boarding', insert or update an 'Alumni' DIVISION in SCHOOL_DETAILS. If the school exists instead, try to update its SCHOOL_DETAILS colors to 'Memorial Colors'. Finally, empty the collection.",
    "id": 67
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_ship_insert that is executed after a new row is inserted into the SHIP table. This trigger operates for each row inserted and begins by declaring a local variable v_next_mission_id of type NUMBER to store the next available mission identifier. The trigger then performs a SELECT statement to retrieve the maximum MISSION_ID from the MISSION table, using the NVL function to handle cases where no mission records exist by defaulting to 0, and increments this value by 1 to determine the next mission ID. This calculated mission ID is stored in the v_next_mission_id variable. Subsequently, the trigger inserts a new record into the MISSION table with the following values: the newly calculated v_next_mission_id for the MISSION_ID column, the SHIP_ID from the newly inserted row in the SHIP table accessed via the :NEW pseudo-record, a static string 'New Mission' for the CODE column, the current year extracted from the system date using the EXTRACT function for the LAUNCHED_YEAR column, a static string 'Unknown' for the LOCATION column, a numeric value 0 for the SPEED_KNOTS column, and a static string 'Active' for the FATE column. The trigger includes an exception handling block that captures any errors during execution using the WHEN OTHERS clause, and raises an application error with a custom error code -20001 and a message that includes the error description obtained from SQLERRM, indicating an error occurred while creating a mission for the new ship.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_ship_insert\nAFTER INSERT ON SHIP\nFOR EACH ROW\nDECLARE\n  v_next_mission_id NUMBER;\nBEGIN\n  -- Get the next available MISSION_ID\n  SELECT NVL(MAX(MISSION_ID), 0) + 1 \n  INTO v_next_mission_id \n  FROM MISSION;\n  \n  -- Insert new mission record\n  INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE)\n  VALUES (v_next_mission_id, :NEW.SHIP_ID, 'New Mission', EXTRACT(YEAR FROM SYSDATE), 'Unknown', 0, 'Active');\n  \nEXCEPTION\n  WHEN OTHERS THEN\n    -- Log error or handle as needed\n    RAISE_APPLICATION_ERROR(-20001, 'Error creating mission for new ship: ' || SQLERRM);\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (101, 'New Ship 1', 'Frigate', 'France', 5000)",
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (102, 'New Ship 2', 'Destroyer', 'USA', 7500)",
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (103, 'New Ship 3', 'Submarine', 'Russia', 6000)",
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (104, 'New Ship 4', 'Aircraft Carrier', 'China', 100000)",
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (105, 'New Ship 5', 'Corvette', 'Germany', 2500)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_ship_insert on the SHIP table. For each new ship, calculate the next MISSION_ID by incrementing the maximum existing ID (defaulting to 0). Insert a new mission record using this new ID, the new ship's SHIP_ID, 'New Mission' as CODE, the current year, 'Unknown' as LOCATION, 0 as SPEED_KNOTS, and 'Active' as FATE. If any error occurs, raise an application error with the error details.",
    "natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger named trg_ship_insert on the SHIP table that, for each new ship, calculates the next MISSION_ID by incrementing the maximum existing ID (defaulting to 0), inserts a new mission record using this new ID, the new ship's SHIP_ID, 'New Mission' as CODE, the current year, 'Unknown' as LOCATION, 0 as SPEED_KNOTS, and 'Active' as FATE, and raises an application error with the error details if any error occurs?",
    "id": 68
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_mission_delete that is defined to execute automatically before any row deletion operation on the MISSION table, and for each individual row being deleted, the trigger performs a delete operation on the SHIP table where the SHIP_ID column value in the SHIP table exactly matches the SHIP_ID column value from the row currently being deleted from the MISSION table, which is accessed via the :OLD.SHIP_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_mission_delete\nBEFORE DELETE ON MISSION\nFOR EACH ROW\nBEGIN\n  DELETE FROM SHIP WHERE SHIP_ID = :OLD.SHIP_ID;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "DELETE FROM MISSION WHERE MISSION_ID = 1",
      "DELETE FROM MISSION WHERE SHIP_ID = 2",
      "DELETE FROM MISSION WHERE CODE = 'VMV-1'",
      "DELETE FROM MISSION WHERE LAUNCHED_YEAR = 1930",
      "DELETE FROM MISSION WHERE MISSION_ID IN (2, 4)"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_mission_delete on the MISSION table. For each mission being deleted, delete the corresponding ship from the SHIP table where SHIP_ID matches the :OLD.SHIP_ID.",
    "natural_language": "Delete the corresponding ship from the SHIP table for each mission being deleted by creating a BEFORE DELETE FOR EACH ROW trigger named trg_mission_delete on the MISSION table, matching the SHIP_ID to the :OLD.SHIP_ID.",
    "id": 69
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_mission_insert that is automatically executed after a new row is inserted into the MISSION table for each individual row that is inserted, and within its execution block, it performs a single INSERT operation into the SHIP table, specifying values for the columns SHIP_ID, NAME, TYPE, NATIONALITY, and TONNAGE, where the value for the SHIP_ID column is taken directly from the newly inserted row in the MISSION table using the :NEW.SHIP_ID reference, while the values for the NAME, TYPE, NATIONALITY, and TONNAGE columns are hard-coded as the string literal 'New Ship', the string literal 'Type', the string literal 'Nationality', and the numeric literal 1000, respectively.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_mission_insert\nAFTER INSERT ON MISSION\nFOR EACH ROW\nBEGIN\n  INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE)\n  VALUES (:NEW.SHIP_ID, 'New Ship', 'Type', 'Nationality', 1000);\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (3, 3, 'VMV-3', 1940, 'France', 20, 'Active')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (5, 4, 'VMV-5', 1945, 'Italy', 22, 'Active')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (6, 6, 'VMV-6', 1950, 'Spain', 18, 'Active')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (7, 7, 'VMV-7', 1960, 'Portugal', 24, 'Active')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (8, 8, 'VMV-8', 1970, 'Netherlands', 26, 'Active')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_mission_insert on the MISSION table. For each new mission, insert a new ship into the SHIP table using the new mission's SHIP_ID, with 'New Ship' as NAME, 'Type' as TYPE, 'Nationality' as NATIONALITY, and 1000 as TONNAGE.",
    "natural_language": "Alright, so set up a trigger called trg_mission_insert on the MISSION table that fires after a new row is added. Every time a new mission pops up, we gotta toss a new ship into the SHIP table. Use the new mission's SHIP_ID for that, and just fill in the other details with 'New Ship' for the NAME, 'Type' for the TYPE, 'Nationality' for the NATIONALITY, and stick 1000 in for the TONNAGE.",
    "id": 70
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_ship_delete that is defined to execute before any delete operation on the SHIP table for each individual row being deleted, and within its execution block, it performs a delete operation on the MISSION table where the condition requires the SHIP_ID column in the MISSION table to be equal to the value of the SHIP_ID column from the row currently being deleted from the SHIP table, which is referenced using the :OLD.SHIP_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_ship_delete\nBEFORE DELETE ON SHIP\nFOR EACH ROW\nBEGIN\n  DELETE FROM MISSION WHERE SHIP_ID = :OLD.SHIP_ID;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "DELETE FROM SHIP WHERE SHIP_ID = 1",
      "DELETE FROM SHIP WHERE SHIP_ID = 2",
      "DELETE FROM SHIP WHERE SHIP_ID = 3"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_ship_delete on the SHIP table. For each deleted row, delete rows from the MISSION table where MISSION.SHIP_ID equals the deleted row's SHIP_ID (:OLD.SHIP_ID).",
    "natural_language": "Hey, set up a trigger called trg_ship_delete that fires before you delete a row from the SHIP table. Every time a ship gets deleted, it should also wipe out any missions in the MISSION table that were linked to that old ship's ID.",
    "id": 71
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_singer_age_calc` that is activated `BEFORE` an `INSERT` operation is performed on the `SINGER` table, and executes `FOR EACH ROW` being inserted. This trigger declares a local numeric variable `v_age_months` to store the calculated age in months. Within the trigger's execution block, it first calculates the age of the singer in months by determining the number of months between the current system date (`SYSDATE`) and the singer's birth date. The singer's birth date is constructed by concatenating the `BIRTH_YEAR` column value from the `NEW` pseudo-record (representing the row being inserted) with the literal string `'-01-01'`, and then converting this combined string into a date format using `TO_DATE` with the format mask `'YYYY-MM-DD'`. The result of this `MONTHS_BETWEEN` function call is assigned to the `v_age_months` variable. Subsequently, a conditional logic block is executed: `IF` the calculated `v_age_months` is `LESS THAN` `600` (representing 50 years), then the `NET_WORTH_MILLIONS` column of the `NEW` pseudo-record is updated by multiplying its current value by `0.9` (effectively reducing it by 10%). `ELSE IF` the calculated `v_age_months` is `GREATER THAN` `960` (representing 80 years), then the `NET_WORTH_MILLIONS` column of the `NEW` pseudo-record is updated by multiplying its current value by `1.1` (effectively increasing it by 10%). If neither of these conditions is met, the `NET_WORTH_MILLIONS` column remains unchanged.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_age_calc\nBEFORE INSERT ON SINGER\nFOR EACH ROW\nDECLARE\n   v_age_months NUMBER;\nBEGIN\n   v_age_months := MONTHS_BETWEEN(SYSDATE, TO_DATE(:NEW.BIRTH_YEAR || '-01-01', 'YYYY-MM-DD'));\n   IF v_age_months < 600 THEN\n      :NEW.NET_WORTH_MILLIONS := :NEW.NET_WORTH_MILLIONS * 0.9;\n   ELSIF v_age_months > 960 THEN\n      :NEW.NET_WORTH_MILLIONS := :NEW.NET_WORTH_MILLIONS * 1.1;\n   END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (10, 'Young Artist', 2010, 10, 'United States')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (11, 'Middle Aged Star', 1985, 50, 'United Kingdom')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (12, 'Senior Legend', 1940, 100, 'France')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (13, 'Teen Prodigy', 2008, 5, 'Canada')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (14, 'Veteran Singer', 1935, 80, 'Italy')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_singer_age_calc on the SINGER table. Calculate the singer's age in months from their BIRTH_YEAR. If age < 600 months (50 years), reduce NET_WORTH_MILLIONS by 10%. If age > 960 months (80 years), increase NET_WORTH_MILLIONS by 10%.",
    "natural_language": "Formulate a BEFORE INSERT row-level trigger designated as trg_singer_age_calc for the SINGER table. The procedure shall compute the age of the singer in months based on the provided BIRTH_YEAR. Should the calculated age be less than 600 months (equating to 50 years), a reduction of 10% is to be applied to the NET_WORTH_MILLIONS field. Conversely, if the age exceeds 960 months (equating to 80 years), an increase of 10% is to be applied to the NET_WORTH_MILLIONS field.",
    "id": 72
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_position_update that is defined to fire automatically after an update operation on the SONG table, but only when the specific column HIGHEST_POSITION is modified, and it executes once for each row affected by the update. The trigger's logic begins by checking a condition: if the new value of the HIGHEST_POSITION column for the updated row, referenced as :NEW.HIGHEST_POSITION, is exactly equal to 1. When this condition is true, the trigger performs an update on the SINGER table. This update operation increases the NET_WORTH_MILLIONS column for the singer associated with the updated song by 5 percent, which is calculated as the current NET_WORTH_MILLIONS value multiplied by 1.05. The update targets the row in the SINGER table where the SINGER_ID column matches the value of the :NEW.SINGER_ID from the updated SONG row. If the condition is false, meaning the new HIGHEST_POSITION is not 1, the trigger takes no further action.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_position_update\nAFTER UPDATE OF HIGHEST_POSITION ON SONG\nFOR EACH ROW\nBEGIN\n   IF :NEW.HIGHEST_POSITION = 1 THEN\n      UPDATE SINGER SET NET_WORTH_MILLIONS = NET_WORTH_MILLIONS * 1.05 WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE SONG_ID = 3",
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE SONG_ID = 4",
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE SONG_ID = 5",
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE SINGER_ID = 2",
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE TITLE = 'Yeah'"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_song_position_update on the SONG table, firing only when the HIGHEST_POSITION column is updated. If the new HIGHEST_POSITION is 1, update the corresponding singer's NET_WORTH_MILLIONS in the SINGER table by increasing it by 5%.",
    "natural_language": "Please implement an AFTER UPDATE row-level trigger designated as trg_song_position_update on the SONG table. This trigger should be configured to execute exclusively when modifications are made to the HIGHEST_POSITION column. In the event that the newly assigned value for HIGHEST_POSITION is 1, it is required to update the NET_WORTH_MILLIONS field for the associated singer in the SINGER table, applying an increase of five percent.",
    "id": 73
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_problem_closed_date that is executed before an update operation on the PROBLEM_LOG table for each row being updated. The trigger checks if the new value of the PROBLEM_STATUS_CODE column in the row being updated is equal to the string 'Solved'. If this condition is true, the trigger sets the new value of the LOG_ENTRY_DATE column in the same row to the current timestamp formatted as a string in the 'YYYY-MM-DD HH24:MI:SS' format. The trigger uses the TO_CHAR function to convert the CURRENT_TIMESTAMP, which represents the current date and time, into a string with the specified format. The trigger does not perform any operations if the PROBLEM_STATUS_CODE is not 'Solved'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_problem_closed_date\nBEFORE UPDATE ON PROBLEM_LOG\nFOR EACH ROW\nBEGIN\n  IF :NEW.PROBLEM_STATUS_CODE = 'Solved' THEN\n    :NEW.LOG_ENTRY_DATE := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');\n  END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved', LOG_ENTRY_DESCRIPTION = 'Fixed' WHERE PROBLEM_ID = 11",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved', OTHER_LOG_DETAILS = 'Resolved' WHERE ASSIGNED_TO_STAFF_ID = 12",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_CATEGORY_CODE = 'Middleware'",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved', LOG_ENTRY_FIX = 'Patch applied' WHERE PROBLEM_LOG_ID = 3"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_update_problem_closed_date on the PROBLEM_LOG table. If the new PROBLEM_STATUS_CODE is 'Solved', set the LOG_ENTRY_DATE to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Set up a BEFORE UPDATE row-level trigger called trg_update_problem_closed_date on the PROBLEM_LOG table. When the new PROBLEM_STATUS_CODE is 'Solved', assign the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format to LOG_ENTRY_DATE.",
    "id": 74
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_trim_problem_description that is executed before an INSERT or UPDATE operation on the PROBLEMS table. This trigger operates on each row affected by the INSERT or UPDATE statement. The trigger modifies the value of the PROBLEM_DESCRIPTION column in the affected row by truncating its content to a maximum length of 100 characters. This is achieved by using the SUBSTR function, which extracts a substring from the PROBLEM_DESCRIPTION column starting at the first character and extending up to the 100th character. The :NEW keyword is used to reference the new value of the PROBLEM_DESCRIPTION column in the row being inserted or updated, ensuring that the modification is applied to the incoming data before it is committed to the table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_trim_problem_description\nBEFORE INSERT OR UPDATE ON PROBLEMS\nFOR EACH ROW\nBEGIN\n  :NEW.PROBLEM_DESCRIPTION := SUBSTR(:NEW.PROBLEM_DESCRIPTION, 1, 100);\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (1, 4, 2, '1978-06-26 19:10:17', 'This is a very long problem description that should be trimmed by the trigger to exactly 100 characters.')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (2, 8, 10, '1988-11-07 16:09:31', 'Short description.')",
      "UPDATE PROBLEMS SET PROBLEM_DESCRIPTION = 'Another extremely long problem description that will definitely exceed the 100 character limit and get trimmed.' WHERE PROBLEM_ID = 1",
      "UPDATE PROBLEMS SET PROBLEM_DESCRIPTION = 'A slightly longer but still within limits description for problem 2.' WHERE PROBLEM_ID = 2",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (3, 1, 1, '1995-05-14 08:32:56', 'This description is exactly one hundred characters long, so it should not be trimmed at all. This is a test.')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_trim_problem_description on the PROBLEMS table. Trim the PROBLEM_DESCRIPTION column value to a maximum of 100 characters.",
    "natural_language": "Hey, can you set up a trigger called trg_trim_problem_description for the PROBLEMS table? It should fire before any new row is added or an existing one is updated. What it needs to do is chop down whatever's in the PROBLEM_DESCRIPTION field so it's no more than 100 characters long.",
    "id": 75
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_set_default_category` that is configured to execute `BEFORE` an `INSERT` operation occurs on the `PROBLEM_LOG` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being inserted into the `PROBLEM_LOG` table. The trigger's execution block `BEGIN` initiates a conditional statement `IF` that evaluates whether the value of the `PROBLEM_CATEGORY_CODE` column in the new row being inserted (represented by `:NEW.PROBLEM_CATEGORY_CODE`) `IS NULL`. If this condition evaluates to `TRUE`, indicating that no value has been explicitly provided for the `PROBLEM_CATEGORY_CODE` column for the current row being inserted, then the trigger proceeds to assign the string literal `'General'` to the `PROBLEM_CATEGORY_CODE` column of the new row (represented by `:NEW.PROBLEM_CATEGORY_CODE`). This assignment effectively sets a default value for the `PROBLEM_CATEGORY_CODE` column if it is left unspecified during an insert operation. The conditional statement then concludes with `END IF;`, and the trigger's execution block concludes with `END;`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_set_default_category\nBEFORE INSERT ON PROBLEM_LOG\nFOR EACH ROW\nBEGIN\n  IF :NEW.PROBLEM_CATEGORY_CODE IS NULL THEN\n    :NEW.PROBLEM_CATEGORY_CODE := 'General';\n  END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE, LOG_ENTRY_DESCRIPTION, LOG_ENTRY_FIX, OTHER_LOG_DETAILS) VALUES (4, 11, 1, 'Reported', '2023-10-01 10:00:00', 'Initial log entry', 'Fix pending', 'Details pending')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE, LOG_ENTRY_DESCRIPTION, LOG_ENTRY_FIX, OTHER_LOG_DETAILS) VALUES (5, 12, 8, 'Reported', '2023-10-02 11:00:00', 'Second log entry', 'Fix pending', 'Details pending')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE, LOG_ENTRY_DESCRIPTION, LOG_ENTRY_FIX, OTHER_LOG_DETAILS) VALUES (6, 11, 11, 'Reported', '2023-10-03 12:00:00', 'Third log entry', 'Fix pending', 'Details pending')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE, LOG_ENTRY_DESCRIPTION, LOG_ENTRY_FIX, OTHER_LOG_DETAILS) VALUES (7, 12, 1, 'Reported', '2023-10-04 13:00:00', 'Fourth log entry', 'Fix pending', 'Details pending')",
      "INSERT INTO PROBLEM_LOG (PROBLEM_LOG_ID, ASSIGNED_TO_STAFF_ID, PROBLEM_ID, PROBLEM_STATUS_CODE, LOG_ENTRY_DATE, LOG_ENTRY_DESCRIPTION, LOG_ENTRY_FIX, OTHER_LOG_DETAILS) VALUES (8, 11, 8, 'Reported', '2023-10-05 14:00:00', 'Fifth log entry', 'Fix pending', 'Details pending')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_set_default_category on the PROBLEM_LOG table. If the new PROBLEM_CATEGORY_CODE is null, set it to 'General'.",
    "natural_language": "Set up a trigger on the PROBLEM_LOG table that runs before adding any new entries. The trigger should be called something like trg_set_default_category. Its job is to handle cases where the problem category isn't specifiedif that field is left empty or seems missing, just fill it in with a default value, maybe something broad like 'General'.",
    "id": 76
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_log_entry_fix` that is configured to execute automatically `BEFORE` any `UPDATE` operation is performed on the `PROBLEM_LOG` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row that is being updated within the `PROBLEM_LOG` table. The trigger's primary purpose is to enforce a maximum length constraint on the `LOG_ENTRY_FIX` column during an update operation. Specifically, for each row being updated, the trigger first evaluates a conditional statement: `IF LENGTH(:NEW.LOG_ENTRY_FIX) > 50 THEN`. This condition checks the length of the new value proposed for the `LOG_ENTRY_FIX` column (referenced as `:NEW.LOG_ENTRY_FIX`). The `LENGTH` function is used to determine the number of characters in the string value of `:NEW.LOG_ENTRY_FIX`. If the length of this new value is found to be strictly greater than `50` characters, then the code within the `IF` block is executed. Inside this `IF` block, the statement `:NEW.LOG_ENTRY_FIX := SUBSTR(:NEW.LOG_ENTRY_FIX, 1, 50);` is executed. This statement assigns a modified value back to the `:NEW.LOG_ENTRY_FIX` column. The `SUBSTR` function is used to extract a substring from the original new value of `LOG_ENTRY_FIX`. It takes three arguments: the source string (`:NEW.LOG_ENTRY_FIX`), the starting position (`1`, indicating the first character), and the length of the substring to extract (`50`). This effectively truncates the `LOG_ENTRY_FIX` value to its first 50 characters if its original length exceeded 50. If the initial `IF` condition evaluates to `FALSE` (i.e., the length of `:NEW.LOG_ENTRY_FIX` is `50` or less), then no action is taken on the `LOG_ENTRY_FIX` column for that particular row, and its new value remains as originally provided in the `UPDATE` statement. The trigger concludes its execution after evaluating and potentially modifying the `LOG_ENTRY_FIX` column for the current row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_log_entry_fix\nBEFORE UPDATE ON PROBLEM_LOG\nFOR EACH ROW\nBEGIN\n  IF LENGTH(:NEW.LOG_ENTRY_FIX) > 50 THEN\n    :NEW.LOG_ENTRY_FIX := SUBSTR(:NEW.LOG_ENTRY_FIX, 1, 50);\n  END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET LOG_ENTRY_FIX = 'This is a very long log entry fix that exceeds fifty characters' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET LOG_ENTRY_FIX = 'Another long log entry fix that needs to be truncated' WHERE PROBLEM_LOG_ID = 2",
      "UPDATE PROBLEM_LOG SET LOG_ENTRY_FIX = 'Yet another example of a log entry fix that is too long' WHERE PROBLEM_LOG_ID = 3",
      "UPDATE PROBLEM_LOG SET LOG_ENTRY_FIX = 'This log entry fix is also too long and should be cut' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET LOG_ENTRY_FIX = 'Final example of a log entry fix that exceeds the limit' WHERE PROBLEM_LOG_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_update_log_entry_fix on the PROBLEM_LOG table. If the new LOG_ENTRY_FIX length exceeds 50 characters, truncate it to 50 characters.",
    "natural_language": "Please construct a BEFORE UPDATE FOR EACH ROW trigger designated as trg_update_log_entry_fix on the PROBLEM_LOG table. The trigger's function is to verify the length of the new LOG_ENTRY_FIX value. Should its length surpass 50 characters, the value must be truncated to a maximum of 50 characters.",
    "id": 77
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_set_reported_date that fires before any row is inserted into the PROBLEMS table, and for each new row, checks if the column DATE_PROBLEM_REPORTED is null; if this condition is true, the trigger assigns a value to the :NEW.DATE_PROBLEM_REPORTED column by calling the CURRENT_TIMESTAMP function to get the current date and time from the system, then uses the TO_CHAR function with the format model 'YYYY-MM-DD HH24:MI:SS' to convert that timestamp into a string representation where YYYY is the four-digit year, MM is the two-digit month, DD is the two-digit day, HH24 is the two-digit hour in 24-hour format, MI is the two-digit minute, and SS is the two-digit second.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_set_reported_date\nBEFORE INSERT ON PROBLEMS\nFOR EACH ROW\nBEGIN\n  IF :NEW.DATE_PROBLEM_REPORTED IS NULL THEN\n    :NEW.DATE_PROBLEM_REPORTED := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');\n  END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (4, 5, 6, 7, 'Problem description 1', 'Details 1')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (5, 6, 7, 8, 'Problem description 2', 'Details 2')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (6, 7, 8, 9, 'Problem description 3', 'Details 3')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (7, 8, 9, 10, 'Problem description 4', 'Details 4')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (8, 9, 10, 11, 'Problem description 5', 'Details 5')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_set_reported_date on the PROBLEMS table. If the new DATE_PROBLEM_REPORTED is null, set it to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Please implement a BEFORE INSERT FOR EACH ROW trigger, designated as trg_set_reported_date, on the PROBLEMS table. This trigger should assign the current timestamp, formatted as 'YYYY-MM-DD HH24:MI:SS', to the new DATE_PROBLEM_REPORTED column whenever its value is found to be null.",
    "id": 78
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_wedding that is defined to execute automatically after a new row is inserted into the WEDDING table, and it executes once for each inserted row, performing two distinct insert operations into the PEOPLE table; for the first insert, it uses the value from the newly inserted WEDDING row's MALE_ID column for the PEOPLE_ID column, sets the NAME column to the literal string 'Unknown', sets the COUNTRY column to the literal string 'Unknown', sets the IS_MALE column to the literal string 'T', and sets the AGE column to the literal number 0; for the second insert, it uses the value from the newly inserted WEDDING row's FEMALE_ID column for the PEOPLE_ID column, sets the NAME column to the literal string 'Unknown', sets the COUNTRY column to the literal string 'Unknown', sets the IS_MALE column to the literal string 'F', and sets the AGE column to the literal number 0.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_wedding\nAFTER INSERT ON WEDDING\nFOR EACH ROW\nBEGIN\n  INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n  VALUES (:NEW.MALE_ID, 'Unknown', 'Unknown', 'T', 0);\n  INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n  VALUES (:NEW.FEMALE_ID, 'Unknown', 'Unknown', 'F', 0);\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (1, 100, 101, 2024)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (2, 200, 201, 2023)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (3, 300, 301, 2025)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (4, 400, 401, 2022)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (5, 500, 501, 2021)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_wedding on the WEDDING table. For each new row, insert two records into the PEOPLE table: one using the MALE_ID with IS_MALE='T', and another using the FEMALE_ID with IS_MALE='F'. Set NAME and COUNTRY to 'Unknown' and AGE to 0 for both.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger designated as trg_insert_wedding on the WEDDING table. For every newly inserted row, it is required to insert two distinct records into the PEOPLE table. The first record shall utilize the MALE_ID value with the IS_MALE attribute set to 'T', and the second shall utilize the FEMALE_ID value with IS_MALE set to 'F'. For both records, the NAME and COUNTRY fields should be assigned the value 'Unknown', and the AGE field should be initialized to 0.",
    "id": 79
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_church` that is activated after a `DELETE` operation is performed on the `CHURCH` table. This trigger is configured to execute once for each row that is deleted from the `CHURCH` table. Upon activation, for each row that has been deleted from the `CHURCH` table, the trigger performs a `DELETE` operation on the `WEDDING` table. The `DELETE` operation on the `WEDDING` table targets all rows where the value in the `CHURCH_ID` column of the `WEDDING` table is equal to the value of the `CHURCH_ID` column from the row that was just deleted from the `CHURCH` table. The `:OLD.CHURCH_ID` refers to the value of the `CHURCH_ID` column in the row of the `CHURCH` table *before* it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_church\nAFTER DELETE ON CHURCH\nFOR EACH ROW\nBEGIN\n  DELETE FROM WEDDING WHERE CHURCH_ID = :OLD.CHURCH_ID;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "DELETE FROM CHURCH WHERE CHURCH_ID = 1",
      "DELETE FROM CHURCH WHERE CHURCH_ID = 2",
      "DELETE FROM CHURCH WHERE CHURCH_ID = 3",
      "DELETE FROM CHURCH WHERE CHURCH_ID = 4",
      "DELETE FROM CHURCH WHERE CHURCH_ID = 5"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_delete_church on the CHURCH table. For each deleted row, delete all rows from the WEDDING table where CHURCH_ID equals the old CHURCH_ID.",
    "natural_language": "Hey, set up a trigger called trg_delete_church on the CHURCH table that fires after a row gets deleted. Every time you zap a church record, it should also clean out any weddings in the WEDDING table that were linked to that church's old ID.",
    "id": 80
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_church that is defined to execute automatically after a new row is successfully inserted into the CHURCH table, and it executes once for each inserted row. The trigger performs a single INSERT operation into a separate table named WEDDING. The INSERT statement specifies four columns for the WEDDING table: CHURCH_ID, MALE_ID, FEMALE_ID, and YEAR. For the CHURCH_ID column, the trigger uses the value from the newly inserted CHURCH row, specifically the CHURCH_ID column value, which is accessed via the :NEW.CHURCH_ID bind variable. For the MALE_ID and FEMALE_ID columns, the trigger inserts the literal integer value 0 into both. For the YEAR column, the trigger calculates the value by calling the EXTRACT function with the 'YEAR' date part on the result of the CURRENT_DATE function, which returns the current date from the system, thereby inserting the four-digit year component of the current date.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_church\nAFTER INSERT ON CHURCH\nFOR EACH ROW\nBEGIN\n  INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n  VALUES (:NEW.CHURCH_ID, 0, 0, EXTRACT(YEAR FROM CURRENT_DATE));\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (4, 'New Church', 'John Doe', 1840, 'Old Church')",
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (5, 'Another Church', 'Jane Smith', 1850, 'Another Old Church')",
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (6, 'Modern Church', 'Alice Johnson', 1860, 'Modern Old Church')",
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (7, 'Future Church', 'Bob Brown', 1870, 'Future Old Church')",
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (8, 'Historic Church', 'Charlie Green', 1880, 'Historic Old Church')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_church on the CHURCH table. For each new row, insert a record into the WEDDING table. Set CHURCH_ID to :NEW.CHURCH_ID, set both MALE_ID and FEMALE_ID to 0, and set YEAR to the current year extracted from the system date.",
    "natural_language": "How can I create an AFTER INSERT row-level trigger named trg_insert_church on the CHURCH table that, for each new row, inserts a record into the WEDDING table, setting CHURCH_ID to the new CHURCH_ID, both MALE_ID and FEMALE_ID to 0, and YEAR to the current year from the system date?",
    "id": 81
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_people_age` that is activated after an `UPDATE` operation is performed on the `PEOPLE` table. This trigger is a row-level trigger, meaning it executes once for each row that is updated in the `PEOPLE` table. Upon activation, for each updated row, the trigger performs a `DELETE` operation on the `WEDDING` table. The `DELETE` operation targets rows in the `WEDDING` table where the value in the `MALE_ID` column is equal to the `PEOPLE_ID` value of the row *before* the update occurred (referenced as `:OLD.PEOPLE_ID`), or where the value in the `FEMALE_ID` column is equal to the `PEOPLE_ID` value of the row *before* the update occurred (also referenced as `:OLD.PEOPLE_ID`). This effectively removes any wedding records associated with the `PEOPLE_ID` of the person whose record was updated, regardless of whether they were listed as the male or female participant in the wedding.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_people_age\nAFTER UPDATE ON PEOPLE\nFOR EACH ROW\nBEGIN\n  DELETE FROM WEDDING WHERE MALE_ID = :OLD.PEOPLE_ID OR FEMALE_ID = :OLD.PEOPLE_ID;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "UPDATE PEOPLE SET AGE = 35 WHERE PEOPLE_ID = 1",
      "UPDATE PEOPLE SET AGE = 33 WHERE PEOPLE_ID = 2",
      "UPDATE PEOPLE SET AGE = 31 WHERE PEOPLE_ID = 3",
      "UPDATE PEOPLE SET AGE = 40 WHERE PEOPLE_ID = 4",
      "UPDATE PEOPLE SET AGE = 25 WHERE PEOPLE_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_people_age on the PEOPLE table. For each updated row, delete all rows from the WEDDING table where the :OLD.PEOPLE_ID matches either the MALE_ID or FEMALE_ID column.",
    "natural_language": "Make an AFTER UPDATE trigger trg_update_people_age on PEOPLE. For each updated row, delete from WEDDING where the old PEOPLE_ID equals MALE_ID or FEMALE_ID.",
    "id": 82
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_people that is executed automatically after a new row is inserted into the PEOPLE table. This trigger operates for each row that is inserted. Within the trigger's body, an INSERT operation is performed on the CHURCH table, adding a new row with specific values. The CHURCH_ID column is set to the value of the PEOPLE_ID column from the newly inserted row in the PEOPLE table, accessed using the :NEW pseudorecord. The NAME column is assigned the string 'New Church'. The ORGANIZED_BY column is given the value 'Unknown'. The OPEN_DATE column is set to the current year, extracted from the system's current date using the EXTRACT function with the YEAR parameter. The CONTINUATION_OF column is assigned the string 'None'. This trigger ensures that every time a new person is added to the PEOPLE table, a corresponding entry is automatically created in the CHURCH table with predefined values.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_people\nAFTER INSERT ON PEOPLE\nFOR EACH ROW\nBEGIN\n  INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n  VALUES (:NEW.PEOPLE_ID, 'New Church', 'Unknown', EXTRACT(YEAR FROM CURRENT_DATE), 'None');\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (10, 'John Doe', 'USA', 'T', 30)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (11, 'Jane Smith', 'Canada', 'F', 25)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (12, 'Peter Jones', 'UK', 'T', 45)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (13, 'Alice Brown', 'Australia', 'F', 38)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (14, 'Bob White', 'Germany', 'T', 50)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_people on the PEOPLE table. For each new row, insert a record into the CHURCH table. Set CHURCH_ID to :NEW.PEOPLE_ID, NAME to 'New Church', ORGANIZED_BY to 'Unknown', OPEN_DATE to the current year, and CONTINUATION_OF to 'None'.",
    "natural_language": "Construct a detailed AFTER INSERT row-level trigger, which should be named trg_insert_people, specifically for the PEOPLE table. For every single new row that is successfully added, you must meticulously insert a corresponding new record directly into the CHURCH table. In this new church record, carefully assign the CHURCH_ID to precisely match the :NEW.PEOPLE_ID value, set the NAME field to the literal string 'New Church', define the ORGANIZED_BY field as 'Unknown', populate the OPEN_DATE with the exact current year, and finally, ensure the CONTINUATION_OF field is explicitly set to 'None'.",
    "id": 83
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_club_ranking_update` that is activated `AFTER` any `UPDATE` operation is performed on any row within the `CLUB` table. This trigger is configured to execute `FOR EACH ROW` that is affected by the `UPDATE` statement. Upon activation, the trigger first declares a local PL/SQL variable named `v_member_count` of data type `NUMBER` to temporarily store a count value. Subsequently, it executes a `SELECT` statement to `COUNT` the total number of rows in the `MEMBER` table where the `AGE` column has a value `GREATER THAN` 18. The result of this count operation is then stored into the `v_member_count` variable. Following this, a conditional `IF` statement evaluates whether the value stored in `v_member_count` is `GREATER THAN` 5. If this condition evaluates to `TRUE`, the trigger proceeds to execute a `DELETE` statement, removing all rows from the `CLUB_LEADER` table where the `CLUB_ID` column matches the `CLUB_ID` value of the row that was just updated in the `CLUB` table (referenced as `:OLD.CLUB_ID`). Regardless of whether the `IF` condition was met or not, the trigger then executes an `INSERT` statement. This `INSERT` statement adds a new row into the `MEMBER` table, populating the `MEMBER_ID` column with the literal value `9999`, the `NAME` column with the literal string `'System'`, the `NATIONALITY` column with the literal string `'Auto'`, and the `AGE` column with the literal value `30`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_club_ranking_update\nAFTER UPDATE ON CLUB\nFOR EACH ROW\nDECLARE\n  v_member_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_member_count FROM MEMBER WHERE AGE > 18;\n  IF v_member_count > 5 THEN\n    DELETE FROM CLUB_LEADER WHERE CLUB_ID = :OLD.CLUB_ID;\n  END IF;\n  INSERT INTO MEMBER (MEMBER_ID, NAME, NATIONALITY, AGE) VALUES (9999, 'System', 'Auto', 30);\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE CLUB SET OVERALL_RANKING = 10 WHERE CLUB_ID = 1",
      "UPDATE CLUB SET CLUB_NAME = 'Updated Houston' WHERE CLUB_ID = 3",
      "UPDATE CLUB SET TEAM_LEADER = 'New Leader' WHERE CLUB_ID = 4",
      "UPDATE CLUB SET OVERALL_RANKING = 60, TEAM_LEADER = 'Updated Leader' WHERE CLUB_ID = 1",
      "UPDATE CLUB SET OVERALL_RANKING = OVERALL_RANKING + 1 WHERE CLUB_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_club_ranking_update on the CLUB table. Declare a variable v_member_count. Count members older than 18 from the MEMBER table into v_member_count. If the count is greater than 5, delete rows from CLUB_LEADER where CLUB_ID equals :OLD.CLUB_ID. Then, insert a new row into the MEMBER table with MEMBER_ID=9999, NAME='System', NATIONALITY='Auto', and AGE=30.",
    "natural_language": "Construct an AFTER UPDATE row-level trigger, which should be named trg_club_ranking_update, specifically for the CLUB table. Begin by declaring a variable called v_member_count. Subsequently, perform a count of all members who are older than 18 years from the detailed MEMBER table, storing the precise result into the v_member_count variable. If this carefully obtained count is found to be greater than 5, then proceed to delete all relevant rows from the CLUB_LEADER table where the CLUB_ID perfectly matches the :OLD.CLUB_ID value. Following that, insert a brand new row into the comprehensive MEMBER table, meticulously setting the MEMBER_ID to 9999, the NAME to 'System', the NATIONALITY to 'Auto', and the AGE to 30.",
    "id": 84
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_leader_year_validation` that is activated `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `CLUB_LEADER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row affected by the `INSERT` or `UPDATE` statement.\n\nUpon activation, the trigger first declares a local numeric variable named `v_max_ranking` to temporarily store a maximum ranking value.\n\nInside the trigger's execution block, the first operation is a `SELECT` statement that retrieves the maximum value from the `OVERALL_RANKING` column of the `CLUB` table. This maximum value is then stored into the `v_max_ranking` variable.\n\nFollowing this, a conditional `IF` statement evaluates a condition: it checks if the value in the `YEAR_JOIN` column of the `NEW` row (the row being inserted or updated) is greater than the string literal `'2019'`.\n\nIf the condition `:NEW.YEAR_JOIN > '2019'` evaluates to `TRUE`, an `UPDATE` statement is executed. This `UPDATE` statement modifies the `MEMBER` table by incrementing the value in the `AGE` column by `1`. This update is applied only to the row(s) in the `MEMBER` table where the `MEMBER_ID` column matches the value in the `MEMBER_ID` column of the `NEW` row (`:NEW.MEMBER_ID`).\n\nIf the condition `:NEW.YEAR_JOIN > '2019'` evaluates to `FALSE` (meaning `YEAR_JOIN` is less than or equal to `'2019'`), the `ELSE` block is executed. Within the `ELSE` block, another `UPDATE` statement is performed. This `UPDATE` statement modifies the `MEMBER` table by decrementing the value in the `AGE` column by `1`. This update is also applied only to the row(s) in the `MEMBER` table where the `MEMBER_ID` column matches the value in the `MEMBER_ID` column of the `NEW` row (`:NEW.MEMBER_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_leader_year_validation\nBEFORE INSERT OR UPDATE ON CLUB_LEADER\nFOR EACH ROW\nDECLARE\n  v_max_ranking NUMBER;\nBEGIN\n  SELECT MAX(OVERALL_RANKING) INTO v_max_ranking FROM CLUB;\n  IF :NEW.YEAR_JOIN > '2019' THEN\n    UPDATE MEMBER SET AGE = AGE + 1 WHERE MEMBER_ID = :NEW.MEMBER_ID;\n  ELSE\n    UPDATE MEMBER SET AGE = AGE - 1 WHERE MEMBER_ID = :NEW.MEMBER_ID;\n  END IF;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID, YEAR_JOIN) VALUES (2, 1987, '2020')",
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID, YEAR_JOIN) VALUES (5, 1988, '2018')",
      "UPDATE CLUB_LEADER SET YEAR_JOIN = '2021' WHERE CLUB_ID = 1 AND MEMBER_ID = 1984",
      "UPDATE CLUB_LEADER SET YEAR_JOIN = '2016' WHERE CLUB_ID = 8 AND MEMBER_ID = 1985",
      "INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID, YEAR_JOIN) VALUES (9, 1990, '2023')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_leader_year_validation on the CLUB_LEADER table. Declare a variable v_max_ranking and store the maximum OVERALL_RANKING from the CLUB table. If :NEW.YEAR_JOIN > '2019', update the MEMBER table to increment AGE by 1 for the row where MEMBER_ID = :NEW.MEMBER_ID. Otherwise, update the MEMBER table to decrement AGE by 1 for the same row.",
    "natural_language": "Create trigger trg_leader_year_validation on CLUB_LEADER. Set v_max_ranking as max CLUB.OVERALL_RANKING. If :NEW.YEAR_JOIN > '2019', increment MEMBER.AGE by 1 for MEMBER_ID = :NEW.MEMBER_ID. Else, decrement AGE by 1.",
    "id": 85
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_supplier that is executed automatically after a delete operation is performed on the SUPPLIERS table. This trigger operates for each row that is deleted from the SUPPLIERS table. Within the trigger's execution block, it performs a delete operation on the PRODUCT_SUPPLIERS table, specifically targeting rows where the SUPPLIER_ID column matches the value of the SUPPLIER_ID from the deleted row in the SUPPLIERS table, accessed using the :OLD prefix to refer to the old value of the SUPPLIER_ID before the deletion. The purpose of this trigger is to ensure that any records in the PRODUCT_SUPPLIERS table that are associated with the deleted supplier are also removed, maintaining referential integrity between the SUPPLIERS and PRODUCT_SUPPLIERS tables.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_supplier\nAFTER DELETE ON SUPPLIERS\nFOR EACH ROW\nBEGIN\n  DELETE FROM PRODUCT_SUPPLIERS\n  WHERE SUPPLIER_ID = :OLD.SUPPLIER_ID;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "STAFF"
    ],
    "call_sqls": [
      "DELETE FROM SUPPLIERS WHERE SUPPLIER_ID = 2",
      "DELETE FROM SUPPLIERS WHERE SUPPLIER_ID = 3",
      "DELETE FROM SUPPLIERS WHERE SUPPLIER_ID = 4"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_supplier on the SUPPLIERS table. For each deleted row, delete rows from the PRODUCT_SUPPLIERS table where SUPPLIER_ID matches the :OLD.SUPPLIER_ID.",
    "natural_language": "Create trigger trg_delete_supplier on SUPPLIERS to delete matching PRODUCT_SUPPLIERS rows after a supplier is deleted.",
    "id": 86
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_product_supplier that is defined to fire automatically after a new row is inserted into the PRODUCT_SUPPLIERS table, executing once for each inserted row. The trigger performs a single INSERT operation into a separate table named SUPPLIERS. This INSERT statement specifies three columns for the SUPPLIERS table: SUPPLIER_ID, SUPPLIER_NAME, and SUPPLIER_PHONE. The values inserted are derived from the newly inserted row in the PRODUCT_SUPPLIERS table and from literal constants. Specifically, the value for the SUPPLIER_ID column is taken directly from the :NEW.SUPPLIER_ID value of the triggering row, while the SUPPLIER_NAME column is populated with the constant string literal 'New Supplier', and the SUPPLIER_PHONE column is populated with the constant string literal '000-000-0000'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_product_supplier\nAFTER INSERT ON PRODUCT_SUPPLIERS\nFOR EACH ROW\nBEGIN\n  INSERT INTO SUPPLIERS (SUPPLIER_ID, SUPPLIER_NAME, SUPPLIER_PHONE)\n  VALUES (:NEW.SUPPLIER_ID, 'New Supplier', '000-000-0000');\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PRODUCT_SUPPLIERS (PRODUCT_ID, SUPPLIER_ID, DATE_SUPPLIED_FROM, DATE_SUPPLIED_TO, TOTAL_AMOUNT_PURCHASED, TOTAL_VALUE_PURCHASED) VALUES (1, 101, '2023-01-01', '2023-01-31', '1000.00', 500)",
      "INSERT INTO PRODUCT_SUPPLIERS (PRODUCT_ID, SUPPLIER_ID, DATE_SUPPLIED_FROM, DATE_SUPPLIED_TO, TOTAL_AMOUNT_PURCHASED, TOTAL_VALUE_PURCHASED) VALUES (2, 102, '2023-02-01', '2023-02-28', '2000.00', 1000)",
      "INSERT INTO PRODUCT_SUPPLIERS (PRODUCT_ID, SUPPLIER_ID, DATE_SUPPLIED_FROM, DATE_SUPPLIED_TO, TOTAL_AMOUNT_PURCHASED, TOTAL_VALUE_PURCHASED) VALUES (3, 103, '2023-03-01', '2023-03-31', '1500.00', 750)",
      "INSERT INTO PRODUCT_SUPPLIERS (PRODUCT_ID, SUPPLIER_ID, DATE_SUPPLIED_FROM, DATE_SUPPLIED_TO, TOTAL_AMOUNT_PURCHASED, TOTAL_VALUE_PURCHASED) VALUES (4, 104, '2023-04-01', '2023-04-30', '2500.00', 1250)",
      "INSERT INTO PRODUCT_SUPPLIERS (PRODUCT_ID, SUPPLIER_ID, DATE_SUPPLIED_FROM, DATE_SUPPLIED_TO, TOTAL_AMOUNT_PURCHASED, TOTAL_VALUE_PURCHASED) VALUES (5, 105, '2023-05-01', '2023-05-31', '3000.00', 1500)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_product_supplier on the PRODUCT_SUPPLIERS table. For each new row, insert a record into the SUPPLIERS table. Set SUPPLIER_ID to :NEW.SUPPLIER_ID, SUPPLIER_NAME to 'New Supplier', and SUPPLIER_PHONE to '000-000-0000'.",
    "natural_language": "Create a row-level trigger called trg_insert_product_supplier that fires AFTER INSERT on the PRODUCT_SUPPLIERS table. For each inserted row, have it insert a corresponding record into the SUPPLIERS table. Set the new record's SUPPLIER_ID to :NEW.SUPPLIER_ID, SUPPLIER_NAME to 'New Supplier', and SUPPLIER_PHONE to '000-000-0000'.",
    "id": 87
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_staff` that is activated `AFTER` an `INSERT` operation is performed on the `STAFF` table. This trigger is defined to execute `FOR EACH ROW` that is inserted into the `STAFF` table, meaning its logic will be applied individually for every new record. Upon activation, the trigger executes a single `INSERT` statement. This `INSERT` statement targets the `CUSTOMERS` table. It populates three specific columns within the `CUSTOMERS` table: `CUSTOMER_ID`, `CUSTOMER_NAME`, and `CUSTOMER_PHONE`. The value for the `CUSTOMER_ID` column is derived from the `STAFF_ID` column of the newly inserted row in the `STAFF` table, referenced using the `:NEW.STAFF_ID` pseudorecord. The value for the `CUSTOMER_NAME` column is derived from the `STAFF_NAME` column of the newly inserted row in the `STAFF` table, referenced using the `:NEW.STAFF_NAME` pseudorecord. The value for the `CUSTOMER_PHONE` column is a static string literal, specifically `'123-456-7890'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_staff\nAFTER INSERT ON STAFF\nFOR EACH ROW\nBEGIN\n  INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_NAME, CUSTOMER_PHONE)\n  VALUES (:NEW.STAFF_ID, :NEW.STAFF_NAME, '123-456-7890');\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO STAFF (STAFF_ID, STAFF_GENDER, STAFF_NAME) VALUES (101, '1', 'John Smith')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_GENDER, STAFF_NAME) VALUES (102, '1', 'Jane Doe')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_GENDER, STAFF_NAME) VALUES (103, '2', 'Robert Johnson')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_GENDER, STAFF_NAME) VALUES (104, '1', 'Emily Davis')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_GENDER, STAFF_NAME) VALUES (105, '2', 'Michael Wilson')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_staff on the STAFF table. For each new row, insert a record into the CUSTOMERS table. Set CUSTOMER_ID to :NEW.STAFF_ID, CUSTOMER_NAME to :NEW.STAFF_NAME, and CUSTOMER_PHONE to '123-456-7890'.",
    "natural_language": "Alright, so we need a trigger that fires off after a new person gets added to the STAFF table. Let's call it trg_insert_staff. Every time a new staff member pops in, we gotta also add them as a customer. Just copy their STAFF_ID over to CUSTOMER_ID, use their STAFF_NAME for the CUSTOMER_NAME, and for the phone number, just hardcode it to '123-456-7890' for now.",
    "id": 88
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_dog_breed_size that is executed before an insert or update operation on the DOGS table for each row. This trigger declares two local variables, v_breed_count and v_size_count, both of type NUMBER, to store the count of records matching specific criteria. It performs a SELECT operation to count the number of records in the BREEDS table where the BREED_CODE column matches the value of the :NEW.BREED_CODE, which is the breed code of the new or updated row in the DOGS table. The result is stored in v_breed_count. Similarly, it performs another SELECT operation to count the number of records in the SIZES table where the SIZE_CODE column matches the value of the :NEW.SIZE_CODE, which is the size code of the new or updated row in the DOGS table, storing the result in v_size_count. The trigger then evaluates conditional statements: if v_breed_count equals zero, it raises an application error with code -20001 and the message 'Breed code does not exist.'; if v_size_count equals zero, it raises an application error with code -20002 and the message 'Size code does not exist.'; if the :NEW.ABANDONED_YN column of the new or updated row in the DOGS table equals '1', indicating the dog is abandoned, it sets the :NEW.DATE_DEPARTED column to the current date using the CURRENT_DATE function; otherwise, it sets the :NEW.DATE_DEPARTED column to NULL.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_dog_breed_size\nBEFORE INSERT OR UPDATE ON DOGS\nFOR EACH ROW\nDECLARE\n  v_breed_count NUMBER;\n  v_size_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_breed_count FROM BREEDS WHERE BREED_CODE = :NEW.BREED_CODE;\n  SELECT COUNT(*) INTO v_size_count FROM SIZES WHERE SIZE_CODE = :NEW.SIZE_CODE;\n  \n  IF v_breed_count = 0 THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Breed code does not exist.');\n  ELSIF v_size_count = 0 THEN\n    RAISE_APPLICATION_ERROR(-20002, 'Size code does not exist.');\n  ELSIF :NEW.ABANDONED_YN = '1' THEN\n    :NEW.DATE_DEPARTED := CURRENT_DATE;\n  ELSE\n    :NEW.DATE_DEPARTED := NULL;\n  END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, AGE, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED) VALUES (100, 1, '0', 'ESK', 'MED', 'Buddy', '5', '2019-04-15 10:00:00', '1', '12.5', '2024-01-10 09:00:00', NULL)",
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, AGE, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED) VALUES (101, 3, '1', 'HUS', 'LGE', 'Max', '3', '2021-02-28 08:30:00', '0', '25.0', '2024-03-01 14:00:00', NULL)",
      "UPDATE DOGS SET SIZE_CODE = 'SML', ABANDONED_YN = '0' WHERE DOG_ID = 1",
      "UPDATE DOGS SET BREED_CODE = 'BUL', ABANDONED_YN = '1' WHERE DOG_ID = 2",
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, AGE, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED) VALUES (102, 4, '0', 'BUL', 'SML', 'Bella', '7', '2017-07-04 12:00:00', '0', '8.2', '2024-02-20 11:00:00', NULL)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_check_dog_breed_size on the DOGS table. Check if the :NEW.BREED_CODE exists in the BREEDS table; if not, raise error -20001 'Breed code does not exist.'. Check if the :NEW.SIZE_CODE exists in the SIZES table; if not, raise error -20002 'Size code does not exist.'. If :NEW.ABANDONED_YN is '1', set :NEW.DATE_DEPARTED to CURRENT_DATE; otherwise, set it to NULL.",
    "natural_language": "Set up a trigger on the DOGS table that runs before adding or changing a row. It should make sure the breed code being used is kind of valid by looking it up in the BREEDS list, and if it's not there, throw an error. Also, it needs to check the size code against the SIZES list and complain if that one's missing. For dogs marked as abandoned, the departure date should be set to today; otherwise, that date should be cleared out.",
    "id": 89
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_owner_contact` that is activated `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `OWNERS` table. This trigger executes `FOR EACH ROW` affected by the DML statement. Upon activation, the trigger declares two local numeric variables: `v_email_count` and `v_phone_count`. The trigger then proceeds to execute a `SELECT` statement to count the number of existing records in the `OWNERS` table where the `EMAIL_ADDRESS` column matches the `EMAIL_ADDRESS` value of the row currently being inserted or updated (referenced as `:NEW.EMAIL_ADDRESS`). The result of this count is stored in the `v_email_count` variable. Subsequently, another `SELECT` statement is executed to count the number of existing records in the `OWNERS` table where the `HOME_PHONE` column matches the `HOME_PHONE` value of the row currently being inserted or updated (referenced as `:NEW.HOME_PHONE`). The result of this second count is stored in the `v_phone_count` variable. Following these counts, the trigger enters a conditional block. The first condition checks if `v_email_count` is greater than `0`. If this condition is true, indicating that an owner with the same email address already exists, the trigger immediately raises an application error with the error code `-20003` and the error message 'Email address already exists.'. If the first condition is false, the trigger proceeds to an `ELSIF` condition that checks if `v_phone_count` is greater than `0`. If this second condition is true, indicating that an owner with the same home phone number already exists, the trigger immediately raises an application error with the error code `-20004` and the error message 'Home phone number already exists.'. If both the first and second conditions are false, the trigger proceeds to another `ELSIF` condition that checks if the `LENGTH` of the `ZIP_CODE` value of the row currently being inserted or updated (referenced as `:NEW.ZIP_CODE`) is not equal to `5`. If this third condition is true, indicating an invalid ZIP code length, the trigger immediately raises an application error with the error code `-20005` and the error message 'Invalid ZIP code length.'. If all preceding conditions are false, the trigger executes the `ELSE` block, which assigns the result of applying the `TRIM` function to the `CELL_NUMBER` value of the row currently being inserted or updated (referenced as `:NEW.CELL_NUMBER`) back to the `CELL_NUMBER` column of the same row (i.e., `:NEW.CELL_NUMBER := TRIM(:NEW.CELL_NUMBER)`), effectively removing any leading or trailing whitespace from the cell number before the `INSERT` or `UPDATE` operation completes.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_owner_contact\nBEFORE INSERT OR UPDATE ON OWNERS\nFOR EACH ROW\nDECLARE\n  v_email_count NUMBER;\n  v_phone_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_email_count FROM OWNERS WHERE EMAIL_ADDRESS = :NEW.EMAIL_ADDRESS;\n  SELECT COUNT(*) INTO v_phone_count FROM OWNERS WHERE HOME_PHONE = :NEW.HOME_PHONE;\n  \n  IF v_email_count > 0 THEN\n    RAISE_APPLICATION_ERROR(-20003, 'Email address already exists.');\n  ELSIF v_phone_count > 0 THEN\n    RAISE_APPLICATION_ERROR(-20004, 'Home phone number already exists.');\n  ELSIF LENGTH(:NEW.ZIP_CODE) != 5 THEN\n    RAISE_APPLICATION_ERROR(-20005, 'Invalid ZIP code length.');\n  ELSE\n    :NEW.CELL_NUMBER := TRIM(:NEW.CELL_NUMBER);\n  END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (5, 'John', 'Doe', '123 Main St', 'Anytown', 'CA', '12345', 'john.doe@example.com', '555-1234', '555-5678')",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (6, 'Jane', 'Smith', '456 Elm St', 'Othertown', 'NY', '54321', 'jane.smith@example.com', '555-5678', '555-8765')",
      "UPDATE OWNERS SET EMAIL_ADDRESS = 'new.email@example.com' WHERE OWNER_ID = 1",
      "UPDATE OWNERS SET HOME_PHONE = '555-0000' WHERE OWNER_ID = 3",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (7, 'Alice', 'Johnson', '789 Oak St', 'Sometown', 'TX', '67890', 'alice.johnson@example.com', '555-6789', '555-9876')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_update_owner_contact on the OWNERS table. Check if the :NEW.EMAIL_ADDRESS already exists in the OWNERS table; if yes, raise error -20003 'Email address already exists.'. Else, check if the :NEW.HOME_PHONE already exists; if yes, raise error -20004 'Home phone number already exists.'. Else, check if LENGTH(:NEW.ZIP_CODE) != 5; if yes, raise error -20005 'Invalid ZIP code length.'. If all checks pass, trim whitespace from :NEW.CELL_NUMBER.",
    "natural_language": "Set up a trigger on the OWNERS table that runs before adding or changing a row, call it trg_update_owner_contact. It should look at the new email and if something like it is already in the table, stop with an error about the email being taken. Then, check the new home phone number against existing ones, and if it seems to be a duplicate, throw a different error for that. Also, if the new ZIP code doesn't look like it's the right number of characters, flag it as invalid. If all those things seem okay, just clean up any extra spaces around the cell number.",
    "id": 90
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_charge_amount that is executed before an insert or update operation on the CHARGES table for each row affected. The trigger begins by declaring a local variable v_charge_type_count of type NUMBER, which is used to store the count of rows in the CHARGES table that have a CHARGE_TYPE matching the CHARGE_TYPE of the new or updated row, referenced as :NEW.CHARGE_TYPE. A SELECT statement is executed to count these rows, and the result is stored in v_charge_type_count. The trigger then evaluates a series of conditional statements: first, it checks if v_charge_type_count is zero, indicating that the CHARGE_TYPE of the new or updated row does not exist in the table, and if so, raises an application error with code -20009 and the message 'Charge type does not exist.' Next, it checks if the CHARGE_AMOUNT of the new or updated row, referenced as :NEW.CHARGE_AMOUNT, is less than zero, and if so, raises an application error with code -20010 and the message 'Charge amount cannot be negative.' Then, it checks if :NEW.CHARGE_AMOUNT is greater than 1000, and if so, raises an application error with code -20011 and the message 'Charge amount exceeds limit.' If none of these conditions are met, the trigger rounds :NEW.CHARGE_AMOUNT to two decimal places using the ROUND function, ensuring the charge amount is stored with a precision of two decimal places.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_charge_amount\nBEFORE INSERT OR UPDATE ON CHARGES\nFOR EACH ROW\nDECLARE\n  v_charge_type_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_charge_type_count FROM CHARGES WHERE CHARGE_TYPE = :NEW.CHARGE_TYPE;\n  \n  IF v_charge_type_count = 0 THEN\n    RAISE_APPLICATION_ERROR(-20009, 'Charge type does not exist.');\n  ELSIF :NEW.CHARGE_AMOUNT < 0 THEN\n    RAISE_APPLICATION_ERROR(-20010, 'Charge amount cannot be negative.');\n  ELSIF :NEW.CHARGE_AMOUNT > 1000 THEN\n    RAISE_APPLICATION_ERROR(-20011, 'Charge amount exceeds limit.');\n  ELSE\n    :NEW.CHARGE_AMOUNT := ROUND(:NEW.CHARGE_AMOUNT, 2);\n  END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO CHARGES (CHARGE_ID, CHARGE_TYPE, CHARGE_AMOUNT) VALUES (100, 'Daily Accommodation', 50.99)",
      "INSERT INTO CHARGES (CHARGE_ID, CHARGE_TYPE, CHARGE_AMOUNT) VALUES (101, 'Drugs', 150.75)",
      "UPDATE CHARGES SET CHARGE_AMOUNT = 1200 WHERE CHARGE_ID = 1",
      "UPDATE CHARGES SET CHARGE_AMOUNT = -10 WHERE CHARGE_ID = 2",
      "INSERT INTO CHARGES (CHARGE_ID, CHARGE_TYPE, CHARGE_AMOUNT) VALUES (102, 'Non-Existent Type', 25)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_check_charge_amount on the CHARGES table. It must validate that the new CHARGE_TYPE exists in the table, that the new CHARGE_AMOUNT is not negative, and that it does not exceed 1000. If all validations pass, round the CHARGE_AMOUNT to two decimal places.",
    "natural_language": "Set up a trigger on the CHARGES table that runs before adding or changing a row. It should make sure the charge type looks right, the amount isn't too low, and stays under a reasonable limit. If everything seems okay, clean up the amount figure a bit.",
    "id": 91
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_championship_count that is executed before an insert operation on the CHAMPIONSHIP table for each row being inserted. The trigger declares a local variable v_existing_joined of type NUMBER to store the JOINED value from an existing record. It begins by attempting to select the JOINED column value into v_existing_joined from the CHAMPIONSHIP table where the INSTITUTION_ID matches the INSTITUTION_ID of the new row being inserted, referenced as :NEW.INSTITUTION_ID. If a record is found, indicating that a championship record already exists for the given institution, the trigger checks if the JOINED value of the new row, :NEW.JOINED, is greater than v_existing_joined. If the new JOINED value is greater, the trigger deletes the existing record from the CHAMPIONSHIP table where the INSTITUTION_ID matches :NEW.INSTITUTION_ID, allowing the new row to be inserted. If the new JOINED value is not greater, the trigger raises an application error with code -20001 and a message stating that a newer or equally joined championship record already exists for the institution, thereby preventing the insertion of the new row. If no existing record is found, indicated by the NO_DATA_FOUND exception, the trigger allows the new row to be inserted without any further action.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_championship_count\nBEFORE INSERT ON CHAMPIONSHIP\nFOR EACH ROW\nDECLARE\n  v_existing_joined NUMBER;\nBEGIN\n  BEGIN\n    SELECT JOINED INTO v_existing_joined\n    FROM CHAMPIONSHIP\n    WHERE INSTITUTION_ID = :NEW.INSTITUTION_ID;\n\n    -- If we reach here, a record with :NEW.INSTITUTION_ID already exists.\n    IF :NEW.JOINED > v_existing_joined THEN\n      -- New record is newer, delete the old one to make way for the new insert.\n      DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = :NEW.INSTITUTION_ID;\n    ELSE\n      -- New record is older or same, we want to keep the existing one.\n      -- Prevent the new insert from happening by raising an error.\n      RAISE_APPLICATION_ERROR(-20001, 'A newer or equally joined championship record already exists for this institution.');\n    END IF;\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n      -- No existing record, so the new insert can proceed normally.\n      NULL;\n  END;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS) VALUES (1, 'Colonials', 1993, 0)",
      "INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS) VALUES (2, 'Terrapins', 1994, 1)",
      "INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS) VALUES (1, 'New Colonials', 1995, 1)",
      "INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS) VALUES (3, 'Wildcats', 1996, 0)",
      "INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS) VALUES (2, 'Old Terrapins', 1990, 0)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_update_championship_count on the CHAMPIONSHIP table. For a new record, if an existing record with the same INSTITUTION_ID is found, only allow insertion if the new JOINED date is greater, deleting the old record. Otherwise, raise an error. If no existing record is found, allow insertion.",
    "natural_language": "Create trigger trg_update_championship_count. Before inserting into CHAMPIONSHIP, if same INSTITUTION_ID exists, allow only if new JOINED date is later, deleting old row. Otherwise, error. If no match, insert.",
    "id": 92
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_institution_team that is defined to fire automatically after an update operation on the TEAM column of the INSTITUTION table for each affected row, and within its execution block, it first checks a condition using an IF statement to compare the old value of the TEAM column (referenced as :OLD.TEAM) with the new value of the TEAM column (referenced as :NEW.TEAM), and if they are not equal, it performs an update on the CHAMPIONSHIP table, setting the NICKNAME column to the new TEAM value (:NEW.TEAM) for all rows in CHAMPIONSHIP where the INSTITUTION_ID column matches the old INSTITUTION_ID value (:OLD.INSTITUTION_ID) from the INSTITUTION table, and then, after this conditional update, it executes a delete operation on the CHAMPIONSHIP table to remove any rows where the INSTITUTION_ID column equals the old INSTITUTION_ID value (:OLD.INSTITUTION_ID) and the NUMBER_OF_CHAMPIONSHIPS column has a value of zero.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_institution_team\nAFTER UPDATE OF TEAM ON INSTITUTION\nFOR EACH ROW\nBEGIN\n  IF :OLD.TEAM != :NEW.TEAM THEN\n    UPDATE CHAMPIONSHIP\n    SET NICKNAME = :NEW.TEAM\n    WHERE INSTITUTION_ID = :OLD.INSTITUTION_ID;\n  END IF;\n  DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = :OLD.INSTITUTION_ID AND NUMBER_OF_CHAMPIONSHIPS = 0;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "UPDATE INSTITUTION SET TEAM = 'New Thunderbirds' WHERE INSTITUTION_ID = 1",
      "UPDATE INSTITUTION SET TEAM = 'New Dinos' WHERE INSTITUTION_ID = 2",
      "UPDATE INSTITUTION SET TEAM = 'New Golden Bears' WHERE INSTITUTION_ID = 3",
      "UPDATE INSTITUTION SET TEAM = 'Updated Colonials' WHERE INSTITUTION_ID = 1",
      "UPDATE INSTITUTION SET TEAM = 'Updated Terrapins' WHERE INSTITUTION_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE OF TEAM row-level trigger named trg_update_institution_team on the INSTITUTION table. If the TEAM value changed, update the NICKNAME in the CHAMPIONSHIP table for matching INSTITUTION_ID. Then, delete any CHAMPIONSHIP records for that INSTITUTION_ID where NUMBER_OF_CHAMPIONSHIPS is zero.",
    "natural_language": "Please construct a row-level trigger designated as 'trg_update_institution_team' to execute after an update operation on the TEAM column within the INSTITUTION table. In the event of a modification to the TEAM value, it is required to subsequently update the NICKNAME field in the CHAMPIONSHIP table for all corresponding INSTITUTION_ID entries. Following this, any records within the CHAMPIONSHIP table associated with that INSTITUTION_ID must be deleted, provided the NUMBER_OF_CHAMPIONSHIPS value is equal to zero.",
    "id": 93
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named delete_old_ratings_trigger that is defined to execute before a delete operation on the MOVIE table for each row being deleted, and within its body, first performs a delete operation on the REVIEWER table where the condition is that a reviewer's RID value must be found in the result set of a subquery that selects the RID column from the RATING table (aliased as R) for all rows where the RATING table's MID column value equals the old MID column value (referenced as :OLD.MID) from the MOVIE row currently being deleted, and subsequently performs a second delete operation directly on the RATING table where the condition is that the MID column value equals the old MID column value (referenced as :OLD.MID) from the MOVIE row currently being deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER delete_old_ratings_trigger\nBEFORE DELETE ON MOVIE\nFOR EACH ROW\nBEGIN\n    -- First, delete related REVIEWER records.\n    -- We need to find all RIDs associated with the movie being deleted,\n    -- regardless of the stars, before deleting from RATING.\n    DELETE FROM REVIEWER\n    WHERE RID IN (SELECT R.RID FROM RATING R WHERE R.MID = :OLD.MID);\n\n    -- Then, delete all RATING records associated with the movie being deleted.\n    -- This ensures no child records remain to violate the foreign key constraint.\n    DELETE FROM RATING WHERE MID = :OLD.MID;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "DELETE FROM MOVIE WHERE MID = 101",
      "DELETE FROM MOVIE WHERE MID = 102",
      "DELETE FROM MOVIE WHERE MID = 103",
      "DELETE FROM MOVIE WHERE MID = 104",
      "DELETE FROM MOVIE WHERE MID = 105"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named delete_old_ratings_trigger on the MOVIE table. When a movie is deleted, first delete all REVIEWER records whose RID is found in RATING records for that movie. Then, delete all RATING records for that movie.",
    "natural_language": "Please construct a BEFORE DELETE row-level trigger designated as delete_old_ratings_trigger on the MOVIE table. The trigger's function is to execute the following operations upon the deletion of a movie: first, delete all entries from the REVIEWER table where the reviewer identifier (RID) is present within any RATING records associated with the movie in question. Subsequently, delete all corresponding records from the RATING table for that specific movie.",
    "id": 94
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named update_reviewer_name_trigger that is defined to fire automatically after each row is updated in the MOVIE table, and within its body, it first checks a conditional IF statement to determine if the value in the DIRECTOR column from the old row state, referenced as :OLD.DIRECTOR, is not equal to the value in the DIRECTOR column from the new row state, referenced as :NEW.DIRECTOR; if this condition evaluates to TRUE, then the trigger executes an UPDATE statement targeting the REVIEWER table, specifically setting the NAME column to the literal string value 'Updated Reviewer' for every reviewer record where the reviewer's identifier, the RID column, is found in the result set of a subquery; this subquery performs a SELECT operation on the RATING table, retrieving the RID column values for all rows where the movie identifier column, MID, matches the new movie identifier value from the updated MOVIE table row, which is referenced as :NEW.MID.",
    "plsql": "CREATE OR REPLACE TRIGGER update_reviewer_name_trigger\nAFTER UPDATE ON MOVIE\nFOR EACH ROW\nBEGIN\n    IF :OLD.DIRECTOR <> :NEW.DIRECTOR THEN\n        UPDATE REVIEWER SET NAME = 'Updated Reviewer' WHERE RID IN (SELECT RID FROM RATING WHERE MID = :NEW.MID);\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "UPDATE MOVIE SET DIRECTOR = 'George Lucas' WHERE MID = 101",
      "UPDATE MOVIE SET DIRECTOR = 'Steven Spielberg' WHERE MID = 102",
      "UPDATE MOVIE SET DIRECTOR = 'Christopher Nolan' WHERE MID = 103",
      "UPDATE MOVIE SET DIRECTOR = 'Quentin Tarantino' WHERE MID = 101",
      "UPDATE MOVIE SET DIRECTOR = 'Martin Scorsese' WHERE MID = 102"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named update_reviewer_name_trigger on the MOVIE table. If the DIRECTOR column is updated, set the NAME to 'Updated Reviewer' for all REVIEWERs whose RID is found in RATING records for the updated movie's MID.",
    "natural_language": "Set up a row-level trigger named update_reviewer_name_trigger to fire AFTER UPDATE on the MOVIE table. For any update to the DIRECTOR column, change the NAME to 'Updated Reviewer' for every REVIEWER whose RID appears in a RATING for that updated movie's MID.",
    "id": 95
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_CHECK_ALBUM_YEAR` that is activated `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `ALBUMS` table. This trigger is defined to execute `FOR EACH ROW` affected by the DML statement, meaning its logic will be applied individually to each row being inserted or updated. Within the trigger's execution block, a conditional statement (`IF`) evaluates whether the `YEAR` column of the row currently being inserted or updated (referenced as `:NEW.YEAR`) is numerically `GREATER THAN` the current calendar year. The current calendar year is obtained by first retrieving the current system date and time using the `SYSDATE` function, and then extracting the year component from this date using the `EXTRACT(YEAR FROM ...)` function. If this condition evaluates to `TRUE`, indicating that the `YEAR` value provided for the album is in the future relative to the current system year, the trigger then raises an application-specific error. This error is generated using the `RAISE_APPLICATION_ERROR` procedure, which takes two parameters: an error number and an error message. The error number provided is `-20001`, which is within the range reserved for user-defined application errors. The associated error message is the string literal `'Year cannot be in the future'`. This action prevents the `INSERT` or `UPDATE` operation from completing, effectively enforcing a business rule that an album's release year cannot be set to a future date.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CHECK_ALBUM_YEAR\nBEFORE INSERT OR UPDATE ON ALBUMS\nFOR EACH ROW\nBEGIN\n    IF :NEW.YEAR > EXTRACT(YEAR FROM SYSDATE) THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Year cannot be in the future');\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "BAND",
      "INSTRUMENTS",
      "PERFORMANCE",
      "SONGS",
      "TRACKLISTS",
      "VOCALS"
    ],
    "call_sqls": [
      "INSERT INTO ALBUMS (AID, TITLE, YEAR, LABEL, TYPE) VALUES (1, 'The Dark Side of the Moon', 1973, 'Harvest', 'Studio')",
      "INSERT INTO ALBUMS (AID, TITLE, YEAR, LABEL, TYPE) VALUES (2, 'Thriller', 1982, 'Epic', 'Studio')",
      "UPDATE ALBUMS SET YEAR = 2000 WHERE AID = 1",
      "INSERT INTO ALBUMS (AID, TITLE, YEAR, LABEL, TYPE) VALUES (3, 'Future Album', EXTRACT(YEAR FROM SYSDATE) + 1, 'Future Records', 'Studio')",
      "UPDATE ALBUMS SET YEAR = EXTRACT(YEAR FROM SYSDATE) + 5 WHERE AID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named TRG_CHECK_ALBUM_YEAR on the ALBUMS table. If the new YEAR value is greater than the current year, raise application error -20001 with message 'Year cannot be in the future'.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE FOR EACH ROW trigger, designated as TRG_CHECK_ALBUM_YEAR, for the ALBUMS table. This trigger must validate that the newly provided YEAR value does not exceed the current calendar year. Should this condition be violated, the trigger is to raise an application error with code -20001 and the accompanying message: 'Year cannot be in the future'.",
    "id": 96
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_UPDATE_SONG_TITLE that fires before any insert operation on the SONGS table and before any update operation that modifies the TITLE column on the SONGS table, executing once for each affected row; the trigger declares a local variable v_title_count of type NUMBER; within its execution block, it performs a SELECT COUNT(*) query on the SONGS table where the TITLE column equals the new TITLE value being inserted or updated, referenced as :NEW.TITLE, and includes a condition that either :NEW.SONGID is NULL or the existing row's SONGID column is not equal to :NEW.SONGID, which effectively excludes the current row from the count during an update operation; the result of this count is stored into the variable v_title_count; then, a conditional IF statement checks if v_title_count is greater than 0, meaning at least one other row in the SONGS table already has the same title; if this condition is true, the trigger modifies the new TITLE value, :NEW.TITLE, by appending the string ' (Duplicate)' to its original value.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_UPDATE_SONG_TITLE\nBEFORE INSERT OR UPDATE OF TITLE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_count NUMBER;\nBEGIN\n    -- Check for existing titles, excluding the current row if it's an update\n    SELECT COUNT(*)\n    INTO v_title_count\n    FROM SONGS\n    WHERE TITLE = :NEW.TITLE\n      AND (:NEW.SONGID IS NULL OR SONGID != :NEW.SONGID); -- Exclude current row for updates\n\n    IF v_title_count > 0 THEN -- If a duplicate title already exists\n        :NEW.TITLE := :NEW.TITLE || ' (Duplicate)';\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "BAND",
      "INSTRUMENTS",
      "PERFORMANCE",
      "SONGS",
      "TRACKLISTS",
      "VOCALS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'Bohemian Rhapsody')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'Bohemian Rhapsody')",
      "UPDATE SONGS SET TITLE = 'Stairway to Heaven' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'Stairway to Heaven' WHERE SONGID = 2",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'Hotel California')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE OF TITLE FOR EACH ROW trigger named TRG_UPDATE_SONG_TITLE on the SONGS table. If another song with the same title exists (excluding the current row during update), append ' (Duplicate)' to the new TITLE value.",
    "natural_language": "Hey, set up a trigger called TRG_UPDATE_SONG_TITLE on the SONGS table that fires before you insert a new song or change a song's title. Basically, if there's already another song with that same title hanging around (but don't count the song you're currently updating), just slap ' (Duplicate)' onto the end of the new title.",
    "id": 97
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_UPDATE_BANDMATE_NAME`. This trigger is defined to execute `BEFORE` any `INSERT` or `UPDATE` operation on the `BAND` table. It is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row affected by the triggering DML statement. The trigger's execution block begins by evaluating a conditional statement. Specifically, it checks the `LENGTH` of the value proposed for the `FIRSTNAME` column in the new or updated row, referenced as `:NEW.FIRSTNAME`. If the `LENGTH` of this `FIRSTNAME` value is less than the integer literal `3`, then the value of the `FIRSTNAME` column for the new or updated row (`:NEW.FIRSTNAME`) is explicitly set to the string literal `'Unknown'`. Following this, another independent conditional statement is evaluated. This statement checks the `LENGTH` of the value proposed for the `LASTNAME` column in the new or updated row, referenced as `:NEW.LASTNAME`. If the `LENGTH` of this `LASTNAME` value is less than the integer literal `3`, then the value of the `LASTNAME` column for the new or updated row (`:NEW.LASTNAME`) is explicitly set to the string literal `'Unknown'`. The trigger's execution block then concludes.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_UPDATE_BANDMATE_NAME\nBEFORE INSERT OR UPDATE ON BAND\nFOR EACH ROW\nBEGIN\n    IF LENGTH(:NEW.FIRSTNAME) < 3 THEN\n        :NEW.FIRSTNAME := 'Unknown';\n    END IF;\n\n    IF LENGTH(:NEW.LASTNAME) < 3 THEN\n        :NEW.LASTNAME := 'Unknown';\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "BAND",
      "INSTRUMENTS",
      "PERFORMANCE",
      "SONGS",
      "TRACKLISTS",
      "VOCALS"
    ],
    "call_sqls": [
      "INSERT INTO BAND (ID, FIRSTNAME, LASTNAME) VALUES (1, 'Jo', 'Doe')",
      "INSERT INTO BAND (ID, FIRSTNAME, LASTNAME) VALUES (2, 'Ed', 'Li')",
      "UPDATE BAND SET FIRSTNAME = 'Al', LASTNAME = 'Wu' WHERE ID = 1",
      "INSERT INTO BAND (ID, FIRSTNAME, LASTNAME) VALUES (3, 'Bob', 'Smith')",
      "UPDATE BAND SET LASTNAME = 'X' WHERE ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named TRG_UPDATE_BANDMATE_NAME on the BAND table. If the new FIRSTNAME length is less than 3, set it to 'Unknown'. If the new LASTNAME length is less than 3, set it to 'Unknown'.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE FOR EACH ROW trigger, designated as TRG_UPDATE_BANDMATE_NAME, for the BAND table. The trigger's function is to assign the value 'Unknown' to the new FIRSTNAME if its character length is fewer than three, and to perform the same assignment to the new LASTNAME if its character length is fewer than three.",
    "id": 98
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_adjust_population that operates on the ROLLER_COASTER table specifically for DELETE operations. This trigger consists of two distinct timing points: AFTER EACH ROW and AFTER STATEMENT. The trigger defines a PL/SQL table type named country_id_t, which is a collection of NUMBER data types indexed by PLS_INTEGER, and a variable v_country_ids of this type to store COUNTRY_ID values. In the AFTER EACH ROW section, the trigger captures the COUNTRY_ID of the deleted row from the ROLLER_COASTER table using the :OLD pseudorecord and appends it to the v_country_ids collection. In the AFTER STATEMENT section, the trigger initializes a local variable v_coaster_count of type NUMBER. It then iterates over the v_country_ids collection using a FOR loop, where for each COUNTRY_ID stored in the collection, it performs a SELECT COUNT(*) operation to determine the number of remaining roller coasters associated with that COUNTRY_ID in the ROLLER_COASTER table. The result of this count is stored in the v_coaster_count variable. Subsequently, the trigger updates the POPULATION column in the COUNTRY table for the corresponding COUNTRY_ID by subtracting the product of the tangent of v_coaster_count and 100 from the current POPULATION value. This update operation is performed for each COUNTRY_ID present in the v_country_ids collection.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_population\nFOR DELETE ON ROLLER_COASTER\nCOMPOUND TRIGGER\n  TYPE country_id_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n  v_country_ids country_id_t;\n  \n  AFTER EACH ROW IS\n  BEGIN\n    v_country_ids(v_country_ids.COUNT + 1) := :OLD.COUNTRY_ID;\n  END AFTER EACH ROW;\n  \n  AFTER STATEMENT IS\n    v_coaster_count NUMBER;\n  BEGIN\n    FOR i IN 1..v_country_ids.COUNT LOOP\n      SELECT COUNT(*) INTO v_coaster_count FROM ROLLER_COASTER WHERE COUNTRY_ID = v_country_ids(i);\n      UPDATE COUNTRY SET POPULATION = POPULATION - TAN(v_coaster_count) * 100 WHERE COUNTRY_ID = v_country_ids(i);\n    END LOOP;\n  END AFTER STATEMENT;\nEND trg_adjust_population;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "DELETE FROM ROLLER_COASTER WHERE ROLLER_COASTER_ID = 1",
      "DELETE FROM ROLLER_COASTER WHERE COUNTRY_ID = 1",
      "DELETE FROM ROLLER_COASTER WHERE NAME = 'Hades 360'",
      "DELETE FROM ROLLER_COASTER WHERE PARK = 'Kemah Boardwalk'",
      "DELETE FROM ROLLER_COASTER WHERE STATUS = 'Operating'"
    ],
    "summary": "Create a compound trigger named trg_adjust_population for DELETE operations on the ROLLER_COASTER table. In AFTER EACH ROW section, collect deleted COUNTRY_IDs. In AFTER STATEMENT section, for each collected COUNTRY_ID, count remaining coasters and update COUNTRY.POPULATION by subtracting TAN(count) * 100.",
    "natural_language": "Construct a compound trigger designated as trg_adjust_population to manage DELETE operations on the ROLLER_COASTER table. Within the AFTER EACH ROW segment, compile the COUNTRY_ID values from the deleted rows. Subsequently, in the AFTER STATEMENT segment, for each distinct COUNTRY_ID that was compiled, calculate the number of remaining roller coasters. Then, update the POPULATION field in the COUNTRY table by decrementing the value by the product of one hundred and the tangent of the aforementioned count.",
    "id": 99
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_calculate_density that fires before each row insertion into the COUNTRY table, declaring a local variable v_avg_speed of type NUMBER, then executing a SELECT statement that queries the ROLLER_COASTER table to calculate the average of the SPEED column values converted to NUMBER data type for all rows where the COUNTRY_ID matches the new COUNTRY_ID value from the inserting row, storing the result into v_avg_speed, subsequently updating the new POPULATION column value for the inserting row by adding to the original new POPULATION value the product of the tangent of v_avg_speed multiplied by 1000, and finally performing an INSERT operation into the ROLLER_COASTER table with specified literal values including a ROLLER_COASTER_ID of 999, a NAME of 'AutoGen', a PARK of 'System', the new COUNTRY_ID from the inserting row, a LENGTH of 1000, a HEIGHT of 50, a SPEED of '50', the current system date for OPENED, and a STATUS of 'Operating'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_calculate_density\nBEFORE INSERT ON COUNTRY\nFOR EACH ROW\nDECLARE\n  v_avg_speed NUMBER;\nBEGIN\n  SELECT AVG(TO_NUMBER(SPEED)) INTO v_avg_speed FROM ROLLER_COASTER WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  :NEW.POPULATION := :NEW.POPULATION + TAN(v_avg_speed) * 1000;\n  INSERT INTO ROLLER_COASTER (ROLLER_COASTER_ID, NAME, PARK, COUNTRY_ID, LENGTH, HEIGHT, SPEED, OPENED, STATUS) VALUES (999, 'AutoGen', 'System', :NEW.COUNTRY_ID, 1000, 50, '50', SYSDATE, 'Operating');\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'Norway', 5378857, 385207, 'Norwegian')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (5, 'Denmark', 5818553, 42933, 'Danish')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'Iceland', 366425, 103000, 'Icelandic')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (7, 'Netherlands', 17407585, 41543, 'Dutch')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (8, 'Belgium', 11589623, 30528, 'Dutch French')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_calculate_density on the COUNTRY table. Calculate average SPEED from ROLLER_COASTER for the new COUNTRY_ID, update new POPULATION by adding TAN(average_speed) * 1000, then insert a new roller coaster record with predefined values including the new COUNTRY_ID.",
    "natural_language": "Before inserting a new record into the COUNTRY table, how can I create a trigger named trg_calculate_density that calculates the average SPEED from the ROLLER_COASTER table for the new COUNTRY_ID, then updates the new POPULATION by adding TAN(average_speed) * 1000, and finally inserts a new roller coaster record with predefined values including the new COUNTRY_ID?",
    "id": 100
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_ratio that is executed after an update operation on the LENGTH column of the ROLLER_COASTER table for each row affected by the update. The trigger begins by declaring a local variable v_country_area of type NUMBER. It then retrieves the AREA value from the COUNTRY table where the COUNTRY_ID matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table, storing this AREA value into the v_country_area variable. The trigger proceeds to evaluate a conditional statement comparing the tangent of the new LENGTH value divided by 1000 with the tangent of the old LENGTH value divided by 1000. If the tangent of the new LENGTH is greater than the tangent of the old LENGTH, the trigger updates the COUNTRY table by increasing the POPULATION column by 100 for the row where the COUNTRY_ID matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table. Conversely, if the tangent of the new LENGTH is not greater than the tangent of the old LENGTH, the trigger updates the COUNTRY table by decreasing the POPULATION column by 100 for the row where the COUNTRY_ID matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_ratio\nAFTER UPDATE OF LENGTH ON ROLLER_COASTER\nFOR EACH ROW\nDECLARE\n  v_country_area NUMBER;\nBEGIN\n  SELECT AREA INTO v_country_area FROM COUNTRY WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  IF TAN(:NEW.LENGTH / 1000) > TAN(:OLD.LENGTH / 1000) THEN\n    UPDATE COUNTRY SET POPULATION = POPULATION + 100 WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  ELSE\n    UPDATE COUNTRY SET POPULATION = POPULATION - 100 WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  END IF;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "UPDATE ROLLER_COASTER SET LENGTH = 4000 WHERE ROLLER_COASTER_ID = 1",
      "UPDATE ROLLER_COASTER SET LENGTH = 2500 WHERE ROLLER_COASTER_ID = 2",
      "UPDATE ROLLER_COASTER SET LENGTH = 5000, COUNTRY_ID = 2 WHERE ROLLER_COASTER_ID = 3",
      "UPDATE ROLLER_COASTER SET LENGTH = LENGTH + 1000 WHERE COUNTRY_ID = 1",
      "UPDATE ROLLER_COASTER SET LENGTH = 1000 WHERE NAME = 'Boardwalk Bullet'"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_maintain_ratio on the ROLLER_COASTER table's LENGTH column. For each updated row, retrieve the AREA from the COUNTRY table matching the row's COUNTRY_ID. If TAN(:NEW.LENGTH/1000) > TAN(:OLD.LENGTH/1000), increase the matching COUNTRY's POPULATION by 100. Otherwise, decrease it by 100.",
    "natural_language": "Please construct a row-level trigger designated as 'trg_maintain_ratio' to execute after updates on the LENGTH column of the ROLLER_COASTER table. For each row that is updated, it is necessary to acquire the AREA value from the COUNTRY table where the COUNTRY_ID matches that of the updated row. Subsequently, if the tangent of the new length divided by 1000 exceeds the tangent of the old length divided by 1000, then the POPULATION for the corresponding country record should be incremented by 100. Conversely, if this condition is not met, the POPULATION should be decremented by 100.",
    "id": 101
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that activates after an update operation on the PROBLEM_LOG table for each row affected by the update. The trigger checks if the new value of the PROBLEM_STATUS_CODE column in the updated row is 'Solved'. If this condition is met, it performs an update operation on the PROBLEMS table, setting the DATE_PROBLEM_CLOSED column to the current system date and time, as returned by the SYSDATE function, for the row where the PROBLEM_ID column matches the PROBLEM_ID value from the updated row in the PROBLEM_LOG table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PROBLEM_LOG_UPDATE\nAFTER UPDATE ON PROBLEM_LOG\nFOR EACH ROW\nBEGIN\n    IF :NEW.PROBLEM_STATUS_CODE = 'Solved' THEN\n        UPDATE PROBLEMS\n        SET DATE_PROBLEM_CLOSED = SYSDATE\n        WHERE PROBLEM_ID = :NEW.PROBLEM_ID;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 2",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 3",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Reported' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 1 AND PROBLEM_ID = 1"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger on the PROBLEM_LOG table. If the updated row's PROBLEM_STATUS_CODE is 'Solved', update the PROBLEMS table's DATE_PROBLEM_CLOSED to SYSDATE for the matching PROBLEM_ID.",
    "natural_language": "Create an AFTER UPDATE trigger on PROBLEM_LOG. When PROBLEM_STATUS_CODE becomes 'Solved', set DATE_PROBLEM_CLOSED to SYSDATE in PROBLEMS for that PROBLEM_ID.",
    "id": 102
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_PROBLEM_CATEGORY_INSERT that executes automatically before any row insertion operation on the table named PROBLEM_CATEGORY_CODES, and for each new row being inserted, the trigger logic checks a single condition: if the value being inserted into the column PROBLEM_CATEGORY_CODE for the new row, referenced as :NEW.PROBLEM_CATEGORY_CODE, is NULL, then the trigger performs an assignment operation to set that :NEW.PROBLEM_CATEGORY_CODE column value for the new row to the literal string 'Unknown'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PROBLEM_CATEGORY_INSERT\nBEFORE INSERT ON PROBLEM_CATEGORY_CODES\nFOR EACH ROW\nBEGIN\n    IF :NEW.PROBLEM_CATEGORY_CODE IS NULL THEN\n        :NEW.PROBLEM_CATEGORY_CODE := 'Unknown';\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Network issues')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Security vulnerabilities')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Performance bottlenecks')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Hardware failures')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Software bugs')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_PROBLEM_CATEGORY_INSERT on the PROBLEM_CATEGORY_CODES table. If :NEW.PROBLEM_CATEGORY_CODE is NULL, set it to 'Unknown'.",
    "natural_language": "Please implement a BEFORE INSERT row-level trigger designated as TRG_PROBLEM_CATEGORY_INSERT on the PROBLEM_CATEGORY_CODES table. The trigger's function is to assign the value 'Unknown' to the :NEW.PROBLEM_CATEGORY_CODE column in the event that its value is found to be NULL.",
    "id": 103
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_PROBLEM_STATUS_UPDATE`. This trigger is defined to execute `AFTER` any `UPDATE` operation is performed on the `PROBLEMS` table. It is a `FOR EACH ROW` trigger, meaning its logic will be executed once for each row that is affected by the `UPDATE` statement on the `PROBLEMS` table. The trigger's execution block begins by evaluating a conditional statement. The condition checks if the value of the `DATE_PROBLEM_CLOSED` column in the `NEW` row image (representing the row's state *after* the update) `IS NOT NULL`. If this condition evaluates to true, indicating that the `DATE_PROBLEM_CLOSED` column has been populated with a value during the update, then an `UPDATE` operation is performed on the `PROBLEM_LOG` table. Specifically, the `PROBLEM_STATUS_CODE` column in the `PROBLEM_LOG` table is set to the literal string value `'Closed'`. This update is applied only to those rows in the `PROBLEM_LOG` table where the `PROBLEM_ID` column matches the value of the `PROBLEM_ID` column from the `NEW` row image of the `PROBLEMS` table that initiated the trigger. If the initial condition (`:NEW.DATE_PROBLEM_CLOSED IS NOT NULL`) evaluates to false, no action is taken within the trigger for that specific row update.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PROBLEM_STATUS_UPDATE\nAFTER UPDATE ON PROBLEMS\nFOR EACH ROW\nBEGIN\n    IF :NEW.DATE_PROBLEM_CLOSED IS NOT NULL THEN\n        UPDATE PROBLEM_LOG\n        SET PROBLEM_STATUS_CODE = 'Closed'\n        WHERE PROBLEM_ID = :NEW.PROBLEM_ID;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE PROBLEMS SET DATE_PROBLEM_CLOSED = '2024-01-15 10:30:00' WHERE PROBLEM_ID = 1",
      "UPDATE PROBLEMS SET DATE_PROBLEM_CLOSED = '2024-01-16 14:45:00', PROBLEM_DESCRIPTION = 'Updated description' WHERE PROBLEM_ID = 2",
      "UPDATE PROBLEMS SET DATE_PROBLEM_CLOSED = '2024-01-17 09:15:00', CLOSURE_AUTHORISED_BY_STAFF_ID = 3 WHERE PROBLEM_ID = 3",
      "UPDATE PROBLEMS SET DATE_PROBLEM_CLOSED = '2024-01-18 16:20:00', OTHER_PROBLEM_DETAILS = 'Resolved' WHERE PROBLEM_ID = 11",
      "UPDATE PROBLEMS SET DATE_PROBLEM_CLOSED = '2024-01-19 11:00:00', REPORTED_BY_STAFF_ID = 10 WHERE PROBLEM_ID = 8"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_PROBLEM_STATUS_UPDATE on the PROBLEMS table. If :NEW.DATE_PROBLEM_CLOSED IS NOT NULL, update the PROBLEM_LOG table's PROBLEM_STATUS_CODE to 'Closed' for all rows with the matching PROBLEM_ID.",
    "natural_language": "Alright, so set up a trigger called TRG_PROBLEM_STATUS_UPDATE on the PROBLEMS table that fires after each row gets updated. Basically, if the new closed date isn't empty, then go ahead and mark all the matching entries in the PROBLEM_LOG table as 'Closed'.",
    "id": 104
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_STAFF_INSERT that fires automatically before any row insertion operation is performed on the STAFF table, and for each new row being inserted, it checks a condition on the column STAFF_FIRST_NAME; specifically, if the incoming value for the STAFF_FIRST_NAME column in the new row, referenced by the bind variable :NEW.STAFF_FIRST_NAME, is found to be NULL, then the trigger executes an assignment operation that sets the value of the :NEW.STAFF_FIRST_NAME column for that row to the literal string 'Unknown', thereby ensuring that no row is inserted into the STAFF table with a NULL value in the STAFF_FIRST_NAME column.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_STAFF_INSERT\nBEFORE INSERT ON STAFF\nFOR EACH ROW\nBEGIN\n    IF :NEW.STAFF_FIRST_NAME IS NULL THEN\n        :NEW.STAFF_FIRST_NAME := 'Unknown';\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO STAFF (STAFF_ID, STAFF_LAST_NAME, OTHER_STAFF_DETAILS) VALUES (101, 'Smith', 'New hire')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_FIRST_NAME, STAFF_LAST_NAME) VALUES (102, NULL, 'Johnson')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_FIRST_NAME, STAFF_LAST_NAME, OTHER_STAFF_DETAILS) VALUES (103, '', 'Williams', 'Manager')",
      "INSERT INTO STAFF VALUES (104, NULL, 'Brown', 'Team Lead')",
      "INSERT INTO STAFF (STAFF_ID, STAFF_LAST_NAME) VALUES (105, 'Davis')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_STAFF_INSERT on the STAFF table. If :NEW.STAFF_FIRST_NAME is NULL, set it to 'Unknown'.",
    "natural_language": "Construct a row-level trigger that executes BEFORE INSERT, designated as TRG_STAFF_INSERT, specifically for the STAFF table. This trigger should meticulously check if the incoming :NEW.STAFF_FIRST_NAME value is NULL and, in such a case, thoughtfully assign the default value of 'Unknown' to it.",
    "id": 105
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_PROBLEM_LOG_DELETE that is a compound trigger designed to execute on the DELETE operation of the PROBLEM_LOG table. This trigger consists of two distinct timing points: AFTER EACH ROW and AFTER STATEMENT. The trigger defines a local PL/SQL collection type named problem_id_t, which is a table of NUMBER data type, and a variable deleted_problem_ids of this type, initialized as an empty collection. During the AFTER EACH ROW phase, the trigger appends the PROBLEM_ID value from the deleted row, accessed via the :OLD pseudorecord, to the deleted_problem_ids collection using the EXTEND method to increase the collection size and assigning the value to the newly extended position using the COUNT method to determine the current size. In the AFTER STATEMENT phase, the trigger iterates over each element in the deleted_problem_ids collection using a FOR loop, where the loop index i ranges from 1 to the total number of elements in the collection. For each PROBLEM_ID stored in the collection, the trigger executes a DELETE statement on the PROBLEMS table, targeting rows where the PROBLEM_ID matches the current element of the collection. The DELETE operation includes a condition that ensures the deletion only occurs if no corresponding PROBLEM_ID exists in the PROBLEM_LOG table, verified by a subquery using the NOT EXISTS clause, which checks for the absence of any row in the PROBLEM_LOG table with the same PROBLEM_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PROBLEM_LOG_DELETE\nFOR DELETE ON PROBLEM_LOG\nCOMPOUND TRIGGER\n    TYPE problem_id_t IS TABLE OF NUMBER;\n    deleted_problem_ids problem_id_t := problem_id_t();\n    \n    AFTER EACH ROW IS\n    BEGIN\n        deleted_problem_ids.EXTEND;\n        deleted_problem_ids(deleted_problem_ids.COUNT) := :OLD.PROBLEM_ID;\n    END AFTER EACH ROW;\n    \n    AFTER STATEMENT IS\n    BEGIN\n        FOR i IN 1..deleted_problem_ids.COUNT LOOP\n            DELETE FROM PROBLEMS p\n            WHERE p.PROBLEM_ID = deleted_problem_ids(i)\n            AND NOT EXISTS (\n                SELECT 1 \n                FROM PROBLEM_LOG pl \n                WHERE pl.PROBLEM_ID = deleted_problem_ids(i)\n            );\n        END LOOP;\n    END AFTER STATEMENT;\nEND TRG_PROBLEM_LOG_DELETE;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "DELETE FROM PROBLEM_LOG WHERE PROBLEM_LOG_ID = 1",
      "DELETE FROM PROBLEM_LOG WHERE PROBLEM_LOG_ID = 2",
      "DELETE FROM PROBLEM_LOG WHERE PROBLEM_LOG_ID = 3",
      "DELETE FROM PROBLEM_LOG WHERE PROBLEM_LOG_ID = 4",
      "DELETE FROM PROBLEM_LOG WHERE PROBLEM_LOG_ID = 5"
    ],
    "summary": "Create a compound trigger named TRG_PROBLEM_LOG_DELETE that fires on DELETE from the PROBLEM_LOG table. In the AFTER EACH ROW section, collect the deleted PROBLEM_IDs into a local array. In the AFTER STATEMENT section, iterate through the collected IDs and delete corresponding rows from the PROBLEMS table, but only if those IDs no longer exist in the PROBLEM_LOG table.",
    "natural_language": "Construct a compound trigger with the name TRG_PROBLEM_LOG_DELETE, which is designed to activate whenever a DELETE operation is performed on the PROBLEM_LOG table. Within the meticulously defined AFTER EACH ROW section, you should systematically gather each deleted PROBLEM_ID, storing them carefully into a locally declared array. Subsequently, in the thoroughly detailed AFTER STATEMENT section, you must iteratively process each collected identifier, using them to delete the matching rows from the PROBLEMS table, but crucially, only under the specific condition that those particular IDs can no longer be found within the PROBLEM_LOG table.",
    "id": 106
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_major_ranking_delete that is defined to execute automatically after a delete operation on the MAJOR_RANKING table for each individual row that is deleted, and within its execution block, it performs a delete operation on the MAJOR table where the condition MAJOR_ID = :OLD.MAJOR_ID is satisfied, using the value of the MAJOR_ID column from the deleted row in the MAJOR_RANKING table, referenced via the :OLD qualifier, as the specific value for the comparison in the condition.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_ranking_delete\nAFTER DELETE ON MAJOR_RANKING\nFOR EACH ROW\nBEGIN\n    DELETE FROM MAJOR WHERE MAJOR_ID = :OLD.MAJOR_ID;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 1 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 3 AND MAJOR_ID = 3",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 2 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 1 AND MAJOR_ID = 3",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 2 AND MAJOR_ID = 3"
    ],
    "summary": "Create a trigger named trg_major_ranking_delete that fires AFTER DELETE on the MAJOR_RANKING table for each row. For each deleted row, delete rows from the MAJOR table where MAJOR_ID equals the deleted row's MAJOR_ID.",
    "natural_language": "What is the command to create a trigger named trg_major_ranking_delete that fires after a row is deleted from the MAJOR_RANKING table, and for each deleted row, removes the corresponding rows from the MAJOR table where the MAJOR_ID matches?",
    "id": 107
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_university_update that is defined to fire automatically after any row in the UNIVERSITY table is updated, and for each individual row that is updated, the trigger executes a DELETE operation on the MAJOR_RANKING table where the condition UNIVERSITY_ID = :OLD.UNIVERSITY_ID is met, using the OLD pseudorecord to reference the value of the UNIVERSITY_ID column from the row in the UNIVERSITY table before the update occurred.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_university_update\nAFTER UPDATE ON UNIVERSITY\nFOR EACH ROW\nBEGIN\n    DELETE FROM MAJOR_RANKING WHERE UNIVERSITY_ID = :OLD.UNIVERSITY_ID;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "UPDATE UNIVERSITY SET UNIVERSITY_NAME = 'Updated College' WHERE UNIVERSITY_ID = 1",
      "UPDATE UNIVERSITY SET CITY = 'New City' WHERE UNIVERSITY_ID = 2",
      "UPDATE UNIVERSITY SET ENROLLMENT = 3000 WHERE UNIVERSITY_ID = 3",
      "UPDATE UNIVERSITY SET STATE = 'California', TEAM_NAME = 'Golden Bears' WHERE UNIVERSITY_ID = 1",
      "UPDATE UNIVERSITY SET AFFILIATION = 'Public' WHERE UNIVERSITY_ID = 2"
    ],
    "summary": "Create a trigger named trg_university_update that fires AFTER UPDATE on the UNIVERSITY table for each row. For each updated row, delete rows from the MAJOR_RANKING table where UNIVERSITY_ID equals the old UNIVERSITY_ID value from the updated row.",
    "natural_language": "What trigger can be created to fire after an update on the UNIVERSITY table, deleting rows from the MAJOR_RANKING table where the UNIVERSITY_ID matches the old UNIVERSITY_ID from the updated row?",
    "id": 108
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_major_update`. This trigger is configured to execute `AFTER` an `UPDATE` operation is performed on the `MAJOR` table. It is a `FOR EACH ROW` trigger, meaning that the trigger body will execute once for every row that is updated in the `MAJOR` table. The trigger body performs a single operation: it executes a `DELETE` statement. This `DELETE` statement targets the `MAJOR_RANKING` table. The rows to be deleted from the `MAJOR_RANKING` table are determined by a `WHERE` clause. The condition in the `WHERE` clause specifies that the `MAJOR_ID` column in the `MAJOR_RANKING` table must be equal to the value of the `MAJOR_ID` column from the row that was just updated in the `MAJOR` table, as referenced by the `:OLD.MAJOR_ID` pseudorecord variable. The `:OLD` pseudorecord provides access to the column values of the row *before* the `UPDATE` operation occurred.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_update\nAFTER UPDATE ON MAJOR\nFOR EACH ROW\nBEGIN\n    DELETE FROM MAJOR_RANKING WHERE MAJOR_ID = :OLD.MAJOR_ID;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "UPDATE MAJOR SET MAJOR_NAME = 'Accounting Updated' WHERE MAJOR_ID = 1",
      "UPDATE MAJOR SET MAJOR_NAME = 'Advertising Updated' WHERE MAJOR_ID = 2",
      "UPDATE MAJOR SET MAJOR_NAME = 'Healthcare Management Updated' WHERE MAJOR_ID = 3",
      "UPDATE MAJOR SET MAJOR_CODE = 1055 WHERE MAJOR_ID = 1",
      "UPDATE MAJOR SET MAJOR_CODE = 1056 WHERE MAJOR_ID = 2"
    ],
    "summary": "Create a trigger named trg_major_update that fires AFTER UPDATE on the MAJOR table for each row. For each updated row, delete rows from the MAJOR_RANKING table where MAJOR_ID equals the old MAJOR_ID value from the updated row.",
    "natural_language": "Construct a trigger, which should be named trg_major_update, that is designed to activate automatically AFTER an UPDATE operation is performed on the MAJOR table, specifically for each individual row that is modified. For every row that has been successfully updated, the trigger must then proceed to meticulously delete all corresponding entries from the MAJOR_RANKING table where the MAJOR_ID column precisely matches the previous, or old, MAJOR_ID value that was associated with the recently updated row.",
    "id": 109
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CLUB_UPDATE that is executed after an update operation on the CLUB table for each row that is updated. The trigger performs an update operation on the CLUB_LEADER table, specifically setting the YEAR_JOIN column to the current year in 'YYYY' format for any row where the CLUB_ID column matches the CLUB_ID of the newly updated row in the CLUB table. The trigger uses the :NEW pseudorecord to reference the new value of the CLUB_ID column from the updated row in the CLUB table. The TO_CHAR function is used to convert the CURRENT_DATE to a string representing the current year.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CLUB_UPDATE\nAFTER UPDATE ON CLUB\nFOR EACH ROW\nBEGIN\n    UPDATE CLUB_LEADER\n    SET YEAR_JOIN = TO_CHAR(CURRENT_DATE, 'YYYY')\n    WHERE CLUB_ID = :NEW.CLUB_ID;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE CLUB SET CLUB_NAME = 'Houston Updated' WHERE CLUB_ID = 1",
      "UPDATE CLUB SET OVERALL_RANKING = 10 WHERE CLUB_ID = 3",
      "UPDATE CLUB SET TEAM_LEADER = 'New Leader' WHERE CLUB_ID = 4",
      "UPDATE CLUB SET CLUB_NAME = 'SMU Updated', OVERALL_RANKING = 60 WHERE CLUB_ID = 3",
      "UPDATE CLUB SET TEAM_LEADER = 'Updated Leader', CLUB_NAME = 'Oklahoma Updated' WHERE CLUB_ID = 4"
    ],
    "summary": "Create a trigger named TRG_CLUB_UPDATE that fires AFTER UPDATE on the CLUB table for each row. For each updated row, update the CLUB_LEADER table, setting the YEAR_JOIN column to the current year (in 'YYYY' format) for rows where CLUB_ID equals the new CLUB_ID value from the updated row.",
    "natural_language": "Create trigger TRG_CLUB_UPDATE. After updating CLUB, set YEAR_JOIN to current year in CLUB_LEADER for matching CLUB_ID.",
    "id": 110
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_MEMBER_UPDATE` that is activated `AFTER` an `UPDATE` operation is performed on the `MEMBER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `MEMBER` table. Upon activation, the trigger performs a single `UPDATE` operation on the `CLUB` table. Specifically, it sets the `TEAM_LEADER` column in the `CLUB` table to the value of the `NAME` column from the row that was just updated in the `MEMBER` table. This new `NAME` value is referenced using the `:NEW.NAME` pseudorecord, which represents the new values of the columns in the updated `MEMBER` row. The `UPDATE` operation on the `CLUB` table is conditionally applied, affecting only those rows in the `CLUB` table where the `CLUB_ID` column matches any `CLUB_ID` found by a subquery. The subquery selects `CLUB_ID` values from the `CLUB_LEADER` table where the `MEMBER_ID` column in `CLUB_LEADER` is equal to the `MEMBER_ID` of the row that was just updated in the `MEMBER` table. This `MEMBER_ID` is referenced using the `:NEW.MEMBER_ID` pseudorecord, representing the new value of the `MEMBER_ID` column from the updated `MEMBER` row.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MEMBER_UPDATE\nAFTER UPDATE ON MEMBER\nFOR EACH ROW\nBEGIN\n    UPDATE CLUB\n    SET TEAM_LEADER = :NEW.NAME\n    WHERE CLUB_ID IN (SELECT CLUB_ID FROM CLUB_LEADER WHERE MEMBER_ID = :NEW.MEMBER_ID);\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE MEMBER SET NAME = 'John Smith' WHERE MEMBER_ID = 1984",
      "UPDATE MEMBER SET NAME = 'Sarah Connor', AGE = 25 WHERE MEMBER_ID = 1985",
      "UPDATE MEMBER SET NATIONALITY = 'Canada', NAME = 'David Lee' WHERE MEMBER_ID = 1986",
      "UPDATE MEMBER SET NAME = 'Maria Garcia' WHERE MEMBER_ID = 1988",
      "UPDATE MEMBER SET AGE = 30, NAME = 'Robert Chen' WHERE MEMBER_ID = 1984"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_MEMBER_UPDATE on the MEMBER table. For each updated row, update the CLUB table's TEAM_LEADER column to :NEW.NAME where CLUB_ID matches any CLUB_ID from the CLUB_LEADER table where MEMBER_ID equals :NEW.MEMBER_ID.",
    "natural_language": "How do you create an AFTER UPDATE row-level trigger named TRG_MEMBER_UPDATE on the MEMBER table that, for each updated row, updates the CLUB table's TEAM_LEADER column to :NEW.NAME where the CLUB_ID matches any CLUB_ID from the CLUB_LEADER table for which the MEMBER_ID equals :NEW.MEMBER_ID?",
    "id": 111
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CLUB_DELETE that is executed before a delete operation is performed on the CLUB table. This trigger operates at the row level, meaning it is triggered for each row that is about to be deleted from the CLUB table. The trigger's main operation is to delete rows from the CLUB_LEADER table where the CLUB_ID column matches the CLUB_ID of the row being deleted from the CLUB table. The :OLD pseudorecord is used to reference the values of the row that is being deleted from the CLUB table, specifically the CLUB_ID column, which is used as a condition to identify and delete the corresponding rows in the CLUB_LEADER table. The trigger does not perform any other operations, such as updates, inserts, or function calls, and does not include any conditional logic or special operations.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CLUB_DELETE\nBEFORE DELETE ON CLUB\nFOR EACH ROW\nBEGIN\n    DELETE FROM CLUB_LEADER WHERE CLUB_ID = :OLD.CLUB_ID;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DELETE FROM CLUB WHERE CLUB_ID = 1",
      "DELETE FROM CLUB WHERE CLUB_ID = 3",
      "DELETE FROM CLUB WHERE CLUB_ID = 4",
      "DELETE FROM CLUB WHERE CLUB_ID = 5",
      "DELETE FROM CLUB WHERE CLUB_ID = 2"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_CLUB_DELETE on the CLUB table. For each deleted row, delete from the CLUB_LEADER table where CLUB_ID equals :OLD.CLUB_ID.",
    "natural_language": "Hey, set up a trigger called TRG_CLUB_DELETE that fires before a row gets deleted from the CLUB table. Every time a club gets axed, it should also wipe out any matching rows in the CLUB_LEADER table where the CLUB_ID matches the old club's ID.",
    "id": 112
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE UPDATE` row-level trigger named `trg_institution_founded_update` that is activated on the `INSTITUTION` table specifically when the `FOUNDED` column is updated. This trigger operates for each row being updated. It declares three local numeric variables: `v_staff_count` to store the count of staff members, `v_oldest_staff` to store the maximum age of staff members, and `v_youngest_staff` to store the minimum age of staff members. The trigger's execution block begins by evaluating a conditional statement: if the new value of the `FOUNDED` column (`:NEW.FOUNDED`), representing the founding year of the institution, is greater than the current year extracted from the system date (`EXTRACT(YEAR FROM SYSDATE)`), then the `FOUNDED` column's new value is set to the current year. Following this, it executes a `SELECT` statement to count the number of rows in the `STAFF` table where the `INSTITUTION_ID` column matches the `INSTITUTION_ID` of the new row being updated (`:NEW.INSTITUTION_ID`), storing this count in the `v_staff_count` variable. Subsequently, another conditional statement checks if `v_staff_count` is greater than 0. If this condition is true, indicating that there are staff members associated with the institution, it proceeds to execute two more `SELECT` statements: first, it selects the maximum value from the `AGE` column in the `STAFF` table where the `INSTITUTION_ID` matches `:NEW.INSTITUTION_ID`, storing this maximum age in `v_oldest_staff`; second, it selects the minimum value from the `AGE` column in the `STAFF` table where the `INSTITUTION_ID` matches `:NEW.INSTITUTION_ID`, storing this minimum age in `v_youngest_staff`. Inside this nested conditional block, it then checks if the new value of the `FOUNDED` column (`:NEW.FOUNDED`) is less than the literal numeric value `1800`. If this condition is true, the `FOUNDED` column's new value is set to `1800`. The trigger concludes its execution after these conditional checks and assignments.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_institution_founded_update\nBEFORE UPDATE OF FOUNDED ON INSTITUTION\nFOR EACH ROW\nDECLARE\n    v_staff_count NUMBER;\n    v_oldest_staff NUMBER;\n    v_youngest_staff NUMBER;\nBEGIN\n    IF :NEW.FOUNDED > EXTRACT(YEAR FROM SYSDATE) THEN\n        :NEW.FOUNDED := EXTRACT(YEAR FROM SYSDATE);\n    END IF;\n    SELECT COUNT(*) INTO v_staff_count FROM STAFF WHERE INSTITUTION_ID = :NEW.INSTITUTION_ID;\n    IF v_staff_count > 0 THEN\n        SELECT MAX(AGE) INTO v_oldest_staff FROM STAFF WHERE INSTITUTION_ID = :NEW.INSTITUTION_ID;\n        SELECT MIN(AGE) INTO v_youngest_staff FROM STAFF WHERE INSTITUTION_ID = :NEW.INSTITUTION_ID;\n        IF :NEW.FOUNDED < 1800 THEN\n            :NEW.FOUNDED := 1800;\n        END IF;\n    END IF;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE INSTITUTION SET FOUNDED = 1900 WHERE INSTITUTION_ID = 1",
      "UPDATE INSTITUTION SET FOUNDED = 2000 WHERE INSTITUTION_ID = 2",
      "UPDATE INSTITUTION SET FOUNDED = 1700 WHERE INSTITUTION_ID = 3",
      "UPDATE INSTITUTION SET FOUNDED = 2025 WHERE INSTITUTION_ID = 1",
      "UPDATE INSTITUTION SET FOUNDED = 1800 WHERE INSTITUTION_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_institution_founded_update on the INSTITUTION table that fires when the FOUNDED column changes. If :NEW.FOUNDED exceeds the current year, set it to the current year. Then count staff for :NEW.INSTITUTION_ID. If staff count > 0, find the maximum and minimum staff age. If :NEW.FOUNDED < 1800, set it to 1800.",
    "natural_language": "How can I create a BEFORE UPDATE row-level trigger named trg_institution_founded_update on the INSTITUTION table that fires when the FOUNDED column is modified, sets :NEW.FOUNDED to the current year if it exceeds that year, counts the staff for :NEW.INSTITUTION_ID and, if the count is greater than zero, finds the maximum and minimum staff age, and finally sets :NEW.FOUNDED to 1800 if it is less than 1800?",
    "id": 113
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_maintain_language_count that fires for each INSERT or DELETE operation on the OFFICIAL_LANGUAGES table, which uses global collections to store affected row data for processing after the statement completes, where the trigger first declares three associative array types: country_id_t and language_id_t, both indexed by PLS_INTEGER, and then declares three global collection variables: g_insert_country_ids of type country_id_t, g_insert_language_ids of type language_id_t, and g_delete_country_ids of type country_id_t, and the trigger's AFTER EACH ROW section captures the COUNTRY_ID and LANGUAGE_ID from the :NEW pseudorecord into the g_insert_country_ids and g_insert_language_ids collections respectively for every inserted row, and captures the COUNTRY_ID from the :OLD pseudorecord into the g_delete_country_ids collection for every deleted row, and the trigger's AFTER STATEMENT section declares local variables v_lang_count of type NUMBER and v_country_id of type NUMBER, and then processes all collected insert operations by iterating through the g_insert_country_ids collection from index 1 to its count, assigning each element to v_country_id, and for each country, it executes a SELECT COUNT(*) query on the OFFICIAL_LANGUAGES table where the COUNTRY_ID equals v_country_id to obtain the current total number of languages for that country into v_lang_count, and if v_lang_count is greater than 5, it executes a DELETE statement on the OFFICIAL_LANGUAGES table to remove the specific newly inserted row where COUNTRY_ID equals v_country_id and LANGUAGE_ID equals the corresponding element from the g_insert_language_ids collection at the same index, and then processes all collected delete operations by iterating through the g_delete_country_ids collection from index 1 to its count, assigning each element to v_country_id, and for each country, it executes a SELECT COUNT(*) query on the OFFICIAL_LANGUAGES table where the COUNTRY_ID equals v_country_id to obtain the current total number of languages for that country into v_lang_count, and if v_lang_count equals 0, it executes an INSERT statement into the OFFICIAL_LANGUAGES table to add a default language with the COUNTRY_ID set to v_country_id and the LANGUAGE_ID set to 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_language_count\nFOR INSERT OR DELETE ON OFFICIAL_LANGUAGES\nCOMPOUND TRIGGER\n\n    TYPE country_id_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n    TYPE language_id_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n    \n    g_insert_country_ids country_id_t;\n    g_insert_language_ids language_id_t;\n    g_delete_country_ids country_id_t;\n    \n    AFTER EACH ROW IS\n    BEGIN\n        IF INSERTING THEN\n            g_insert_country_ids(g_insert_country_ids.COUNT + 1) := :NEW.COUNTRY_ID;\n            g_insert_language_ids(g_insert_language_ids.COUNT + 1) := :NEW.LANGUAGE_ID;\n        ELSIF DELETING THEN\n            g_delete_country_ids(g_delete_country_ids.COUNT + 1) := :OLD.COUNTRY_ID;\n        END IF;\n    END AFTER EACH ROW;\n    \n    AFTER STATEMENT IS\n        v_lang_count NUMBER;\n        v_country_id NUMBER;\n    BEGIN\n        -- Handle INSERT validation: remove any new rows that would exceed 5 languages per country\n        FOR i IN 1..g_insert_country_ids.COUNT LOOP\n            v_country_id := g_insert_country_ids(i);\n            \n            SELECT COUNT(*) INTO v_lang_count \n            FROM OFFICIAL_LANGUAGES \n            WHERE COUNTRY_ID = v_country_id;\n            \n            IF v_lang_count > 5 THEN\n                DELETE FROM OFFICIAL_LANGUAGES \n                WHERE COUNTRY_ID = v_country_id \n                AND LANGUAGE_ID = g_insert_language_ids(i);\n            END IF;\n        END LOOP;\n        \n        -- Handle DELETE validation: add default language if country has 0 languages\n        FOR i IN 1..g_delete_country_ids.COUNT LOOP\n            v_country_id := g_delete_country_ids(i);\n            \n            SELECT COUNT(*) INTO v_lang_count \n            FROM OFFICIAL_LANGUAGES \n            WHERE COUNTRY_ID = v_country_id;\n            \n            IF v_lang_count = 0 THEN\n                INSERT INTO OFFICIAL_LANGUAGES (COUNTRY_ID, LANGUAGE_ID) \n                VALUES (v_country_id, 1);\n            END IF;\n        END LOOP;\n    END AFTER STATEMENT;\n    \nEND trg_maintain_language_count;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "INSERT INTO OFFICIAL_LANGUAGES (COUNTRY_ID, LANGUAGE_ID) VALUES (1, 1)",
      "INSERT INTO OFFICIAL_LANGUAGES (COUNTRY_ID, LANGUAGE_ID) VALUES (1, 2)",
      "INSERT INTO OFFICIAL_LANGUAGES (COUNTRY_ID, LANGUAGE_ID) VALUES (1, 3)",
      "DELETE FROM OFFICIAL_LANGUAGES WHERE COUNTRY_ID = 1 AND LANGUAGE_ID = 1",
      "DELETE FROM OFFICIAL_LANGUAGES WHERE COUNTRY_ID = 1 AND LANGUAGE_ID = 2"
    ],
    "summary": "Create a compound trigger named trg_maintain_language_count on the OFFICIAL_LANGUAGES table for INSERT and DELETE operations. Use global collections to store affected COUNTRY_ID and LANGUAGE_ID values. After the statement completes, process inserts: if a country's language count exceeds 5 after insertion, delete that specific new row. Process deletes: if a country's language count becomes 0 after deletion, insert a default language (LANGUAGE_ID=1) for that country.",
    "natural_language": "Set up a trigger on the OFFICIAL_LANGUAGES table for adding and removing entries. Use some shared storage to keep track of the involved country and language codes. After everything's done, handle new additions: if a country ends up with too many languages after a new one is put in, get rid of that specific new entry. For removals: if taking a language away leaves a country with none, put in a standard default language for that place.",
    "id": 114
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_language_names that executes automatically before any update operation that modifies the NAME column on the LANGUAGES table, and it processes each affected row individually. The trigger declares a local variable v_country_count of type NUMBER. It performs a SELECT statement on the OFFICIAL_LANGUAGES table, counting all rows where the LANGUAGE_ID column matches the new ID value from the LANGUAGES row being updated, and stores the result in v_country_count. If this count is greater than zero, the trigger proceeds with two conditional checks. First, it checks if the length of the new NAME value exceeds 20 characters; if so, it modifies the new NAME value by using the SUBSTR function to truncate it to only the first 20 characters. Second, it compares the new NAME value to the old NAME value; if they are different, the trigger performs an INSERT operation into the LANGUAGES table, creating a new row where the ID column is set to the new ID value plus 1000 and the NAME column is set to the concatenation of the old NAME value and the string '_old'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_language_names\nBEFORE UPDATE OF NAME ON LANGUAGES\nFOR EACH ROW\nDECLARE\n    v_country_count NUMBER;\n    PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n    SELECT COUNT(*) INTO v_country_count FROM OFFICIAL_LANGUAGES WHERE LANGUAGE_ID = :NEW.ID;\n    IF v_country_count > 0 THEN\n        IF LENGTH(:NEW.NAME) > 20 THEN\n            :NEW.NAME := SUBSTR(:NEW.NAME, 1, 20);\n        END IF;\n        IF :NEW.NAME != :OLD.NAME THEN\n            INSERT INTO LANGUAGES (ID, NAME) VALUES (:NEW.ID + 1000, :OLD.NAME || '_old');\n            COMMIT;\n        END IF;\n    END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "UPDATE LANGUAGES SET NAME = 'English_Updated' WHERE ID = 3",
      "UPDATE LANGUAGES SET NAME = 'Swedish_Modified_Name' WHERE ID = 2",
      "UPDATE LANGUAGES SET NAME = 'A_very_long_language_name_exceeding_twenty_chars' WHERE ID = 1",
      "UPDATE LANGUAGES SET NAME = 'French' WHERE ID = 4",
      "UPDATE LANGUAGES SET NAME = 'German_New' WHERE ID = 5"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_sync_language_names on the LANGUAGES table that fires when the NAME column changes. Count how many countries use this language. If count > 0: truncate new NAME to 20 characters if longer, and if NAME changed, insert a new language row with ID = :NEW.ID + 1000 and NAME = :OLD.NAME || '_old'.",
    "natural_language": "Make a BEFORE UPDATE trigger trg_sync_language_names for LANGUAGES. On NAME change: count its countries. If any, cap new NAME at 20 chars. If NAME changed, also insert old copy with ID + 1000 and '_old' suffix.",
    "id": 115
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE UPDATE` row-level trigger named `trg_balance_country_scores` that is activated on the `COUNTRIES` table. This trigger executes for each row *before* an `UPDATE` operation is applied to that row. The trigger declares a local numeric variable `v_total_score` to temporarily store a calculated value. Upon activation, the trigger first calculates `v_total_score` by summing the values of the `JUSTICE_SCORE`, `HEALTH_SCORE`, and `EDUCATION_SCORE` columns from the new row image (represented by `:NEW`). It then proceeds with a conditional logic block. If `v_total_score` is strictly greater than `250`, the trigger decrements the `ECONOMICS_SCORE` column of the new row image by `5`. If `v_total_score` is not greater than `250` but is strictly less than `150`, the trigger increments the `POLITICS_SCORE` column of the new row image by `10`. If `v_total_score` is neither strictly greater than `250` nor strictly less than `150` (i.e., it is between `150` and `250` inclusive), the trigger calculates a new `OVERALL_SCORE` for the new row image. This `OVERALL_SCORE` is computed by summing the `JUSTICE_SCORE`, `HEALTH_SCORE`, `EDUCATION_SCORE`, `ECONOMICS_SCORE`, and `POLITICS_SCORE` columns from the new row image, dividing the sum by `5`, and then rounding the result to one decimal place using the `ROUND` function. Following this primary conditional block, the trigger performs another independent conditional check. It evaluates if the `ID` column of the new row image is an even number by using the `MOD` function to check if the remainder of `ID` divided by `2` is equal to `0`. If this condition is true, the trigger increments the `OVERALL_SCORE` column of the new row image by `1`. All modifications made to the `:NEW` values within this trigger will be applied to the `COUNTRIES` table as part of the `UPDATE` statement that fired the trigger.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_balance_country_scores\nBEFORE UPDATE ON COUNTRIES\nFOR EACH ROW\nDECLARE\n    v_total_score NUMBER;\nBEGIN\n    v_total_score := :NEW.JUSTICE_SCORE + :NEW.HEALTH_SCORE + :NEW.EDUCATION_SCORE;\n    IF v_total_score > 250 THEN\n        :NEW.ECONOMICS_SCORE := :NEW.ECONOMICS_SCORE - 5;\n    ELSIF v_total_score < 150 THEN\n        :NEW.POLITICS_SCORE := :NEW.POLITICS_SCORE + 10;\n    ELSE\n        :NEW.OVERALL_SCORE := ROUND((:NEW.JUSTICE_SCORE + :NEW.HEALTH_SCORE + :NEW.EDUCATION_SCORE + :NEW.ECONOMICS_SCORE + :NEW.POLITICS_SCORE) / 5, 1);\n    END IF;\n    IF MOD(:NEW.ID, 2) = 0 THEN\n        :NEW.OVERALL_SCORE := :NEW.OVERALL_SCORE + 1;\n    END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "UPDATE COUNTRIES SET JUSTICE_SCORE = 90, HEALTH_SCORE = 80, EDUCATION_SCORE = 85 WHERE ID = 1",
      "UPDATE COUNTRIES SET JUSTICE_SCORE = 50, HEALTH_SCORE = 40, EDUCATION_SCORE = 30 WHERE ID = 2",
      "UPDATE COUNTRIES SET JUSTICE_SCORE = 70, HEALTH_SCORE = 75, EDUCATION_SCORE = 60 WHERE ID = 3",
      "UPDATE COUNTRIES SET JUSTICE_SCORE = 100, HEALTH_SCORE = 90, EDUCATION_SCORE = 95 WHERE ID = 1",
      "UPDATE COUNTRIES SET JUSTICE_SCORE = 60, HEALTH_SCORE = 50, EDUCATION_SCORE = 40 WHERE ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_balance_country_scores on the COUNTRIES table. For each row, calculate the total of the new JUSTICE_SCORE, HEALTH_SCORE, and EDUCATION_SCORE. If the total is greater than 250, decrease the new ECONOMICS_SCORE by 5. If the total is less than 150, increase the new POLITICS_SCORE by 10. If the total is between 150 and 250 inclusive, calculate and set the new OVERALL_SCORE as the average of the five scores (JUSTICE, HEALTH, EDUCATION, ECONOMICS, POLITICS), rounded to one decimal place. Then, if the new ID is even, increase the new OVERALL_SCORE by 1.",
    "natural_language": "Set up a BEFORE UPDATE trigger on the COUNTRIES table to adjust things before saving. For each row being updated, first add up the new scores for justice, health, and education. If that combined number seems pretty highlike over 250then nudge the economics score down a bit, say by 5. If the total comes out on the low side, under 150, then bump up the politics score by a decent amount, like 10. If the total is somewhere in the middle, between 150 and 250, then figure out a kind of overall average from all five scores and round it to one decimal. Also, if the new ID looks like an even number, give that overall score a little extra boost of 1.",
    "id": 116
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_clean_customer_email that is defined to fire automatically before any row insertion operation is performed on the CUSTOMERS table, and for each individual row being inserted, the trigger executes a block of code that performs a single operation: it assigns a new value to the EMAIL_ADDRESS column of the newly inserted row, represented by the :NEW.EMAIL_ADDRESS pseudorecord, by applying the RTRIM function to the original incoming value of :NEW.EMAIL_ADDRESS, which removes any trailing space characters from the end of the email address string.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_clean_customer_email\nBEFORE INSERT ON CUSTOMERS\nFOR EACH ROW\nBEGIN\n    :NEW.EMAIL_ADDRESS := RTRIM(:NEW.EMAIL_ADDRESS);\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (1, 'Good Credit Rating', '123 Main St', 'Apt 1A', 'Anytown', 'CA', 'test1@example.com   ', '555-1111')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (2, 'Good Credit Rating', '456 Oak Ave', NULL, 'Otherville', 'NY', 'test2@example.org  ', '555-2222')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (3, 'Good Credit Rating', '789 Pine Ln', 'Suite 200', 'Smalltown', 'TX', 'test3@example.net     ', '555-3333')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (4, 'Good Credit Rating', '101 Elm Rd', 'Unit B', 'Big City', 'FL', 'another.email@domain.com ', '555-4444')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (5, 'Good Credit Rating', '202 Maple Dr', NULL, 'Metropolis', 'GA', 'user.name@company.org   ', '555-5555')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_clean_customer_email on the CUSTOMERS table. For each row, trim trailing spaces from the new EMAIL_ADDRESS value.",
    "natural_language": "Hey, can you set up a trigger called trg_clean_customer_email for the CUSTOMERS table? It should fire before any new row is added and just clean up the EMAIL_ADDRESS by chopping off any extra spaces at the end.",
    "id": 117
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_clean_staff_phone that is executed before an update operation on the STAFF table, specifically for each row being updated. The trigger modifies the PHONE_NUMBER column of the row being updated by applying the RTRIM function to the new value of PHONE_NUMBER, which removes any trailing spaces from the string. The trigger uses the :NEW keyword to reference the new value of the PHONE_NUMBER column that is being set during the update operation. The trigger does not perform any conditional checks or involve any other columns or tables, and it solely focuses on ensuring that the PHONE_NUMBER column does not contain any trailing spaces after the update operation is executed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_clean_staff_phone\nBEFORE UPDATE ON STAFF\nFOR EACH ROW\nBEGIN\n    :NEW.PHONE_NUMBER := RTRIM(:NEW.PHONE_NUMBER);\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE STAFF SET PHONE_NUMBER = '142-311-6503x206 ' WHERE STAFF_ID = 115",
      "UPDATE STAFF SET PHONE_NUMBER = '345-656-5571  ', LAST_NAME = 'Smith' WHERE STAFF_ID = 116",
      "UPDATE STAFF SET PHONE_NUMBER = '1-132-839-9409x288   ', EMAIL_ADDRESS = 'new.email@example.com' WHERE FIRST_NAME = 'Bradly'",
      "UPDATE STAFF SET PHONE_NUMBER = '555-123-4567 ' WHERE STAFF_ID = 117",
      "UPDATE STAFF SET PHONE_NUMBER = ' 999-888-7777', GENDER = '1' WHERE STAFF_ID = 120"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_clean_staff_phone on the STAFF table. For each row, trim trailing spaces from the new PHONE_NUMBER value.",
    "natural_language": "Please implement a BEFORE UPDATE row-level trigger designated as trg_clean_staff_phone on the STAFF table. This trigger shall execute for each row, ensuring that any trailing spaces are removed from the new PHONE_NUMBER value prior to the update operation.",
    "id": 118
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_set_complaint_default_date that is executed automatically before a new row is inserted into the COMPLAINTS table. This trigger operates on each row being inserted and sets the DATE_COMPLAINT_RAISED column of the new row to the current system date and time. The system date and time are retrieved using the SYSDATE function, which returns the current date and time of the database server. The SYSDATE value is then converted to a string in the format 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function, ensuring that the date and time are stored in a specific string format. The trigger does not involve any conditional logic or additional operations beyond setting the DATE_COMPLAINT_RAISED column for each new row inserted into the COMPLAINTS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_set_complaint_default_date\nBEFORE INSERT ON COMPLAINTS\nFOR EACH ROW\nBEGIN\n    :NEW.DATE_COMPLAINT_RAISED := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_OUTCOME_CODE, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, DATE_COMPLAINT_CLOSED, STAFF_ID) VALUES (4, 117, 113, 'OK', 'New', 'Product Failure', '2023-01-01 10:00:00', 115)",
      "INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_OUTCOME_CODE, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, DATE_COMPLAINT_CLOSED, STAFF_ID) VALUES (5, 118, 114, NULL, 'New', 'Product Unusable', '2023-02-01 11:00:00', 116)",
      "INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_OUTCOME_CODE, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, DATE_COMPLAINT_CLOSED, STAFF_ID) VALUES (6, 119, 115, 'OK', 'Closed', 'Product Failure', '2023-03-01 12:00:00', 117)",
      "INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, STAFF_ID) VALUES (7, 117, 113, 'New', 'Product Unusable', 115)",
      "INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_OUTCOME_CODE, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, DATE_COMPLAINT_CLOSED, STAFF_ID) VALUES (8, 118, 114, 'OK', 'New', 'Product Failure', '2023-04-01 13:00:00', 116)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_set_complaint_default_date on the COMPLAINTS table. For each row, set the new DATE_COMPLAINT_RAISED to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Set up a BEFORE INSERT row-level trigger called trg_set_complaint_default_date for the COMPLAINTS table. For every new row, assign the current system date and time in 'YYYY-MM-DD HH24:MI:SS' format to the DATE_COMPLAINT_RAISED column.",
    "id": 119
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_uppercase_product_name that is defined to fire automatically before any INSERT operation or UPDATE operation is executed on the PRODUCTS table, and it fires once for each individual row being inserted or updated; within its execution block, the trigger performs a single assignment operation where it takes the new value for the column PRODUCT_NAME, which is referenced using the :NEW.PRODUCT_NAME bind variable, applies the built-in SQL function UPPER to that value to convert all alphabetical characters within the string to their uppercase equivalents, and then assigns this transformed uppercase string back to the :NEW.PRODUCT_NAME column value, thereby ensuring the PRODUCT_NAME column value is stored in uppercase for the row about to be inserted or updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_uppercase_product_name\nBEFORE INSERT OR UPDATE ON PRODUCTS\nFOR EACH ROW\nBEGIN\n    :NEW.PRODUCT_NAME := UPPER(:NEW.PRODUCT_NAME);\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY_CODE, PRODUCT_PRICE) VALUES (120, 'apple', 'Food', 1.50)",
      "INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY_CODE, PRODUCT_PRICE) VALUES (121, 'orange juice', 'Beverage', 3.99)",
      "UPDATE PRODUCTS SET PRODUCT_NAME = 'banana' WHERE PRODUCT_ID = 117",
      "INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY_CODE, PRODUCT_PRICE) VALUES (122, 'milk', 'Dairy', 2.75)",
      "UPDATE PRODUCTS SET PRODUCT_NAME = 'dark chocolate' WHERE PRODUCT_ID = 118"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_uppercase_product_name on the PRODUCTS table. For each row, convert the new PRODUCT_NAME value to uppercase.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE row-level trigger called trg_uppercase_product_name on the PRODUCTS table that converts the new PRODUCT_NAME value to uppercase for each row?",
    "id": 120
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named trg_format_customer_address that is defined to execute automatically before any new row is inserted into the CUSTOMERS table, operating once for each individual row being inserted, and within its execution block, it performs two distinct assignment operations on the new row's data values: first, it assigns the value of the :NEW.ADDRESS_LINE_1 column to be the result of applying the RTRIM function to the original incoming :NEW.ADDRESS_LINE_1 value, which removes all trailing space characters from the end of that string, and second, it assigns the value of the :NEW.ADDRESS_LINE_2 column to be the result of applying the RTRIM function to the original incoming :NEW.ADDRESS_LINE_2 value, thereby also removing all trailing space characters from the end of that string.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_format_customer_address\nBEFORE INSERT ON CUSTOMERS\nFOR EACH ROW\nBEGIN\n    :NEW.ADDRESS_LINE_1 := RTRIM(:NEW.ADDRESS_LINE_1);\n    :NEW.ADDRESS_LINE_2 := RTRIM(:NEW.ADDRESS_LINE_2);\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (200, 'Good Credit Rating', '123 Main St   ', 'Apt. 101   ', 'Springfield', 'Illinois', 'test1@example.com', '555-0101')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (201, 'Good Credit Rating', '456 Oak Ave', NULL, 'Shelbyville', 'Indiana', 'test2@example.net', '555-0102')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (202, 'Good Credit Rating', '  789 Pine Rd   ', '   Suite 200   ', 'Capital City', 'Ohio', 'test3@example.org', '555-0103')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (203, 'Good Credit Rating', 'No Trailing Spaces', 'Apt. 300', 'Metropolis', 'New York', 'test4@example.com', '1-555-0104')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (204, 'Good Credit Rating', 'Single Tab   ', 'Apt. 400   ', 'Smallville', 'Kansas', 'test5@example.net', '997.698.4779')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_format_customer_address on the CUSTOMERS table. For each new row, trim trailing spaces from the ADDRESS_LINE_1 and ADDRESS_LINE_2 columns.",
    "natural_language": "Set up a trigger on the CUSTOMERS table that runs before adding new entries. It should tidy up the address fields a bit, like removing any extra spaces hanging off the end of the main address lines.",
    "id": 121
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_route_location_count that fires for INSERT operations on the DELIVERY_ROUTE_LOCATIONS table, which first declares a private collection type named route_id_list_t as a table of NUMBER and initializes a global variable g_route_ids of that type, then in its AFTER EACH ROW section extends the g_route_ids collection and assigns the newly inserted ROUTE_ID value from the :NEW pseudorecord into the last position of the collection, and subsequently in its AFTER STATEMENT section declares a local variable v_count of type NUMBER, then iterates through each index from 1 to the total count of elements in the g_route_ids collection, and for each iteration performs a SELECT COUNT(*) query from the DELIVERY_ROUTE_LOCATIONS table into v_count where the ROUTE_ID column equals the value stored at the current index in the g_route_ids collection, then checks if the modulus of v_count divided by 2 equals zero using the MOD function, and if true executes an UPDATE on the DELIVERY_ROUTES table setting the ROUTE_NAME column to the string literal 'Even Locations Route' for the row where the ROUTE_ID matches the current collection element, otherwise executes an UPDATE on the DELIVERY_ROUTES table setting the ROUTE_NAME column to the string literal 'Odd Locations Route' for the matching ROUTE_ID, and after the loop completes, invokes the DELETE method on the g_route_ids collection to remove all its elements.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_route_location_count\nFOR INSERT ON DELIVERY_ROUTE_LOCATIONS\nCOMPOUND TRIGGER\n\n    TYPE route_id_list_t IS TABLE OF NUMBER;\n    g_route_ids route_id_list_t := route_id_list_t();\n\n    AFTER EACH ROW IS\n    BEGIN\n        g_route_ids.EXTEND;\n        g_route_ids(g_route_ids.COUNT) := :NEW.ROUTE_ID;\n    END AFTER EACH ROW;\n\n    AFTER STATEMENT IS\n        v_count NUMBER;\n    BEGIN\n        FOR i IN 1..g_route_ids.COUNT LOOP\n            SELECT COUNT(*) INTO v_count \n            FROM DELIVERY_ROUTE_LOCATIONS \n            WHERE ROUTE_ID = g_route_ids(i);\n            \n            IF MOD(v_count, 2) = 0 THEN\n                UPDATE DELIVERY_ROUTES \n                SET ROUTE_NAME = 'Even Locations Route' \n                WHERE ROUTE_ID = g_route_ids(i);\n            ELSE\n                UPDATE DELIVERY_ROUTES \n                SET ROUTE_NAME = 'Odd Locations Route' \n                WHERE ROUTE_ID = g_route_ids(i);\n            END IF;\n        END LOOP;\n        \n        g_route_ids.DELETE;\n    END AFTER STATEMENT;\n\nEND trg_route_location_count;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "ORDER_DELIVERIES",
      "DELIVERY_ROUTE_LOCATIONS",
      "DELIVERY_ROUTES",
      "TRUCKS"
    ],
    "call_sqls": [
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('27 City Rd', 11, 5, 'Labadie-Crooks')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('30 Sam Rd', 7, 13, 'VonRueden, Schmeler and Fay')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('67 LV Rd', 11, 6, 'Carter, Pfannerstill and Ruthe...')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('45 Main St', 7, 8, 'New Location Name')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('99 Elm St', 11, 9, 'Another Location Name')"
    ],
    "summary": "Create a compound trigger named trg_route_location_count for INSERT operations on the DELIVERY_ROUTE_LOCATIONS table. After each row, store the inserted ROUTE_ID in a collection. After the statement, for each stored ROUTE_ID, count its locations in the table. If the count is even, update the corresponding row in DELIVERY_ROUTES to set ROUTE_NAME to 'Even Locations Route'. If odd, set it to 'Odd Locations Route'. Finally, clear the collection.",
    "natural_language": "Please construct a compound trigger designated as trg_route_location_count to be activated upon INSERT operations targeting the DELIVERY_ROUTE_LOCATIONS table. Subsequent to each row insertion, the associated ROUTE_ID value is to be recorded within a collection. Following the completion of the statement, for every ROUTE_ID retained in said collection, ascertain the total count of its corresponding locations within the table. Should this count be determined to be an even number, proceed to update the relevant entry in the DELIVERY_ROUTES table, setting its ROUTE_NAME field to 'Even Locations Route'. Conversely, if the count is determined to be odd, the ROUTE_NAME field should be updated to 'Odd Locations Route'. Conclude the process by purging the contents of the collection.",
    "id": 122
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_delivery_status that is executed after an update operation on the DELIVERY_STATUS_CODE column of the ORDER_DELIVERIES table for each row affected by the update. The trigger checks the new and old values of the DELIVERY_STATUS_CODE column for specific conditions. If the new DELIVERY_STATUS_CODE is 'Ready' and the old DELIVERY_STATUS_CODE was not 'Ready', it updates the ORDER_STATUS_CODE column in the ACTUAL_ORDERS table to 'Processing' for the row where the ACTUAL_ORDER_ID matches the NEW.ACTUAL_ORDER_ID. If the new DELIVERY_STATUS_CODE is 'On Road' and the old DELIVERY_STATUS_CODE was not 'On Road', it updates the ORDER_STATUS_CODE column in the ACTUAL_ORDERS table to 'Shipped' for the row where the ACTUAL_ORDER_ID matches the NEW.ACTUAL_ORDER_ID. Additionally, if the length of the new DELIVERY_STATUS_CODE is greater than the length of the old DELIVERY_STATUS_CODE, it updates the ORDER_STATUS_CODE column in the ACTUAL_ORDERS table to 'Status Updated' for the row where the ACTUAL_ORDER_ID matches the NEW.ACTUAL_ORDER_ID. The trigger uses conditional statements to determine which update operation to perform based on the comparison of the new and old values of the DELIVERY_STATUS_CODE column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_delivery_status\nAFTER UPDATE OF DELIVERY_STATUS_CODE ON ORDER_DELIVERIES\nFOR EACH ROW\nBEGIN\n    IF :NEW.DELIVERY_STATUS_CODE = 'Ready' AND :OLD.DELIVERY_STATUS_CODE != 'Ready' THEN\n        UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Processing' WHERE ACTUAL_ORDER_ID = :NEW.ACTUAL_ORDER_ID;\n    ELSIF :NEW.DELIVERY_STATUS_CODE = 'On Road' AND :OLD.DELIVERY_STATUS_CODE != 'On Road' THEN\n        UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Shipped' WHERE ACTUAL_ORDER_ID = :NEW.ACTUAL_ORDER_ID;\n    ELSIF LENGTH(:NEW.DELIVERY_STATUS_CODE) > LENGTH(:OLD.DELIVERY_STATUS_CODE) THEN\n        UPDATE ACTUAL_ORDERS SET ORDER_STATUS_CODE = 'Status Updated' WHERE ACTUAL_ORDER_ID = :NEW.ACTUAL_ORDER_ID;\n    END IF;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "ORDER_DELIVERIES",
      "DELIVERY_ROUTE_LOCATIONS",
      "DELIVERY_ROUTES",
      "TRUCKS"
    ],
    "call_sqls": [
      "UPDATE ORDER_DELIVERIES SET DELIVERY_STATUS_CODE = 'Ready' WHERE ACTUAL_ORDER_ID = 1 AND LOCATION_CODE = '27 City Rd'",
      "UPDATE ORDER_DELIVERIES SET DELIVERY_STATUS_CODE = 'On Road' WHERE ACTUAL_ORDER_ID = 2 AND LOCATION_CODE = '30 Sam Rd'",
      "UPDATE ORDER_DELIVERIES SET DELIVERY_STATUS_CODE = 'Delivered' WHERE ACTUAL_ORDER_ID = 3 AND LOCATION_CODE = '67 LV Rd'",
      "UPDATE ORDER_DELIVERIES SET DELIVERY_STATUS_CODE = 'Ready for Dispatch' WHERE ACTUAL_ORDER_ID = 11 AND LOCATION_CODE = '27 City Rd'",
      "UPDATE ORDER_DELIVERIES SET DELIVERY_STATUS_CODE = 'On Road to Destination' WHERE ACTUAL_ORDER_ID = 1 AND LOCATION_CODE = '27 City Rd'"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_delivery_status on the ORDER_DELIVERIES table, firing when the DELIVERY_STATUS_CODE column is updated. If the new status is 'Ready' and the old was not, update the corresponding order in ACTUAL_ORDERS to 'Processing'. If the new status is 'On Road' and the old was not, update the order to 'Shipped'. Additionally, if the length of the new status code is greater than the old, update the order to 'Status Updated'. Use the NEW.ACTUAL_ORDER_ID to find the matching order.",
    "natural_language": "How do I create an AFTER UPDATE row-level trigger named trg_update_delivery_status on the ORDER_DELIVERIES table that fires when the DELIVERY_STATUS_CODE column is updated? The trigger should update the corresponding order in ACTUAL_ORDERS to 'Processing' if the new status is 'Ready' and the old was not, to 'Shipped' if the new status is 'On Road' and the old was not, and to 'Status Updated' if the length of the new status code is greater than the old, using NEW.ACTUAL_ORDER_ID to find the matching order.",
    "id": 123
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_generate_route_name` on the `DELIVERY_ROUTES` table. This trigger executes automatically for each row *before* an `INSERT` operation is performed on the `DELIVERY_ROUTES` table. The trigger declares two local variables: `v_max_id` of type `NUMBER` to store the maximum `ROUTE_ID` found in the `DELIVERY_ROUTES` table, and `v_name_length` of type `NUMBER` to store the length of the `ROUTE_NAME` column value for the new row being inserted.\n\nUpon execution, the trigger first performs a `SELECT` operation to retrieve the maximum value from the `ROUTE_ID` column in the `DELIVERY_ROUTES` table. If no rows exist in the `DELIVERY_ROUTES` table, or if all `ROUTE_ID` values are `NULL`, the `NVL` (Null Value Logic) function ensures that `0` is returned instead of `NULL`. This retrieved maximum ID (or `0`) is then stored into the `v_max_id` variable.\n\nNext, the trigger calculates the length of the `ROUTE_NAME` column value for the new row being inserted, which is referenced as `:NEW.ROUTE_NAME`. The `LENGTH` function is used for this calculation, and the result is stored in the `v_name_length` variable.\n\nFollowing this, the trigger enters a conditional block (`IF-ELSIF-ELSE`) to determine how to modify the `:NEW.ROUTE_NAME` value based on its calculated length:\n1. If `v_name_length` is less than `5`, the `:NEW.ROUTE_NAME` is updated to a concatenated string consisting of the literal `'Route_'`, followed by the value of the `ROUTE_ID` for the new row (`:NEW.ROUTE_ID`), and then the literal `'_Short'`.\n2. Else if `v_name_length` is between `5` and `10` (inclusive), the `:NEW.ROUTE_NAME` is updated to a concatenated string. This string is formed by taking the first `5` characters of the original `:NEW.ROUTE_NAME` using the `SUBSTR` function (starting at position `1` for a length of `5`), followed by the literal `'_'`, and then the value of `:NEW.ROUTE_ID`.\n3. Else (if `v_name_length` is greater than `10`), the `:NEW.ROUTE_NAME` is updated to a concatenated string consisting of the literal `'Long_Route_'`, followed by the value of `:NEW.ROUTE_ID`.\n\nFinally, regardless of the conditional logic for `ROUTE_NAME`, the trigger updates the `:NEW.OTHER_ROUTE_DETAILS` column for the new row. It sets this column to a concatenated string consisting of the literal `'Generated from trigger with max_id='`, followed by the value stored in the `v_max_id` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_generate_route_name\nBEFORE INSERT ON DELIVERY_ROUTES\nFOR EACH ROW\nDECLARE\n    v_max_id NUMBER;\n    v_name_length NUMBER;\nBEGIN\n    SELECT NVL(MAX(ROUTE_ID), 0) INTO v_max_id FROM DELIVERY_ROUTES;\n    v_name_length := LENGTH(:NEW.ROUTE_NAME);\n    IF v_name_length < 5 THEN\n        :NEW.ROUTE_NAME := 'Route_' || :NEW.ROUTE_ID || '_Short';\n    ELSIF v_name_length BETWEEN 5 AND 10 THEN\n        :NEW.ROUTE_NAME := SUBSTR(:NEW.ROUTE_NAME, 1, 5) || '_' || :NEW.ROUTE_ID;\n    ELSE\n        :NEW.ROUTE_NAME := 'Long_Route_' || :NEW.ROUTE_ID;\n    END IF;\n    :NEW.OTHER_ROUTE_DETAILS := 'Generated from trigger with max_id=' || v_max_id;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "ORDER_DELIVERIES",
      "DELIVERY_ROUTE_LOCATIONS",
      "DELIVERY_ROUTES",
      "TRUCKS"
    ],
    "call_sqls": [
      "INSERT INTO DELIVERY_ROUTES (ROUTE_ID, ROUTE_NAME) VALUES (1, 'R1')",
      "INSERT INTO DELIVERY_ROUTES (ROUTE_ID, ROUTE_NAME) VALUES (2, 'RouteA')",
      "INSERT INTO DELIVERY_ROUTES (ROUTE_ID, ROUTE_NAME) VALUES (3, 'MyLongRouteName')",
      "INSERT INTO DELIVERY_ROUTES (ROUTE_ID, ROUTE_NAME) VALUES (4, 'Short')",
      "INSERT INTO DELIVERY_ROUTES (ROUTE_ID, ROUTE_NAME) VALUES (5, 'MediumRoute')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_generate_route_name on the DELIVERY_ROUTES table. First, find the maximum ROUTE_ID in the table (default to 0). Then, check the length of the new ROUTE_NAME. If less than 5, set ROUTE_NAME to 'Route_' concatenated with the new ROUTE_ID and '_Short'. If between 5 and 10 inclusive, set it to the first 5 characters of the original name, an underscore, and the ROUTE_ID. If greater than 10, set it to 'Long_Route_' concatenated with the ROUTE_ID. Finally, set OTHER_ROUTE_DETAILS to 'Generated from trigger with max_id=' concatenated with the maximum ID found.",
    "natural_language": "Create trigger trg_generate_route_name for DELIVERY_ROUTES. On insert, get max ROUTE_ID. If new ROUTE_NAME length <5, set to 'Route_'||new ROUTE_ID||'_Short'. If between 5 and 10, set to first 5 chars of name||'_'||ROUTE_ID. If >10, set to 'Long_Route_'||ROUTE_ID. Set OTHER_ROUTE_DETAILS to 'Generated from trigger with max_id='||max ID.",
    "id": 124
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_round_on_member_delete` that is activated `AFTER` a `DELETE` operation is performed on the `MEMBER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is deleted from the `MEMBER` table. Upon activation, for each row that has been deleted from the `MEMBER` table, the trigger performs a `DELETE` operation on the `ROUND` table. The `DELETE` operation on the `ROUND` table is conditional: it removes all rows from the `ROUND` table where the value in the `MEMBER_ID` column of the `ROUND` table is equal to the value of the `MEMBER_ID` column from the row that was just deleted from the `MEMBER` table. The `:OLD.MEMBER_ID` pseudo-record refers to the value of the `MEMBER_ID` column in the row of the `MEMBER` table that was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_round_on_member_delete\nAFTER DELETE ON MEMBER\nFOR EACH ROW\nBEGIN\n  DELETE FROM ROUND WHERE MEMBER_ID = :OLD.MEMBER_ID;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 2",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 3",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 4",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 5"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_round_on_member_delete on the MEMBER table. For each deleted member row, delete all rows from the ROUND table where the MEMBER_ID matches the deleted member's MEMBER_ID (accessed via :OLD.MEMBER_ID).",
    "natural_language": "Construct a detailed AFTER DELETE row-level trigger, to be named trg_delete_round_on_member_delete, which will be meticulously placed on the MEMBER table. This trigger must be configured to activate for each individual member row that is removed, subsequently performing a thorough deletion of every associated row from the ROUND table. The deletion should precisely target those records where the ROUND table's MEMBER_ID column corresponds exactly to the MEMBER_ID value of the recently deleted member, which is carefully accessed through the :OLD.MEMBER_ID reference.",
    "id": 125
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_round_on_member_insert that is defined to execute automatically after a new row is inserted into the MEMBER table, and it executes once for each inserted row; within its body, it performs a single INSERT operation into a table named ROUND, specifying values for four columns: the ROUND_ID column is populated with the value from the :NEW.MEMBER_ID pseudo-record field of the newly inserted MEMBER row, the MEMBER_ID column is also populated with the same :NEW.MEMBER_ID value, the DECORATION_THEME column is populated with the literal string 'Default Theme', and the RANK_IN_ROUND column is populated with the literal numeric value 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_round_on_member_insert\nAFTER INSERT ON MEMBER\nFOR EACH ROW\nBEGIN\n  INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND)\n  VALUES (:NEW.MEMBER_ID, :NEW.MEMBER_ID, 'Default Theme', 1);\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (4, 'Gary Player', 'South Africa', 1)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (5, 'Seve Ballesteros', 'Spain', 2)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (6, 'Tom Watson', 'United States', 3)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (7, 'Lee Trevino', 'United States', 1)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (8, 'Nick Faldo', 'United Kingdom', 2)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_round_on_member_insert on the MEMBER table. For each new row, insert into the ROUND table: set ROUND_ID and MEMBER_ID to :NEW.MEMBER_ID, DECORATION_THEME to 'Default Theme', and RANK_IN_ROUND to 1.",
    "natural_language": "Please construct an AFTER INSERT row-level trigger designated as trg_insert_round_on_member_insert for the MEMBER table. For each inserted row, the trigger must execute an insertion into the ROUND table, assigning the ROUND_ID and MEMBER_ID columns the value from :NEW.MEMBER_ID, setting the DECORATION_THEME to 'Default Theme', and initializing the RANK_IN_ROUND to 1.",
    "id": 126
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `TRG_CUST_ADDR_BIU` on the `CUSTOMER_ADDRESSES` table. This trigger executes for each row affected by an `INSERT` or `UPDATE` statement on the `CUSTOMER_ADDRESSES` table, prior to the data being committed to the database. The trigger performs two main operations. First, it handles date validation: it compares the value of the `DATE_FROM` column in the new or updated row (`:NEW.DATE_FROM`) with the value of the `DATE_TO` column in the new or updated row (`:NEW.DATE_TO`). Both column values are explicitly converted to `DATE` data types using the `TO_DATE` function with the format mask `'YYYY-MM-DD HH24:MI:SS'` before comparison. If the converted `DATE_FROM` is found to be chronologically later than the converted `DATE_TO`, then the `DATE_TO` column in the new or updated row (`:NEW.DATE_TO`) is set to the value of the `DATE_FROM` column in the new or updated row (`:NEW.DATE_FROM`). Second, the trigger ensures that the `ADDRESS_ID` column always has a value: it checks if the `ADDRESS_ID` column in the new or updated row (`:NEW.ADDRESS_ID`) is `NULL`. If `ADDRESS_ID` is `NULL`, the trigger generates a new `ADDRESS_ID` by querying the `CUSTOMER_ADDRESSES` table. It selects the maximum existing `ADDRESS_ID` from the `CUSTOMER_ADDRESSES` table, uses the `NVL` function to treat a `NULL` result from `MAX(ADDRESS_ID)` as `0`, adds `1` to this value, and then assigns the resulting incremented value to the `ADDRESS_ID` column in the new or updated row (`:NEW.ADDRESS_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CUST_ADDR_BIU\nBEFORE INSERT OR UPDATE ON CUSTOMER_ADDRESSES\nFOR EACH ROW\nBEGIN\n    -- Handle date validation\n    IF TO_DATE(:NEW.DATE_FROM, 'YYYY-MM-DD HH24:MI:SS') > TO_DATE(:NEW.DATE_TO, 'YYYY-MM-DD HH24:MI:SS') THEN\n        :NEW.DATE_TO := :NEW.DATE_FROM;\n    END IF;\n    \n    -- Always generate ADDRESS_ID if NULL\n    IF :NEW.ADDRESS_ID IS NULL THEN\n        SELECT NVL(MAX(ADDRESS_ID), 0) + 1 INTO :NEW.ADDRESS_ID FROM CUSTOMER_ADDRESSES;\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ADDRESSES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (15, NULL, '2024-01-01 10:00:00', '2023-12-31 10:00:00')",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (20, '2024-05-01 08:30:00', '2024-05-10 18:45:00')",
      "UPDATE CUSTOMER_ADDRESSES SET DATE_FROM = '2024-06-15 12:00:00', DATE_TO = '2024-06-01 12:00:00' WHERE CUSTOMER_ID = 2 AND ADDRESS_ID = 9",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM) VALUES (25, '2024-07-01 00:00:00')",
      "UPDATE CUSTOMER_ADDRESSES SET DATE_TO = '2024-03-01 09:00:00' WHERE CUSTOMER_ID = 10 AND ADDRESS_ID = 8"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_CUST_ADDR_BIU on the CUSTOMER_ADDRESSES table. For each row: 1) If DATE_FROM (converted to DATE with format 'YYYY-MM-DD HH24:MI:SS') is later than DATE_TO (similarly converted), set DATE_TO equal to DATE_FROM. 2) If ADDRESS_ID is NULL, set it to the maximum existing ADDRESS_ID plus 1 (or 1 if the table is empty).",
    "natural_language": "Construct a row-level trigger called TRG_CUST_ADDR_BIU, which is designed to activate before any insert or update operation on the CUSTOMER_ADDRESSES table. For every individual row being processed, the trigger must perform two detailed checks: firstly, it should carefully compare the DATE_FROM and DATE_TO values, after converting each to a standard DATE format of 'YYYY-MM-DD HH24:MI:SS'. If it finds that the converted DATE_FROM is chronologically later than the converted DATE_TO, it must automatically correct this by setting the DATE_TO to be exactly equal to DATE_FROM. Secondly, it must thoroughly examine the ADDRESS_ID field; if this field is discovered to be NULL, the trigger should dynamically calculate a new value by taking the maximum ADDRESS_ID currently present in the entire table and incrementing it by one, or simply assigning the value 1 if the table is completely empty at that moment.",
    "id": 127
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_CUST_ADDR_BI` that is configured to execute `BEFORE` an `INSERT` operation occurs on the `CUSTOMER_ADDRESSES` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will execute once for every row being inserted into the `CUSTOMER_ADDRESSES` table. The primary purpose of this trigger is to automatically generate a unique `ADDRESS_ID` for each new row being inserted.\n\nUpon activation for a new row, the trigger declares a local variable named `v_max_id` of data type `NUMBER`. Inside an anonymous PL/SQL block, the trigger then executes a `SELECT` statement to retrieve the maximum existing value from the `ADDRESS_ID` column within the `CUSTOMER_ADDRESSES` table. This maximum value is then stored into the `v_max_id` variable.\n\nFollowing this, the trigger assigns a value to the `ADDRESS_ID` column of the new row being inserted. This assignment uses the `:NEW` pseudorecord, which represents the row currently being inserted. The value assigned to `:NEW.ADDRESS_ID` is calculated by taking the value of `v_max_id`, applying the `NVL` function to it to handle cases where `v_max_id` might be `NULL` (meaning no records exist in `CUSTOMER_ADDRESSES` yet, in which case `NVL` will return `0`), and then adding `1` to the result. This ensures that the new `ADDRESS_ID` is always one greater than the current maximum `ADDRESS_ID` in the table, or `1` if the table is empty.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CUST_ADDR_BI\nBEFORE INSERT ON CUSTOMER_ADDRESSES\nFOR EACH ROW\nBEGIN\n    DECLARE\n        v_max_id NUMBER;\n    BEGIN\n        SELECT MAX(ADDRESS_ID) INTO v_max_id FROM CUSTOMER_ADDRESSES;\n        :NEW.ADDRESS_ID := NVL(v_max_id, 0) + 1;\n    END;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ADDRESSES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (3, '2023-01-01 10:00:00', '2023-12-31 23:59:59')",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (4, '2023-02-01 10:00:00', '2023-11-30 23:59:59')",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (5, '2023-03-01 10:00:00', '2023-10-31 23:59:59')",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (6, '2023-04-01 10:00:00', '2023-09-30 23:59:59')",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (7, '2023-05-01 10:00:00', '2023-08-31 23:59:59')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_CUST_ADDR_BI on the CUSTOMER_ADDRESSES table. For each new row, if ADDRESS_ID is NULL, set it to the maximum existing ADDRESS_ID plus 1 (or 1 if the table is empty).",
    "natural_language": "Create a row-level trigger called TRG_CUST_ADDR_BI that fires BEFORE INSERT on the CUSTOMER_ADDRESSES table. For each new row, if the ADDRESS_ID is NULL, assign it a value equal to the highest current ADDRESS_ID plus one, or set it to 1 if the table is empty.",
    "id": 128
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_audit_job_change` that is activated `AFTER` an `UPDATE` operation specifically on the `JOB_ID` column of the `EMPLOYEES` table. This trigger is configured to execute `FOR EACH ROW` that is affected by such an update. Upon activation, the trigger first declares a local PL/SQL variable named `v_job_title` of data type `VARCHAR2` with a maximum length of 255 characters. Subsequently, it performs a `SELECT` operation to retrieve the `JOB_TITLE` from the `JOBS` table. The `JOB_TITLE` value corresponding to the `JOB_ID` that the `EMPLOYEE` is being updated to (represented by `:NEW.JOB_ID`) is fetched and stored into the `v_job_title` variable. Following this, an `INSERT` operation is executed to add a new record into the `JOB_HISTORY` table. The values inserted into the `JOB_HISTORY` table are as follows: the `EMPLOYEE_ID` from the `OLD` state of the `EMPLOYEES` table row (before the update, represented by `:OLD.EMPLOYEE_ID`) is inserted into the `EMPLOYEE_ID` column; the `HIRE_DATE` from the `OLD` state of the `EMPLOYEES` table row (represented by `:OLD.HIRE_DATE`) is inserted into the `START_DATE` column; the current system date and time (obtained using the `SYSDATE` function) is inserted into the `END_DATE` column; the `JOB_ID` from the `OLD` state of the `EMPLOYEES` table row (represented by `:OLD.JOB_ID`) is inserted into the `JOB_ID` column; and the `DEPARTMENT_ID` from the `OLD` state of the `EMPLOYEES` table row (represented by `:OLD.DEPARTMENT_ID`) is inserted into the `DEPARTMENT_ID` column. This sequence of operations effectively records the previous job details of an employee into the `JOB_HISTORY` table whenever their `JOB_ID` is changed in the `EMPLOYEES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_audit_job_change\nAFTER UPDATE OF JOB_ID ON EMPLOYEES\nFOR EACH ROW\nDECLARE\n  v_job_title VARCHAR2(255);\nBEGIN\n  SELECT JOB_TITLE INTO v_job_title FROM JOBS WHERE JOB_ID = :NEW.JOB_ID;\n  INSERT INTO JOB_HISTORY (EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)\n  VALUES (:OLD.EMPLOYEE_ID, :OLD.HIRE_DATE, SYSDATE, :OLD.JOB_ID, :OLD.DEPARTMENT_ID);\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "UPDATE EMPLOYEES SET JOB_ID = 'AD_VP' WHERE EMPLOYEE_ID = 100",
      "UPDATE EMPLOYEES SET JOB_ID = 'AD_ASST' WHERE EMPLOYEE_ID = 101",
      "UPDATE EMPLOYEES SET JOB_ID = 'AD_PRES' WHERE EMPLOYEE_ID = 102"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_audit_job_change on the EMPLOYEES table, firing only when the JOB_ID column is updated. For each updated row: fetch the JOB_TITLE for the new JOB_ID from the JOBS table. Then insert a record into JOB_HISTORY with :OLD.EMPLOYEE_ID, :OLD.HIRE_DATE as START_DATE, SYSDATE as END_DATE, :OLD.JOB_ID, and :OLD.DEPARTMENT_ID.",
    "natural_language": "Alright, so we need a trigger that kicks in after someone updates a row in the EMPLOYEES table, but only if they actually change the JOB_ID. Let's call it trg_audit_job_change. When that happens, grab the JOB_TITLE for the new job from the JOBS table. Then, just toss a new record into the JOB_HISTORY table using the old employee's ID, their original hire date as the start, today's date as the end, plus their old job and department IDs.",
    "id": 129
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_location_city that is executed after an insert operation on the DEPARTMENTS table for each row affected by the insert. The trigger begins by declaring three local variables: v_city of type VARCHAR2(255), v_location_exists of type NUMBER, and v_new_location_id of type NUMBER. The trigger first performs a SELECT COUNT(*) operation to determine if a location with the LOCATION_ID matching the newly inserted department's LOCATION_ID already exists in the LOCATIONS table, storing the result in v_location_exists. If v_location_exists equals 0, indicating that the location does not exist, the trigger proceeds to create a new city name by concatenating the first five characters of the newly inserted department's DEPARTMENT_NAME with the string '_LOC', storing this result in v_city. The trigger then checks if the LOCATION_ID from the newly inserted department is NULL. If it is NULL, the trigger generates a new unique LOCATION_ID by selecting the maximum LOCATION_ID from the LOCATIONS table, adding 1 to it, and storing the result in v_new_location_id. If the LOCATION_ID is not NULL, the trigger assigns the department's LOCATION_ID to v_new_location_id. Subsequently, the trigger inserts a new row into the LOCATIONS table with the following values: v_new_location_id for LOCATION_ID, 'AUTO_GEN' for STREET_ADDRESS, '00000' for POSTAL_CODE, v_city for CITY, NULL for STATE_PROVINCE, and 'US' for COUNTRY_ID. The trigger includes an exception handler for the DUP_VAL_ON_INDEX exception, which occurs if there is a duplicate key issue during the insert operation, and handles this exception silently by doing nothing.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_location_city\nAFTER INSERT ON DEPARTMENTS\nFOR EACH ROW\nDECLARE\n  v_city VARCHAR2(255);\n  v_location_exists NUMBER;\n  v_new_location_id NUMBER;\nBEGIN\n  -- Check if the location already exists\n  SELECT COUNT(*)\n  INTO v_location_exists\n  FROM LOCATIONS\n  WHERE LOCATION_ID = :NEW.LOCATION_ID;\n  \n  -- Only insert if location doesn't exist\n  IF v_location_exists = 0 THEN\n    v_city := SUBSTR(:NEW.DEPARTMENT_NAME, 1, 5) || '_LOC';\n    \n    -- Generate a new unique location ID if the one from department is null or conflicts\n    IF :NEW.LOCATION_ID IS NULL THEN\n      SELECT NVL(MAX(LOCATION_ID), 0) + 1\n      INTO v_new_location_id\n      FROM LOCATIONS;\n    ELSE\n      v_new_location_id := :NEW.LOCATION_ID;\n    END IF;\n    \n    INSERT INTO LOCATIONS (LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID)\n    VALUES (v_new_location_id, 'AUTO_GEN', '00000', v_city, NULL, 'US');\n  END IF;\nEXCEPTION\n  WHEN DUP_VAL_ON_INDEX THEN\n    -- Handle any remaining duplicate key issues silently\n    NULL;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (40, 'Human Resources', 2000)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (50, 'Research', NULL)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME) VALUES (60, 'Development')",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (70, 'Quality Assurance', 1700)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (80, 'Sales', 9999)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_maintain_location_city on the DEPARTMENTS table. For each new row: check if its LOCATION_ID exists in the LOCATIONS table. If not, create a city name from the first five characters of DEPARTMENT_NAME plus '_LOC'. If the department's LOCATION_ID is NULL, generate a new ID as max(LOCATION_ID)+1; otherwise, use it. Insert a new location into LOCATIONS with the generated/found ID, 'AUTO_GEN' street, '00000' postal code, the created city, NULL state, and 'US' country. Handle duplicate key errors silently.",
    "natural_language": "Create a row-level trigger named trg_maintain_location_city that fires AFTER INSERT on the DEPARTMENTS table. For each new row, first check if its LOCATION_ID exists in the LOCATIONS table. If it does not exist, construct a city name by taking the first five characters of the DEPARTMENT_NAME and appending '_LOC'. If the department's LOCATION_ID is NULL, generate a new ID by taking the maximum existing LOCATION_ID and adding one; otherwise, use the provided LOCATION_ID. Then, insert a new row into the LOCATIONS table using the generated or existing LOCATION_ID, with 'AUTO_GEN' for the street address, '00000' for the postal code, the constructed city name, NULL for the state, and 'US' for the country ID. Ensure any duplicate key errors are handled silently without raising an exception.",
    "id": 130
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_sync_manager_department` that is activated `AFTER` an `UPDATE` operation specifically on the `MANAGER_ID` column of the `DEPARTMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is affected by the `UPDATE` statement. Upon activation, the trigger first declares a local variable named `v_employee_count` of data type `NUMBER`. Subsequently, it executes a `SELECT` statement to `COUNT` the total number of rows in the `EMPLOYEES` table where the `DEPARTMENT_ID` column matches the `DEPARTMENT_ID` of the row currently being updated in the `DEPARTMENTS` table (referred to as `:NEW.DEPARTMENT_ID`). The result of this `COUNT` operation is then stored into the `v_employee_count` variable. Following this, the trigger performs an `UPDATE` operation on the `EMPLOYEES` table. In this `UPDATE` operation, it sets the value of the `MANAGER_ID` column for all rows in the `EMPLOYEES` table to the new `MANAGER_ID` value of the updated department (referred to as `:NEW.MANAGER_ID`). This `UPDATE` is applied only to those rows in the `EMPLOYEES` table where the `DEPARTMENT_ID` column matches the `DEPARTMENT_ID` of the row currently being updated in the `DEPARTMENTS` table (referred to as `:NEW.DEPARTMENT_ID`). The trigger concludes its execution after this `UPDATE` statement.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_manager_department\nAFTER UPDATE OF MANAGER_ID ON DEPARTMENTS\nFOR EACH ROW\nDECLARE\n  v_employee_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_employee_count FROM EMPLOYEES WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\n  UPDATE EMPLOYEES SET MANAGER_ID = :NEW.MANAGER_ID WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "UPDATE DEPARTMENTS SET MANAGER_ID = 200 WHERE DEPARTMENT_ID = 10",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 201 WHERE DEPARTMENT_ID = 20",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 114 WHERE DEPARTMENT_ID = 30",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 100 WHERE DEPARTMENT_ID = 10",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 200 WHERE DEPARTMENT_ID = 20"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_sync_manager_department on the DEPARTMENTS table that fires when MANAGER_ID is updated. The trigger should count employees in the matching department, then update all employees in that department to have the new manager ID.",
    "natural_language": "Create trigger trg_sync_manager_department on DEPARTMENTS after update of MANAGER_ID. For each row, count the department's employees and set their manager to the new ID.",
    "id": 131
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_archive_employee that fires automatically after each row is deleted from the EMPLOYEES table, and within its execution block, it first declares a local variable v_department_name of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the DEPARTMENTS table to retrieve the DEPARTMENT_NAME column value where the DEPARTMENT_ID column matches the deleted row's original DEPARTMENT_ID value (accessed via the :OLD.DEPARTMENT_ID pseudorecord), storing the result into the v_department_name variable, and subsequently performs an INSERT operation into the JOB_HISTORY table, populating the EMPLOYEE_ID column with the deleted row's original EMPLOYEE_ID (:OLD.EMPLOYEE_ID), the START_DATE column with the deleted row's original HIRE_DATE (:OLD.HIRE_DATE), the END_DATE column with the current system date and time (SYSDATE), the JOB_ID column with the deleted row's original JOB_ID (:OLD.JOB_ID), and the DEPARTMENT_ID column with the deleted row's original DEPARTMENT_ID (:OLD.DEPARTMENT_ID).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_archive_employee\nAFTER DELETE ON EMPLOYEES\nFOR EACH ROW\nDECLARE\n  v_department_name VARCHAR2(255);\nBEGIN\n  SELECT DEPARTMENT_NAME INTO v_department_name FROM DEPARTMENTS WHERE DEPARTMENT_ID = :OLD.DEPARTMENT_ID;\n  INSERT INTO JOB_HISTORY (EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)\n  VALUES (:OLD.EMPLOYEE_ID, :OLD.HIRE_DATE, SYSDATE, :OLD.JOB_ID, :OLD.DEPARTMENT_ID);\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 100",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 101",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 102",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 103",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 104"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_archive_employee on the EMPLOYEES table. The trigger should retrieve the department name for the deleted employee and insert a record into the JOB_HISTORY table with the employee's details, using SYSDATE for the end date.",
    "natural_language": "Create AFTER DELETE trigger trg_archive_employee on EMPLOYEES. For each deleted row, get its department name and insert employee details with SYSDATE as end date into JOB_HISTORY.",
    "id": 132
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_validate_salary_range` that is configured to execute `BEFORE` any `INSERT` or `UPDATE` operation on the `EMPLOYEES` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row affected by the triggering DML statement. Upon activation, the trigger declares two local `NUMBER` variables: `v_min_salary` and `v_max_salary`. The first operation performed within the trigger's `BEGIN` block is a `SELECT` statement. This `SELECT` statement retrieves the `MIN_SALARY` and `MAX_SALARY` column values from the `JOBS` table. The retrieved `MIN_SALARY` value is then assigned to the `v_min_salary` variable, and the retrieved `MAX_SALARY` value is assigned to the `v_max_salary` variable. The `WHERE` clause of this `SELECT` statement specifies a condition: `JOB_ID = :NEW.JOB_ID`. This condition ensures that the salary range is fetched specifically for the job associated with the row currently being inserted or updated in the `EMPLOYEES` table, where `:NEW.JOB_ID` refers to the `JOB_ID` value of the new or updated row in the `EMPLOYEES` table. Following this data retrieval, the trigger performs an assignment operation on the `:NEW.SALARY` column. The `:NEW.SALARY` value, which represents the salary of the row currently being inserted or updated in the `EMPLOYEES` table, is set to the result of a nested function call. The inner function call is `GREATEST(:NEW.SALARY, v_min_salary)`. This `GREATEST` function returns the larger of the current `:NEW.SALARY` value and the `v_min_salary` value. The result of this `GREATEST` function is then passed as the first argument to the outer `LEAST` function: `LEAST(GREATEST(:NEW.SALARY, v_min_salary), v_max_salary)`. This `LEAST` function returns the smaller of its two arguments, which are the result of the `GREATEST` function (ensuring the salary is not below the minimum) and the `v_max_salary` value (ensuring the salary is not above the maximum). In essence, this operation clamps the `:NEW.SALARY` value to be within the range defined by `v_min_salary` and `v_max_salary` for the employee's specific job. If the original `:NEW.SALARY` is less than `v_min_salary`, it will be set to `v_min_salary`. If the original `:NEW.SALARY` is greater than `v_max_salary`, it will be set to `v_max_salary`. If the original `:NEW.SALARY` is already within the valid range, it will remain unchanged. This modified `:NEW.SALARY` value is then used for the actual `INSERT` or `UPDATE` operation on the `EMPLOYEES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_salary_range\nBEFORE INSERT OR UPDATE ON EMPLOYEES\nFOR EACH ROW\nDECLARE\n  v_min_salary NUMBER;\n  v_max_salary NUMBER;\nBEGIN\n  SELECT MIN_SALARY, MAX_SALARY INTO v_min_salary, v_max_salary FROM JOBS WHERE JOB_ID = :NEW.JOB_ID;\n  :NEW.SALARY := LEAST(GREATEST(:NEW.SALARY, v_min_salary), v_max_salary);\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (103, 'John', 'Doe', 'JDOE', '515.123.4570', '2023-10-01', 'AD_PRES', 25000, 0, 100, 90)",
      "INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (104, 'Jane', 'Smith', 'JSMITH', '515.123.4571', '2023-10-02', 'AD_VP', 16000, 0, 101, 90)",
      "UPDATE EMPLOYEES SET SALARY = 18000 WHERE EMPLOYEE_ID = 100",
      "UPDATE EMPLOYEES SET SALARY = 35000 WHERE EMPLOYEE_ID = 101",
      "INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (105, 'Alice', 'Johnson', 'AJOHNSON', '515.123.4572', '2023-10-03', 'AD_ASST', 5000, 0, 102, 90)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_validate_salary_range on the EMPLOYEES table. The trigger should fetch the minimum and maximum salary for the employee's job from the JOBS table, then clamp the new salary value to ensure it falls within that valid range.",
    "natural_language": "Set up a trigger on the EMPLOYEES table that runs before adding or changing a record. It should be called something like trg_validate_salary_range. The idea is to look up the typical low and high pay for that type of job from the JOBS list and then adjust the new salary figure to be somewhere reasonable within those general bounds.",
    "id": 133
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_resident_cleanup that is executed before a delete operation on the RESIDENTS table for each row being deleted. The trigger begins by declaring a local variable v_event_count of type NUMBER to store the count of related records. It then performs a SELECT operation to count the number of records in the CUSTOMER_EVENTS table where the RESIDENT_ID column matches the RESIDENT_ID of the row being deleted from the RESIDENTS table, storing this count in v_event_count. Following this, the trigger executes a DELETE operation on the CUSTOMER_EVENT_NOTES table to remove records where the CUSTOMER_EVENT_ID column matches any CUSTOMER_EVENT_ID from the CUSTOMER_EVENTS table that has the same RESIDENT_ID as the row being deleted. This is achieved using a subquery that selects CUSTOMER_EVENT_ID from CUSTOMER_EVENTS where RESIDENT_ID equals :OLD.RESIDENT_ID, which refers to the RESIDENT_ID of the row being deleted. Subsequently, the trigger performs another DELETE operation on the CUSTOMER_EVENT_NOTES table to remove records directly where the RESIDENT_ID column matches :OLD.RESIDENT_ID. Finally, the trigger deletes records from the CUSTOMER_EVENTS table where the RESIDENT_ID column matches :OLD.RESIDENT_ID, effectively cleaning up all related records in both CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables before the deletion of the row in the RESIDENTS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_resident_cleanup\nBEFORE DELETE ON RESIDENTS\nFOR EACH ROW\nDECLARE\n   v_event_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_event_count FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :OLD.RESIDENT_ID;\n   \n   -- Delete child records first - CUSTOMER_EVENT_NOTES that reference CUSTOMER_EVENTS to be deleted\n   DELETE FROM CUSTOMER_EVENT_NOTES \n   WHERE CUSTOMER_EVENT_ID IN (\n       SELECT CUSTOMER_EVENT_ID \n       FROM CUSTOMER_EVENTS \n       WHERE RESIDENT_ID = :OLD.RESIDENT_ID\n   );\n   \n   -- Also delete CUSTOMER_EVENT_NOTES directly by RESIDENT_ID\n   DELETE FROM CUSTOMER_EVENT_NOTES WHERE RESIDENT_ID = :OLD.RESIDENT_ID;\n   \n   -- Now delete parent records - CUSTOMER_EVENTS\n   DELETE FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :OLD.RESIDENT_ID;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "THINGS",
      "TIMED_LOCATIONS_OF_THINGS"
    ],
    "call_sqls": [
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 6",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 10",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 23",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 28",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 37"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_resident_cleanup on the RESIDENTS table. The trigger should first count related events, then delete all associated records from CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables where the RESIDENT_ID matches the deleted resident.",
    "natural_language": "Before deleting a resident, count their related events and remove all associated records from the CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables. Implement this logic in a BEFORE DELETE FOR EACH ROW trigger named trg_resident_cleanup on the RESIDENTS table.",
    "id": 134
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_thing_service_sync that is defined to fire automatically after each row is updated on the THINGS table, and within its body, it executes a DELETE operation on the TIMED_LOCATIONS_OF_THINGS table where the condition requires that the THING_ID column value in the TIMED_LOCATIONS_OF_THINGS table matches the new THING_ID value from the updated row in the THINGS table, which is referenced as :NEW.THING_ID, and simultaneously requires that the LOCATION_CODE column value in the TIMED_LOCATIONS_OF_THINGS table begins with the string 'Temp' as enforced by the LIKE 'Temp%' operator.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_thing_service_sync\nAFTER UPDATE ON THINGS\nFOR EACH ROW\nBEGIN\n   -- The original INSERT statement relied on a sequence 'CUSTOMER_EVENT_NOTES_SEQ'\n   -- which is not defined in the provided schema.\n   -- Without a defined sequence or an alternative method to generate CUSTOMER_EVENT_NOTE_ID,\n   -- this insert will cause a compilation error.\n   -- For the purpose of fixing the ORA-04098, this statement is removed.\n   -- If a sequence is intended, it must be created first.\n   -- INSERT INTO CUSTOMER_EVENT_NOTES (CUSTOMER_EVENT_NOTE_ID, SERVICE_TYPE_CODE, DATE_MOVED_IN)\n   -- VALUES (CUSTOMER_EVENT_NOTES_SEQ.NEXTVAL, :NEW.SERVICE_TYPE_CODE, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n\n   -- The v_service_json variable and its assignment were not used, so they are removed.\n\n   DELETE FROM TIMED_LOCATIONS_OF_THINGS WHERE THING_ID = :NEW.THING_ID AND LOCATION_CODE LIKE 'Temp%';\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "THINGS",
      "TIMED_LOCATIONS_OF_THINGS"
    ],
    "call_sqls": [
      "UPDATE THINGS SET SERVICE_TYPE_CODE = 'Check' WHERE THING_ID = 1",
      "UPDATE THINGS SET SERVICE_DETAILS = 'Satisfied' WHERE THING_ID = 2",
      "UPDATE THINGS SET ORGANIZATION_ID = 9 WHERE THING_ID = 10",
      "UPDATE THINGS SET TYPE_OF_THING_CODE = 'Furniture' WHERE THING_ID = 14",
      "UPDATE THINGS SET SERVICE_TYPE_CODE = 'Cleanning' WHERE THING_ID = 80"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_thing_service_sync on the THINGS table. The trigger should delete records from the TIMED_LOCATIONS_OF_THINGS table where the THING_ID matches the updated thing and the LOCATION_CODE starts with 'Temp'.",
    "natural_language": "Set up a trigger on the THINGS table that runs after updates, named something like trg_thing_service_sync. It should generally clean up some old or temporary location records in the TIMED_LOCATIONS_OF_THINGS table for the updated item, specifically where the location code seems to be temporary or starts with something like 'Temp'.",
    "id": 135
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT FOR EACH ROW` trigger named `trg_location_history` on the `TIMED_LOCATIONS_OF_THINGS` table. This trigger executes after each row is successfully inserted into the `TIMED_LOCATIONS_OF_THINGS` table. For each newly inserted row, the trigger performs the following sequence of operations:\n\nFirst, it declares four local PL/SQL variables: `v_thing_type` of type `VARCHAR2(100)`, `v_customer_event_id` of type `NUMBER`, `v_resident_id` of type `NUMBER`, and `v_property_id` of type `NUMBER`.\n\nNext, it attempts to retrieve the `TYPE_OF_THING_CODE` from the `THINGS` table. It executes a `SELECT` statement to fetch the `TYPE_OF_THING_CODE` into the `v_thing_type` variable, using the `THING_ID` from the newly inserted row (`:NEW.THING_ID`) as the join condition. If no data is found for the given `THING_ID` in the `THINGS` table, it catches the `NO_DATA_FOUND` exception and assigns the string literal 'Unknown' to `v_thing_type`. This retrieved `v_thing_type` is declared but not subsequently used in the trigger's logic.\n\nFollowing this, it attempts to retrieve specific event-related identifiers from the `CUSTOMER_EVENTS` table. It executes a `SELECT` statement to fetch the minimum `CUSTOMER_EVENT_ID`, minimum `RESIDENT_ID`, and minimum `PROPERTY_ID` into the `v_customer_event_id`, `v_resident_id`, and `v_property_id` variables, respectively. The selection is filtered by matching the `THING_ID` from the newly inserted row (`:NEW.THING_ID`) with the `THING_ID` in the `CUSTOMER_EVENTS` table. If no data is found for the given `THING_ID` in the `CUSTOMER_EVENTS` table, it catches the `NO_DATA_FOUND` exception and assigns the numeric literal `1` to `v_customer_event_id`, `v_resident_id`, and `v_property_id`.\n\nSubsequently, it inserts a new record into the `CUSTOMER_EVENT_NOTES` table. The `INSERT` statement populates the following columns:\n- `CUSTOMER_EVENT_NOTE_ID`: This column is populated by a subquery that calculates `NVL(MAX(CUSTOMER_EVENT_NOTE_ID), 0) + 1` from the `CUSTOMER_EVENT_NOTES` table, effectively generating a new sequential ID.\n- `CUSTOMER_EVENT_ID`: This column is populated with the value stored in the `v_customer_event_id` variable.\n- `SERVICE_TYPE_CODE`: This column is populated with the string literal 'Location'.\n- `RESIDENT_ID`: This column is populated with the value stored in the `v_resident_id` variable.\n- `PROPERTY_ID`: This column is populated with the value stored in the `v_property_id` variable.\n- `DATE_MOVED_IN`: This column is populated with the `DATE_AND_TIME` value from the newly inserted row (`:NEW.DATE_AND_TIME`).\n\nFinally, it performs a cleanup operation on the `CUSTOMER_EVENT_NOTES` table. It executes a `DELETE` statement to remove records from `CUSTOMER_EVENT_NOTES` where the `SERVICE_TYPE_CODE` is equal to the string literal 'Old_Location' AND the `DATE_MOVED_IN` column's value is less than the `DATE_AND_TIME` value from the newly inserted row (`:NEW.DATE_AND_TIME`).\n\nThe entire trigger logic is enclosed within an exception block that catches `WHEN OTHERS` exceptions. If any unhandled exception occurs during the execution of the trigger, it executes a `NULL` statement, effectively ignoring the error without logging or specific handling.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_location_history\nAFTER INSERT ON TIMED_LOCATIONS_OF_THINGS\nFOR EACH ROW\nDECLARE\n   v_thing_type VARCHAR2(100);\n   v_customer_event_id NUMBER;\n   v_resident_id NUMBER;\n   v_property_id NUMBER;\nBEGIN\n   -- Get thing type (keeping original logic even though unused)\n   BEGIN\n      SELECT TYPE_OF_THING_CODE INTO v_thing_type \n      FROM THINGS \n      WHERE THING_ID = :NEW.THING_ID;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         v_thing_type := 'Unknown';\n   END;\n   \n   -- Get required values for the insert\n   BEGIN\n      SELECT MIN(CUSTOMER_EVENT_ID), MIN(RESIDENT_ID), MIN(PROPERTY_ID)\n      INTO v_customer_event_id, v_resident_id, v_property_id\n      FROM CUSTOMER_EVENTS\n      WHERE THING_ID = :NEW.THING_ID;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         v_customer_event_id := 1;\n         v_resident_id := 1;\n         v_property_id := 1;\n   END;\n   \n   -- Insert with all required columns\n   INSERT INTO CUSTOMER_EVENT_NOTES (\n      CUSTOMER_EVENT_NOTE_ID, \n      CUSTOMER_EVENT_ID,\n      SERVICE_TYPE_CODE, \n      RESIDENT_ID,\n      PROPERTY_ID,\n      DATE_MOVED_IN\n   ) VALUES (\n      (SELECT NVL(MAX(CUSTOMER_EVENT_NOTE_ID), 0) + 1 FROM CUSTOMER_EVENT_NOTES),\n      v_customer_event_id,\n      'Location', \n      v_resident_id,\n      v_property_id,\n      :NEW.DATE_AND_TIME\n   );\n   \n   -- Clean up old location records\n   DELETE FROM CUSTOMER_EVENT_NOTES \n   WHERE SERVICE_TYPE_CODE = 'Old_Location' \n   AND DATE_MOVED_IN < :NEW.DATE_AND_TIME;\n   \nEXCEPTION\n   WHEN OTHERS THEN\n      -- Log error or handle as needed\n      NULL;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "THINGS",
      "TIMED_LOCATIONS_OF_THINGS"
    ],
    "call_sqls": [
      "INSERT INTO TIMED_LOCATIONS_OF_THINGS (THING_ID, DATE_AND_TIME, LOCATION_CODE) VALUES (1, '2023-01-01 10:00:00', 'New Location A')",
      "INSERT INTO TIMED_LOCATIONS_OF_THINGS (THING_ID, DATE_AND_TIME, LOCATION_CODE) VALUES (80, '2023-01-02 11:30:00', 'New Location B')",
      "INSERT INTO TIMED_LOCATIONS_OF_THINGS (THING_ID, DATE_AND_TIME, LOCATION_CODE) VALUES (14, '2023-01-03 14:15:00', 'New Location C')",
      "INSERT INTO TIMED_LOCATIONS_OF_THINGS (THING_ID, DATE_AND_TIME, LOCATION_CODE) VALUES (2, '2023-01-04 09:00:00', 'New Location D')",
      "INSERT INTO TIMED_LOCATIONS_OF_THINGS (THING_ID, DATE_AND_TIME, LOCATION_CODE) VALUES (10, '2023-01-05 16:45:00', 'New Location E')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_location_history on the TIMED_LOCATIONS_OF_THINGS table. For each new row, retrieve the minimum CUSTOMER_EVENT_ID, RESIDENT_ID, and PROPERTY_ID from the CUSTOMER_EVENTS table using the new THING_ID, defaulting to 1 if not found. Insert a new record into CUSTOMER_EVENT_NOTES with a generated sequential ID, the retrieved values, 'Location' as SERVICE_TYPE_CODE, and the new DATE_AND_TIME as DATE_MOVED_IN. Then, delete records from CUSTOMER_EVENT_NOTES where SERVICE_TYPE_CODE is 'Old_Location' and DATE_MOVED_IN is older than the new DATE_AND_TIME. Handle all exceptions silently.",
    "natural_language": "Set up a trigger on the TIMED_LOCATIONS_OF_THINGS table that runs after new entries are added. For each new entry, it should look up some related details from the CUSTOMER_EVENTS table using the new THING_ID, picking the smallest IDs available or just using 1 if nothing turns up. Then, it should add a note about the location into the CUSTOMER_EVENT_NOTES table with a new ID, those details, and the new time as the move-in date. Also, get rid of any old location notes that seem to be from before this new time. If anything goes wrong during this, just don't make a fuss about it.",
    "id": 136
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_customer_consolidation that is executed before a delete operation on the CUSTOMERS table for each row that is about to be deleted. The trigger declares a local variable v_total_events of type NUMBER to store the count of related events. It begins by performing a SELECT statement to count the number of rows in the CUSTOMER_EVENTS table where the CUSTOMER_ID column matches the CUSTOMER_ID of the row being deleted from the CUSTOMERS table, storing this count in the v_total_events variable. Next, it executes a DELETE statement on the CUSTOMER_EVENT_NOTES table to remove all rows where the CUSTOMER_EVENT_ID column matches any CUSTOMER_EVENT_ID from the CUSTOMER_EVENTS table that has the same CUSTOMER_ID as the row being deleted. This is achieved by using a subquery that selects CUSTOMER_EVENT_ID from the CUSTOMER_EVENTS table where the CUSTOMER_ID matches the CUSTOMER_ID of the row being deleted. Finally, the trigger deletes all rows from the CUSTOMER_EVENTS table where the CUSTOMER_ID matches the CUSTOMER_ID of the row being deleted from the CUSTOMERS table. The trigger ensures that all related records in the CUSTOMER_EVENTS and CUSTOMER_EVENT_NOTES tables are removed before the deletion of a customer record from the CUSTOMERS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customer_consolidation\nBEFORE DELETE ON CUSTOMERS\nFOR EACH ROW\nDECLARE\n   v_total_events NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_total_events FROM CUSTOMER_EVENTS WHERE CUSTOMER_ID = :OLD.CUSTOMER_ID;\n   DELETE FROM CUSTOMER_EVENT_NOTES WHERE CUSTOMER_EVENT_ID IN (SELECT CUSTOMER_EVENT_ID FROM CUSTOMER_EVENTS WHERE CUSTOMER_ID = :OLD.CUSTOMER_ID);\n   DELETE FROM CUSTOMER_EVENTS WHERE CUSTOMER_ID = :OLD.CUSTOMER_ID;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "THINGS",
      "TIMED_LOCATIONS_OF_THINGS"
    ],
    "call_sqls": [
      "DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 4",
      "DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 5",
      "DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 16",
      "DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 19",
      "DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 1"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_customer_consolidation on the CUSTOMERS table. For the row being deleted, first delete all related records from CUSTOMER_EVENT_NOTES where the CUSTOMER_EVENT_ID matches any event for this customer. Then, delete all related records from the CUSTOMER_EVENTS table for this customer.",
    "natural_language": "Construct a BEFORE DELETE FOR EACH ROW trigger, which should be named trg_customer_consolidation, on the CUSTOMERS table. For the specific customer row that is about to be permanently removed, the trigger must first meticulously locate and delete every single associated record from the CUSTOMER_EVENT_NOTES table, specifically those where the CUSTOMER_EVENT_ID corresponds to any event that belongs to this particular customer. Subsequently, it must proceed to thoroughly eliminate all related entries for this customer from the CUSTOMER_EVENTS table.",
    "id": 137
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_country_uppercase` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `COUNTRY` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row that is being inserted into the `COUNTRY` table. Within the `DECLARE` section, a local PL/SQL variable named `v_upper_name` is declared, which is of data type `VARCHAR2` with a maximum length of 255 characters. The `BEGIN` block of the trigger first assigns a value to `v_upper_name` by calling the `UPPER()` SQL function. The `UPPER()` function takes a single string argument and returns that string with all alphabetic characters converted to uppercase. The argument passed to `UPPER()` is `:NEW.NAME`, which represents the value of the `NAME` column for the row currently being inserted, as it exists `BEFORE` the insert operation is finalized. Subsequently, the trigger modifies the value of the `NAME` column for the row currently being inserted by assigning the value stored in the `v_upper_name` variable to `:NEW.NAME`. This effectively ensures that the `NAME` column of any new row inserted into the `COUNTRY` table will have its value automatically converted to uppercase before the row is permanently stored in the table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_country_uppercase\nBEFORE INSERT ON COUNTRY\nFOR EACH ROW\nDECLARE\n  v_upper_name VARCHAR2(255);\nBEGIN\n  v_upper_name := UPPER(:NEW.NAME);\n  :NEW.NAME := v_upper_name;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'france', 67750000, 551695, 'French')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME) VALUES (5, 'germany')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'spain', 47450795, 505990, 'Spanish')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION) VALUES (7, 'italy', 60317116)",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, AREA, LANGUAGES) VALUES (8, 'portugal', 92212, 'Portuguese')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_country_uppercase on the COUNTRY table. Convert the new NAME column value to uppercase before insertion.",
    "natural_language": "Please implement a BEFORE INSERT FOR EACH ROW trigger, designated as trg_country_uppercase, for the COUNTRY table. This trigger must convert the value of the incoming NAME column to uppercase prior to its insertion.",
    "id": 138
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_country_validate that is executed before an insert or update operation on the COUNTRY table. This trigger operates for each row affected by the insert or update. It declares a local variable v_dummy of type NUMBER, which is used to temporarily store a value during the execution of a SELECT statement. The trigger performs a SELECT operation on the DUAL table, which is a special one-row, one-column table used for selecting a constant value. The SELECT statement checks if the new values being inserted or updated in the COUNTRY table have a POPULATION greater than 0 and an AREA greater than 0. If both conditions are true, the SELECT statement assigns the value 1 to the v_dummy variable. If either condition is false, the SELECT statement does not return any data, causing a NO_DATA_FOUND exception to be raised. The trigger handles this exception by invoking the RAISE_APPLICATION_ERROR procedure, which generates a custom error with the error code -20001 and the message 'Population and area must be positive'. This error prevents the insert or update operation from proceeding if the conditions are not met, ensuring that only rows with positive values for POPULATION and AREA are allowed in the COUNTRY table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_country_validate\nBEFORE INSERT OR UPDATE ON COUNTRY\nFOR EACH ROW\nDECLARE\n  v_dummy NUMBER;\nBEGIN\n  SELECT 1 INTO v_dummy FROM DUAL WHERE :NEW.POPULATION > 0 AND :NEW.AREA > 0;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Population and area must be positive');\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'France', 65273511, 551695, 'French')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (5, 'Germany', 83019200, 357022, 'German')",
      "UPDATE COUNTRY SET POPULATION = 10000000, AREA = 100000 WHERE COUNTRY_ID = 1",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'Spain', 0, 505990, 'Spanish')",
      "UPDATE COUNTRY SET POPULATION = 50000000, AREA = 0 WHERE COUNTRY_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_country_validate on the COUNTRY table. Validate that the new POPULATION and AREA values are both greater than 0. If not, raise an application error with code -20001 and message 'Population and area must be positive'.",
    "natural_language": "Construct a BEFORE INSERT OR UPDATE FOR EACH ROW trigger, which should be named trg_country_validate, specifically for the COUNTRY table. This trigger must thoroughly validate that the newly provided POPULATION and AREA values are each distinctly greater than 0. Should either of these crucial values fail to meet this essential positive requirement, the trigger must promptly raise a detailed application error, utilizing the specific error code -20001 along with the clear and instructive message: 'Population and area must be positive'.",
    "id": 139
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_course_author that is executed automatically after a new row is inserted into the COURSES table. This trigger operates for each row that is inserted. The trigger performs an insert operation into the COURSE_AUTHORS_AND_TUTORS table, specifically inserting values into the AUTHOR_ID and AUTHOR_TUTOR_ATB columns. The value inserted into the AUTHOR_ID column is derived from the newly inserted row in the COURSES table, specifically from the AUTHOR_ID column of the new row, accessed using the :NEW pseudorecord. The value inserted into the AUTHOR_TUTOR_ATB column is a constant string 'New Author'. This operation ensures that whenever a new course is added to the COURSES table, a corresponding entry is created in the COURSE_AUTHORS_AND_TUTORS table, associating the new author with the label 'New Author'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_course_author\nAFTER INSERT ON COURSES\nFOR EACH ROW\nBEGIN\n    INSERT INTO COURSE_AUTHORS_AND_TUTORS (AUTHOR_ID, AUTHOR_TUTOR_ATB)\n    VALUES (:NEW.AUTHOR_ID, 'New Author');\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (4, 8, 1, 'networking', 'networking basics')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (5, 6, 1, 'data structures', 'introduction to data structures')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (6, 15, 1, 'algorithms', 'basic algorithms')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (7, 8, 1, 'machine learning', 'intro to machine learning')",
      "INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION) VALUES (8, 6, 1, 'artificial intelligence', 'AI fundamentals')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_update_course_author on the COURSES table. For each new row, insert a record into the COURSE_AUTHORS_AND_TUTORS table using the new AUTHOR_ID and the constant string 'New Author' for the AUTHOR_TUTOR_ATB column.",
    "natural_language": "Set up a trigger on the COURSES table that runs after new entries are added. For each fresh record, it should put something into the COURSE_AUTHORS_AND_TUTORS table, using the new author's ID and a standard placeholder text like 'New Author' for the type of author role.",
    "id": 140
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_log_student_enrolment that is automatically executed after every successful insertion of a single row into the STUDENT_COURSE_ENROLMENT table, and for each newly inserted row, it performs an insert operation into the STUDENT_TESTS_TAKEN table, specifying values for three columns: it sets the REGISTRATION_ID column to the value of the REGISTRATION_ID column from the newly inserted row in STUDENT_COURSE_ENROLMENT (referenced via the :NEW.REGISTRATION_ID bind variable), it sets the DATE_TEST_TAKEN column to the current system date and time formatted as a string in the 'YYYY-MM-DD HH24:MI:SS' pattern using the TO_CHAR function with the SYSDATE function as its input, and it sets the TEST_RESULT column to the literal string value 'Pending'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_log_student_enrolment\nAFTER INSERT ON STUDENT_COURSE_ENROLMENT\nFOR EACH ROW\nBEGIN\n    INSERT INTO STUDENT_TESTS_TAKEN (REGISTRATION_ID, DATE_TEST_TAKEN, TEST_RESULT)\n    VALUES (:NEW.REGISTRATION_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'Pending');\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT) VALUES (101, 11, 2, '2024-01-15 10:30:00')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT) VALUES (102, 15, 4, '2024-01-16 14:45:00')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT) VALUES (103, 10, 8, '2024-01-17 09:15:00')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT) VALUES (104, 1, 1, '2024-01-18 11:20:00')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT) VALUES (105, 2, 3, '2024-01-19 16:00:00')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_log_student_enrolment on the STUDENT_COURSE_ENROLMENT table. For each new row, insert a record into the STUDENT_TESTS_TAKEN table. Set REGISTRATION_ID to :NEW.REGISTRATION_ID, DATE_TEST_TAKEN to the current system date formatted as 'YYYY-MM-DD HH24:MI:SS', and TEST_RESULT to 'Pending'.",
    "natural_language": "Construct an AFTER INSERT row-level trigger, which should be named trg_log_student_enrolment, on the STUDENT_COURSE_ENROLMENT table. For every single new row that is successfully inserted, you must meticulously insert a corresponding record into the STUDENT_TESTS_TAKEN table. Specifically, you should set the REGISTRATION_ID to the value from :NEW.REGISTRATION_ID, carefully assign the DATE_TEST_TAKEN to the precise current system date, which must be formatted exactly as 'YYYY-MM-DD HH24:MI:SS', and thoughtfully initialize the TEST_RESULT to the default status of 'Pending'.",
    "id": 141
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_student_tests that is defined to execute before a delete operation on the STUDENTS table for each individual row being deleted, and within its body performs a delete operation on the STUDENT_TESTS_TAKEN table where the condition is that the REGISTRATION_ID column value in STUDENT_TESTS_TAKEN must match any REGISTRATION_ID value found in a subquery that selects the REGISTRATION_ID column from the STUDENT_COURSE_ENROLMENT table for rows where the STUDENT_ID column equals the value of the :OLD.STUDENT_ID pseudo-record column, which represents the STUDENT_ID value from the STUDENTS table row that is currently in the process of being deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_student_tests\nBEFORE DELETE ON STUDENTS\nFOR EACH ROW\nBEGIN\n    DELETE FROM STUDENT_TESTS_TAKEN WHERE REGISTRATION_ID IN (\n        SELECT REGISTRATION_ID FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = :OLD.STUDENT_ID\n    );\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "DELETE FROM STUDENTS WHERE STUDENT_ID = 1",
      "DELETE FROM STUDENTS WHERE STUDENT_ID = 2",
      "DELETE FROM STUDENTS WHERE STUDENT_ID = 3",
      "DELETE FROM STUDENTS WHERE STUDENT_ID = 11",
      "DELETE FROM STUDENTS WHERE STUDENT_ID = 15"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_delete_student_tests on the STUDENTS table. For each row being deleted, delete from the STUDENT_TESTS_TAKEN table where its REGISTRATION_ID matches any REGISTRATION_ID in the STUDENT_COURSE_ENROLMENT table for rows where STUDENT_ID equals :OLD.STUDENT_ID.",
    "natural_language": "How can I create a BEFORE DELETE row-level trigger named trg_delete_student_tests on the STUDENTS table that, for each row being deleted, removes records from the STUDENT_TESTS_TAKEN table where its REGISTRATION_ID matches any REGISTRATION_ID in the STUDENT_COURSE_ENROLMENT table for rows where STUDENT_ID equals the :OLD.STUDENT_ID?",
    "id": 142
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_subject_course` that is defined to execute automatically after an `INSERT` operation is performed on the `SUBJECTS` table. This trigger is a row-level trigger, meaning it will execute once for each row that is inserted into the `SUBJECTS` table. Upon activation, the trigger performs a single `INSERT` operation into the `COURSES` table. The `INSERT` statement populates the `COURSE_ID`, `AUTHOR_ID`, `SUBJECT_ID`, `COURSE_NAME`, and `COURSE_DESCRIPTION` columns of the `COURSES` table. The value for the `COURSE_ID` column is determined by a subquery that first selects the maximum existing `COURSE_ID` from the `COURSES` table using the `MAX()` aggregate function. If no `COURSE_ID` exists (i.e., `MAX(COURSE_ID)` returns `NULL`), the `NVL()` function replaces `NULL` with `0`. This result is then incremented by `1` to generate a new, unique `COURSE_ID`. The `AUTHOR_ID` column is assigned a static numeric value of `1`. The `SUBJECT_ID` column is populated with the value of the `SUBJECT_ID` column from the newly inserted row in the `SUBJECTS` table, referenced using the `:NEW.SUBJECT_ID` pseudorecord. The `COURSE_NAME` column is assigned the static string literal `'New Course'`. Finally, the `COURSE_DESCRIPTION` column is assigned the static string literal `'Description'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_subject_course\nAFTER INSERT ON SUBJECTS\nFOR EACH ROW\nBEGIN\n    INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION)\n    VALUES ((SELECT NVL(MAX(COURSE_ID), 0) + 1 FROM COURSES), 1, :NEW.SUBJECT_ID, 'New Course', 'Description');\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (101, 'Mathematics')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (102, 'Physics')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (103, 'Chemistry')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (104, 'Biology')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (105, 'History')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_subject_course on the SUBJECTS table. For each new row, insert a record into the COURSES table. Set COURSE_ID to the maximum existing COURSE_ID plus one (starting at 1 if null), AUTHOR_ID to 1, SUBJECT_ID to :NEW.SUBJECT_ID, COURSE_NAME to 'New Course', and COURSE_DESCRIPTION to 'Description'.",
    "natural_language": "Alright, so we need a trigger that fires off after a new row is added to the SUBJECTS table. Name it 'trg_insert_subject_course'. Every time a new subject pops in, we gotta add a matching entry to the COURSES table. For that new course record, figure out the COURSE_ID by taking the highest one we already have and adding 1 to it (if there's none, just start at 1). Set the AUTHOR_ID to 1, grab the new SUBJECT_ID from the fresh row, call the COURSE_NAME 'New Course', and slap 'Description' into the COURSE_DESCRIPTION.",
    "id": 143
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_PAYMENT_VALIDATION` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `PAYMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being inserted into the `PAYMENTS` table. Within the `DECLARE` section, a local variable `v_settled_amount` of data type `NUMBER` is declared to temporarily store a retrieved settlement amount. The trigger's `BEGIN` block starts by executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `AMOUNT_SETTLED` column from the `SETTLEMENTS` table. The retrieved value is then immediately assigned to the `v_settled_amount` variable. The `WHERE` clause of this `SELECT` statement specifies that the row to be selected from the `SETTLEMENTS` table must have its `SETTLEMENT_ID` column value equal to the `SETTLEMENT_ID` column value of the new row being inserted into the `PAYMENTS` table, which is referenced by `:NEW.SETTLEMENT_ID`. Following this data retrieval, an `IF` conditional statement is evaluated. This `IF` statement checks if the value of the `AMOUNT_PAYMENT` column of the new row being inserted into the `PAYMENTS` table (referenced by `:NEW.AMOUNT_PAYMENT`) is strictly greater than the value stored in the `v_settled_amount` variable. If this condition evaluates to `TRUE`, then the code within the `IF` block is executed. Inside the `IF` block, the value of the `AMOUNT_PAYMENT` column of the new row being inserted into the `PAYMENTS` table (`:NEW.AMOUNT_PAYMENT`) is updated to be equal to the value stored in the `v_settled_amount` variable. This effectively caps the payment amount to the settled amount if the proposed payment exceeds it. The `IF` statement concludes, and then the trigger's `END` block is reached, completing its execution for the current row being inserted.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PAYMENT_VALIDATION\nBEFORE INSERT ON PAYMENTS\nFOR EACH ROW\nDECLARE\n    v_settled_amount NUMBER;\nBEGIN\n    SELECT AMOUNT_SETTLED INTO v_settled_amount FROM SETTLEMENTS WHERE SETTLEMENT_ID = :NEW.SETTLEMENT_ID;\n    IF :NEW.AMOUNT_PAYMENT > v_settled_amount THEN\n        :NEW.AMOUNT_PAYMENT := v_settled_amount;\n    END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (501, 476, 'Visa', '2023-10-01', 2000)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (502, 412, 'PayPal', '2023-10-02', 1500)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (503, 357, 'MasterCard', '2023-10-03', 2500)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (504, 476, 'American Express', '2023-10-04', 3000)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (505, 412, 'Discover', '2023-10-05', 1800)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_PAYMENT_VALIDATION on the PAYMENTS table. Declare a local variable v_settled_amount. Select the AMOUNT_SETTLED from the SETTLEMENTS table where SETTLEMENT_ID equals :NEW.SETTLEMENT_ID into v_settled_amount. If :NEW.AMOUNT_PAYMENT is greater than v_settled_amount, set :NEW.AMOUNT_PAYMENT to v_settled_amount.",
    "natural_language": "Please construct a BEFORE INSERT row-level trigger designated as TRG_PAYMENT_VALIDATION for the PAYMENTS table. It is required to declare a local variable, v_settled_amount. Subsequently, retrieve the AMOUNT_SETTLED value from the SETTLEMENTS table where the SETTLEMENT_ID matches :NEW.SETTLEMENT_ID and assign it to the variable v_settled_amount. Should the value of :NEW.AMOUNT_PAYMENT exceed that of v_settled_amount, it is necessary to adjust :NEW.AMOUNT_PAYMENT to equal v_settled_amount.",
    "id": 144
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CUSTOMER_POLICY_CHECK that is executed before an insert operation on the CUSTOMER_POLICIES table for each row being inserted. The trigger declares a local variable v_customer_count of type NUMBER to store the count of customers. It performs a SELECT statement to count the number of rows in the CUSTOMERS table where the CUSTOMER_ID column matches the CUSTOMER_ID of the new row being inserted into the CUSTOMER_POLICIES table, using the :NEW.CUSTOMER_ID syntax to reference the new row's CUSTOMER_ID. The result of this count is stored in the v_customer_count variable. The trigger then evaluates a conditional statement: if v_customer_count is equal to 0, indicating that there are no existing customers with the given CUSTOMER_ID, it executes an INSERT statement to add a new row into the CUSTOMERS table with the CUSTOMER_ID set to the new row's CUSTOMER_ID and the CUSTOMER_DETAILS column set to the string 'New Customer'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CUSTOMER_POLICY_CHECK\nBEFORE INSERT ON CUSTOMER_POLICIES\nFOR EACH ROW\nDECLARE\n    v_customer_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMERS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    IF v_customer_count = 0 THEN\n        INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_DETAILS) VALUES (:NEW.CUSTOMER_ID, 'New Customer');\n    END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (100, 1, 'Car', '2023-01-01', '2024-01-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (101, 2, 'Life', '2023-02-01', '2025-02-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (102, 999, 'Home', '2023-03-01', '2026-03-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (103, 1000, 'Travel', '2023-04-01', '2023-05-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (104, 3, 'Car', '2023-05-01', '2024-05-01')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_CUSTOMER_POLICY_CHECK on the CUSTOMER_POLICIES table. Declare a local variable v_customer_count. Count rows in the CUSTOMERS table where CUSTOMER_ID equals :NEW.CUSTOMER_ID and store the result in v_customer_count. If v_customer_count is 0, insert a new row into the CUSTOMERS table with CUSTOMER_ID set to :NEW.CUSTOMER_ID and CUSTOMER_DETAILS set to 'New Customer'.",
    "natural_language": "Create BEFORE INSERT trigger TRG_CUSTOMER_POLICY_CHECK on CUSTOMER_POLICIES. Count matching CUSTOMER_ID in CUSTOMERS. If zero, insert new customer.",
    "id": 145
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_company_rank_update` that is activated `BEFORE` an `INSERT` operation occurs on the `STATION_COMPANY` table. This trigger executes `FOR EACH ROW` that is being inserted. Upon activation, the trigger declares two local numeric variables: `v_avg_rank` and `v_max_rank`. The trigger then proceeds to execute two `SELECT` statements. The first `SELECT` statement calculates the `AVG` (average) of the `RANK_OF_THE_YEAR` column from the `STATION_COMPANY` table, specifically for records where the `COMPANY_ID` column matches the `COMPANY_ID` of the new row being inserted (referenced as `:NEW.COMPANY_ID`), and stores this average value into the `v_avg_rank` variable. The second `SELECT` statement calculates the `MAX` (maximum) value of the `RANK_OF_THE_YEAR` column from the `STATION_COMPANY` table, again for records where the `COMPANY_ID` column matches the `COMPANY_ID` of the new row being inserted (`:NEW.COMPANY_ID`), and stores this maximum value into the `v_max_rank` variable. Following these selections, the trigger evaluates a conditional `IF` statement. If the value of `v_avg_rank` is `GREATER THAN` `5`, then an `UPDATE` operation is performed on the `COMPANY` table, setting the `RANK` column to the value stored in `v_max_rank` for the row where the `COMPANY_ID` column matches the `COMPANY_ID` of the new row being inserted (`:NEW.COMPANY_ID`). Otherwise, if the condition `v_avg_rank > 5` is `FALSE`, an `ELSIF` condition is evaluated. If the value of `v_avg_rank` is `LESS THAN OR EQUAL TO` `5`, then an `UPDATE` operation is performed on the `COMPANY` table, setting the `RANK` column to the value stored in `v_avg_rank` for the row where the `COMPANY_ID` column matches the `COMPANY_ID` of the new row being inserted (`:NEW.COMPANY_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_rank_update\nBEFORE INSERT ON STATION_COMPANY\nFOR EACH ROW\nDECLARE\n    v_avg_rank NUMBER;\n    v_max_rank NUMBER;\nBEGIN\n    SELECT AVG(RANK_OF_THE_YEAR) INTO v_avg_rank FROM STATION_COMPANY WHERE COMPANY_ID = :NEW.COMPANY_ID;\n    SELECT MAX(RANK_OF_THE_YEAR) INTO v_max_rank FROM STATION_COMPANY WHERE COMPANY_ID = :NEW.COMPANY_ID;\n    IF v_avg_rank > 5 THEN\n        UPDATE COMPANY SET RANK = v_max_rank WHERE COMPANY_ID = :NEW.COMPANY_ID;\n    ELSIF v_avg_rank <= 5 THEN\n        UPDATE COMPANY SET RANK = v_avg_rank WHERE COMPANY_ID = :NEW.COMPANY_ID;\n    END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (12, 1, 6)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (13, 2, 4)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (14, 3, 7)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (15, 1, 5)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (16, 2, 3)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_company_rank_update on the STATION_COMPANY table. For each new row, calculate the average and maximum RANK_OF_THE_YEAR for the same COMPANY_ID. If the average is greater than 5, update the COMPANY table's RANK column with the maximum value for that COMPANY_ID. Otherwise, update it with the average value.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger, which you should name trg_company_rank_update, to be placed on the STATION_COMPANY table. For every single new row that is inserted, you must meticulously calculate both the average and the maximum value of the RANK_OF_THE_YEAR specifically for rows that share the same COMPANY_ID. Subsequently, if the carefully computed average value is determined to be greater than 5, you are required to update the RANK column within the COMPANY table, setting it to the previously identified maximum value for that particular COMPANY_ID. Conversely, if the average is not greater than 5, you should instead update the COMPANY table's RANK column with that calculated average value.",
    "id": 146
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_station_company_insert that fires automatically before each row is inserted into the GAS_STATION table, declaring local variables v_company_id of type NUMBER and v_rank_count of type NUMBER, then executing a query to select the COMPANY_ID from the COMPANY table where the row number is equal to 1 after ordering all rows by the SALES_BILLION column in descending order, storing the result into v_company_id, followed by a second query to count all rows in the STATION_COMPANY table where the COMPANY_ID column matches the value in v_company_id, storing the result into v_rank_count, and then, if the value of v_rank_count is less than 10, inserting a new row into the STATION_COMPANY table with column STATION_ID set to the new STATION_ID value from the triggering row in GAS_STATION (referenced as :NEW.STATION_ID), column COMPANY_ID set to the value in v_company_id, and column RANK_OF_THE_YEAR set to 1, otherwise, if v_rank_count is 10 or greater, inserting a new row into the STATION_COMPANY table with column STATION_ID set to :NEW.STATION_ID, column COMPANY_ID set to v_company_id, and column RANK_OF_THE_YEAR set to 2.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_station_company_insert\nBEFORE INSERT ON GAS_STATION\nFOR EACH ROW\nDECLARE\n    v_company_id NUMBER;\n    v_rank_count NUMBER;\nBEGIN\n    SELECT COMPANY_ID INTO v_company_id FROM COMPANY WHERE ROWNUM = 1 ORDER BY SALES_BILLION DESC;\n    SELECT COUNT(*) INTO v_rank_count FROM STATION_COMPANY WHERE COMPANY_ID = v_company_id;\n    IF v_rank_count < 10 THEN\n        INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (:NEW.STATION_ID, v_company_id, 1);\n    ELSE\n        INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (:NEW.STATION_ID, v_company_id, 2);\n    END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (100, 2023, 'Main Street', 'John Doe', 'Jane Smith', 'Bob Johnson')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (101, 2023, 'Oak Avenue', 'Alice Brown', 'Charlie Davis', 'Eve Wilson')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (102, 2024, 'Pine Road', 'Frank Miller', 'Grace Lee', 'Henry Taylor')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (103, 2024, 'Maple Lane', 'Ivan Garcia', 'Karen White', 'Leo Martinez')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (104, 2025, 'Cedar Blvd', 'Mona Patel', 'Nick Chen', 'Olivia Kim')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_station_company_insert on the GAS_STATION table. For each new row, find the COMPANY_ID of the company with the highest SALES_BILLION. Count how many stations that company already has in STATION_COMPANY. If the count is less than 10, insert a new row into STATION_COMPANY with RANK_OF_THE_YEAR set to 1. Otherwise, insert it with RANK_OF_THE_YEAR set to 2.",
    "natural_language": "Before inserting a new gas station, how do we set up a trigger to check the company with the highest sales? For the company that has the highest sales, if it already has fewer than 10 stations, should the new station be given a rank of 1 in STATION_COMPANY, or should it be given a rank of 2?",
    "id": 147
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_company_sales_adjust` that is defined on the `COMPANY` table and specifically activates when the `SALES_BILLION` column is updated. This trigger utilizes a compound structure, allowing for separate logic execution at different points during the DML statement.\n\nThe trigger declares a nested record type `company_data_type` which contains four fields: `company_id` of type `NUMBER`, `sales_increase` of type `BOOLEAN`, `station_count` of type `NUMBER`, and `total_rank` of type `NUMBER`. It also declares a nested table type `company_data_table` which is a collection of `company_data_type` records, indexed by `PLS_INTEGER`. A variable `company_data` of type `company_data_table` is declared to store data collected during the row-level processing, and an index variable `idx` of type `PLS_INTEGER` is initialized to `0` to manage entries in the `company_data` collection.\n\nIn the `BEFORE EACH ROW` section, which executes once for each row being updated, the `idx` variable is incremented by `1`. The `company_id` field of the current `company_data` record (at index `idx`) is populated with the `COMPANY_ID` value from the new row (`:NEW.COMPANY_ID`). The `sales_increase` field is set to `TRUE` if the new `SALES_BILLION` value (`:NEW.SALES_BILLION`) is greater than the old `SALES_BILLION` value (`:OLD.SALES_BILLION`), otherwise it is set to `FALSE`. Subsequently, a `SELECT` statement is executed to retrieve data from the `STATION_COMPANY` table. This `SELECT` statement calculates the count of all rows and the sum of the `RANK_OF_THE_YEAR` column from `STATION_COMPANY` where the `COMPANY_ID` matches the `COMPANY_ID` of the new row (`:NEW.COMPANY_ID`). The calculated count is stored in the `station_count` field of the current `company_data` record, and the calculated sum of `RANK_OF_THE_YEAR` is stored in the `total_rank` field of the current `company_data` record.\n\nIn the `AFTER STATEMENT` section, which executes once after all rows have been processed by the DML statement, a `FOR` loop iterates from `1` up to the final value of `idx`. Inside this loop, for each record `i` in the `company_data` collection, a conditional `IF` statement checks the value of `company_data(i).sales_increase`. If `company_data(i).sales_increase` is `TRUE`, an `UPDATE` statement is executed on the `COMPANY` table. This `UPDATE` statement sets the `PROFITS_BILLION` column to its current value plus the product of `company_data(i).station_count` and `0.1`. This update is applied only to the row in `COMPANY` where `COMPANY_ID` matches `company_data(i).company_id`. If `company_data(i).sales_increase` is `FALSE`, an `UPDATE` statement is executed on the `COMPANY` table. This `UPDATE` statement sets the `PROFITS_BILLION` column to its current value minus the product of `company_data(i).total_rank` and `0.05`. This update is applied only to the row in `COMPANY` where `COMPANY_ID` matches `company_data(i).company_id`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_sales_adjust\nFOR UPDATE OF SALES_BILLION ON COMPANY\nCOMPOUND TRIGGER\n\n  TYPE company_data_type IS RECORD (\n    company_id NUMBER,\n    sales_increase BOOLEAN,\n    station_count NUMBER,\n    total_rank NUMBER\n  );\n\n  TYPE company_data_table IS TABLE OF company_data_type INDEX BY PLS_INTEGER;\n  company_data company_data_table;\n  idx PLS_INTEGER := 0;\n\nBEFORE EACH ROW IS\nBEGIN\n  idx := idx + 1;\n  company_data(idx).company_id := :NEW.COMPANY_ID;\n  company_data(idx).sales_increase := :NEW.SALES_BILLION > :OLD.SALES_BILLION;\n\n  SELECT COUNT(*), SUM(RANK_OF_THE_YEAR)\n  INTO company_data(idx).station_count, company_data(idx).total_rank\n  FROM STATION_COMPANY\n  WHERE COMPANY_ID = :NEW.COMPANY_ID;\nEND BEFORE EACH ROW;\n\nAFTER STATEMENT IS\nBEGIN\n  FOR i IN 1 .. idx LOOP\n    IF company_data(i).sales_increase THEN\n      UPDATE COMPANY\n      SET PROFITS_BILLION = PROFITS_BILLION + (company_data(i).station_count * 0.1)\n      WHERE COMPANY_ID = company_data(i).company_id;\n    ELSE\n      UPDATE COMPANY\n      SET PROFITS_BILLION = PROFITS_BILLION - (company_data(i).total_rank * 0.05)\n      WHERE COMPANY_ID = company_data(i).company_id;\n    END IF;\n  END LOOP;\nEND AFTER STATEMENT;\n\nEND trg_company_sales_adjust;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "UPDATE COMPANY SET SALES_BILLION = 450 WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET SALES_BILLION = 150 WHERE COMPANY_ID = 2",
      "UPDATE COMPANY SET SALES_BILLION = 480 WHERE COMPANY_ID = 3",
      "UPDATE COMPANY SET SALES_BILLION = 440 WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET SALES_BILLION = 160 WHERE COMPANY_ID = 2"
    ],
    "summary": "Create a compound trigger named trg_company_sales_adjust on the COMPANY table for UPDATE of SALES_BILLION. In the BEFORE EACH ROW section, for each updated row, store the COMPANY_ID, whether SALES_BILLION increased, the count of its stations, and the sum of their RANK_OF_THE_YEAR. In the AFTER STATEMENT section, for each stored company, if sales increased, update its PROFITS_BILLION by adding (station_count * 0.1). If sales decreased, update its PROFITS_BILLION by subtracting (total_rank * 0.05).",
    "natural_language": "Create trigger trg_company_sales_adjust on COMPANY for updating SALES_BILLION. Before each row, save COMPANY_ID, if SALES_BILLION rose, its station count, and sum of their RANK_OF_THE_YEAR. After statement, for each saved company: if sales up, add station_count * 0.1 to PROFITS_BILLION; if sales down, subtract total_rank * 0.05 from PROFITS_BILLION.",
    "id": 148
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_station_year_validation that is executed before an INSERT or UPDATE operation on the GAS_STATION table for each row affected. The trigger begins by declaring two local variables: v_current_year and v_oldest_year, both of type NUMBER. It then retrieves the current year from the system date using the EXTRACT function and stores it in v_current_year. Next, it selects the minimum value from the OPEN_YEAR column of the GAS_STATION table and assigns it to v_oldest_year. The trigger then evaluates the OPEN_YEAR value of the new row being inserted or updated. If the OPEN_YEAR is greater than the current year, it sets OPEN_YEAR to the current year. If OPEN_YEAR is less than the oldest year found in the GAS_STATION table, it sets OPEN_YEAR to the oldest year. Additionally, if OPEN_YEAR is less than 1990, it sets OPEN_YEAR to 1990. The trigger ensures that the OPEN_YEAR value for any new or updated row in the GAS_STATION table is constrained to be no greater than the current year, no less than the oldest year in the table, and no less than 1990.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_station_year_validation\nBEFORE INSERT OR UPDATE ON GAS_STATION\nFOR EACH ROW\nDECLARE\n    v_current_year NUMBER;\n    v_oldest_year NUMBER;\nBEGIN\n    SELECT EXTRACT(YEAR FROM SYSDATE) INTO v_current_year FROM DUAL;\n    SELECT MIN(OPEN_YEAR) INTO v_oldest_year FROM GAS_STATION;\n    IF :NEW.OPEN_YEAR > v_current_year THEN\n        :NEW.OPEN_YEAR := v_current_year;\n    ELSIF :NEW.OPEN_YEAR < v_oldest_year THEN\n        :NEW.OPEN_YEAR := v_oldest_year;\n    END IF;\n    IF :NEW.OPEN_YEAR < 1990 THEN\n        :NEW.OPEN_YEAR := 1990;\n    END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (100, 2025, 'Test Location 1', 'Manager 1', 'Vice Manager 1', 'Rep 1')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (101, 1980, 'Test Location 2', 'Manager 2', 'Vice Manager 2', 'Rep 2')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (102, 2005, 'Test Location 3', 'Manager 3', 'Vice Manager 3', 'Rep 3')",
      "UPDATE GAS_STATION SET OPEN_YEAR = 2030 WHERE STATION_ID = 1",
      "UPDATE GAS_STATION SET OPEN_YEAR = 1970 WHERE STATION_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_station_year_validation on the GAS_STATION table. For each new or modified row, constrain the OPEN_YEAR value: it must not be greater than the current year, not less than the oldest OPEN_YEAR in the table, and not less than 1990. Adjust the value to these boundaries if necessary.",
    "natural_language": "Hey, can you set up a trigger called trg_station_year_validation for the GAS_STATION table? It should fire before any new row is added or an existing one is updated. Basically, for each row, we need to keep the OPEN_YEAR in check: it shouldn't be later than this year, shouldn't be older than the earliest OPEN_YEAR we already have on file, and it's gotta be 1990 or later. If the value's out of bounds, just tweak it to fit within those limits.",
    "id": 149
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_rank_recalculation that is executed for DELETE operations on the STATION_COMPANY table. This trigger is a compound trigger, which means it has multiple timing points. It defines a PL/SQL associative array type t_company_ids to store COMPANY_ID values of the deleted rows, indexed by PLS_INTEGER. The trigger has a BEFORE EACH ROW section that increments an index variable v_index and stores the COMPANY_ID of the deleted row into the v_company_ids array using the index. The AFTER STATEMENT section initializes three local variables: v_remaining_stations, v_company_rank, and v_company_id, all of type NUMBER. It then iterates over the stored COMPANY_IDs in the v_company_ids array. For each COMPANY_ID, it performs a SELECT COUNT(*) query on the STATION_COMPANY table to determine the number of remaining stations associated with that COMPANY_ID, storing the result in v_remaining_stations. It also retrieves the current RANK of the company from the COMPANY table using a SELECT query, storing the result in v_company_rank. The trigger then evaluates the number of remaining stations: if v_remaining_stations is zero, it deletes the company from the COMPANY table; if v_remaining_stations is less than five, it updates the COMPANY table to increase the RANK by one; otherwise, it updates the COMPANY table to decrease the RANK by one.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_rank_recalculation\nFOR DELETE ON STATION_COMPANY\nCOMPOUND TRIGGER\n\n    TYPE t_company_ids IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n    v_company_ids t_company_ids;\n    v_index PLS_INTEGER := 0;\n\nBEFORE EACH ROW IS\nBEGIN\n    v_index := v_index + 1;\n    v_company_ids(v_index) := :OLD.COMPANY_ID;\nEND BEFORE EACH ROW;\n\nAFTER STATEMENT IS\n    v_remaining_stations NUMBER;\n    v_company_rank NUMBER;\n    v_company_id NUMBER;\nBEGIN\n    FOR i IN 1..v_company_ids.COUNT LOOP\n        v_company_id := v_company_ids(i);\n        \n        SELECT COUNT(*) INTO v_remaining_stations \n        FROM STATION_COMPANY \n        WHERE COMPANY_ID = v_company_id;\n        \n        SELECT RANK INTO v_company_rank \n        FROM COMPANY \n        WHERE COMPANY_ID = v_company_id;\n        \n        IF v_remaining_stations = 0 THEN\n            DELETE FROM COMPANY WHERE COMPANY_ID = v_company_id;\n        ELSIF v_remaining_stations < 5 THEN\n            UPDATE COMPANY SET RANK = v_company_rank + 1 WHERE COMPANY_ID = v_company_id;\n        ELSE\n            UPDATE COMPANY SET RANK = v_company_rank - 1 WHERE COMPANY_ID = v_company_id;\n        END IF;\n    END LOOP;\nEND AFTER STATEMENT;\n\nEND trg_rank_recalculation;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "DELETE FROM STATION_COMPANY WHERE STATION_ID = 11 AND COMPANY_ID = 1",
      "DELETE FROM STATION_COMPANY WHERE COMPANY_ID = 3",
      "DELETE FROM STATION_COMPANY WHERE STATION_ID = 6",
      "DELETE FROM STATION_COMPANY WHERE COMPANY_ID = 2 AND STATION_ID = 15",
      "DELETE FROM STATION_COMPANY WHERE COMPANY_ID = 5"
    ],
    "summary": "Create a compound trigger named trg_rank_recalculation for DELETE on the STATION_COMPANY table. In the BEFORE EACH ROW section, store the COMPANY_ID of each deleted row. In the AFTER STATEMENT section, for each affected COMPANY_ID, count its remaining stations in STATION_COMPANY. If zero stations remain, delete the company from the COMPANY table. If less than five remain, increase the company's RANK by one. Otherwise, decrease its RANK by one.",
    "natural_language": "Construct a compound trigger designated as trg_rank_recalculation to handle DELETE operations specifically on the STATION_COMPANY table. Within the meticulously defined BEFORE EACH ROW segment, you must carefully capture and temporarily store the unique COMPANY_ID associated with each individual row that is being removed. Subsequently, in the comprehensive AFTER STATEMENT phase, for every single COMPANY_ID that was impacted by the deletion, you are required to perform a detailed count of its associated stations that still persist within the STATION_COMPANY table. Should this thorough count reveal that absolutely zero stations remain for a given company, then you must proceed to permanently delete that corresponding company record from the overarching COMPANY table. Alternatively, if the precise count indicates that fewer than five stations are left, then you should appropriately increase the company's RANK value by exactly one. In all other remaining cases, where five or more stations are still present, you are to systematically decrease the company's RANK by one.",
    "id": 150
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named mission_after_update that is automatically executed after an update operation on the MISSION table, specifically after the LOCATION column is updated, and it executes once for each row that is updated; the trigger's logic performs an update on the SHIP table, setting the NAME column to its current value concatenated with the string literal ' - Updated' for every row in the SHIP table where the SHIP_ID column value matches the new SHIP_ID value from the updated row in the MISSION table, which is accessed via the :NEW.SHIP_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER mission_after_update\nAFTER UPDATE OF LOCATION ON MISSION\nFOR EACH ROW\nBEGIN\n   UPDATE SHIP SET NAME = NAME || ' - Updated' WHERE SHIP_ID = :NEW.SHIP_ID;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "UPDATE MISSION SET LOCATION = 'United Kingdom' WHERE MISSION_ID = 1",
      "UPDATE MISSION SET LOCATION = 'France', SPEED_KNOTS = 20 WHERE MISSION_ID = 2",
      "UPDATE MISSION SET LOCATION = 'Norway' WHERE SHIP_ID = 5",
      "UPDATE MISSION SET LOCATION = 'Germany', FATE = 'Active' WHERE CODE = 'VMV-1'",
      "UPDATE MISSION SET LOCATION = 'Mediterranean Sea', LAUNCHED_YEAR = 1925 WHERE MISSION_ID = 4"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named mission_after_update on the MISSION table that fires when the LOCATION column is updated. For each updated row, update the SHIP table by appending ' - Updated' to the NAME column where SHIP_ID matches :NEW.SHIP_ID.",
    "natural_language": "Set up a trigger on the MISSION table that runs after some updates. When the location gets changed, it should also make a related update to the names of certain ships, adding a note to them.",
    "id": 151
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `ship_before_delete` that is activated before a `DELETE` operation is performed on any row in the `SHIP` table. This trigger is a row-level trigger, meaning it executes once for each row that is being deleted from the `SHIP` table. When activated, the trigger performs a `DELETE` operation on the `MISSION` table. The rows targeted for deletion in the `MISSION` table are those where the value in the `SHIP_ID` column of the `MISSION` table matches the value of the `SHIP_ID` column from the row currently being deleted from the `SHIP` table. The `:OLD.SHIP_ID` refers to the `SHIP_ID` value of the row in the `SHIP` table that is about to be deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER ship_before_delete\nBEFORE DELETE ON SHIP\nFOR EACH ROW\nBEGIN\n   DELETE FROM MISSION WHERE SHIP_ID = :OLD.SHIP_ID;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "DELETE FROM SHIP WHERE SHIP_ID = 1",
      "DELETE FROM SHIP WHERE SHIP_ID = 2",
      "DELETE FROM SHIP WHERE SHIP_ID = 3",
      "DELETE FROM SHIP WHERE SHIP_ID = 99",
      "DELETE FROM SHIP WHERE NAME = 'Corbridge'"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named ship_before_delete on the SHIP table. For each row being deleted, delete all rows from the MISSION table where SHIP_ID equals :OLD.SHIP_ID.",
    "natural_language": "Please construct a BEFORE DELETE row-level trigger designated as `ship_before_delete` for the SHIP table. This trigger must be configured to execute for each row prior to its deletion. Its function is to remove all corresponding records from the MISSION table where the SHIP_ID column matches the value of the :OLD.SHIP_ID identifier from the row slated for deletion.",
    "id": 152
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_ship_tonnage_validation` that is defined to execute `BEFORE UPDATE` operations on the `SHIP` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being updated in the `SHIP` table. The trigger's purpose is to modify the `TYPE` column of the `SHIP` table based on the `TONNAGE` value of the row being updated. Specifically, it evaluates the `TONNAGE` value of the new row image (`:NEW.TONNAGE`). If the `TONNAGE` value is strictly greater than 5000, the trigger concatenates the string literal 'Heavy ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). If the `TONNAGE` value is not greater than 5000, the trigger then checks if the `TONNAGE` value is strictly less than 2000. If this condition is true, it concatenates the string literal 'Light ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). If neither of the preceding conditions is met (i.e., `TONNAGE` is between 2000 and 5000, inclusive), the trigger concatenates the string literal 'Medium ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). The modifications to `:NEW.TYPE` will be applied to the `TYPE` column of the `SHIP` table as part of the `UPDATE` statement that fired the trigger.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_ship_tonnage_validation\nBEFORE UPDATE ON SHIP\nFOR EACH ROW\nBEGIN\n    IF :NEW.TONNAGE > 5000 THEN\n        :NEW.TYPE := 'Heavy ' || :NEW.TYPE;\n    ELSIF :NEW.TONNAGE < 2000 THEN\n        :NEW.TYPE := 'Light ' || :NEW.TYPE;\n    ELSE\n        :NEW.TYPE := 'Medium ' || :NEW.TYPE;\n    END IF;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "UPDATE SHIP SET TONNAGE = 6000 WHERE SHIP_ID = 1",
      "UPDATE SHIP SET TONNAGE = 1500 WHERE SHIP_ID = 2",
      "UPDATE SHIP SET TONNAGE = 2500 WHERE SHIP_ID = 3",
      "UPDATE SHIP SET TONNAGE = 500 WHERE SHIP_ID = 1",
      "UPDATE SHIP SET TONNAGE = 4500 WHERE SHIP_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_ship_tonnage_validation on the SHIP table. For each row, modify :NEW.TYPE by prepending 'Heavy ' if :NEW.TONNAGE > 5000, 'Light ' if :NEW.TONNAGE < 2000, or 'Medium ' otherwise.",
    "natural_language": "Create a BEFORE UPDATE row-level trigger called trg_ship_tonnage_validation for the SHIP table. For each updated row, set the :NEW.TYPE to 'Heavy ' if :NEW.TONNAGE exceeds 5000, to 'Light ' if it is below 2000, and to 'Medium ' in all other cases.",
    "id": 153
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_mission_year_check` that is configured to execute automatically before any `INSERT` or `UPDATE` operation is performed on any row within the `MISSION` table. For each row being inserted or updated, the trigger first evaluates the value of the `LAUNCHED_YEAR` column. If the `LAUNCHED_YEAR` value is found to be less than the integer literal `1900`, the trigger modifies the `LAUNCHED_YEAR` column of the new or updated row to `1900`. Otherwise, if the `LAUNCHED_YEAR` value is found to be greater than the integer literal `2023`, the trigger modifies the `LAUNCHED_YEAR` column of the new or updated row to `2023`. If the `LAUNCHED_YEAR` value is between `1900` and `2023` (inclusive), no modification is made to this column. Following this, the trigger checks if the current operation is an `INSERT` operation using the `INSERTING` conditional predicate. If the operation is an `INSERT` and the `FATE` column of the new row (`:NEW.FATE`) is `NULL`, the trigger then sets the `FATE` column of the new row to the string literal `'Active'`. This specific modification to the `FATE` column only occurs during `INSERT` operations and only if the `FATE` column is initially `NULL`; it does not apply during `UPDATE` operations.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_mission_year_check\nBEFORE INSERT OR UPDATE ON MISSION\nFOR EACH ROW\nBEGIN\n    IF :NEW.LAUNCHED_YEAR < 1900 THEN\n        :NEW.LAUNCHED_YEAR := 1900;\n    ELSIF :NEW.LAUNCHED_YEAR > 2023 THEN\n        :NEW.LAUNCHED_YEAR := 2023;\n    END IF;\n    \n    -- Only set FATE to 'Active' for new inserts, not updates\n    IF INSERTING AND :NEW.FATE IS NULL THEN\n        :NEW.FATE := 'Active';\n    END IF;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (10, 1, 'TEST-1', 1880, 'Germany', 20, NULL)",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS) VALUES (11, 2, 'TEST-2', 2050, 'Norway', 25)",
      "UPDATE MISSION SET LAUNCHED_YEAR = 1800 WHERE MISSION_ID = 1",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (12, 3, 'TEST-3', 1955, 'UK', 18, 'Sold 1970')",
      "UPDATE MISSION SET LAUNCHED_YEAR = 2100, FATE = NULL WHERE MISSION_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_mission_year_check on the MISSION table. For each row, constrain :NEW.LAUNCHED_YEAR between 1900 and 2023. Additionally, if INSERTING and :NEW.FATE is NULL, set :NEW.FATE to 'Active'.",
    "natural_language": "Hey, can you set up a trigger called trg_mission_year_check for the MISSION table? It should fire before any new row is inserted or an existing one is updated. For each row, make sure the LAUNCHED_YEAR is always between 1900 and 2023. Oh, and one more thing: if it's an insert and the FATE field is left empty, just automatically set it to 'Active'.",
    "id": 154
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_ship_nationality_format` that automatically executes before an `INSERT` operation or an `UPDATE` operation is performed on any row in the `SHIP` table. For each row being inserted or updated, the trigger performs three distinct operations. First, it modifies the `NATIONALITY` column of the new or updated row by converting its value to uppercase using the `UPPER()` SQL function. This ensures that all nationality entries are consistently stored in an uppercase format. Second, it evaluates a conditional statement: if the `LENGTH()` of the `NAME` column in the new or updated row is less than 3 characters, then the `NAME` column is set to the string literal 'UNKNOWN'. This condition checks if the ship's name is too short and, if so, assigns a default value. Third, it modifies the `TONNAGE` column of the new or updated row by rounding its value to the nearest hundred using the `ROUND()` SQL function with a precision of -2. This operation standardizes the tonnage values by rounding them to a specific granularity.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_ship_nationality_format\nBEFORE INSERT OR UPDATE ON SHIP\nFOR EACH ROW\nBEGIN\n    :NEW.NATIONALITY := UPPER(:NEW.NATIONALITY);\n    IF LENGTH(:NEW.NAME) < 3 THEN\n        :NEW.NAME := 'UNKNOWN';\n    END IF;\n    :NEW.TONNAGE := ROUND(:NEW.TONNAGE, -2);\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (4, 'Al', 'Cruise Ship', 'france', 1234)",
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (5, 'Bo', 'Fishing Vessel', 'spain', 5678)",
      "UPDATE SHIP SET NAME = 'Ca', NATIONALITY = 'italy', TONNAGE = 2345 WHERE SHIP_ID = 1",
      "UPDATE SHIP SET NAME = 'De', NATIONALITY = 'germany', TONNAGE = 6789 WHERE SHIP_ID = 2",
      "INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE) VALUES (6, 'Ed', 'Cargo Ship', 'netherlands', 3456)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_ship_nationality_format on the SHIP table. For each row, set :NEW.NATIONALITY to UPPER(:NEW.NATIONALITY), set :NEW.NAME to 'UNKNOWN' if its length is less than 3, and round :NEW.TONNAGE to the nearest hundred.",
    "natural_language": "Please implement a BEFORE INSERT OR UPDATE row-level trigger designated as trg_ship_nationality_format for the SHIP table. For each row processed, the trigger must execute the following modifications: convert the value of :NEW.NATIONALITY to uppercase, assign the value 'UNKNOWN' to :NEW.NAME if its character length is fewer than three, and adjust :NEW.TONNAGE to the nearest hundred.",
    "id": 155
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_mission_location_check that is executed before an insert operation on the MISSION table for each row being inserted. The trigger first declares two local variables: v_count of type NUMBER to store the count of existing mission IDs, and v_max_id of type NUMBER to store the maximum mission ID found in the table. The trigger logic begins by checking if the MISSION_ID of the new row (:NEW.MISSION_ID) is NULL. If it is NULL, the trigger assigns a new unique MISSION_ID to the row by selecting the maximum MISSION_ID from the MISSION table, using the NVL function to handle cases where the table might be empty, and adding 1 to this maximum value. If the MISSION_ID is not NULL, the trigger checks if this ID already exists in the MISSION table by counting the number of rows with the same MISSION_ID and storing this count in v_count. If v_count is greater than 0, indicating that the MISSION_ID already exists, the trigger assigns a new unique MISSION_ID to the row in the same manner as when the MISSION_ID is NULL. Next, the trigger checks if the LOCATION of the new row (:NEW.LOCATION) is NULL. If it is NULL, the trigger sets the LOCATION to the string 'UNKNOWN'. The trigger then converts the CODE of the new row (:NEW.CODE) to uppercase using the UPPER function. It rounds the SPEED_KNOTS of the new row (:NEW.SPEED_KNOTS) to the nearest whole number using the ROUND function. Finally, the trigger ensures that the SPEED_KNOTS is not less than 10 by checking if it is below this threshold and setting it to 10 if necessary.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_mission_location_check\nBEFORE INSERT ON MISSION\nFOR EACH ROW\nDECLARE\n    v_count NUMBER;\n    v_max_id NUMBER;\nBEGIN\n    -- Ensure MISSION_ID is unique if not provided\n    IF :NEW.MISSION_ID IS NULL THEN\n        SELECT NVL(MAX(MISSION_ID), 0) + 1 INTO :NEW.MISSION_ID FROM MISSION;\n    ELSE\n        -- Check if MISSION_ID already exists\n        SELECT COUNT(*) INTO v_count FROM MISSION WHERE MISSION_ID = :NEW.MISSION_ID;\n        IF v_count > 0 THEN\n            SELECT NVL(MAX(MISSION_ID), 0) + 1 INTO :NEW.MISSION_ID FROM MISSION;\n        END IF;\n    END IF;\n    \n    IF :NEW.LOCATION IS NULL THEN\n        :NEW.LOCATION := 'UNKNOWN';\n    END IF;\n    :NEW.CODE := UPPER(:NEW.CODE);\n    :NEW.SPEED_KNOTS := ROUND(:NEW.SPEED_KNOTS);\n    IF :NEW.SPEED_KNOTS < 10 THEN\n        :NEW.SPEED_KNOTS := 10;\n    END IF;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "INSERT INTO MISSION (SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (1, 'vmv-10', 1942, NULL, 8.7, 'Sunk 1944')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (NULL, 2, 'alpha-5', 1918, 'Norway', 25.3, 'Decommissioned')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (4, 3, 'bravo-2', 1935, 'Germany', 12.1, 'Retired')",
      "INSERT INTO MISSION (SHIP_ID, CODE, LAUNCHED_YEAR, SPEED_KNOTS, FATE) VALUES (5, 'charlie-7', 1920, 9.2, 'Scrapped')",
      "INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE) VALUES (2, 1, 'delta-1', 1945, 'United Kingdom', 30.8, 'Active')"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_mission_location_check on the MISSION table. If the new MISSION_ID is null or already exists, assign a new unique ID by taking the maximum existing ID plus one. If the new LOCATION is null, set it to 'UNKNOWN'. Convert the new CODE to uppercase. Round the new SPEED_KNOTS to the nearest whole number and ensure it is not less than 10.",
    "natural_language": "Hey, set up a BEFORE INSERT trigger called trg_mission_location_check for the MISSION table. Basically, if the new MISSION_ID is empty or a duplicate, just make up a fresh one by adding 1 to the biggest ID we've already got. Oh, and if the LOCATION field's left blank, just slap 'UNKNOWN' in there. Also, make sure to change any new CODE to all caps. For the SPEED_KNOTS, round it off to the nearest whole number and don't let it drop below 10, okay?",
    "id": 156
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_customer_order_status that is executed before a new row is inserted into the CUSTOMER_ORDERS table. This trigger sets the ORDER_STATUS_CODE column of the new row to the string 'Pending'. It then attempts to delete rows from the ORDER_ITEMS table where the ORDER_ID column matches the ORDER_ID of the new row being inserted into CUSTOMER_ORDERS, and the ORDER_QUANTITY column, when converted to a number, is less than 1. If a VALUE_ERROR exception occurs during the conversion of ORDER_QUANTITY to a number, the exception is caught and handled gracefully by doing nothing, allowing the trigger to continue without interruption.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_customer_order_status\nBEFORE INSERT ON CUSTOMER_ORDERS\nFOR EACH ROW\nBEGIN\n  :NEW.ORDER_STATUS_CODE := 'Pending';\n  \n  BEGIN\n    DELETE FROM ORDER_ITEMS \n    WHERE ORDER_ID = :NEW.ORDER_ID \n      AND TO_NUMBER(ORDER_QUANTITY) < 1;\n  EXCEPTION\n    WHEN VALUE_ERROR THEN\n      NULL; -- Handle non-numeric ORDER_QUANTITY gracefully\n  END;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE) VALUES (4, 1, '2023-10-01 10:00:00')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE) VALUES (5, 4, '2023-10-02 11:00:00')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE) VALUES (6, 5, '2023-10-03 12:00:00')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE) VALUES (7, 1, '2023-10-04 13:00:00')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE) VALUES (8, 4, '2023-10-05 14:00:00')"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_update_customer_order_status on the CUSTOMER_ORDERS table. Set the new ORDER_STATUS_CODE to 'Pending'. Then, attempt to delete rows from ORDER_ITEMS where the ORDER_ID matches the new ORDER_ID and the ORDER_QUANTITY (converted to a number) is less than 1. Handle any VALUE_ERROR exception gracefully by ignoring it.",
    "natural_language": "Create BEFORE INSERT trigger trg_update_customer_order_status on CUSTOMER_ORDERS. Set new ORDER_STATUS_CODE to 'Pending'. Delete from ORDER_ITEMS where ORDER_ID matches new ORDER_ID and converted ORDER_QUANTITY < 1. Ignore VALUE_ERROR.",
    "id": 157
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_insert_order_item_check` that is defined on the `ORDER_ITEMS` table and fires for `INSERT` operations. This trigger is a compound trigger, meaning it has distinct sections for `AFTER EACH ROW` and `AFTER STATEMENT` events.\n\nWithin the declaration section of the compound trigger, a nested table type named `order_item_id_list` is declared, which is a collection of `ORDER_ITEMS.ORDER_ITEM_ID%TYPE` elements. A variable of this type, `order_items_to_delete`, is also declared and initialized as an empty collection. This collection is used to store `ORDER_ITEM_ID` values of order items that need to be deleted after the statement completes.\n\nThe `AFTER EACH ROW` section of the trigger executes for every row that is inserted into the `ORDER_ITEMS` table. In this section, two main operations are performed:\n1. An `INSERT` statement attempts to insert a new row into the `PRODUCTS` table. The `PRODUCT_ID` column is populated with the value from the `:NEW.PRODUCT_ID` pseudorecord, the `PRODUCT_TYPE_CODE` column is set to the literal string 'Misc', the `PRODUCT_NAME` column is set to the literal string 'New Product', and the `PRODUCT_PRICE` column is set to the numeric literal `0`. This insertion only occurs if a product with the `PRODUCT_ID` matching `:NEW.PRODUCT_ID` does not already exist in the `PRODUCTS` table, as determined by a `WHERE NOT EXISTS` subquery that selects `1` from `PRODUCTS` where `PRODUCT_ID` equals `:NEW.PRODUCT_ID`.\n2. A conditional `IF` statement checks if the value of `:NEW.ORDER_QUANTITY` (which is implicitly converted to a number using `TO_NUMBER`) is less than `1`. If this condition is true, the `order_items_to_delete` collection is extended by one element using `EXTEND`, and the `ORDER_ITEM_ID` from the `:NEW.ORDER_ITEM_ID` pseudorecord is assigned to the newly added element at the current count of the collection.\n\nThe `AFTER STATEMENT` section of the trigger executes once after all rows affected by the `INSERT` statement have been processed. In this section, a `FORALL` statement iterates through the `INDICES OF` the `order_items_to_delete` collection. For each index `i` in the collection, a `DELETE` statement is executed to remove rows from the `ORDER_ITEMS` table where the `ORDER_ITEM_ID` column matches the value stored at `order_items_to_delete(i)`. This effectively deletes all order items that were identified in the `AFTER EACH ROW` section as having an `ORDER_QUANTITY` less than `1`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_order_item_check\nFOR INSERT ON ORDER_ITEMS\nCOMPOUND TRIGGER\n\n  TYPE order_item_id_list IS TABLE OF ORDER_ITEMS.ORDER_ITEM_ID%TYPE;\n  order_items_to_delete order_item_id_list := order_item_id_list();\n\nAFTER EACH ROW IS\nBEGIN\n  INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_TYPE_CODE, PRODUCT_NAME, PRODUCT_PRICE)\n  SELECT :NEW.PRODUCT_ID, 'Misc', 'New Product', 0 FROM DUAL\n  WHERE NOT EXISTS (SELECT 1 FROM PRODUCTS WHERE PRODUCT_ID = :NEW.PRODUCT_ID);\n\n  IF TO_NUMBER(:NEW.ORDER_QUANTITY) < 1 THEN\n    order_items_to_delete.EXTEND;\n    order_items_to_delete(order_items_to_delete.COUNT) := :NEW.ORDER_ITEM_ID;\n  END IF;\nEND AFTER EACH ROW;\n\nAFTER STATEMENT IS\nBEGIN\n  FORALL i IN INDICES OF order_items_to_delete\n    DELETE FROM ORDER_ITEMS WHERE ORDER_ITEM_ID = order_items_to_delete(i);\nEND AFTER STATEMENT;\n\nEND trg_insert_order_item_check;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY) VALUES (101, 1, 201, '5')",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY) VALUES (102, 2, 202, '0')",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY) VALUES (103, 3, 203, '10')",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY) VALUES (104, 4, 204, '-2')",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY) VALUES (105, 5, 205, '1')"
    ],
    "summary": "Create a compound trigger named trg_insert_order_item_check for INSERT on the ORDER_ITEMS table. In the AFTER EACH ROW section: 1) Insert a new product into PRODUCTS with the new PRODUCT_ID, type 'Misc', name 'New Product', and price 0, only if the product does not already exist. 2) If the new ORDER_QUANTITY is less than 1, store the new ORDER_ITEM_ID in a collection. In the AFTER STATEMENT section, delete all rows from ORDER_ITEMS whose ORDER_ITEM_ID is in the collection.",
    "natural_language": "Alright, so we need a compound trigger called trg_insert_order_item_check that fires when we INSERT into ORDER_ITEMS. First, for each new row right after it's added: 1) If the product isn't already in the PRODUCTS table, go ahead and slap a new entry in there using the new PRODUCT_ID, set the type to 'Misc', name it 'New Product', and make the price zero. 2) If the ORDER_QUANTITY we just got is less than 1, we gotta stash that ORDER_ITEM_ID in a collection for later. Then, after the whole insert statement is done, we need to clean up by deleting any rows from ORDER_ITEMS where the ORDER_ITEM_ID is in that collection we were filling up.",
    "id": 158
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_customer_email_check` on the `CUSTOMERS` table. This trigger executes for each row immediately before an `INSERT` operation is performed on the `CUSTOMERS` table. The trigger first converts the value of the `CUSTOMER_EMAIL` column in the new row being inserted (`:NEW.CUSTOMER_EMAIL`) to its lowercase equivalent using the `LOWER()` SQL function and assigns this lowercase value back to the `CUSTOMER_EMAIL` column of the new row. Following this, it evaluates a conditional statement: if the `CUSTOMER_EMAIL` column of the new row (`:NEW.CUSTOMER_EMAIL`) does not contain the '@' symbol, as determined by the `NOT LIKE '%@%'` pattern matching operator, then the trigger raises an application error. This error is identified by the error number `-20001` and includes the error message 'Invalid email format: email must contain @ symbol'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customer_email_check\nBEFORE INSERT ON CUSTOMERS\nFOR EACH ROW\nBEGIN\n  -- Convert email to lowercase\n  :NEW.CUSTOMER_EMAIL := LOWER(:NEW.CUSTOMER_EMAIL);\n  \n  -- Validate email format\n  IF :NEW.CUSTOMER_EMAIL NOT LIKE '%@%' THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Invalid email format: email must contain @ symbol');\n  END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL) VALUES (6, 10, 'Credit Card', '123', 'Alice', '123 Main St', '123-456-7890', 'alice@example.com')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL) VALUES (7, 11, 'Credit Card', '456', 'Bob', '456 Elm St', '987-654-3210', 'bob@example.com')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL) VALUES (8, 12, 'Credit Card', '789', 'Charlie', '789 Oak St', '555-555-5555', 'charlie@example.com')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL) VALUES (9, 13, 'Credit Card', '012', 'David', '012 Pine St', '111-222-3333', 'david@example.com')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL) VALUES (10, 14, 'Credit Card', '345', 'Eve', '345 Maple St', '444-555-6666', 'eve@example.com')"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_customer_email_check on the CUSTOMERS table. Convert the new CUSTOMER_EMAIL to lowercase. If the resulting email does not contain an '@' symbol, raise an application error (-20001) with the message 'Invalid email format: email must contain @ symbol'.",
    "natural_language": "Create a BEFORE INSERT row trigger called trg_customer_email_check for the CUSTOMERS table. Make it convert the new CUSTOMER_EMAIL to lowercase and then raise an application error (-20001) with the message 'Invalid email format: email must contain @ symbol' if the converted email lacks an '@' symbol.",
    "id": 159
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_order_date_check that is executed before an insert operation on the CUSTOMER_ORDERS table. This trigger operates on each row being inserted. It checks if the ORDER_DATE column of the new row (:NEW.ORDER_DATE) is NULL. If ORDER_DATE is NULL, the trigger sets it to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS', using the TO_CHAR function applied to SYSDATE. The trigger includes a comment noting that the original DELETE logic intended to prevent insertion of rows with NULL ORDER_DATE is not directly applicable in a BEFORE trigger context. Instead, it suggests that a NOT NULL constraint on the ORDER_DATE column or raising an application error would be more appropriate for preventing such insertions. However, by ensuring ORDER_DATE is set to the current date and time when NULL, the trigger effectively ensures that ORDER_DATE is always populated, thus addressing the condition indirectly.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_order_date_check\nBEFORE INSERT ON CUSTOMER_ORDERS\nFOR EACH ROW\nBEGIN\n  -- If ORDER_DATE is not provided or is NULL, set it to the current system date\n  IF :NEW.ORDER_DATE IS NULL THEN\n    :NEW.ORDER_DATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\n  END IF;\n  -- The original DELETE logic is not directly translatable to a BEFORE trigger\n  -- for preventing insertion of the current row. If the intent was to prevent\n  -- rows with NULL ORDER_DATE, a NOT NULL constraint on the column or\n  -- raising an application error would be more appropriate.\n  -- However, by ensuring :NEW.ORDER_DATE is set above, this condition\n  -- should ideally not be met if the intent was to always populate it.\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE) VALUES (101, 1, NULL, 'Pending')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE) VALUES (102, 4, '2023-01-15 10:30:00', 'Completed')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE) VALUES (103, 5, NULL, 'Processing')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE) VALUES (104, 1, '2024-03-20 14:00:00', 'Shipped')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE) VALUES (105, 4, NULL, 'Cancelled')"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_order_date_check on the CUSTOMER_ORDERS table. If the new ORDER_DATE is null, set it to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Hey, set up a trigger called trg_order_date_check for the CUSTOMER_ORDERS table that fires before a new row is added. If the ORDER_DATE that's coming in is empty, just fill it in with the current date and time, formatted like 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 160
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER UPDATE` row-level trigger named `trg_update_student_logon` that is automatically executed on the `STUDENTS` table. This trigger fires immediately after an `UPDATE` operation is performed on any row within the `STUDENTS` table. For each individual row that is updated, the trigger evaluates a conditional statement. The condition checks if the `DATE_OF_LATEST_LOGON` column in the newly updated row (`:NEW.DATE_OF_LATEST_LOGON`) has a value that is not `NULL`. If this condition evaluates to `TRUE`, meaning a value has been provided for `DATE_OF_LATEST_LOGON` in the updated row, then an `INSERT` operation is performed. This `INSERT` operation adds a new row into the `STUDENT_TESTS_TAKEN` table. The `REGISTRATION_ID` column of the new row in `STUDENT_TESTS_TAKEN` is populated with the value from the `STUDENT_ID` column of the newly updated row in the `STUDENTS` table (`:NEW.STUDENT_ID`). The `DATE_TEST_TAKEN` column of the new row in `STUDENT_TESTS_TAKEN` is populated with the current system timestamp, obtained by calling the `CURRENT_TIMESTAMP` function. The `TEST_RESULT` column of the new row in `STUDENT_TESTS_TAKEN` is populated with the literal string value `'Logon Updated'`. If the initial condition, checking if `:NEW.DATE_OF_LATEST_LOGON` is not `NULL`, evaluates to `FALSE`, then no `INSERT` operation is performed, and the trigger simply completes its execution for that row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_student_logon\nAFTER UPDATE ON STUDENTS\nFOR EACH ROW\nBEGIN\n    IF :NEW.DATE_OF_LATEST_LOGON IS NOT NULL THEN\n        INSERT INTO STUDENT_TESTS_TAKEN (REGISTRATION_ID, DATE_TEST_TAKEN, TEST_RESULT)\n        VALUES (:NEW.STUDENT_ID, CURRENT_TIMESTAMP, 'Logon Updated');\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-01-01 10:00:00' WHERE STUDENT_ID = 1",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-02-15 11:30:00' WHERE STUDENT_ID = 2",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-03-20 09:45:00' WHERE STUDENT_ID = 3",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-04-05 14:00:00' WHERE STUDENT_ID = 1",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-05-10 16:15:00' WHERE STUDENT_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_student_logon on the STUDENTS table. For each updated row, if :NEW.DATE_OF_LATEST_LOGON is not NULL, insert a new row into STUDENT_TESTS_TAKEN. Populate REGISTRATION_ID with :NEW.STUDENT_ID, DATE_TEST_TAKEN with CURRENT_TIMESTAMP, and TEST_RESULT with 'Logon Updated'.",
    "natural_language": "Set up a trigger on the STUDENTS table that runs after updates. For any student record that gets changed, if their latest logon date is filled in, then add a note about it to the student tests log. Use the student's ID for the registration, the current time for the date, and just mark the result as a logon update.",
    "id": 161
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_course_author that is defined to fire automatically after a new row is inserted into the COURSE_AUTHORS_AND_TUTORS table for each affected row, and within its execution block, it declares a local variable v_count of type NUMBER, then performs a SELECT COUNT(*) query from the COURSES table into v_count where the AUTHOR_ID column equals the newly inserted AUTHOR_ID value from the :NEW pseudorecord, and if the resulting v_count equals zero, it executes an INSERT statement into the COURSES table specifying columns COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, and COURSE_DESCRIPTION with corresponding values: a pseudo-random integer generated by the DBMS_RANDOM.VALUE function called with arguments 1 and 1000 and wrapped by the FLOOR function, the :NEW.AUTHOR_ID value, the literal number 1, the literal string 'New Course', and the literal string 'Description'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_course_author\nAFTER INSERT ON COURSE_AUTHORS_AND_TUTORS\nFOR EACH ROW\nBEGIN\n    DECLARE\n        v_count NUMBER;\n    BEGIN\n        SELECT COUNT(*) INTO v_count FROM COURSES WHERE AUTHOR_ID = :NEW.AUTHOR_ID;\n        IF v_count = 0 THEN\n            INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION)\n            VALUES (FLOOR(DBMS_RANDOM.VALUE(1, 1000)), :NEW.AUTHOR_ID, 1, 'New Course', 'Description');\n        END IF;\n    END;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "INSERT INTO COURSE_AUTHORS_AND_TUTORS (AUTHOR_ID, AUTHOR_TUTOR_ATB, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, FAMILY_NAME, GENDER_MF, ADDRESS_LINE_1) VALUES (1, 'Tutor', 'login1', 'pass1', 'John', 'A', 'Doe', 'M', '123 Main St')",
      "INSERT INTO COURSE_AUTHORS_AND_TUTORS (AUTHOR_ID, AUTHOR_TUTOR_ATB, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, FAMILY_NAME, GENDER_MF, ADDRESS_LINE_1) VALUES (2, 'Tutor', 'login2', 'pass2', 'Jane', 'B', 'Smith', 'F', '456 Elm St')",
      "INSERT INTO COURSE_AUTHORS_AND_TUTORS (AUTHOR_ID, AUTHOR_TUTOR_ATB, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, FAMILY_NAME, GENDER_MF, ADDRESS_LINE_1) VALUES (3, 'Tutor', 'login3', 'pass3', 'Alice', 'C', 'Johnson', 'F', '789 Oak St')",
      "INSERT INTO COURSE_AUTHORS_AND_TUTORS (AUTHOR_ID, AUTHOR_TUTOR_ATB, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, FAMILY_NAME, GENDER_MF, ADDRESS_LINE_1) VALUES (4, 'Tutor', 'login4', 'pass4', 'Bob', 'D', 'Brown', 'M', '101 Pine St')",
      "INSERT INTO COURSE_AUTHORS_AND_TUTORS (AUTHOR_ID, AUTHOR_TUTOR_ATB, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, FAMILY_NAME, GENDER_MF, ADDRESS_LINE_1) VALUES (5, 'Tutor', 'login5', 'pass5', 'Charlie', 'E', 'Davis', 'M', '202 Maple St')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_course_author on the COURSE_AUTHORS_AND_TUTORS table. For each inserted row, count courses where AUTHOR_ID = :NEW.AUTHOR_ID. If the count is zero, insert a new row into COURSES with COURSE_ID as FLOOR(DBMS_RANDOM.VALUE(1,1000)), AUTHOR_ID as :NEW.AUTHOR_ID, SUBJECT_ID as 1, COURSE_NAME as 'New Course', and COURSE_DESCRIPTION as 'Description'.",
    "natural_language": "Construct a detailed AFTER INSERT row-level trigger, to be named trg_insert_course_author, which will be specifically applied to the COURSE_AUTHORS_AND_TUTORS table. For every single row that is newly inserted, the trigger must meticulously calculate the total number of existing courses where the AUTHOR_ID matches the freshly inserted :NEW.AUTHOR_ID. In the event that this comprehensive count is found to be precisely zero, indicating the author has no courses, the trigger must then proceed to insert a brand new row into the COURSES table. This new entry should have its COURSE_ID dynamically generated as FLOOR(DBMS_RANDOM.VALUE(1,1000)), its AUTHOR_ID set to the :NEW.AUTHOR_ID, its SUBJECT_ID assigned the value 1, its COURSE_NAME initialized as 'New Course', and its COURSE_DESCRIPTION populated with the text 'Description'.",
    "id": 162
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_student_enrolment that is defined to execute automatically before any row insertion operation on the STUDENT_COURSE_ENROLMENT table, and for each individual row being inserted, the trigger declares a local variable v_student_exists of type NUMBER, then performs a SELECT statement that queries the STUDENTS table to count the number of rows where the STUDENT_ID column value matches the value of the :NEW.STUDENT_ID bind variable from the triggering insert row, storing the result count into the v_student_exists variable, and then evaluates a conditional IF statement that checks if the v_student_exists variable equals zero, and if this condition is true, the trigger raises a custom application error with error code -20001 and the message 'Student does not exist', thereby preventing the insertion of the new row into STUDENT_COURSE_ENROLMENT.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_student_enrolment\nBEFORE INSERT ON STUDENT_COURSE_ENROLMENT\nFOR EACH ROW\nBEGIN\n    DECLARE\n        v_student_exists NUMBER;\n    BEGIN\n        SELECT COUNT(*) INTO v_student_exists FROM STUDENTS WHERE STUDENT_ID = :NEW.STUDENT_ID;\n        IF v_student_exists = 0 THEN\n            RAISE_APPLICATION_ERROR(-20001, 'Student does not exist');\n        END IF;\n    END;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (101, 1, 1, '2023-01-01', '2023-06-30')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (102, 2, 2, '2023-02-01', '2023-07-31')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (103, 3, 3, '2023-03-01', '2023-08-31')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (104, 999, 1, '2023-04-01', '2023-09-30')",
      "INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT, DATE_OF_COMPLETION) VALUES (105, 1, 4, '2023-05-01', '2023-10-31')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_check_student_enrolment on the STUDENT_COURSE_ENROLMENT table. For each row to be inserted, check if the STUDENT_ID exists in the STUDENTS table. If it does not exist, raise an application error with code -20001 and message 'Student does not exist' to prevent the insertion.",
    "natural_language": "Create trigger trg_check_student_enrolment on STUDENT_COURSE_ENROLMENT. Before insert, verify STUDENT_ID exists in STUDENTS. If not, raise error -20001: 'Student does not exist'.",
    "id": 163
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_subject_update that is executed after an update operation on the SUBJECTS table for each row affected by the update. The trigger begins by declaring a local variable v_course_count of type NUMBER, which is used to store the count of courses associated with the updated subject. The trigger then performs a SELECT statement to count the number of rows in the COURSES table where the SUBJECT_ID column matches the SUBJECT_ID of the updated row in the SUBJECTS table, using the :NEW.SUBJECT_ID reference to access the new value of the SUBJECT_ID column after the update. The result of this count is stored in the v_course_count variable. Following this, the trigger evaluates an IF conditional statement to check if the value of v_course_count is greater than zero, indicating that there are courses associated with the updated subject. If this condition is true, the trigger executes an UPDATE statement on the COURSES table, setting the COURSE_DESCRIPTION column to the string 'Updated Subject' for all rows where the SUBJECT_ID matches the :NEW.SUBJECT_ID value. This operation effectively updates the course descriptions for all courses linked to the subject that has been updated in the SUBJECTS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_subject_update\nAFTER UPDATE ON SUBJECTS\nFOR EACH ROW\nBEGIN\n    DECLARE\n        v_course_count NUMBER;\n    BEGIN\n        SELECT COUNT(*) INTO v_course_count FROM COURSES WHERE SUBJECT_ID = :NEW.SUBJECT_ID;\n        IF v_course_count > 0 THEN\n            UPDATE COURSES\n            SET COURSE_DESCRIPTION = 'Updated Subject'\n            WHERE SUBJECT_ID = :NEW.SUBJECT_ID;\n        END IF;\n    END;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "UPDATE SUBJECTS SET SUBJECT_NAME = 'Computer Science Updated' WHERE SUBJECT_ID = 1",
      "UPDATE SUBJECTS SET SUBJECT_NAME = 'Arts Updated' WHERE SUBJECT_ID = 2",
      "UPDATE SUBJECTS SET SUBJECT_NAME = 'Language Updated' WHERE SUBJECT_ID = 3",
      "UPDATE SUBJECTS SET SUBJECT_NAME = 'Mathematics' WHERE SUBJECT_ID = 4",
      "UPDATE SUBJECTS SET SUBJECT_NAME = 'Physics' WHERE SUBJECT_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_subject_update on the SUBJECTS table. For each updated row, count courses where SUBJECT_ID = :NEW.SUBJECT_ID. If the count is greater than zero, update the COURSES table, setting COURSE_DESCRIPTION to 'Updated Subject' for all rows where SUBJECT_ID = :NEW.SUBJECT_ID.",
    "natural_language": "Create a row-level trigger called trg_subject_update that fires AFTER UPDATE on the SUBJECTS table. For each updated row, count the courses linked to the new SUBJECT_ID. If the count exceeds zero, update the COURSES table by setting COURSE_DESCRIPTION to 'Updated Subject' for all courses with that SUBJECT_ID.",
    "id": 164
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_station_company_rank` that is activated `AFTER` an `INSERT` operation occurs on the `GAS_STATION` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `GAS_STATION` table. Upon activation, the trigger performs a single `INSERT` operation into the `STATION_COMPANY` table. The `INSERT` statement populates three columns in the `STATION_COMPANY` table: `STATION_ID`, `COMPANY_ID`, and `RANK_OF_THE_YEAR`. The value for the `STATION_ID` column is derived from the `STATION_ID` of the newly inserted row in the `GAS_STATION` table, referenced as `:NEW.STATION_ID`. The value for the `COMPANY_ID` column is a hardcoded literal integer `1`. The value for the `RANK_OF_THE_YEAR` column is determined by a subquery. This subquery calculates the `COUNT(*)` of all rows in the `STATION_COMPANY` table where the `COMPANY_ID` column is equal to the literal integer `1`. The result of this count is then incremented by `1` to produce the final value for `RANK_OF_THE_YEAR`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_station_company_rank\nAFTER INSERT ON GAS_STATION\nFOR EACH ROW\nBEGIN\n  INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR)\n  VALUES (:NEW.STATION_ID, 1, (SELECT COUNT(*) FROM STATION_COMPANY WHERE COMPANY_ID = 1) + 1);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (4, 2001, 'Central Park', 'John Doe', 'Jane Smith', 'Alice Johnson')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (5, 2002, 'Downtown', 'Michael Brown', 'Sarah Davis', 'Tom Wilson')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (6, 2003, 'Uptown', 'Chris Green', 'Laura White', 'Emma Thompson')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (7, 2004, 'Suburbia', 'David Black', 'Emily Clark', 'Oliver Harris')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (8, 2005, 'Riverside', 'Daniel King', 'Sophia Lewis', 'Liam Scott')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_update_station_company_rank on the GAS_STATION table. For each inserted row, insert a new row into STATION_COMPANY. Populate STATION_ID with :NEW.STATION_ID, COMPANY_ID with 1, and RANK_OF_THE_YEAR with (SELECT COUNT(*) FROM STATION_COMPANY WHERE COMPANY_ID = 1) + 1.",
    "natural_language": "Create a row-level trigger called trg_update_station_company_rank on the GAS_STATION table to fire after each insert. For every new row, insert a corresponding record into the STATION_COMPANY table. Set the STATION_ID to the new station's ID, the COMPANY_ID to 1, and calculate the RANK_OF_THE_YEAR as one more than the current total number of entries for company 1 in STATION_COMPANY.",
    "id": 165
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_company that is executed automatically after a new row is inserted into the STATION_COMPANY table. This trigger operates for each row that is inserted into the STATION_COMPANY table. Upon activation, it performs an insert operation into the COMPANY table, populating the columns COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, and MARKET_VALUE. The COMPANY_ID column in the COMPANY table is assigned the value from the COMPANY_ID column of the newly inserted row in the STATION_COMPANY table, accessed using the :NEW pseudo-record. The RANK column is set to the integer value 1. The COMPANY column is assigned the string 'New Company'. Both the HEADQUARTERS and MAIN_INDUSTRY columns are set to the string 'Unknown'. The SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, and MARKET_VALUE columns are all initialized to the numeric value 0. This trigger does not involve any conditional logic, function calls, or special operations beyond the straightforward insertion of fixed and derived values into the COMPANY table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_company\nAFTER INSERT ON STATION_COMPANY\nFOR EACH ROW\nBEGIN\n  INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE)\n  VALUES (:NEW.COMPANY_ID, 1, 'New Company', 'Unknown', 'Unknown', 0, 0, 0, 0);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (100, 999, 1)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (101, 1000, 2)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (102, 1001, 3)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (103, 1002, 1)",
      "INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (104, 1003, 2)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_company on the STATION_COMPANY table. For each new row, insert a corresponding row into the COMPANY table. Map COMPANY_ID from :NEW. Set RANK to 1, COMPANY to 'New Company', HEADQUARTERS and MAIN_INDUSTRY to 'Unknown', and SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, and MARKET_VALUE to 0.",
    "natural_language": "Please construct an AFTER INSERT row-level trigger designated as trg_insert_company on the STATION_COMPANY table. For every newly inserted row, it is required to insert a corresponding record into the COMPANY table. The COMPANY_ID should be mapped from the :NEW value. Assign a RANK of 1, set COMPANY to 'New Company', designate both HEADQUARTERS and MAIN_INDUSTRY as 'Unknown', and initialize the values for SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, and MARKET_VALUE to 0.",
    "id": 166
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_station_company that is defined to fire before any delete operation is performed on the COMPANY table, and it is configured to execute once for each individual row being deleted; within its execution block, it performs a delete operation on the STATION_COMPANY table, specifically targeting all rows where the COMPANY_ID column in the STATION_COMPANY table matches the value of the COMPANY_ID column from the row currently being deleted from the COMPANY table, which is accessed via the :OLD.COMPANY_ID pseudorecord qualifier.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_station_company\nBEFORE DELETE ON COMPANY\nFOR EACH ROW\nBEGIN\n  DELETE FROM STATION_COMPANY WHERE COMPANY_ID = :OLD.COMPANY_ID;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "DELETE FROM COMPANY WHERE COMPANY_ID = 1",
      "DELETE FROM COMPANY WHERE COMPANY_ID = 2",
      "DELETE FROM COMPANY WHERE COMPANY_ID = 3",
      "DELETE FROM COMPANY WHERE COMPANY_ID = 4",
      "DELETE FROM COMPANY WHERE COMPANY_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_delete_station_company on the COMPANY table. For each row being deleted, delete all rows from the STATION_COMPANY table where its COMPANY_ID matches the :OLD.COMPANY_ID from the COMPANY table.",
    "natural_language": "Write a BEFORE DELETE row-level trigger called trg_delete_station_company for the COMPANY table. For each deleted row, remove all corresponding records from the STATION_COMPANY table where the COMPANY_ID equals the :OLD.COMPANY_ID.",
    "id": 167
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named update_gymnast_total that is defined to fire BEFORE any INSERT or UPDATE operation on the GYMNAST table, and it executes FOR EACH ROW affected by the operation; the trigger's logic is to calculate a new value for the TOTAL_POINTS column of the newly inserted or updated row, represented by the :NEW pseudorecord, by performing an arithmetic addition of the values from six specific columns within the same :NEW pseudorecord: FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS, and then assigning the resulting sum directly to the :NEW.TOTAL_POINTS column.",
    "plsql": "CREATE OR REPLACE TRIGGER update_gymnast_total\nBEFORE INSERT OR UPDATE ON GYMNAST\nFOR EACH ROW\nBEGIN\n  :NEW.TOTAL_POINTS := :NEW.FLOOR_EXERCISE_POINTS + :NEW.POMMEL_HORSE_POINTS + :NEW.RINGS_POINTS + :NEW.VAULT_POINTS + :NEW.PARALLEL_BARS_POINTS + :NEW.HORIZONTAL_BAR_POINTS;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (10, 9.5, 9.6, 9.7, 9.4, 9.8, 9.3)",
      "UPDATE GYMNAST SET FLOOR_EXERCISE_POINTS = 9.8 WHERE GYMNAST_ID = 1",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (11, 8.9, 9.1, 9.0, 9.2, 9.4, 9.5)",
      "UPDATE GYMNAST SET POMMEL_HORSE_POINTS = 9.9, RINGS_POINTS = 9.8 WHERE GYMNAST_ID = 2",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (12, 10.0, 9.85, 9.9, 9.95, 9.87, 9.92)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named update_gymnast_total on the GYMNAST table. For each row, set :NEW.TOTAL_POINTS to the sum of :NEW.FLOOR_EXERCISE_POINTS, :NEW.POMMEL_HORSE_POINTS, :NEW.RINGS_POINTS, :NEW.VAULT_POINTS, :NEW.PARALLEL_BARS_POINTS, and :NEW.HORIZONTAL_BAR_POINTS.",
    "natural_language": "Set up a trigger on the GYMNAST table that fires before adding or changing a row. Name it something like update_gymnast_total. For each new or updated record, make the TOTAL_POINTS field hold a value that roughly represents the combined score from all the different apparatuseslike the floor, pommel horse, rings, vault, parallel bars, and horizontal bar. Basically, it should be the total of those main event scores.",
    "id": 168
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named adjust_points_by_age that fires before any insert or update operation on the GYMNAST table for each affected row, which declares a local variable v_people_age of type NUMBER, then queries the AGE column from the PEOPLE table by selecting the row where the PEOPLE_ID column matches the new GYMNAST_ID value from the triggering row in the GYMNAST table, storing the result in v_people_age, and subsequently uses a conditional IF-ELSIF-ELSE block to adjust the new TOTAL_POINTS value in the GYMNAST row: if the retrieved age equals 18, the new TOTAL_POINTS is multiplied by 1.1; if the age equals 19, it is multiplied by 1.05; for any other age value, the new TOTAL_POINTS remains unchanged.",
    "plsql": "CREATE OR REPLACE TRIGGER adjust_points_by_age\nBEFORE INSERT OR UPDATE ON GYMNAST\nFOR EACH ROW\nDECLARE\n  v_people_age NUMBER;\nBEGIN\n  SELECT AGE INTO v_people_age FROM PEOPLE WHERE PEOPLE_ID = :NEW.GYMNAST_ID;\n  \n  IF v_people_age = 18 THEN\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS * 1.1;\n  ELSIF v_people_age = 19 THEN\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS * 1.05;\n  ELSE\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS;\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) \nVALUES (1, 9.725, 9.737, 9.512, 9.575, 9.762, 9.75, 58.061)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) \nVALUES (2, 9.7, 9.625, 9.625, 9.65, 9.587, 9.737, 57.924)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) \nVALUES (4, 8.987, 9.75, 9.75, 9.65, 9.787, 9.725, 57.649)",
      "UPDATE GYMNAST SET TOTAL_POINTS = 58.5 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET TOTAL_POINTS = 57.0 WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named adjust_points_by_age on the GYMNAST table. For each row, retrieve the AGE from the PEOPLE table where PEOPLE_ID = :NEW.GYMNAST_ID. If the age is 18, multiply :NEW.TOTAL_POINTS by 1.1. If the age is 19, multiply it by 1.05. Otherwise, leave it unchanged.",
    "natural_language": "Alright, so we need a trigger that fires off before a new gymnast gets added or an existing one gets updated. Call it \"adjust_points_by_age\". Here's the deal: every time a row in the GYMNAST table is touched, you gotta look up that gymnast's age from the PEOPLE table using their ID. If they're 18, bump up their TOTAL_POINTS by 10% (just multiply by 1.1). If they're 19, give 'em a smaller boost, like 5% (multiply by 1.05). For any other age, don't change a thing, just leave the points as they are.",
    "id": 169
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `validate_gymnast_height` on the `GYMNAST` table. This trigger is activated for each row immediately before an `INSERT` operation or an `UPDATE` operation is performed on the `GYMNAST` table. The trigger declares a local numeric variable `v_gymnast_height` to temporarily store the height of a gymnast. Upon activation, the trigger first executes a `SELECT` statement to retrieve the `HEIGHT` column value from the `PEOPLE` table. This `SELECT` statement uses the `PEOPLE_ID` column in the `PEOPLE` table to match against the `GYMNAST_ID` column value of the row currently being inserted or updated in the `GYMNAST` table (referenced as `:NEW.GYMNAST_ID`). The retrieved `HEIGHT` value is then stored into the `v_gymnast_height` variable. Following this, the trigger evaluates a conditional `IF` statement: if the value stored in `v_gymnast_height` is less than `1.65`, then the `TOTAL_POINTS` column of the row currently being inserted or updated in the `GYMNAST` table (referenced as `:NEW.TOTAL_POINTS`) is updated by multiplying its current value by `0.95`. If the condition `v_gymnast_height < 1.65` is false, no action is taken on the `TOTAL_POINTS` column.",
    "plsql": "CREATE OR REPLACE TRIGGER validate_gymnast_height\nBEFORE INSERT OR UPDATE ON GYMNAST\nFOR EACH ROW\nDECLARE\n  v_gymnast_height NUMBER;\nBEGIN\n  SELECT HEIGHT INTO v_gymnast_height FROM PEOPLE WHERE PEOPLE_ID = :NEW.GYMNAST_ID;\n  IF v_gymnast_height < 1.65 THEN\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS * 0.95;\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN) VALUES (101, 'John Doe', 25, 1.60, 'New York');\nINSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (101, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 54.0)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN) VALUES (102, 'Jane Smith', 22, 1.70, 'Los Angeles');\nINSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (102, 9.5, 9.5, 9.5, 9.5, 9.5, 9.5, 57.0)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN) VALUES (103, 'Peter Jones', 28, 1.64, 'Chicago');\nINSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (103, 8.8, 8.8, 8.8, 8.8, 8.8, 8.8, 52.8)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN) VALUES (104, 'Alice Brown', 20, 1.66, 'Houston');\nINSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (104, 9.2, 9.2, 9.2, 9.2, 9.2, 9.2, 55.2)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN) VALUES (105, 'Bob White', 23, 1.55, 'Miami');\nINSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (105, 8.5, 8.5, 8.5, 8.5, 8.5, 8.5, 51.0)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named validate_gymnast_height on the GYMNAST table. For each row, retrieve the HEIGHT from the PEOPLE table where PEOPLE_ID = :NEW.GYMNAST_ID. If the retrieved height is less than 1.65, multiply :NEW.TOTAL_POINTS by 0.95.",
    "natural_language": "Alright, so we need a trigger that fires off before you insert or update a row in the GYMNAST table. Let's call it \"validate_gymnast_height\". For each new or updated gymnast, we've gotta go check their height over in the PEOPLE table, using their PEOPLE_ID (which matches the new GYMNAST_ID). If it turns out they're shorter than 1.65 meters, we'll knock 5% off their TOTAL_POINTS by multiplying it by 0.95.",
    "id": 170
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named set_minimum_points that fires before any insert operation on the GYMNAST table for each individual row being inserted, and within its execution block, it assigns a value to the TOTAL_POINTS column of the new row using the NVL function, which evaluates the incoming value for the :NEW.TOTAL_POINTS column and, if that value is null, replaces it with the numeric literal 50, thereby ensuring the TOTAL_POINTS column for the inserted record is never null by defaulting it to 50.",
    "plsql": "CREATE OR REPLACE TRIGGER set_minimum_points\nBEFORE INSERT ON GYMNAST\nFOR EACH ROW\nBEGIN\n  :NEW.TOTAL_POINTS := NVL(:NEW.TOTAL_POINTS, 50);\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (3, 9.8, 9.7, 9.6, 9.5, 9.7, 9.8)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (5, 9.9, 9.8, 9.7, 9.6, 9.8, 9.9)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (6, 9.85, 9.75, 9.65, 9.55, 9.75, 9.85)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (7, 9.7, 9.6, 9.5, 9.4, 9.6, 9.7)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) VALUES (8, 9.75, 9.65, 9.55, 9.45, 9.65, 9.75)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named set_minimum_points on the GYMNAST table. Use NVL to set the :NEW.TOTAL_POINTS to 50 if the incoming value is NULL.",
    "natural_language": "Create trigger set_minimum_points on GYMNAST before insert. Use NVL to set new TOTAL_POINTS to 50 if null.",
    "id": 171
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `normalize_gymnast_points` that is configured to execute `BEFORE` any `UPDATE` operation is performed on a row in the `GYMNAST` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed individually for every row that is being updated. The trigger's purpose is to enforce a business rule on the `TOTAL_POINTS` column of the `GYMNAST` table. Specifically, it contains a conditional statement (`IF :NEW.TOTAL_POINTS > 60 THEN`) that checks the value of the `TOTAL_POINTS` column for the row currently being updated. The `:NEW` pseudorecord refers to the new values that are attempting to be written to the row. If the value of `:NEW.TOTAL_POINTS` is found to be strictly greater than `60`, then the trigger modifies the value of `:NEW.TOTAL_POINTS` by setting it to `60` (`:NEW.TOTAL_POINTS := 60;`). This modification occurs before the actual update operation is committed to the database, effectively capping the `TOTAL_POINTS` value at `60` if an attempt is made to update it to a higher value.",
    "plsql": "CREATE OR REPLACE TRIGGER normalize_gymnast_points\nBEFORE UPDATE ON GYMNAST\nFOR EACH ROW\nBEGIN\n  IF :NEW.TOTAL_POINTS > 60 THEN\n    :NEW.TOTAL_POINTS := 60;\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "UPDATE GYMNAST SET TOTAL_POINTS = 65 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET TOTAL_POINTS = 55 WHERE GYMNAST_ID = 2",
      "UPDATE GYMNAST SET TOTAL_POINTS = 70 WHERE GYMNAST_ID = 4",
      "UPDATE GYMNAST SET TOTAL_POINTS = 60.01 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET TOTAL_POINTS = 59.99 WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named normalize_gymnast_points on the GYMNAST table. If :NEW.TOTAL_POINTS is greater than 60, set it to 60.",
    "natural_language": "Construct a BEFORE UPDATE FOR EACH ROW trigger, which should be named normalize_gymnast_points, specifically for the GYMNAST table. This trigger must carefully check the newly provided value; if the :NEW.TOTAL_POINTS value is found to be greater than the maximum allowable score of 60, it should then be explicitly and permanently capped at that precise upper limit of 60.",
    "id": 172
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_salary_range that is defined to fire automatically after any INSERT operation or UPDATE operation is performed on the EMPLOYEES table, and it is configured to execute once for each row affected by the triggering statement. The trigger declares two local variables, v_min_salary and v_max_salary, which are defined to have the same data type as the MIN_SALARY and MAX_SALARY columns of the JOBS table, respectively. For each new or updated employee row, the trigger performs a SELECT statement to query the JOBS table, retrieving the MIN_SALARY and MAX_SALARY values from the single row where the JOB_ID column matches the new JOB_ID value from the :NEW pseudorecord, which represents the incoming row data from the INSERT or UPDATE operation on EMPLOYEES; these retrieved values are stored into the local variables v_min_salary and v_max_salary. The trigger then evaluates a conditional IF statement: first, it checks if the new SALARY value from the :NEW pseudorecord is less than the retrieved v_min_salary value; if this condition is true, the trigger calls the RAISE_APPLICATION_ERROR built-in procedure with error number -20001 and the message 'Salary is below the minimum for this job.', which immediately stops execution and causes the triggering INSERT or UPDATE operation to fail and roll back. If the first condition is false, the trigger proceeds to an ELSIF condition to check if the new SALARY value from the :NEW pseudorecord is greater than the retrieved v_max_salary value; if this condition is true, the trigger calls RAISE_APPLICATION_ERROR with error number -20002 and the message 'Salary exceeds the maximum for this job.', again causing the operation to fail. If neither condition is met, meaning the new salary is within the inclusive range defined by v_min_salary and v_max_salary, the trigger executes a NULL statement, which performs no action and allows the triggering INSERT or UPDATE operation to proceed successfully.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_salary_range\nAFTER INSERT OR UPDATE ON EMPLOYEES\nFOR EACH ROW\nDECLARE\n    v_min_salary JOBS.MIN_SALARY%TYPE;\n    v_max_salary JOBS.MAX_SALARY%TYPE;\nBEGIN\n    SELECT MIN_SALARY, MAX_SALARY INTO v_min_salary, v_max_salary\n    FROM JOBS\n    WHERE JOB_ID = :NEW.JOB_ID;\n\n    IF :NEW.SALARY < v_min_salary THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Salary is below the minimum for this job.');\n    ELSIF :NEW.SALARY > v_max_salary THEN\n        RAISE_APPLICATION_ERROR(-20002, 'Salary exceeds the maximum for this job.');\n    ELSE\n        NULL;\n    END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, DEPARTMENT_ID) VALUES (207, 'John', 'Doe', 'JDOE', '555.123.4567', '2024-01-15', 'AD_PRES', 25000, 90)",
      "UPDATE EMPLOYEES SET SALARY = 18000 WHERE EMPLOYEE_ID = 101",
      "INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, DEPARTMENT_ID) VALUES (208, 'Jane', 'Smith', 'JSMITH', '555.123.4568', '2024-01-16', 'AD_ASST', 5000, 10)",
      "UPDATE EMPLOYEES SET SALARY = 35000, JOB_ID = 'AD_VP' WHERE EMPLOYEE_ID = 102",
      "INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, DEPARTMENT_ID) VALUES (209, 'Bob', 'Wilson', 'BWILSON', '555.123.4569', '2024-01-17', 'AD_VP', 31000, 20)"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE FOR EACH ROW trigger named trg_check_salary_range on the EMPLOYEES table. For each row, get the MIN_SALARY and MAX_SALARY for the new JOB_ID from the JOBS table. If the new SALARY is below the minimum, raise error -20001 'Salary is below the minimum for this job.'. If it is above the maximum, raise error -20002 'Salary exceeds the maximum for this job.'.",
    "natural_language": "Create trigger trg_check_salary_range on EMPLOYEES. On insert or update, check new salary against job's min and max from JOBS. If too low, error -20001. If too high, error -20002.",
    "id": 173
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_employee_job_history that activates after an update operation on the JOB_ID column of the EMPLOYEES table for each row affected by the update. The trigger begins by declaring a local variable v_count of type NUMBER, which is used to store the count of records retrieved from the JOB_HISTORY table. The trigger then executes a SELECT statement to count the number of records in the JOB_HISTORY table where the EMPLOYEE_ID matches the old value of EMPLOYEE_ID from the updated row and the END_DATE is NULL, storing the result in v_count. If v_count equals zero, indicating no current job history record exists for the employee, the trigger performs an INSERT operation into the JOB_HISTORY table, adding a new record with the old EMPLOYEE_ID, the current system date as START_DATE, NULL as END_DATE, the old JOB_ID, and the old DEPARTMENT_ID. If v_count is not zero, indicating an existing job history record is present, the trigger updates the JOB_HISTORY table by setting the END_DATE to the current system date for the record where EMPLOYEE_ID matches the old EMPLOYEE_ID and END_DATE is NULL. Subsequently, the trigger inserts a new record into the JOB_HISTORY table with the new EMPLOYEE_ID, the current system date as START_DATE, NULL as END_DATE, the new JOB_ID, and the new DEPARTMENT_ID, effectively creating a new job history entry for the employee's updated job position.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_employee_job_history\nAFTER UPDATE OF JOB_ID ON EMPLOYEES\nFOR EACH ROW\nDECLARE\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM JOB_HISTORY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID AND END_DATE IS NULL;\n\n    IF v_count = 0 THEN\n        INSERT INTO JOB_HISTORY (EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)\n        VALUES (:OLD.EMPLOYEE_ID, SYSDATE, NULL, :OLD.JOB_ID, :OLD.DEPARTMENT_ID);\n    ELSE\n        UPDATE JOB_HISTORY SET END_DATE = SYSDATE WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID AND END_DATE IS NULL;\n        INSERT INTO JOB_HISTORY (EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID)\n        VALUES (:NEW.EMPLOYEE_ID, SYSDATE, NULL, :NEW.JOB_ID, :NEW.DEPARTMENT_ID);\n    END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "UPDATE EMPLOYEES SET JOB_ID = 'IT_PROG' WHERE EMPLOYEE_ID = 100",
      "UPDATE EMPLOYEES SET JOB_ID = 'AD_VP', DEPARTMENT_ID = 90 WHERE EMPLOYEE_ID = 101",
      "UPDATE EMPLOYEES SET JOB_ID = 'AD_ASST' WHERE EMPLOYEE_ID = 102",
      "UPDATE EMPLOYEES SET JOB_ID = 'AC_MGR', DEPARTMENT_ID = 110 WHERE EMPLOYEE_ID = 200",
      "UPDATE EMPLOYEES SET JOB_ID = 'AC_ACCOUNT' WHERE EMPLOYEE_ID = 201"
    ],
    "summary": "Create an AFTER UPDATE OF JOB_ID FOR EACH ROW trigger named trg_employee_job_history on the EMPLOYEES table. Check if a record exists in JOB_HISTORY for the employee with a NULL END_DATE. If not, insert a new history record with the old job details and a NULL END_DATE. If one exists, update that record's END_DATE to SYSDATE. Then, insert a new history record with the new job details and a NULL END_DATE.",
    "natural_language": "Set up a trigger on the EMPLOYEES table for when a job gets changed. The trigger should look at the job history for that person. If there isn't a current, open history entry, just make a new one with the old job info. If there is one of those open entries already, close it off with today's date. Then, in either case, add a fresh entry for the new job to show it's the current one.",
    "id": 174
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_location that is defined to fire automatically after each row is inserted into or updated in the DEPARTMENTS table, and within its declarative section it defines a local variable v_count of type NUMBER; in its execution section, for each affected row, it performs a SELECT statement that queries the LOCATIONS table to count the number of rows where the LOCATION_ID column value equals the new LOCATION_ID value from the triggering row in DEPARTMENTS (referenced as :NEW.LOCATION_ID), storing the result into the v_count variable, then evaluates a conditional IF statement: if the v_count value is exactly zero, it raises a user-defined application error with error code -20004 and the message 'Invalid location ID.', otherwise, if v_count is not zero, it executes a NULL statement to take no action.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_location\nAFTER INSERT OR UPDATE ON DEPARTMENTS\nFOR EACH ROW\nDECLARE\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM LOCATIONS WHERE LOCATION_ID = :NEW.LOCATION_ID;\n\n    IF v_count = 0 THEN\n        RAISE_APPLICATION_ERROR(-20004, 'Invalid location ID.');\n    ELSE\n        NULL;\n    END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID) VALUES (280, 'New Department 1', 200, 1000)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID) VALUES (290, 'New Department 2', 201, 1100)",
      "UPDATE DEPARTMENTS SET LOCATION_ID = 1200 WHERE DEPARTMENT_ID = 10",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID) VALUES (300, 'Invalid Department', 200, 9999)",
      "UPDATE DEPARTMENTS SET LOCATION_ID = 9999 WHERE DEPARTMENT_ID = 20"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE FOR EACH ROW trigger named trg_check_location on the DEPARTMENTS table. Check if the new LOCATION_ID exists in the LOCATIONS table. If it does not exist (count is zero), raise application error -20004 'Invalid location ID.'.",
    "natural_language": "Construct an AFTER INSERT OR UPDATE FOR EACH ROW trigger, which should be named trg_check_location, on the DEPARTMENTS table. This trigger must meticulously verify whether the newly provided LOCATION_ID actually exists within the LOCATIONS table. If, upon checking, the count is found to be zero, indicating the location does not exist, the trigger must promptly raise a specific application error, numbered -20004, with the detailed message 'Invalid location ID.'.",
    "id": 175
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_employee_commission_check` that is activated `AFTER` an `UPDATE` operation specifically on the `COMMISSION_PCT` column of the `EMPLOYEES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is affected by the `UPDATE` statement. Upon activation, the trigger declares a local variable `v_job_title` of the same data type as the `JOB_TITLE` column in the `JOBS` table. The trigger then performs a `SELECT` operation to retrieve the `JOB_TITLE` from the `JOBS` table, storing the result into the `v_job_title` variable. This `SELECT` statement uses a `WHERE` clause to match the `JOB_ID` from the `JOBS` table with the `JOB_ID` of the row currently being updated in the `EMPLOYEES` table, which is referenced using the `:NEW.JOB_ID` pseudorecord. Following this, the trigger evaluates a conditional `IF` statement. The first condition checks if the `v_job_title` is exactly equal to the string literal 'Sales Representative' `AND` if the `COMMISSION_PCT` of the updated row (`:NEW.COMMISSION_PCT`) `IS NULL`. If both parts of this condition are true, the trigger raises an application error with the error code `-20005` and the error message 'Sales Representatives must have a commission percentage.'. If the first condition is false, the trigger proceeds to an `ELSIF` condition. This `ELSIF` condition checks if the `v_job_title` is `NOT` equal to the string literal 'Sales Representative' `AND` if the `COMMISSION_PCT` of the updated row (`:NEW.COMMISSION_PCT`) `IS NOT NULL`. If both parts of this `ELSIF` condition are true, the trigger raises an application error with the error code `-20006` and the error message 'Only Sales Representatives can have a commission percentage.'. If neither the `IF` nor the `ELSIF` conditions are met, the `ELSE` block is executed, which contains a `NULL` statement, indicating that no action is taken and the update operation is allowed to proceed without error.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_employee_commission_check\nAFTER UPDATE OF COMMISSION_PCT ON EMPLOYEES\nFOR EACH ROW\nDECLARE\n    v_job_title JOBS.JOB_TITLE%TYPE;\nBEGIN\n    SELECT JOB_TITLE INTO v_job_title FROM JOBS WHERE JOB_ID = :NEW.JOB_ID;\n\n    IF v_job_title = 'Sales Representative' AND :NEW.COMMISSION_PCT IS NULL THEN\n        RAISE_APPLICATION_ERROR(-20005, 'Sales Representatives must have a commission percentage.');\n    ELSIF v_job_title <> 'Sales Representative' AND :NEW.COMMISSION_PCT IS NOT NULL THEN\n        RAISE_APPLICATION_ERROR(-20006, 'Only Sales Representatives can have a commission percentage.');\n    ELSE\n        NULL;\n    END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "UPDATE EMPLOYEES SET COMMISSION_PCT = NULL WHERE EMPLOYEE_ID = 100 AND JOB_ID = 'SA_REP'",
      "UPDATE EMPLOYEES SET COMMISSION_PCT = 0.2 WHERE EMPLOYEE_ID = 101 AND JOB_ID = 'SA_REP'",
      "UPDATE EMPLOYEES SET COMMISSION_PCT = 0.15 WHERE EMPLOYEE_ID = 102 AND JOB_ID = 'IT_PROG'",
      "UPDATE EMPLOYEES SET COMMISSION_PCT = NULL, JOB_ID = 'SA_REP' WHERE EMPLOYEE_ID = 103",
      "UPDATE EMPLOYEES SET COMMISSION_PCT = 0.1 WHERE EMPLOYEE_ID = 104 AND JOB_ID = 'SA_REP'"
    ],
    "summary": "Create a trigger named `trg_employee_commission_check` that fires AFTER UPDATE on the `COMMISSION_PCT` column of the `EMPLOYEES` table for each row. It retrieves the `JOB_TITLE` from the `JOBS` table based on the new `JOB_ID`. If the job title is 'Sales Representative' and the new `COMMISSION_PCT` is NULL, raise error -20005: 'Sales Representatives must have a commission percentage.'. If the job title is NOT 'Sales Representative' and the new `COMMISSION_PCT` is NOT NULL, raise error -20006: 'Only Sales Representatives can have a commission percentage.'.",
    "natural_language": "Alright, so we need a trigger called `trg_employee_commission_check`. It should kick in AFTER we update the `COMMISSION_PCT` field in the `EMPLOYEES` table for each changed row. First, it's gotta grab the `JOB_TITLE` from the `JOBS` table using the new `JOB_ID`. Here's the deal: if the job title is 'Sales Representative' but the new commission percentage is empty (NULL), then throw an error with code -20005 saying, \"Hey, Sales Reps gotta have a commission percentage!\". On the flip side, if the job isn't 'Sales Representative' but someone tries to stick a commission percentage in there, that's a no-gofire error -20006 with the message, \"Only Sales Reps can get a commission, buddy.\"",
    "id": 176
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `songs_title_check_trigger` that is activated `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `SONGS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row affected by the `INSERT` or `UPDATE` statement. Within the trigger's execution block, a local numeric variable named `v_title_length` is declared. The trigger then calculates the length of the `TITLE` column of the row currently being processed (referred to as `:NEW.TITLE` in the context of `BEFORE` row-level triggers, representing the new value of the column) using the `LENGTH` function, and assigns this calculated length to the `v_title_length` variable. Following this, a conditional `IF-ELSIF-ELSE` statement evaluates the value of `v_title_length`. If `v_title_length` is less than `5`, the `TITLE` column of the new or updated row (`:NEW.TITLE`) is modified by prepending the string literal `'SHORT_'` to its current value. If `v_title_length` is not less than `5` but is `BETWEEN` `5` and `15` (inclusive), the `TITLE` column of the new or updated row (`:NEW.TITLE`) is modified by prepending the string literal `'MEDIUM_'` to its current value. In all other cases (i.e., if `v_title_length` is `16` or greater), the `TITLE` column of the new or updated row (`:NEW.TITLE`) is modified by prepending the string literal `'LONG_'` to its current value. The trigger concludes after these conditional modifications to the `:NEW.TITLE` value.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_check_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 5 THEN\n        :NEW.TITLE := 'SHORT_' || :NEW.TITLE;\n    ELSIF v_title_length BETWEEN 5 AND 15 THEN\n        :NEW.TITLE := 'MEDIUM_' || :NEW.TITLE;\n    ELSE\n        :NEW.TITLE := 'LONG_' || :NEW.TITLE;\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'Rock')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'Pop Song')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'A Very Long Song Title Indeed')",
      "UPDATE SONGS SET TITLE = 'New Rock' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'Updated Pop Song Title' WHERE SONGID = 2"
    ],
    "summary": "Create a trigger named `songs_title_check_trigger` that fires BEFORE INSERT or UPDATE on the `SONGS` table for each row. Based on the length of the new `TITLE`: if less than 5, prepend 'SHORT_'; if between 5 and 15 inclusive, prepend 'MEDIUM_'; otherwise, prepend 'LONG_'.",
    "natural_language": "Hey, can you set up a trigger called `songs_title_check_trigger`? It should kick in BEFORE we INSERT or UPDATE a row in the `SONGS` table. For each new row, check the length of the `TITLE`: if it's less than 5 characters, slap 'SHORT_' in front of it; if it's between 5 and 15 characters (including those numbers), put 'MEDIUM_' in front; otherwise, if it's longer, just stick 'LONG_' at the beginning.",
    "id": 177
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named songs_title_modification_trigger that is executed before an insert or update operation on the SONGS table for each row affected by the operation. The trigger declares a local variable v_title_length of type NUMBER to store the length of the TITLE column of the new row being inserted or updated. The trigger calculates the length of the TITLE column using the LENGTH() function and assigns it to v_title_length. It then evaluates the length of the TITLE using a series of conditional statements. If the length of the TITLE is less than 8 characters, the TITLE is converted to lowercase using the LOWER() function and assigned back to the :NEW.TITLE, which represents the new value of the TITLE column for the row being processed. If the length of the TITLE is between 8 and 12 characters inclusive, the TITLE is converted to uppercase using the UPPER() function and assigned back to :NEW.TITLE. If the length of the TITLE is greater than 12 characters, the TITLE is truncated to the first 20 characters using the SUBSTR() function, which extracts a substring starting from the first character up to the 20th character, and this substring is assigned back to :NEW.TITLE. The trigger ensures that the TITLE column of the SONGS table is modified according to the specified conditions before the row is inserted or updated in the database.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_modification_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 8 THEN\n        :NEW.TITLE := LOWER(:NEW.TITLE);\n    ELSIF v_title_length BETWEEN 8 AND 12 THEN\n        :NEW.TITLE := UPPER(:NEW.TITLE);\n    ELSE\n        :NEW.TITLE := SUBSTR(:NEW.TITLE, 1, 20);\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'Short')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'MediumTitle')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'ThisIsAVeryLongTitleThatExceedsTwentyCharacters')",
      "UPDATE SONGS SET TITLE = 'UpdateShort' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'UpdateMediumTitle' WHERE SONGID = 2"
    ],
    "summary": "Create a trigger named `songs_title_modification_trigger` that fires BEFORE INSERT or UPDATE on the `SONGS` table for each row. Based on the length of the new `TITLE`: if less than 8, convert to lowercase; if between 8 and 12 inclusive, convert to uppercase; if greater than 12, truncate to the first 20 characters.",
    "natural_language": "Define a trigger called `songs_title_modification_trigger` to execute BEFORE INSERT or UPDATE on the `SONGS` table for each row. For the new `TITLE` value, apply these rules: convert it to lowercase if its length is less than 8; convert it to uppercase if its length is between 8 and 12 inclusive; and truncate it to the first 20 characters if its length is greater than 12.",
    "id": 178
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named songs_title_adjustment_trigger that executes automatically before any INSERT or UPDATE operation on the SONGS table for each affected row, and within its execution block, it first declares a local variable v_title_length of type NUMBER, then assigns to this variable the result of the LENGTH function called on the new value of the TITLE column from the triggering row, referenced as :NEW.TITLE, and then uses a conditional IF-ELSIF-ELSE statement to check the value of v_title_length: if v_title_length is less than 6, it prepends the string literal 'MINI_' to the original :NEW.TITLE value and reassigns this concatenated result back to the :NEW.TITLE column; if v_title_length is between 6 and 10 inclusive (using the BETWEEN operator), it prepends the string literal 'MIDI_' to the original :NEW.TITLE value and reassigns this concatenated result back to the :NEW.TITLE column; otherwise, for any case where v_title_length is greater than 10, it prepends the string literal 'MAXI_' to the original :NEW.TITLE value and reassigns this concatenated result back to the :NEW.TITLE column.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_adjustment_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 6 THEN\n        :NEW.TITLE := 'MINI_' || :NEW.TITLE;\n    ELSIF v_title_length BETWEEN 6 AND 10 THEN\n        :NEW.TITLE := 'MIDI_' || :NEW.TITLE;\n    ELSE\n        :NEW.TITLE := 'MAXI_' || :NEW.TITLE;\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'Short')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'Medium')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'LongerTitle')",
      "UPDATE SONGS SET TITLE = 'Tiny' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'ExtendedTitle' WHERE SONGID = 2"
    ],
    "summary": "Create a trigger named `songs_title_adjustment_trigger` that fires BEFORE INSERT or UPDATE on the `SONGS` table for each row. Based on the length of the new `TITLE`: if less than 6, prepend 'MINI_'; if between 6 and 10 inclusive, prepend 'MIDI_'; otherwise, prepend 'MAXI_'.",
    "natural_language": "Set up a trigger called `songs_title_adjustment_trigger` to run before adding or changing records in the `SONGS` table. For each new entry, look at how long the `TITLE` is. If it's pretty short, stick 'MINI_' in front. If it's a medium kind of length, put 'MIDI_' at the beginning. For the really long ones, just start it with 'MAXI_'.",
    "id": 179
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `songs_title_format_trigger` that is configured to execute automatically `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `SONGS` table, and for `EACH ROW` affected by such an operation. This trigger declares a local numeric variable named `v_title_length` to store the length of the song title. Upon activation, the trigger first calculates the length of the `TITLE` column of the row currently being inserted or updated (referred to as `:NEW.TITLE`) using the `LENGTH` SQL function, and assigns this calculated value to the `v_title_length` variable. Subsequently, it evaluates a series of conditional statements based on the value of `v_title_length`. If `v_title_length` is less than 7, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by applying the `INITCAP` SQL function to its current value, which converts the first letter of each word in the title to uppercase and the rest to lowercase. If the first condition is false, the trigger then checks if `v_title_length` is `BETWEEN` 7 and 14 (inclusive). If this condition is true, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by replacing all occurrences of a single space character (' ') with an underscore character ('_') within its current value, using the `REPLACE` SQL function. If both preceding conditions are false, meaning `v_title_length` is greater than 14, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by extracting a substring from its current value, starting from the first character (position 1) and extending for a maximum of 25 characters, using the `SUBSTR` SQL function.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_format_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 7 THEN\n        :NEW.TITLE := INITCAP(:NEW.TITLE);\n    ELSIF v_title_length BETWEEN 7 AND 14 THEN\n        :NEW.TITLE := REPLACE(:NEW.TITLE, ' ', '_');\n    ELSE\n        :NEW.TITLE := SUBSTR(:NEW.TITLE, 1, 25);\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'short')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'medium length')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'This is a very long title that exceeds the limit')",
      "UPDATE SONGS SET TITLE = 'tiny' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'adequate length' WHERE SONGID = 2"
    ],
    "summary": "Create a trigger named `songs_title_format_trigger` that fires BEFORE INSERT or UPDATE on the `SONGS` table for each row. Based on the length of the new `TITLE`: if less than 7, apply `INITCAP`; if between 7 and 14 inclusive, replace spaces with underscores; if greater than 14, truncate to the first 25 characters.",
    "natural_language": "Set up a trigger called `songs_title_format_trigger` to run before adding or changing records in the `SONGS` table. For each new entry, adjust the `TITLE` in a certain way depending roughly on how long it is: for pretty short titles, make them proper case; for titles of a medium length, swap out spaces with underscores; and for the really long ones, just cut them off after a bunch of characters.",
    "id": 180
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named songs_title_prefix_trigger that fires before any insert or update operation on the SONGS table for each affected row, declaring a local variable v_title_length of type NUMBER, then assigning to it the character length of the new value for the TITLE column from the :NEW pseudorecord, then checking if v_title_length is less than 9 and, if true, prepending the string literal 'PREFIX_' to the :NEW.TITLE value, or else checking if v_title_length is between 9 and 18 inclusive and, if true, prepending the string literal 'SUFFIX_' to the :NEW.TITLE value, or else for any other case where v_title_length is greater than 18, assigning to :NEW.TITLE a new string formed by concatenating the literal 'TRUNC_' with a substring extracted from the original :NEW.TITLE starting at the first character and spanning 15 characters.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_prefix_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 9 THEN\n        :NEW.TITLE := 'PREFIX_' || :NEW.TITLE;\n    ELSIF v_title_length BETWEEN 9 AND 18 THEN\n        :NEW.TITLE := 'SUFFIX_' || :NEW.TITLE;\n    ELSE\n        :NEW.TITLE := 'TRUNC_' || SUBSTR(:NEW.TITLE, 1, 15);\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'Short')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'MediumTitle')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'ThisIsAVeryLongTitle')",
      "UPDATE SONGS SET TITLE = 'Tiny' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'AnotherLongTitleExample' WHERE SONGID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named SONGS_TITLE_PREFIX_TRIGGER on the SONGS table. For each row, modify the new TITLE value based on its length: if less than 9 characters, prepend 'PREFIX_'; if between 9 and 18 characters inclusive, prepend 'SUFFIX_'; if greater than 18 characters, replace it with 'TRUNC_' concatenated with the first 15 characters of the original title.",
    "natural_language": "Construct a row-level trigger to be executed before any insertion or update operation on the SONGS table, naming it SONGS_TITLE_PREFIX_TRIGGER. For every individual row being processed, you must carefully adjust the new TITLE value according to a detailed set of length-based rules: should the title contain fewer than nine characters, you are to add the specific string 'PREFIX_' to its beginning; if the title's length falls within the inclusive range of nine to eighteen characters, you must instead prepend the distinct label 'SUFFIX_'; however, in cases where the title exceeds eighteen characters in length, you are required to completely replace it by concatenating the fixed term 'TRUNC_' with precisely the first fifteen characters extracted from the original title.",
    "id": 181
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_after_payment_lesson_check` that fires for each row inserted into the `CUSTOMER_PAYMENTS` table, first accumulating payment data per customer in a collection during the row-level phase and then processing that aggregated data to update customer statuses in a statement-level phase. The trigger defines a record type `customer_payment_rec` with fields for `customer_id` (matching the `CUSTOMER_ID%TYPE` from `CUSTOMER_PAYMENTS`), `amount_payment` (matching the `AMOUNT_PAYMENT%TYPE` from `CUSTOMER_PAYMENTS`), `total_payment` (a `NUMBER`), and `payment_count` (a `NUMBER`), and an associative array type `customer_payment_tab` indexed by `PLS_INTEGER` to hold these records, which is instantiated as a global package-level variable `g_customer_payments`. In the `AFTER EACH ROW` section, for each new row inserted, the trigger uses the new `CUSTOMER_ID` value as an index key `l_index` to check if an entry for that customer already exists in the `g_customer_payments` collection using the `EXISTS` method; if it does not exist, it initializes a new record at that index, setting the `customer_id` to `:NEW.CUSTOMER_ID`, the `amount_payment` to `:NEW.AMOUNT_PAYMENT`, the `total_payment` to `:NEW.AMOUNT_PAYMENT`, and the `payment_count` to 1; if it does exist, it updates the existing record by setting the `amount_payment` to the new `:NEW.AMOUNT_PAYMENT`, incrementing the `total_payment` by `:NEW.AMOUNT_PAYMENT`, and incrementing the `payment_count` by 1. In the `AFTER STATEMENT` section, after all rows are inserted and processed, the trigger iterates through every distinct `customer_id` stored in the `g_customer_payments` collection using the `FIRST` and `NEXT` collection methods, assigning each key to a variable `l_customer_id`; for each customer, it performs a `SELECT COUNT(*)` query on the `LESSONS` table into a local variable `v_lesson_count`, counting all rows where the `CUSTOMER_ID` column equals the current `l_customer_id`; it then calculates an average payment `v_avg_payment` by dividing the customer's accumulated `total_payment` from the collection by their `payment_count`; based on these values, it assigns a status string to a local variable `v_status` using conditional logic: if `v_lesson_count` equals 0, `v_status` is set to 'New Customer'; otherwise, if the most recent `amount_payment` (from the collection) for that customer is greater than `v_avg_payment`, `v_status` is set to 'Premium'; if the most recent `amount_payment` is less than `v_avg_payment`, `v_status` is set to 'Standard'; if neither greater nor less (implying equality), `v_status` is set to 'Balanced'; finally, for each customer, it executes an `UPDATE` statement on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the derived `v_status` value for the row where the `CUSTOMER_ID` column matches the current `l_customer_id`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_payment_lesson_check\nFOR INSERT ON CUSTOMER_PAYMENTS\nCOMPOUND TRIGGER\n\n  TYPE customer_payment_rec IS RECORD (\n    customer_id CUSTOMER_PAYMENTS.CUSTOMER_ID%TYPE,\n    amount_payment CUSTOMER_PAYMENTS.AMOUNT_PAYMENT%TYPE,\n    total_payment NUMBER := 0,\n    payment_count NUMBER := 0\n  );\n\n  TYPE customer_payment_tab IS TABLE OF customer_payment_rec INDEX BY PLS_INTEGER;\n  g_customer_payments customer_payment_tab;\n\n  AFTER EACH ROW IS\n    l_index PLS_INTEGER;\n  BEGIN\n    l_index := :NEW.CUSTOMER_ID;\n    \n    IF NOT g_customer_payments.EXISTS(l_index) THEN\n      g_customer_payments(l_index).customer_id := :NEW.CUSTOMER_ID;\n      g_customer_payments(l_index).amount_payment := :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).total_payment := :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).payment_count := 1;\n    ELSE\n      g_customer_payments(l_index).amount_payment := :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).total_payment := g_customer_payments(l_index).total_payment + :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).payment_count := g_customer_payments(l_index).payment_count + 1;\n    END IF;\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n    v_lesson_count NUMBER;\n    v_avg_payment NUMBER;\n    v_status VARCHAR2(255);\n    l_customer_id NUMBER;\n  BEGIN\n    l_customer_id := g_customer_payments.FIRST;\n    \n    WHILE l_customer_id IS NOT NULL LOOP\n      SELECT COUNT(*) INTO v_lesson_count \n      FROM LESSONS \n      WHERE CUSTOMER_ID = l_customer_id;\n      \n      v_avg_payment := g_customer_payments(l_customer_id).total_payment / g_customer_payments(l_customer_id).payment_count;\n      \n      IF v_lesson_count = 0 THEN\n        v_status := 'New Customer';\n      ELSIF g_customer_payments(l_customer_id).amount_payment > v_avg_payment THEN\n        v_status := 'Premium';\n      ELSIF g_customer_payments(l_customer_id).amount_payment < v_avg_payment THEN\n        v_status := 'Standard';\n      ELSE\n        v_status := 'Balanced';\n      END IF;\n      \n      UPDATE CUSTOMERS \n      SET CUSTOMER_STATUS_CODE = v_status\n      WHERE CUSTOMER_ID = l_customer_id;\n      \n      l_customer_id := g_customer_payments.NEXT(l_customer_id);\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_after_payment_lesson_check;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-01-01 10:00:00', 'Credit Card', 100.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-01-02 11:00:00', 'Debit Card', 150.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (2, '2023-01-03 12:00:00', 'Bank Transfer', 200.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (3, '2023-01-04 13:00:00', 'Credit Card', 50.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-01-05 14:00:00', 'Debit Card', 120.00)"
    ],
    "summary": "Create a compound trigger named TRG_AFTER_PAYMENT_LESSON_CHECK on the CUSTOMER_PAYMENTS table. In the AFTER EACH ROW section, accumulate payment totals and counts per customer into a collection. In the AFTER STATEMENT section, for each customer in the collection, calculate their lesson count and average payment. Update the CUSTOMERS table's CUSTOMER_STATUS_CODE for each customer based on these values: 'New Customer' if no lessons, 'Premium' if the latest payment is above average, 'Standard' if below, or 'Balanced' if equal.",
    "natural_language": "Build a compound trigger called TRG_AFTER_PAYMENT_LESSON_CHECK on the CUSTOMER_PAYMENTS table. In the AFTER EACH ROW section, gather payment totals and counts per customer into a collection. Then, in the AFTER STATEMENT section, for every customer in that collection, compute their lesson count and average payment. Finally, set the CUSTOMERS table's CUSTOMER_STATUS_CODE for each customer using these rules: assign 'New Customer' if there are no lessons, 'Premium' if the latest payment exceeds the average, 'Standard' if it is below average, or 'Balanced' if it matches.",
    "id": 182
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_before_lesson_staff_check` that executes before a new row is inserted into the `LESSONS` table. For each new row being inserted, the trigger performs a series of checks to determine the appropriate `LESSON_STATUS_CODE` for the new lesson. First, it declares three local variables: `v_staff_left` of type `DATE` to store the date a staff member left, `v_outstanding` of type `NUMBER` to store the outstanding amount for a customer, and `v_payment_count` of type `NUMBER` to store the count of payments made by a customer. The trigger then executes a `SELECT` statement to retrieve the `DATE_LEFT_STAFF` column from the `STAFF` table, converting it to a `DATE` data type using `TO_DATE` with the format mask 'YYYY-MM-DD HH24:MI:SS', and stores this value into the `v_staff_left` variable. This `SELECT` operation is filtered by matching the `STAFF_ID` column in the `STAFF` table with the `STAFF_ID` value of the new row being inserted into the `LESSONS` table, referenced as `:NEW.STAFF_ID`. Next, it executes another `SELECT` statement to retrieve the `AMOUNT_OUTSTANDING` column from the `CUSTOMERS` table and stores this value into the `v_outstanding` variable. This `SELECT` operation is filtered by matching the `CUSTOMER_ID` column in the `CUSTOMERS` table with the `CUSTOMER_ID` value of the new row being inserted into the `LESSONS` table, referenced as `:NEW.CUSTOMER_ID`. Subsequently, it executes a third `SELECT` statement to count the number of rows in the `CUSTOMER_PAYMENTS` table and stores this count into the `v_payment_count` variable. This `SELECT` operation is filtered by matching the `CUSTOMER_ID` column in the `CUSTOMER_PAYMENTS` table with the `CUSTOMER_ID` value of the new row being inserted into the `LESSONS` table, referenced as `:NEW.CUSTOMER_ID`. After retrieving these values, the trigger proceeds with a series of conditional checks. If the `v_staff_left` variable is not `NULL`, meaning the staff member has left, then the `LESSON_STATUS_CODE` column of the new row being inserted (`:NEW.LESSON_STATUS_CODE`) is set to the string literal 'Staff Left'. Otherwise, if the `v_staff_left` variable is `NULL`, it checks if the `v_outstanding` variable is greater than 1000. If this condition is true, then the `LESSON_STATUS_CODE` column of the new row (`:NEW.LESSON_STATUS_CODE`) is set to the string literal 'High Debt'. Otherwise, if both previous conditions are false, it checks if the `v_payment_count` variable is equal to 0. If this condition is true, then the `LESSON_STATUS_CODE` column of the new row (`:NEW.LESSON_STATUS_CODE`) is set to the string literal 'No Payment'. If none of the preceding conditions are met, then the `LESSON_STATUS_CODE` column of the new row (`:NEW.LESSON_STATUS_CODE`) is set to the string literal 'Approved'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_before_lesson_staff_check\nBEFORE INSERT ON LESSONS\nFOR EACH ROW\nDECLARE\n    v_staff_left DATE;\n    v_outstanding NUMBER;\n    v_payment_count NUMBER;\nBEGIN\n    SELECT TO_DATE(DATE_LEFT_STAFF, 'YYYY-MM-DD HH24:MI:SS') INTO v_staff_left FROM STAFF WHERE STAFF_ID = :NEW.STAFF_ID;\n    SELECT AMOUNT_OUTSTANDING INTO v_outstanding FROM CUSTOMERS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    SELECT COUNT(*) INTO v_payment_count FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    IF v_staff_left IS NOT NULL THEN\n        :NEW.LESSON_STATUS_CODE := 'Staff Left';\n    ELSIF v_outstanding > 1000 THEN\n        :NEW.LESSON_STATUS_CODE := 'High Debt';\n    ELSIF v_payment_count = 0 THEN\n        :NEW.LESSON_STATUS_CODE := 'No Payment';\n    ELSE\n        :NEW.LESSON_STATUS_CODE := 'Approved';\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (4, 1, 1, 3, '2023-10-01 10:00:00', '2', 150)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (5, 3, 2, 2, '2023-10-02 11:00:00', '3', 200)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (6, 4, 3, 1, '2023-10-03 12:00:00', '4', 250)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (7, 1, 2, 3, '2023-10-04 13:00:00', '5', 300)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (8, 3, 1, 2, '2023-10-05 14:00:00', '6', 350)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_BEFORE_LESSON_STAFF_CHECK on the LESSONS table. For each new row, determine the LESSON_STATUS_CODE by checking: 1) If the assigned staff member has left (DATE_LEFT_STAFF is not NULL), set status to 'Staff Left'. 2) Else, if the customer's outstanding amount exceeds 1000, set status to 'High Debt'. 3) Else, if the customer has made zero payments, set status to 'No Payment'. 4) Otherwise, set the status to 'Approved'.",
    "natural_language": "Create trigger TRG_BEFORE_LESSON_STAFF_CHECK on LESSONS. Before insert, set LESSON_STATUS_CODE: 'Staff Left' if staff DATE_LEFT_STAFF is not null, else 'High Debt' if customer owes >1000, else 'No Payment' if payments are zero, else 'Approved'.",
    "id": 183
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_after_customer_update_status that activates after an update to the AMOUNT_OUTSTANDING column in the CUSTOMERS table for each row affected. The trigger declares four local variables: v_total_payments of type NUMBER to store the sum of payments made by the customer, v_lesson_price_avg of type NUMBER to store the average price of lessons associated with the customer, v_staff_active of type NUMBER to count active staff members linked to the customer's lessons, and v_action of type VARCHAR2(255) to determine the status of the customer based on certain conditions. The trigger first executes a SELECT statement to calculate the total payments made by the customer by summing the AMOUNT_PAYMENT column from the CUSTOMER_PAYMENTS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID. It then calculates the average lesson price by selecting the AVG(PRICE) from the LESSONS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID. Next, it counts the number of active staff members by selecting COUNT(*) from the STAFF table where DATE_LEFT_STAFF is NULL and the STAFF_ID is present in the LESSONS table for the given CUSTOMER_ID. The trigger then evaluates several conditions: if the new AMOUNT_OUTSTANDING is greater than the total payments, it sets v_action to 'Overdue'; if the average lesson price exceeds 200 and there are active staff members, it sets v_action to 'VIP Service'; if the old AMOUNT_OUTSTANDING is less than the new AMOUNT_OUTSTANDING, it sets v_action to 'Increasing Debt'; otherwise, it sets v_action to 'Stable'. Finally, the trigger deletes rows from the LESSONS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID and the LESSON_STATUS_CODE is 'Cancelled'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_customer_update_status\nAFTER UPDATE OF AMOUNT_OUTSTANDING ON CUSTOMERS\nFOR EACH ROW\nDECLARE\n    v_total_payments NUMBER;\n    v_lesson_price_avg NUMBER;\n    v_staff_active NUMBER;\n    v_action VARCHAR2(255);\nBEGIN\n    SELECT SUM(AMOUNT_PAYMENT) INTO v_total_payments FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    SELECT AVG(PRICE) INTO v_lesson_price_avg FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    SELECT COUNT(*) INTO v_staff_active FROM STAFF WHERE DATE_LEFT_STAFF IS NULL AND STAFF_ID IN (SELECT STAFF_ID FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID);\n    IF :NEW.AMOUNT_OUTSTANDING > v_total_payments THEN\n        v_action := 'Overdue';\n    ELSIF v_lesson_price_avg > 200 AND v_staff_active > 0 THEN\n        v_action := 'VIP Service';\n    ELSIF :OLD.AMOUNT_OUTSTANDING < :NEW.AMOUNT_OUTSTANDING THEN\n        v_action := 'Increasing Debt';\n    ELSE\n        v_action := 'Stable';\n    END IF;\n    DELETE FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID AND LESSON_STATUS_CODE = 'Cancelled';\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 500 WHERE CUSTOMER_ID = 1",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 10000 WHERE CUSTOMER_ID = 3",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 2000, CUSTOMER_STATUS_CODE = 'Good Customer' WHERE CUSTOMER_ID = 4",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = AMOUNT_OUTSTANDING + 100 WHERE CUSTOMER_ID = 6",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 0 WHERE CUSTOMER_ID = 8"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_AFTER_CUSTOMER_UPDATE_STATUS on the CUSTOMERS table, firing when the AMOUNT_OUTSTANDING column is updated. For each affected row, calculate the customer's total payments, average lesson price, and count of active staff. Based on these values and the old/new outstanding amounts, determine a status ('Overdue', 'VIP Service', 'Increasing Debt', or 'Stable'). Finally, delete any lessons for this customer with a status of 'Cancelled'.",
    "natural_language": "Set up a trigger on the CUSTOMERS table that runs after updates, specifically when the amount a customer owes changes. For each customer row that gets updated, figure out some general numbers about their payments, what they typically pay for lessons, and how many staff are currently helping them. Then, look at their old and new outstanding amounts along with those numbers to decide on a general status category, like if they're behind, deserve special treatment, are getting deeper in debt, or are just okay. After that, get rid of any of that customer's lessons that are marked as cancelled.",
    "id": 184
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_ACTOR_NAME_UPPER that fires automatically before any INSERT operation or UPDATE operation is performed on the ACTOR table, executing once for each row being inserted or updated, and within its logic, it assigns a new value to the NAME column of the new row data (referenced as :NEW.NAME) by applying the UPPER function, which converts all alphabetical characters in the string to their uppercase equivalents, thereby ensuring the NAME column value is stored in all capital letters.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ACTOR_NAME_UPPER\nBEFORE INSERT OR UPDATE ON ACTOR\nFOR EACH ROW\nBEGIN\n    :NEW.NAME := UPPER(:NEW.NAME);\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "DIRECTOR",
      "DIRECTED_BY"
    ],
    "call_sqls": [
      "INSERT INTO ACTOR (AID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', 'Leonardo DiCaprio', 'American', 'Los Angeles', 1974)",
      "INSERT INTO ACTOR (AID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', 'Meryl Streep', 'American', 'Summit', 1949)",
      "INSERT INTO ACTOR (AID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (3, 'Male', 'Tom Hanks', 'American', 'Concord', 1956)",
      "UPDATE ACTOR SET NAME = 'Robert Downey Jr.' WHERE AID = 1",
      "UPDATE ACTOR SET NAME = 'Scarlett Johansson' WHERE AID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_ACTOR_NAME_UPPER on the ACTOR table. For each row, convert the new value for the NAME column to uppercase before it is inserted or updated.",
    "natural_language": "Please implement a BEFORE INSERT OR UPDATE row-level trigger designated as TRG_ACTOR_NAME_UPPER for the ACTOR table. This trigger must execute for each row, ensuring that any new value intended for the NAME column is converted to uppercase prior to its insertion or update.",
    "id": 185
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CAST_ROLE_DEFAULT that is executed before an insert operation on the CAST table. This trigger operates at the row level, meaning it is triggered for each row that is being inserted into the table. The trigger's purpose is to ensure that the ROLE column of the new row being inserted is not null. It achieves this by using the NVL function, which checks if the :NEW.ROLE value is null. If :NEW.ROLE is null, the NVL function assigns a default value of 0 to :NEW.ROLE; otherwise, it retains the original value of :NEW.ROLE. The :NEW keyword is a special PL/SQL construct that refers to the new row that is being inserted into the table. This trigger does not perform any other operations such as updates, deletes, or selects, and it does not involve any conditional statements beyond the use of the NVL function.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CAST_ROLE_DEFAULT\nBEFORE INSERT ON CAST\nFOR EACH ROW\nBEGIN\n    :NEW.ROLE := NVL(:NEW.ROLE, 0);\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "DIRECTOR",
      "DIRECTED_BY"
    ],
    "call_sqls": [
      "INSERT INTO CAST (ID, MSID, AID) VALUES (1, 101, 201)",
      "INSERT INTO CAST (ID, MSID, AID, ROLE) VALUES (2, 102, 202, NULL)",
      "INSERT INTO CAST (ID, MSID, AID) VALUES (3, 103, 203)",
      "INSERT INTO CAST (ID, MSID, AID, ROLE) VALUES (4, 104, 204, NULL)",
      "INSERT INTO CAST (ID, MSID, AID) VALUES (5, 105, 205)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_CAST_ROLE_DEFAULT on the CAST table. Use NVL to set :NEW.ROLE to 0 if it is null.",
    "natural_language": "Make a BEFORE INSERT trigger TRG_CAST_ROLE_DEFAULT for CAST. Use NVL to default :NEW.ROLE to 0 when null.",
    "id": 186
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_DIRECTOR_NAME_TRIM that fires automatically before any INSERT operation or UPDATE operation is executed on the DIRECTOR table, and for each individual row being processed by that operation, it performs a single assignment operation where the new value for the NAME column, represented by the bind variable :NEW.NAME, is set to the result of applying the TRIM function to the original incoming :NEW.NAME value, which removes any leading spaces, trailing spaces, or both from the character string.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_DIRECTOR_NAME_TRIM\nBEFORE INSERT OR UPDATE ON DIRECTOR\nFOR EACH ROW\nBEGIN\n    :NEW.NAME := TRIM(:NEW.NAME);\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "DIRECTOR",
      "DIRECTED_BY"
    ],
    "call_sqls": [
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', ' Steven Spielberg ', 'American', 'Cincinnati', 1946)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', ' Sofia Coppola ', 'American', 'New York', 1971)",
      "UPDATE DIRECTOR SET NAME = ' Quentin Tarantino ' WHERE DID = 3",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (4, 'Male', ' Martin Scorsese ', 'American', 'New York', 1942)",
      "UPDATE DIRECTOR SET NAME = ' Christopher Nolan ' WHERE DID = 5"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_DIRECTOR_NAME_TRIM on the DIRECTOR table. Set :NEW.NAME to TRIM(:NEW.NAME).",
    "natural_language": "Hey, can you set up a trigger called TRG_DIRECTOR_NAME_TRIM for the DIRECTOR table? It should fire before any new row is added or an existing one is updated. The job is to just clean up any extra spaces from the start or end of the NAME field and put that trimmed value back in.",
    "id": 187
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_ACTOR_NATIONALITY_LOWER that is executed before an insert or update operation on the ACTOR table. This trigger operates at the row level, meaning it is triggered for each row that is inserted or updated. The trigger's purpose is to ensure that the value of the NATIONALITY column in the ACTOR table is stored in lowercase. It achieves this by using the built-in Oracle SQL function LOWER(), which converts a given string to all lowercase letters. Specifically, when a new row is being inserted or an existing row is being updated, the trigger takes the value of the NATIONALITY column from the :NEW pseudo-record, which represents the new state of the row, and applies the LOWER() function to it. The result of this function call is then assigned back to the :NEW.NATIONALITY field, ensuring that the NATIONALITY value is always stored in lowercase regardless of how it was originally input. This trigger does not involve any conditional logic or additional operations beyond the conversion to lowercase.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ACTOR_NATIONALITY_LOWER\nBEFORE INSERT OR UPDATE ON ACTOR\nFOR EACH ROW\nBEGIN\n    :NEW.NATIONALITY := LOWER(:NEW.NATIONALITY);\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "DIRECTOR",
      "DIRECTED_BY"
    ],
    "call_sqls": [
      "INSERT INTO ACTOR (AID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', 'Tom Hanks', 'AMERICAN', 'Concord', 1956)",
      "INSERT INTO ACTOR (AID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', 'Meryl Streep', 'GERMAN', 'Summit', 1949)",
      "UPDATE ACTOR SET NATIONALITY = 'BRITISH' WHERE AID = 1",
      "INSERT INTO ACTOR (AID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (3, 'Male', 'Leonardo DiCaprio', 'ITALIAN', 'Los Angeles', 1974)",
      "UPDATE ACTOR SET NATIONALITY = 'FRENCH' WHERE AID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_ACTOR_NATIONALITY_LOWER on the ACTOR table. Set :NEW.NATIONALITY to LOWER(:NEW.NATIONALITY).",
    "natural_language": "Make trigger TRG_ACTOR_NATIONALITY_LOWER for ACTOR before insert or update. Force new nationality to lowercase.",
    "id": 188
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_MANAGEMENT_AGE_VALIDATION that fires automatically before any row is inserted into the MANAGEMENT table, and for each individual row being inserted, the trigger declares a local variable v_head_age of the same data type as the AGE column in the HEAD table, then executes a SELECT statement to query the HEAD table, retrieving the AGE value from the row where the HEAD_ID column matches the new HEAD_ID value being inserted into the MANAGEMENT table (referenced as :NEW.HEAD_ID), and stores that retrieved age into the v_head_age variable, then evaluates a conditional IF statement to check if the value in v_head_age is less than 30, and if this condition is true, the trigger raises a custom application error with error number -20001 and the message 'Head must be at least 30 years old.', which prevents the insertion of the new row into the MANAGEMENT table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MANAGEMENT_AGE_VALIDATION\nBEFORE INSERT ON MANAGEMENT\nFOR EACH ROW\nDECLARE\n    v_head_age HEAD.AGE%TYPE;\nBEGIN\n    SELECT AGE INTO v_head_age FROM HEAD WHERE HEAD_ID = :NEW.HEAD_ID;\n    IF v_head_age < 30 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Head must be at least 30 years old.');\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (1, 1, 'No')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (2, 2, 'Yes')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID) VALUES (3, 3)",
      "INSERT INTO MANAGEMENT VALUES (1, 4, 'No')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (2, 5, 'Yes')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_MANAGEMENT_AGE_VALIDATION on the MANAGEMENT table. Select the AGE from the HEAD table where HEAD_ID = :NEW.HEAD_ID. If the retrieved age is less than 30, raise application error -20001 with message 'Head must be at least 30 years old.'.",
    "natural_language": "Create trigger TRG_MANAGEMENT_AGE_VALIDATION on MANAGEMENT before insert. Check if HEAD.AGE for the new HEAD_ID is under 30. If so, raise error 'Head must be at least 30 years old.'.",
    "id": 189
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_MANAGEMENT_DEPT_EXISTS that fires automatically before any row insertion operation is performed on the MANAGEMENT table, for each individual row being inserted. The trigger declares a local variable v_dept_count of type NUMBER. For each new row, the trigger executes a SELECT statement that queries the DEPARTMENT table, counting the number of rows where the DEPARTMENT_ID column value equals the value of the DEPARTMENT_ID column from the new row (referenced as :NEW.DEPARTMENT_ID), and stores this count result into the variable v_dept_count. Immediately after this query, the trigger evaluates a conditional IF statement that checks if the value of v_dept_count is exactly equal to 0. If this condition is true, indicating that no corresponding department record exists in the DEPARTMENT table for the provided DEPARTMENT_ID, the trigger raises a custom application error with error number -20004 and the message 'Department does not exist.', which halts the insertion into the MANAGEMENT table. If the condition is false, meaning v_dept_count is greater than 0 and a matching department exists, the trigger completes without error, allowing the INSERT operation on the MANAGEMENT table to proceed.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MANAGEMENT_DEPT_EXISTS\nBEFORE INSERT ON MANAGEMENT\nFOR EACH ROW\nDECLARE\n    v_dept_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_dept_count FROM DEPARTMENT WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\n    IF v_dept_count = 0 THEN\n        RAISE_APPLICATION_ERROR(-20004, 'Department does not exist.');\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (1, 5, 'No')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID) VALUES (2, 4)",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (3, 6, 'Yes')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID) VALUES (99, 1)",
      "INSERT INTO MANAGEMENT VALUES (15, 3, 'No')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_MANAGEMENT_DEPT_EXISTS on the MANAGEMENT table. Count rows in the DEPARTMENT table where DEPARTMENT_ID = :NEW.DEPARTMENT_ID. If the count is 0, raise application error -20004 with message 'Department does not exist.'.",
    "natural_language": "How can I create a BEFORE INSERT row-level trigger called TRG_MANAGEMENT_DEPT_EXISTS for the MANAGEMENT table that checks if the department exists? The trigger should count the rows in the DEPARTMENT table where the DEPARTMENT_ID matches the new DEPARTMENT_ID, and if the count is zero, raise application error -20004 with the message 'Department does not exist.'",
    "id": 190
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE UPDATE` row-level trigger named `TRG_DEPARTMENT_RANKING_UPDATE` that is activated whenever an `UPDATE` operation is performed on the `DEPARTMENT` table, specifically when the `RANKING` column is being modified. For each individual row that is being updated, the trigger executes a block of code. Inside this block, a conditional statement (`IF`) checks the value of the `RANKING` column as it is being updated (referred to as `:NEW.RANKING`). The condition evaluates whether the new `RANKING` value is less than `1` OR if the new `RANKING` value is greater than `10`. If this condition is true, meaning the proposed `RANKING` value falls outside the acceptable range of `1` to `10` (inclusive), then the trigger immediately raises an application error. This error is identified by the error number `-20005` and includes the descriptive error message 'Ranking must be between 1 and 10.'. This action prevents the `UPDATE` operation from completing for that specific row, effectively enforcing a business rule that the `RANKING` column in the `DEPARTMENT` table must always hold a value between `1` and `10`.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_DEPARTMENT_RANKING_UPDATE\nBEFORE UPDATE OF RANKING ON DEPARTMENT\nFOR EACH ROW\nBEGIN\n    IF :NEW.RANKING < 1 OR :NEW.RANKING > 10 THEN\n        RAISE_APPLICATION_ERROR(-20005, 'Ranking must be between 1 and 10.');\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "UPDATE DEPARTMENT SET RANKING = 5 WHERE DEPARTMENT_ID = 1",
      "UPDATE DEPARTMENT SET RANKING = 10 WHERE NAME = 'Defense'",
      "UPDATE DEPARTMENT SET RANKING = 1, BUDGET_IN_BILLIONS = 500 WHERE DEPARTMENT_ID = 2",
      "UPDATE DEPARTMENT SET RANKING = 8 WHERE RANKING = 3",
      "UPDATE DEPARTMENT SET RANKING = 0 WHERE DEPARTMENT_ID = 3"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named TRG_DEPARTMENT_RANKING_UPDATE on the DEPARTMENT table. For each updated row, if the new RANKING value is less than 1 or greater than 10, raise application error -20005 with message 'Ranking must be between 1 and 10.'.",
    "natural_language": "Make a BEFORE UPDATE row trigger TRG_DEPARTMENT_RANKING_UPDATE for DEPARTMENT. If a new RANKING is not 1-10, raise error -20005: 'Ranking must be between 1 and 10.'",
    "id": 191
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_update_claim_amount` that is defined on the `CLAIMS` table and fires for `INSERT` operations. This trigger is designed to capture data from each newly inserted row into the `CLAIMS` table and then, after all rows in the statement have been processed, perform additional operations based on the collected data.\n\nThe trigger begins by declaring a record type named `claim_rec_type` which mirrors the structure of a claim record, containing fields for `claim_id` (of type `CLAIMS.CLAIM_ID%TYPE`), `policy_id` (of type `CLAIMS.POLICY_ID%TYPE`), `date_claim_made` (of type `CLAIMS.DATE_CLAIM_MADE%TYPE`), and `amount_claimed` (of type `CLAIMS.AMOUNT_CLAIMED%TYPE`). It then declares a nested table type named `claim_rec_tab_type` which is a table of `claim_rec_type` records. A variable `claim_rec_tab` of type `claim_rec_tab_type` is initialized as an empty nested table.\n\nThe `AFTER EACH ROW` section of the compound trigger executes for every row that is inserted into the `CLAIMS` table. Within this section, the `claim_rec_tab` nested table is extended by one element. The values from the newly inserted row, specifically `:NEW.CLAIM_ID`, `:NEW.POLICY_ID`, `:NEW.DATE_CLAIM_MADE`, and `:NEW.AMOUNT_CLAIMED`, are then assigned to the corresponding fields of the last element added to `claim_rec_tab`. This effectively collects the details of each inserted claim into the `claim_rec_tab` collection.\n\nThe `AFTER STATEMENT` section of the compound trigger executes once after all rows affected by the `INSERT` statement on the `CLAIMS` table have been processed. A local variable `v_avg_amount` of type `NUMBER` is declared within this section. The trigger then iterates through each record stored in the `claim_rec_tab` collection using a `FOR` loop, from the first element to the last (`1 .. claim_rec_tab.COUNT`). Inside the loop, for each collected claim record:\n1. A `SELECT` statement is executed to calculate the average `AMOUNT_CLAIMED` from the `CLAIMS` table. This average is determined for all claims that share the same `POLICY_ID` as the current claim record being processed from `claim_rec_tab(i).policy_id`. The calculated average amount is stored into the `v_avg_amount` variable.\n2. An `INSERT` statement is executed to add a new record into the `SETTLEMENTS` table. The values for the new record are derived as follows:\n    - `SETTLEMENT_ID`: This is generated by selecting the maximum `SETTLEMENT_ID` from the `SETTLEMENTS` table, using `NVL` to default to `0` if no records exist, and then adding `1` to that value.\n    - `CLAIM_ID`: This is set to the `claim_id` from the current collected claim record, `claim_rec_tab(i).claim_id`.\n    - `DATE_CLAIM_MADE`: This is set to the `date_claim_made` from the current collected claim record, `claim_rec_tab(i).date_claim_made`.\n    - `DATE_CLAIM_SETTLED`: This is set to `NULL`.\n    - `AMOUNT_CLAIMED`: This is set to the `amount_claimed` from the current collected claim record, `claim_rec_tab(i).amount_claimed`.\n    - `AMOUNT_SETTLED`: This is set to the `v_avg_amount` that was calculated in the previous step.\n    - `CUSTOMER_POLICY_ID`: This is set to the `policy_id` from the current collected claim record, `claim_rec_tab(i).policy_id`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_claim_amount\nFOR INSERT ON CLAIMS\nCOMPOUND TRIGGER\n\n  TYPE claim_rec_type IS RECORD (\n    claim_id CLAIMS.CLAIM_ID%TYPE,\n    policy_id CLAIMS.POLICY_ID%TYPE,\n    date_claim_made CLAIMS.DATE_CLAIM_MADE%TYPE,\n    amount_claimed CLAIMS.AMOUNT_CLAIMED%TYPE\n  );\n\n  TYPE claim_rec_tab_type IS TABLE OF claim_rec_type;\n  claim_rec_tab claim_rec_tab_type := claim_rec_tab_type();\n\n  AFTER EACH ROW IS\n  BEGIN\n    claim_rec_tab.EXTEND;\n    claim_rec_tab(claim_rec_tab.LAST) := claim_rec_type(\n      :NEW.CLAIM_ID,\n      :NEW.POLICY_ID,\n      :NEW.DATE_CLAIM_MADE,\n      :NEW.AMOUNT_CLAIMED\n    );\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n    v_avg_amount NUMBER;\n  BEGIN\n    FOR i IN 1 .. claim_rec_tab.COUNT LOOP\n      SELECT AVG(AMOUNT_CLAIMED) INTO v_avg_amount FROM CLAIMS WHERE POLICY_ID = claim_rec_tab(i).policy_id;\n\n      INSERT INTO SETTLEMENTS (SETTLEMENT_ID, CLAIM_ID, DATE_CLAIM_MADE, DATE_CLAIM_SETTLED, AMOUNT_CLAIMED, AMOUNT_SETTLED, CUSTOMER_POLICY_ID)\n      VALUES ((SELECT NVL(MAX(SETTLEMENT_ID), 0) + 1 FROM SETTLEMENTS), claim_rec_tab(i).claim_id, claim_rec_tab(i).date_claim_made, NULL, claim_rec_tab(i).amount_claimed, v_avg_amount, claim_rec_tab(i).policy_id);\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_update_claim_amount;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (501, 744, '2023-10-01', 50000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (502, 552, '2023-10-02', 60000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (503, 473, '2023-10-03', 70000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (504, 744, '2023-10-04', 80000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (505, 552, '2023-10-05', 90000)"
    ],
    "summary": "Create a compound trigger named trg_update_claim_amount on the CLAIMS table for INSERT operations. In the AFTER EACH ROW section, collect each inserted row's CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, and AMOUNT_CLAIMED into a nested table. In the AFTER STATEMENT section, for each collected record: calculate the average AMOUNT_CLAIMED for claims with the same POLICY_ID, then insert a new record into SETTLEMENTS table with SETTLEMENT_ID as MAX+1, CLAIM_ID, DATE_CLAIM_MADE, NULL for DATE_CLAIM_SETTLED, AMOUNT_CLAIMED, the calculated average as AMOUNT_SETTLED, and POLICY_ID as CUSTOMER_POLICY_ID.",
    "natural_language": "Set up a compound trigger on the claims table for new entries. After each row goes in, gather some details like the claim ID, policy number, when it was made, and the claimed amount into a collection. Later, after everything's done, for each of those saved records: figure out the typical amount claimed for other claims under the same policy, then add a new settlement record. Use the next available ID, the original claim details, leave the settlement date blank for now, put in the claimed amount, use that typical figure as the settled amount, and include the policy ID.",
    "id": 192
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named `trg_policy_expiry_check` that is activated `AFTER` an `UPDATE` operation occurs on the `CUSTOMER_POLICIES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is updated in the `CUSTOMER_POLICIES` table. Inside the `DECLARE` section, a local variable `v_total_claims` of type `NUMBER` is declared to store a count of claims. The trigger's `BEGIN` block first executes a `SELECT` statement to count the number of records in the `CLAIMS` table. This count is stored into the `v_total_claims` variable. The `SELECT` statement includes a `WHERE` clause that filters records where the `POLICY_ID` column matches the `POLICY_ID` of the newly updated row in `CUSTOMER_POLICIES` (referenced as `:NEW.POLICY_ID`) and where the `DATE_CLAIM_SETTLED` column is `NULL`. Following this, a `DELETE` statement is executed on the `CLAIMS` table. This `DELETE` statement removes records where the `POLICY_ID` column matches the `POLICY_ID` of the newly updated row in `CUSTOMER_POLICIES` (referenced as `:NEW.POLICY_ID`), where the `DATE_CLAIM_SETTLED` column is `NULL`, and where the `END_DATE` column of the newly updated row in `CUSTOMER_POLICIES` (referenced as `:NEW.END_DATE`) is less than the current system date, which is converted to a `VARCHAR2` string in 'YYYY-MM-DD' format using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`. Finally, an `INSERT` statement is executed to add a new record into the `PAYMENTS` table. For the `PAYMENT_ID` column, the value is determined by a subquery that selects the maximum `PAYMENT_ID` from the `PAYMENTS` table, adds 1 to it, and uses `NVL` to default to 0 if no `PAYMENT_ID` exists, effectively generating a new sequential ID. The `SETTLEMENT_ID` column is set to `NULL`. The `PAYMENT_METHOD_CODE` column is set to the string literal 'Expired'. The `DATE_PAYMENT_MADE` column is set to the current system date, converted to a `VARCHAR2` string in 'YYYY-MM-DD' format using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`. The `AMOUNT_PAYMENT` column is set to the value of the `v_total_claims` variable multiplied by 100.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_policy_expiry_check\nAFTER UPDATE ON CUSTOMER_POLICIES\nFOR EACH ROW\nDECLARE\n    v_total_claims NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_claims FROM CLAIMS WHERE POLICY_ID = :NEW.POLICY_ID AND DATE_CLAIM_SETTLED IS NULL;\n    DELETE FROM CLAIMS WHERE POLICY_ID = :NEW.POLICY_ID AND DATE_CLAIM_SETTLED IS NULL AND :NEW.END_DATE < TO_CHAR(SYSDATE, 'YYYY-MM-DD');\n    INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT)\n    VALUES ((SELECT NVL(MAX(PAYMENT_ID), 0) + 1 FROM PAYMENTS), NULL, 'Expired', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), v_total_claims * 100);\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "UPDATE CUSTOMER_POLICIES SET END_DATE = '2023-01-01' WHERE POLICY_ID = 119",
      "UPDATE CUSTOMER_POLICIES SET END_DATE = '2022-05-15' WHERE POLICY_ID = 141",
      "UPDATE CUSTOMER_POLICIES SET END_DATE = '2021-11-30' WHERE POLICY_ID = 143",
      "UPDATE CUSTOMER_POLICIES SET END_DATE = '2024-03-20' WHERE POLICY_ID = (SELECT POLICY_ID FROM CUSTOMER_POLICIES WHERE ROWNUM = 1)",
      "UPDATE CUSTOMER_POLICIES SET END_DATE = '2023-07-01' WHERE POLICY_ID = (SELECT POLICY_ID FROM CUSTOMER_POLICIES WHERE ROWNUM = 2)"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_policy_expiry_check on the CUSTOMER_POLICIES table. For each updated row: count claims where POLICY_ID matches :NEW.POLICY_ID and DATE_CLAIM_SETTLED is NULL into v_total_claims. If :NEW.END_DATE is less than current date, delete claims with matching POLICY_ID and NULL DATE_CLAIM_SETTLED. Then insert into PAYMENTS table: PAYMENT_ID as MAX+1, SETTLEMENT_ID as NULL, PAYMENT_METHOD_CODE as 'Expired', DATE_PAYMENT_MADE as current date, and AMOUNT_PAYMENT as v_total_claims * 100.",
    "natural_language": "Construct an AFTER UPDATE row-level trigger, which should be named trg_policy_expiry_check, specifically for the CUSTOMER_POLICIES table. For every individual row that gets updated, you must first carefully calculate the total number of unsettled claims by counting all entries where the POLICY_ID corresponds to the newly updated :NEW.POLICY_ID and where the DATE_CLAIM_SETTLED field remains unpopulated, storing this result into a variable called v_total_claims. Subsequently, if the freshly updated :NEW.END_DATE is found to be earlier than the present date, you are required to meticulously delete all those unsettled claims that share the matching POLICY_ID and have a NULL DATE_CLAIM_SETTLED. Following this, proceed to insert a detailed new record into the PAYMENTS table, where the PAYMENT_ID is set to the maximum existing value incremented by one, the SETTLEMENT_ID is explicitly assigned as NULL, the PAYMENT_METHOD_CODE is designated as 'Expired', the DATE_PAYMENT_MADE is recorded as the current date, and the AMOUNT_PAYMENT is computed as the previously stored v_total_claims multiplied by one hundred.",
    "id": 193
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_payment_method_update` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `PAYMENTS` table. This trigger is defined to fire `FOR EACH ROW` that is being inserted into the `PAYMENTS` table, meaning its logic will be executed individually for every new row. The trigger operates on the `NEW` pseudo-record, which represents the data of the row currently being inserted. Within the trigger's `BEGIN...END` block, a conditional statement (`IF`) evaluates the value of the `AMOUNT_PAYMENT` column in the `NEW` pseudo-record. Specifically, it checks if the value of `:NEW.AMOUNT_PAYMENT` is `GREATER THAN` the numeric literal `400000`. If this condition evaluates to `TRUE`, then the trigger proceeds to modify the `PAYMENT_METHOD_CODE` column of the `NEW` pseudo-record. The value of `:NEW.PAYMENT_METHOD_CODE` is assigned the string literal `'Updated'`. If the initial `IF` condition evaluates to `FALSE` (i.e., `:NEW.AMOUNT_PAYMENT` is not greater than `400000`), then no action is taken on the `PAYMENT_METHOD_CODE` column, and its value remains unchanged from what was provided in the original `INSERT` statement. The trigger's execution concludes after this conditional logic, and the modified `NEW` row (if any modifications occurred) is then used for the actual `INSERT` operation into the `PAYMENTS` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_payment_method_update\nBEFORE INSERT ON PAYMENTS\nFOR EACH ROW\nBEGIN\n    -- Simple logic to update payment method without querying the mutating table\n    -- Using a threshold value instead of calculating median from the mutating table\n    IF :NEW.AMOUNT_PAYMENT > 400000 THEN\n        :NEW.PAYMENT_METHOD_CODE := 'Updated';\n    END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (1001, 516, 'MasterCard', '2024-01-15', 500000)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (1002, 476, 'Visa', '2024-01-16', 300000)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (1003, 516, 'Cash', '2024-01-17', 450000)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (1004, 476, 'Amex', '2024-01-18', 410000)",
      "INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT) VALUES (1005, 516, 'Check', '2024-01-19', 350000)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_payment_method_update on the PAYMENTS table. For each inserted row, if :NEW.AMOUNT_PAYMENT is greater than 400000, set :NEW.PAYMENT_METHOD_CODE to 'Updated'.",
    "natural_language": "How can I create a BEFORE INSERT row-level trigger named trg_payment_method_update on the PAYMENTS table that sets the PAYMENT_METHOD_CODE to 'Updated' for each new row where the AMOUNT_PAYMENT is greater than 400000?",
    "id": 194
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER UPDATE` row-level trigger named `trg_customer_details_update` on the `CUSTOMERS` table. This trigger executes immediately after an `UPDATE` operation is performed on any row in the `CUSTOMERS` table. For each row that is updated, the trigger declares a local PL/SQL variable named `v_total_settled` of `NUMBER` data type. The trigger then performs a `SELECT` statement to calculate the sum of `AMOUNT_SETTLED` from the `SETTLEMENTS` table. The rows considered for this sum are filtered by a subquery: `CUSTOMER_POLICY_ID` in the `SETTLEMENTS` table must exist in the `POLICY_ID` column of the `CUSTOMER_POLICIES` table, where the `CUSTOMER_ID` in `CUSTOMER_POLICIES` matches the `CUSTOMER_ID` of the `NEW` (updated) row in the `CUSTOMERS` table (referenced as `:NEW.CUSTOMER_ID`). The result of this sum is stored into the `v_total_settled` variable. Following this, the trigger executes an `INSERT` statement to add a new row into the `CLAIMS` table. The `CLAIM_ID` column for the new row is determined by a subquery that selects the maximum `CLAIM_ID` from the `CLAIMS` table, uses the `NVL` function to treat a `NULL` result (if no claims exist) as `0`, and then adds `1` to this value, effectively generating a new sequential `CLAIM_ID`. The `POLICY_ID` column is set to `NULL`. The `DATE_CLAIM_MADE` column is populated by converting the current system date (`SYSDATE`) to a character string in 'YYYY-MM-DD' format using the `TO_CHAR` function. The `DATE_CLAIM_SETTLED` column is set to `NULL`. The `AMOUNT_CLAIMED` column is populated with the value stored in the `v_total_settled` variable. Finally, the `AMOUNT_SETTLED` column is set to `0`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customer_details_update\nAFTER UPDATE ON CUSTOMERS\nFOR EACH ROW\nDECLARE\n    v_total_settled NUMBER;\nBEGIN\n    SELECT SUM(AMOUNT_SETTLED) INTO v_total_settled FROM SETTLEMENTS WHERE CUSTOMER_POLICY_ID IN (SELECT POLICY_ID FROM CUSTOMER_POLICIES WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID);\n    INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, DATE_CLAIM_SETTLED, AMOUNT_CLAIMED, AMOUNT_SETTLED)\n    VALUES ((SELECT NVL(MAX(CLAIM_ID), 0) + 1 FROM CLAIMS), NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), NULL, v_total_settled, 0);\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "UPDATE CUSTOMERS SET CUSTOMER_DETAILS = 'John Doe' WHERE CUSTOMER_ID = 1",
      "UPDATE CUSTOMERS SET CUSTOMER_DETAILS = 'Jane Smith' WHERE CUSTOMER_ID = 2",
      "UPDATE CUSTOMERS SET CUSTOMER_DETAILS = 'Updated Name' WHERE CUSTOMER_ID = 3",
      "UPDATE CUSTOMERS SET CUSTOMER_DETAILS = 'Robert Johnson' WHERE CUSTOMER_ID = 10",
      "UPDATE CUSTOMERS SET CUSTOMER_DETAILS = 'Alice Brown' WHERE CUSTOMER_ID = 15"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_customer_details_update on the CUSTOMERS table. For each updated row: calculate the sum of AMOUNT_SETTLED from SETTLEMENTS where CUSTOMER_POLICY_ID exists in CUSTOMER_POLICIES with CUSTOMER_ID matching :NEW.CUSTOMER_ID, store in v_total_settled. Then insert into CLAIMS table: CLAIM_ID as MAX+1, POLICY_ID as NULL, DATE_CLAIM_MADE as current date, DATE_CLAIM_SETTLED as NULL, AMOUNT_CLAIMED as v_total_settled, and AMOUNT_SETTLED as 0.",
    "natural_language": "Please construct a row-level trigger designated as trg_customer_details_update, to be executed after update operations on the CUSTOMERS table. For each row that is updated, the procedure should be as follows: first, compute the aggregate sum of the AMOUNT_SETTLED column from the SETTLEMENTS table. This calculation should be restricted to records where the CUSTOMER_POLICY_ID is present within the CUSTOMER_POLICIES table and is associated with a CUSTOMER_ID that matches the new CUSTOMER_ID value from the updated row. Store this computed value in a variable named v_total_settled. Subsequently, insert a new record into the CLAIMS table. The values for this insertion are to be assigned as follows: CLAIM_ID should be set to the maximum existing CLAIM_ID incremented by one, POLICY_ID should be set to NULL, DATE_CLAIM_MADE should be set to the current system date, DATE_CLAIM_SETTLED should be set to NULL, AMOUNT_CLAIMED should be assigned the value stored in v_total_settled, and AMOUNT_SETTLED should be initialized to zero.",
    "id": 195
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_settlement_amount_check that fires before any row is updated on the SETTLEMENTS table, and for each row being updated, it declares a local variable v_max_claimed of type NUMBER, then executes a SELECT statement to query the CLAIMS and CUSTOMER_POLICIES tables, joining them on the condition that c.POLICY_ID equals cp.POLICY_ID, and filtering the result with a WHERE clause that requires cp.POLICY_ID to match the POLICY_ID obtained from a subquery that selects the POLICY_ID from the CLAIMS table where the CLAIM_ID equals the new CLAIM_ID value from the :NEW pseudorecord of the trigger, storing the maximum value of the c.AMOUNT_CLAIMED column from the result set into the v_max_claimed variable, and then uses an IF conditional statement to check if the new AMOUNT_SETTLED value from the :NEW pseudorecord is less than the retrieved v_max_claimed value, and if this condition is true, it assigns the value of v_max_claimed to the :NEW.AMOUNT_SETTLED column for the row being updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_settlement_amount_check\nBEFORE UPDATE ON SETTLEMENTS\nFOR EACH ROW\nDECLARE\n    v_max_claimed NUMBER;\nBEGIN\n    SELECT MAX(c.AMOUNT_CLAIMED)\n      INTO v_max_claimed\n      FROM CLAIMS c\n      JOIN CUSTOMER_POLICIES cp ON c.POLICY_ID = cp.POLICY_ID\n     WHERE cp.POLICY_ID = (SELECT POLICY_ID FROM CLAIMS WHERE CLAIM_ID = :NEW.CLAIM_ID);\n    \n    IF :NEW.AMOUNT_SETTLED < v_max_claimed THEN\n        :NEW.AMOUNT_SETTLED := v_max_claimed;\n    END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 5000 WHERE SETTLEMENT_ID = 357",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 10000, DATE_CLAIM_SETTLED = '2023-12-01' WHERE CLAIM_ID = 486",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 7500 WHERE SETTLEMENT_ID = 412",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 2000, AMOUNT_CLAIMED = 25000 WHERE SETTLEMENT_ID = 476",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 15000 WHERE CLAIM_ID = 621"
    ],
    "summary": "Create a BEFORE UPDATE row trigger named trg_settlement_amount_check on the SETTLEMENTS table. For each row, if the new AMOUNT_SETTLED is less than the maximum AMOUNT_CLAIMED for the claim's policy (from CLAIMS and CUSTOMER_POLICIES), set the new AMOUNT_SETTLED to that maximum value.",
    "natural_language": "Before updating a row in the SETTLEMENTS table, check the amount. For each row, if the new AMOUNT_SETTLED is less than the maximum AMOUNT_CLAIMED for the claim's policy, set the new AMOUNT_SETTLED to that maximum value. Name this row trigger trg_settlement_amount_check.",
    "id": 196
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_validate_teacher_classroom` on the `TEACHERS` table. This trigger executes before a new row is inserted into the `TEACHERS` table. For each row being inserted, it declares a local numeric variable `v_classroom_count` to store the count of matching classrooms. The trigger then performs a `SELECT COUNT(*)` operation on the `LIST` table to count the number of rows where the `CLASSROOM` column's value is equal to the `CLASSROOM` value of the new row being inserted into the `TEACHERS` table (referenced as `:NEW.CLASSROOM`). The result of this count is stored in the `v_classroom_count` variable. Following this, a conditional `IF` statement checks if the value of `v_classroom_count` is equal to `0`. If `v_classroom_count` is `0`, indicating that the `CLASSROOM` value specified for the new teacher does not exist in the `LIST` table, then the `CLASSROOM` column of the new row being inserted into the `TEACHERS` table (referenced as `:NEW.CLASSROOM`) is set to `NULL`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_teacher_classroom\nBEFORE INSERT ON TEACHERS\nFOR EACH ROW\nDECLARE\n    v_classroom_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_classroom_count FROM LIST WHERE CLASSROOM = :NEW.CLASSROOM;\n    IF v_classroom_count = 0 THEN\n        :NEW.CLASSROOM := NULL;\n    END IF;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Smith', 'John', 101)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Doe', 'Jane', 999)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Brown', 'Robert', 105)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Wilson', 'Emily', NULL)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Taylor', 'Michael', 110)"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_validate_teacher_classroom on the TEACHERS table. For each row, if the specified CLASSROOM does not exist in the LIST table, set the new CLASSROOM value to NULL.",
    "natural_language": "Please construct a BEFORE INSERT row trigger designated as trg_validate_teacher_classroom for the TEACHERS table. For each inserted row, if the provided CLASSROOM value is not present within the LIST table, the new CLASSROOM value should be assigned as NULL.",
    "id": 197
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_classroom_on_insert that is executed automatically after a new row is inserted into the LIST table. This trigger operates for each row that is inserted. Upon activation, it performs an insert operation into the TEACHERS table, adding a new record with values derived from the newly inserted row in the LIST table. Specifically, it inserts the value from the LASTNAME column of the new row into the LASTNAME column of the TEACHERS table, the value from the FIRSTNAME column of the new row into the FIRSTNAME column of the TEACHERS table, and the value from the CLASSROOM column of the new row into the CLASSROOM column of the TEACHERS table. The trigger does not perform any conditional checks or additional operations beyond this straightforward insertion.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_classroom_on_insert\nAFTER INSERT ON LIST\nFOR EACH ROW\nBEGIN\n    INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM)\n    VALUES (:NEW.LASTNAME, :NEW.FIRSTNAME, :NEW.CLASSROOM);\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "INSERT INTO LIST (LASTNAME, FIRSTNAME, GRADE, CLASSROOM) VALUES ('Smith', 'John', 5, 101)",
      "INSERT INTO LIST (LASTNAME, FIRSTNAME, GRADE, CLASSROOM) VALUES ('Doe', 'Jane', 6, 102)",
      "INSERT INTO LIST (LASTNAME, FIRSTNAME, GRADE, CLASSROOM) VALUES ('Brown', 'Charlie', 4, 103)",
      "INSERT INTO LIST (LASTNAME, FIRSTNAME, GRADE, CLASSROOM) VALUES ('Johnson', 'Emily', 3, 104)",
      "INSERT INTO LIST (LASTNAME, FIRSTNAME, GRADE, CLASSROOM) VALUES ('Williams', 'Michael', 2, 105)"
    ],
    "summary": "Create an AFTER INSERT row trigger named trg_sync_classroom_on_insert on the LIST table. For each row, insert a new record into the TEACHERS table using the new row's LASTNAME, FIRSTNAME, and CLASSROOM values.",
    "natural_language": "Please construct an AFTER INSERT row trigger designated as trg_sync_classroom_on_insert on the LIST table. For each inserted row, it is required to insert a corresponding record into the TEACHERS table, utilizing the LASTNAME, FIRSTNAME, and CLASSROOM values from the new row.",
    "id": 198
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_prevent_duplicate_teacher that is executed before an insert operation on the TEACHERS table. This trigger operates for each row that is being inserted. It declares a local variable v_exists of type NUMBER to store the count of existing records. The trigger performs a SELECT statement to count the number of rows in the TEACHERS table where the LASTNAME column matches the LASTNAME value of the new row being inserted, and the FIRSTNAME column matches the FIRSTNAME value of the new row. The result of this count is stored in the v_exists variable. The trigger then evaluates a conditional statement: if the value of v_exists is greater than 0, indicating that there is at least one existing record with the same LASTNAME and FIRSTNAME as the new row, it raises an application error with the error code -20001 and the message 'Teacher already exists'. This prevents the insertion of a new row into the TEACHERS table if a teacher with the same first and last name already exists in the table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_prevent_duplicate_teacher\nBEFORE INSERT ON TEACHERS\nFOR EACH ROW\nDECLARE\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM TEACHERS WHERE LASTNAME = :NEW.LASTNAME AND FIRSTNAME = :NEW.FIRSTNAME;\n    IF v_exists > 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Teacher already exists');\n    END IF;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Smith', 'John', 101)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Doe', 'Jane', 102)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Williams', 'Emily', 103)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Brown', 'Michael', 104)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Smith', 'John', 105)"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_prevent_duplicate_teacher on the TEACHERS table. For each row, if a teacher with the same FIRSTNAME and LASTNAME already exists, raise an application error (-20001) with the message 'Teacher already exists'.",
    "natural_language": "How can I create a BEFORE INSERT row trigger called trg_prevent_duplicate_teacher for the TEACHERS table that raises an application error (-20001) with the message 'Teacher already exists' if a teacher with the same FIRSTNAME and LASTNAME is already present?",
    "id": 199
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_ARTIST_AGE_CHECK that fires before each row is inserted into the ARTIST table, declaring two local NUMBER variables v_count and v_next_id, then executing a SELECT statement to count rows in the VOLUME table where the VOLUME.ARTIST_ID column matches the new ARTIST_ID value being inserted into the ARTIST table, storing the result in v_count, and if this count is greater than zero, performing a second SELECT statement to retrieve the maximum value from the ID column of the MUSIC_FESTIVAL table, applying the NVL function to treat a NULL maximum as zero, adding one to this value, and storing the result in v_next_id, followed by an INSERT statement into the MUSIC_FESTIVAL table that populates the columns ID with v_next_id, MUSIC_FESTIVAL with the literal string 'Auto Festival', DATE_OF_CEREMONY with the current date converted to a string in the 'DD MON YYYY' format using the TO_CHAR function with the CURRENT_DATE pseudo-column, CATEGORY with the literal string 'Auto Category', VOLUME with the v_count value, and RESULT with the literal string 'Auto Result'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ARTIST_AGE_CHECK\nBEFORE INSERT ON ARTIST\nFOR EACH ROW\nDECLARE\n   v_count NUMBER;\n   v_next_id NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_count FROM VOLUME WHERE ARTIST_ID = :NEW.ARTIST_ID;\n   IF v_count > 0 THEN\n      SELECT NVL(MAX(ID), 0) + 1 INTO v_next_id FROM MUSIC_FESTIVAL;\n      INSERT INTO MUSIC_FESTIVAL (ID, MUSIC_FESTIVAL, DATE_OF_CEREMONY, CATEGORY, VOLUME, RESULT) \n      VALUES (v_next_id, 'Auto Festival', TO_CHAR(CURRENT_DATE, 'DD MON YYYY'), 'Auto Category', v_count, 'Auto Result');\n   END IF;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (1, 'Test Artist 1', 30, 'Test Title', 'January 2023')",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (2, 'Test Artist 2', 25, 'Another Title', 'March 2023')",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (4, 'Test Artist 3', 40, 'Third Title', 'May 2023')",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (5, 'New Artist', 22, 'Debut', 'June 2024')",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (10, 'Another New Artist', 28, 'Hit Single', 'July 2024')"
    ],
    "summary": "Create a BEFORE INSERT row trigger named TRG_ARTIST_AGE_CHECK on the ARTIST table. For each row, if the new ARTIST_ID exists in the VOLUME table, count the occurrences, then insert a new record into the MUSIC_FESTIVAL table. The new record's ID is the maximum ID from MUSIC_FESTIVAL plus one, and it includes the count, static text values, and the current date formatted as 'DD MON YYYY'.",
    "natural_language": "Create trigger TRG_ARTIST_AGE_CHECK on ARTIST. Before insert, if new ARTIST_ID is in VOLUME, count its occurrences. Insert into MUSIC_FESTIVAL with max ID plus one, the count, static text, and current date as 'DD MON YYYY'.",
    "id": 200
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_VOLUME_INSERT_LOG that is executed before an insert operation on the VOLUME table for each row being inserted. The trigger declares a local variable v_artist_name of type VARCHAR2 with a maximum length of 255 characters. It begins by selecting the ARTIST column value from the ARTIST table where the ARTIST_ID matches the ARTIST_ID of the new row being inserted into the VOLUME table, and assigns this value to the v_artist_name variable. Subsequently, it updates the MUSIC_FESTIVAL table by setting the RESULT column to a string that concatenates 'Updated by ' with the value of v_artist_name for the row where the VOLUME column matches the VOLUME_ID of the new row being inserted into the VOLUME table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_VOLUME_INSERT_LOG\nBEFORE INSERT ON VOLUME\nFOR EACH ROW\nDECLARE\n   v_artist_name VARCHAR2(255);\nBEGIN\n   SELECT ARTIST INTO v_artist_name FROM ARTIST WHERE ARTIST_ID = :NEW.ARTIST_ID;\n   UPDATE MUSIC_FESTIVAL SET RESULT = 'Updated by ' || v_artist_name WHERE VOLUME = :NEW.VOLUME_ID;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (4, '45:17', '31 January', 2, 'New Song', 1)",
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (5, '45:18', '7 February', 1, 'Another Song', 2)",
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (6, '45:19', '14 February', 3, 'Hit Song', 4)",
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (7, '45:20', '21 February', 4, 'Top Song', 1)",
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (8, '45:21', '28 February', 5, 'Popular Song', 2)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_VOLUME_INSERT_LOG on the VOLUME table. For each new row, retrieve the ARTIST name from the ARTIST table using the new ARTIST_ID, then update the MUSIC_FESTIVAL table's RESULT column to 'Updated by ' concatenated with that artist name where VOLUME matches the new VOLUME_ID.",
    "natural_language": "Create a BEFORE INSERT row-level trigger called TRG_VOLUME_INSERT_LOG for the VOLUME table. For every new row, fetch the ARTIST name from the ARTIST table using the new ARTIST_ID. Then, set the MUSIC_FESTIVAL table's RESULT column to 'Updated by ' combined with that artist name wherever the VOLUME matches the new VOLUME_ID.",
    "id": 201
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_VOLUME_ARTIST_CLEANUP that is defined to fire automatically after a row is deleted from the VOLUME table, executing once for each deleted row; within the trigger body, a local variable v_artist_age of type NUMBER is declared, then a SELECT statement is executed to retrieve the AGE column value from the ARTIST table for the specific row where the ARTIST_ID column matches the ARTIST_ID value from the deleted VOLUME row (referenced via the :OLD.ARTIST_ID bind variable), storing the result into v_artist_age; subsequently, an UPDATE statement modifies the MUSIC_FESTIVAL table, setting its RESULT column to a concatenated string literal 'Artist Age: ' followed by the numeric value of v_artist_age, but only for those rows in MUSIC_FESTIVAL where the VOLUME column equals the VOLUME_ID value from the deleted VOLUME row (referenced via the :OLD.VOLUME_ID bind variable).",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_VOLUME_ARTIST_CLEANUP\nAFTER DELETE ON VOLUME\nFOR EACH ROW\nDECLARE\n   v_artist_age NUMBER;\nBEGIN\n   SELECT AGE INTO v_artist_age FROM ARTIST WHERE ARTIST_ID = :OLD.ARTIST_ID;\n   UPDATE MUSIC_FESTIVAL SET RESULT = 'Artist Age: ' || v_artist_age WHERE VOLUME = :OLD.VOLUME_ID;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "DELETE FROM VOLUME WHERE VOLUME_ID = 1",
      "DELETE FROM VOLUME WHERE ARTIST_ID = 2",
      "DELETE FROM VOLUME WHERE VOLUME_ID = 3 AND ARTIST_ID = 1",
      "DELETE FROM VOLUME WHERE VOLUME_ISSUE = '45:14 '",
      "DELETE FROM VOLUME WHERE SONG = ' Walk Like an Egyptian '"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named TRG_VOLUME_ARTIST_CLEANUP on the VOLUME table. For each deleted row, retrieve the AGE from the ARTIST table using the old ARTIST_ID, then update the MUSIC_FESTIVAL table's RESULT column to 'Artist Age: ' concatenated with that age where VOLUME matches the old VOLUME_ID.",
    "natural_language": "Alright, so we need a trigger that fires after a row gets deleted from the VOLUME table. Call it TRG_VOLUME_ARTIST_CLEANUP. Every time a row's wiped out, grab the ARTIST's AGE from the ARTIST table using the old ARTIST_ID. Then, go update the MUSIC_FESTIVAL table: set its RESULT column to 'Artist Age: ' plus that age you just grabbed, but only for rows where the VOLUME matches the old VOLUME_ID that was just deleted.",
    "id": 202
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_actor_update that is defined to fire automatically after each row is updated on the ACTOR table, and within its declarative section it declares a local variable v_new_musical_id of type NUMBER; the trigger's execution block first checks a condition on the updated row's new AGE value, and if that AGE is greater than 30, it performs an update on the MUSICAL table, setting the RESULT column to the string 'Legendary' specifically for the row where the MUSICAL_ID column matches the new MUSICAL_ID value from the updated ACTOR row; if the AGE is not greater than 30 (i.e., 30 or less), it instead performs a delete operation on the MUSICAL table, removing the row where the MUSICAL_ID column matches the new MUSICAL_ID value from the updated ACTOR row; following this conditional logic, the trigger executes a SELECT statement that retrieves the maximum value from the MUSICAL_ID column in the MUSICAL table, adds 1 to it, and stores the result into the local variable v_new_musical_id; finally, the trigger performs an INSERT operation into the MUSICAL table, creating a new row with the following column values: the MUSICAL_ID column is set to the calculated v_new_musical_id, the NAME column is set to the string 'Future Musical', the YEAR column is set to the number 2025, the AWARD column is set to the string 'Future Award', the CATEGORY column is set to the string 'Future Category', the NOMINEE column is set to the string 'Future Nominee', and the RESULT column is set to the string 'Pending'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_actor_update\nAFTER UPDATE ON ACTOR\nFOR EACH ROW\nDECLARE\n  v_new_musical_id NUMBER;\nBEGIN\n  IF :NEW.AGE > 30 THEN\n    UPDATE MUSICAL SET RESULT = 'Legendary' WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n  ELSE\n    DELETE FROM MUSICAL WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n  END IF;\n\n  SELECT MAX(MUSICAL_ID) + 1 INTO v_new_musical_id FROM MUSICAL;\n  \n  INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT)\n  VALUES (v_new_musical_id, 'Future Musical', 2025, 'Future Award', 'Future Category', 'Future Nominee', 'Pending');\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "UPDATE ACTOR SET AGE = 31 WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 32 WHERE ACTOR_ID = 2",
      "UPDATE ACTOR SET AGE = 33 WHERE ACTOR_ID = 3",
      "UPDATE ACTOR SET AGE = 25 WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 29 WHERE ACTOR_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_actor_update on the ACTOR table. For each updated row: if the new AGE > 30, update the MUSICAL table's RESULT to 'Legendary' where MUSICAL_ID matches the new MUSICAL_ID; otherwise, delete that MUSICAL row. Then, insert a new row into MUSICAL with an auto-incremented MUSICAL_ID and preset values ('Future Musical', 2025, 'Future Award', 'Future Category', 'Future Nominee', 'Pending').",
    "natural_language": "Create trigger trg_actor_update on ACTOR. After updating a row: if new AGE > 30, set MUSICAL.RESULT to 'Legendary' for matching MUSICAL_ID; else delete that MUSICAL row. Then insert a new MUSICAL row with auto-incremented ID and preset values.",
    "id": 203
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT` row-level trigger named `trg_musical_insert` on the `MUSICAL` table that executes after a new row is successfully inserted into the `MUSICAL` table. For each newly inserted `MUSICAL` row, the trigger first declares a local numeric variable `v_new_actor_id` to store a generated actor identifier. The trigger then evaluates a conditional `IF` statement based on the `YEAR` column of the newly inserted `MUSICAL` row, referenced as `:NEW.YEAR`.\n\nIf the value of `:NEW.YEAR` is greater than `2000`, the trigger proceeds with the following operations:\n1. It calculates a new unique `ACTOR_ID` by selecting the maximum existing `ACTOR_ID` from the `ACTOR` table, using the `NVL` function to treat a `NULL` result (if the `ACTOR` table is empty) as `0`, and then adding `1` to this value. This calculated `ACTOR_ID` is stored in the `v_new_actor_id` variable.\n2. It then inserts a new row into the `ACTOR` table. The `ACTOR_ID` column is set to the value of `v_new_actor_id`. The `NAME` column is set to the string literal `'Modern Actor'`. The `MUSICAL_ID` column is set to the value of `v_new_actor_id`, which, based on the provided schema description, implies a self-referencing foreign key relationship where `ACTOR.MUSICAL_ID` references `ACTOR.ACTOR_ID`. The `\"CHARACTER\"` column is set to the string literal `'Modern Character'`. The `DURATION` column is set to the string literal `'2023'`. The `AGE` column is set to the numeric value `25`.\n\nIf the value of `:NEW.YEAR` is not greater than `2000` (i.e., it is less than or equal to `2000`), the trigger executes the `ELSE` branch, which performs a `DELETE` operation. It deletes all rows from the `ACTOR` table where the `MUSICAL_ID` column matches the `MUSICAL_ID` of the newly inserted `MUSICAL` row, referenced as `:NEW.MUSICAL_ID`.\n\nRegardless of the `IF` condition's outcome, after the conditional block, the trigger performs an `UPDATE` operation on the `ACTOR` table. It sets the `DURATION` column to the string literal `'2023'` for all rows in the `ACTOR` table where the `MUSICAL_ID` column matches the `MUSICAL_ID` of the newly inserted `MUSICAL` row, referenced as `:NEW.MUSICAL_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_musical_insert\nAFTER INSERT ON MUSICAL\nFOR EACH ROW\nDECLARE\n  v_new_actor_id NUMBER;\nBEGIN\n  IF :NEW.YEAR > 2000 THEN\n    -- Generate a unique ACTOR_ID for the new actor\n    SELECT NVL(MAX(ACTOR_ID), 0) + 1 INTO v_new_actor_id FROM ACTOR;\n\n    -- Insert into ACTOR.\n    -- Based on the schema description \"ACTOR.MUSICAL_ID = ACTOR.ACTOR_ID\",\n    -- ACTOR.MUSICAL_ID is a foreign key referencing ACTOR.ACTOR_ID.\n    -- Therefore, ACTOR.MUSICAL_ID must be set to an existing ACTOR_ID.\n    -- To satisfy this for a newly inserted actor, we set it to its own ACTOR_ID (self-reference).\n    -- This is an unusual design for a column named MUSICAL_ID, but adheres to the explicit schema.\n    INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, \"CHARACTER\", DURATION, AGE)\n    VALUES (v_new_actor_id, 'Modern Actor', v_new_actor_id, 'Modern Character', '2023', 25);\n  ELSE\n    -- Delete actors associated with the new musical if year is not > 2000\n    -- This logic seems a bit odd, but it's what was in the original ELSE branch.\n    DELETE FROM ACTOR WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n  END IF;\n\n  -- Update duration for actors associated with the new musical\n  -- This update still uses MUSICAL_ID to filter, which implies a logical link to MUSICAL.\n  -- This highlights the conflict between the explicit schema relationship and the column name/usage.\n  -- Assuming this update is intended to affect actors related to the *musical* just inserted.\n  UPDATE ACTOR SET DURATION = '2023' WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n\n  -- Removed: DELETE FROM MUSICAL WHERE YEAR < 1990;\n  -- This statement caused an ORA-04091 (mutating table) error,\n  -- as a trigger cannot perform DML on the table that fired it.\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT) VALUES (4, 'Hamilton', 2015, 'Tony Award', 'Best Musical', 'Lin-Manuel Miranda', 'Won')",
      "INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT) VALUES (5, 'Dear Evan Hansen', 2016, 'Tony Award', 'Best Musical', 'Ben Platt', 'Won')",
      "INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT) VALUES (6, 'Come From Away', 2017, 'Tony Award', 'Best Direction of a Musical', 'Christopher Ashley', 'Won')",
      "INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT) VALUES (7, 'The Lion King', 1997, 'Tony Award', 'Best Musical', 'Julie Taymor', 'Won')",
      "INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT) VALUES (8, 'Chicago', 1996, 'Tony Award', 'Best Revival of a Musical', 'Walter Bobbie', 'Won')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_musical_insert on the MUSICAL table. For each new row: if YEAR > 2000, generate a new ACTOR_ID and insert a new actor with preset values ('Modern Actor', etc.) into the ACTOR table; otherwise, delete all actors where MUSICAL_ID matches the new MUSICAL_ID. Finally, update all matching actors' DURATION to '2023'.",
    "natural_language": "Construct an AFTER INSERT row-level trigger, which should be named trg_musical_insert, specifically for the MUSICAL table. For every newly inserted row, the trigger must perform a detailed conditional check: if the inserted YEAR value is determined to be greater than the year 2000, then the system must meticulously generate a fresh ACTOR_ID and subsequently insert a brand new actor record, complete with carefully preset values such as 'Modern Actor', into the ACTOR table. Conversely, if the YEAR is not greater than 2000, the trigger must comprehensively locate and delete all existing actor records where their MUSICAL_ID precisely matches the new row's MUSICAL_ID. Finally, as a concluding action, the trigger must diligently update the DURATION field to the specific string '2023' for every single actor record that matches the MUSICAL_ID of the newly inserted musical.",
    "id": 204
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_player_update that is executed automatically after an update operation is performed on the PLAYER table. This trigger operates for each row affected by the update. Within the trigger's body, a DELETE operation is executed on the SCHOOL_DETAILS table, specifically targeting rows where the SCHOOL_ID column matches the value of the SCHOOL_ID column from the row before it was updated in the PLAYER table, referred to as :OLD.SCHOOL_ID. The trigger does not perform any other operations, such as inserts, updates, or selects, and does not involve any function calls or conditional logic.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_player_update\nAFTER UPDATE ON PLAYER\nFOR EACH ROW\nBEGIN\n    DELETE FROM SCHOOL_DETAILS\n    WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "UPDATE PLAYER SET PLAYER = 'New Player Name' WHERE PLAYER_ID = 1",
      "UPDATE PLAYER SET TEAM = 'New Team' WHERE PLAYER_ID = 2",
      "UPDATE PLAYER SET AGE = 17 WHERE PLAYER_ID = 3",
      "UPDATE PLAYER SET POSITION = 'Pitcher' WHERE PLAYER_ID = 1",
      "UPDATE PLAYER SET SCHOOL_ID = 99 WHERE PLAYER_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_player_update on the PLAYER table. For each updated row, delete from SCHOOL_DETAILS where SCHOOL_ID matches the old SCHOOL_ID.",
    "natural_language": "Make an AFTER UPDATE row trigger trg_player_update on PLAYER. Delete from SCHOOL_DETAILS where SCHOOL_ID equals the old SCHOOL_ID.",
    "id": 205
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_delete that is defined to execute before any delete operation on the SCHOOL table for each individual row being deleted, and within its body performs a delete operation on the SCHOOL_PERFORMANCE table where the SCHOOL_PERFORMANCE.SCHOOL_ID column value exactly matches the SCHOOL_ID column value from the row currently being deleted from the SCHOOL table, which is accessed using the :OLD.SCHOOL_ID correlation identifier.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_delete\nBEFORE DELETE ON SCHOOL\nFOR EACH ROW\nBEGIN\n    DELETE FROM SCHOOL_PERFORMANCE\n    WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 1",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 2",
      "DELETE FROM SCHOOL WHERE LOCATION = 'Hornsby'",
      "DELETE FROM SCHOOL WHERE SCHOOL = 'Barker College'",
      "DELETE FROM SCHOOL WHERE FOUNDED < 1900"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_school_delete on the SCHOOL table. For each deleted row, delete from SCHOOL_PERFORMANCE where SCHOOL_ID equals the deleted row's SCHOOL_ID.",
    "natural_language": "How can I create a BEFORE DELETE row-level trigger named trg_school_delete on the SCHOOL table that, for each deleted row, deletes the corresponding records from the SCHOOL_PERFORMANCE table where SCHOOL_ID matches the deleted row's SCHOOL_ID?",
    "id": 206
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT` row-level trigger named `trg_likes_after_insert` on the `LIKES` table. This trigger executes immediately after a new row is successfully inserted into the `LIKES` table. For each row inserted, the trigger first declares two local numeric variables: `v_grade` and `v_count`. It then attempts to retrieve the `GRADE` column value from the `HIGHSCHOOLER` table for the student whose `ID` matches the `STUDENT_ID` of the newly inserted row in the `LIKES` table (referenced as `:NEW.STUDENT_ID`). This retrieved `GRADE` value is stored in the `v_grade` variable. Following this, a conditional logic block is executed. If the `v_grade` is greater than 10, the trigger performs a `DELETE` operation on the `FRIEND` table, removing all rows where the `STUDENT_ID` column matches the `STUDENT_ID` of the newly inserted row in the `LIKES` table (`:NEW.STUDENT_ID`). If the `v_grade` is not greater than 10 but is less than 10, the trigger proceeds to check for the existence of a specific friend pair. It performs a `SELECT COUNT(*)` operation on the `FRIEND` table, counting rows where the `STUDENT_ID` matches `:NEW.STUDENT_ID` and the `FRIEND_ID` matches the `LIKED_ID` of the newly inserted row in the `LIKES` table (`:NEW.LIKED_ID`). The result of this count is stored in the `v_count` variable. If `v_count` is 0, indicating that the friend pair does not already exist, the trigger then performs an `INSERT` operation into the `FRIEND` table, adding a new row with `STUDENT_ID` set to `:NEW.STUDENT_ID` and `FRIEND_ID` set to `:NEW.LIKED_ID`. If neither of the previous conditions ( `v_grade > 10` or `v_grade < 10`) is met, meaning `v_grade` is exactly 10, the trigger performs an `UPDATE` operation on the `HIGHSCHOOLER` table. It concatenates the string `'_L'` to the existing `NAME` column value and updates this `NAME` for the row where the `ID` matches `:NEW.STUDENT_ID`. An exception handler is included for the `NO_DATA_FOUND` exception. If the initial `SELECT` statement into `v_grade` does not find a matching student in the `HIGHSCHOOLER` table, this exception is caught, and the handler performs no action (represented by `NULL`), effectively ignoring the case where the student associated with the new like does not exist in the `HIGHSCHOOLER` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_likes_after_insert\nAFTER INSERT ON LIKES\nFOR EACH ROW\nDECLARE\n  v_grade NUMBER;\n  v_count NUMBER;\nBEGIN\n  SELECT GRADE INTO v_grade FROM HIGHSCHOOLER WHERE ID = :NEW.STUDENT_ID;\n  \n  IF v_grade > 10 THEN\n    DELETE FROM FRIEND WHERE STUDENT_ID = :NEW.STUDENT_ID;\n  ELSIF v_grade < 10 THEN\n    -- Check if the friend pair already exists to avoid primary key violation\n    SELECT COUNT(*) INTO v_count \n    FROM FRIEND \n    WHERE STUDENT_ID = :NEW.STUDENT_ID \n      AND FRIEND_ID = :NEW.LIKED_ID;\n    \n    IF v_count = 0 THEN\n      INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) \n      VALUES (:NEW.STUDENT_ID, :NEW.LIKED_ID);\n    END IF;\n  ELSE\n    UPDATE HIGHSCHOOLER \n    SET NAME = NAME || '_L' \n    WHERE ID = :NEW.STUDENT_ID;\n  END IF;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    NULL; -- Handle case where student doesn't exist in HIGHSCHOOLER\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (1510, 1101)",
      "INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (1689, 1468)",
      "INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (1381, 1304)",
      "INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (1510, 1247)",
      "INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (1689, 1025)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_likes_after_insert on the LIKES table. For each new row, get the student's grade from HIGHSCHOOLER. If grade > 10, delete the student's records from FRIEND. If grade < 10, check if a friend pair exists; if not, insert it into FRIEND. If grade = 10, update the student's name in HIGHSCHOOLER by appending '_L'. Handle NO_DATA_FOUND by doing nothing.",
    "natural_language": "Construct an AFTER INSERT row-level trigger designated as trg_likes_after_insert on the LIKES table. For each inserted row, retrieve the associated student's grade from the HIGHSCHOOLER table. Should the grade exceed 10, proceed to delete all records pertaining to that student from the FRIEND table. If the grade is below 10, verify the existence of the corresponding friend pair; in the event it does not exist, insert said pair into the FRIEND table. In the case where the grade is precisely equal to 10, update the student's name within the HIGHSCHOOLER table by appending the suffix '_L'. Any NO_DATA_FOUND exception encountered is to be handled silently, with no subsequent action required.",
    "id": 207
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_friend_before_delete that fires before a row is deleted from the FRIEND table, for each affected row, and declares local variables v_name as a VARCHAR2 with a maximum length of 255 characters and v_xml as an XMLTYPE; the trigger first selects the NAME column from the HIGHSCHOOLER table into v_name where the HIGHSCHOOLER.ID column matches the old value of the STUDENT_ID column from the FRIEND table being deleted, then constructs an XMLTYPE value v_xml by concatenating the string '<record><action>DELETE</action><student>' with the retrieved v_name and the closing string '</student></record>'; then, using a conditional IF statement, the trigger checks if the old STUDENT_ID value is equal to the old FRIEND_ID value from the FRIEND row, and if this condition is true, it executes a DELETE operation on the LIKES table where the LIKES.STUDENT_ID column equals the old STUDENT_ID value; if the condition is false, meaning the old STUDENT_ID and old FRIEND_ID are different, the trigger instead performs an INSERT into the LIKES table, specifying columns STUDENT_ID and LIKED_ID with values set to the old STUDENT_ID and old FRIEND_ID respectively, and then executes an UPDATE on the HIGHSCHOOLER table, decrementing the GRADE column by one for the row where the HIGHSCHOOLER.ID column equals the old STUDENT_ID value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_friend_before_delete\nBEFORE DELETE ON FRIEND\nFOR EACH ROW\nDECLARE\n  v_name VARCHAR2(255);\n  v_xml XMLTYPE;\nBEGIN\n  SELECT NAME INTO v_name FROM HIGHSCHOOLER WHERE ID = :OLD.STUDENT_ID;\n  v_xml := XMLTYPE('<record><action>DELETE</action><student>' || v_name || '</student></record>');\n  IF :OLD.STUDENT_ID = :OLD.FRIEND_ID THEN\n    DELETE FROM LIKES WHERE STUDENT_ID = :OLD.STUDENT_ID;\n  ELSE\n    INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (:OLD.STUDENT_ID, :OLD.FRIEND_ID);\n    UPDATE HIGHSCHOOLER SET GRADE = GRADE - 1 WHERE ID = :OLD.STUDENT_ID;\n  END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1101 AND FRIEND_ID = 1641",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1247 AND FRIEND_ID = 1501",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1381 AND FRIEND_ID = 1381",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1510 AND FRIEND_ID = 1689",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1689 AND FRIEND_ID = 1510"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_friend_before_delete on the FRIEND table. For each deleted row, get the student's name from HIGHSCHOOLER and build an XML record. If the deleted STUDENT_ID equals the deleted FRIEND_ID, delete the student's records from LIKES. Otherwise, insert a new record into LIKES and decrement the student's grade in HIGHSCHOOLER.",
    "natural_language": "Please construct a BEFORE DELETE row-level trigger designated as trg_friend_before_delete on the FRIEND table. For each row that is deleted, one must retrieve the corresponding student name from the HIGHSCHOOLER table and assemble an XML record. In the event that the deleted STUDENT_ID is identical to the deleted FRIEND_ID, it is necessary to delete all records for that student from the LIKES table. Otherwise, a new record should be inserted into the LIKES table, and the student's grade in the HIGHSCHOOLER table must be decremented.",
    "id": 208
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_highschooler_after_update that activates after any update operation on the HIGHSCHOOLER table, executing once for each row affected by the update. The trigger begins by declaring two local variables: v_friend_count of type NUMBER, which will store the count of friends for the updated student, and v_xml of type XMLTYPE, which will store an XML representation of the update event. The trigger first performs a SELECT COUNT(*) operation on the FRIEND table, counting the number of rows where the STUDENT_ID column matches the ID of the updated row in the HIGHSCHOOLER table, and stores this count in v_friend_count. It then constructs an XML document using XMLTYPE, containing the updated student's ID and the friend count, and assigns it to v_xml. The trigger proceeds with a conditional logic block that evaluates the change in the GRADE column between the new and old versions of the row. If the new GRADE is greater than the old GRADE, it executes a DELETE operation on the LIKES table, removing any rows where both STUDENT_ID and LIKED_ID columns match the updated student's ID. If the new GRADE is less than the old GRADE, it performs an INSERT operation into the FRIEND table, adding new rows with STUDENT_ID set to the updated student's ID and FRIEND_ID set to the ID of each student in the HIGHSCHOOLER table whose GRADE matches the new GRADE. If the GRADE remains unchanged, it executes an UPDATE operation on the HIGHSCHOOLER table, setting the NAME column to its uppercase version for all rows where the ID matches any FRIEND_ID associated with the updated student's ID in the FRIEND table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_highschooler_after_update\nAFTER UPDATE ON HIGHSCHOOLER\nFOR EACH ROW\nDECLARE\n  v_friend_count NUMBER;\n  v_xml XMLTYPE;\nBEGIN\n  SELECT COUNT(*) INTO v_friend_count FROM FRIEND WHERE STUDENT_ID = :NEW.ID;\n  v_xml := XMLTYPE('<update><id>' || :NEW.ID || '</id><friends>' || v_friend_count || '</friends></update>');\n  IF :NEW.GRADE > :OLD.GRADE THEN\n    DELETE FROM LIKES WHERE STUDENT_ID = :NEW.ID AND LIKED_ID = :NEW.ID;\n  ELSIF :NEW.GRADE < :OLD.GRADE THEN\n    INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) SELECT :NEW.ID, ID FROM HIGHSCHOOLER WHERE GRADE = :NEW.GRADE;\n  ELSE\n    UPDATE HIGHSCHOOLER SET NAME = UPPER(NAME) WHERE ID IN (SELECT FRIEND_ID FROM FRIEND WHERE STUDENT_ID = :NEW.ID);\n  END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "UPDATE HIGHSCHOOLER SET GRADE = 10 WHERE ID = 1510",
      "UPDATE HIGHSCHOOLER SET GRADE = 8 WHERE ID = 1689",
      "UPDATE HIGHSCHOOLER SET NAME = 'New Name' WHERE ID = 1381",
      "UPDATE HIGHSCHOOLER SET GRADE = 11, NAME = 'Updated Jordan' WHERE ID = 1510",
      "UPDATE HIGHSCHOOLER SET GRADE = 9, NAME = 'Updated Gabriel' WHERE ID = 1689"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_highschooler_after_update on the HIGHSCHOOLER table. For each updated row, count the student's friends and build an XML document. If the new grade is greater than the old grade, delete the student's self-likes from LIKES. If the new grade is less than the old grade, insert new friends from students with the same new grade. If the grade is unchanged, update the names of the student's friends to uppercase.",
    "natural_language": "Build a row-level trigger called trg_highschooler_after_update on the HIGHSCHOOLER table to fire AFTER UPDATE. For each updated row, count the student's friends and construct an XML document. If the new grade is higher than the old grade, remove the student's self-likes from the LIKES table. If the new grade is lower, insert new friends from students who share the new grade. If the grade stays the same, change the names of the student's friends to uppercase.",
    "id": 209
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_likes_before_update` that is activated `BEFORE` any `UPDATE` operation occurs on the `LIKES` table, and executes `FOR EACH ROW` that is being updated. This trigger first declares two local `NUMBER` variables: `v_old_grade` and `v_new_grade`. It then performs a `SELECT` operation to retrieve the `GRADE` from the `HIGHSCHOOLER` table, specifically for the highschooler whose `ID` matches the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`), and stores this retrieved grade into the `v_old_grade` variable. Subsequently, it performs another `SELECT` operation to retrieve the `GRADE` from the `HIGHSCHOOLER` table, specifically for the highschooler whose `ID` matches the `STUDENT_ID` value of the row `AFTER` the update (`:NEW.STUDENT_ID`), and stores this retrieved grade into the `v_new_grade` variable. Following these data retrievals, the trigger evaluates a conditional `IF-THEN-ELSIF-ELSE` block. If the value of `v_old_grade` is `EQUAL` to the value of `v_new_grade`, then an `INSERT` operation is performed into the `FRIEND` table, adding a new record where the `STUDENT_ID` column is set to the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`) and the `FRIEND_ID` column is set to the `STUDENT_ID` value of the row `AFTER` the update (`:NEW.STUDENT_ID`). If the first condition is not met, and the value of `v_old_grade` is `GREATER THAN` the value of `v_new_grade`, then a `DELETE` operation is performed on the `FRIEND` table, removing any records where the `STUDENT_ID` column matches the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`) `AND` the `FRIEND_ID` column matches the `STUDENT_ID` value of the row `AFTER` the update (`:NEW.STUDENT_ID`). If neither of the preceding conditions is met, then an `UPDATE` operation is performed on the `HIGHSCHOOLER` table, setting the `GRADE` column to the value of `v_new_grade` for the highschooler whose `ID` matches the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_likes_before_update\nBEFORE UPDATE ON LIKES\nFOR EACH ROW\nDECLARE\n  v_old_grade NUMBER;\n  v_new_grade NUMBER;\nBEGIN\n  SELECT GRADE INTO v_old_grade FROM HIGHSCHOOLER WHERE ID = :OLD.STUDENT_ID;\n  SELECT GRADE INTO v_new_grade FROM HIGHSCHOOLER WHERE ID = :NEW.STUDENT_ID;\n  IF v_old_grade = v_new_grade THEN\n    INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (:OLD.STUDENT_ID, :NEW.STUDENT_ID);\n  ELSIF v_old_grade > v_new_grade THEN\n    DELETE FROM FRIEND WHERE STUDENT_ID = :OLD.STUDENT_ID AND FRIEND_ID = :NEW.STUDENT_ID;\n  ELSE\n    UPDATE HIGHSCHOOLER SET GRADE = v_new_grade WHERE ID = :OLD.STUDENT_ID;\n  END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "UPDATE LIKES SET STUDENT_ID = 1025 WHERE STUDENT_ID = 1247 AND LIKED_ID = 1101",
      "UPDATE LIKES SET STUDENT_ID = 1316 WHERE STUDENT_ID = 1025 AND LIKED_ID = 1468",
      "UPDATE LIKES SET LIKED_ID = 1304 WHERE STUDENT_ID = 1247 AND LIKED_ID = 1101",
      "UPDATE LIKES SET STUDENT_ID = 1025, LIKED_ID = 1468 WHERE STUDENT_ID = 1316 AND LIKED_ID = 1304",
      "UPDATE LIKES SET STUDENT_ID = 1247 WHERE STUDENT_ID = 1025 AND LIKED_ID = 1468"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_likes_before_update on the LIKES table. For each updated row, get the grades for the old and new STUDENT_ID from HIGHSCHOOLER. If the grades are equal, insert a new friend record. If the old grade is greater than the new grade, delete the corresponding friend record. Otherwise, update the old student's grade in HIGHSCHOOLER to the new grade.",
    "natural_language": "Alright, so we need a trigger called trg_likes_before_update for the LIKES table, and it's gotta fire for each row before an update. Here's the deal: grab the grades for the old and new STUDENT_ID from the HIGHSCHOOLER table. If the grades are the same, just go ahead and add a new friend record. If the old grade is higher than the new one, you'll wanna delete that friend record. Otherwise, if none of that fits, just update the old student's grade in HIGHSCHOOLER to match the new one.",
    "id": 210
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_validate_truck_delivery` that is activated `BEFORE` an `INSERT` operation occurs on the `ORDER_DELIVERIES` table. This trigger executes `FOR EACH ROW` being inserted. Inside the trigger, two local `NUMBER` type variables are declared: `v_truck_exists` and `v_order_exists`. The trigger first performs a `SELECT COUNT(*)` operation to determine if a truck with the `TRUCK_ID` value from the new row (`:NEW.TRUCK_ID`) already exists in the `TRUCKS` table. The result of this count is stored in the `v_truck_exists` variable. Subsequently, another `SELECT COUNT(*)` operation is executed to ascertain if an order with the `ACTUAL_ORDER_ID` value from the new row (`:NEW.ACTUAL_ORDER_ID`) already exists in the `ACTUAL_ORDERS` table. The result of this second count is stored in the `v_order_exists` variable. Following these checks, a conditional `IF` statement evaluates if `v_truck_exists` is equal to `0`. If this condition is true, indicating that no truck with the specified `TRUCK_ID` exists, an `INSERT` operation is performed into the `TRUCKS` table. This `INSERT` statement populates the `TRUCK_ID` column with the value from `:NEW.TRUCK_ID`, the `TRUCK_LICENCE_NUMBER` column with a concatenated string formed by 'DEFAULT' and the value from `:NEW.TRUCK_ID`, and the `TRUCK_DETAILS` column with the literal string 'Auto-generated'. After this, another conditional `IF` statement evaluates if `v_order_exists` is equal to `0`. If this condition is true, signifying that no order with the specified `ACTUAL_ORDER_ID` exists, an `INSERT` operation is performed into the `ACTUAL_ORDERS` table. This `INSERT` statement populates the `ACTUAL_ORDER_ID` column with the value from `:NEW.ACTUAL_ORDER_ID`, the `ORDER_STATUS_CODE` column with the literal string 'Pending', the `REGULAR_ORDER_ID` column with the numeric value `0`, and the `ACTUAL_ORDER_DATE` column with the literal string '2024-01-01 00:00:00'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_truck_delivery\nBEFORE INSERT ON ORDER_DELIVERIES\nFOR EACH ROW\nDECLARE\n    v_truck_exists NUMBER;\n    v_order_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_truck_exists FROM TRUCKS WHERE TRUCK_ID = :NEW.TRUCK_ID;\n    SELECT COUNT(*) INTO v_order_exists FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = :NEW.ACTUAL_ORDER_ID;\n    IF v_truck_exists = 0 THEN\n        INSERT INTO TRUCKS (TRUCK_ID, TRUCK_LICENCE_NUMBER, TRUCK_DETAILS) VALUES (:NEW.TRUCK_ID, 'DEFAULT' || :NEW.TRUCK_ID, 'Auto-generated');\n    END IF;\n    IF v_order_exists = 0 THEN\n        INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID, ACTUAL_ORDER_DATE) VALUES (:NEW.ACTUAL_ORDER_ID, 'Pending', 0, '2024-01-01 00:00:00');\n    END IF;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "ORDER_DELIVERIES",
      "DELIVERY_ROUTE_LOCATIONS",
      "DELIVERY_ROUTES",
      "TRUCKS"
    ],
    "call_sqls": [
      "INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE) VALUES ('27 City Rd', 11, 'Ready', 6, 11, '2024-01-01 00:00:00')",
      "INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE) VALUES ('30 Sam Rd', 1, 'On Road', 4, 10, '2024-01-01 00:00:00')",
      "INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE) VALUES ('67 LV Rd', 3, 'Ready', 1, 2, '2024-01-01 00:00:00')",
      "INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE) VALUES ('27 City Rd', 2, 'On Road', 5, 12, '2024-01-01 00:00:00')",
      "INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE) VALUES ('30 Sam Rd', 14, 'Ready', 3, 13, '2024-01-01 00:00:00')"
    ],
    "summary": "Create a BEFORE INSERT trigger named `trg_validate_truck_delivery` on the `ORDER_DELIVERIES` table. For each new row, check if the `TRUCK_ID` exists in the `TRUCKS` table and if the `ACTUAL_ORDER_ID` exists in the `ACTUAL_ORDERS` table. If the truck does not exist, insert a default record into `TRUCKS`. If the order does not exist, insert a default record into `ACTUAL_ORDERS`.",
    "natural_language": "Please implement a BEFORE INSERT trigger designated as `trg_validate_truck_delivery` on the `ORDER_DELIVERIES` table. For every inserted row, it is necessary to verify the existence of the provided `TRUCK_ID` within the `TRUCKS` table and the `ACTUAL_ORDER_ID` within the `ACTUAL_ORDERS` table. Should the specified truck identifier not be present, a default record must be inserted into the `TRUCKS` table. Correspondingly, if the referenced order identifier is not found, a default record must be inserted into the `ACTUAL_ORDERS` table.",
    "id": 211
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_insert_defaults that is executed before an insert operation on the SONG table for each row being inserted. The trigger first declares a local variable v_next_id of type NUMBER to store the next unique SONG_ID. It then checks if the SONG_ID for the new row (:NEW.SONG_ID) is NULL. If it is NULL, the trigger executes a SELECT statement to find the maximum SONG_ID currently in the SONG table, using the NVL function to handle cases where the table might be empty by returning 0 as the default. It adds 1 to this maximum value to generate the next unique SONG_ID and assigns this value to :NEW.SONG_ID. The trigger then sets default values for other columns in the new row: it assigns 0 to :NEW.SALES if it is NULL, using the NVL function to provide this default value, and assigns 999 to :NEW.HIGHEST_POSITION if it is NULL, again using the NVL function to ensure a default value is set.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_insert_defaults\nBEFORE INSERT ON SONG\nFOR EACH ROW\nDECLARE\n  v_next_id NUMBER;\nBEGIN\n  -- Generate unique SONG_ID if not provided\n  IF :NEW.SONG_ID IS NULL THEN\n    SELECT NVL(MAX(SONG_ID), 0) + 1 INTO v_next_id FROM SONG;\n    :NEW.SONG_ID := v_next_id;\n  END IF;\n  \n  -- Set default values for other columns\n  :NEW.SALES := NVL(:NEW.SALES, 0);\n  :NEW.HIGHEST_POSITION := NVL(:NEW.HIGHEST_POSITION, 999);\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SONG (TITLE, SINGER_ID) VALUES ('New Song 1', 1)",
      "INSERT INTO SONG (TITLE, SINGER_ID, SALES) VALUES ('New Song 2', 2, 500000)",
      "INSERT INTO SONG (TITLE) VALUES ('New Song 3')",
      "INSERT INTO SONG (TITLE, SINGER_ID, HIGHEST_POSITION) VALUES ('New Song 4', 3, 5)",
      "INSERT INTO SONG (TITLE, SALES, HIGHEST_POSITION) VALUES ('New Song 5', 250000, 10)"
    ],
    "summary": "Create a BEFORE INSERT trigger named `trg_song_insert_defaults` on the `SONG` table. For each new row, if `SONG_ID` is NULL, assign the next sequential ID. Also, set default values of 0 for `SALES` and 999 for `HIGHEST_POSITION` if they are NULL.",
    "natural_language": "Hey, can you set up a trigger called `trg_song_insert_defaults` for the `SONG` table that fires before any new row is added? Basically, if the `SONG_ID` is missing, just give it the next number in line. Also, if `SALES` or `HIGHEST_POSITION` are empty, just slap a default of 0 on sales and 999 on the highest position.",
    "id": 212
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_birth_year_validation that is executed before an INSERT or UPDATE operation on the SINGER table. This trigger operates on each row affected by the INSERT or UPDATE statement. The trigger modifies the BIRTH_YEAR column of the row being inserted or updated. It uses the NVL function to check if the new value for BIRTH_YEAR is NULL; if it is NULL, the trigger assigns the current year extracted from the system date (SYSDATE) to the BIRTH_YEAR column. The EXTRACT function is used to obtain the year component from SYSDATE, which represents the current date and time in the database. The ROUND function is applied to ensure the year is a whole number, although this is redundant since the year extracted from SYSDATE is already an integer. The trigger ensures that the BIRTH_YEAR column is never left as NULL during an INSERT or UPDATE operation, defaulting it to the current year if no value is provided.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_birth_year_validation\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nBEGIN\n  :NEW.BIRTH_YEAR := ROUND(NVL(:NEW.BIRTH_YEAR, EXTRACT(YEAR FROM SYSDATE)));\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (4, 'John Doe', NULL, 15.5, 'Canada')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (5, 'Jane Smith', 1985, 20.0, 'United Kingdom')",
      "UPDATE SINGER SET BIRTH_YEAR = NULL WHERE SINGER_ID = 1",
      "UPDATE SINGER SET BIRTH_YEAR = 1990 WHERE SINGER_ID = 2",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (6, 'Michael Johnson', 1975, 10.0, 'Australia')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger named `trg_singer_birth_year_validation` on the `SINGER` table. For each row, if `BIRTH_YEAR` is NULL, set it to the current year extracted from `SYSDATE`.",
    "natural_language": "Hey, set up a trigger called `trg_singer_binger_birth_year_validation` for the `SINGER` table that fires before a new entry is added or an existing one is updated. For each row, if the `BIRTH_YEAR` is left empty, just fill it in with the current year pulled from `SYSDATE`.",
    "id": 213
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is defined as a BEFORE INSERT trigger on the SINGER table, which is executed for each row that is being inserted into the table. The trigger is named trg_singer_citizenship_default. The purpose of this trigger is to ensure that the CITIZENSHIP column of the new row being inserted into the SINGER table is assigned a default value if it is not explicitly provided. Specifically, the trigger uses the NVL function to check the value of the :NEW.CITIZENSHIP pseudo-record, which represents the CITIZENSHIP column of the row currently being inserted. If the :NEW.CITIZENSHIP value is NULL, the NVL function assigns the string 'Unknown' to :NEW.CITIZENSHIP. If :NEW.CITIZENSHIP already has a non-NULL value, it remains unchanged. This operation ensures that every new row in the SINGER table has a non-NULL value in the CITIZENSHIP column, defaulting to 'Unknown' when no value is provided during the insert operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_citizenship_default\nBEFORE INSERT ON SINGER\nFOR EACH ROW\nBEGIN\n  :NEW.CITIZENSHIP := NVL(:NEW.CITIZENSHIP, 'Unknown');\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS) VALUES (100, 'New Artist', 1990, 5)",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (101, 'Another Artist', 1985, 10, NULL)",
      "INSERT INTO SINGER (SINGER_ID, NAME) VALUES (102, 'Name Only Singer')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, CITIZENSHIP) VALUES (103, 'Singer With Citizenship', 1975, 'Canada')",
      "INSERT INTO SINGER VALUES (104, 'Full Data Singer', 2000, 2.5, NULL)"
    ],
    "summary": "Create a BEFORE INSERT trigger named `trg_singer_citizenship_default` on the `SINGER` table. For each new row, if `CITIZENSHIP` is NULL, set it to the default value 'Unknown'.",
    "natural_language": "Set up a trigger on the SINGER table that runs before adding new entries. If the citizenship field looks empty or isn't filled in, just put something like 'Unknown' in there by default.",
    "id": 214
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_ACTOR_UPDATE` that is configured to execute automatically after an `UPDATE` operation is performed on the `ACTOR` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning it will execute once for each individual row that is affected by the `UPDATE` statement on the `ACTOR` table. Upon activation, for each updated row in the `ACTOR` table, the trigger performs an `UPDATE` operation on the `MUSICAL` table. Specifically, it sets the value of the `NAME` column in the `MUSICAL` table to the literal string `'Updated Musical'`. This update is applied only to those rows in the `MUSICAL` table where the value of the `MUSICAL_ID` column matches the value of the `MUSICAL_ID` column from the row that was just updated in the `ACTOR` table. The `:NEW.MUSICAL_ID` refers to the value of the `MUSICAL_ID` column in the `ACTOR` table *after* the `UPDATE` operation has been applied to that specific row.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ACTOR_UPDATE\nAFTER UPDATE ON ACTOR\nFOR EACH ROW\nBEGIN\n    UPDATE MUSICAL\n    SET NAME = 'Updated Musical'\n    WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "UPDATE ACTOR SET NAME = 'Updated Actor' WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 30 WHERE ACTOR_ID = 2",
      "UPDATE ACTOR SET CHARACTER = 'New Role' WHERE ACTOR_ID = 3",
      "UPDATE ACTOR SET DURATION = '2020' WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET MUSICAL_ID = 2 WHERE ACTOR_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE trigger named `TRG_ACTOR_UPDATE` on the `ACTOR` table. For each updated row, update the `MUSICAL` table, setting the `NAME` column to 'Updated Musical' where the `MUSICAL_ID` matches the new `MUSICAL_ID` from the updated actor row.",
    "natural_language": "Create AFTER UPDATE trigger TRG_ACTOR_UPDATE on ACTOR. Update MUSICAL set NAME to 'Updated Musical' where MUSICAL_ID matches new MUSICAL_ID.",
    "id": 215
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_MUSICAL_DELETE that is executed before a delete operation on the MUSICAL table for each row being deleted. The trigger first updates the ACTOR table by setting the MUSICAL_ID column to NULL for all records where the MUSICAL_ID matches the MUSICAL_ID of the row being deleted from the MUSICAL table, effectively breaking any circular references between ACTOR records that may exist due to this MUSICAL_ID. After updating the ACTOR table, the trigger proceeds to delete all records from the ACTOR table where the MUSICAL_ID matches the MUSICAL_ID of the row being deleted from the MUSICAL table, ensuring that all associated ACTOR records are removed before the deletion of the MUSICAL record.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MUSICAL_DELETE\nBEFORE DELETE ON MUSICAL\nFOR EACH ROW\nBEGIN\n    -- First, update any ACTOR records that reference other ACTOR records\n    -- to break the circular reference before deletion\n    UPDATE ACTOR \n    SET MUSICAL_ID = NULL \n    WHERE MUSICAL_ID = :OLD.MUSICAL_ID;\n    \n    -- Then delete the ACTOR records that have the matching MUSICAL_ID\n    DELETE FROM ACTOR WHERE MUSICAL_ID = :OLD.MUSICAL_ID;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 1",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 2",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 3",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 4",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_MUSICAL_DELETE on the MUSICAL table. For each deleted row, first set the MUSICAL_ID to NULL in the ACTOR table for matching records, then delete all ACTOR records with that MUSICAL_ID.",
    "natural_language": "How can I create a BEFORE DELETE row-level trigger named TRG_MUSICAL_DELETE on the MUSICAL table that, for each deleted row, first sets the MUSICAL_ID to NULL in the ACTOR table for matching records and then deletes all ACTOR records with that MUSICAL_ID?",
    "id": 216
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_singer_net_worth` that is defined to execute `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `SINGER` table, and for `EACH ROW` affected by such an operation. This trigger's purpose is to automatically determine and set the value of the `CITIZENSHIP` column for the row being inserted or updated, based on the value of its `NET_WORTH_MILLIONS` column. Specifically, the trigger evaluates the value of the `NET_WORTH_MILLIONS` column of the `NEW` row (represented by `:NEW.NET_WORTH_MILLIONS`). If the value of `:NEW.NET_WORTH_MILLIONS` is strictly greater than `50`, then the `CITIZENSHIP` column of the `NEW` row (represented by `:NEW.CITIZENSHIP`) is set to the string literal `'High Net Worth'`. Otherwise, if the previous condition is not met, the trigger proceeds to check if the value of `:NEW.NET_WORTH_MILLIONS` is strictly greater than `30`. If this second condition is true, then the `CITIZENSHIP` column of the `NEW` row (`:NEW.CITIZENSHIP`) is set to the string literal `'Moderate Net Worth'`. If neither of the preceding conditions is met (meaning `:NEW.NET_WORTH_MILLIONS` is less than or equal to `30`), then the `CITIZENSHIP` column of the `NEW` row (`:NEW.CITIZENSHIP`) is set to the string literal `'Low Net Worth'`. This assignment to `:NEW.CITIZENSHIP` occurs before the actual `INSERT` or `UPDATE` operation is committed to the `SINGER` table, effectively modifying the data that will be stored.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_singer_net_worth\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nBEGIN\n  IF :NEW.NET_WORTH_MILLIONS > 50 THEN\n    :NEW.CITIZENSHIP := 'High Net Worth';\n  ELSIF :NEW.NET_WORTH_MILLIONS > 30 THEN\n    :NEW.CITIZENSHIP := 'Moderate Net Worth';\n  ELSE\n    :NEW.CITIZENSHIP := 'Low Net Worth';\n  END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (4, 'Adele', 1988, 60, 'United Kingdom')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (5, 'Ed Sheeran', 1991, 45, 'United Kingdom')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (6, 'Taylor Swift', 1989, 25, 'United States')",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 55 WHERE SINGER_ID = 1",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 35 WHERE SINGER_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_UPDATE_SINGER_NET_WORTH on the SINGER table. Set the CITIZENSHIP column to 'High Net Worth' if NET_WORTH_MILLIONS > 50, 'Moderate Net Worth' if > 30, otherwise 'Low Net Worth'.",
    "natural_language": "Please implement a BEFORE INSERT OR UPDATE row-level trigger designated as TRG_UPDATE_SINGER_NET_WORTH on the SINGER table. The trigger's function is to assign a value to the CITIZENSHIP column based on the NET_WORTH_MILLIONS figure. Specifically, it should set the column to 'High Net Worth' for values exceeding 50, to 'Moderate Net Worth' for values exceeding 30, and to 'Low Net Worth' for all other values.",
    "id": 217
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_singer_age that is executed before an insert or update operation on the SINGER table for each row affected. The trigger begins by declaring a local variable v_age of type NUMBER to store the calculated age of the singer. The age is computed by subtracting the BIRTH_YEAR column value of the new row (:NEW.BIRTH_YEAR) from the current year obtained using the EXTRACT function on SYSDATE. The trigger then evaluates the calculated age using conditional statements. If the age is greater than 70, the NAME column of the new row (:NEW.NAME) is updated to its uppercase version using the UPPER function. If the age is greater than 50 but not more than 70, the NAME column is updated to its title case version using the INITCAP function. If the age is 50 or less, the NAME column is updated to its lowercase version using the LOWER function. The trigger ensures that the NAME column is formatted according to the age of the singer before the row is inserted or updated in the SINGER table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_singer_age\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nBEGIN\n  DECLARE\n    v_age NUMBER;\n  BEGIN\n    v_age := EXTRACT(YEAR FROM SYSDATE) - :NEW.BIRTH_YEAR;\n    IF v_age > 70 THEN\n      :NEW.NAME := UPPER(:NEW.NAME);\n    ELSIF v_age > 50 THEN\n      :NEW.NAME := INITCAP(:NEW.NAME);\n    ELSE\n      :NEW.NAME := LOWER(:NEW.NAME);\n    END IF;\n  END;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (10, 'john lennon', 1940, 800, 'United Kingdom')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (11, 'paul mccartney', 1942, 1200, 'United Kingdom')",
      "UPDATE SINGER SET BIRTH_YEAR = 1935 WHERE SINGER_ID = 1",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (12, 'mick jagger', 1965, 500, 'United Kingdom')",
      "UPDATE SINGER SET BIRTH_YEAR = 1955, NAME = 'Original Name' WHERE SINGER_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_UPDATE_SINGER_AGE on the SINGER table. Calculate the singer's age from BIRTH_YEAR. Set the NAME to UPPER if age > 70, to INITCAP if age > 50, otherwise to LOWER.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE row-level trigger named TRG_UPDATE_SINGER_AGE on the SINGER table that calculates a singer's age from BIRTH_YEAR and sets the NAME to UPPER if the age is greater than 70, to INITCAP if the age is greater than 50, and to LOWER otherwise?",
    "id": 218
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_citizenship_check that is executed before an INSERT or UPDATE operation on the SINGER table. This trigger operates on each row affected by the INSERT or UPDATE statement. It checks the value of the CITIZENSHIP column in the new row data being inserted or updated. If the CITIZENSHIP is 'United States', it modifies the NET_WORTH_MILLIONS column by multiplying its current value by 1.1 and then rounding the result. If the CITIZENSHIP is 'France', it adjusts the NET_WORTH_MILLIONS column by multiplying its current value by 1.05 and rounding the result. For all other citizenship values, it updates the NET_WORTH_MILLIONS column by multiplying its current value by 1.02 and rounding the result. The ROUND function is used to ensure the NET_WORTH_MILLIONS value is rounded to the nearest whole number after the multiplication operation. The trigger uses conditional logic with IF, ELSIF, and ELSE statements to determine which multiplication factor to apply based on the CITIZENSHIP value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_citizenship_check\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nBEGIN\n  IF :NEW.CITIZENSHIP = 'United States' THEN\n    :NEW.NET_WORTH_MILLIONS := ROUND(:NEW.NET_WORTH_MILLIONS * 1.1);\n  ELSIF :NEW.CITIZENSHIP = 'France' THEN\n    :NEW.NET_WORTH_MILLIONS := ROUND(:NEW.NET_WORTH_MILLIONS * 1.05);\n  ELSE\n    :NEW.NET_WORTH_MILLIONS := ROUND(:NEW.NET_WORTH_MILLIONS * 1.02);\n  END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (10, 'Taylor Swift', 1989, 100, 'United States')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (11, 'Johnny Hallyday', 1943, 50, 'France')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (12, 'Shakira', 1977, 80, 'Colombia')",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 200, CITIZENSHIP = 'United States' WHERE SINGER_ID = 1",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 40, CITIZENSHIP = 'France' WHERE SINGER_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_SINGER_CITIZENSHIP_CHECK on the SINGER table. Adjust NET_WORTH_MILLIONS by multiplying and rounding: by 1.1 for 'United States', 1.05 for 'France', and 1.02 for all other citizenships.",
    "natural_language": "Hey, can you set up a trigger called TRG_SINGER_CITIZENSHIP_CHECK for the SINGER table? It should fire before any new row is added or an existing one is updated. Basically, it needs to tweak the NET_WORTH_MILLIONS: bump it up by 10% for US citizens, 5% for French folks, and just 2% for everyone else, making sure to round the numbers.",
    "id": 219
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named course_arrange_insert_trigger that is defined to fire automatically after a new row is successfully inserted into the COURSE_ARRANGE table, executing once for each inserted row, and within its body performs a single INSERT operation into the TEACHER table, specifying values for the TEACHER_ID, NAME, AGE, and HOMETOWN columns, where the value for the TEACHER_ID column is taken directly from the newly inserted row in the COURSE_ARRANGE table using the :NEW.TEACHER_ID reference, the value for the NAME column is the literal string 'New Teacher', the value for the AGE column is the literal string '30', and the value for the HOMETOWN column is the literal string 'Unknown'.",
    "plsql": "CREATE OR REPLACE TRIGGER course_arrange_insert_trigger\nAFTER INSERT ON COURSE_ARRANGE\nFOR EACH ROW\nBEGIN\n    INSERT INTO TEACHER (TEACHER_ID, NAME, AGE, HOMETOWN)\n    VALUES (:NEW.TEACHER_ID, 'New Teacher', '30', 'Unknown');\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (1, 10, 4)",
      "INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (2, 11, 5)",
      "INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (3, 12, 6)",
      "INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (4, 13, 2)",
      "INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (5, 14, 3)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named COURSE_ARRANGE_INSERT_TRIGGER on the COURSE_ARRANGE table. For each new row, insert a record into the TEACHER table using :NEW.TEACHER_ID, with NAME='New Teacher', AGE='30', and HOMETOWN='Unknown'.",
    "natural_language": "Please construct a row-level trigger designated as COURSE_ARRANGE_INSERT_TRIGGER, which is to be executed after an insertion operation on the COURSE_ARRANGE table. For each newly inserted row, the trigger must insert a corresponding record into the TEACHER table. This record should utilize the TEACHER_ID value from the :NEW pseudorecord, while assigning the values 'New Teacher' to the NAME column, '30' to the AGE column, and 'Unknown' to the HOMETOWN column.",
    "id": 220
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named course_update_trigger that is executed automatically after an update operation is performed on the COURSE table. This trigger operates for each row affected by the update. Within the trigger's body, it performs a delete operation on the COURSE_ARRANGE table, specifically targeting rows where the COURSE_ID column matches the value of the COURSE_ID column from the row before it was updated in the COURSE table. The :OLD.COURSE_ID syntax is used to reference the original value of the COURSE_ID column prior to the update. The trigger does not include any conditional logic or function calls, and its sole purpose is to ensure that any arrangements associated with the course identified by the old COURSE_ID are removed from the COURSE_ARRANGE table following an update to the COURSE table.",
    "plsql": "CREATE OR REPLACE TRIGGER course_update_trigger\nAFTER UPDATE ON COURSE\nFOR EACH ROW\nBEGIN\n    DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = :OLD.COURSE_ID;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "UPDATE COURSE SET STARING_DATE = '8 May' WHERE COURSE_ID = 1",
      "UPDATE COURSE SET COURSE = 'History' WHERE COURSE_ID = 2",
      "UPDATE COURSE SET STARING_DATE = '9 May' WHERE COURSE_ID = 3",
      "UPDATE COURSE SET COURSE = 'Geography' WHERE COURSE_ID = 1",
      "UPDATE COURSE SET STARING_DATE = '10 May' WHERE COURSE_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named course_update_trigger on the COURSE table. For each updated row, delete from the COURSE_ARRANGE table where COURSE_ID equals the old COURSE_ID value (:OLD.COURSE_ID).",
    "natural_language": "Hey, set up a trigger called course_update_trigger that fires after a row gets updated in the COURSE table. Every time a row's changed, it should go ahead and wipe out any matching entries in the COURSE_ARRANGE table where the COURSE_ID matches the old value from that updated row (that's :OLD.COURSE_ID).",
    "id": 221
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `course_arrange_delete_trigger` that is activated immediately after a `DELETE` operation is performed on the `COURSE_ARRANGE` table. This trigger is defined to execute for `EACH ROW` that is affected by the `DELETE` statement. Upon activation for each deleted row, the trigger performs a `DELETE` operation on the `TEACHER` table. The `DELETE` operation on the `TEACHER` table is conditional, targeting only those rows where the value in the `TEACHER_ID` column of the `TEACHER` table is equal to the value of the `TEACHER_ID` column from the row that was just deleted from the `COURSE_ARRANGE` table. The `:OLD` pseudorecord is used to access the `TEACHER_ID` value from the row that existed in the `COURSE_ARRANGE` table prior to its deletion.",
    "plsql": "CREATE OR REPLACE TRIGGER course_arrange_delete_trigger\nAFTER DELETE ON COURSE_ARRANGE\nFOR EACH ROW\nBEGIN\n    DELETE FROM TEACHER WHERE TEACHER_ID = :OLD.TEACHER_ID;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = 2 AND TEACHER_ID = 3 AND GRADE = 3",
      "DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = 3 AND TEACHER_ID = 5 AND GRADE = 1",
      "DELETE FROM COURSE_ARRANGE WHERE TEACHER_ID = 2",
      "DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = 2",
      "DELETE FROM COURSE_ARRANGE"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named course_arrange_delete_trigger on the COURSE_ARRANGE table. For each deleted row, delete from the TEACHER table where TEACHER_ID equals the old TEACHER_ID value (:OLD.TEACHER_ID).",
    "natural_language": "How can I create an AFTER DELETE row-level trigger named course_arrange_delete_trigger on the COURSE_ARRANGE table that, for each deleted row, deletes the corresponding record from the TEACHER table where TEACHER_ID matches the old TEACHER_ID value?",
    "id": 222
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER UPDATE` row-level trigger named `teacher_update_trigger` that is automatically executed after an `UPDATE` operation is performed on any row in the `TEACHER` table. This trigger operates `FOR EACH ROW` that is updated. Within the trigger's execution block, a local variable named `v_new_course_id` of data type `NUMBER` is declared. The trigger first executes a `SELECT` statement to determine the next available `COURSE_ID` for insertion into the `COURSE` table. This `SELECT` statement queries the `COURSE` table to find the `MAX`imum value of the `COURSE_ID` column. The `NVL` (Null Value Logic) function is applied to the result of `MAX(COURSE_ID)` to handle cases where the `COURSE` table might be empty; if `MAX(COURSE_ID)` returns `NULL` (meaning no courses exist), `NVL` will substitute `0`. This result (either the maximum `COURSE_ID` or `0`) is then incremented by `1` to generate a new, unique `COURSE_ID`. The calculated `v_new_course_id` is then assigned to the `v_new_course_id` variable. Following this, an `INSERT` statement is executed to add a new row into the `COURSE` table. The `INSERT` statement populates three columns: `COURSE_ID` with the value stored in `v_new_course_id`, `STARING_DATE` with the literal string value `'1 Jan'`, and `COURSE` with the literal string value `'New Course'`. This entire sequence of operations (calculating a new `COURSE_ID` and inserting a new course) is performed for every single row that is updated in the `TEACHER` table.",
    "plsql": "CREATE OR REPLACE TRIGGER teacher_update_trigger\nAFTER UPDATE ON TEACHER\nFOR EACH ROW\nDECLARE\n    v_new_course_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(COURSE_ID), 0) + 1 INTO v_new_course_id FROM COURSE;\n    \n    INSERT INTO COURSE (COURSE_ID, STARING_DATE, COURSE)\n    VALUES (v_new_course_id, '1 Jan', 'New Course');\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "UPDATE TEACHER SET NAME = 'Joseph Huts Updated' WHERE TEACHER_ID = 1",
      "UPDATE TEACHER SET AGE = '33' WHERE TEACHER_ID = 2",
      "UPDATE TEACHER SET HOMETOWN = 'New Hometown' WHERE TEACHER_ID = 3",
      "UPDATE TEACHER SET NAME = 'Gustaaf Deloor Updated' WHERE TEACHER_ID = 2",
      "UPDATE TEACHER SET AGE = '27' WHERE TEACHER_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named teacher_update_trigger on the TEACHER table. For each updated row, calculate a new COURSE_ID as MAX(COURSE_ID)+1 from the COURSE table (use 0 if NULL), then insert a new row into the COURSE table with this new COURSE_ID, a STARTING_DATE of '1 Jan', and a COURSE name of 'New Course'.",
    "natural_language": "For each updated row in the TEACHER table, calculate the next COURSE_ID by adding 1 to the maximum existing COURSE_ID (use 0 if none exist) from the COURSE table. Then, insert a new row into the COURSE table with that new ID, a STARTING_DATE of '1 Jan', and the name 'New Course'. Create a row-level AFTER UPDATE trigger named teacher_update_trigger to perform this action.",
    "id": 223
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_order_items_ai that activates after a new row is inserted into the ORDER_ITEMS table. This trigger operates for each row inserted and begins by declaring two local variables: v_price of type NUMBER and v_current_type of type VARCHAR2(255). The trigger then executes a SELECT statement to retrieve the PRODUCT_PRICE and PRODUCT_TYPE_CODE from the PRODUCTS table, where the PRODUCT_ID matches the PRODUCT_ID of the newly inserted row in ORDER_ITEMS, storing these values into v_price and v_current_type respectively. Following this, the trigger evaluates a conditional statement: if v_price is greater than 1000 and v_current_type is either NULL or not equal to 'PREMIUM', it enters a nested BEGIN-END block to perform an UPDATE operation on the PRODUCTS table. This update sets the PRODUCT_TYPE_CODE to 'PREMIUM' for the row where PRODUCT_ID matches the PRODUCT_ID of the newly inserted ORDER_ITEMS row. The nested block includes an exception handler for DUP_VAL_ON_INDEX, which gracefully handles any unique constraint violations by doing nothing. Additionally, the trigger has an outer exception handler for NO_DATA_FOUND, which also does nothing if the SELECT statement fails to find a matching product.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_order_items_ai\nAFTER INSERT ON ORDER_ITEMS\nFOR EACH ROW\nDECLARE\n    v_price NUMBER;\n    v_current_type VARCHAR2(255);\nBEGIN\n    SELECT PRODUCT_PRICE, PRODUCT_TYPE_CODE \n    INTO v_price, v_current_type \n    FROM PRODUCTS \n    WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n    \n    IF v_price > 1000 AND (v_current_type IS NULL OR v_current_type != 'PREMIUM') THEN\n        BEGIN\n            UPDATE PRODUCTS \n            SET PRODUCT_TYPE_CODE = 'PREMIUM' \n            WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n        EXCEPTION\n            WHEN DUP_VAL_ON_INDEX THEN\n                NULL; -- Handle unique constraint violation gracefully\n        END;\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        NULL; -- Handle case where product doesn't exist\nEND;",
    "database_name": "department_store",
    "tables": [
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (1, 101, 1)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (2, 102, 2)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (3, 103, 3)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (4, 104, 4)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (5, 105, 5)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_order_items_ai on the ORDER_ITEMS table. For each new row, retrieve the product's price and type from the PRODUCTS table. If the price is greater than 1000 and the type is not 'PREMIUM' (or NULL), update the product's type to 'PREMIUM' in the PRODUCTS table. Handle NO_DATA_FOUND and DUP_VAL_ON_INDEX exceptions by doing nothing.",
    "natural_language": "Set up a trigger on the ORDER_ITEMS table for new entries. When a row is added, get the related product's price and category. If the price seems quite high and the category isn't set to or doesn't look like 'PREMIUM', then change that product's category to 'PREMIUM'. If you run into certain common errors, just skip them.",
    "id": 224
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_order_items_bi that executes automatically before any row is inserted into the ORDER_ITEMS table, and for each new row, it declares a local variable v_type of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the PRODUCTS table to retrieve the PRODUCT_TYPE_CODE column value for the row where the PRODUCT_ID column matches the new incoming PRODUCT_ID value (referenced as :NEW.PRODUCT_ID) and stores that value into the v_type variable, and subsequently checks a conditional IF statement to see if the retrieved v_type value is exactly equal to the string literal 'Clothes', and if this condition is true, it modifies the new ORDER_ID value (referenced as :NEW.ORDER_ID) by adding 1000 to its original value before the row is finally inserted into the ORDER_ITEMS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_order_items_bi\nBEFORE INSERT ON ORDER_ITEMS\nFOR EACH ROW\nDECLARE\n    v_type VARCHAR2(255);\nBEGIN\n    SELECT PRODUCT_TYPE_CODE INTO v_type FROM PRODUCTS WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n    IF v_type = 'Clothes' THEN\n        :NEW.ORDER_ID := :NEW.ORDER_ID + 1000;\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (1, 100, 1)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (2, 200, 2)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (3, 300, 3)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (4, 400, 1)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (5, 500, 2)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_order_items_bi on the ORDER_ITEMS table. For each new row, retrieve the product type from the PRODUCTS table. If the type is 'Clothes', add 1000 to the new ORDER_ID value (:NEW.ORDER_ID) before insertion.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger, which should be named trg_order_items_bi, specifically for the ORDER_ITEMS table. For every single new row that is about to be inserted, you must carefully retrieve the corresponding product type from the detailed PRODUCTS table. In the specific scenario where the retrieved type is precisely identified as 'Clothes', it is essential to programmatically add a value of 1000 to the new ORDER_ID value, referenced as :NEW.ORDER_ID, ensuring this modification occurs seamlessly just prior to the final insertion of the row.",
    "id": 225
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_catalog_content_price_update that is executed before an update operation on the PRICE_IN_DOLLARS column of the CATALOG_CONTENTS table for each row being updated. The trigger first checks if the new value of PRICE_IN_DOLLARS is greater than the old value; if true, it updates the PRICE_IN_EUROS column of the same row to be 85% of the new PRICE_IN_DOLLARS value. If the new PRICE_IN_DOLLARS is less than the old value, it updates the PRICE_IN_POUNDS column to be 75% of the new PRICE_IN_DOLLARS value. If the new and old PRICE_IN_DOLLARS values are equal, it inserts a new row into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table with the CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER from the updated row, an ATTRIBUTE_ID of 1, and an ATTRIBUTE_VALUE of 'Unchanged'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_catalog_content_price_update\nBEFORE UPDATE OF PRICE_IN_DOLLARS ON CATALOG_CONTENTS\nFOR EACH ROW\nBEGIN\n  IF :NEW.PRICE_IN_DOLLARS > :OLD.PRICE_IN_DOLLARS THEN\n    :NEW.PRICE_IN_EUROS := :NEW.PRICE_IN_DOLLARS * 0.85;\n  ELSIF :NEW.PRICE_IN_DOLLARS < :OLD.PRICE_IN_DOLLARS THEN\n    :NEW.PRICE_IN_POUNDS := :NEW.PRICE_IN_DOLLARS * 0.75;\n  ELSE\n    INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE)\n    VALUES (:NEW.CATALOG_ENTRY_ID, :NEW.CATALOG_LEVEL_NUMBER, 1, 'Unchanged');\n  END IF;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 250.00 WHERE CATALOG_ENTRY_ID = 1",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 150.00 WHERE CATALOG_ENTRY_ID = 2",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 360.50 WHERE CATALOG_ENTRY_ID = 3",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 700.00 WHERE CATALOG_ENTRY_ID = 1",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 50.00 WHERE CATALOG_ENTRY_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_catalog_content_price_update on the CATALOG_CONTENTS table for the PRICE_IN_DOLLARS column. If the new price is greater than the old, set PRICE_IN_EUROS to 85% of the new price. If the new price is less, set PRICE_IN_POUNDS to 75% of the new price. If the prices are equal, insert a row into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES with the row's CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID=1, and ATTRIBUTE_VALUE='Unchanged'.",
    "natural_language": "Alright, so we need a trigger that fires off before any row gets updated in the CATALOG_CONTENTS table, specifically when the PRICE_IN_DOLLARS changes. Call this trigger trg_catalog_content_price_update. Here's the deal: if the new price is higher than the old one, we gotta set the PRICE_IN_EUROS to 85% of that new price. If the new price is lower, then set PRICE_IN_POUNDS to 75% of the new price instead. Now, if the old and new prices are exactly the same, we need to log that by popping a new row into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table. For that row, use the current entry's CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER, set the ATTRIBUTE_ID to 1, and slap 'Unchanged' into the ATTRIBUTE_VALUE field.",
    "id": 226
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_catalog_contents_insert` that is activated for `INSERT` operations on the `CATALOG_CONTENTS` table. This trigger defines a local record type `t_catalog_entry` with three fields: `catalog_entry_id` of type `NUMBER`, `catalog_level_number` of type `NUMBER`, and `parent_entry_id` of type `NUMBER`. It also defines a nested table type `t_catalog_entry_list` as a collection of `t_catalog_entry` records. A variable `catalog_entries` of type `t_catalog_entry_list` is declared and initialized as an empty collection.\n\nThe trigger has an `AFTER EACH ROW` section that executes for every row inserted into the `CATALOG_CONTENTS` table. In this section, the `catalog_entries` collection is extended by one element. The `catalog_entry_id` field of the newly added element (which is the last element in the collection) is populated with the value of the `CATALOG_ENTRY_ID` column from the newly inserted row (`:NEW.CATALOG_ENTRY_ID`). Similarly, the `catalog_level_number` field of the last element is populated with the value of the `CATALOG_LEVEL_NUMBER` column from the newly inserted row (`:NEW.CATALOG_LEVEL_NUMBER`), and the `parent_entry_id` field of the last element is populated with the value of the `PARENT_ENTRY_ID` column from the newly inserted row (`:NEW.PARENT_ENTRY_ID`).\n\nThe trigger also has an `AFTER STATEMENT` section that executes once after all rows have been processed by the `AFTER EACH ROW` section. In this section, two local variables are declared: `v_parent_name` of type `VARCHAR2(255)` and `v_attribute_count` of type `NUMBER`. First, a `SELECT` statement is executed to count the number of rows in the `ATTRIBUTE_DEFINITIONS` table where the `ATTRIBUTE_DATA_TYPE` column is equal to the string literal 'Bool'. The result of this count is stored in the `v_attribute_count` variable.\n\nNext, a conditional `IF` statement checks if the `v_attribute_count` is greater than 0. If this condition is true, a `FOR` loop iterates through each element in the `catalog_entries` collection, from the first element to the last. Inside the loop, for each element `i` in `catalog_entries`, a `BEGIN...EXCEPTION...END` block is used to handle potential errors. Within this block, a `SELECT` statement attempts to retrieve the `CATALOG_ENTRY_NAME` from the `CATALOG_CONTENTS` table where the `CATALOG_ENTRY_ID` column matches the `parent_entry_id` field of the current `catalog_entries(i)` element. The retrieved `CATALOG_ENTRY_NAME` is stored in the `v_parent_name` variable.\n\nFollowing this `SELECT` statement, another conditional `IF` statement checks if `v_parent_name` is not `NULL`. If this condition is true, an `INSERT` statement is executed to add a new row into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. The `CATALOG_ENTRY_ID` column of the new row is set to the `catalog_entry_id` field of the current `catalog_entries(i)` element. The `CATALOG_LEVEL_NUMBER` column is set to the `catalog_level_number` field of the current `catalog_entries(i)` element. The `ATTRIBUTE_ID` column is populated by a subquery that selects the minimum `ATTRIBUTE_ID` from the `ATTRIBUTE_DEFINITIONS` table where the `ATTRIBUTE_DATA_TYPE` column is equal to the string literal 'Bool'. Finally, the `ATTRIBUTE_VALUE` column is set to the string literal '1'.\n\nIf the `SELECT` statement within the `BEGIN...EXCEPTION...END` block raises a `NO_DATA_FOUND` exception (meaning no parent entry was found for the given `parent_entry_id`), the exception handler simply performs a `NULL` operation, effectively ignoring the error and continuing the loop.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_catalog_contents_insert\nFOR INSERT ON CATALOG_CONTENTS\nCOMPOUND TRIGGER\n  TYPE t_catalog_entry IS RECORD (\n    catalog_entry_id NUMBER,\n    catalog_level_number NUMBER,\n    parent_entry_id NUMBER\n  );\n  TYPE t_catalog_entry_list IS TABLE OF t_catalog_entry;\n  catalog_entries t_catalog_entry_list := t_catalog_entry_list();\n\n  AFTER EACH ROW IS\n  BEGIN\n    catalog_entries.EXTEND;\n    catalog_entries(catalog_entries.LAST).catalog_entry_id := :NEW.CATALOG_ENTRY_ID;\n    catalog_entries(catalog_entries.LAST).catalog_level_number := :NEW.CATALOG_LEVEL_NUMBER;\n    catalog_entries(catalog_entries.LAST).parent_entry_id := :NEW.PARENT_ENTRY_ID;\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n    v_parent_name VARCHAR2(255);\n    v_attribute_count NUMBER;\n  BEGIN\n    SELECT COUNT(*) INTO v_attribute_count FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_DATA_TYPE = 'Bool';\n\n    IF v_attribute_count > 0 THEN\n      FOR i IN 1 .. catalog_entries.COUNT LOOP\n        BEGIN\n          SELECT CATALOG_ENTRY_NAME INTO v_parent_name FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = catalog_entries(i).parent_entry_id;\n          IF v_parent_name IS NOT NULL THEN\n            INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE)\n            VALUES (catalog_entries(i).catalog_entry_id, catalog_entries(i).catalog_level_number, (SELECT MIN(ATTRIBUTE_ID) FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_DATA_TYPE = 'Bool'), '1');\n          END IF;\n        EXCEPTION\n          WHEN NO_DATA_FOUND THEN\n            NULL; -- Handle case where parent entry does not exist\n        END;\n      END LOOP;\n    END IF;\n  END AFTER STATEMENT;\nEND trg_catalog_contents_insert;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, PREVIOUS_ENTRY_ID, NEXT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, PRICE_IN_DOLLARS, PRICE_IN_EUROS, PRICE_IN_POUNDS, CAPACITY, LENGTH, HEIGHT, WIDTH) VALUES (4, 1, 5, 9, 7, 'Ginger Ale', '45 ab', 150.00, 120.00, 130.00, '2', '4', '6', '3')",
      "INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, PREVIOUS_ENTRY_ID, NEXT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, PRICE_IN_DOLLARS, PRICE_IN_EUROS, PRICE_IN_POUNDS, CAPACITY, LENGTH, HEIGHT, WIDTH) VALUES (5, 8, 6, 6, 8, 'Orange Soda', '50 cd', 250.00, 200.00, 210.00, '3', '5', '7', '4')",
      "INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, PREVIOUS_ENTRY_ID, NEXT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, PRICE_IN_DOLLARS, PRICE_IN_EUROS, PRICE_IN_POUNDS, CAPACITY, LENGTH, HEIGHT, WIDTH) VALUES (6, 1, 5, 9, 7, 'Lemon Soda', '60 ef', 300.00, 240.00, 260.00, '4', '6', '8', '5')",
      "INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, PREVIOUS_ENTRY_ID, NEXT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, PRICE_IN_DOLLARS, PRICE_IN_EUROS, PRICE_IN_POUNDS, CAPACITY, LENGTH, HEIGHT, WIDTH) VALUES (7, 8, 6, 6, 8, 'Grape Soda', '70 gh', 350.00, 280.00, 310.00, '5', '7', '9', '6')",
      "INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, PREVIOUS_ENTRY_ID, NEXT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, PRICE_IN_DOLLARS, PRICE_IN_EUROS, PRICE_IN_POUNDS, CAPACITY, LENGTH, HEIGHT, WIDTH) VALUES (8, 1, 5, 9, 7, 'Cherry Soda', '80 ij', 400.00, 320.00, 360.00, '6', '8', '10', '7')"
    ],
    "summary": "Create a compound trigger named trg_catalog_contents_insert for INSERT on the CATALOG_CONTENTS table. In the AFTER EACH ROW section, store each new row's ID, level number, and parent ID into a collection. In the AFTER STATEMENT section, if any 'Bool' type attributes exist in ATTRIBUTE_DEFINITIONS, loop through the collected rows. For each row where a parent name can be found, insert a record into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES using the row's ID and level number, the minimum 'Bool' ATTRIBUTE_ID, and ATTRIBUTE_VALUE='1'. Silently skip rows where the parent is not found.",
    "natural_language": "Alright, so we need a compound trigger called trg_catalog_contents_insert for when we INSERT into the CATALOG_CONTENTS table. First, after each new row goes in, grab its ID, level number, and parent ID and stash them in a collection. Then, after the whole statement is done, check if there are any 'Bool' type attributes over in the ATTRIBUTE_DEFINITIONS table. If there are, go through all the rows we collected. For each one, if you can find its parent's name, pop a new record into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES. Use that row's ID and level number, the smallest 'Bool' ATTRIBUTE_ID you've got, and set the ATTRIBUTE_VALUE to '1'. If a row's parent is MIA, just don't sweat it and move on to the next one.",
    "id": 227
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_catalog_revision_update that fires before any row is updated on the CATALOGS table, and within this trigger, if the new value for the DATE_OF_LATEST_REVISION column is different from its old value, then it performs two operations: first, it updates the CATALOG_ENTRY_NAME column in the CATALOG_CONTENTS table by appending the string '_rev' to the existing name for all catalog entries where the CATALOG_ENTRY_ID matches any entry ID found in a subquery; this subquery selects CATALOG_ENTRY_ID from CATALOG_CONTENTS where the CATALOG_LEVEL_NUMBER equals the minimum CATALOG_LEVEL_NUMBER retrieved from the CATALOG_STRUCTURE table for the specific CATALOG_ID that is being updated in the CATALOGS table (accessed via :NEW.CATALOG_ID); second, it deletes rows from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID matches any entry ID found in another subquery; this second subquery selects CATALOG_ENTRY_ID from the CATALOG_CONTENTS table where the PRICE_IN_DOLLARS is less than 100 and the CATALOG_LEVEL_NUMBER equals the maximum CATALOG_LEVEL_NUMBER retrieved from the CATALOG_STRUCTURE table for the same specific CATALOG_ID (:NEW.CATALOG_ID).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_catalog_revision_update\nBEFORE UPDATE ON CATALOGS\nFOR EACH ROW\nBEGIN\n  IF :NEW.DATE_OF_LATEST_REVISION <> :OLD.DATE_OF_LATEST_REVISION THEN\n    UPDATE CATALOG_CONTENTS SET CATALOG_ENTRY_NAME = CATALOG_ENTRY_NAME || '_rev' WHERE CATALOG_ENTRY_ID IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE CATALOG_LEVEL_NUMBER = (SELECT MIN(CATALOG_LEVEL_NUMBER) FROM CATALOG_STRUCTURE WHERE CATALOG_ID = :NEW.CATALOG_ID));\n    DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS < 100 AND CATALOG_LEVEL_NUMBER = (SELECT MAX(CATALOG_LEVEL_NUMBER) FROM CATALOG_STRUCTURE WHERE CATALOG_ID = :NEW.CATALOG_ID));\n  END IF;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "UPDATE CATALOGS SET DATE_OF_LATEST_REVISION = '2023-01-01 00:00:00' WHERE CATALOG_ID = 1",
      "UPDATE CATALOGS SET DATE_OF_LATEST_REVISION = '2023-02-01 00:00:00' WHERE CATALOG_ID = 2",
      "UPDATE CATALOGS SET DATE_OF_LATEST_REVISION = '2023-03-01 00:00:00' WHERE CATALOG_ID = 3",
      "UPDATE CATALOGS SET DATE_OF_LATEST_REVISION = '2023-04-01 00:00:00' WHERE CATALOG_ID = 1",
      "UPDATE CATALOGS SET DATE_OF_LATEST_REVISION = '2023-05-01 00:00:00' WHERE CATALOG_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_catalog_revision_update on the CATALOGS table. When DATE_OF_LATEST_REVISION changes, perform two actions: 1) Append '_rev' to CATALOG_ENTRY_NAME in CATALOG_CONTENTS for entries whose ID matches those at the minimum CATALOG_LEVEL_NUMBER (from CATALOG_STRUCTURE) for the updated catalog. 2) Delete from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where the entry ID matches those with PRICE_IN_DOLLARS < 100 and at the maximum CATALOG_LEVEL_NUMBER for the same catalog.",
    "natural_language": "Please construct a BEFORE UPDATE row-level trigger designated as trg_catalog_revision_update for the CATALOGS table. Upon modification of the DATE_OF_LATEST_REVISION field, the trigger shall execute two distinct operations. First, it shall append the suffix '_rev' to the CATALOG_ENTRY_NAME within the CATALOG_CONTENTS table for all entries whose ID corresponds to those associated with the minimum CATALOG_LEVEL_NUMBER, as derived from the CATALOG_STRUCTURE table for the catalog being updated. Second, it shall proceed to delete records from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the entry ID matches those entries possessing a PRICE_IN_DOLLARS value less than 100 and which are associated with the maximum CATALOG_LEVEL_NUMBER for the same catalog.",
    "id": 228
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_attribute_definition_cleanup that fires automatically after each row is deleted from the ATTRIBUTE_DEFINITIONS table, performing the following operations: first, it declares two local NUMBER variables, v_total_entries and v_avg_price; then, it executes a SELECT statement to count all rows from the CATALOG_CONTENTS table and stores the result in v_total_entries; next, it executes another SELECT statement to calculate the average value of the PRICE_IN_DOLLARS column from the CATALOG_CONTENTS table and stores the result in v_avg_price; following this, it evaluates a conditional IF statement that checks if v_total_entries is greater than 10 and if v_avg_price is greater than 300; if both conditions are true, it performs two data manipulation operations: first, it deletes rows from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the ATTRIBUTE_ID column matches the value of the ATTRIBUTE_ID column from the deleted row in the ATTRIBUTE_DEFINITIONS table, referenced via the :OLD.ATTRIBUTE_ID bind variable; second, it updates the CATALOG_CONTENTS table, setting the PRICE_IN_EUROS column to its current value multiplied by 1.05, but only for rows where the CATALOG_ENTRY_ID is found in a subquery result; this subquery selects the CATALOG_ENTRY_ID from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the ATTRIBUTE_VALUE column equals the string literal '1' and the CATALOG_LEVEL_NUMBER column matches the result of a nested subquery; this nested subquery selects the CATALOG_LEVEL_NUMBER from the CATALOG_STRUCTURE table where the CATALOG_LEVEL_NAME column equals the string literal 'Product'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_attribute_definition_cleanup\nAFTER DELETE ON ATTRIBUTE_DEFINITIONS\nFOR EACH ROW\nDECLARE\n  v_total_entries NUMBER;\n  v_avg_price NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_total_entries FROM CATALOG_CONTENTS;\n  SELECT AVG(PRICE_IN_DOLLARS) INTO v_avg_price FROM CATALOG_CONTENTS;\n  IF v_total_entries > 10 AND v_avg_price > 300 THEN\n    DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE ATTRIBUTE_ID = :OLD.ATTRIBUTE_ID;\n    UPDATE CATALOG_CONTENTS SET PRICE_IN_EUROS = PRICE_IN_EUROS * 1.05 WHERE CATALOG_ENTRY_ID IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE ATTRIBUTE_VALUE = '1' AND CATALOG_LEVEL_NUMBER = (SELECT CATALOG_LEVEL_NUMBER FROM CATALOG_STRUCTURE WHERE CATALOG_LEVEL_NAME = 'Product'));\n  END IF;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "DELETE FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_ID = 1",
      "DELETE FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_ID = 2",
      "DELETE FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_NAME = 'Green'",
      "DELETE FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_DATA_TYPE = 'Bool'",
      "DELETE FROM ATTRIBUTE_DEFINITIONS WHERE ATTRIBUTE_ID = 3"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_attribute_definition_cleanup on the ATTRIBUTE_DEFINITIONS table. Calculate the total entries and average price from CATALOG_CONTENTS. If total entries > 10 and average price > 300, then: 1) Delete from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where ATTRIBUTE_ID equals the deleted one. 2) Increase PRICE_IN_EUROS by 5% in CATALOG_CONTENTS for entries whose ID is found in CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where ATTRIBUTE_VALUE='1' and the level number matches the 'Product' level from CATALOG_STRUCTURE.",
    "natural_language": "Set up a trigger called trg_attribute_definition_cleanup to run after something gets removed from the ATTRIBUTE_DEFINITIONS table. First, figure out the overall count and the typical price from CATALOG_CONTENTS. If those numbers seem pretty highlike the total is more than a handful and the average price is over a certain decent amountthen do a couple of things: 1) Get rid of related records in CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES for the old attribute. 2) Give a small bump to the prices in CATALOG_CONTENTS for items that are linked to those attributes with a specific value and are at the right product level.",
    "id": 229
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_SINGER_NET_WORTH_UPDATE that is defined to fire automatically after an update operation on the SINGER table, but only when the specific column NET_WORTH_MILLIONS is modified, and it executes once for each row affected by the update. The trigger performs an INSERT operation into the SONG table. For the insertion, it constructs the values for the SONG_ID, TITLE, SINGER_ID, SALES, and HIGHEST_POSITION columns. The SONG_ID value is determined by executing a scalar subquery that selects the maximum existing SONG_ID from the SONG table, applies the NVL function to that result to convert a potential NULL value to 0, and then adds 1 to this result, thereby generating a new sequential identifier. The TITLE column is populated with the literal string constant 'Net Worth Updated'. The SINGER_ID column is populated with the new value of the SINGER_ID column from the updated row in the SINGER table, referenced using the :NEW qualifier. The SALES column is populated with the new value of the NET_WORTH_MILLIONS column from the updated row in the SINGER table, also referenced using the :NEW qualifier. The HIGHEST_POSITION column is populated with the literal numeric constant 0.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_SINGER_NET_WORTH_UPDATE\nAFTER UPDATE OF NET_WORTH_MILLIONS ON SINGER\nFOR EACH ROW\nBEGIN\n    INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION)\n    VALUES ((SELECT NVL(MAX(SONG_ID),0) + 1 FROM SONG), 'Net Worth Updated', :NEW.SINGER_ID, :NEW.NET_WORTH_MILLIONS, 0);\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 31 WHERE SINGER_ID = 1",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 29 WHERE SINGER_ID = 2",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 27 WHERE SINGER_ID = 3",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 32 WHERE SINGER_ID = 1",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 30 WHERE SINGER_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_SINGER_NET_WORTH_UPDATE on the SINGER table, firing only when NET_WORTH_MILLIONS is modified. For each updated row, insert a new record into the SONG table. The SONG_ID is the maximum existing ID plus one (starting at 1). Set TITLE to 'Net Worth Updated', SINGER_ID to the new singer ID, SALES to the new net worth, and HIGHEST_POSITION to 0.",
    "natural_language": "How do I create an AFTER UPDATE row-level trigger named TRG_SINGER_NET_WORTH_UPDATE on the SINGER table that fires only when NET_WORTH_MILLIONS is modified? For each updated row, it should insert a new record into the SONG table where the SONG_ID is the maximum existing ID plus one (starting at 1), the TITLE is set to 'Net Worth Updated', the SINGER_ID is set to the new singer ID, the SALES is set to the new net worth, and the HIGHEST_POSITION is set to 0.",
    "id": 230
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_warehouse_capacity` that is activated `AFTER` an `INSERT` operation occurs on the `BOXES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `BOXES` table. Upon activation, the trigger performs a single `UPDATE` operation on the `WAREHOUSES` table. The `UPDATE` statement modifies the `CAPACITY` column of the `WAREHOUSES` table by decrementing its current value by `1`. This modification is applied only to the row(s) in the `WAREHOUSES` table where the `CODE` column matches the value of the `WAREHOUSE` column from the newly inserted row in the `BOXES` table. The `:NEW.WAREHOUSE` refers to the value of the `WAREHOUSE` column in the row that has just been inserted into the `BOXES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_warehouse_capacity\nAFTER INSERT ON BOXES\nFOR EACH ROW\nBEGIN\n    UPDATE WAREHOUSES\n    SET CAPACITY = CAPACITY - 1\n    WHERE CODE = :NEW.WAREHOUSE;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B001', 'Books', 100, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B002', 'Electronics', 500, 2)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B003', 'Clothes', 75, 3)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B004', 'Tools', 200, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B005', 'Toys', 50, 2)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_update_warehouse_capacity on the BOXES table. For each new row, update the WAREHOUSES table by decrementing the CAPACITY by 1 where the WAREHOUSES.CODE matches the new row's :NEW.WAREHOUSE value.",
    "natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger called trg_update_warehouse_capacity on the BOXES table that, for each new row, updates the WAREHOUSES table to decrement the CAPACITY by 1 where the WAREHOUSES.CODE matches the new row's :NEW.WAREHOUSE value?",
    "id": 231
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_normalize_box_code` that is configured to execute automatically before an `INSERT` operation is performed on the `BOXES` table. This trigger is defined to operate `FOR EACH ROW` affected by the `INSERT` statement, meaning its logic will be applied individually to every new row being inserted. Within the trigger's execution block, the value of the `CODE` column for the new row being inserted, referenced as `:NEW.CODE`, is transformed by converting all its characters to their uppercase equivalents using the `UPPER()` SQL function. The result of this `UPPER()` function call is then assigned back to the `CODE` column of the new row, effectively overwriting the original value with its uppercase version before the row is permanently stored in the `BOXES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_normalize_box_code\nBEFORE INSERT ON BOXES\nFOR EACH ROW\nBEGIN\n    :NEW.CODE := UPPER(:NEW.CODE);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('0mn7', 'Rocks', 180, 3)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('4h8p', 'Scissors', 250, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('4rt3', 'Paper', 190, 4)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('aBcD', 'Tools', 300, 2)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('xYz1', 'Electronics', 500, 3)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_normalize_box_code on the BOXES table. For each new row, set the :NEW.CODE to UPPER(:NEW.CODE).",
    "natural_language": "Set up a trigger on the BOXES table that runs before any new entries are added. It should do something to make the CODE field look more standardized, maybe by adjusting its case to be all uppercase or something similar. Name the trigger something appropriate like trg_normalize_box_code.",
    "id": 232
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_update_warehouse_location` that is defined to execute on the `BOXES` table specifically for `DELETE` operations. This compound trigger is structured into distinct timing points: `BEFORE STATEMENT`, `AFTER EACH ROW`, and `AFTER STATEMENT`.\n\nThe trigger declares a nested table type named `WarehouseIDList` capable of holding `NUMBER` values, and then declares a variable `warehouse_ids` of this `WarehouseIDList` type, initializing it as an empty collection.\n\nDuring the `BEFORE STATEMENT` section, which executes once before any rows are processed by the `DELETE` statement, the `warehouse_ids` collection is cleared of all its elements using the `DELETE` method. This ensures that the collection is empty at the start of each `DELETE` operation.\n\nDuring the `AFTER EACH ROW` section, which executes once for each row that is being deleted from the `BOXES` table, the `warehouse_ids` collection is extended by one element using the `EXTEND` method. The `WAREHOUSE` column value from the row being deleted (referenced as `:OLD.WAREHOUSE`) is then assigned to the newly extended last element of the `warehouse_ids` collection. This effectively collects the `WAREHOUSE` codes of all boxes that are being deleted.\n\nDuring the `AFTER STATEMENT` section, which executes once after all rows have been processed by the `DELETE` statement, a `FOR` loop iterates from `1` up to the current count of elements in the `warehouse_ids` collection. Inside this loop, for each `warehouse_id` retrieved from the `warehouse_ids` collection at index `i`, an `UPDATE` operation is performed on the `WAREHOUSES` table. This `UPDATE` statement sets the `LOCATION` column to the string literal `'Unknown'` for any row in the `WAREHOUSES` table where the `CODE` column matches the current `warehouse_id` from the collection, and additionally, where a subquery condition is met. The subquery `SELECT 1 FROM BOXES WHERE WAREHOUSE = warehouse_ids(i)` checks for the existence of any rows in the `BOXES` table where the `WAREHOUSE` column matches the current `warehouse_id`. The `NOT EXISTS` clause ensures that the `LOCATION` is updated to `'Unknown'` only if there are no remaining boxes associated with that specific `warehouse_id` in the `BOXES` table after the deletion operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_warehouse_location\nFOR DELETE ON BOXES\nCOMPOUND TRIGGER\n\n  TYPE WarehouseIDList IS TABLE OF NUMBER;\n  warehouse_ids WarehouseIDList := WarehouseIDList();\n\n  BEFORE STATEMENT IS\n  BEGIN\n    warehouse_ids.DELETE;\n  END BEFORE STATEMENT;\n\n  AFTER EACH ROW IS\n  BEGIN\n    warehouse_ids.EXTEND;\n    warehouse_ids(warehouse_ids.LAST) := :OLD.WAREHOUSE;\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n  BEGIN\n    FOR i IN 1 .. warehouse_ids.COUNT LOOP\n      UPDATE WAREHOUSES\n      SET LOCATION = 'Unknown'\n      WHERE CODE = warehouse_ids(i) AND NOT EXISTS (\n        SELECT 1 FROM BOXES WHERE WAREHOUSE = warehouse_ids(i)\n      );\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_update_warehouse_location;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DELETE FROM BOXES WHERE CODE = '0MN7'",
      "DELETE FROM BOXES WHERE CODE = '4H8P'",
      "DELETE FROM BOXES WHERE CODE = '4RT3'",
      "DELETE FROM BOXES WHERE WAREHOUSE = 1",
      "DELETE FROM BOXES WHERE WAREHOUSE = 3"
    ],
    "summary": "Create a compound trigger named trg_update_warehouse_location for DELETE on the BOXES table. Declare a nested table variable to store warehouse IDs. In BEFORE STATEMENT, initialize the collection. In AFTER EACH ROW, add the :OLD.WAREHOUSE value to the collection. In AFTER STATEMENT, loop through the collection and update the WAREHOUSES table, setting LOCATION to 'Unknown' for each warehouse code where no associated boxes remain in the BOXES table.",
    "natural_language": "Make a trigger for the BOXES table that handles deletions. It should use a collection to keep track of some warehouse numbers. At the start, get that list ready. Then, as each row is deleted, put the old warehouse value into that list. Finally, after everything is done, go through that list and for any warehouse that doesn't seem to have boxes left, mark its location as something like 'Unknown'.",
    "id": 233
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_box_value that is executed before an insert operation on the BOXES table, specifically for each row being inserted. The trigger modifies the VALUE column of the new row being inserted by applying the ABS function, which calculates the absolute value of the VALUE. This ensures that the VALUE column in the BOXES table will always store a non-negative number, regardless of the original value being inserted. The trigger does not perform any other operations such as updates, deletes, or selects, nor does it involve any conditional statements or logic flow beyond the application of the ABS function to the VALUE column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_box_value\nBEFORE INSERT ON BOXES\nFOR EACH ROW\nBEGIN\n    :NEW.VALUE := ABS(:NEW.VALUE);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('A1B2', 'Books', -100, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('C3D4', 'Tools', -50, 2)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('E5F6', 'Clothes', -200, 3)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('G7H8', 'Electronics', -75, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('I9J0', 'Toys', -120, 2)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_insert_box_value on the BOXES table. For each new row, set the :NEW.VALUE to ABS(:NEW.VALUE) to ensure it is non-negative.",
    "natural_language": "Set up a trigger on the BOXES table that runs before adding any new entries. Make it so that for each new row, the VALUE field ends up being a positive number, basically by taking its absolute value to avoid any negative figures.",
    "id": 234
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_box_contents that is executed before an update operation on the BOXES table. This trigger operates on each row that is being updated. The trigger modifies the value of the CONTENTS column in the row being updated. Specifically, it sets the CONTENTS column to the result of the INITCAP function applied to the new value of CONTENTS. The INITCAP function is a built-in Oracle function that converts the first letter of each word in a string to uppercase and the remaining letters to lowercase. The trigger uses the :NEW pseudorecord to access the new value of the CONTENTS column, which represents the value that will be stored in the database after the update operation. The trigger does not perform any conditional checks or additional operations beyond applying the INITCAP function to the CONTENTS column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_box_contents\nBEFORE UPDATE ON BOXES\nFOR EACH ROW\nBEGIN\n    :NEW.CONTENTS := INITCAP(:NEW.CONTENTS);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "UPDATE BOXES SET CONTENTS = 'rocks' WHERE CODE = '0MN7'",
      "UPDATE BOXES SET CONTENTS = 'scissors' WHERE CODE = '4H8P'",
      "UPDATE BOXES SET CONTENTS = 'paper' WHERE CODE = '4RT3'",
      "UPDATE BOXES SET CONTENTS = 'sand' WHERE CODE = '0MN7'",
      "UPDATE BOXES SET CONTENTS = 'gravel' WHERE CODE = '4H8P'"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_update_box_contents on the BOXES table. For each updated row, set the :NEW.CONTENTS to INITCAP(:NEW.CONTENTS).",
    "natural_language": "Set up a trigger on the BOXES table that runs before any updates. For each row being changed, make sure the contents field gets a bit of formatting, like capitalizing the first letter of each word or something similar. Name the trigger something like trg_update_box_contents.",
    "id": 235
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_council_tax_update that executes before any row is updated on the COUNCIL_TAX table, and within this trigger, if the old value of the CMI_CROSS_REF_ID column is different from the new value of the CMI_CROSS_REF_ID column, then it first selects the MASTER_CUSTOMER_ID value from the CMI_CROSS_REFERENCES table where the CMI_CROSS_REF_ID column equals the old CMI_CROSS_REF_ID value from the COUNCIL_TAX row and stores it in a local variable v_master_customer_id, then it deletes all rows from the RENT_ARREARS table where the COUNCIL_TAX_ID column equals the old COUNCIL_TAX_ID value from the COUNCIL_TAX row, deletes all rows from the PARKING_FINES table where the COUNCIL_TAX_ID column equals the old COUNCIL_TAX_ID value, deletes all rows from the BENEFITS_OVERPAYMENTS table where the COUNCIL_TAX_ID column equals the old COUNCIL_TAX_ID value, then deletes the row from the CMI_CROSS_REFERENCES table where the CMI_CROSS_REF_ID column equals the old CMI_CROSS_REF_ID value, then selects the count of rows from the CMI_CROSS_REFERENCES table where the MASTER_CUSTOMER_ID column equals the retrieved v_master_customer_id value and stores it in a local variable v_ref_count, and if this v_ref_count equals zero, it deletes the row from the CUSTOMER_MASTER_INDEX table where the MASTER_CUSTOMER_ID column equals the v_master_customer_id value; if during the initial selection of MASTER_CUSTOMER_ID no data is found, the trigger handles the NO_DATA_FOUND exception by performing no action.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_council_tax_update\nBEFORE UPDATE ON COUNCIL_TAX\nFOR EACH ROW\nDECLARE\n  v_master_customer_id NUMBER;\n  v_ref_count NUMBER;\nBEGIN\n  IF :OLD.CMI_CROSS_REF_ID <> :NEW.CMI_CROSS_REF_ID THEN\n    -- Get the master customer ID before deleting the cross reference\n    SELECT MASTER_CUSTOMER_ID \n    INTO v_master_customer_id\n    FROM CMI_CROSS_REFERENCES \n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n    \n    -- Delete child records first\n    DELETE FROM RENT_ARREARS WHERE COUNCIL_TAX_ID = :OLD.COUNCIL_TAX_ID;\n    DELETE FROM PARKING_FINES WHERE COUNCIL_TAX_ID = :OLD.COUNCIL_TAX_ID;\n    DELETE FROM BENEFITS_OVERPAYMENTS WHERE COUNCIL_TAX_ID = :OLD.COUNCIL_TAX_ID;\n    \n    -- Delete the cross reference record\n    DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n    \n    -- Check if any other cross references still point to this master customer\n    SELECT COUNT(*)\n    INTO v_ref_count\n    FROM CMI_CROSS_REFERENCES\n    WHERE MASTER_CUSTOMER_ID = v_master_customer_id;\n    \n    -- Only delete from CUSTOMER_MASTER_INDEX if no other references exist\n    IF v_ref_count = 0 THEN\n      DELETE FROM CUSTOMER_MASTER_INDEX WHERE MASTER_CUSTOMER_ID = v_master_customer_id;\n    END IF;\n  END IF;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    NULL; -- Handle case where CMI_CROSS_REF_ID doesn't exist\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 105 WHERE COUNCIL_TAX_ID = 1",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 106, COUNCIL_TAX_ID = 2 WHERE COUNCIL_TAX_ID = 2",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = NULL WHERE COUNCIL_TAX_ID = 3",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 107 WHERE CMI_CROSS_REF_ID = 101",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = CMI_CROSS_REF_ID + 100 WHERE COUNCIL_TAX_ID = 4"
    ],
    "summary": "Create a BEFORE UPDATE row trigger named trg_council_tax_update on the COUNCIL_TAX table. If the CMI_CROSS_REF_ID is changed, retrieve the associated MASTER_CUSTOMER_ID from CMI_CROSS_REFERENCES using the old ID. Then, delete related records from RENT_ARREARS, PARKING_FINES, and BENEFITS_OVERPAYMENTS using the old COUNCIL_TAX_ID. Next, delete the old row from CMI_CROSS_REFERENCES. Finally, if the retrieved MASTER_CUSTOMER_ID has no remaining references in CMI_CROSS_REFERENCES, delete it from CUSTOMER_MASTER_INDEX. Handle NO_DATA_FOUND for the initial select by doing nothing.",
    "natural_language": "Set up a BEFORE UPDATE trigger on the COUNCIL_TAX table, call it something like trg_council_tax_update. Basically, if someone changes the CMI_CROSS_REF_ID, you need to look up the related MASTER_CUSTOMER_ID from CMI_CROSS_REFERENCES using the old reference value. Then, go ahead and clear out any linked entries in a few tableslike RENT_ARREARS, PARKING_FINES, and BENEFITS_OVERPAYMENTSusing the old council tax identifier. After that, remove the old record from CMI_CROSS_REFERENCES. Lastly, if that customer ID you fetched doesn't seem to be linked to anything else in the cross-references anymore, you should probably delete it from the main customer list too. If the initial lookup doesn't find anything, just skip it and don't worry about it.",
    "id": 236
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_parking_fines_update that is defined to fire automatically after each row is updated on the PARKING_FINES table. For each updated row, the trigger performs a series of five update operations on other tables. First, it updates the RENT_ARREARS table, setting its CMI_CROSS_REF_ID column to the new value of the CMI_CROSS_REF_ID column from the updated PARKING_FINES row, but only for rows in RENT_ARREARS where the COUNCIL_TAX_ID column matches the new COUNCIL_TAX_ID value from the PARKING_FINES row. Second, it performs an identical update on the BENEFITS_OVERPAYMENTS table, setting its CMI_CROSS_REF_ID column to the new CMI_CROSS_REF_ID value for rows where its COUNCIL_TAX_ID matches the new COUNCIL_TAX_ID. Third, it performs the same update on the COUNCIL_TAX table, setting its CMI_CROSS_REF_ID column to the new CMI_CROSS_REF_ID value for rows where its COUNCIL_TAX_ID matches the new COUNCIL_TAX_ID. Fourth, it updates the CUSTOMER_MASTER_INDEX table, setting its CMI_DETAILS column to the current date formatted as 'YYYY-MM-DD' using the TO_CHAR function with the CURRENT_DATE parameter; the row to update in CUSTOMER_MASTER_INDEX is identified by a subquery that selects the MASTER_CUSTOMER_ID from the CMI_CROSS_REFERENCES table where the CMI_CROSS_REF_ID column equals the new CMI_CROSS_REF_ID value from the updated PARKING_FINES row. Fifth and finally, it updates the CMI_CROSS_REFERENCES table, setting its SOURCE_SYSTEM_CODE column to the literal string 'Parking' for the row where the CMI_CROSS_REF_ID column matches the new CMI_CROSS_REF_ID value from the updated PARKING_FINES row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_parking_fines_update\nAFTER UPDATE ON PARKING_FINES\nFOR EACH ROW\nBEGIN\n  UPDATE RENT_ARREARS\n  SET CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID\n  WHERE COUNCIL_TAX_ID = :NEW.COUNCIL_TAX_ID;\n\n  UPDATE BENEFITS_OVERPAYMENTS\n  SET CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID\n  WHERE COUNCIL_TAX_ID = :NEW.COUNCIL_TAX_ID;\n\n  UPDATE COUNCIL_TAX\n  SET CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID\n  WHERE COUNCIL_TAX_ID = :NEW.COUNCIL_TAX_ID;\n\n  UPDATE CUSTOMER_MASTER_INDEX\n  SET CMI_DETAILS = TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD')\n  WHERE MASTER_CUSTOMER_ID = (SELECT MASTER_CUSTOMER_ID FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID);\n\n  UPDATE CMI_CROSS_REFERENCES\n  SET SOURCE_SYSTEM_CODE = 'Parking'\n  WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "UPDATE PARKING_FINES SET CMI_CROSS_REF_ID = 65 WHERE COUNCIL_TAX_ID = 9",
      "UPDATE PARKING_FINES SET CMI_CROSS_REF_ID = 41, COUNCIL_TAX_ID = 10 WHERE COUNCIL_TAX_ID = 10",
      "UPDATE PARKING_FINES SET CMI_CROSS_REF_ID = 83 WHERE COUNCIL_TAX_ID = 9",
      "UPDATE PARKING_FINES SET CMI_CROSS_REF_ID = 100 WHERE COUNCIL_TAX_ID = 10",
      "UPDATE PARKING_FINES SET CMI_CROSS_REF_ID = 8 WHERE COUNCIL_TAX_ID = 9"
    ],
    "summary": "Create an AFTER UPDATE row trigger named trg_parking_fines_update on the PARKING_FINES table. Update the CMI_CROSS_REF_ID in RENT_ARREARS, BENEFITS_OVERPAYMENTS, and COUNCIL_TAX to the new value where their COUNCIL_TAX_ID matches the new COUNCIL_TAX_ID. Then, update the CMI_DETAILS in CUSTOMER_MASTER_INDEX to today's date (format 'YYYY-MM-DD') for the MASTER_CUSTOMER_ID linked to the new CMI_CROSS_REF_ID. Finally, update the SOURCE_SYSTEM_CODE to 'Parking' in CMI_CROSS_REFERENCES for the matching new CMI_CROSS_REF_ID.",
    "natural_language": "Please construct an AFTER UPDATE row trigger designated as trg_parking_fines_update on the PARKING_FINES table. The trigger's operations are as follows: first, update the CMI_CROSS_REF_ID field within the RENT_ARREARS, BENEFITS_OVERPAYMENTS, and COUNCIL_TAX tables to the new value, contingent upon a match between their COUNCIL_TAX_ID and the new COUNCIL_TAX_ID. Subsequently, update the CMI_DETAILS field in the CUSTOMER_MASTER_INDEX table to the current date, formatted as 'YYYY-MM-DD', for the MASTER_CUSTOMER_ID associated with the new CMI_CROSS_REF_ID. Finally, update the SOURCE_SYSTEM_CODE to 'Parking' in the CMI_CROSS_REFERENCES table for the corresponding new CMI_CROSS_REF_ID.",
    "id": 237
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE DELETE` row-level trigger named `trg_rent_arrears_delete` on the `RENT_ARREARS` table. This trigger executes before a row is deleted from the `RENT_ARREARS` table. It declares two local variables: `v_master_customer_id` of type `NUMBER` to store a master customer identifier, and `v_ref_count` of type `NUMBER` to store a count of references. The trigger first performs a series of cascading deletions based on the `COUNCIL_TAX_ID` of the row being deleted from `RENT_ARREARS`. Specifically, it deletes rows from the `PARKING_FINES` table where the `COUNCIL_TAX_ID` column matches the `COUNCIL_TAX_ID` of the old (being deleted) `RENT_ARREARS` record. Subsequently, it deletes rows from the `BENEFITS_OVERPAYMENTS` table where the `COUNCIL_TAX_ID` column matches the `COUNCIL_TAX_ID` of the old `RENT_ARREARS` record. Following this, it deletes rows from the `COUNCIL_TAX` table where the `COUNCIL_TAX_ID` column matches the `COUNCIL_TAX_ID` of the old `RENT_ARREARS` record.\n\nAfter these deletions, the trigger retrieves the `MASTER_CUSTOMER_ID` associated with the `CMI_CROSS_REF_ID` of the `RENT_ARREARS` row being deleted. It selects the `MASTER_CUSTOMER_ID` from the `CMI_CROSS_REFERENCES` table into the `v_master_customer_id` variable, using a condition where the `CMI_CROSS_REF_ID` column in `CMI_CROSS_REFERENCES` matches the `CMI_CROSS_REF_ID` of the old `RENT_ARREARS` record.\n\nNext, the trigger performs another series of cascading deletions, this time based on the `CMI_CROSS_REF_ID` of the row being deleted from `RENT_ARREARS`. It deletes rows from the `BENEFITS_OVERPAYMENTS` table where the `CMI_CROSS_REF_ID` column matches the `CMI_CROSS_REF_ID` of the old `RENT_ARREARS` record. Then, it deletes rows from the `PARKING_FINES` table where the `CMI_CROSS_REF_ID` column matches the `CMI_CROSS_REF_ID` of the old `RENT_ARREARS` record. Following this, it deletes rows from the `ELECTORAL_REGISTER` table where the `CMI_CROSS_REF_ID` column matches the `CMI_CROSS_REF_ID` of the old `RENT_ARREARS` record.\n\nAfter these related deletions, the trigger deletes the corresponding row from the `CMI_CROSS_REFERENCES` table itself, where the `CMI_CROSS_REF_ID` column matches the `CMI_CROSS_REF_ID` of the old `RENT_ARREARS` record.\n\nFinally, the trigger checks if the `MASTER_CUSTOMER_ID` that was previously retrieved still has any remaining references in the `CMI_CROSS_REFERENCES` table. It selects the count of rows from the `CMI_CROSS_REFERENCES` table into the `v_ref_count` variable, using a condition where the `MASTER_CUSTOMER_ID` column matches the `v_master_customer_id` variable. An `IF` conditional statement then evaluates `v_ref_count`. If `v_ref_count` is equal to 0, indicating no remaining references for that `MASTER_CUSTOMER_ID` in `CMI_CROSS_REFERENCES`, the trigger proceeds to delete the corresponding row from the `CUSTOMER_MASTER_INDEX` table where the `MASTER_CUSTOMER_ID` column matches the `v_master_customer_id` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_rent_arrears_delete\nBEFORE DELETE ON RENT_ARREARS\nFOR EACH ROW\nDECLARE\n  v_master_customer_id NUMBER;\n  v_ref_count NUMBER;\nBEGIN\n  -- Delete from tables that reference COUNCIL_TAX_ID\n  DELETE FROM PARKING_FINES WHERE COUNCIL_TAX_ID = :OLD.COUNCIL_TAX_ID;\n  DELETE FROM BENEFITS_OVERPAYMENTS WHERE COUNCIL_TAX_ID = :OLD.COUNCIL_TAX_ID;\n  DELETE FROM COUNCIL_TAX WHERE COUNCIL_TAX_ID = :OLD.COUNCIL_TAX_ID;\n  \n  -- Get the MASTER_CUSTOMER_ID for the CMI_CROSS_REF_ID being deleted\n  SELECT MASTER_CUSTOMER_ID INTO v_master_customer_id\n  FROM CMI_CROSS_REFERENCES\n  WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  \n  -- Delete from ALL tables that reference this CMI_CROSS_REF_ID\n  DELETE FROM BENEFITS_OVERPAYMENTS WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  DELETE FROM PARKING_FINES WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  DELETE FROM ELECTORAL_REGISTER WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  \n  -- Now delete from CMI_CROSS_REFERENCES\n  DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  \n  -- Check if this MASTER_CUSTOMER_ID has any remaining references in CMI_CROSS_REFERENCES\n  SELECT COUNT(*) INTO v_ref_count\n  FROM CMI_CROSS_REFERENCES\n  WHERE MASTER_CUSTOMER_ID = v_master_customer_id;\n  \n  -- Only delete from CUSTOMER_MASTER_INDEX if no references remain\n  IF v_ref_count = 0 THEN\n    DELETE FROM CUSTOMER_MASTER_INDEX WHERE MASTER_CUSTOMER_ID = v_master_customer_id;\n  END IF;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "DELETE FROM RENT_ARREARS WHERE COUNCIL_TAX_ID = 1 AND CMI_CROSS_REF_ID = 100",
      "DELETE FROM RENT_ARREARS WHERE COUNCIL_TAX_ID = 2 AND CMI_CROSS_REF_ID = 8",
      "DELETE FROM RENT_ARREARS WHERE COUNCIL_TAX_ID = 6 AND CMI_CROSS_REF_ID = 59",
      "DELETE FROM RENT_ARREARS WHERE COUNCIL_TAX_ID = 1 AND CMI_CROSS_REF_ID = 8",
      "DELETE FROM RENT_ARREARS WHERE COUNCIL_TAX_ID = 2 AND CMI_CROSS_REF_ID = 100"
    ],
    "summary": "Create a BEFORE DELETE row trigger named trg_rent_arrears_delete on the RENT_ARREARS table. Declare variables v_master_customer_id and v_ref_count. First, delete related records from PARKING_FINES, BENEFITS_OVERPAYMENTS, and COUNCIL_TAX using the old COUNCIL_TAX_ID. Retrieve the MASTER_CUSTOMER_ID from CMI_CROSS_REFERENCES using the old CMI_CROSS_REF_ID. Then, delete related records from BENEFITS_OVERPAYMENTS, PARKING_FINES, and ELECTORAL_REGISTER using the old CMI_CROSS_REF_ID. Delete the corresponding row from CMI_CROSS_REFERENCES. Finally, if the retrieved MASTER_CUSTOMER_ID has no remaining references in CMI_CROSS_REFERENCES, delete it from CUSTOMER_MASTER_INDEX.",
    "natural_language": "Construct a BEFORE DELETE row trigger with the name trg_rent_arrears_delete, which is to be placed on the RENT_ARREARS table. You must carefully declare two variables, specifically v_master_customer_id and v_ref_count. Initially, proceed to meticulously delete all associated records from the PARKING_FINES, BENEFITS_OVERPAYMENTS, and COUNCIL_TAX tables by utilizing the old COUNCIL_TAX_ID value. Subsequently, you need to retrieve the crucial MASTER_CUSTOMER_ID from the CMI_CROSS_REFERENCES table by querying with the old CMI_CROSS_REF_ID. Following that, thoroughly delete any related records from the BENEFITS_OVERPAYMENTS, PARKING_FINES, and ELECTORAL_REGISTER tables, again using the old CMI_CROSS_REF_ID as the key. Then, delete the corresponding row from the CMI_CROSS_REFERENCES table itself. Finally, as a last step, if the retrieved MASTER_CUSTOMER_ID has no remaining references whatsoever within the entire CMI_CROSS_REFERENCES table, you must permanently delete it from the CUSTOMER_MASTER_INDEX.",
    "id": 238
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_customer_master_index_insert that is defined to fire automatically after a new row is inserted into the CUSTOMER_MASTER_INDEX table, executing its logic once for each inserted row. The trigger performs a series of five INSERT operations into five different tables, using the value from the newly inserted row's MASTER_CUSTOMER_ID column, referenced via the :NEW pseudorecord, to populate various columns. First, it inserts a row into the CMI_CROSS_REFERENCES table, specifying values for the CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, and SOURCE_SYSTEM_CODE columns; the CMI_CROSS_REF_ID and MASTER_CUSTOMER_ID are both set to the new :NEW.MASTER_CUSTOMER_ID value, and the SOURCE_SYSTEM_CODE is set to the literal string 'Customer'. Second, it inserts a row into the COUNCIL_TAX table, populating the COUNCIL_TAX_ID and CMI_CROSS_REF_ID columns, both with the :NEW.MASTER_CUSTOMER_ID value. Third, it inserts a row into the PARKING_FINES table, populating the COUNCIL_TAX_ID and CMI_CROSS_REF_ID columns, both with the :NEW.MASTER_CUSTOMER_ID value. Fourth, it inserts a row into the RENT_ARREARS table, populating the COUNCIL_TAX_ID and CMI_CROSS_REF_ID columns, both with the :NEW.MASTER_CUSTOMER_ID value. Fifth, it inserts a row into the BENEFITS_OVERPAYMENTS table, populating the COUNCIL_TAX_ID and CMI_CROSS_REF_ID columns, both with the :NEW.MASTER_CUSTOMER_ID value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_customer_master_index_insert\nAFTER INSERT ON CUSTOMER_MASTER_INDEX\nFOR EACH ROW\nBEGIN\n  INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE)\n  VALUES (:NEW.MASTER_CUSTOMER_ID, :NEW.MASTER_CUSTOMER_ID, 'Customer');\n\n  INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID)\n  VALUES (:NEW.MASTER_CUSTOMER_ID, :NEW.MASTER_CUSTOMER_ID);\n\n  INSERT INTO PARKING_FINES (COUNCIL_TAX_ID, CMI_CROSS_REF_ID)\n  VALUES (:NEW.MASTER_CUSTOMER_ID, :NEW.MASTER_CUSTOMER_ID);\n\n  INSERT INTO RENT_ARREARS (COUNCIL_TAX_ID, CMI_CROSS_REF_ID)\n  VALUES (:NEW.MASTER_CUSTOMER_ID, :NEW.MASTER_CUSTOMER_ID);\n\n  INSERT INTO BENEFITS_OVERPAYMENTS (COUNCIL_TAX_ID, CMI_CROSS_REF_ID)\n  VALUES (:NEW.MASTER_CUSTOMER_ID, :NEW.MASTER_CUSTOMER_ID);\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (101, 'Details for Customer 101')",
      "INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (102, 'Details for Customer 102')",
      "INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (103, 'Details for Customer 103')",
      "INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (104, 'Details for Customer 104')",
      "INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (105, 'Details for Customer 105')"
    ],
    "summary": "Create an AFTER INSERT row trigger named trg_customer_master_index_insert on the CUSTOMER_MASTER_INDEX table. For each new row, insert a record into CMI_CROSS_REFERENCES using :NEW.MASTER_CUSTOMER_ID for CMI_CROSS_REF_ID and MASTER_CUSTOMER_ID, with SOURCE_SYSTEM_CODE as 'Customer'. Then, insert records into COUNCIL_TAX, PARKING_FINES, RENT_ARREARS, and BENEFITS_OVERPAYMENTS, populating each table's COUNCIL_TAX_ID and CMI_CROSS_REF_ID columns with :NEW.MASTER_CUSTOMER_ID.",
    "natural_language": "Create an AFTER INSERT row trigger called trg_customer_master_index_insert on the CUSTOMER_MASTER_INDEX table. For every new row, first insert a record into CMI_CROSS_REFERENCES, setting CMI_CROSS_REF_ID and MASTER_CUSTOMER_ID to :NEW.MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE to 'Customer'. Then, insert corresponding records into the COUNCIL_TAX, PARKING_FINES, RENT_ARREARS, and BENEFITS_OVERPAYMENTS tables, using :NEW.MASTER_CUSTOMER_ID for both the COUNCIL_TAX_ID and CMI_CROSS_REF_ID columns in each.",
    "id": 239
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_order_status that is defined to fire automatically after any update operation on the ORDER_STATUS_CODE column of the CUSTOMER_ORDERS table, executing once for each row that is modified; within the trigger body, a conditional IF-THEN-ELSE statement evaluates the newly updated value of the ORDER_STATUS_CODE column, referenced as :NEW.ORDER_STATUS_CODE, and if this value is exactly equal to the string literal 'Completed', it executes an UPDATE statement on the ORDER_ITEMS table, setting the PRODUCT_ID column to the numeric value 0 for every row in ORDER_ITEMS where the ORDER_ID column matches the new ORDER_ID value from the updated CUSTOMER_ORDERS row, referenced as :NEW.ORDER_ID; conversely, if the :NEW.ORDER_STATUS_CODE is not equal to 'Completed', the trigger executes a DELETE statement on the ORDER_ITEMS table, removing all rows where the ORDER_ID column equals :NEW.ORDER_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_order_status\nAFTER UPDATE OF ORDER_STATUS_CODE ON CUSTOMER_ORDERS\nFOR EACH ROW\nBEGIN\n    IF :NEW.ORDER_STATUS_CODE = 'Completed' THEN\n        UPDATE ORDER_ITEMS SET PRODUCT_ID = 0 WHERE ORDER_ID = :NEW.ORDER_ID;\n    ELSE\n        DELETE FROM ORDER_ITEMS WHERE ORDER_ID = :NEW.ORDER_ID;\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'Completed' WHERE ORDER_ID = 1",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'New' WHERE ORDER_ID = 2",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'PartFilled' WHERE ORDER_ID = 3",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'Completed' WHERE ORDER_ID = 4",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'New' WHERE ORDER_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE row trigger named trg_update_order_status on the CUSTOMER_ORDERS table that fires when ORDER_STATUS_CODE is updated. If :NEW.ORDER_STATUS_CODE equals 'Completed', update the ORDER_ITEMS table, setting PRODUCT_ID to 0 for all items matching :NEW.ORDER_ID. Otherwise, if the status is not 'Completed', delete all items from ORDER_ITEMS matching :NEW.ORDER_ID.",
    "natural_language": "Create trigger trg_update_order_status on CUSTOMER_ORDERS after update of ORDER_STATUS_CODE. If new status is 'Completed', set PRODUCT_ID to 0 in ORDER_ITEMS for that order. Otherwise, delete the order's items.",
    "id": 240
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_supplier_address` that is activated `AFTER` an `INSERT` operation occurs on the `SUPPLIERS` table. This trigger is configured to execute `FOR EACH ROW` that is inserted into the `SUPPLIERS` table, meaning its logic will be applied individually for every new supplier record. Upon activation, the trigger performs two distinct operations. First, it executes an `INSERT` statement into the `SUPPLIER_ADDRESSES` table. For this `INSERT` operation, the `SUPPLIER_ID` column is populated with the value from the `SUPPLIER_ID` column of the newly inserted row in the `SUPPLIERS` table, referenced as `:NEW.SUPPLIER_ID`. The `ADDRESS_ID` column is populated with a calculated value, specifically `100` plus the value from `:NEW.SUPPLIER_ID`. The `DATE_FROM` column is populated with the current system date and time, obtained using the `SYSDATE` function, which is then formatted into a character string using `TO_CHAR` with the format mask `'YYYY-MM-DD HH24:MI:SS'`, resulting in a string like '2023-10-27 14:35:01'. The `DATE_TO` column is explicitly set to `NULL`. Second, immediately after the `INSERT` operation, the trigger executes an `UPDATE` statement on the `PRODUCT_SUPPLIERS` table. This `UPDATE` statement modifies the `TOTAL_VALUE_PURCHASED` column by adding `1000` to its current value. This modification is applied only to those rows in the `PRODUCT_SUPPLIERS` table where the `SUPPLIER_ID` column matches the `SUPPLIER_ID` of the newly inserted row in the `SUPPLIERS` table, again referenced as `:NEW.SUPPLIER_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_supplier_address\nAFTER INSERT ON SUPPLIERS\nFOR EACH ROW\nBEGIN\n    INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO)\n    VALUES (:NEW.SUPPLIER_ID, 100 + :NEW.SUPPLIER_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL);\n    UPDATE PRODUCT_SUPPLIERS SET TOTAL_VALUE_PURCHASED = TOTAL_VALUE_PURCHASED + 1000 WHERE SUPPLIER_ID = :NEW.SUPPLIER_ID;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "INSERT INTO SUPPLIERS (SUPPLIER_ID, SUPPLIER_NAME, SUPPLIER_PHONE) VALUES (10, 'New Supplier Inc.', '555-123-4567')",
      "INSERT INTO SUPPLIERS (SUPPLIER_ID, SUPPLIER_NAME) VALUES (11, 'Quick Parts Co.')",
      "INSERT INTO SUPPLIERS (SUPPLIER_ID, SUPPLIER_NAME, SUPPLIER_PHONE) VALUES (12, 'Global Goods', '1-800-555-9999')",
      "INSERT INTO SUPPLIERS (SUPPLIER_ID, SUPPLIER_NAME) VALUES (13, 'Tech Supplies Ltd')",
      "INSERT INTO SUPPLIERS (SUPPLIER_ID, SUPPLIER_NAME, SUPPLIER_PHONE) VALUES (14, 'Office Depot', '333-444-5555')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_supplier_address on the SUPPLIERS table. For each new row, insert a record into SUPPLIER_ADDRESSES with SUPPLIER_ID from :NEW.SUPPLIER_ID, ADDRESS_ID as 100 + :NEW.SUPPLIER_ID, DATE_FROM as TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), and DATE_TO as NULL. Then, update the PRODUCT_SUPPLIERS table by adding 1000 to TOTAL_VALUE_PURCHASED where SUPPLIER_ID matches :NEW.SUPPLIER_ID.",
    "natural_language": "Alright, so we need a trigger called trg_insert_supplier_address that fires after a new row is added to the SUPPLIERS table. Every time a new supplier pops in, we gotta do a couple things. First, toss a new record into the SUPPLIER_ADDRESSES table. For that record, use the new supplier's ID, make the address ID by adding 100 to that supplier ID, set the DATE_FROM to the current date and time formatted nicely, and leave DATE_TO as null. Then, right after that, we also need to bump up the TOTAL_VALUE_PURCHASED by 1000 in the PRODUCT_SUPPLIERS table for any row that matches the new supplier's ID.",
    "id": 241
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_order_items` that is configured to execute `BEFORE` a `DELETE` operation is performed on the `CUSTOMER_ORDERS` table. This trigger is defined to fire `FOR EACH ROW` that is being deleted from the `CUSTOMER_ORDERS` table. Upon activation for each deleted row, the trigger performs two distinct `DELETE` operations. The first `DELETE` operation targets the `ORDER_ITEMS` table. It removes all rows from the `ORDER_ITEMS` table where the value in the `ORDER_ID` column of `ORDER_ITEMS` is equal to the value of the `ORDER_ID` column from the row currently being deleted from the `CUSTOMER_ORDERS` table (referenced as `:OLD.ORDER_ID`). The second `DELETE` operation targets the `PRODUCT_SUPPLIERS` table. It removes all rows from the `PRODUCT_SUPPLIERS` table where the value in the `PRODUCT_ID` column of `PRODUCT_SUPPLIERS` is found within the set of `PRODUCT_ID` values retrieved by a subquery. This subquery selects all `PRODUCT_ID` values from the `ORDER_ITEMS` table where the `ORDER_ID` column of `ORDER_ITEMS` is equal to the value of the `ORDER_ID` column from the row currently being deleted from the `CUSTOMER_ORDERS` table (referenced as `:OLD.ORDER_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_order_items\nBEFORE DELETE ON CUSTOMER_ORDERS\nFOR EACH ROW\nBEGIN\n    DELETE FROM ORDER_ITEMS WHERE ORDER_ID = :OLD.ORDER_ID;\n    DELETE FROM PRODUCT_SUPPLIERS WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM ORDER_ITEMS WHERE ORDER_ID = :OLD.ORDER_ID);\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "DELETE FROM CUSTOMER_ORDERS WHERE ORDER_ID = 1",
      "DELETE FROM CUSTOMER_ORDERS WHERE ORDER_ID = 2",
      "DELETE FROM CUSTOMER_ORDERS WHERE ORDER_ID = 3",
      "DELETE FROM CUSTOMER_ORDERS WHERE ORDER_ID = 9",
      "DELETE FROM CUSTOMER_ORDERS WHERE ORDER_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_delete_order_items on the CUSTOMER_ORDERS table. For each deleted row, first delete from ORDER_ITEMS where ORDER_ID equals :OLD.ORDER_ID. Then, delete from PRODUCT_SUPPLIERS where PRODUCT_ID is in the set of PRODUCT_IDs from ORDER_ITEMS for the same :OLD.ORDER_ID.",
    "natural_language": "Construct a BEFORE DELETE FOR EACH ROW trigger, which should be named trg_delete_order_items, on the CUSTOMER_ORDERS table. For every single row that is being deleted, the trigger must first meticulously delete all corresponding entries from the ORDER_ITEMS table where the ORDER_ID matches the :OLD.ORDER_ID value. Subsequently, it must proceed to carefully delete records from the PRODUCT_SUPPLIERS table, specifically those where the PRODUCT_ID is found within the comprehensive set of PRODUCT_IDs that were associated with the ORDER_ITEMS entries for that very same :OLD.ORDER_ID.",
    "id": 242
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_supplier_phone` that is activated `AFTER` an `UPDATE` operation on the `SUPPLIERS` table, specifically when the `SUPPLIER_PHONE` column is modified. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is updated in the `SUPPLIERS` table. Upon activation, the trigger performs two distinct operations. First, it executes an `UPDATE` statement on the `SUPPLIER_ADDRESSES` table. This `UPDATE` statement sets the `DATE_TO` column to a character string representing the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (which returns the current date and time) into a character string formatted as 'YYYY-MM-DD HH24:MI:SS' (e.g., '2023-10-27 14:35:01'). This update is applied to rows in `SUPPLIER_ADDRESSES` where the `SUPPLIER_ID` column matches the `SUPPLIER_ID` of the row that was just updated in the `SUPPLIERS` table. The `:NEW.SUPPLIER_ID` pseudo-record variable provides access to the `SUPPLIER_ID` value of the row *after* the update operation on the `SUPPLIERS` table. Second, immediately after the update, the trigger executes an `INSERT` statement into the `SUPPLIER_ADDRESSES` table. This `INSERT` statement adds a new row with four column values. The `SUPPLIER_ID` column is populated with the `SUPPLIER_ID` of the newly updated supplier, again accessed via `:NEW.SUPPLIER_ID`. The `ADDRESS_ID` column is populated with a calculated value, which is `200` plus the `SUPPLIER_ID` of the updated supplier (`200 + :NEW.SUPPLIER_ID`). The `DATE_FROM` column is populated with a character string representing the current system date and time, formatted using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, similar to the `DATE_TO` column in the preceding `UPDATE` statement. Finally, the `DATE_TO` column for this newly inserted row is explicitly set to `NULL`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_supplier_phone\nAFTER UPDATE OF SUPPLIER_PHONE ON SUPPLIERS\nFOR EACH ROW\nBEGIN\n    UPDATE SUPPLIER_ADDRESSES SET DATE_TO = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') WHERE SUPPLIER_ID = :NEW.SUPPLIER_ID;\n    INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO)\n    VALUES (:NEW.SUPPLIER_ID, 200 + :NEW.SUPPLIER_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL);\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '1-800-555-0101' WHERE SUPPLIER_ID = 2",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '555-1234' WHERE SUPPLIER_ID = 3",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '1-432-960-9999' WHERE SUPPLIER_ID = 4",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '287-071-0000', SUPPLIER_NAME = 'Tesco Updated' WHERE SUPPLIER_ID = 3",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = 'NEW-PHONE-123' WHERE SUPPLIER_NAME = 'AB Store'"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_supplier_phone on the SUPPLIERS table, firing when SUPPLIER_PHONE is updated. For each updated row, first update SUPPLIER_ADDRESSES to set DATE_TO to TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') where SUPPLIER_ID equals :NEW.SUPPLIER_ID. Then, insert a new row into SUPPLIER_ADDRESSES with SUPPLIER_ID from :NEW.SUPPLIER_ID, ADDRESS_ID as 200 + :NEW.SUPPLIER_ID, DATE_FROM as TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), and DATE_TO as NULL.",
    "natural_language": "Construct an AFTER UPDATE FOR EACH ROW trigger, which should be named trg_update_supplier_phone, on the SUPPLIERS table; this trigger must be configured to fire specifically and exclusively whenever the SUPPLIER_PHONE column is updated. For every single row that is updated, the trigger must first meticulously update the SUPPLIER_ADDRESSES table, setting the DATE_TO column to the precisely formatted current system timestamp using TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), but only for those records where the SUPPLIER_ID matches the new :NEW.SUPPLIER_ID value from the triggering update. Subsequently and importantly, it must then proceed to insert a brand new row into the SUPPLIER_ADDRESSES table, carefully populating it with the following values: the SUPPLIER_ID should be taken directly from :NEW.SUPPLIER_ID, the ADDRESS_ID should be calculated as 200 plus the :NEW.SUPPLIER_ID, the DATE_FROM should be set to the same current system timestamp formatted as 'YYYY-MM-DD HH24:MI:SS', and finally, the DATE_TO column should be explicitly set to NULL.",
    "id": 243
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_order_date that is defined to execute before any insert operation on the CUSTOMER_ORDERS table for each individual row being inserted, and within its logic it first evaluates a condition using an IF statement that compares the result of converting the string value from the new row's ORDER_DATE column using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS' to the current system date and time (SYSDATE); if the converted ORDER_DATE is earlier than SYSDATE, then it performs a DELETE operation on the ORDER_ITEMS table where the ORDER_ID column in ORDER_ITEMS matches the new row's ORDER_ID value from the CUSTOMER_ORDERS table; otherwise, if the converted ORDER_DATE is not earlier than SYSDATE, it performs an INSERT operation into the ORDER_ITEMS table, specifying values for the columns ORDER_ITEM_ID, ORDER_ID, and PRODUCT_ID, where ORDER_ITEM_ID is calculated as the sum of 1000 and the new row's ORDER_ID value, ORDER_ID is set to the new row's ORDER_ID value, and PRODUCT_ID is set to the constant integer 999.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_order_date\nBEFORE INSERT ON CUSTOMER_ORDERS\nFOR EACH ROW\nBEGIN\n    IF TO_DATE(:NEW.ORDER_DATE, 'YYYY-MM-DD HH24:MI:SS') < SYSDATE THEN\n        DELETE FROM ORDER_ITEMS WHERE ORDER_ID = :NEW.ORDER_ID;\n    ELSE\n        INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (1000 + :NEW.ORDER_ID, :NEW.ORDER_ID, 999);\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_STATUS_CODE, ORDER_DATE) VALUES (1, 12, 'New', '2018-02-10 15:44:48')",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_STATUS_CODE, ORDER_DATE) VALUES (2, 4, 'Completed', TO_CHAR(SYSDATE + 1, 'YYYY-MM-DD HH24:MI:SS'))",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_STATUS_CODE, ORDER_DATE) VALUES (3, 1, 'PartFilled', TO_CHAR(SYSDATE - 5, 'YYYY-MM-DD HH24:MI:SS'))",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_STATUS_CODE, ORDER_DATE) VALUES (4, 12, 'New', TO_CHAR(SYSDATE + 10, 'YYYY-MM-DD HH24:MI:SS'))",
      "INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_STATUS_CODE, ORDER_DATE) VALUES (5, 4, 'Completed', '2018-01-31 17:49:18')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_check_order_date on the CUSTOMER_ORDERS table. For each new row, check if TO_DATE(:NEW.ORDER_DATE, 'YYYY-MM-DD HH24:MI:SS') is earlier than SYSDATE. If true, delete from ORDER_ITEMS where ORDER_ID equals :NEW.ORDER_ID. If false, insert into ORDER_ITEMS values (1000 + :NEW.ORDER_ID, :NEW.ORDER_ID, 999).",
    "natural_language": "Make a BEFORE INSERT FOR EACH ROW trigger called trg_check_order_date on CUSTOMER_ORDERS. If the new ORDER_DATE is before SYSDATE, delete matching rows from ORDER_ITEMS. Otherwise, insert a row into ORDER_ITEMS with values (1000 + ORDER_ID, ORDER_ID, 999).",
    "id": 244
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_box_value that fires before each row is inserted into the BOXES table, declaring a local variable v_max_value of type NUMBER, then for the new row being inserted, it queries the WAREHOUSES table to select the value of the expression GREATEST(200, CAPACITY * 100) for the row where the CODE column equals the new row's WAREHOUSE column value, storing the result into v_max_value, and then performs a conditional check: if the new row's VALUE column is greater than the calculated v_max_value, it modifies the new row's VALUE column by setting it to the value of v_max_value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_box_value\nBEFORE INSERT ON BOXES\nFOR EACH ROW\nDECLARE\n    v_max_value NUMBER;\nBEGIN\n    SELECT GREATEST(200, CAPACITY * 100) INTO v_max_value FROM WAREHOUSES WHERE CODE = :NEW.WAREHOUSE;\n    IF :NEW.VALUE > v_max_value THEN\n        :NEW.VALUE := v_max_value;\n    END IF;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('TEST1', 'Books', 500, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('TEST2', 'Electronics', 1000, 3)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('TEST3', 'Clothes', 150, 2)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('TEST4', 'Tools', 800, 4)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('TEST5', 'Toys', 300, 1)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_validate_box_value on the BOXES table. Declare a local variable v_max_value. For the new row, select GREATEST(200, CAPACITY * 100) into v_max_value from WAREHOUSES where CODE equals :NEW.WAREHOUSE. If :NEW.VALUE is greater than v_max_value, set :NEW.VALUE to v_max_value.",
    "natural_language": "Please construct a BEFORE INSERT FOR EACH ROW trigger designated as trg_validate_box_value for the BOXES table. It is required to declare a local variable named v_max_value. For each new row, one must assign to v_max_value the result of the GREATEST(200, CAPACITY * 100) expression, obtained from the WAREHOUSES table where the CODE matches the :NEW.WAREHOUSE value. Should the :NEW.VALUE exceed the calculated v_max_value, it is necessary to adjust :NEW.VALUE to equal v_max_value.",
    "id": 245
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_adjust_capacity_on_delete that is defined to execute automatically after a row is deleted from the WAREHOUSES table, operating for each affected row, and within its body, it performs a delete operation on the BOXES table where the WAREHOUSE column value matches the CODE column value from the deleted WAREHOUSES row, which is accessed via the :OLD.CODE pseudorecord qualifier, and the trigger's logic originally contained an additional insert operation that was commented out, which attempted to insert a new row into the WAREHOUSES table using values derived from the deleted row, specifically adding 100 to the old CODE, and using the old LOCATION and CAPACITY values, but this insert statement was removed to prevent a mutating table error.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_capacity_on_delete\nAFTER DELETE ON WAREHOUSES\nFOR EACH ROW\nBEGIN\n    -- This DELETE statement is fine as it operates on a different table (BOXES).\n    DELETE FROM BOXES WHERE WAREHOUSE = :OLD.CODE;\n    -- The following INSERT statement caused the ORA-04091 mutating table error\n    -- because it attempts to modify the WAREHOUSES table (the triggering table)\n    -- within a row-level trigger on WAREHOUSES.\n    -- INSERT INTO WAREHOUSES (CODE, LOCATION, CAPACITY) VALUES (:OLD.CODE + 100, :OLD.LOCATION, :OLD.CAPACITY);\n    -- Removed the problematic INSERT statement to resolve the mutating table error.\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DELETE FROM WAREHOUSES WHERE CODE = 1",
      "DELETE FROM WAREHOUSES WHERE CODE = 3",
      "DELETE FROM WAREHOUSES WHERE CODE = 2",
      "DELETE FROM WAREHOUSES WHERE CODE = 4",
      "DELETE FROM WAREHOUSES WHERE CODE = 5"
    ],
    "summary": "Create an AFTER DELETE trigger named trg_adjust_capacity_on_delete on the WAREHOUSES table. For each deleted row, delete rows from the BOXES table where the WAREHOUSE column equals the deleted row's :OLD.CODE value.",
    "natural_language": "Please implement an AFTER DELETE trigger designated as trg_adjust_capacity_on_delete on the WAREHOUSES table. This trigger shall, for each row that is deleted, proceed to delete corresponding rows from the BOXES table where the value in the WAREHOUSE column matches the :OLD.CODE value from the deleted row.",
    "id": 246
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_location_update that fires before any row is updated on the WAREHOUSES table, and within its execution block, it checks a conditional statement: if the new value for the LOCATION column in the WAREHOUSES table, referenced as :NEW.LOCATION, is not equal to the old value of the LOCATION column, referenced as :OLD.LOCATION, then it executes an UPDATE operation on the BOXES table, setting the CONTENTS column for all rows in BOXES where the WAREHOUSE column matches the new value of the CODE column from the WAREHOUSES table, referenced as :NEW.CODE, to the result of the GREATEST function, which compares the existing CONTENTS value with the new :NEW.LOCATION value and returns the larger of the two.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_location_update\nBEFORE UPDATE ON WAREHOUSES\nFOR EACH ROW\nBEGIN\n    IF :NEW.LOCATION != :OLD.LOCATION THEN\n        UPDATE BOXES SET CONTENTS = GREATEST(CONTENTS, :NEW.LOCATION) WHERE WAREHOUSE = :NEW.CODE;\n    END IF;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "UPDATE WAREHOUSES SET LOCATION = 'Los Angeles' WHERE CODE = 1",
      "UPDATE WAREHOUSES SET LOCATION = 'Miami', CAPACITY = 5 WHERE CODE = 3",
      "UPDATE WAREHOUSES SET LOCATION = 'Chicago' WHERE CODE = 2",
      "UPDATE WAREHOUSES SET LOCATION = 'Seattle' WHERE CODE = 4",
      "UPDATE WAREHOUSES SET LOCATION = 'Boston' WHERE CODE = (SELECT CODE FROM WAREHOUSES WHERE ROWNUM = 1)"
    ],
    "summary": "Create a BEFORE UPDATE trigger named trg_sync_location_update on the WAREHOUSES table. For each row, if the :NEW.LOCATION differs from :OLD.LOCATION, update the BOXES table. Set the CONTENTS column to the result of GREATEST(CONTENTS, :NEW.LOCATION) for rows where the WAREHOUSE column equals :NEW.CODE.",
    "natural_language": "Before updating a row in the WAREHOUSES table, if the LOCATION is being changed, how should the BOXES table be synchronized? Specifically, for rows in BOXES where the WAREHOUSE matches the updated warehouse's CODE, how do you set the CONTENTS to the greater value between its current CONTENTS and the new LOCATION?",
    "id": 247
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CTAX_CMI_INS that activates after an insert operation on the COUNCIL_TAX table for each row affected by the insert. The trigger declares two local variables: v_master_customer_id of type NUMBER and v_cmi_details of type VARCHAR2(255). It then performs a SELECT operation to retrieve the MASTER_CUSTOMER_ID and the uppercase version of CMI_DETAILS from the CMI_CROSS_REFERENCES and CUSTOMER_MASTER_INDEX tables, respectively. The SELECT statement uses a JOIN condition where the MASTER_CUSTOMER_ID from CMI_CROSS_REFERENCES matches the MASTER_CUSTOMER_ID from CUSTOMER_MASTER_INDEX. The WHERE clause filters the results based on the CMI_CROSS_REF_ID column from the CMI_CROSS_REFERENCES table, which must equal the CMI_CROSS_REF_ID value from the newly inserted row in the COUNCIL_TAX table, referenced as :NEW.CMI_CROSS_REF_ID. The retrieved values are stored into the local variables v_master_customer_id and v_cmi_details. The UPPER() function is applied to the CMI_DETAILS column to convert its value to uppercase before storing it in v_cmi_details.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CTAX_CMI_INS\nAFTER INSERT ON COUNCIL_TAX\nFOR EACH ROW\nDECLARE\n    v_master_customer_id NUMBER;\n    v_cmi_details VARCHAR2(255);\nBEGIN\n    SELECT c.MASTER_CUSTOMER_ID, UPPER(cmi.CMI_DETAILS)\n    INTO v_master_customer_id, v_cmi_details\n    FROM CMI_CROSS_REFERENCES c\n    JOIN CUSTOMER_MASTER_INDEX cmi ON c.MASTER_CUSTOMER_ID = cmi.MASTER_CUSTOMER_ID\n    WHERE c.CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (4, 101)",
      "INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (5, 103)",
      "INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (6, 104)",
      "INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (7, 101)",
      "INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (8, 103)"
    ],
    "summary": "Create an AFTER INSERT trigger named TRG_CTAX_CMI_INS on the COUNCIL_TAX table. For each inserted row, select the MASTER_CUSTOMER_ID and the uppercase CMI_DETAILS from joined CMI_CROSS_REFERENCES and CUSTOMER_MASTER_INDEX tables where CMI_CROSS_REF_ID equals :NEW.CMI_CROSS_REF_ID. Store the results into local variables v_master_customer_id and v_cmi_details.",
    "natural_language": "Create AFTER INSERT trigger TRG_CTAX_CMI_INS on COUNCIL_TAX. For each new row, get MASTER_CUSTOMER_ID and uppercase CMI_DETAILS from joined CMI_CROSS_REFERENCES and CUSTOMER_MASTER_INDEX where CMI_CROSS_REF_ID matches :NEW.CMI_CROSS_REF_ID. Store in v_master_customer_id and v_cmi_details.",
    "id": 248
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CMI_REF_DEL that is defined to execute BEFORE a DELETE operation on the CMI_CROSS_REFERENCES table for each affected row, and within this trigger, first declare three local NUMBER variables named v_benefits_count, v_council_tax_count, and v_rent_arrears_count, then perform a SELECT COUNT(*) query from the BENEFITS_OVERPAYMENTS table into the v_benefits_count variable where the CMI_CROSS_REF_ID column in BENEFITS_OVERPAYMENTS equals the OLD.CMI_CROSS_REF_ID value from the row being deleted from CMI_CROSS_REFERENCES, then perform a second SELECT COUNT(*) query from the COUNCIL_TAX table into the v_council_tax_count variable where the CMI_CROSS_REF_ID column in COUNCIL_TAX equals the OLD.CMI_CROSS_REF_ID value, then perform a third SELECT COUNT(*) query from the RENT_ARREARS table into the v_rent_arrears_count variable where the CMI_CROSS_REF_ID column in RENT_ARREARS equals the OLD.CMI_CROSS_REF_ID value, then execute a DELETE statement on the BENEFITS_OVERPAYMENTS table where the CMI_CROSS_REF_ID column equals the OLD.CMI_CROSS_REF_ID value and the condition v_benefits_count > 0 is true, then execute a DELETE statement on the COUNCIL_TAX table where the CMI_CROSS_REF_ID column equals the OLD.CMI_CROSS_REF_ID value and the condition v_council_tax_count > 0 is true, and finally execute a DELETE statement on the RENT_ARREARS table where the CMI_CROSS_REF_ID column equals the OLD.CMI_CROSS_REF_ID value and the condition v_rent_arrears_count > 0 is true.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CMI_REF_DEL\nBEFORE DELETE ON CMI_CROSS_REFERENCES\nFOR EACH ROW\nDECLARE\n    v_benefits_count NUMBER;\n    v_council_tax_count NUMBER;\n    v_rent_arrears_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_benefits_count\n    FROM BENEFITS_OVERPAYMENTS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n\n    SELECT COUNT(*)\n    INTO v_council_tax_count\n    FROM COUNCIL_TAX\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n\n    SELECT COUNT(*)\n    INTO v_rent_arrears_count\n    FROM RENT_ARREARS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n\n    DELETE FROM BENEFITS_OVERPAYMENTS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID\n    AND v_benefits_count > 0;\n\n    DELETE FROM COUNCIL_TAX\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID\n    AND v_council_tax_count > 0;\n\n    DELETE FROM RENT_ARREARS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID\n    AND v_rent_arrears_count > 0;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 2",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 65",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 41",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 83",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 100"
    ],
    "summary": "Create a BEFORE DELETE trigger named TRG_CMI_REF_DEL on the CMI_CROSS_REFERENCES table. For each row, count related records in BENEFITS_OVERPAYMENTS, COUNCIL_TAX, and RENT_ARREARS tables using :OLD.CMI_CROSS_REF_ID. Store counts in variables. Then, conditionally delete from each of those three tables where CMI_CROSS_REF_ID equals :OLD.CMI_CROSS_REF_ID, but only if its corresponding count variable is greater than 0.",
    "natural_language": "Alright, so we need a trigger called TRG_CMI_REF_DEL that fires before a row gets deleted from the CMI_CROSS_REFERENCES table. For each old row, we gotta check how many related records there are in the BENEFITS_OVERPAYMENTS, COUNCIL_TAX, and RENT_ARREARS tables using the old row's CMI_CROSS_REF_ID. We'll stash those counts in some variables. Then, only if a count for a specific table is more than zero, we go ahead and delete the matching records from that table where the CMI_CROSS_REF_ID matches the old one.",
    "id": 249
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_del_coaster_update_pop` that is activated `AFTER` a `DELETE` operation occurs on the `ROLLER_COASTER` table. This trigger is defined to execute `FOR EACH ROW` that is deleted from the `ROLLER_COASTER` table. Upon activation for each deleted row, the trigger performs a sequence of three operations. First, it executes an `UPDATE` statement on the `COUNTRY` table. This `UPDATE` statement modifies the `POPULATION` column by subtracting `1000` from its current value for all rows where the `COUNTRY_ID` column matches the `COUNTRY_ID` value of the row that was just deleted from the `ROLLER_COASTER` table. The `COUNTRY_ID` of the deleted row is accessed using the `:OLD.COUNTRY_ID` pseudorecord variable. Second, immediately after the update, the trigger executes a `DELETE` statement on the `COUNTRY` table. This `DELETE` statement removes all rows from the `COUNTRY` table where the `POPULATION` column has a value `less than` `0`. Third, following the conditional deletion, the trigger executes an `INSERT` statement into the `COUNTRY` table. This `INSERT` statement adds a new row with specific values for five columns: `COUNTRY_ID`, `NAME`, `POPULATION`, `AREA`, and `LANGUAGES`. The value for `COUNTRY_ID` is determined by a subquery that selects the `MAX`imum `COUNTRY_ID` currently existing in the `COUNTRY` table and adds `1` to it, ensuring a unique and incremented identifier. The `NAME` column is set to the literal string `'Compensated'`. The `POPULATION` column is set to the numeric literal `5000`. The `AREA` column is set to the numeric literal `1000`. The `LANGUAGES` column is set to the literal string `'English'`. This `INSERT` operation is performed unconditionally after the previous `UPDATE` and `DELETE` operations within the trigger's execution for each deleted `ROLLER_COASTER` row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_del_coaster_update_pop\nAFTER DELETE ON ROLLER_COASTER\nFOR EACH ROW\nBEGIN\n    UPDATE COUNTRY SET POPULATION = POPULATION - 1000 WHERE COUNTRY_ID = :OLD.COUNTRY_ID;\n    DELETE FROM COUNTRY WHERE POPULATION < 0;\n    INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) SELECT MAX(COUNTRY_ID) + 1, 'Compensated', 5000, 1000, 'English' FROM COUNTRY;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "DELETE FROM ROLLER_COASTER WHERE ROLLER_COASTER_ID = 1",
      "DELETE FROM ROLLER_COASTER WHERE ROLLER_COASTER_ID = 2",
      "DELETE FROM ROLLER_COASTER WHERE ROLLER_COASTER_ID = 3",
      "DELETE FROM ROLLER_COASTER WHERE NAME = 'Boardwalk Bullet'",
      "DELETE FROM ROLLER_COASTER WHERE PARK = 'Kemah Boardwalk'"
    ],
    "summary": "Create an AFTER DELETE trigger named trg_del_coaster_update_pop on the ROLLER_COASTER table. For each deleted row, first update the COUNTRY table by subtracting 1000 from POPULATION where COUNTRY_ID equals :OLD.COUNTRY_ID. Then, delete any rows from COUNTRY where POPULATION is less than 0. Finally, insert a new row into COUNTRY. The new row's COUNTRY_ID is the maximum existing COUNTRY_ID plus 1, NAME is 'Compensated', POPULATION is 5000, AREA is 1000, and LANGUAGES is 'English'.",
    "natural_language": "Alright, so we need a trigger that fires after a row gets deleted from the ROLLER_COASTER table. Call it 'trg_del_coaster_update_pop'. Every time you delete a coaster, first go to the COUNTRY table and knock 1000 off the POPULATION for the country that matches the old coaster's COUNTRY_ID. Then, if any country ends up with a population below zero, just get rid of it. Finally, add a brand new country entry. For this new country, make its ID one more than the highest ID already there, set its NAME to 'Compensated', give it a POPULATION of 5000, an AREA of 1000, and list its LANGUAGES as 'English'.",
    "id": 250
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_upd_coaster_length_agg` that is activated `AFTER` an `UPDATE` operation on the `LENGTH` column of the `ROLLER_COASTER` table. This trigger declares two local numeric variables: `v_avg_length` to store the calculated average length and `v_max_length` to store the calculated maximum length. Upon activation, the trigger first executes a `SELECT` statement to calculate the average of all values in the `LENGTH` column from the `ROLLER_COASTER` table and stores this result into the `v_avg_length` variable. Concurrently, it calculates the maximum value among all entries in the `LENGTH` column from the `ROLLER_COASTER` table and stores this result into the `v_max_length` variable. Following this, the trigger performs an `INSERT` operation into the `COUNTRY` table. This `INSERT` operation creates a new row with a `COUNTRY_ID` of `999`, a `NAME` of `'Stats'`, a `POPULATION` value equal to the `v_avg_length` variable, an `AREA` value equal to the `v_max_length` variable, and `LANGUAGES` set to `'Data'`. Finally, the trigger executes a `DELETE` statement on the `COUNTRY` table, removing any rows where the `COUNTRY_ID` is `999` and the `POPULATION` column has a value less than `1000`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_upd_coaster_length_agg\nAFTER UPDATE OF LENGTH ON ROLLER_COASTER\nDECLARE\n    v_avg_length NUMBER;\n    v_max_length NUMBER;\nBEGIN\n    SELECT AVG(LENGTH), MAX(LENGTH) INTO v_avg_length, v_max_length FROM ROLLER_COASTER;\n    INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (999, 'Stats', v_avg_length, v_max_length, 'Data');\n    DELETE FROM COUNTRY WHERE COUNTRY_ID = 999 AND POPULATION < 1000;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "UPDATE ROLLER_COASTER SET LENGTH = 3300 WHERE ROLLER_COASTER_ID = 1",
      "UPDATE ROLLER_COASTER SET LENGTH = 4000 WHERE ROLLER_COASTER_ID = 2",
      "UPDATE ROLLER_COASTER SET LENGTH = 4800 WHERE ROLLER_COASTER_ID = 3",
      "UPDATE ROLLER_COASTER SET LENGTH = 3500 WHERE ROLLER_COASTER_ID = 1",
      "UPDATE ROLLER_COASTER SET LENGTH = 4100 WHERE ROLLER_COASTER_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE trigger on the ROLLER_COASTER table's LENGTH column named trg_upd_coaster_length_agg. It calculates the average and maximum LENGTH, stores them in variables, inserts a row into the COUNTRY table with ID 999, 'Stats' name, and the calculated values for POPULATION and AREA, then deletes rows from COUNTRY where ID is 999 and POPULATION is less than 1000.",
    "natural_language": "Alright, so we need a trigger that fires after someone updates the LENGTH column in the ROLLER_COASTER table. Let's call it 'trg_upd_coaster_length_agg'. What it's gotta do is figure out the average and max LENGTH and stash those numbers in some variables. Then, it pops a new row into the COUNTRY tableuse ID 999, name it 'Stats', and plug those calculated numbers into POPULATION and AREA. Oh, and after that, clean up by wiping out any rows from COUNTRY where the ID is 999 and the POPULATION's under 1000.",
    "id": 251
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_upd_country_coaster_clean that is executed after an update operation on the COUNTRY table for each row affected by the update. The trigger performs the following operations: it deletes rows from the ROLLER_COASTER table where the COUNTRY_ID column matches the old COUNTRY_ID value from the updated COUNTRY table row and the HEIGHT column is less than 50. It then inserts a new row into the ROLLER_COASTER table with the following values: ROLLER_COASTER_ID set to 9999, NAME set to 'Default', PARK set to 'Unknown', COUNTRY_ID set to the new COUNTRY_ID value from the updated COUNTRY table row, LENGTH set to 1000, HEIGHT set to 60, SPEED set to '30', OPENED set to '2000', and STATUS set to 'Closed'. Finally, the trigger updates the ROLLER_COASTER table by increasing the LENGTH column by 100 for all rows where the COUNTRY_ID matches the new COUNTRY_ID value from the updated COUNTRY table row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_upd_country_coaster_clean\nAFTER UPDATE ON COUNTRY\nFOR EACH ROW\nBEGIN\n    DELETE FROM ROLLER_COASTER WHERE COUNTRY_ID = :OLD.COUNTRY_ID AND HEIGHT < 50;\n    INSERT INTO ROLLER_COASTER (ROLLER_COASTER_ID, NAME, PARK, COUNTRY_ID, LENGTH, HEIGHT, SPEED, OPENED, STATUS) VALUES (9999, 'Default', 'Unknown', :NEW.COUNTRY_ID, 1000, 60, '30', '2000', 'Closed');\n    UPDATE ROLLER_COASTER SET LENGTH = LENGTH + 100 WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "UPDATE COUNTRY SET POPULATION = 8300000 WHERE COUNTRY_ID = 1",
      "UPDATE COUNTRY SET AREA = 84000 WHERE COUNTRY_ID = 2",
      "UPDATE COUNTRY SET NAME = 'Austria Updated' WHERE COUNTRY_ID = 1",
      "UPDATE COUNTRY SET LANGUAGES = 'German, English' WHERE COUNTRY_ID = 3",
      "UPDATE COUNTRY SET POPULATION = POPULATION + 100000 WHERE COUNTRY_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger on the COUNTRY table named trg_upd_country_coaster_clean. It deletes from ROLLER_COASTER where COUNTRY_ID matches the old value and HEIGHT < 50, inserts a new default coaster row with the new COUNTRY_ID, and updates all coasters with the new COUNTRY_ID by increasing their LENGTH by 100.",
    "natural_language": "Set up a trigger on the COUNTRY table that fires after updates, called trg_upd_country_coaster_clean. It should handle cleaning up some of the smaller roller coasters in the old country, add a basic new coaster entry for the updated country, and generally give a decent boost to the length of the other coasters now associated with the new country ID.",
    "id": 252
  },
  {
    "ir": "Write a PL/SQL package named `book_title_pkg` that declares a global package-level numeric variable named `g_total_readers`, initialized to `0`. This package variable is intended to store a running total of readers. Additionally, define two database triggers. The first trigger, named `trg_before_statement`, is a `BEFORE STATEMENT` level trigger that fires before any `INSERT` or `DELETE` operation on the `REVIEW` table. When this trigger fires, it executes a `SELECT` statement to calculate the sum of all `READERS_IN_MILLION` values from the `REVIEW` table. If the sum is `NULL` (meaning there are no rows or all `READERS_IN_MILLION` values are `NULL`), it defaults to `0` using the `NVL` function. This calculated sum is then assigned to the `book_title_pkg.g_total_readers` package variable, effectively initializing or re-initializing the running total of readers before the DML statement begins processing individual rows. The second trigger, named `trg_update_book_title`, is an `AFTER ROW` level trigger that fires after each `INSERT` or `DELETE` operation on the `REVIEW` table. Inside this trigger, two local variables are declared: `v_book_id` of type `NUMBER` and `v_current_total` of type `NUMBER`. The trigger first checks the type of DML operation that occurred. If the operation is an `INSERT` (checked by `IF INSERTING THEN`), it adds the `READERS_IN_MILLION` value from the newly inserted row (`:NEW.READERS_IN_MILLION`) to the `book_title_pkg.g_total_readers` package variable. If `:NEW.READERS_IN_MILLION` is `NULL`, it defaults to `0` using the `NVL` function. The `BOOK_ID` from the newly inserted row (`:NEW.BOOK_ID`) is assigned to `v_book_id`. If the operation is a `DELETE` (checked by `ELSIF DELETING THEN`), it subtracts the `READERS_IN_MILLION` value from the deleted row (`:OLD.READERS_IN_MILLION`) from the `book_title_pkg.g_total_readers` package variable. If `:OLD.READERS_IN_MILLION` is `NULL`, it defaults to `0` using the `NVL` function. The `BOOK_ID` from the deleted row (`:OLD.BOOK_ID`) is assigned to `v_book_id`. If neither `INSERTING` nor `DELETING` conditions are met (which should not occur for this trigger definition), `v_book_id` is set to `NULL`. After updating the `book_title_pkg.g_total_readers` based on the DML operation, the current value of `book_title_pkg.g_total_readers` is assigned to the local variable `v_current_total`. Subsequently, a conditional check is performed to ensure `v_book_id` is not `NULL`. If `v_book_id` has a valid value, another conditional check evaluates `v_current_total`. If `v_current_total` is greater than `10`, an `UPDATE` statement is executed on the `BOOK` table, setting the `TITLE` column to the concatenated string `'Popular Book '` followed by the value of `v_book_id`, for the row where `BOOK_ID` matches `v_book_id`. Otherwise (if `v_current_total` is not greater than `10`), an `UPDATE` statement is executed on the `BOOK` table, setting the `TITLE` column to the concatenated string `'Regular Book '` followed by the value of `v_book_id`, for the row where `BOOK_ID` matches `v_book_id`.",
    "plsql": "CREATE OR REPLACE PACKAGE book_title_pkg IS\n  g_total_readers NUMBER := 0;\nEND book_title_pkg;\n/\n\nCREATE OR REPLACE TRIGGER trg_before_statement\nBEFORE INSERT OR DELETE ON REVIEW\nBEGIN\n  -- Initialize total readers before statement execution\n  SELECT NVL(SUM(READERS_IN_MILLION), 0) \n    INTO book_title_pkg.g_total_readers \n    FROM REVIEW;\nEND;\n/\n\nCREATE OR REPLACE TRIGGER trg_update_book_title\nAFTER INSERT OR DELETE ON REVIEW\nFOR EACH ROW\nDECLARE\n  v_book_id NUMBER;\n  v_current_total NUMBER;\nBEGIN\n  -- Update the running total based on the operation\n  IF INSERTING THEN\n    book_title_pkg.g_total_readers := book_title_pkg.g_total_readers + NVL(:NEW.READERS_IN_MILLION, 0);\n    v_book_id := :NEW.BOOK_ID;\n  ELSIF DELETING THEN\n    book_title_pkg.g_total_readers := book_title_pkg.g_total_readers - NVL(:OLD.READERS_IN_MILLION, 0);\n    v_book_id := :OLD.BOOK_ID;\n  ELSE\n    v_book_id := NULL;\n  END IF;\n  \n  -- Use the updated total from the package variable\n  v_current_total := book_title_pkg.g_total_readers;\n  \n  -- Only update if we have a valid BOOK_ID\n  IF v_book_id IS NOT NULL THEN\n    IF v_current_total > 10 THEN\n      UPDATE BOOK SET TITLE = 'Popular Book ' || v_book_id WHERE BOOK_ID = v_book_id;\n    ELSE\n      UPDATE BOOK SET TITLE = 'Regular Book ' || v_book_id WHERE BOOK_ID = v_book_id;\n    END IF;\n  END IF;\nEND;\n/",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (4, 1, 7.0, 4.0, 15)",
      "DELETE FROM REVIEW WHERE REVIEW_ID = 1",
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (5, 2, 6.5, 3.5, 20)",
      "DELETE FROM REVIEW WHERE REVIEW_ID = 2",
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (6, 3, 6.0, 2.0, 18)"
    ],
    "summary": "Create a package named book_title_pkg with a global variable g_total_readers initialized to 0. Create two triggers on the REVIEW table: a BEFORE STATEMENT trigger for INSERT/DELETE that initializes g_total_readers to the sum of READERS_IN_MILLION, and an AFTER ROW trigger for INSERT/DELETE that updates g_total_readers based on the row's value, then updates the corresponding BOOK's TITLE to 'Popular Book [ID]' if the total exceeds 10, otherwise to 'Regular Book [ID]'.",
    "natural_language": "How can I create a package called book_title_pkg that includes a global variable g_total_readers set to 0, and then set up two triggers on the REVIEW table: one BEFORE STATEMENT trigger for INSERT and DELETE operations to initialize g_total_readers to the sum of READERS_IN_MILLION, and an AFTER ROW trigger for INSERT and DELETE that adjusts g_total_readers based on each row's value and subsequently updates the corresponding BOOK's TITLE to 'Popular Book [ID]' if the total surpasses 10, or to 'Regular Book [ID]' otherwise?",
    "id": 253
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_adjust_book_rank` that is activated automatically after an `UPDATE` operation occurs on the `RATING` column of the `REVIEW` table. This trigger does not accept any explicit parameters. Internally, it declares a local variable `v_avg_rating` of type `BINARY_DOUBLE` to store the calculated average rating for a book. It also defines a cursor named `book_cursor` which, when opened, will select distinct `BOOK_ID` values from the `REVIEW` table. The trigger's execution logic begins by iterating through each unique `BOOK_ID` retrieved by the `book_cursor`. For each `book_rec` (representing a record from the `book_cursor` containing a `BOOK_ID`), the trigger performs a `SELECT` statement to calculate the average rating. Specifically, it calculates the average of the `RATING` column from the `REVIEW` table, explicitly casting each `RATING` value to `BINARY_DOUBLE` using the `TO_BINARY_DOUBLE` function before averaging, and stores this result into the `v_avg_rating` variable. This average is calculated only for reviews where the `BOOK_ID` matches the current `book_rec.BOOK_ID`. Following this, a conditional block (`IF-ELSIF-ELSE`) evaluates the `v_avg_rating`. If `v_avg_rating` is strictly greater than `8.0`, an `UPDATE` statement is executed on the `BOOK` table, setting the `TYPE` column to the string literal 'Bestseller' for the row where `BOOK_ID` matches the current `book_rec.BOOK_ID`. If the previous condition is false but `v_avg_rating` is strictly greater than `5.0`, an `UPDATE` statement is executed on the `BOOK` table, setting the `TYPE` column to the string literal 'Popular' for the row where `BOOK_ID` matches the current `book_rec.BOOK_ID`. Otherwise (if `v_avg_rating` is not greater than `8.0` and not greater than `5.0`), an `UPDATE` statement is executed on the `BOOK` table, setting the `TYPE` column to the string literal 'Standard' for the row where `BOOK_ID` matches the current `book_rec.BOOK_ID`. This process repeats for all distinct `BOOK_ID`s found in the `REVIEW` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_book_rank\nAFTER UPDATE OF RATING ON REVIEW\nDECLARE\n  v_avg_rating BINARY_DOUBLE;\n  CURSOR book_cursor IS\n    SELECT DISTINCT BOOK_ID FROM REVIEW;\nBEGIN\n  FOR book_rec IN book_cursor LOOP\n    SELECT AVG(TO_BINARY_DOUBLE(RATING)) INTO v_avg_rating \n    FROM REVIEW \n    WHERE BOOK_ID = book_rec.BOOK_ID;\n    \n    IF v_avg_rating > 8.0 THEN\n      UPDATE BOOK SET TYPE = 'Bestseller' WHERE BOOK_ID = book_rec.BOOK_ID;\n    ELSIF v_avg_rating > 5.0 THEN\n      UPDATE BOOK SET TYPE = 'Popular' WHERE BOOK_ID = book_rec.BOOK_ID;\n    ELSE\n      UPDATE BOOK SET TYPE = 'Standard' WHERE BOOK_ID = book_rec.BOOK_ID;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "UPDATE REVIEW SET RATING = 7.0 WHERE REVIEW_ID = 1",
      "UPDATE REVIEW SET RATING = 9.0 WHERE REVIEW_ID = 2",
      "UPDATE REVIEW SET RATING = 4.5 WHERE REVIEW_ID = 3",
      "UPDATE REVIEW SET RATING = 6.0 WHERE REVIEW_ID = 1",
      "UPDATE REVIEW SET RATING = 8.5 WHERE REVIEW_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE trigger on the REVIEW table's RATING column named trg_adjust_book_rank. It declares a cursor for distinct BOOK_IDs. For each book, it calculates the average RATING (cast to BINARY_DOUBLE) and updates the BOOK table's TYPE to 'Bestseller' if the average > 8.0, 'Popular' if > 5.0, or 'Standard' otherwise.",
    "natural_language": "Set up a trigger on the REVIEW table for after updates to the rating, call it something like trg_adjust_book_rank. It should go through the books involved. For each one, figure out the typical rating score. Then, based on that average, update the book's category: if it's really high, mark it as a top seller; if it's pretty decent, call it popular; otherwise, just leave it as the regular type.",
    "id": 254
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_review_rank that fires automatically before any INSERT or UPDATE operation on the REVIEW table for each affected row, declaring a local variable v_high_rating_count of type NUMBER, then executing a SELECT statement to count the number of existing rows in the REVIEW table where the BOOK_ID column matches the new BOOK_ID value from the :NEW pseudorecord and the RATING column is greater than 8.0, storing the result into v_high_rating_count, and then using an IF-THEN-ELSIF-ELSE conditional block to assign a value to the :NEW.RANK column: if the count is greater than 5, the new RANK is set to 1; if the count is not greater than 5 but is greater than 2, the new RANK is set to 50; otherwise, for all other cases, the new RANK is set to 100.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_review_rank\nBEFORE INSERT OR UPDATE ON REVIEW\nFOR EACH ROW\nDECLARE\n  v_high_rating_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_high_rating_count FROM REVIEW WHERE BOOK_ID = :NEW.BOOK_ID AND RATING > 8.0;\n  IF v_high_rating_count > 5 THEN\n    :NEW.RANK := 1;\n  ELSIF v_high_rating_count > 2 THEN\n    :NEW.RANK := 50;\n  ELSE\n    :NEW.RANK := 100;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION) VALUES (4, 1, 9.0, 3.5)",
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION) VALUES (5, 1, 8.5, 3.0)",
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION) VALUES (6, 2, 7.0, 2.9)",
      "UPDATE REVIEW SET RATING = 9.1 WHERE REVIEW_ID = 1",
      "UPDATE REVIEW SET RATING = 8.2 WHERE REVIEW_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger on the REVIEW table named trg_check_review_rank. It counts existing reviews for the same BOOK_ID with RATING > 8.0. It then sets the :NEW.RANK column to 1 if the count > 5, to 50 if the count > 2, or to 100 otherwise.",
    "natural_language": "Please implement a BEFORE INSERT OR UPDATE FOR EACH ROW trigger on the REVIEW table, designated as trg_check_review_rank. The trigger's function is to calculate the number of existing reviews for the identical BOOK_ID that possess a RATING exceeding 8.0. Subsequently, it will assign a value to the :NEW.RANK column according to the following logic: a value of 1 if the calculated count is greater than 5, a value of 50 if the count is greater than 2, and a value of 100 in all other cases.",
    "id": 255
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_book_type that is executed after an INSERT or UPDATE operation on the REVIEW table. This trigger does not take any parameters. It begins by declaring a local variable v_total_reviews of type NUMBER, which is used to store the count of reviews for each book. The trigger then enters a loop that iterates over a cursor selecting distinct BOOK_ID values from the REVIEW table. For each BOOK_ID retrieved, it performs a SELECT COUNT(*) operation to determine the total number of reviews associated with that BOOK_ID, storing the result in the v_total_reviews variable. The trigger then evaluates the value of v_total_reviews using a series of conditional statements. If v_total_reviews is greater than 10, it executes an UPDATE statement on the BOOK table, setting the TYPE column to 'Highly Reviewed' for the corresponding BOOK_ID. If v_total_reviews is greater than 5 but not more than 10, it updates the TYPE column to 'Moderately Reviewed'. If v_total_reviews is 5 or less, it updates the TYPE column to 'Lightly Reviewed'. The loop continues until all distinct BOOK_IDs from the REVIEW table have been processed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_book_type\nAFTER INSERT OR UPDATE ON REVIEW\nDECLARE\n  v_total_reviews NUMBER;\nBEGIN\n  FOR book_rec IN (SELECT DISTINCT BOOK_ID FROM REVIEW) LOOP\n    SELECT COUNT(*) INTO v_total_reviews FROM REVIEW WHERE BOOK_ID = book_rec.BOOK_ID;\n    IF v_total_reviews > 10 THEN\n      UPDATE BOOK SET TYPE = 'Highly Reviewed' WHERE BOOK_ID = book_rec.BOOK_ID;\n    ELSIF v_total_reviews > 5 THEN\n      UPDATE BOOK SET TYPE = 'Moderately Reviewed' WHERE BOOK_ID = book_rec.BOOK_ID;\n    ELSE\n      UPDATE BOOK SET TYPE = 'Lightly Reviewed' WHERE BOOK_ID = book_rec.BOOK_ID;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (100, 1, 7.5, 4.2, 15)",
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (101, 2, 8.1, 5.0, 12)",
      "UPDATE REVIEW SET RATING = 9.0 WHERE REVIEW_ID = 1",
      "INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (102, 1, 6.8, 3.8, 18)",
      "UPDATE REVIEW SET BOOK_ID = 3 WHERE REVIEW_ID = 2"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE trigger named TRG_UPDATE_BOOK_TYPE on the REVIEW table. For each distinct BOOK_ID in REVIEW, count its reviews. Update the BOOK table's TYPE column to 'Highly Reviewed' if count > 10, 'Moderately Reviewed' if count > 5 and <= 10, or 'Lightly Reviewed' if count <= 5.",
    "natural_language": "Create trigger TRG_UPDATE_BOOK_TYPE on REVIEW after insert or update. For each BOOK_ID, set BOOK.TYPE to 'Highly Reviewed' if review count > 10, 'Moderately Reviewed' if > 5 and <= 10, else 'Lightly Reviewed'.",
    "id": 256
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_INS_SUPPLIER_ADDRESS` that is activated `AFTER` an `INSERT` operation occurs on the `SUPPLIER_ADDRESSES` table. This trigger executes `FOR EACH ROW` that is inserted into the `SUPPLIER_ADDRESSES` table. Upon activation, the trigger declares a local variable named `v_address_count` of data type `NUMBER` to store an integer count. The trigger then performs a `SELECT` statement to `COUNT` the number of rows in the `ADDRESSES` table where the `ADDRESS_ID` column matches the `ADDRESS_ID` value of the newly inserted row in the `SUPPLIER_ADDRESSES` table (referenced as `:NEW.ADDRESS_ID`). The result of this count operation is then stored `INTO` the `v_address_count` variable. Following this, a conditional `IF` statement checks if the value of `v_address_count` is equal to `0`. If this condition is true, meaning no existing record with the same `ADDRESS_ID` was found in the `ADDRESSES` table, the trigger then executes an `INSERT` statement. This `INSERT` statement adds a new row into the `ADDRESSES` table, setting the `ADDRESS_ID` column to the `ADDRESS_ID` value of the newly inserted row in `SUPPLIER_ADDRESSES` (again, referenced as `:NEW.ADDRESS_ID`) and setting the `ADDRESS_DETAILS` column to the literal string value `'Auto-generated'`. If the `v_address_count` is not `0`, the `IF` condition is false, and no `INSERT` operation is performed on the `ADDRESSES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_INS_SUPPLIER_ADDRESS\nAFTER INSERT ON SUPPLIER_ADDRESSES\nFOR EACH ROW\nDECLARE\n    v_address_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_address_count FROM ADDRESSES WHERE ADDRESS_ID = :NEW.ADDRESS_ID;\n    IF v_address_count = 0 THEN\n        INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS) VALUES (:NEW.ADDRESS_ID, 'Auto-generated');\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES",
      "PRODUCT_SUPPLIERS"
    ],
    "call_sqls": [
      "INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (1, 101, '2023-01-01', '2024-01-01')",
      "INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (2, 102, '2023-02-01', '2024-02-01')",
      "INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (3, 103, '2023-03-01', '2024-03-01')",
      "INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (4, 104, '2023-04-01', '2024-04-01')",
      "INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (5, 105, '2023-05-01', '2024-05-01')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named TRG_INS_SUPPLIER_ADDRESS on the SUPPLIER_ADDRESSES table. If the inserted ADDRESS_ID does not exist in the ADDRESSES table, insert a new row into ADDRESSES with that ADDRESS_ID and 'Auto-generated' as ADDRESS_DETAILS.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger designated as TRG_INS_SUPPLIER_ADDRESS for the SUPPLIER_ADDRESSES table. The trigger's function is to verify, upon each insertion, whether the provided ADDRESS_ID is present within the ADDRESSES table. Should the ADDRESS_ID not exist, the trigger must subsequently insert a new record into the ADDRESSES table, utilizing the provided ADDRESS_ID and assigning the value 'Auto-generated' to the ADDRESS_DETAILS column.",
    "id": 257
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_DEL_SUPPLIER_CASCADE` that is activated `AFTER` a `DELETE` operation occurs on the `SUPPLIERS` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will execute once for every individual row that is deleted from the `SUPPLIERS` table. Upon activation, the trigger performs two distinct `DELETE` operations. The first operation `DELETE`s rows from the `PRODUCT_SUPPLIERS` table. The condition for this deletion is `WHERE SUPPLIER_ID = :OLD.SUPPLIER_ID`. Here, `:OLD.SUPPLIER_ID` refers to the value of the `SUPPLIER_ID` column from the specific row in the `SUPPLIERS` table that was just deleted, effectively removing all related product-supplier linkages for the deleted supplier. The second operation `DELETE`s rows from the `SUPPLIER_ADDRESSES` table. The condition for this deletion is `WHERE SUPPLIER_ID = :OLD.SUPPLIER_ID`. Similar to the previous operation, `:OLD.SUPPLIER_ID` refers to the `SUPPLIER_ID` of the row that was just deleted from the `SUPPLIERS` table, thereby removing all associated addresses for the deleted supplier.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_DEL_SUPPLIER_CASCADE\nAFTER DELETE ON SUPPLIERS\nFOR EACH ROW\nBEGIN\n    DELETE FROM PRODUCT_SUPPLIERS WHERE SUPPLIER_ID = :OLD.SUPPLIER_ID;\n    DELETE FROM SUPPLIER_ADDRESSES WHERE SUPPLIER_ID = :OLD.SUPPLIER_ID;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES",
      "PRODUCT_SUPPLIERS"
    ],
    "call_sqls": [
      "DELETE FROM SUPPLIERS WHERE SUPPLIER_ID = 2",
      "DELETE FROM SUPPLIERS WHERE SUPPLIER_ID = 3",
      "DELETE FROM SUPPLIERS WHERE SUPPLIER_ID = 4"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named TRG_DEL_SUPPLIER_CASCADE on the SUPPLIERS table. For each deleted supplier, delete related rows from the PRODUCT_SUPPLIERS and SUPPLIER_ADDRESSES tables where SUPPLIER_ID matches the deleted row's SUPPLIER_ID.",
    "natural_language": "Set up a trigger on the SUPPLIERS table that runs after a row is removed. It should handle cleaning up related information from a couple of other tablesthe ones for product links and addresseswhen the supplier IDs line up with the one that was just taken out.",
    "id": 258
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_AU_SUPPLIER_PHONE that is executed after an update operation on the SUPPLIER_PHONE column of the SUPPLIERS table. This trigger is defined to execute for each row that is affected by the update operation. Within the trigger body, perform an update operation on the SUPPLIER_ADDRESSES table, specifically setting the DATE_TO column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'. The update operation is applied to all rows in the SUPPLIER_ADDRESSES table where the SUPPLIER_ID column matches the SUPPLIER_ID value of the newly updated row in the SUPPLIERS table, referenced as :NEW.SUPPLIER_ID. The function TO_CHAR is used to convert the current timestamp obtained from CURRENT_TIMESTAMP into a string format that includes the year, month, day, hour, minute, and second.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_AU_SUPPLIER_PHONE\nAFTER UPDATE OF SUPPLIER_PHONE ON SUPPLIERS\nFOR EACH ROW\nBEGIN\n    UPDATE SUPPLIER_ADDRESSES SET DATE_TO = TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') WHERE SUPPLIER_ID = :NEW.SUPPLIER_ID;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES",
      "PRODUCT_SUPPLIERS"
    ],
    "call_sqls": [
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '111-222-3333' WHERE SUPPLIER_ID = 2",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '444-555-6666' WHERE SUPPLIER_ID = 3",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '777-888-9999' WHERE SUPPLIER_ID = 4",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '000-111-2222' WHERE SUPPLIER_ID = 2",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '333-444-5555' WHERE SUPPLIER_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named TRG_AU_SUPPLIER_PHONE on the SUPPLIERS table, firing when the SUPPLIER_PHONE column is updated. Update the SUPPLIER_ADDRESSES table, setting DATE_TO to the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format, for rows where SUPPLIER_ID matches the updated row's SUPPLIER_ID.",
    "natural_language": "Construct an AFTER UPDATE FOR EACH ROW trigger called TRG_AU_SUPPLIER_PHONE on the SUPPLIERS table, which is specifically designed to fire whenever the SUPPLIER_PHONE column is modified. This trigger should then proceed to update the SUPPLIER_ADDRESSES table by carefully setting the DATE_TO column to the precise current timestamp, formatted as 'YYYY-MM-DD HH24:MI:SS', but only for those rows where the SUPPLIER_ID perfectly matches the SUPPLIER_ID from the row that was just updated.",
    "id": 259
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_AI_ADDRESSES that is defined to execute automatically after a new row is inserted into the ADDRESSES table, and it executes once for each inserted row; within the trigger's execution block, it first declares a local variable v_max_supplier_id of type NUMBER, then performs a SELECT statement on the SUPPLIERS table to retrieve the maximum value from the SUPPLIER_ID column and stores that single result into the v_max_supplier_id variable; following this, it executes an INSERT statement into the SUPPLIER_ADDRESSES table, specifying values for four columns: it sets the SUPPLIER_ID column to the value stored in v_max_supplier_id, sets the ADDRESS_ID column to the value of the newly inserted ADDRESS_ID column from the ADDRESSES table (accessed via the :NEW.ADDRESS_ID bind variable), sets the DATE_FROM column to a character string representation of the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function with CURRENT_DATE as input, and sets the DATE_TO column to the fixed literal string '9999-12-31 23:59:59'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_AI_ADDRESSES\nAFTER INSERT ON ADDRESSES\nFOR EACH ROW\nDECLARE\n    v_max_supplier_id NUMBER;\nBEGIN\n    SELECT MAX(SUPPLIER_ID) INTO v_max_supplier_id FROM SUPPLIERS;\n    INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (v_max_supplier_id, :NEW.ADDRESS_ID, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD HH24:MI:SS'), '9999-12-31 23:59:59');\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES",
      "PRODUCT_SUPPLIERS"
    ],
    "call_sqls": [
      "INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS) VALUES (1, '123 Main St')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS) VALUES (2, '456 Oak Ave')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS) VALUES (3, '789 Pine Ln')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS) VALUES (4, '101 Elm Rd')",
      "INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS) VALUES (5, '202 Maple Dr')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named TRG_AI_ADDRESSES on the ADDRESSES table. Insert a row into SUPPLIER_ADDRESSES using the maximum SUPPLIER_ID from SUPPLIERS, the new ADDRESS_ID, the current timestamp as DATE_FROM, and '9999-12-31 23:59:59' as DATE_TO.",
    "natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger designated as TRG_AI_ADDRESSES on the ADDRESSES table. This trigger should be configured to insert a record into the SUPPLIER_ADDRESSES table. The inserted values must consist of the maximum SUPPLIER_ID obtained from the SUPPLIERS table, the newly generated ADDRESS_ID from the trigger context, the current system timestamp for the DATE_FROM field, and a value of '9999-12-31 23:59:59' for the DATE_TO field.",
    "id": 260
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_sales_update that activates after an update operation on the SONG table for each row affected. The trigger begins by declaring a local variable v_count of type NUMBER. It includes a PRAGMA AUTONOMOUS_TRANSACTION directive to allow independent transaction control within the trigger. The trigger logic first checks if the updated SALES column value in the SONG table exceeds 500,000. If true, it attempts to insert a new record into the SINGER table with the columns SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, and CITIZENSHIP, using the updated SINGER_ID from the SONG table, a fixed NAME value 'New Star', a calculated BIRTH_YEAR as the current year minus 30, a NET_WORTH_MILLIONS value derived from dividing the updated SALES by 1,000,000, and a fixed CITIZENSHIP value 'Unknown'. If a duplicate value on a unique index is encountered during insertion, the exception is caught and ignored. If the updated SALES value is between 300,000 and 500,000 inclusive, the trigger updates the SINGER table by increasing the NET_WORTH_MILLIONS column by 5 for the row where SINGER_ID matches the updated SINGER_ID from the SONG table. The trigger then performs a SELECT COUNT(*) operation into the v_count variable to count the number of rows in the SONG table where SINGER_ID matches the updated SINGER_ID. If v_count exceeds 10, the trigger updates the SINGER table to set the CITIZENSHIP column to 'Global' for the row where SINGER_ID matches the updated SINGER_ID from the SONG table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_sales_update\nAFTER UPDATE ON SONG\nFOR EACH ROW\nDECLARE\n   v_count NUMBER;\n   PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n   IF :NEW.SALES > 500000 THEN\n      BEGIN\n         INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP)\n         VALUES (:NEW.SINGER_ID, 'New Star', EXTRACT(YEAR FROM CURRENT_DATE) - 30, :NEW.SALES / 1000000, 'Unknown');\n      EXCEPTION\n         WHEN DUP_VAL_ON_INDEX THEN\n            NULL; -- Singer already exists, ignore\n      END;\n   ELSIF :NEW.SALES BETWEEN 300000 AND 500000 THEN\n      UPDATE SINGER SET NET_WORTH_MILLIONS = NET_WORTH_MILLIONS + 5 WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\n   \n   SELECT COUNT(*) INTO v_count FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID;\n   IF v_count > 10 THEN\n      UPDATE SINGER SET CITIZENSHIP = 'Global' WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\n   \n   COMMIT;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SONG SET SALES = 600000 WHERE SONG_ID = 3",
      "UPDATE SONG SET SALES = 450000 WHERE SONG_ID = 4",
      "UPDATE SONG SET SALES = 320000 WHERE SONG_ID = 5",
      "UPDATE SONG SET SALES = 700000 WHERE SONG_ID = 3",
      "UPDATE SONG SET SALES = 480000 WHERE SONG_ID = 4"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_song_sales_update on the SONG table. Declare a local NUMBER variable v_count and use PRAGMA AUTONOMOUS_TRANSACTION. If the updated SALES > 500,000, insert a new singer into the SINGER table using the updated SINGER_ID, with NAME='New Star', BIRTH_YEAR as current year minus 30, NET_WORTH_MILLIONS as SALES/1,000,000, and CITIZENSHIP='Unknown'. Ignore duplicate value errors. If SALES is between 300,000 and 500,000 inclusive, update the SINGER table to increase NET_WORTH_MILLIONS by 5 for the matching SINGER_ID. Then, count the songs for this singer. If the count exceeds 10, update the singer's CITIZENSHIP to 'Global'.",
    "natural_language": "Set up a trigger on the SONG table for after updates. It should have a local number variable and use that autonomous transaction pragma. If the sales figure gets bumped up past a really high threshold, like over half a million, then add a new singer entry. Use the singer ID from the update, set the name to something like 'New Star', make the birth year roughly 30 years back from now, calculate the net worth from the sales in a simple way, and mark citizenship as 'Unknown'. Don't worry if it tries to add a duplicate. If the sales are in that pretty good range, say from 300k up to 500k, then give the existing singer's net worth a decent boost. After that, check how many songs that singer has. If it's a lot, more than ten, then update their citizenship to something like 'Global'.",
    "id": 261
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_net_worth that is executed before an insert or update operation on the SINGER table for each row affected. The trigger begins by declaring two local variables: v_song_count of type NUMBER, which will store the count of songs associated with a singer, and v_next_song_id of type NUMBER, which will be used to determine the next song ID for insertion. The trigger first checks if the NET_WORTH_MILLIONS column of the new row being inserted or updated is greater than 50. If this condition is true, it updates the SONG table by increasing the SALES column by 10,000 for all rows where the SINGER_ID matches the SINGER_ID of the new row. If the NET_WORTH_MILLIONS is not greater than 50, it deletes rows from the SONG table where the SINGER_ID matches the SINGER_ID of the new row and the SALES column is less than 200,000. The trigger then performs a SELECT COUNT(*) operation to count the number of songs associated with the SINGER_ID of the new row and stores this count in the v_song_count variable. If v_song_count is greater than 5, the trigger calculates the next song ID by selecting the maximum SONG_ID from the SONG table, using the NVL function to handle null values, and adding 1 to this maximum value, storing the result in v_next_song_id. It then inserts a new row into the SONG table with the calculated v_next_song_id, a TITLE of 'New Hit', the SINGER_ID from the new row, SALES set to 500,000, and HIGHEST_POSITION set to 1. Additionally, the trigger checks if the CITIZENSHIP column of the new row is 'Unknown'. If so, it updates the CITIZENSHIP column to 'International'. The trigger includes an exception handler that catches any errors during execution and raises an application error with the code -20001 and a message that includes the error description using SQLERRM.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_net_worth\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nDECLARE\n   v_song_count NUMBER;\n   v_next_song_id NUMBER;\nBEGIN\n   IF :NEW.NET_WORTH_MILLIONS > 50 THEN\n      UPDATE SONG SET SALES = SALES + 10000 WHERE SINGER_ID = :NEW.SINGER_ID;\n   ELSE\n      DELETE FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID AND SALES < 200000;\n   END IF;\n   \n   SELECT COUNT(*) INTO v_song_count FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID;\n   \n   IF v_song_count > 5 THEN\n      SELECT NVL(MAX(SONG_ID), 0) + 1 INTO v_next_song_id FROM SONG;\n      INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION)\n      VALUES (v_next_song_id, 'New Hit', :NEW.SINGER_ID, 500000, 1);\n   END IF;\n   \n   IF :NEW.CITIZENSHIP = 'Unknown' THEN\n      :NEW.CITIZENSHIP := 'International';\n   END IF;\nEXCEPTION\n   WHEN OTHERS THEN\n      RAISE_APPLICATION_ERROR(-20001, 'Error in trigger: ' || SQLERRM);\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (10, 'New Singer 1', 1990, 60, 'USA')",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 70 WHERE SINGER_ID = 1",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (11, 'New Singer 2', 1985, 40, 'UK')",
      "UPDATE SINGER SET CITIZENSHIP = 'Unknown' WHERE SINGER_ID = 2",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (12, 'New Singer 3', 1995, 55, 'France')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_singer_net_worth on the SINGER table. Declare local NUMBER variables v_song_count and v_next_song_id. If the new NET_WORTH_MILLIONS > 50, update the SONG table to increase SALES by 10,000 for all songs by this singer. Otherwise, delete songs by this singer where SALES < 200,000. Then, count the singer's songs. If the count > 5, calculate the next SONG_ID and insert a new song with TITLE='New Hit', the singer's SINGER_ID, SALES=500,000, and HIGHEST_POSITION=1. If the new CITIZENSHIP is 'Unknown', update it to 'International'. Include an exception handler to raise application error -20001 with the SQLERRM message.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE row-level trigger called trg_singer_net_worth for the SINGER table? The trigger should declare local NUMBER variables v_song_count and v_next_song_id. If the new NET_WORTH_MILLIONS exceeds 50, how do I update the SONG table to increase SALES by 10,000 for all songs by this singer? Otherwise, how do I delete songs by this singer where SALES is below 200,000? After that, how do I count the singer's songs? If the count is greater than 5, how do I calculate the next SONG_ID and insert a new song with TITLE='New Hit', the singer's SINGER_ID, SALES=500,000, and HIGHEST_POSITION=1? Also, if the new CITIZENSHIP is 'Unknown', how do I update it to 'International'? Finally, how do I include an exception handler to raise application error -20001 with the SQLERRM message?",
    "id": 262
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_citizenship_update that is executed before an insert or update operation on the SINGER table for each row being processed. The trigger declares a local variable v_song_count of type NUMBER, although this variable is not used within the trigger body. The trigger checks the value of the CITIZENSHIP column in the new row being inserted or updated. If the CITIZENSHIP value is 'United States', it updates the CITIZENSHIP column to 'USA'. If the CITIZENSHIP value is 'France', it updates the CITIZENSHIP column to 'FR'. For any other CITIZENSHIP value, it updates the CITIZENSHIP column to the uppercase version of the current value using the UPPER() function, which converts a string to uppercase letters. The trigger does not perform any other operations or interact with other tables or columns.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_citizenship_update\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nDECLARE\n   v_song_count NUMBER;\nBEGIN\n   IF :NEW.CITIZENSHIP = 'United States' THEN\n      :NEW.CITIZENSHIP := 'USA';\n   ELSIF :NEW.CITIZENSHIP = 'France' THEN\n      :NEW.CITIZENSHIP := 'FR';\n   ELSE\n      :NEW.CITIZENSHIP := UPPER(:NEW.CITIZENSHIP);\n   END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (1, 'Singer A', 1980, 10.5, 'United States')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (2, 'Singer B', 1985, 12.3, 'France')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (3, 'Singer C', 1990, 8.9, 'Germany')",
      "UPDATE SINGER SET CITIZENSHIP = 'United States' WHERE SINGER_ID = 3",
      "UPDATE SINGER SET CITIZENSHIP = 'Canada' WHERE SINGER_ID = 1"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_singer_citizenship_update on the SINGER table. Declare an unused local NUMBER variable v_song_count. For the new row, standardize the CITIZENSHIP value: change 'United States' to 'USA', 'France' to 'FR', and convert any other value to uppercase.",
    "natural_language": "Make a BEFORE INSERT OR UPDATE trigger trg_singer_citizenship_update on SINGER. Declare unused NUMBER v_song_count. For new rows, set CITIZENSHIP: 'United States' to 'USA', 'France' to 'FR', others to uppercase.",
    "id": 263
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_position_update that fires before any row is updated in the SONG table, and for each row being updated, it declares a local variable v_singer_count of type NUMBER, then checks if the new value for the SALES column in the SONG table is greater than 500000, and if this condition is true, it sets the new value for the HIGHEST_POSITION column in the SONG table to 1, then checks if the new value for the HIGHEST_POSITION column equals 1, and if this condition is true, it executes an update on the SINGER table, incrementing the NET_WORTH_MILLIONS column by 10 for the specific row where the SINGER_ID column matches the new SINGER_ID value from the SONG table, then performs a select statement on the SINGER table to count the number of rows where the SINGER_ID column matches the new SINGER_ID value from the SONG table, storing the result into the v_singer_count variable, then checks if the v_singer_count variable equals 0, and if this condition is true, it executes an insert into the SINGER table, providing values for the columns SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, and CITIZENSHIP, where the SINGER_ID is set to the new SINGER_ID value from the SONG table, the NAME is set to the literal string 'New Talent', the BIRTH_YEAR is calculated by extracting the year component from the current system date using the EXTRACT function with the YEAR argument and CURRENT_DATE, then subtracting 20 from that year, the NET_WORTH_MILLIONS is set to 0, and the CITIZENSHIP is set to the literal string 'Unknown'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_position_update\nBEFORE UPDATE ON SONG\nFOR EACH ROW\nDECLARE\n   v_singer_count NUMBER;\nBEGIN\n   IF :NEW.SALES > 500000 THEN\n      :NEW.HIGHEST_POSITION := 1;\n   END IF;\n\n   IF :NEW.HIGHEST_POSITION = 1 THEN\n      UPDATE SINGER SET NET_WORTH_MILLIONS = NET_WORTH_MILLIONS + 10 WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\n\n   SELECT COUNT(*) INTO v_singer_count FROM SINGER WHERE SINGER_ID = :NEW.SINGER_ID;\n\n   IF v_singer_count = 0 THEN\n      INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP)\n      VALUES (:NEW.SINGER_ID, 'New Talent', EXTRACT(YEAR FROM CURRENT_DATE) - 20, 0, 'Unknown');\n   END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SONG SET SALES = 600000 WHERE SONG_ID = 3",
      "UPDATE SONG SET SALES = 550000, SINGER_ID = 1 WHERE SONG_ID = 4",
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE SONG_ID = 5",
      "UPDATE SONG SET SALES = 700000, SINGER_ID = 99 WHERE SONG_ID = 6",
      "UPDATE SONG SET SALES = 400000, HIGHEST_POSITION = 1, SINGER_ID = 100 WHERE SONG_ID = 7"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_song_position_update on the SONG table. Declare a local NUMBER variable v_singer_count. If the new SALES > 500,000, set the new HIGHEST_POSITION to 1. If the new HIGHEST_POSITION is 1, update the SINGER table to increase NET_WORTH_MILLIONS by 10 for the matching SINGER_ID. Then, check if this singer exists. If not (count = 0), insert a new singer with the SINGER_ID from the song, NAME='New Talent', BIRTH_YEAR as current year minus 20, NET_WORTH_MILLIONS=0, and CITIZENSHIP='Unknown'.",
    "natural_language": "Create a BEFORE UPDATE row-level trigger called trg_song_position_update for the SONG table. First, declare a local NUMBER variable named v_singer_count. If the new SALES value exceeds 500,000, set the new HIGHEST_POSITION to 1. Then, if the new HIGHEST_POSITION is 1, update the SINGER table to add 10 to the NET_WORTH_MILLIONS for the matching SINGER_ID. Next, check for the existence of this singer. If the singer does not exist (count is 0), insert a new singer record using the song's SINGER_ID, set the NAME to 'New Talent', the BIRTH_YEAR to the current year minus 20, NET_WORTH_MILLIONS to 0, and CITIZENSHIP to 'Unknown'.",
    "id": 264
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_update_box_value that fires for any update operation on the contents column of the boxes table, and which uses two global collections: one of type t_warehouse_list, which is a nested table of the warehouse column's data type from the boxes table, and another of type t_contents_list, which is a nested table of the contents column's data type from the boxes table, initializing these collections as empty. In the BEFORE EACH ROW section, for each row being updated, the trigger extends both global collections by one element and then assigns the new warehouse value from the :NEW pseudorecord and the new contents value from the :NEW pseudorecord into the last positions of the g_warehouses and g_contents collections, respectively. In the AFTER STATEMENT section, after all row-level operations are complete, the trigger iterates through the populated global collections using a FOR loop from index 1 to the count of elements in the g_warehouses collection, and for each index i, it executes an update statement on the boxes table, setting the value column to its current value multiplied by 1.1 for every row where the warehouse column equals the value stored in g_warehouses(i) and the contents column equals the value stored in g_contents(i). Finally, after completing the loop, the trigger deletes all elements from both the g_warehouses and g_contents collections.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_box_value\nFOR UPDATE OF contents ON boxes\nCOMPOUND TRIGGER\n    TYPE t_warehouse_list IS TABLE OF boxes.warehouse%TYPE;\n    TYPE t_contents_list IS TABLE OF boxes.contents%TYPE;\n    \n    g_warehouses t_warehouse_list := t_warehouse_list();\n    g_contents   t_contents_list := t_contents_list();\n    \n    BEFORE EACH ROW IS\n    BEGIN\n        g_warehouses.EXTEND;\n        g_contents.EXTEND;\n        g_warehouses(g_warehouses.LAST) := :NEW.warehouse;\n        g_contents(g_contents.LAST) := :NEW.contents;\n    END BEFORE EACH ROW;\n    \n    AFTER STATEMENT IS\n    BEGIN\n        FOR i IN 1..g_warehouses.COUNT LOOP\n            UPDATE boxes\n            SET value = value * 1.1\n            WHERE warehouse = g_warehouses(i)\n            AND contents = g_contents(i);\n        END LOOP;\n        \n        g_warehouses.DELETE;\n        g_contents.DELETE;\n    END AFTER STATEMENT;\nEND trg_update_box_value;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "UPDATE boxes SET contents = 'Rocks' WHERE code = '0MN7'",
      "UPDATE boxes SET contents = 'Scissors' WHERE code = '4H8P'",
      "UPDATE boxes SET contents = 'Rocks' WHERE code = '4RT3'",
      "UPDATE boxes SET contents = 'Scissors' WHERE warehouse = 1",
      "UPDATE boxes SET contents = 'Rocks' WHERE warehouse = 3"
    ],
    "summary": "Create a compound trigger named trg_update_box_value for updates on the contents column of the boxes table. Declare two global nested table collections: g_warehouses (type of warehouse column) and g_contents (type of contents column), initialized as empty. In the BEFORE EACH ROW section, extend both collections and store the :NEW.warehouse and :NEW.contents values. In the AFTER STATEMENT section, loop through the collections. For each index i, update the boxes table, setting value = value * 1.1 where warehouse = g_warehouses(i) and contents = g_contents(i). Finally, delete all elements from both collections.",
    "natural_language": "Alright, so we need to whip up a compound trigger called trg_update_box_value that kicks in whenever the contents column in the boxes table gets updated. First off, set up two global collections as nested tables: one for warehouses (matching the warehouse column's type) and another for contents (matching the contents column's type). Start 'em off empty. In the BEFORE EACH ROW part, just add the new :NEW.warehouse and :NEW.contents values into those collections. Then, in the AFTER STATEMENT section, loop through everything we've collected. For each item in the loop, update the boxes table by bumping up the value by 10% (so, value = value * 1.1) but only for rows where the warehouse and contents match what we've got stored. Once that's all done, clear out both collections so they're ready for the next round.",
    "id": 265
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_box_contents that fires automatically before any row insertion operation on the boxes table, and for each new row being inserted, the trigger declares a local variable v_null_check of type VARCHAR2 with a maximum length of 255 characters, then assigns to this variable the result of the NULLIF function, which takes two arguments: the new value being inserted into the contents column of the boxes table, referenced as :NEW.contents, and the literal string 'Unknown', where the function returns NULL if the two arguments are equal, otherwise it returns the first argument, and after this assignment, the trigger executes a conditional IF statement that checks if the v_null_check variable is NULL, and if this condition evaluates to TRUE, the trigger modifies the new value for the contents column, :NEW.contents, by directly assigning it the literal string 'Unspecified' before the row is inserted into the database table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_box_contents\nBEFORE INSERT ON boxes\nFOR EACH ROW\nDECLARE\n    v_null_check VARCHAR2(255);\nBEGIN\n    v_null_check := NULLIF(:NEW.contents, 'Unknown');\n    \n    IF v_null_check IS NULL THEN\n        :NEW.contents := 'Unspecified';\n    END IF;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('A1B2', 'Unknown', 100, 1)",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('C3D4', NULL, 200, 2)",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('E5F6', 'Rocks', 150, 3)",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('G7H8', 'Unknown', 50, 4)",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('I9J0', 'Paper', 300, 1)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_validate_box_contents on the boxes table. For each new row, if the contents column value is 'Unknown', change it to 'Unspecified' before insertion.",
    "natural_language": "Make a BEFORE INSERT trigger trg_validate_box_contents for boxes. If contents is 'Unknown', set it to 'Unspecified'.",
    "id": 266
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_conference that is executed automatically after a delete operation is performed on the CONFERENCE table. This trigger operates for each row that is deleted from the CONFERENCE table. Within the trigger body, it performs a delete operation on the CONFERENCE_PARTICIPATION table, specifically removing all rows where the CONFERENCE_ID column matches the value of the CONFERENCE_ID from the deleted row in the CONFERENCE table. The trigger uses the :OLD pseudorecord to access the value of the CONFERENCE_ID from the row that was deleted in the CONFERENCE table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_conference\nAFTER DELETE ON CONFERENCE\nFOR EACH ROW\nBEGIN\n  DELETE FROM CONFERENCE_PARTICIPATION\n  WHERE CONFERENCE_ID = :OLD.CONFERENCE_ID;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "DELETE FROM CONFERENCE WHERE CONFERENCE_ID = 1",
      "DELETE FROM CONFERENCE WHERE CONFERENCE_ID = 2",
      "DELETE FROM CONFERENCE WHERE CONFERENCE_ID = 3",
      "DELETE FROM CONFERENCE WHERE CONFERENCE_ID = 4",
      "DELETE FROM CONFERENCE WHERE CONFERENCE_ID = 5"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_conference on the CONFERENCE table. For each deleted row, delete all matching rows from the CONFERENCE_PARTICIPATION table where CONFERENCE_ID equals the deleted row's CONFERENCE_ID.",
    "natural_language": "Hey, set up a trigger called trg_delete_conference that fires after a row is deleted from the CONFERENCE table. Every time a conference gets axed, it should also clean up and delete any related entries in the CONFERENCE_PARTICIPATION table where the CONFERENCE_ID matches the one that was just removed.",
    "id": 267
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_conference_location` that is activated `AFTER` an `UPDATE` operation on the `LOCATION` column of the `CONFERENCE` table. This trigger is defined to execute `FOR EACH ROW` that is affected by the `UPDATE` statement. Upon activation, for each row where the `LOCATION` column has been updated, the trigger performs a `DELETE` operation on the `CONFERENCE_PARTICIPATION` table. The `DELETE` operation targets rows in the `CONFERENCE_PARTICIPATION` table where the value in its `CONFERENCE_ID` column matches the value of the `CONFERENCE_ID` column from the row in the `CONFERENCE` table *before* the `UPDATE` operation occurred. This is referenced using the `:OLD.CONFERENCE_ID` pseudorecord variable, which provides access to the original values of the columns of the row being updated in the `CONFERENCE` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_conference_location\nAFTER UPDATE OF LOCATION ON CONFERENCE\nFOR EACH ROW\nBEGIN\n  DELETE FROM CONFERENCE_PARTICIPATION\n  WHERE CONFERENCE_ID = :OLD.CONFERENCE_ID;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE CONFERENCE SET LOCATION = 'New York' WHERE CONFERENCE_ID = 1",
      "UPDATE CONFERENCE SET LOCATION = 'London' WHERE CONFERENCE_ID = 2",
      "UPDATE CONFERENCE SET LOCATION = 'Paris' WHERE CONFERENCE_ID = 3",
      "UPDATE CONFERENCE SET LOCATION = 'Berlin' WHERE CONFERENCE_ID = 1 AND YEAR = 2003",
      "UPDATE CONFERENCE SET LOCATION = 'Tokyo' WHERE CONFERENCE_NAME = 'Naccl'"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_conference_location on the CONFERENCE table, firing when the LOCATION column is updated. For each updated row, delete all rows from CONFERENCE_PARTICIPATION where CONFERENCE_ID equals the original (pre-update) CONFERENCE_ID.",
    "natural_language": "Set up a trigger on the conference table that runs after the location gets changed. When that happens, it should clean up any related participation records for those conferences.",
    "id": 268
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_staff that is defined to execute automatically after a new row is successfully inserted into the STAFF table, and it executes once for each individual row that is inserted; the trigger performs a single operation, which is to insert a new record into the CONFERENCE_PARTICIPATION table; for this insertion, the trigger uses the literal constant value 1 for the CONFERENCE_ID column, uses the newly inserted STAFF_ID value from the :NEW pseudorecord for the STAFF_ID column, and uses the literal string constant 'Participant' for the ROLE column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_staff\nAFTER INSERT ON STAFF\nFOR EACH ROW\nBEGIN\n  INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE)\n  VALUES (1, :NEW.STAFF_ID, 'Participant');\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (1, 'Bobby Jackson', 24, 'United States', 1)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (2, 'Casey Jacobsen', 23, 'United Kindom', 2)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (3, 'Alexander Johnson', 42, 'United States', 3)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (4, 'Jane Doe', 30, 'Canada', 1)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (5, 'John Smith', 50, 'Australia', 2)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_staff on the STAFF table. For each new staff row, insert a record into CONFERENCE_PARTICIPATION with CONFERENCE_ID=1, STAFF_ID from the new staff, and ROLE='Participant'.",
    "natural_language": "How can I create an AFTER INSERT row-level trigger called trg_insert_staff on the STAFF table so that for each new staff member added, a record is inserted into the CONFERENCE_PARTICIPATION table with CONFERENCE_ID set to 1, STAFF_ID taken from the new staff row, and ROLE set to 'Participant'?",
    "id": 269
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_boxes_value_check` that is associated with the `boxes` table and is activated for both `INSERT` and `UPDATE` operations. This trigger defines two custom record types: `avg_value_type`, which contains two fields, `warehouse` (of `NUMBER` type) and `avg_value` (of `NUMBER` type), and `avg_value_table_type`, which is a PL/SQL associative array (indexed by `PLS_INTEGER`) of `avg_value_type` records. A variable named `avg_values` of type `avg_value_table_type` is declared to store aggregated average values.\n\nThe trigger's `BEFORE STATEMENT` section executes once before any row-level operations for the triggering statement. Within this section, it iterates through a result set obtained by querying the `boxes` table. This query groups rows by the `warehouse` column and calculates the average of the `value` column for each `warehouse` group, aliasing this average as `avg_value`. For each record (`rec`) returned by this query, the `warehouse` field of the `avg_values` associative array at the index corresponding to `rec.warehouse` is populated with `rec.warehouse`, and the `avg_value` field of the same array element is populated with `rec.avg_value`. This effectively pre-calculates and stores the average `value` for each `warehouse` present in the `boxes` table before any individual row is processed.\n\nThe trigger's `BEFORE EACH ROW` section executes for every row that is being inserted or updated. Within this section, it first checks if an entry exists in the `avg_values` associative array for the `warehouse` of the new or updated row (`:NEW.warehouse`). If an entry exists, it then compares the `value` of the new or updated row (`:NEW.value`) with the pre-calculated average `value` for that specific `warehouse` (retrieved from `avg_values(:NEW.warehouse).avg_value`). If the `value` of the new or updated row is found to be less than the stored average `value` for its `warehouse`, the `value` of the new or updated row (`:NEW.value`) is then modified to be equal to that pre-calculated average `value` from `avg_values(:NEW.warehouse).avg_value`. This ensures that the `value` of any inserted or updated box is not less than the average `value` of other boxes in the same `warehouse`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_boxes_value_check\nFOR INSERT OR UPDATE ON boxes\nCOMPOUND TRIGGER\n  TYPE avg_value_type IS RECORD (\n    warehouse NUMBER,\n    avg_value NUMBER\n  );\n  TYPE avg_value_table_type IS TABLE OF avg_value_type INDEX BY PLS_INTEGER;\n  avg_values avg_value_table_type;\n  \n  BEFORE STATEMENT IS\n  BEGIN\n    FOR rec IN (SELECT warehouse, AVG(value) AS avg_value FROM boxes GROUP BY warehouse) LOOP\n      avg_values(rec.warehouse).warehouse := rec.warehouse;\n      avg_values(rec.warehouse).avg_value := rec.avg_value;\n    END LOOP;\n  END BEFORE STATEMENT;\n  \n  BEFORE EACH ROW IS\n  BEGIN\n    IF avg_values.EXISTS(:NEW.warehouse) THEN\n      IF :NEW.value < avg_values(:NEW.warehouse).avg_value THEN\n        :NEW.value := avg_values(:NEW.warehouse).avg_value;\n      END IF;\n    END IF;\n  END BEFORE EACH ROW;\nEND trg_boxes_value_check;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('A001', 'Books', 100, 1)",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('A002', 'Electronics', 50, 1)",
      "UPDATE boxes SET VALUE = 70 WHERE CODE = 'A001'",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B001', 'Clothes', 200, 2)",
      "UPDATE boxes SET VALUE = 150 WHERE CODE = 'B001'"
    ],
    "summary": "Create a compound trigger named trg_boxes_value_check for INSERT and UPDATE operations on the boxes table. In the BEFORE STATEMENT section, calculate and store the average value per warehouse. In the BEFORE EACH ROW section, for each inserted or updated row, if its value is below its warehouse's average, raise it to that average.",
    "natural_language": "Hey, so we need a compound trigger called trg_boxes_value_check that fires for inserts and updates on the boxes table. First off, before the whole statement runs, figure out and stash the average value for each warehouse. Then, right before each individual row is processed, if that row's value is less than its warehouse's average, just bump it up to match that average.",
    "id": 270
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `trg_boxes_value_limit` that is activated on the `boxes` table. This trigger executes before any `INSERT` operation or `UPDATE` operation on any row within the `boxes` table. For each row being inserted or updated, the trigger first declares a local numeric variable named `max_value` to store a maximum value. It then performs a `SELECT` operation to retrieve the maximum `value` from the `boxes` table. This `SELECT` operation includes a `WHERE` clause that filters the rows based on the `warehouse` column, specifically selecting only those rows where the `warehouse` column's value matches the `warehouse` value of the new or updated row, which is referenced as `:NEW.warehouse`. The result of this `SELECT` operation, which is the maximum `value` found for the specified `warehouse`, is then stored into the `max_value` variable. Following this, the trigger evaluates a conditional `IF` statement. The condition checks two criteria: first, if `max_value` is not `NULL`, and second, if the `value` of the new or updated row, referenced as `:NEW.value`, is strictly greater than the `max_value` retrieved from the `boxes` table for the same `warehouse`. If both of these conditions are true, meaning a maximum value exists for the warehouse and the new or updated row's `value` exceeds this maximum, then the trigger performs an assignment operation. It sets the `value` of the new or updated row, `:NEW.value`, to the `max_value` that was previously retrieved. This effectively caps the `value` of the incoming or updated row at the existing maximum `value` for its respective `warehouse` if the new `value` attempts to exceed it.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_boxes_value_limit\nBEFORE INSERT OR UPDATE ON boxes\nFOR EACH ROW\nDECLARE\n    max_value NUMBER;\nBEGIN\n    SELECT MAX(value) INTO max_value FROM boxes WHERE warehouse = :NEW.warehouse;\n    \n    IF max_value IS NOT NULL AND :NEW.value > max_value THEN\n        :NEW.value := max_value;\n    END IF;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('A001', 'Books', 200, 1)",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('A002', 'Electronics', 300, 1)",
      "UPDATE boxes SET VALUE = 400 WHERE CODE = 'A001'",
      "INSERT INTO boxes (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B001', 'Clothes', 150, 2)",
      "UPDATE boxes SET VALUE = 250 WHERE CODE = 'B001'"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_boxes_value_limit on the boxes table. For each row, retrieve the maximum value from boxes for the same warehouse. If the new value is greater than this maximum, cap the new value at that maximum.",
    "natural_language": "Create trigger trg_boxes_value_limit on boxes before insert or update to cap new value at the warehouse's current maximum.",
    "id": 271
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_CLUB_LEADER_INSERT` that is activated `AFTER` a `DELETE` operation occurs on the `CLUB_LEADER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is deleted from the `CLUB_LEADER` table. Upon activation, the trigger declares a local numeric variable named `v_min_age`. The trigger then performs a `SELECT` operation to retrieve the minimum value from the `AGE` column of the `MEMBER` table. This retrieved minimum age value is then stored into the `v_min_age` variable. Following this, the trigger executes an `INSERT` operation into the `MEMBER` table. For this `INSERT` operation, the `MEMBER_ID` column is populated with the value of the `MEMBER_ID` column from the row that was just deleted from the `CLUB_LEADER` table (referenced as `:OLD.MEMBER_ID`), to which the numeric value `2000` is added. The `NAME` column is populated with the literal string `'New Leader'`. The `AGE` column is populated with the value currently stored in the `v_min_age` variable, which represents the minimum age found in the `MEMBER` table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CLUB_LEADER_INSERT\nAFTER DELETE ON CLUB_LEADER\nFOR EACH ROW\nDECLARE\n    v_min_age NUMBER;\nBEGIN\n    SELECT MIN(AGE) INTO v_min_age FROM MEMBER;\n    INSERT INTO MEMBER (MEMBER_ID, NAME, AGE) VALUES (:OLD.MEMBER_ID + 2000, 'New Leader', v_min_age);\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 1 AND MEMBER_ID = 1988",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 8 AND MEMBER_ID = 1984",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 6 AND MEMBER_ID = 1985",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 3 AND MEMBER_ID = 1990",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 4 AND MEMBER_ID = 1992"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named TRG_CLUB_LEADER_INSERT on the CLUB_LEADER table. For each deleted row, find the minimum age from the MEMBER table. Insert a new row into MEMBER using the deleted MEMBER_ID plus 2000, the name 'New Leader', and the minimum age.",
    "natural_language": "How can I create an AFTER DELETE row-level trigger called TRG_CLUB_LEADER_INSERT on the CLUB_LEADER table that, for each deleted row, finds the minimum age from the MEMBER table and inserts a new row into MEMBER with the deleted MEMBER_ID increased by 2000, the name 'New Leader', and that minimum age?",
    "id": 272
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CLUB_NAME_SYNC that is defined to fire automatically after each row is updated in the CLUB table, and within its declarative section it defines a local variable v_leader_count of type NUMBER; the trigger body begins by executing a SELECT statement that queries the CLUB_LEADER table to count all rows where the CLUB_ID column matches the new CLUB_ID value from the updated row in the CLUB table, storing the result into the v_leader_count variable, and then executes a DELETE statement on the CLUB_LEADER table where the CLUB_ID column equals the new CLUB_ID value and the pseudo-column ROWNUM is less than or equal to the result of the expression v_leader_count minus one.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CLUB_NAME_SYNC\nAFTER UPDATE ON CLUB\nFOR EACH ROW\nDECLARE\n    v_leader_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_leader_count FROM CLUB_LEADER WHERE CLUB_ID = :NEW.CLUB_ID;\n    DELETE FROM CLUB_LEADER WHERE CLUB_ID = :NEW.CLUB_ID AND ROWNUM <= v_leader_count - 1;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE CLUB SET CLUB_NAME = 'New Houston' WHERE CLUB_ID = 1",
      "UPDATE CLUB SET OVERALL_RANKING = 10 WHERE CLUB_ID = 3",
      "UPDATE CLUB SET TEAM_LEADER = 'New Leader' WHERE CLUB_ID = 4",
      "UPDATE CLUB SET CLUB_NAME = 'Updated SMU' WHERE CLUB_ID = 5",
      "UPDATE CLUB SET OVERALL_RANKING = 99 WHERE CLUB_ID = 6"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_CLUB_NAME_SYNC on the CLUB table. For each updated row, count the leaders in the CLUB_LEADER table for the new CLUB_ID. Then delete all but one of those leaders from the CLUB_LEADER table for that CLUB_ID.",
    "natural_language": "Create trigger TRG_CLUB_NAME_SYNC on CLUB after update. For each row, count leaders for the new CLUB_ID in CLUB_LEADER, then delete all but one.",
    "id": 273
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_MEMBER_AGE_ARCHIVE` that is activated `BEFORE` any `DELETE` operation is performed on the `MEMBER` table. This trigger is defined to execute `FOR EACH ROW` that is being deleted. Within the trigger's execution block, a local variable `v_max_ranking` of data type `NUMBER` is declared. The first operation performed is a `SELECT` statement that retrieves the maximum value from the `OVERALL_RANKING` column of the `CLUB` table and stores this value into the `v_max_ranking` variable. Following this, an `INSERT` operation is executed on the `CLUB_LEADER` table. This `INSERT` statement populates three columns: `CLUB_ID`, `MEMBER_ID`, and `YEAR_JOIN`. The `CLUB_ID` column is assigned a literal integer value of `1`. The `MEMBER_ID` column is assigned the value of the `MEMBER_ID` column from the row currently being deleted from the `MEMBER` table, referenced by `:OLD.MEMBER_ID`. The `YEAR_JOIN` column is assigned a substring of the `NAME` column from the row currently being deleted from the `MEMBER` table, referenced by `:OLD.NAME`. Specifically, the `SUBSTR` function extracts the first four characters (from position 1 for a length of 4) of the `:OLD.NAME` value.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MEMBER_AGE_ARCHIVE\nBEFORE DELETE ON MEMBER\nFOR EACH ROW\nDECLARE\n    v_max_ranking NUMBER;\nBEGIN\n    SELECT MAX(OVERALL_RANKING) INTO v_max_ranking FROM CLUB;\n    INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID, YEAR_JOIN) VALUES (1, :OLD.MEMBER_ID, SUBSTR(:OLD.NAME, 1, 4));\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1984",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1985",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1986",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1988",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1989"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_MEMBER_AGE_ARCHIVE on the MEMBER table. For each deleted row, find the maximum overall ranking from the CLUB table. Insert a row into CLUB_LEADER with CLUB_ID as 1, the deleted MEMBER_ID, and the first four characters of the deleted NAME as YEAR_JOIN.",
    "natural_language": "Create trigger TRG_MEMBER_AGE_ARCHIVE on MEMBER before delete. For each row, get max ranking from CLUB. Insert into CLUB_LEADER: CLUB_ID=1, deleted MEMBER_ID, first four chars of deleted NAME as YEAR_JOIN.",
    "id": 274
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_NATIONALITY_CLEANUP` that is configured to execute automatically after an `UPDATE` operation is performed on any row within the `MEMBER` table. This trigger does not accept any explicit parameters. Upon activation, the trigger first declares two local PL/SQL variables: `v_total_clubs` of data type `NUMBER` and `v_avg_age` of data type `NUMBER`. The trigger then proceeds to execute a `SELECT` statement to count all rows in the `CLUB` table, storing the resulting total number of clubs into the `v_total_clubs` variable. Subsequently, another `SELECT` statement is executed to calculate the average value of the `AGE` column from all rows in the `MEMBER` table where the `NATIONALITY` column is exactly equal to the string literal 'Australia'. This calculated average age is then stored into the `v_avg_age` variable. Finally, the trigger performs a `DELETE` operation on the `CLUB` table, removing all rows where the value in the `OVERALL_RANKING` column is strictly greater than the value stored in the `v_avg_age` variable AND the value in the `CLUB_ID` column is strictly greater than the value stored in the `v_total_clubs` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_NATIONALITY_CLEANUP\nAFTER UPDATE ON MEMBER\nDECLARE\n    v_total_clubs NUMBER;\n    v_avg_age NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_clubs FROM CLUB;\n    SELECT AVG(AGE) INTO v_avg_age FROM MEMBER WHERE NATIONALITY = 'Australia';\n    DELETE FROM CLUB WHERE OVERALL_RANKING > v_avg_age AND CLUB_ID > v_total_clubs;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE MEMBER SET AGE = 25 WHERE MEMBER_ID = 1984",
      "UPDATE MEMBER SET NATIONALITY = 'Australia' WHERE MEMBER_ID = 1985",
      "UPDATE MEMBER SET AGE = 30, NATIONALITY = 'Australia' WHERE MEMBER_ID = 1986",
      "UPDATE MEMBER SET AGE = AGE + 1 WHERE NATIONALITY = 'Australia'",
      "UPDATE MEMBER SET NAME = 'Updated Name' WHERE MEMBER_ID = 1984"
    ],
    "summary": "Create an AFTER UPDATE statement-level trigger named TRG_NATIONALITY_CLEANUP on the MEMBER table. Count the total clubs and calculate the average age of Australian members. Delete clubs where the OVERALL_RANKING is greater than the average age and the CLUB_ID is greater than the total club count.",
    "natural_language": "After updating the MEMBER table, what is the total number of clubs and the average age of Australian members? Then, which clubs should be deleted if their OVERALL_RANKING exceeds that average age and their CLUB_ID is greater than the total club count?",
    "id": 275
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_painting_location_default that is executed before an insert operation on the PAINTINGS table. This trigger operates on each row being inserted into the table. It checks the value of the LOCATION column for the new row being inserted. If the LOCATION column is found to be NULL, the trigger assigns the default value 'Unknown Gallery' to the LOCATION column of the new row. The trigger ensures that every new painting record has a non-null LOCATION value by providing a default when none is specified during the insert operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_painting_location_default\nBEFORE INSERT ON PAINTINGS\nFOR EACH ROW\nBEGIN\n  IF :NEW.LOCATION IS NULL THEN\n    :NEW.LOCATION := 'Unknown Gallery';\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, PAINTERID) VALUES (85, 'Starry Night', 1889, 740, 920, 'oil', 'canvas', 333)",
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, PAINTERID) VALUES (86, 'The Persistence of Memory', 1931, 240, 330, 'oil', 'canvas', 222)",
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, PAINTERID) VALUES (87, 'The Scream', 1893, 910, 730, 'tempera', 'cardboard', 111)",
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, PAINTERID) VALUES (88, 'Girl with a Pearl Earring', 1665, 440, 390, 'oil', 'canvas', 333)",
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, PAINTERID) VALUES (89, 'The Night Watch', 1642, 3630, 4370, 'oil', 'canvas', 111)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_painting_location_default on the PAINTINGS table. If the new row's LOCATION is NULL, set it to 'Unknown Gallery'.",
    "natural_language": "How can I create a BEFORE INSERT row-level trigger named trg_painting_location_default on the PAINTINGS table that sets the LOCATION to 'Unknown Gallery' if the new row's LOCATION is NULL?",
    "id": 276
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_sculpture_year_check` that is configured to execute automatically before any `INSERT` or `UPDATE` operation is performed on the `SCULPTURES` table. This trigger is a row-level trigger, meaning it executes once for each row affected by the `INSERT` or `UPDATE` statement. Within the trigger's execution block, a conditional statement evaluates the value of the `YEAR` column for the row currently being processed. Specifically, it checks if the new value proposed for the `YEAR` column (referenced as `:NEW.YEAR`), which is of a numeric data type, is strictly less than the integer literal `1800`. If this condition evaluates to true, indicating that the proposed year is earlier than 1800, then the trigger modifies the new value of the `YEAR` column for the current row. It assigns the integer literal `1800` to `:NEW.YEAR`, effectively setting the year to 1800 if it was originally proposed to be earlier. If the condition `:NEW.YEAR < 1800` evaluates to false (i.e., the proposed year is 1800 or later), no action is taken on the `YEAR` column, and its original proposed value is retained. This ensures that no `SCULPTURES` record can have a `YEAR` value less than 1800.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sculpture_year_check\nBEFORE INSERT OR UPDATE ON SCULPTURES\nFOR EACH ROW\nBEGIN\n  IF :NEW.YEAR < 1800 THEN\n    :NEW.YEAR := 1800;\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "INSERT INTO SCULPTURES (SCULPTUREID, TITLE, YEAR, MEDIUM, LOCATION, SCULPTORID) VALUES (23, 'Modern Art', 1790, 'marble', 'Gallery 101', 333)",
      "INSERT INTO SCULPTURES (SCULPTUREID, TITLE, YEAR, MEDIUM, LOCATION, SCULPTORID) VALUES (24, 'Classic Bust', 1750, 'stone', 'Gallery 102', 111)",
      "UPDATE SCULPTURES SET YEAR = 1700 WHERE SCULPTUREID = 20",
      "INSERT INTO SCULPTURES (SCULPTUREID, TITLE, YEAR, MEDIUM, LOCATION, SCULPTORID) VALUES (25, 'Ancient Statue', 1600, 'granite', 'Gallery 103', 222)",
      "UPDATE SCULPTURES SET YEAR = 1780 WHERE SCULPTUREID = 21"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_sculpture_year_check on the SCULPTURES table. If the new YEAR value is less than 1800, set it to 1800.",
    "natural_language": "Develop a row-level trigger to be executed before any insert or update operation, naming it trg_sculpture_year_check for the SCULPTURES table, which will meticulously verify the new YEAR value and, should it be found to be earlier than 1800, will automatically and consistently adjust it to the baseline year of 1800.",
    "id": 277
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_artist_deathyear_check` that is configured to execute `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `ARTISTS` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row affected by the `INSERT` or `UPDATE` statement. The trigger's primary purpose is to enforce data integrity related to an artist's birth and death years. Within the trigger's `BEGIN...END` block, a conditional statement (`IF`) is evaluated. This condition checks two criteria: first, if the `DEATHYEAR` column of the `NEW` row (the row being inserted or updated) `IS NOT NULL`, and second, if the value of the `DEATHYEAR` column in the `NEW` row is `LESS THAN` the value of the `BIRTHYEAR` column in the `NEW` row. If both of these conditions are met (i.e., a death year is provided and it is chronologically before the birth year), then the `DEATHYEAR` column of the `NEW` row is explicitly set to `NULL`. This action effectively nullifies an invalid `DEATHYEAR` entry before the row is permanently inserted or updated in the `ARTISTS` table, preventing the storage of illogical death year data.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_artist_deathyear_check\nBEFORE INSERT OR UPDATE ON ARTISTS\nFOR EACH ROW\nBEGIN\n  IF :NEW.DEATHYEAR IS NOT NULL AND :NEW.DEATHYEAR < :NEW.BIRTHYEAR THEN\n    :NEW.DEATHYEAR := NULL;\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "INSERT INTO ARTISTS (ARTISTID, LNAME, FNAME, BIRTHYEAR, DEATHYEAR) VALUES (444, 'Monet', 'Claude', 1840, 1820)",
      "UPDATE ARTISTS SET DEATHYEAR = 1800 WHERE ARTISTID = 111",
      "INSERT INTO ARTISTS (ARTISTID, LNAME, FNAME, BIRTHYEAR, DEATHYEAR) VALUES (555, 'Rembrandt', 'Harmenszoon', 1606, 1669)",
      "UPDATE ARTISTS SET BIRTHYEAR = 1900, DEATHYEAR = 1850 WHERE ARTISTID = 222",
      "INSERT INTO ARTISTS (ARTISTID, LNAME, FNAME, BIRTHYEAR) VALUES (666, 'Vermeer', 'Johannes', 1632)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_artist_deathyear_check on the ARTISTS table. If the new DEATHYEAR is not null and is less than the new BIRTHYEAR, set DEATHYEAR to NULL.",
    "natural_language": "Hey, set up a trigger called trg_artist_deathyear_check for the ARTISTS table that fires before you insert or update a row. If someone tries to put in a death year that's not empty but is actually earlier than the birth year, just blank out that death year and set it to null.",
    "id": 278
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_painting_medium_check that is executed before an INSERT or UPDATE operation on the PAINTINGS table. This trigger operates on each row affected by the DML operation. Within the trigger, it checks the value of the MEDIUM column for the row being inserted or updated. If the MEDIUM column in the new row (:NEW.MEDIUM) is NULL, the trigger assigns the string 'Unknown Medium' to the MEDIUM column of that row. This ensures that any new or updated row in the PAINTINGS table will have a non-null value in the MEDIUM column, defaulting to 'Unknown Medium' if no specific medium is provided.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_painting_medium_check\nBEFORE INSERT OR UPDATE ON PAINTINGS\nFOR EACH ROW\nBEGIN\n  IF :NEW.MEDIUM IS NULL THEN\n    :NEW.MEDIUM := 'Unknown Medium';\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, LOCATION, PAINTERID) VALUES (100, 'New Painting 1', 2023, 100, 100, NULL, 'canvas', 'Gallery 1', 111)",
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUMON, LOCATION, PAINTERID) VALUES (101, 'New Painting 2', 2023, 150, 120, 'wood', 'Gallery 2', 222)",
      "UPDATE PAINTINGS SET MEDIUM = NULL WHERE PAINTINGID = 80",
      "INSERT INTO PAINTINGS (PAINTINGID, TITLE, YEAR, HEIGHT_MM, WIDTH_MM, MEDIUM, MEDIUMON, LOCATION, PAINTERID) VALUES (102, 'New Painting 3', 2024, 200, 180, 'oil', 'canvas', 'Gallery 3', 111)",
      "UPDATE PAINTINGS SET MEDIUM = NULL WHERE PAINTINGID = 83"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_painting_medium_check on the PAINTINGS table. If the new MEDIUM is NULL, set it to 'Unknown Medium'.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE row-level trigger called trg_painting_medium_check for the PAINTINGS table that sets the new MEDIUM to 'Unknown Medium' if it is NULL?",
    "id": 279
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_staff_age that is executed before an insert operation on the STAFF table for each row being inserted. The trigger declares two local variables: v_institution_count of type NUMBER, which is used to store the count of records in the INSTITUTION table, and v_unique_age of type NUMBER, which is used to calculate a unique age value for the new staff member. The trigger begins by executing a SELECT statement to count all rows in the INSTITUTION table and stores this count in the v_institution_count variable. It then checks if the STAFF_ID of the new row being inserted is not null. If STAFF_ID is not null, it calculates v_unique_age using the modulus operation on the absolute value of the sum of STAFF_ID and v_institution_count, ensuring the result is between 18 and 117 by adding 18 to the modulus result. If STAFF_ID is null, which is unlikely since STAFF_ID is typically a primary key, it calculates v_unique_age using only v_institution_count, again ensuring the result is between 18 and 117 by adding 18 to the modulus result. The calculated v_unique_age is then assigned to the AGE column of the new row. If any error occurs during the execution of the trigger, it catches the exception using the WHEN OTHERS clause and raises an application error with a custom error message that includes the SQL error message.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_staff_age\nBEFORE INSERT ON STAFF\nFOR EACH ROW\nDECLARE\n  v_institution_count NUMBER;\n  v_unique_age NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_institution_count FROM INSTITUTION;\n  \n  -- Generate a more reasonable age value to avoid constraint violations\n  -- Using a combination of institution count and staff_id for uniqueness\n  IF :NEW.STAFF_ID IS NOT NULL THEN\n    v_unique_age := MOD(ABS(:NEW.STAFF_ID + v_institution_count), 100) + 18;\n  ELSE\n    -- Fallback if STAFF_ID is null (though it shouldn't be as it's primary key)\n    v_unique_age := MOD(v_institution_count, 100) + 18;\n  END IF;\n  \n  :NEW.AGE := v_unique_age;\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Log error and re-raise\n    RAISE_APPLICATION_ERROR(-20001, 'Error in trg_maintain_staff_age: ' || SQLERRM);\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO STAFF (STAFF_ID, NAME, NATIONALITY, INSTITUTION_ID) VALUES (101, 'John Doe', 'American', 1)",
      "INSERT INTO STAFF (STAFF_ID, NAME, NATIONALITY, INSTITUTION_ID) VALUES (102, 'Jane Smith', 'British', 2)",
      "INSERT INTO STAFF (STAFF_ID, NAME, NATIONALITY, INSTITUTION_ID) VALUES (103, 'Peter Jones', 'Canadian', 3)",
      "INSERT INTO STAFF (STAFF_ID, NAME, NATIONALITY, INSTITUTION_ID) VALUES (104, 'Alice Brown', 'Australian', 1)",
      "INSERT INTO STAFF (STAFF_ID, NAME, NATIONALITY, INSTITUTION_ID) VALUES (105, 'Bob White', 'German', 2)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_maintain_staff_age on the STAFF table. Calculate a unique AGE for the new row based on the STAFF_ID and the count of records in the INSTITUTION table, ensuring the result is between 18 and 117. Handle any exceptions by raising an application error with the SQL error message.",
    "natural_language": "Create trigger trg_maintain_staff_age on STAFF. Set AGE using STAFF_ID and INSTITUTION count, limit to 18-117. Raise error on exception.",
    "id": 280
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_cleanup_institution that is defined to fire automatically after a row is deleted from the INSTITUTION table, executing for each deleted row, and within its body, it performs two delete operations: first, it deletes all rows from the STAFF table where the INSTITUTION_ID column matches the value of the INSTITUTION_ID column from the deleted INSTITUTION row, which is referenced using the :OLD.INSTITUTION_ID bind variable, and second, it deletes all rows from the CONFERENCE table where the LOCATION column contains, as a substring, the value of the LOCATION column from the deleted INSTITUTION row, which is referenced using the :OLD.LOCATION bind variable, by constructing a pattern using the concatenation operator where the pattern consists of any characters, followed by the deleted location value, followed by any other characters, effectively using the condition LOCATION LIKE '%' || :OLD.LOCATION || '%'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_cleanup_institution\nAFTER DELETE ON INSTITUTION\nFOR EACH ROW\nBEGIN\n  DELETE FROM STAFF WHERE INSTITUTION_ID = :OLD.INSTITUTION_ID;\n  DELETE FROM CONFERENCE WHERE LOCATION LIKE '%' || :OLD.LOCATION || '%';\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "DELETE FROM INSTITUTION WHERE INSTITUTION_ID = 1",
      "DELETE FROM INSTITUTION WHERE INSTITUTION_NAME = 'Bradley University'",
      "DELETE FROM INSTITUTION WHERE LOCATION = 'Eureka, Illinois'",
      "DELETE FROM INSTITUTION WHERE INSTITUTION_ID IN (2, 3)",
      "DELETE FROM INSTITUTION WHERE FOUNDED < 1860"
    ],
    "summary": "Create an AFTER DELETE trigger on the INSTITUTION table that deletes related records from the STAFF table (matching INSTITUTION_ID) and from the CONFERENCE table (where LOCATION contains the deleted institution's LOCATION).",
    "natural_language": "Hey, set up a trigger that kicks in after we delete something from the INSTITUTION table. It should clean up by getting rid of any staff records linked to that institution's ID and also wipe out any conference entries where the location mentions the deleted institution's location.",
    "id": 281
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_UPD_GYMNAST_TOTAL` that is designed to execute automatically before an `UPDATE` operation is performed on the `GYMNAST` table. This trigger is specifically activated only when one or more of the following columns are being updated: `FLOOR_EXERCISE_POINTS`, `POMMEL_HORSE_POINTS`, `RINGS_POINTS`, `VAULT_POINTS`, `PARALLEL_BARS_POINTS`, or `HORIZONTAL_BAR_POINTS`. The trigger is defined with the `FOR EACH ROW` clause, meaning that its body will be executed once for every individual row in the `GYMNAST` table that is affected by the `UPDATE` statement. Within the trigger's execution block, the value of the `TOTAL_POINTS` column for the row currently being updated (represented by `:NEW.TOTAL_POINTS`) is calculated. This calculation involves summing the values of several other columns from the same row as they will be after the update. Specifically, the new value for `TOTAL_POINTS` is set to the sum of the new value of `FLOOR_EXERCISE_POINTS` (represented by `:NEW.FLOOR_EXERCISE_POINTS`), the new value of `POMMEL_HORSE_POINTS` (represented by `:NEW.POMMEL_HORSE_POINTS`), the new value of `RINGS_POINTS` (represented by `:NEW.RINGS_POINTS`), the new value of `VAULT_POINTS` (represented by `:NEW.VAULT_POINTS`), the new value of `PARALLEL_BARS_POINTS` (represented by `:NEW.PARALLEL_BARS_POINTS`), and the new value of `HORIZONTAL_BAR_POINTS` (represented by `:NEW.HORIZONTAL_BAR_POINTS`). This operation effectively ensures that the `TOTAL_POINTS` column is automatically maintained as the sum of the individual event scores whenever any of those individual scores are modified.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_UPD_GYMNAST_TOTAL\nBEFORE UPDATE OF FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS ON GYMNAST\nFOR EACH ROW\nBEGIN\n    :NEW.TOTAL_POINTS := :NEW.FLOOR_EXERCISE_POINTS + :NEW.POMMEL_HORSE_POINTS + :NEW.RINGS_POINTS + :NEW.VAULT_POINTS + :NEW.PARALLEL_BARS_POINTS + :NEW.HORIZONTAL_BAR_POINTS;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "UPDATE GYMNAST SET FLOOR_EXERCISE_POINTS = 9.8 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET POMMEL_HORSE_POINTS = 9.8 WHERE GYMNAST_ID = 2",
      "UPDATE GYMNAST SET RINGS_POINTS = 9.8 WHERE GYMNAST_ID = 4",
      "UPDATE GYMNAST SET VAULT_POINTS = 9.8 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET PARALLEL_BARS_POINTS = 9.8 WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE trigger on the GYMNAST table that fires when specific points columns are updated. For each row, recalculate TOTAL_POINTS as the sum of the new values for FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS.",
    "natural_language": "Set up a trigger on the gymnast table that runs before updates. When certain score columns get changed, have it figure out a new total by adding up the fresh numbers from a few of the main events.",
    "id": 282
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_DEL_PEOPLE that is executed automatically after a delete operation is performed on the PEOPLE table. This trigger operates for each row that is deleted from the PEOPLE table. The trigger's main function is to delete a corresponding row from the GYMNAST table. Specifically, it removes the row where the GYMNAST_ID column matches the PEOPLE_ID of the row that was just deleted from the PEOPLE table. The trigger uses the special :OLD pseudorecord to access the PEOPLE_ID value of the deleted row from the PEOPLE table, ensuring that the deletion in the GYMNAST table is directly linked to the deletion event in the PEOPLE table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_DEL_PEOPLE\nAFTER DELETE ON PEOPLE\nFOR EACH ROW\nBEGIN\n    DELETE FROM GYMNAST WHERE GYMNAST_ID = :OLD.PEOPLE_ID;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "DELETE FROM PEOPLE WHERE PEOPLE_ID = 1",
      "DELETE FROM PEOPLE WHERE PEOPLE_ID = 2",
      "DELETE FROM PEOPLE WHERE PEOPLE_ID = 3",
      "DELETE FROM PEOPLE WHERE NAME = 'Paul Hamm'",
      "DELETE FROM PEOPLE WHERE AGE > 20"
    ],
    "summary": "Create an AFTER DELETE trigger on the PEOPLE table that, for each deleted row, deletes the corresponding row from the GYMNAST table where GYMNAST_ID matches the deleted PEOPLE_ID.",
    "natural_language": "How do you create an AFTER DELETE trigger on the PEOPLE table that removes the matching row from the GYMNAST table for each deleted person, using the GYMNAST_ID and PEOPLE_ID fields?",
    "id": 283
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_INS_PEOPLE that is defined to fire automatically after a new row is inserted into the GYMNAST table, executing once for each inserted row. The trigger's logic is to conditionally insert a corresponding record into the PEOPLE table. It performs a conditional check using a WHERE NOT EXISTS clause to ensure an insertion only occurs if a row with a PEOPLE_ID value equal to the newly inserted GYMNAST_ID value from the GYMNAST table, referenced via the :NEW.GYMNAST_ID bind variable, does not already exist in the PEOPLE table. If this condition is true, the trigger executes an INSERT statement into the PEOPLE table, specifying the columns PEOPLE_ID, NAME, AGE, HEIGHT, and HOMETOWN. For the new row, it sets the PEOPLE_ID column to the value of :NEW.GYMNAST_ID from the triggering insert, the NAME column to the literal string 'Unknown', the AGE column to the literal number 0, the HEIGHT column to the literal number 0, and the HOMETOWN column to the literal string 'Unknown'. The SELECT statement sourcing these values uses the DUAL table solely to enable the WHERE NOT EXISTS subquery syntax.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_INS_PEOPLE\nAFTER INSERT ON GYMNAST\nFOR EACH ROW\nBEGIN\n    INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN)\n    SELECT :NEW.GYMNAST_ID, 'Unknown', 0, 0, 'Unknown'\n    FROM DUAL\n    WHERE NOT EXISTS (SELECT 1 FROM PEOPLE WHERE PEOPLE_ID = :NEW.GYMNAST_ID);\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (3, 9.8, 9.6, 9.7, 9.5, 9.6, 9.7, 58.9)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (5, 9.9, 9.8, 9.7, 9.6, 9.5, 9.4, 58.9)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (6, 9.7, 9.6, 9.5, 9.4, 9.3, 9.2, 56.7)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (7, 9.6, 9.5, 9.4, 9.3, 9.2, 9.1, 55.1)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) VALUES (8, 9.5, 9.4, 9.3, 9.2, 9.1, 9.0, 54.5)"
    ],
    "summary": "Create an AFTER INSERT trigger on the GYMNAST table that, for each new row, inserts a corresponding record into the PEOPLE table only if a record with that PEOPLE_ID does not already exist. Set the new PEOPLE row's ID to the new GYMNAST_ID, and set NAME, AGE, HEIGHT, and HOMETOWN to default values ('Unknown' or 0).",
    "natural_language": "Alright, so every time we add a new gymnast, we need a trigger to fire right after. This trigger should check if there's already a person with that same ID in the PEOPLE table. If there isn't one, it's gotta pop a new record into PEOPLE. Use the new gymnast's ID for the person's ID, and just fill in the name, age, height, and hometown with placeholders like 'Unknown' or zero.",
    "id": 284
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_reviewer_name_format that is executed before an insert operation on the REVIEWER table. This trigger operates on each row being inserted into the table. The trigger modifies the NAME column of the new row being inserted. Specifically, it transforms the NAME value such that the first character is converted to uppercase using the UPPER() function, and the rest of the characters are converted to lowercase using the LOWER() function. The transformation is achieved by concatenating the uppercase version of the first character, obtained using the UPPER(SUBSTR(:NEW.NAME, 1, 1)) expression, with the lowercase version of the remaining characters, obtained using the LOWER(SUBSTR(:NEW.NAME, 2)) expression. The :NEW.NAME syntax refers to the NAME column value of the row currently being inserted into the REVIEWER table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_reviewer_name_format\nBEFORE INSERT ON REVIEWER\nFOR EACH ROW\nBEGIN\n  :NEW.NAME := UPPER(SUBSTR(:NEW.NAME, 1, 1)) || LOWER(SUBSTR(:NEW.NAME, 2));\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "INSERT INTO REVIEWER (RID, NAME) VALUES (204, 'john doe')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (205, 'jane smith')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (206, 'ALEX JOHNSON')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (207, 'bOb wIlSoN')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (208, 'charlie brown')"
    ],
    "summary": "Create a BEFORE INSERT trigger on the REVIEWER table that formats the NAME column of each new row to have the first character in uppercase and the remaining characters in lowercase.",
    "natural_language": "Make a BEFORE INSERT trigger for REVIEWER to capitalize the first letter of NAME and make the rest lowercase.",
    "id": 285
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_rating_date_default that is executed before an insert operation on the RATING table. This trigger operates on each row being inserted into the table. It checks if the RATINGDATE column of the new row (:NEW.RATINGDATE) is null. If the RATINGDATE column is null, the trigger assigns the current system date to this column, formatted as a string in the 'YYYY-MM-DD' format using the TO_CHAR function applied to SYSDATE, which retrieves the current date and time from the system. The trigger ensures that every new row inserted into the RATING table has a non-null RATINGDATE value, defaulting to the current date if no date is provided during the insert operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_rating_date_default\nBEFORE INSERT ON RATING\nFOR EACH ROW\nBEGIN\n  IF :NEW.RATINGDATE IS NULL THEN\n    :NEW.RATINGDATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD');\n  END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "INSERT INTO RATING (RID, MID, STARS) VALUES (301, 101, 5)",
      "INSERT INTO RATING (RID, MID, STARS, RATINGDATE) VALUES (302, 102, 3, NULL)",
      "INSERT INTO RATING (RID, MID, STARS) VALUES (303, 103, 4)",
      "INSERT INTO RATING (RID, MID, STARS, RATINGDATE) VALUES (304, 101, 2, '2024-05-01')",
      "INSERT INTO RATING (RID, MID, STARS) VALUES (305, 102, 1)"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_rating_date_default on the RATING table. If the new RATINGDATE is null, set it to the current system date formatted as 'YYYY-MM-DD'.",
    "natural_language": "Hey, can you whip up a BEFORE INSERT row trigger called trg_rating_date_default for the RATING table? Basically, if the new RATINGDATE is empty or null, just fill it in with today's date in 'YYYY-MM-DD' format.",
    "id": 286
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_movie_title_validation that is executed before an INSERT or UPDATE operation on the MOVIE table for each row being processed. The trigger checks if the TITLE column of the new row (:NEW.TITLE) is NULL. If the TITLE is NULL, the trigger assigns a default value to the TITLE column. This default value is a concatenated string consisting of the literal text 'Untitled Movie ', followed by the value of the MID column from the new row (:NEW.MID), an underscore character '_', and a timestamp string generated by converting the current system timestamp (SYSTIMESTAMP) into a formatted string using the TO_CHAR function with the format 'YYYYMMDDHH24MISSFF', which represents the year, month, day, hour, minute, second, and fractional seconds. This ensures that each untitled movie has a unique title based on its MID and the precise time of the operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_movie_title_validation\nBEFORE INSERT OR UPDATE ON MOVIE\nFOR EACH ROW\nBEGIN\n  IF :NEW.TITLE IS NULL THEN\n    :NEW.TITLE := 'Untitled Movie ' || :NEW.MID || '_' || TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF');\n  END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "INSERT INTO MOVIE (MID, TITLE, YEAR, DIRECTOR) VALUES (104, 'Inception', 2010, 'Christopher Nolan')",
      "INSERT INTO MOVIE (MID, TITLE, YEAR, DIRECTOR) VALUES (105, NULL, 2001, 'Stanley Kubrick')",
      "UPDATE MOVIE SET TITLE = NULL WHERE MID = 101",
      "INSERT INTO MOVIE (MID, YEAR, DIRECTOR) VALUES (106, 1994, 'Quentin Tarantino')",
      "UPDATE MOVIE SET TITLE = 'New Title' WHERE MID = 102"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row trigger named trg_movie_title_validation on the MOVIE table. If the new TITLE is null, set it to a unique default value: 'Untitled Movie ' concatenated with the new MID, an underscore, and the current timestamp formatted as 'YYYYMMDDHH24MISSFF'.",
    "natural_language": "Hey, can you set up a trigger for the MOVIE table called trg_movie_title_validation that fires before a new row is inserted or an existing one is updated? Here's the deal: if the new TITLE is empty, we gotta fill it with something unique. Make it say 'Untitled Movie ' followed by the new MID, then an underscore, and then the current timestamp in 'YYYYMMDDHH24MISSFF' format.",
    "id": 287
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_institution_delete` that is activated `AFTER` a `DELETE` operation is performed on the `INSTITUTION` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is deleted from the `INSTITUTION` table. Upon activation, for each row that has been deleted from the `INSTITUTION` table, the trigger performs a `DELETE` operation on the `CHAMPIONSHIP` table. The `DELETE` operation on the `CHAMPIONSHIP` table is conditional: it removes all rows from the `CHAMPIONSHIP` table where the value in the `INSTITUTION_ID` column of the `CHAMPIONSHIP` table is equal to the value of the `INSTITUTION_ID` column from the row that was just deleted from the `INSTITUTION` table. The `:OLD.INSTITUTION_ID` refers to the value of the `INSTITUTION_ID` column in the row that existed in the `INSTITUTION` table immediately before it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_institution_delete\nAFTER DELETE ON INSTITUTION\nFOR EACH ROW\nBEGIN\n    DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = :OLD.INSTITUTION_ID;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "DELETE FROM INSTITUTION WHERE INSTITUTION_ID = 1",
      "DELETE FROM INSTITUTION WHERE INSTITUTION_ID = 2",
      "DELETE FROM INSTITUTION WHERE INSTITUTION_ID = 3",
      "DELETE FROM INSTITUTION WHERE NAME = 'University of British Columbia'",
      "DELETE FROM INSTITUTION WHERE CITY = 'Calgary'"
    ],
    "summary": "Create an AFTER DELETE row trigger named trg_institution_delete on the INSTITUTION table. For each deleted row, delete all rows from the CHAMPIONSHIP table where CHAMPIONSHIP.INSTITUTION_ID equals the old INSTITUTION_ID.",
    "natural_language": "Construct an AFTER DELETE row trigger with the name trg_institution_delete on the INSTITUTION table. For every single row that is removed, you must meticulously and completely delete all corresponding rows from the CHAMPIONSHIP table where the CHAMPIONSHIP.INSTITUTION_ID matches the old, now-deleted INSTITUTION_ID value.",
    "id": 288
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_institution_update` that is activated `AFTER` an `UPDATE` operation is performed on any row in the `INSTITUTION` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is updated in the `INSTITUTION` table. Upon activation, the trigger first executes a `DELETE` statement on the `CHAMPIONSHIP` table. This `DELETE` statement removes all rows from the `CHAMPIONSHIP` table where the `INSTITUTION_ID` column matches the value of the `INSTITUTION_ID` column from the row `BEFORE` the update operation occurred on the `INSTITUTION` table, referenced as `:OLD.INSTITUTION_ID`. Following the deletion, the trigger then executes an `INSERT` statement into the `CHAMPIONSHIP` table. This `INSERT` statement populates the `INSTITUTION_ID`, `NICKNAME`, `JOINED`, and `NUMBER_OF_CHAMPIONSHIPS` columns. The `INSTITUTION_ID` column is populated with the value of the `INSTITUTION_ID` column from the row `AFTER` the update operation occurred on the `INSTITUTION` table, referenced as `:NEW.INSTITUTION_ID`. The `NICKNAME` column is populated with the result of applying the `LOWER()` function to the value of the `TEAM` column from the row `AFTER` the update operation occurred on the `INSTITUTION` table, referenced as `:NEW.TEAM`, effectively converting the team name to lowercase. The `JOINED` column is populated with the value of the `FOUNDED` column from the row `AFTER` the update operation occurred on the `INSTITUTION` table, referenced as `:NEW.FOUNDED`. Finally, the `NUMBER_OF_CHAMPIONSHIPS` column is populated with the static numeric value `0`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_institution_update\nAFTER UPDATE ON INSTITUTION\nFOR EACH ROW\nBEGIN\n    DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = :OLD.INSTITUTION_ID;\n    INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n    VALUES (:NEW.INSTITUTION_ID, LOWER(:NEW.TEAM), :NEW.FOUNDED, 0);\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "UPDATE INSTITUTION SET TEAM = 'Thunderbirds' WHERE INSTITUTION_ID = 1",
      "UPDATE INSTITUTION SET TEAM = 'Dinos' WHERE INSTITUTION_ID = 2",
      "UPDATE INSTITUTION SET TEAM = 'Golden Bears' WHERE INSTITUTION_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE row trigger named trg_institution_update on the INSTITUTION table. For each updated row, first delete from CHAMPIONSHIP where INSTITUTION_ID equals the old INSTITUTION_ID. Then insert a new row into CHAMPIONSHIP with INSTITUTION_ID as the new INSTITUTION_ID, NICKNAME as the lowercase of the new TEAM, JOINED as the new FOUNDED, and NUMBER_OF_CHAMPIONSHIPS as 0.",
    "natural_language": "How can I create an AFTER UPDATE row trigger called trg_institution_update on the INSTITUTION table that, for each updated row, first deletes from CHAMPIONSHIP where INSTITUTION_ID matches the old INSTITUTION_ID and then inserts a new row into CHAMPIONSHIP with INSTITUTION_ID as the new INSTITUTION_ID, NICKNAME as the lowercase version of the new TEAM, JOINED as the new FOUNDED, and NUMBER_OF_CHAMPIONSHIPS set to 0?",
    "id": 289
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_musical_after_update that is executed after an update operation on the MUSICAL table for each row affected by the update. The trigger declares two local variables: v_actor_count of type NUMBER to store the count of actors associated with a specific musical, and v_total_age of type NUMBER to store the sum of ages of these actors. The trigger begins by selecting the count of rows from the ACTOR table where the MUSICAL_ID column matches the MUSICAL_ID of the updated row in the MUSICAL table, storing this count in v_actor_count. It then selects the sum of the AGE column from the ACTOR table for the same condition, storing the result in v_total_age. The trigger contains a conditional statement that checks if v_actor_count is greater than zero and if the RESULT column value in the old version of the row (:OLD.RESULT) is different from the new version (:NEW.RESULT). If both conditions are true, it updates the ACTOR table by appending the new RESULT value to the CHARACTER column for all rows where the MUSICAL_ID matches the updated MUSICAL_ID. Another conditional statement checks if v_total_age is greater than 100. If true, it inserts a new row into the MUSICAL table with the MUSICAL_ID set to the updated MUSICAL_ID plus 1000, the NAME set to 'Legacy Production', the YEAR, AWARD, NOMINEE, and RESULT columns set to the corresponding values from the updated row, and the CATEGORY column set to 'Veteran Cast'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_musical_after_update\nAFTER UPDATE ON MUSICAL\nFOR EACH ROW\nDECLARE\n    v_actor_count NUMBER;\n    v_total_age NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_actor_count FROM ACTOR WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n    SELECT SUM(AGE) INTO v_total_age FROM ACTOR WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n    IF v_actor_count > 0 AND :OLD.RESULT != :NEW.RESULT THEN\n        UPDATE ACTOR SET CHARACTER = CHARACTER || ' - ' || :NEW.RESULT WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n    END IF;\n    IF v_total_age > 100 THEN\n        INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT) VALUES (:NEW.MUSICAL_ID + 1000, 'Legacy Production', :NEW.YEAR, :NEW.AWARD, 'Veteran Cast', :NEW.NOMINEE, :NEW.RESULT);\n    END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "UPDATE MUSICAL SET RESULT = 'Won' WHERE MUSICAL_ID = 1",
      "UPDATE MUSICAL SET RESULT = 'Lost' WHERE MUSICAL_ID = 2",
      "UPDATE MUSICAL SET RESULT = 'Nominated' WHERE MUSICAL_ID = 3",
      "UPDATE MUSICAL SET RESULT = 'Finalist' WHERE MUSICAL_ID = 1",
      "UPDATE MUSICAL SET RESULT = 'Runner-up' WHERE MUSICAL_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row trigger named trg_musical_after_update on the MUSICAL table. Declare variables to count actors and sum their ages for the updated musical's ID. If the actor count is greater than zero and the old and new RESULT values differ, append the new RESULT to the CHARACTER column for all actors of that musical. If the total age sum exceeds 100, insert a new row into MUSICAL with the ID as the updated ID plus 1000, NAME as 'Legacy Production', other columns from the updated row, and CATEGORY as 'Veteran Cast'.",
    "natural_language": "Alright, so we need a trigger that fires after a row in the MUSICAL table gets updated. Call it 'trg_musical_after_update'. Gotta set up some variables to figure out how many actors are in the updated musical and add up all their ages. If there are actually actors and the old and new 'RESULT' values aren't the same, then tack that new RESULT onto the CHARACTER column for every actor in that musical. Oh, and if the total of all those ages is over 100, we gotta slip a new row into the MUSICAL table. For that new row, make the ID the old updated ID plus 1000, set the NAME to 'Legacy Production', copy the other stuff from the updated row, and mark the CATEGORY as 'Veteran Cast'.",
    "id": 290
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_actor_before_update that fires before any row is updated on the ACTOR table, declaring local variables v_musical_year of type NUMBER and v_category_count of type NUMBER, then for each row being updated, it executes a SELECT statement to retrieve the YEAR column from the MUSICAL table into v_musical_year where the MUSICAL_ID in the MUSICAL table matches the new value of the MUSICAL_ID column from the updating row, and executes another SELECT statement to count rows in the MUSICAL table into v_category_count where the CATEGORY column equals the old value of the CHARACTER column from the updating row, then checks a conditional IF statement where if the new value of the AGE column is greater than the old value of the AGE column and the retrieved v_musical_year is less than 2000, it concatenates the string ' - Veteran' to the new value of the CHARACTER column and assigns the result back to the new CHARACTER column, and then checks another conditional IF statement where if the retrieved v_category_count is greater than 0, it concatenates the old value of the DURATION column with the literal string ' | Updated: ' and the current system year formatted as a four-digit string using the TO_CHAR function with the SYSDATE and 'YYYY' format mask, and assigns the result back to the new DURATION column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_actor_before_update\nBEFORE UPDATE ON ACTOR\nFOR EACH ROW\nDECLARE\n    v_musical_year NUMBER;\n    v_category_count NUMBER;\nBEGIN\n    SELECT YEAR INTO v_musical_year FROM MUSICAL WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n    SELECT COUNT(*) INTO v_category_count FROM MUSICAL WHERE CATEGORY = :OLD.CHARACTER;\n    IF :NEW.AGE > :OLD.AGE AND v_musical_year < 2000 THEN\n        :NEW.CHARACTER := :NEW.CHARACTER || ' - Veteran';\n    END IF;\n    IF v_category_count > 0 THEN\n        :NEW.DURATION := :OLD.DURATION || ' | Updated: ' || TO_CHAR(SYSDATE, 'YYYY');\n    END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "UPDATE ACTOR SET AGE = 27 WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 23 WHERE ACTOR_ID = 2",
      "UPDATE ACTOR SET AGE = 22 WHERE ACTOR_ID = 3",
      "UPDATE ACTOR SET AGE = 28 WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 24 WHERE ACTOR_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_actor_before_update on the ACTOR table. Declare variables v_musical_year and v_category_count. For each row, select the YEAR from MUSICAL where MUSICAL_ID matches :NEW.MUSICAL_ID into v_musical_year. Count rows in MUSICAL where CATEGORY equals :OLD.CHARACTER into v_category_count. If :NEW.AGE > :OLD.AGE and v_musical_year < 2000, set :NEW.CHARACTER to :NEW.CHARACTER || ' - Veteran'. If v_category_count > 0, set :NEW.DURATION to :OLD.DURATION || ' | Updated: ' || TO_CHAR(SYSDATE, 'YYYY').",
    "natural_language": "How can I create a BEFORE UPDATE FOR EACH ROW trigger named trg_actor_before_update on the ACTOR table? The trigger should declare variables v_musical_year and v_category_count. For each row, how do I select the YEAR from MUSICAL where MUSICAL_ID matches :NEW.MUSICAL_ID into v_musical_year, and count rows in MUSICAL where CATEGORY equals :OLD.CHARACTER into v_category_count? Then, if :NEW.AGE > :OLD.AGE and v_musical_year is less than 2000, how do I set :NEW.CHARACTER to :NEW.CHARACTER concatenated with ' - Veteran'? Also, if v_category_count is greater than 0, how do I set :NEW.DURATION to :OLD.DURATION concatenated with ' | Updated: ' and the current year from SYSDATE?",
    "id": 291
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_dog_weight` that is activated `AFTER` an `INSERT` operation occurs on the `TREATMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `TREATMENTS` table. Upon activation, the trigger performs an `UPDATE` operation on the `DOGS` table. Specifically, it modifies the `WEIGHT` column of a particular row in the `DOGS` table. The row to be updated is identified by a `WHERE` clause, which specifies that the `DOG_ID` column in the `DOGS` table must be equal to the `DOG_ID` value of the newly inserted row in the `TREATMENTS` table. This `DOG_ID` value from the newly inserted row is accessed using the `:NEW.DOG_ID` pseudorecord. The new value for the `WEIGHT` column in the `DOGS` table is calculated by first converting the existing `WEIGHT` column's value from its current data type (which is implicitly assumed to be a character type due to the `TO_NUMBER` function call) to a numerical data type using the `TO_NUMBER()` function. To this numerical value, `0.5` is added. The resulting sum is then converted back to a character data type using the `TO_CHAR()` function before being assigned to the `WEIGHT` column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_dog_weight\nAFTER INSERT ON TREATMENTS\nFOR EACH ROW\nBEGIN\n    UPDATE DOGS SET WEIGHT = TO_CHAR(TO_NUMBER(WEIGHT) + 0.5) WHERE DOG_ID = :NEW.DOG_ID;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (4, 1, 9, 'EXAM', '2023-10-01 10:00:00', 300)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (5, 2, 10, 'VAC', '2023-10-02 11:00:00', 150)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (6, 3, 4, 'WALK', '2023-10-03 12:00:00', 50)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (7, 1, 9, 'EXAM', '2023-10-04 13:00:00', 200)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (8, 2, 10, 'VAC', '2023-10-05 14:00:00', 100)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_update_dog_weight on the TREATMENTS table. For each inserted row, update the DOGS table. Set the WEIGHT column to TO_CHAR(TO_NUMBER(WEIGHT) + 0.5) where DOG_ID equals :NEW.DOG_ID.",
    "natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger named trg_update_dog_weight on the TREATMENTS table that, for each new row, updates the DOGS table by setting the WEIGHT column to TO_CHAR(TO_NUMBER(WEIGHT) + 0.5) where DOG_ID matches :NEW.DOG_ID?",
    "id": 292
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_uppercase_owner_city` that is associated with the `OWNERS` table. This trigger is configured to execute its logic *before* any `INSERT` operation or any `UPDATE` operation is performed on a row within the `OWNERS` table. The trigger is defined as a `FOR EACH ROW` trigger, meaning its body will execute once for every single row that is being inserted or updated. The sole operation performed by this trigger is to modify the value of the `CITY` column for the row currently being processed. Specifically, it takes the value that is being provided for the `CITY` column in the new or updated row (referred to as `:NEW.CITY`) and converts it to its uppercase equivalent using the `UPPER()` SQL function. The result of this `UPPER()` function is then assigned back to the `CITY` column of the new or updated row (`:NEW.CITY`), effectively ensuring that the `CITY` column will always store its value in all uppercase letters when a new row is inserted or an existing row is updated in the `OWNERS` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_uppercase_owner_city\nBEFORE INSERT OR UPDATE ON OWNERS\nFOR EACH ROW\nBEGIN\n    :NEW.CITY := UPPER(:NEW.CITY);\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (5, 'John', 'Doe', '123 Main St', 'New York', 'NY', '10001', 'john.doe@example.com', '123-456-7890', '098-765-4321')",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (6, 'Jane', 'Smith', '456 Elm St', 'Los Angeles', 'CA', '90001', 'jane.smith@example.com', '234-567-8901', '987-654-3210')",
      "UPDATE OWNERS SET CITY = 'Chicago' WHERE OWNER_ID = 1",
      "UPDATE OWNERS SET CITY = 'Houston' WHERE OWNER_ID = 3",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (7, 'Alice', 'Johnson', '789 Oak St', 'Miami', 'FL', '33101', 'alice.johnson@example.com', '345-678-9012', '876-543-2109')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_uppercase_owner_city on the OWNERS table. For each row, set :NEW.CITY to UPPER(:NEW.CITY).",
    "natural_language": "Develop a trigger named trg_uppercase_owner_city, which is designed to activate automatically before any new row is inserted into or any existing row is updated within the OWNERS table. This trigger, executing meticulously for each individual row, will consistently and reliably transform the value in the CITY field of the :NEW pseudorecord, converting it entirely to uppercase letters.",
    "id": 293
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_treatment_cost that fires automatically before any INSERT or UPDATE operation is performed on the TREATMENTS table for each affected row, and within its execution block, it assigns a new value to the COST_OF_TREATMENT column of the newly inserted or updated row (referenced by the :NEW pseudorecord) by applying the LEAST function, which compares the incoming value of :NEW.COST_OF_TREATMENT with the constant numeric value 500 and returns the smaller of the two, thereby ensuring the COST_OF_TREATMENT is capped at a maximum of 500 for the operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_treatment_cost\nBEFORE INSERT OR UPDATE ON TREATMENTS\nFOR EACH ROW\nBEGIN\n    :NEW.COST_OF_TREATMENT := LEAST(:NEW.COST_OF_TREATMENT, 500);\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (4, 1, 5, 'EXAM', '2023-10-01 10:00:00', 600)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (5, 2, 6, 'VAC', '2023-10-02 11:00:00', 550)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (6, 3, 7, 'WALK', '2023-10-03 12:00:00', 700)",
      "UPDATE TREATMENTS SET COST_OF_TREATMENT = 650 WHERE TREATMENT_ID = 1",
      "UPDATE TREATMENTS SET COST_OF_TREATMENT = 800 WHERE TREATMENT_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_update_treatment_cost on the TREATMENTS table. For each row, set :NEW.COST_OF_TREATMENT to LEAST(:NEW.COST_OF_TREATMENT, 500).",
    "natural_language": "Set up a BEFORE INSERT OR UPDATE FOR EACH ROW trigger called trg_update_treatment_cost on the TREATMENTS table to cap the :NEW.COST_OF_TREATMENT at 500 for each row.",
    "id": 294
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_standardize_zip_code that fires before any INSERT or UPDATE operation on the OWNERS table for each affected row, and within the trigger body, it modifies the new value for the ZIP_CODE column by applying the LPAD function to it, which pads the left side of the original :NEW.ZIP_CODE value with the character '0' until the resulting string reaches a total length of 5 characters, thereby standardizing the ZIP_CODE format to a 5-digit zero-padded string for the data being inserted or updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_standardize_zip_code\nBEFORE INSERT OR UPDATE ON OWNERS\nFOR EACH ROW\nBEGIN\n    :NEW.ZIP_CODE := LPAD(:NEW.ZIP_CODE, 5, '0');\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (5, 'John', 'Doe', '123 Main St', 'Anytown', 'Anystate', '123', 'john.doe@example.com', '123-456-7890', '098-765-4321')",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (6, 'Jane', 'Smith', '456 Elm St', 'Othertown', 'Otherstate', '45', 'jane.smith@example.com', '234-567-8901', '987-654-3210')",
      "UPDATE OWNERS SET ZIP_CODE = '789' WHERE OWNER_ID = 1",
      "UPDATE OWNERS SET ZIP_CODE = '12' WHERE OWNER_ID = 3",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (7, 'Alice', 'Johnson', '789 Pine St', 'Sometown', 'Somestate', '6789', 'alice.johnson@example.com', '345-678-9012', '876-543-2109')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_standardize_zip_code on the OWNERS table. For each row, set :NEW.ZIP_CODE to LPAD(:NEW.ZIP_CODE, 5, '0').",
    "natural_language": "Set up a BEFORE INSERT OR UPDATE FOR EACH ROW trigger called trg_standardize_zip_code on the OWNERS table. For each new or updated row, pad the :NEW.ZIP_CODE value with leading zeros to ensure it is five characters long.",
    "id": 295
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_dog_age that is defined to fire BEFORE INSERT on the DOGS table for each individual row being inserted, and within its body, it performs a calculation to derive an age value from the incoming row's DATE_OF_BIRTH column, which is expected to be a string in the 'YYYY-MM-DD HH24:MI:SS' format, by first converting this string to a date using the TO_DATE function with the specified format mask, then extracting the year component from that resulting date using the EXTRACT(YEAR FROM ...) function, then extracting the current year from the system date SYSDATE using the same EXTRACT function, subtracting the birth year from the current year to get a numerical year difference, converting this numerical result to a character string using the TO_CHAR function, and finally assigning this computed character string value directly to the :NEW.AGE pseudo-column of the row that is about to be inserted into the DOGS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_dog_age\nBEFORE INSERT ON DOGS\nFOR EACH ROW\nBEGIN\n    -- Calculate age based on the DATE_OF_BIRTH of the new row\n    -- and assign it directly to the :NEW.AGE pseudo-column.\n    -- This avoids the mutating table error by modifying the row before it's inserted.\n    :NEW.AGE := TO_CHAR(EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(:NEW.DATE_OF_BIRTH, 'YYYY-MM-DD HH24:MI:SS')));\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED, DATE_DEPARTED) VALUES (4, 1, '0', 'ESK', 'MED', 'Buddy', '2015-03-15 10:00:00', '1', '5.5', '2023-10-01 12:00:00', NULL, NULL)",
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED, DATE_DEPARTED) VALUES (5, 3, '1', 'BUL', 'LGE', 'Max', '2010-06-20 08:30:00', '0', '10.2', '2023-10-02 14:00:00', NULL, NULL)",
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED, DATE_DEPARTED) VALUES (6, 11, '0', 'HUS', 'SML', 'Bella', '2018-11-05 09:45:00', '1', '3.8', '2023-10-03 16:00:00', NULL, NULL)",
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED, DATE_DEPARTED) VALUES (7, 4, '0', 'ESK', 'MED', 'Charlie', '2012-02-28 11:15:00', '0', '6.7', '2023-10-04 18:00:00', NULL, NULL)",
      "INSERT INTO DOGS (DOG_ID, OWNER_ID, ABANDONED_YN, BREED_CODE, SIZE_CODE, NAME, DATE_OF_BIRTH, GENDER, WEIGHT, DATE_ARRIVED, DATE_ADOPTED, DATE_DEPARTED) VALUES (8, 1, '1', 'BUL', 'LGE', 'Lucy', '2016-07-12 07:30:00', '1', '8.9', '2023-10-05 20:00:00', NULL, NULL)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_update_dog_age on the DOGS table. Calculate the dog's age by converting the DATE_OF_BIRTH string ('YYYY-MM-DD HH24:MI:SS') to a date, extracting the year, subtracting it from the current year, and assign the result as a string to the :NEW.AGE column.",
    "natural_language": "Hey, set up a trigger called trg_update_dog_age for the DOGS table that fires before each new row is added. You gotta figure out the pup's age by taking its DATE_OF_BIRTH string (which looks like 'YYYY-MM-DD HH24:MI:SS'), turning that into a proper date, and then pulling out the year. Just subtract that birth year from this year, and slap the result as a string into the :NEW.AGE column.",
    "id": 296
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_manufacturer_revenue_delete` that is activated `AFTER` a `DELETE` operation occurs on the `PRODUCTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is deleted from the `PRODUCTS` table. When activated, the trigger performs an `UPDATE` operation on the `MANUFACTURERS` table. Specifically, it modifies the `REVENUE` column in the `MANUFACTURERS` table by subtracting the `PRICE` value of the row that was just deleted from the `PRODUCTS` table. The `PRICE` value is accessed using the `:OLD.PRICE` pseudorecord, which refers to the `PRICE` column of the row being deleted. This update is applied only to the row in the `MANUFACTURERS` table where the `CODE` column matches the `MANUFACTURER` value of the row that was just deleted from the `PRODUCTS` table. The `MANUFACTURER` value is accessed using the `:OLD.MANUFACTURER` pseudorecord, which refers to the `MANUFACTURER` column of the row being deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_manufacturer_revenue_delete\nAFTER DELETE ON PRODUCTS\nFOR EACH ROW\nBEGIN\nUPDATE MANUFACTURERS SET REVENUE = REVENUE - :OLD.PRICE WHERE CODE = :OLD.MANUFACTURER;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "DELETE FROM PRODUCTS WHERE CODE = 1",
      "DELETE FROM PRODUCTS WHERE CODE = 2",
      "DELETE FROM PRODUCTS WHERE CODE = 3",
      "DELETE FROM PRODUCTS WHERE CODE = 4",
      "DELETE FROM PRODUCTS WHERE CODE = 5"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_manufacturer_revenue_delete on the PRODUCTS table. For each deleted row, update the MANUFACTURERS table by subtracting the :OLD.PRICE from the REVENUE column where the MANUFACTURERS.CODE equals the :OLD.MANUFACTURER.",
    "natural_language": "How can I create an AFTER DELETE FOR EACH ROW trigger named trg_manufacturer_revenue_delete on the PRODUCTS table so that, for each deleted row, it updates the MANUFACTURERS table by subtracting the :OLD.PRICE from the REVENUE column where the MANUFACTURERS.CODE matches the :OLD.MANUFACTURER?",
    "id": 297
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_revenue_adjustment` that is activated after an `UPDATE` operation on the `PRICE` column of the `PRODUCTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `PRODUCTS` table. Upon activation, the trigger performs a single `UPDATE` operation on the `MANUFACTURERS` table. Specifically, it modifies the `REVENUE` column in the `MANUFACTURERS` table by adding the difference between the new `PRICE` value and the old `PRICE` value from the updated `PRODUCTS` row. The `REVENUE` column is updated for the specific manufacturer whose `CODE` column matches the `MANUFACTURER` column value from the newly updated `PRODUCTS` row. The `:NEW.PRICE` pseudo-record variable represents the new value of the `PRICE` column after the update on the `PRODUCTS` table, and the `:OLD.PRICE` pseudo-record variable represents the old value of the `PRICE` column before the update on the `PRODUCTS` table. The `:NEW.MANUFACTURER` pseudo-record variable represents the new value of the `MANUFACTURER` column after the update on the `PRODUCTS` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_revenue_adjustment\nAFTER UPDATE OF PRICE ON PRODUCTS\nFOR EACH ROW\nBEGIN\nUPDATE MANUFACTURERS SET REVENUE = REVENUE + (:NEW.PRICE - :OLD.PRICE) WHERE CODE = :NEW.MANUFACTURER;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "UPDATE PRODUCTS SET PRICE = 250 WHERE CODE = 1",
      "UPDATE PRODUCTS SET PRICE = 130 WHERE NAME = 'Memory'",
      "UPDATE PRODUCTS SET PRICE = 160 WHERE MANUFACTURER = 4",
      "UPDATE PRODUCTS SET PRICE = 200 WHERE CODE = 1 AND MANUFACTURER = 5",
      "UPDATE PRODUCTS SET PRICE = 100 WHERE NAME = 'ZIP drive'"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_revenue_adjustment on the PRODUCTS table, firing when the PRICE column is updated. Update the MANUFACTURERS table by adding the difference (:NEW.PRICE - :OLD.PRICE) to the REVENUE column where the MANUFACTURERS.CODE equals the :NEW.MANUFACTURER.",
    "natural_language": "Alright, so we need a trigger that kicks in after someone updates a row in the PRODUCTS table, specifically when the PRICE gets changed. Name it 'trg_revenue_adjustment'. What it should do is take the price difference (the new price minus the old one) and add that amount to the REVENUE column over in the MANUFACTURERS table, but only for the manufacturer whose CODE matches the one on this updated product.",
    "id": 298
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_school_enrollment that is defined to fire automatically after each row insertion into the PLAYER table, and within its execution block, it declares a local variable v_enrollment of type NUMBER; the trigger's logic begins by initiating a nested PL/SQL block where it first attempts to select the ENROLLMENT column value from the SCHOOL table into the variable v_enrollment, using a condition that the SCHOOL_ID column in the SCHOOL table must equal the newly inserted SCHOOL_ID value from the :NEW pseudorecord of the PLAYER table; if this select operation successfully finds a matching school record, the trigger then proceeds to update the SCHOOL table by incrementing the ENROLLMENT column value by one for the specific row where the SCHOOL_ID matches the :NEW.SCHOOL_ID value; the trigger includes an exception handling section for this nested block that catches the NO_DATA_FOUND exception, which occurs when the SELECT statement finds no matching SCHOOL_ID in the SCHOOL table, and in this case the trigger performs a NULL operation, meaning it takes no action and allows the original player insertion to complete without updating any school enrollment; the exception handler also catches any other unexpected exceptions using the WHEN OTHERS clause and responds by re-raising the caught exception using the RAISE statement to propagate the error outward.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_school_enrollment\nAFTER INSERT ON PLAYER\nFOR EACH ROW\nDECLARE\n    v_enrollment NUMBER;\nBEGIN\n    BEGIN\n        SELECT ENROLLMENT INTO v_enrollment FROM SCHOOL WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n        -- If a school is found, update its enrollment\n        UPDATE SCHOOL SET ENROLLMENT = ENROLLMENT + 1 WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            -- Handle the case where the SCHOOL_ID from the new player does not exist in the SCHOOL table.\n            -- Depending on business rules, one might log this, raise a custom error, or simply do nothing.\n            -- For this exercise, we'll simply do nothing, allowing the player insert to proceed\n            -- but not updating a non-existent school's enrollment.\n            NULL;\n        WHEN OTHERS THEN\n            -- Catch any other unexpected errors during the SELECT or UPDATE\n            RAISE; -- Re-raise the exception to propagate it\n    END;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (101, 'New Player 1', 'Team A', 18, 'Forward', 2)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (102, 'New Player 2', 'Team B', 17, 'Guard', 3)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (103, 'New Player 3', 'Team C', 16, 'Center', 4)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (104, 'New Player 4', 'Team D', 19, 'Defender', 1)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (105, 'New Player 5', 'Team E', 15, 'Midfielder', 5)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_update_school_enrollment on the PLAYER table. Declare a variable v_enrollment. In a nested block, select the SCHOOL.ENROLLMENT into v_enrollment where SCHOOL_ID = :NEW.SCHOOL_ID. If found, update SCHOOL.ENROLLMENT by 1 for that SCHOOL_ID. Handle NO_DATA_FOUND by doing nothing and re-raise any other exception.",
    "natural_language": "Create a trigger named trg_update_school_enrollment on the PLAYER table that fires AFTER INSERT FOR EACH ROW. First, declare a variable v_enrollment. Then, within a nested block, select the SCHOOL.ENROLLMENT into v_enrollment where SCHOOL_ID equals the new row's SCHOOL_ID. If the record is found, update the SCHOOL.ENROLLMENT by incrementing it by 1 for that SCHOOL_ID. Handle the NO_DATA_FOUND exception by doing nothing, but re-raise any other exception that occurs.",
    "id": 299
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_school_performance that is executed before an insert operation on the SCHOOL_PERFORMANCE table for each row being inserted. The trigger declares a local variable v_school_count of type NUMBER to store the count of records. It performs a SELECT operation to count the number of rows in the SCHOOL table where the SCHOOL_ID column matches the SCHOOL_ID value of the new row being inserted into the SCHOOL_PERFORMANCE table, using the :NEW.SCHOOL_ID syntax to reference the new row's SCHOOL_ID. The result of this count is stored in the v_school_count variable. The trigger then evaluates a conditional statement: if the value of v_school_count is equal to zero, indicating that no matching SCHOOL_ID exists in the SCHOOL table, it raises an application error with the error code -20001 and a message stating 'Invalid SCHOOL_ID: ' followed by the SCHOOL_ID value from the new row, indicating that this SCHOOL_ID does not exist in the SCHOOL table. This prevents the insertion of the new row into the SCHOOL_PERFORMANCE table if the SCHOOL_ID is invalid.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_school_performance\nBEFORE INSERT ON SCHOOL_PERFORMANCE\nFOR EACH ROW\nDECLARE\n    v_school_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_school_count FROM SCHOOL WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    IF v_school_count = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Invalid SCHOOL_ID: ' || :NEW.SCHOOL_ID || ' does not exist in SCHOOL table.');\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (2, '1990-91', 'New Class A', 'New Class AA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (3, '1991-92', 'Another Class A', 'Another Class AA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (4, '1992-93', 'Different Class A', 'Different Class AA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (2, '1993-94', 'Sample Class A', 'Sample Class AA')",
      "INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA) VALUES (3, '1994-95', 'Example Class A', 'Example Class AA')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_check_school_performance on the SCHOOL_PERFORMANCE table. Declare a variable v_school_count. Count rows in the SCHOOL table where SCHOOL_ID = :NEW.SCHOOL_ID. If the count is zero, raise an application error (-20001) with the message 'Invalid SCHOOL_ID: ' || :NEW.SCHOOL_ID.",
    "natural_language": "How can I create a BEFORE INSERT FOR EACH ROW trigger named trg_check_school_performance on the SCHOOL_PERFORMANCE table? The trigger should declare a variable v_school_count, count the rows in the SCHOOL table where SCHOOL_ID equals :NEW.SCHOOL_ID, and if the count is zero, raise an application error (-20001) with the message 'Invalid SCHOOL_ID: ' concatenated with :NEW.SCHOOL_ID.",
    "id": 300
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_colors_update that is executed after an update operation on the SCHOOL table for each row affected by the update. The trigger declares a local variable v_colors of type VARCHAR2 with a maximum length of 255 characters. It begins by selecting the COLORS column from the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the row before the update, referred to as :OLD.SCHOOL_ID, and stores the result in the v_colors variable. The trigger then checks if v_colors is not null, indicating that the COLORS column in SCHOOL_DETAILS has a value for the corresponding SCHOOL_ID. If this condition is true, the trigger proceeds to update the SCHOOL_DETAILS table by setting the COLORS column to the new value of SCHOOL_COLORS from the updated row in the SCHOOL table, identified by :NEW.SCHOOL_COLORS, for the same SCHOOL_ID that matches :OLD.SCHOOL_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_colors_update\nAFTER UPDATE ON SCHOOL\nFOR EACH ROW\nDECLARE\n    v_colors VARCHAR2(255);\nBEGIN\n    SELECT COLORS INTO v_colors FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    IF v_colors IS NOT NULL THEN\n        UPDATE SCHOOL_DETAILS SET COLORS = :NEW.SCHOOL_COLORS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Green & Yellow' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Purple & Gold' WHERE SCHOOL_ID = 3",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Orange & Black' WHERE SCHOOL_ID = 4",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Blue & White' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Maroon & Silver' WHERE SCHOOL_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_school_colors_update on the SCHOOL table. It retrieves the existing COLORS value from SCHOOL_DETAILS for the OLD.SCHOOL_ID. If a value exists, it updates the SCHOOL_DETAILS.COLORS with the NEW.SCHOOL_COLORS value for the same SCHOOL_ID.",
    "natural_language": "Create a row-level trigger called trg_school_colors_update that fires AFTER UPDATE on the SCHOOL table. For each updated row, fetch the current COLORS value from SCHOOL_DETAILS using the OLD.SCHOOL_ID. If a record is found, update the SCHOOL_DETAILS.COLORS value to match the NEW.SCHOOL_COLORS for that SCHOOL_ID.",
    "id": 301
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_ARTIST_AGE_CHECK that fires before any INSERT or UPDATE operation on the ARTIST table for each affected row, declaring a local variable v_count of type NUMBER, and within its execution block, it checks the value of the AGE column in the new row data referenced by :NEW.AGE, applying a conditional logic where if the new age value is less than 0, it sets the :NEW.AGE column value to 0, and alternatively, if the new age value is greater than 150, it sets the :NEW.AGE column value to 150.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ARTIST_AGE_CHECK\nBEFORE INSERT OR UPDATE ON ARTIST\nFOR EACH ROW\nDECLARE\n    v_count NUMBER;\nBEGIN\n    IF :NEW.AGE < 0 THEN\n        :NEW.AGE := 0;\n    ELSIF :NEW.AGE > 150 THEN\n        :NEW.AGE := 150;\n    END IF;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (5, 'New Artist', -5, 'New Title', 'January 1, 2023')",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (6, 'Another Artist', 200, 'Another Title', 'February 2, 2023')",
      "UPDATE ARTIST SET AGE = -10 WHERE ARTIST_ID = 1",
      "UPDATE ARTIST SET AGE = 160 WHERE ARTIST_ID = 2",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (7, 'Third Artist', 151, 'Third Title', 'March 3, 2023')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_ARTIST_AGE_CHECK on the ARTIST table. It validates the NEW.AGE value, setting it to 0 if less than 0, or to 150 if greater than 150.",
    "natural_language": "Hey, can you set up a trigger called TRG_ARTIST_AGE_CHECK for the ARTIST table? It should fire off before any new row is added or an existing one is updated. Basically, it needs to check the incoming AGE value. If it's a negative number, just bump it up to 0. If it's crazy high, like over 150, cap it at 150. Keep things in a sensible range.",
    "id": 302
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_ARTIST_TITLE_UPDATE that is executed before an insert or update operation on the ARTIST table for each row being processed. The trigger first declares a local variable v_count of type NUMBER to store the result of a count query. It then checks if the length of the new value for the FAMOUS_TITLE column in the ARTIST table exceeds 100 characters. If it does, the trigger truncates the FAMOUS_TITLE to the first 100 characters using the SUBSTR function. Next, the trigger performs a SELECT statement to count the number of rows in the MUSIC_FESTIVAL table where the VOLUME column matches the new ARTIST_ID value from the ARTIST table. The result of this count is stored in the v_count variable. If v_count equals zero, indicating that there are no matching rows in the MUSIC_FESTIVAL table, the trigger sets the FAMOUS_TITLE column of the ARTIST table to the string 'Unknown'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ARTIST_TITLE_UPDATE\nBEFORE INSERT OR UPDATE ON ARTIST\nFOR EACH ROW\nDECLARE\n    v_count NUMBER; -- Declare the variable v_count\nBEGIN\n    IF LENGTH(:NEW.FAMOUS_TITLE) > 100 THEN\n        :NEW.FAMOUS_TITLE := SUBSTR(:NEW.FAMOUS_TITLE, 1, 100);\n    END IF;\n    SELECT COUNT(*) INTO v_count FROM MUSIC_FESTIVAL WHERE VOLUME = :NEW.ARTIST_ID;\n    IF v_count = 0 THEN\n        :NEW.FAMOUS_TITLE := 'Unknown';\n    END IF;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (5, 'New Artist', 30, 'A Very Long Title That Exceeds The Maximum Length Allowed For This Field', 'December 2023')",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (6, 'Another Artist', 28, 'Short Title', 'January 2024')",
      "UPDATE ARTIST SET FAMOUS_TITLE = 'An Even Longer Title That Will Be Trimmed To Fit The Maximum Length Requirement' WHERE ARTIST_ID = 1",
      "UPDATE ARTIST SET FAMOUS_TITLE = 'Title Update Test' WHERE ARTIST_ID = 2",
      "INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE, FAMOUS_TITLE, FAMOUS_RELEASE_DATE) VALUES (7, 'Newcomer', 22, 'Title That Will Be Set To Unknown', 'February 2024')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_ARTIST_TITLE_UPDATE on the ARTIST table. It truncates NEW.FAMOUS_TITLE to 100 characters if longer. It then checks if the NEW.ARTIST_ID exists in the MUSIC_FESTIVAL.VOLUME column. If no match is found, it sets NEW.FAMOUS_TITLE to 'Unknown'.",
    "natural_language": "Create a row-level trigger named TRG_ARTIST_TITLE_UPDATE for the ARTIST table that fires BEFORE INSERT OR UPDATE. First, truncate the NEW.FAMOUS_TITLE value to 100 characters if it exceeds that length. Then, check if the NEW.ARTIST_ID exists within the MUSIC_FESTIVAL.VOLUME column. If the ID is not found, set NEW.FAMOUS_TITLE to 'Unknown'.",
    "id": 303
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_VOLUME_SONG_CHECK that is executed before an insert or update operation on the VOLUME table for each row affected. The trigger begins by declaring a local variable v_count of type NUMBER. It checks if the SONG column in the new row (:NEW.SONG) is NULL, and if so, assigns the value 'Untitled' to it. Next, the trigger evaluates whether the ARTIST_ID column in the new row (:NEW.ARTIST_ID) is not NULL. If this condition is true, it performs a SELECT COUNT(*) query on the ARTIST table to count the number of rows where the ARTIST_ID matches the value in :NEW.ARTIST_ID, storing the result in the v_count variable. If v_count equals zero, indicating that no matching ARTIST_ID exists in the ARTIST table, the trigger sets :NEW.ARTIST_ID to NULL.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_VOLUME_SONG_CHECK\nBEFORE INSERT OR UPDATE ON VOLUME\nFOR EACH ROW\nDECLARE\n    v_count NUMBER;\nBEGIN\n    IF :NEW.SONG IS NULL THEN\n        :NEW.SONG := 'Untitled';\n    END IF;\n    \n    IF :NEW.ARTIST_ID IS NOT NULL THEN\n        SELECT COUNT(*) INTO v_count FROM ARTIST WHERE ARTIST_ID = :NEW.ARTIST_ID;\n        IF v_count = 0 THEN\n            :NEW.ARTIST_ID := NULL;\n        END IF;\n    END IF;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (10, '46:01', 'January 1, 2024', 2, 'My New Song', 1)",
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (11, '46:02', 'January 8, 2024', 1, NULL, 2)",
      "UPDATE VOLUME SET SONG = 'Updated Song Title', ARTIST_ID = 4 WHERE VOLUME_ID = 10",
      "INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, ISSUE_DATE, WEEKS_ON_TOP, SONG, ARTIST_ID) VALUES (12, '46:03', 'January 15, 2024', 3, 'Another Hit', 999)",
      "UPDATE VOLUME SET ARTIST_ID = NULL WHERE VOLUME_ID = 11"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_VOLUME_SONG_CHECK on the VOLUME table. It sets NEW.SONG to 'Untitled' if NULL. If NEW.ARTIST_ID is not NULL, it verifies the ID exists in the ARTIST table. If it does not exist, it sets NEW.ARTIST_ID to NULL.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE row-level trigger designated as TRG_VOLUME_SONG_CHECK for the VOLUME table. The trigger's function is to assign the value 'Untitled' to the NEW.SONG attribute should it be found to be NULL. Furthermore, if the NEW.ARTIST_ID attribute is not NULL, the trigger must validate the existence of this identifier within the ARTIST table. In the event the identifier is not present, the trigger is to set the NEW.ARTIST_ID attribute to NULL.",
    "id": 304
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_audit that is executed before an insert or update operation on the SCHOOL table for each row affected. The trigger declares a local variable v_count of type NUMBER to store the count of records. It performs a SELECT operation to count the number of rows in the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the new row being inserted or updated. If the operation is an insert, the trigger checks if v_count is zero, indicating no existing record in SCHOOL_DETAILS for the given SCHOOL_ID. If true, it inserts a new row into SCHOOL_DETAILS with SCHOOL_ID set to the new row's SCHOOL_ID, NICKNAME set to the first 10 characters of the new row's SCHOOL column, and COLORS set to 'Unknown', while LEAGUE, CLASS, and DIVISION are set to NULL. If the operation is an update, the trigger checks if v_count is greater than zero, indicating an existing record in SCHOOL_DETAILS for the given SCHOOL_ID. If true, it updates the COLORS column in SCHOOL_DETAILS to the new row's SCHOOL_COLORS where SCHOOL_ID matches the new row's SCHOOL_ID. If v_count is zero, it inserts a new row into SCHOOL_DETAILS with SCHOOL_ID set to the new row's SCHOOL_ID, NICKNAME set to the first 10 characters of the new row's SCHOOL column, COLORS set to the new row's SCHOOL_COLORS, and LEAGUE, CLASS, and DIVISION set to NULL. The trigger includes an exception handler for the DUP_VAL_ON_INDEX exception, which does nothing when this exception occurs.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_audit\nBEFORE INSERT OR UPDATE ON SCHOOL\nFOR EACH ROW\nDECLARE\n   v_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_count FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n   \n   IF INSERTING THEN\n      IF v_count = 0 THEN\n         INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION) \n         VALUES (:NEW.SCHOOL_ID, SUBSTR(:NEW.SCHOOL, 1, 10), 'Unknown', NULL, NULL, NULL);\n      END IF;\n   ELSIF UPDATING THEN\n      IF v_count > 0 THEN\n         UPDATE SCHOOL_DETAILS \n         SET COLORS = :NEW.SCHOOL_COLORS \n         WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n      ELSE\n         INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION)\n         VALUES (:NEW.SCHOOL_ID, SUBSTR(:NEW.SCHOOL, 1, 10), :NEW.SCHOOL_COLORS, NULL, NULL, NULL);\n      END IF;\n   END IF;\nEXCEPTION\n   WHEN DUP_VAL_ON_INDEX THEN\n      NULL;\nEND;",
    "database_name": "school_player",
    "tables": [
      "SCHOOL",
      "SCHOOL_DETAILS"
    ],
    "call_sqls": [
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (10, 'New School A', 'Sydney', 500, 2000, 'Anglican', 'Co-ed', 'Day', 2010, 'Green & Gold')",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (11, 'Another School B', 'Melbourne', 750, 1995, 'Catholic', 'Boys', 'Day & Boarding', 2005, 'Blue & White')",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Purple & Yellow' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Orange & Black', ENROLLMENT = 1200 WHERE SCHOOL_ID = 3",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (12, 'Test School C', 'Brisbane', 300, 2015, 'Uniting Church', 'Girls', 'Day', 2018, 'Pink & Grey')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_school_audit on the SCHOOL table. It checks if a SCHOOL_DETAILS record exists for the NEW.SCHOOL_ID. For INSERTs with no existing record, it inserts a new SCHOOL_DETAILS row with default values. For UPDATEs, it updates the existing SCHOOL_DETAILS.COLORS or inserts a new row if none exists. Handle DUP_VAL_ON_INDEX by ignoring it.",
    "natural_language": "Create a row-level trigger named trg_school_audit on the SCHOOL table to fire BEFORE INSERT OR UPDATE. For each row, check if a SCHOOL_DETAILS record exists for the NEW.SCHOOL_ID. If it's an INSERT and no record exists, insert a new SCHOOL_DETAILS row with default values. If it's an UPDATE, update the existing SCHOOL_DETAILS.COLORS or insert a new row if none exists. Ignore any DUP_VAL_ON_INDEX exception.",
    "id": 305
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_location_update that fires automatically after any row in the SCHOOL table has its LOCATION column updated, executing the following logic for each affected row: first, it checks if the old LOCATION value is different from the new LOCATION value; if they are different, it performs three distinct data manipulation operations on the SCHOOL_DETAILS table using the new SCHOOL_ID value from the updated SCHOOL row: it executes an UPDATE statement to set the LEAGUE column to the first four characters of the new LOCATION, converted to uppercase via the UPPER and SUBSTR functions, for all SCHOOL_DETAILS records matching the SCHOOL_ID; it then executes a DELETE statement to remove any SCHOOL_DETAILS records for that SCHOOL_ID where the NICKNAME column is NULL; finally, it uses a MERGE statement to conditionally insert or update a record in SCHOOL_DETAILS, sourcing data from a dual-row subquery containing the new SCHOOL_ID, the new SCHOOL_COLORS, and a literal string 'Updated' for league_val, with the merge condition being a match on SCHOOL_ID: if a matching SCHOOL_DETAILS row exists, it updates that row's COLORS column with the school_colors value and the LEAGUE column with the 'Updated' literal; if no match is found, it inserts a new row into SCHOOL_DETAILS with columns SCHOOL_ID, COLORS, and LEAGUE populated from the source values.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_location_update\nAFTER UPDATE OF LOCATION ON SCHOOL\nFOR EACH ROW\nBEGIN\n   IF :OLD.LOCATION != :NEW.LOCATION THEN\n      -- Update the LEAGUE for the existing school detail record\n      UPDATE SCHOOL_DETAILS SET LEAGUE = UPPER(SUBSTR(:NEW.LOCATION, 1, 4)) WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n\n      -- Delete school detail records where NICKNAME is NULL for the updated school\n      -- This might remove the only record for the school if NICKNAME was NULL\n      DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID AND NICKNAME IS NULL;\n\n      -- Use MERGE to either update an existing row or insert a new one,\n      -- preventing ORA-00001 if a row already exists for :NEW.SCHOOL_ID.\n      MERGE INTO SCHOOL_DETAILS sd\n      USING (SELECT :NEW.SCHOOL_ID AS school_id,\n                    :NEW.SCHOOL_COLORS AS school_colors,\n                    'Updated' AS league_val\n             FROM DUAL) src\n      ON (sd.SCHOOL_ID = src.school_id)\n      WHEN MATCHED THEN\n        UPDATE SET sd.COLORS = src.school_colors,\n                   sd.LEAGUE = src.league_val\n      WHEN NOT MATCHED THEN\n        INSERT (SCHOOL_ID, COLORS, LEAGUE)\n        VALUES (src.school_id, src.school_colors, src.league_val);\n   END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "SCHOOL",
      "SCHOOL_DETAILS"
    ],
    "call_sqls": [
      "UPDATE SCHOOL SET LOCATION = 'New Hornsby', SCHOOL_COLORS = 'Green & Gold' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET LOCATION = 'New Bellevue Hill', SCHOOL_COLORS = 'Purple & White' WHERE SCHOOL_ID = 3",
      "UPDATE SCHOOL SET LOCATION = 'New Wahroonga', SCHOOL_COLORS = 'Orange & Black' WHERE SCHOOL_ID = 4",
      "UPDATE SCHOOL SET LOCATION = 'Updated Location A', SCHOOL_COLORS = 'Silver & Gold' WHERE SCHOOL_ID = 1",
      "UPDATE SCHOOL SET LOCATION = 'Updated Location B', SCHOOL_COLORS = 'Brown & Beige' WHERE SCHOOL_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_school_location_update on the SCHOOL table. When the LOCATION column is updated, for each affected row: 1) Update SCHOOL_DETAILS, setting LEAGUE to the first four uppercase characters of the new LOCATION for matching SCHOOL_ID. 2) Delete SCHOOL_DETAILS records for that SCHOOL_ID where NICKNAME is NULL. 3) Use MERGE to insert or update SCHOOL_DETAILS: if a row with the SCHOOL_ID exists, update its COLORS and set LEAGUE to 'Updated'; otherwise, insert a new row with SCHOOL_ID, COLORS, and LEAGUE.",
    "natural_language": "How can I create an AFTER UPDATE row-level trigger named trg_school_location_update on the SCHOOL table so that, whenever the LOCATION column is updated for a row, it performs the following actions: first, update the SCHOOL_DETAILS table to set the LEAGUE to the first four uppercase characters of the new LOCATION for the matching SCHOOL_ID; second, delete any records in SCHOOL_DETAILS for that SCHOOL_ID where the NICKNAME is NULL; and third, use a MERGE statement to either insert a new row into SCHOOL_DETAILS with the SCHOOL_ID, COLORS, and LEAGUE if one doesn't exist, or update the existing row's COLORS and set its LEAGUE to 'Updated'?",
    "id": 306
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_details_cleanup that is executed before a delete operation on the SCHOOL table for each row that is about to be deleted. The trigger performs two main operations: first, it deletes all records from the SCHOOL_DETAILS table where the SCHOOL_ID column matches the SCHOOL_ID of the row being deleted from the SCHOOL table, using the :OLD.SCHOOL_ID reference to access the SCHOOL_ID of the row that is being deleted. Second, it inserts a new record into the SCHOOL_DETAILS table with the SCHOOL_ID set to the same value as the deleted row's SCHOOL_ID, the NICKNAME column set to the string 'Archived', and the COLORS column set to the string 'Gray'. This ensures that any existing details associated with the school being deleted are removed, and a new record is inserted to indicate that the school has been archived.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_details_cleanup\nBEFORE DELETE ON SCHOOL\nFOR EACH ROW\nBEGIN\n   -- Delete all existing records for this SCHOOL_ID first\n   DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n   \n   -- Insert the archived record\n   INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS) VALUES (:OLD.SCHOOL_ID, 'Archived', 'Gray');\nEND;",
    "database_name": "school_player",
    "tables": [
      "SCHOOL",
      "SCHOOL_DETAILS"
    ],
    "call_sqls": [
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 2",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 3",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 4",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 1",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_school_details_cleanup on the SCHOOL table. For each row to be deleted: 1) Delete all records from SCHOOL_DETAILS where SCHOOL_ID equals the OLD.SCHOOL_ID. 2) Insert a new record into SCHOOL_DETAILS with SCHOOL_ID set to OLD.SCHOOL_ID, NICKNAME set to 'Archived', and COLORS set to 'Gray'.",
    "natural_language": "Hey, set up a trigger called trg_school_details_cleanup that fires before you delete a row from the SCHOOL table. For each school row you're about to axe: 1) First, wipe out all the records in SCHOOL_DETAILS that have the same SCHOOL_ID as the old one. 2) Then, pop a new record into SCHOOL_DETAILS for that old SCHOOL_ID, setting its NICKNAME to 'Archived' and its COLORS to 'Gray'.",
    "id": 307
  },
  {
    "ir": "Write an Oracle PL/SQL package and two triggers that manage school enrollment data. The package, named school_pkg, defines a PL/SQL associative array type called school_id_table, which stores school IDs as numbers indexed by PLS_INTEGER. It also declares a global variable g_school_ids of this type and a global index variable g_index initialized to zero. The first trigger, trg_school_enrollment_check_row, is a row-level trigger that fires after an insert or update of the ENROLLMENT column in the SCHOOL table. It increments the g_index variable and stores the SCHOOL_ID from the newly inserted or updated row into the g_school_ids array at the current index. The second trigger, trg_school_enrollment_check_stmt, is a statement-level trigger that activates after an insert or update on the SCHOOL table. It calculates the average enrollment across all schools by selecting the average ENROLLMENT into a local variable v_avg_enrollment. It then iterates over the g_school_ids array from index 1 to g_index, checking each school ID. For each school ID, it updates the DIVISION column in the SCHOOL_DETAILS table to 'Above Average' if the school's enrollment exceeds the average, or 'Below Average' otherwise. Additionally, if a school's enrollment is greater than 2000, it updates the CLASS column in SCHOOL_DETAILS to 'Large School'. It deletes any row in SCHOOL_DETAILS where the SCHOOL_ID matches the current school ID and the NICKNAME is 'Temporary'. It inserts a new row into SCHOOL_DETAILS with the current school ID and the current year as the LEAGUE, formatted as a string using TO_CHAR(SYSDATE, 'YYYY'). After processing all school IDs, it resets the g_index variable to zero.",
    "plsql": "CREATE OR REPLACE PACKAGE school_pkg IS\n  TYPE school_id_table IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n  g_school_ids school_id_table;\n  g_index PLS_INTEGER := 0;\nEND school_pkg;\n/\n\nCREATE OR REPLACE TRIGGER trg_school_enrollment_check_row\nAFTER INSERT OR UPDATE OF ENROLLMENT ON SCHOOL\nFOR EACH ROW\nBEGIN\n  school_pkg.g_index := school_pkg.g_index + 1;\n  school_pkg.g_school_ids(school_pkg.g_index) := :NEW.SCHOOL_ID;\nEND;\n/\n\nCREATE OR REPLACE TRIGGER trg_school_enrollment_check_stmt\nAFTER INSERT OR UPDATE ON SCHOOL\nDECLARE\n  v_avg_enrollment NUMBER;\nBEGIN\n  SELECT AVG(ENROLLMENT) INTO v_avg_enrollment FROM SCHOOL;\n\n  FOR i IN 1 .. school_pkg.g_index LOOP\n    IF EXISTS (SELECT 1 FROM SCHOOL WHERE SCHOOL_ID = school_pkg.g_school_ids(i) AND ENROLLMENT > v_avg_enrollment) THEN\n      UPDATE SCHOOL_DETAILS SET DIVISION = 'Above Average' WHERE SCHOOL_ID = school_pkg.g_school_ids(i);\n    ELSE\n      UPDATE SCHOOL_DETAILS SET DIVISION = 'Below Average' WHERE SCHOOL_ID = school_pkg.g_school_ids(i);\n    END IF;\n\n    IF EXISTS (SELECT 1 FROM SCHOOL WHERE SCHOOL_ID = school_pkg.g_school_ids(i) AND ENROLLMENT > 2000) THEN\n      UPDATE SCHOOL_DETAILS SET CLASS = 'Large School' WHERE SCHOOL_ID = school_pkg.g_school_ids(i);\n    END IF;\n\n    DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = school_pkg.g_school_ids(i) AND NICKNAME = 'Temporary';\n    INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, LEAGUE) VALUES (school_pkg.g_school_ids(i), TO_CHAR(SYSDATE, 'YYYY'));\n  END LOOP;\n\n  school_pkg.g_index := 0; -- Reset the index after processing\nEND;\n/",
    "database_name": "school_player",
    "tables": [
      "SCHOOL",
      "SCHOOL_DETAILS"
    ],
    "call_sqls": [
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (5, 'Test School', 'Test City', 1500, 1950, 'Test Denomination', 'Co-ed', 'Day', 2000, 'Green & Gold')",
      "UPDATE SCHOOL SET ENROLLMENT = 2500 WHERE SCHOOL_ID = 2",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (6, 'Another School', 'Another City', 800, 1960, 'Another Denomination', 'Girls', 'Boarding', 2010, 'Purple & Silver')",
      "UPDATE SCHOOL SET ENROLLMENT = 1800, LOCATION = 'Updated City' WHERE SCHOOL_ID = 3",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (7, 'Large Academy', 'Metro City', 3000, 1900, 'Academy', 'Boys', 'Day & Boarding', 1950, 'Maroon & Grey')"
    ],
    "summary": "Create a package named school_pkg with an associative array type school_id_table, a variable g_school_ids of that type, and an index variable g_index. Create two triggers on the SCHOOL table: 1) An AFTER INSERT OR UPDATE row-level trigger trg_school_enrollment_check_row that stores the SCHOOL_ID into g_school_ids when ENROLLMENT is modified. 2) An AFTER INSERT OR UPDATE statement-level trigger trg_school_enrollment_check_stmt that calculates the average ENROLLMENT, then for each stored SCHOOL_ID: updates SCHOOL_DETAILS.DIVISION based on enrollment vs. average; updates SCHOOL_DETAILS.CLASS to 'Large School' if enrollment > 2000; deletes SCHOOL_DETAILS rows where NICKNAME is 'Temporary'; inserts a new SCHOOL_DETAILS row with the current year as LEAGUE. Finally, reset g_index.",
    "natural_language": "Create a package for school stuff with a type for holding school IDs and a variable for that type, plus a counter. Set up a couple of triggers on the main school table. The first one, which fires after you add or change a row, should save the school's ID into our list when the student count is adjusted. The second one, which runs after the whole insert or update operation, needs to figure out the typical enrollment size. Then, for each school ID we saved, it should adjust the division category in the details table by comparing its enrollment to that typical size, mark it as a 'Large School' if it has a lot of students, get rid of any temporary detail entries, and add a new detail record with the current year. After all that, clear the counter.",
    "id": 308
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_insert_church` on the `CHURCH` table. This trigger activates for each row *before* an `INSERT` operation is performed on the `CHURCH` table. The trigger first determines the `CHURCH_ID` for the new row being inserted. It does this by executing a `SELECT` statement to retrieve the maximum value of the `CHURCH_ID` column from the `CHURCH` table. This maximum value is then assigned to the `CHURCH_ID` column of the new row (`:NEW.CHURCH_ID`). Immediately after, the value of `:NEW.CHURCH_ID` is incremented by `1`. Next, the trigger checks if the `OPEN_DATE` column of the new row (`:NEW.OPEN_DATE`) is `NULL`. If `:NEW.OPEN_DATE` is `NULL`, the trigger assigns a random integer value to it. This random value is generated using the `DBMS_RANDOM.VALUE` function, which produces a random number between `1800` (inclusive) and `1900` (exclusive). The `FLOOR` function is then applied to this random number to round it down to the nearest whole integer. Finally, the trigger populates the `CONTINUATION_OF` column of the new row (`:NEW.CONTINUATION_OF`). It achieves this by executing a `SELECT` statement to retrieve the `NAME` column from the `CHURCH` table where the `CHURCH_ID` matches the value of `:NEW.CHURCH_ID` minus `1`. The retrieved `NAME` value is then assigned to `:NEW.CONTINUATION_OF`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_church\nBEFORE INSERT ON CHURCH\nFOR EACH ROW\nBEGIN\n  SELECT MAX(CHURCH_ID) INTO :NEW.CHURCH_ID FROM CHURCH;\n  :NEW.CHURCH_ID := :NEW.CHURCH_ID + 1;\n  IF :NEW.OPEN_DATE IS NULL THEN\n    :NEW.OPEN_DATE := FLOOR(DBMS_RANDOM.VALUE(1800, 1900));\n  END IF;\n  SELECT NAME INTO :NEW.CONTINUATION_OF FROM CHURCH WHERE CHURCH_ID = :NEW.CHURCH_ID - 1;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO CHURCH (NAME, ORGANIZED_BY) VALUES ('New Church 1', 'John Doe')",
      "INSERT INTO CHURCH (NAME, ORGANIZED_BY, OPEN_DATE) VALUES ('New Church 2', 'Jane Smith', 1850)",
      "INSERT INTO CHURCH (NAME, ORGANIZED_BY) VALUES ('New Church 3', 'Alice Johnson')",
      "INSERT INTO CHURCH (NAME, ORGANIZED_BY, OPEN_DATE) VALUES ('New Church 4', 'Bob Brown', 1845)",
      "INSERT INTO CHURCH (NAME, ORGANIZED_BY) VALUES ('New Church 5', 'Charlie Davis')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_insert_church on the CHURCH table. For each new row: 1) Set :NEW.CHURCH_ID to the maximum CHURCH_ID from the table plus 1. 2) If :NEW.OPEN_DATE is NULL, set it to a random integer between 1800 and 1899. 3) Set :NEW.CONTINUATION_OF to the NAME from the CHURCH record where CHURCH_ID equals :NEW.CHURCH_ID minus 1.",
    "natural_language": "Please construct a BEFORE INSERT row-level trigger designated as trg_insert_church for the CHURCH table. For each inserted row, the trigger must perform the following operations: first, assign to :NEW.CHURCH_ID a value equivalent to the maximum existing CHURCH_ID incremented by one. Second, if the :NEW.OPEN_DATE is found to be null, it should be populated with a randomly generated integer within the range of 1800 to 1899, inclusive. Third, assign to :NEW.CONTINUATION_OF the NAME value retrieved from the CHURCH record whose CHURCH_ID is exactly one less than the newly assigned :NEW.CHURCH_ID.",
    "id": 309
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_people_country` that is activated after an `UPDATE` operation is performed on the `PEOPLE` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `PEOPLE` table. The trigger's logic is as follows: it evaluates the `COUNTRY` column of the row *after* the update operation has occurred (referred to as `:NEW.COUNTRY`). If the value of `:NEW.COUNTRY` is exactly 'United States', then an `UPDATE` statement is executed on the `CHURCH` table. This `UPDATE` statement sets the `ORGANIZED_BY` column to the string literal 'John Doe' for the row in `CHURCH` where the `CHURCH_ID` column matches the `PEOPLE_ID` column of the row *before* the update operation on the `PEOPLE` table (referred to as `:OLD.PEOPLE_ID`). If the value of `:NEW.COUNTRY` is not 'United States' but is exactly 'Canada', then an `UPDATE` statement is executed on the `CHURCH` table. This `UPDATE` statement sets the `ORGANIZED_BY` column to the string literal 'Jane Smith' for the row in `CHURCH` where the `CHURCH_ID` column matches `:OLD.PEOPLE_ID`. If the value of `:NEW.COUNTRY` is neither 'United States' nor 'Canada', then an `UPDATE` statement is executed on the `CHURCH` table. This `UPDATE` statement sets the `ORGANIZED_BY` column to the string literal 'Unknown' for the row in `CHURCH` where the `CHURCH_ID` column matches `:OLD.PEOPLE_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_people_country\nAFTER UPDATE ON PEOPLE\nFOR EACH ROW\nBEGIN\n  IF :NEW.COUNTRY = 'United States' THEN\n    UPDATE CHURCH SET ORGANIZED_BY = 'John Doe' WHERE CHURCH_ID = :OLD.PEOPLE_ID;\n  ELSIF :NEW.COUNTRY = 'Canada' THEN\n    UPDATE CHURCH SET ORGANIZED_BY = 'Jane Smith' WHERE CHURCH_ID = :OLD.PEOPLE_ID;\n  ELSE\n    UPDATE CHURCH SET ORGANIZED_BY = 'Unknown' WHERE CHURCH_ID = :OLD.PEOPLE_ID;\n  END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "UPDATE PEOPLE SET COUNTRY = 'United States' WHERE PEOPLE_ID = 1",
      "UPDATE PEOPLE SET COUNTRY = 'Canada' WHERE PEOPLE_ID = 2",
      "UPDATE PEOPLE SET COUNTRY = 'Mexico' WHERE PEOPLE_ID = 3",
      "UPDATE PEOPLE SET COUNTRY = 'United States' WHERE PEOPLE_ID = 2",
      "UPDATE PEOPLE SET COUNTRY = 'Canada' WHERE PEOPLE_ID = 1"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_people_country on the PEOPLE table. For each updated row: If :NEW.COUNTRY is 'United States', update the CHURCH table setting ORGANIZED_BY to 'John Doe' where CHURCH_ID equals :OLD.PEOPLE_ID. If :NEW.COUNTRY is 'Canada', update CHURCH setting ORGANIZED_BY to 'Jane Smith' where CHURCH_ID equals :OLD.PEOPLE_ID. Otherwise, update CHURCH setting ORGANIZED_BY to 'Unknown' where CHURCH_ID equals :OLD.PEOPLE_ID.",
    "natural_language": "Construct an AFTER UPDATE row-level trigger, which should be named trg_update_people_country, to be placed on the PEOPLE table. For every individual row that is updated, you must perform the following detailed checks and actions: if the newly entered COUNTRY value is specifically 'United States', then proceed to update the CHURCH table by carefully setting its ORGANIZED_BY field to the precise value 'John Doe', but only where the CHURCH_ID matches the original PEOPLE_ID from before the update. Alternatively, if the new COUNTRY is instead 'Canada', then you must accordingly update the CHURCH table, setting ORGANIZED_BY to the distinct value 'Jane Smith', again only where the CHURCH_ID corresponds to the old PEOPLE_ID. In all other possible cases, where the new COUNTRY is neither of those two nations, you must diligently update the CHURCH table, setting the ORGANIZED_BY field to the generic value 'Unknown', strictly under the condition that the CHURCH_ID equals the former PEOPLE_ID.",
    "id": 310
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_delete_wedding` that is activated for `DELETE` operations on the `WEDDING` table. This trigger is designed to perform actions both before each row is deleted and after the entire `DELETE` statement has completed. It declares a nested table type `church_id_t` as a collection of `NUMBER` indexed by `PLS_INTEGER`, and a global variable `g_church_ids` of this type to store `CHURCH_ID` values.\n\nIn the `BEFORE EACH ROW` section, for every row being deleted from the `WEDDING` table, the trigger performs two `DELETE` operations on the `PEOPLE` table. First, it deletes a row from the `PEOPLE` table where the `PEOPLE_ID` column matches the `MALE_ID` column value of the `OLD` row being deleted from the `WEDDING` table. Second, it deletes another row from the `PEOPLE` table where the `PEOPLE_ID` column matches the `FEMALE_ID` column value of the `OLD` row being deleted from the `WEDDING` table. After these deletions, the `CHURCH_ID` column value of the `OLD` row being deleted from the `WEDDING` table is added to the `g_church_ids` collection. The `COUNT` attribute of `g_church_ids` is used to determine the next available index for insertion.\n\nIn the `AFTER STATEMENT` section, after all rows specified by the `DELETE` statement on the `WEDDING` table have been processed, the trigger declares a local variable `v_wedding_count` of type `NUMBER`. It then iterates through each `CHURCH_ID` stored in the `g_church_ids` collection. For each `CHURCH_ID` in the collection, it executes a `SELECT` statement to count the number of rows in the `WEDDING` table where the `CHURCH_ID` column matches the current `CHURCH_ID` from the `g_church_ids` collection, storing this count in `v_wedding_count`. Subsequently, it checks if `v_wedding_count` is equal to `0`. If `v_wedding_count` is `0`, indicating that there are no remaining weddings associated with that specific `CHURCH_ID`, it then performs a `DELETE` operation on the `CHURCH` table, removing the row where the `CHURCH_ID` column matches the current `CHURCH_ID` from the `g_church_ids` collection.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_wedding\nFOR DELETE ON WEDDING\nCOMPOUND TRIGGER\n  TYPE church_id_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n  g_church_ids church_id_t;\n  \n  BEFORE EACH ROW IS\n  BEGIN\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = :OLD.MALE_ID;\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = :OLD.FEMALE_ID;\n    g_church_ids(g_church_ids.COUNT + 1) := :OLD.CHURCH_ID;\n  END BEFORE EACH ROW;\n  \n  AFTER STATEMENT IS\n    v_wedding_count NUMBER;\n  BEGIN\n    FOR i IN 1..g_church_ids.COUNT LOOP\n      SELECT COUNT(*) INTO v_wedding_count\n      FROM WEDDING\n      WHERE CHURCH_ID = g_church_ids(i);\n      \n      IF v_wedding_count = 0 THEN\n        DELETE FROM CHURCH WHERE CHURCH_ID = g_church_ids(i);\n      END IF;\n    END LOOP;\n  END AFTER STATEMENT;\nEND trg_delete_wedding;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "DELETE FROM WEDDING WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "DELETE FROM WEDDING WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4",
      "DELETE FROM WEDDING WHERE CHURCH_ID = 5 AND MALE_ID = 5 AND FEMALE_ID = 6",
      "DELETE FROM WEDDING WHERE CHURCH_ID = 2",
      "DELETE FROM WEDDING WHERE YEAR = 2014"
    ],
    "summary": "Create a compound trigger named `trg_delete_wedding` for DELETE operations on the WEDDING table. Before each row deletion, delete from the PEOPLE table where PEOPLE_ID matches the OLD.MALE_ID and OLD.FEMALE_ID, then store the OLD.CHURCH_ID in a collection. After the statement completes, for each stored CHURCH_ID, if no weddings remain in the WEDDING table for that CHURCH_ID, delete the corresponding row from the CHURCH table.",
    "natural_language": "Please construct a compound trigger designated as `trg_delete_wedding` to manage DELETE operations on the WEDDING table. Prior to the deletion of each individual row, it is necessary to remove corresponding entries from the PEOPLE table where the PEOPLE_ID aligns with the OLD.MALE_ID and OLD.FEMALE_ID values. Subsequently, the OLD.CHURCH_ID should be recorded into a collection. Upon completion of the statement, for each CHURCH_ID retained in the collection, if no associated records remain in the WEDDING table for that specific CHURCH_ID, the corresponding entry must be deleted from the CHURCH table.",
    "id": 311
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_wedding_year that is executed automatically after an update operation is performed on the WEDDING table. This trigger operates on each row affected by the update. It evaluates the YEAR column of the updated row using conditional logic. If the new YEAR value is greater than 2020, it updates the CHURCH table by increasing the OPEN_DATE column by 10 for the row where the CHURCH_ID matches the old CHURCH_ID value from the updated WEDDING row. If the new YEAR value is between 2010 and 2020 inclusive, it updates the CHURCH table by increasing the OPEN_DATE column by 5 for the row where the CHURCH_ID matches the old CHURCH_ID value from the updated WEDDING row. If the new YEAR value is less than 2010, it updates the CHURCH table by increasing the OPEN_DATE column by 1 for the row where the CHURCH_ID matches the old CHURCH_ID value from the updated WEDDING row. The trigger uses the :NEW and :OLD pseudorecords to access the new and old values of the YEAR and CHURCH_ID columns, respectively, from the WEDDING table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_wedding_year\nAFTER UPDATE ON WEDDING\nFOR EACH ROW\nBEGIN\n  IF :NEW.YEAR > 2020 THEN\n    UPDATE CHURCH SET OPEN_DATE = OPEN_DATE + 10 WHERE CHURCH_ID = :OLD.CHURCH_ID;\n  ELSIF :NEW.YEAR BETWEEN 2010 AND 2020 THEN\n    UPDATE CHURCH SET OPEN_DATE = OPEN_DATE + 5 WHERE CHURCH_ID = :OLD.CHURCH_ID;\n  ELSE\n    UPDATE CHURCH SET OPEN_DATE = OPEN_DATE + 1 WHERE CHURCH_ID = :OLD.CHURCH_ID;\n  END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "UPDATE WEDDING SET YEAR = 2021 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2019 WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4",
      "UPDATE WEDDING SET YEAR = 2022 WHERE CHURCH_ID = 5 AND MALE_ID = 5 AND FEMALE_ID = 6",
      "UPDATE WEDDING SET YEAR = 2010 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2005 WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4"
    ],
    "summary": "Create a row-level trigger named `trg_update_wedding_year` that fires after UPDATE on the WEDDING table. Based on the new YEAR value: if >2020, add 10 to OPEN_DATE in CHURCH for the old CHURCH_ID; if between 2010 and 2020 inclusive, add 5; if <2010, add 1.",
    "natural_language": "Please construct a row-level trigger designated as `trg_update_wedding_year`. This trigger should be configured to execute subsequent to any UPDATE operation performed on the WEDDING table. Its logic must evaluate the newly provided YEAR value and, accordingly, modify the OPEN_DATE within the CHURCH table. The specific modifications are as follows: should the new YEAR exceed 2020, increment the OPEN_DATE by 10 for the record associated with the previous CHURCH_ID; should the new YEAR fall within the inclusive range of 2010 to 2020, increment the OPEN_DATE by 5; and should the new YEAR be less than 2010, increment the OPEN_DATE by 1.",
    "id": 312
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_round_product_price that executes before any insert or update operation on the PRODUCTS table for each affected row, and within its execution block, first assigns a new value to the PRICE column of the newly inserted or updated row by applying the ROUND function to the incoming :NEW.PRICE value with a precision of two decimal places, then checks if the triggering operation is an insert and if the :NEW.CODE column value is null, and if both conditions are true, performs a select statement on the PRODUCTS table to calculate a new code by taking the maximum existing value from the CODE column, using the NVL function to substitute zero if the maximum is null, and adding one to that result, and assigns this calculated value to the :NEW.CODE column; furthermore, the trigger includes an exception handling section that catches the predefined DUP_VAL_ON_INDEX exception, which signifies a violation of a unique constraint, and upon catching this exception, executes a select statement identical to the one described previously to calculate and assign a new unique value to the :NEW.CODE column, and then re-applies the ROUND function to the :NEW.PRICE value with two decimal precision and assigns it back to the :NEW.PRICE column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_round_product_price\nBEFORE INSERT OR UPDATE ON PRODUCTS\nFOR EACH ROW\nBEGIN\n    -- Round the price to 2 decimal places\n    :NEW.PRICE := ROUND(:NEW.PRICE, 2);\n    \n    -- Ensure CODE is not null for INSERT operations\n    IF INSERTING AND :NEW.CODE IS NULL THEN\n        SELECT NVL(MAX(CODE), 0) + 1 INTO :NEW.CODE FROM PRODUCTS;\n    END IF;\nEXCEPTION\n    WHEN DUP_VAL_ON_INDEX THEN\n        -- Handle unique constraint violation by generating a new CODE\n        SELECT NVL(MAX(CODE), 0) + 1 INTO :NEW.CODE FROM PRODUCTS;\n        :NEW.PRICE := ROUND(:NEW.PRICE, 2);\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO PRODUCTS (NAME, PRICE, MANUFACTURER) VALUES ('SSD', 199.999, 1)",
      "INSERT INTO PRODUCTS (NAME, PRICE, MANUFACTURER) VALUES ('Monitor', 150.456, 2)",
      "INSERT INTO PRODUCTS (NAME, PRICE, MANUFACTURER) VALUES ('Keyboard', 49.999, 3)",
      "UPDATE PRODUCTS SET PRICE = 89.999 WHERE CODE = 1",
      "UPDATE PRODUCTS SET PRICE = 129.456 WHERE CODE = 2"
    ],
    "summary": "Create a row-level trigger named `trg_round_product_price` that fires before INSERT or UPDATE on the PRODUCTS table. Round the new PRICE to two decimals. If the operation is INSERT and new CODE is null, assign a new CODE as the maximum existing CODE plus one. Handle DUP_VAL_ON_INDEX by recalculating CODE and re-rounding PRICE.",
    "natural_language": "Create a trigger named `trg_round_product_price` that fires before any INSERT or UPDATE on the PRODUCTS table. For every row, round the new PRICE value to two decimal places. If the operation is an INSERT and the new CODE is null, set the CODE to the maximum existing CODE plus one. Also, handle any DUP_VAL_ON_INDEX exception by recalculating the CODE and re-rounding the PRICE.",
    "id": 313
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_manufacturer_name that is executed after an update operation on the MANUFACTURERS table. This trigger operates for each row that is updated in the MANUFACTURERS table. Within the trigger's body, an update operation is performed on the PRODUCTS table. Specifically, the NAME column of the PRODUCTS table is modified by appending the string ' - Updated' to its current value. This update is applied to all rows in the PRODUCTS table where the MANUFACTURER column matches the new value of the CODE column from the updated row in the MANUFACTURERS table. The trigger uses the :NEW pseudo-record to reference the new value of the CODE column from the updated row in the MANUFACTURERS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_manufacturer_name\nAFTER UPDATE ON MANUFACTURERS\nFOR EACH ROW\nBEGIN\n    UPDATE PRODUCTS\n    SET NAME = NAME || ' - Updated'\n    WHERE MANUFACTURER = :NEW.CODE;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "UPDATE MANUFACTURERS SET NAME = 'Sony Corporation' WHERE CODE = 1",
      "UPDATE MANUFACTURERS SET NAME = 'Creative Labs Inc.' WHERE CODE = 2",
      "UPDATE MANUFACTURERS SET NAME = 'HP Inc.' WHERE CODE = 3",
      "UPDATE MANUFACTURERS SET NAME = 'Sony Electronics' WHERE CODE = 1",
      "UPDATE MANUFACTURERS SET NAME = 'Creative Technology' WHERE CODE = 2"
    ],
    "summary": "Create a row-level trigger named `trg_update_manufacturer_name` that fires after UPDATE on the MANUFACTURERS table. Update the NAME column in the PRODUCTS table by appending ' - Updated' for all rows where MANUFACTURER matches the new CODE from the updated MANUFACTURERS row.",
    "natural_language": "Set up a trigger that runs after changes are made to the manufacturer details. It should kind of adjust the product names by adding a note like ' - Updated' for items linked to that manufacturer, but only when the manufacturer code gets updated.",
    "id": 314
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_wedding that is defined to fire automatically after a new row is successfully inserted into the WEDDING table, executing once for each inserted row, and its body performs a single INSERT operation into the CHURCH table, populating the CHURCH_ID column with the value from the newly inserted WEDDING row's CHURCH_ID column (referenced via the :NEW.CHURCH_ID bind variable), setting the NAME column to the literal string 'New Church', setting the ORGANIZED_BY column to the literal string 'Organizer', calculating the OPEN_DATE column value by using the EXTRACT function to obtain only the four-digit year component from the result of the CURRENT_DATE function which returns the current date from the system, and setting the CONTINUATION_OF column to the literal string 'Continuation'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_wedding\nAFTER INSERT ON WEDDING\nFOR EACH ROW\nBEGIN\n  INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n  VALUES (:NEW.CHURCH_ID, 'New Church', 'Organizer', EXTRACT(YEAR FROM CURRENT_DATE), 'Continuation');\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (10, 1, 2, 2023)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (11, 3, 4, 2024)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (12, 5, 6, 2025)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (13, 7, 8, 2026)",
      "INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR) VALUES (14, 9, 10, 2027)"
    ],
    "summary": "Create a row-level trigger named `trg_insert_wedding` that fires after INSERT on the WEDDING table. Insert a new row into the CHURCH table using the new CHURCH_ID, with NAME as 'New Church', ORGANIZED_BY as 'Organizer', OPEN_DATE as the current year extracted from CURRENT_DATE, and CONTINUATION_OF as 'Continuation'.",
    "natural_language": "Create trigger `trg_insert_wedding` after WEDDING insert. Add row to CHURCH with new CHURCH_ID, NAME 'New Church', ORGANIZED_BY 'Organizer', OPEN_DATE current year, CONTINUATION_OF 'Continuation'.",
    "id": 315
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_people` that is configured to execute `AFTER` a `DELETE` operation occurs on the `PEOPLE` table. This trigger is a `FOR EACH ROW` trigger, meaning its body will execute once for each individual row that is deleted from the `PEOPLE` table. When a row is deleted from the `PEOPLE` table, the trigger's execution context provides access to the values of the columns of the row that was just deleted via the `:OLD` correlation name. Inside the trigger body, a `DELETE` statement is executed against the `WEDDING` table. This `DELETE` statement removes rows from the `WEDDING` table where either the `MALE_ID` column's value matches the `PEOPLE_ID` of the row that was just deleted from the `PEOPLE` table (accessed as `:OLD.PEOPLE_ID`), or the `FEMALE_ID` column's value matches the `PEOPLE_ID` of the row that was just deleted from the `PEOPLE` table (also accessed as `:OLD.PEOPLE_ID`). The `OR` logical operator ensures that any `WEDDING` record where the deleted person was either the male or the female participant is removed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_people\nAFTER DELETE ON PEOPLE\nFOR EACH ROW\nBEGIN\n  DELETE FROM WEDDING WHERE MALE_ID = :OLD.PEOPLE_ID OR FEMALE_ID = :OLD.PEOPLE_ID;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "DELETE FROM PEOPLE WHERE PEOPLE_ID = 1",
      "DELETE FROM PEOPLE WHERE PEOPLE_ID = 3",
      "DELETE FROM PEOPLE WHERE PEOPLE_ID = 5",
      "DELETE FROM PEOPLE WHERE NAME = 'Mike Weir'",
      "DELETE FROM PEOPLE WHERE COUNTRY = 'Canada'"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_delete_people on the PEOPLE table. For each deleted row, delete from the WEDDING table where the deleted person's ID (:OLD.PEOPLE_ID) matches either the MALE_ID or FEMALE_ID.",
    "natural_language": "Create a trigger named trg_delete_people on the PEOPLE table that fires AFTER DELETE FOR EACH ROW. For every deleted row, remove the corresponding records from the WEDDING table where the deleted person's ID (:OLD.PEOPLE_ID) is equal to either the MALE_ID or the FEMALE_ID.",
    "id": 316
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_church that is automatically executed after a new row is successfully inserted into the CHURCH table for each individual row affected by the insert operation, and within its execution block, it performs a single INSERT operation into the PEOPLE table, specifying values for the columns PEOPLE_ID, NAME, COUNTRY, IS_MALE, and AGE, where the value for PEOPLE_ID is taken directly from the newly inserted CHURCH row's CHURCH_ID column using the :NEW correlation identifier, the value for NAME is the literal string 'New Person', the value for COUNTRY is the literal string 'Unknown', the value for IS_MALE is the literal string 'T', and the value for AGE is the literal number 30.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_church\nAFTER INSERT ON CHURCH\nFOR EACH ROW\nBEGIN\n  INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n  VALUES (:NEW.CHURCH_ID, 'New Person', 'Unknown', 'T', 30);\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (100, 'Test Church', 'John Doe', 2024, NULL)",
      "INSERT INTO CHURCH (CHURCH_ID, NAME) VALUES (101, 'Grace Community Church')",
      "INSERT INTO CHURCH (CHURCH_ID, NAME, OPEN_DATE) VALUES (102, 'First Baptist', 1990)",
      "INSERT INTO CHURCH VALUES (103, 'St. Mary', 'Fr. James', 1955, 'Diocese')",
      "INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF) VALUES (104, 'Cathedral', 'Bishop', 1800, 'Old Parish')"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_church on the CHURCH table. For each new row, insert into the PEOPLE table using :NEW.CHURCH_ID for PEOPLE_ID, 'New Person' for NAME, 'Unknown' for COUNTRY, 'T' for IS_MALE, and 30 for AGE.",
    "natural_language": "Create AFTER INSERT trigger trg_insert_church on CHURCH. For each new row, insert into PEOPLE with :NEW.CHURCH_ID as PEOPLE_ID, 'New Person' as NAME, 'Unknown' as COUNTRY, 'T' as IS_MALE, and 30 as AGE.",
    "id": 317
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_wedding_year that is defined to fire automatically after any row in the WEDDING table is updated, and it executes once for each updated row. The trigger performs an UPDATE operation on the CHURCH table. It sets the OPEN_DATE column of the CHURCH table to the value of the :NEW.YEAR column from the updated WEDDING row. This update is applied only to the specific row in the CHURCH table where the CHURCH_ID column matches the value of the :NEW.CHURCH_ID column from the updated WEDDING row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_wedding_year\nAFTER UPDATE ON WEDDING\nFOR EACH ROW\nBEGIN\n  UPDATE CHURCH\n  SET\n    OPEN_DATE = :NEW.YEAR\n  WHERE\n    CHURCH_ID = :NEW.CHURCH_ID;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "UPDATE WEDDING SET YEAR = 2024 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2023 WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4",
      "UPDATE WEDDING SET YEAR = 2025 WHERE CHURCH_ID = 5 AND MALE_ID = 5 AND FEMALE_ID = 6",
      "UPDATE WEDDING SET YEAR = 2022, CHURCH_ID = 2 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2021 WHERE CHURCH_ID = 2 AND MALE_ID = 7 AND FEMALE_ID = 8"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_wedding_year on the WEDDING table. For each updated row, update the CHURCH table, setting OPEN_DATE to :NEW.YEAR where CHURCH_ID equals :NEW.CHURCH_ID.",
    "natural_language": "Please construct an AFTER UPDATE FOR EACH ROW trigger designated as trg_update_wedding_year on the WEDDING table. For every row that is updated, it is required to perform an update on the CHURCH table. Specifically, set the OPEN_DATE column to the value of :NEW.YEAR for the record where the CHURCH_ID matches :NEW.CHURCH_ID.",
    "id": 318
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_camera_lens_audit that is executed after an insert operation on the CAMERA_LENS table for each row affected by the insert. The trigger declares a local variable v_new_id of type NUMBER to store a new identifier. It begins by selecting the maximum value of the ID column from the PHOTOS table, using the NVL function to handle nulls by defaulting to 0 if no rows exist, and increments this maximum value by 1 to generate a new unique ID, storing the result in v_new_id. The trigger then performs an insert operation into the PHOTOS table, populating the ID column with v_new_id, the CAMERA_LENS_ID column with the ID of the newly inserted row in the CAMERA_LENS table (accessed via the :NEW pseudorecord), the MOUNTAIN_ID column with a constant value of 3, the COLOR column with the string 'RGB', and the NAME column with the string 'test_photo'. Following the insert, the trigger executes an update operation on the PHOTOS table, setting the COLOR column to 'CMYK' for all rows where the CAMERA_LENS_ID matches the ID of the newly inserted row in the CAMERA_LENS table, again using the :NEW pseudorecord to reference the current row's ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_camera_lens_audit\nAFTER INSERT ON CAMERA_LENS\nFOR EACH ROW\nDECLARE\n    v_new_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(ID), 0) + 1 INTO v_new_id FROM PHOTOS;\n    INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME) \n    VALUES (v_new_id, :NEW.ID, 3, 'RGB', 'test_photo');\n    UPDATE PHOTOS SET COLOR = 'CMYK' WHERE CAMERA_LENS_ID = :NEW.ID;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "INSERT INTO CAMERA_LENS (ID, BRAND, NAME, FOCAL_LENGTH_MM, MAX_APERTURE) VALUES (12, 'Canon', 'Canon 50mm f1.8', 50, 1.8)",
      "INSERT INTO CAMERA_LENS (ID, BRAND, NAME, FOCAL_LENGTH_MM, MAX_APERTURE) VALUES (13, 'Nikon', 'Nikon 85mm f1.4', 85, 1.4)",
      "INSERT INTO CAMERA_LENS (ID, BRAND, NAME, FOCAL_LENGTH_MM, MAX_APERTURE) VALUES (14, 'Sony', 'Sony 35mm f1.8', 35, 1.8)",
      "INSERT INTO CAMERA_LENS (ID, BRAND, NAME, FOCAL_LENGTH_MM, MAX_APERTURE) VALUES (15, 'Tamron', 'Tamron 70-200mm f2.8', 70, 2.8)",
      "INSERT INTO CAMERA_LENS (ID, BRAND, NAME, FOCAL_LENGTH_MM, MAX_APERTURE) VALUES (16, 'Sigma', 'Sigma 24-70mm f2.8', 24, 2.8)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_camera_lens_audit on the CAMERA_LENS table. Declare a variable v_new_id. Set v_new_id to NVL(MAX(ID),0)+1 from PHOTOS. Insert into PHOTOS using v_new_id for ID, :NEW.ID for CAMERA_LENS_ID, 3 for MOUNTAIN_ID, 'RGB' for COLOR, and 'test_photo' for NAME. Then update PHOTOS, setting COLOR to 'CMYK' where CAMERA_LENS_ID equals :NEW.ID.",
    "natural_language": "Create a trigger named trg_camera_lens_audit on the CAMERA_LENS table that fires after each row is inserted. First, declare a variable v_new_id. Set its value to one greater than the maximum ID in the PHOTOS table, using 0 if no IDs exist. Then, insert a new row into PHOTOS. Use v_new_id for the ID, the new CAMERA_LENS row's ID for CAMERA_LENS_ID, 3 for MOUNTAIN_ID, 'RGB' for COLOR, and 'test_photo' for NAME. Finally, update the PHOTOS table, changing the COLOR to 'CMYK' for any rows where the CAMERA_LENS_ID matches the ID of the newly inserted CAMERA_LENS row.",
    "id": 319
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_photos_cleanup` that is activated after a `DELETE` operation is performed on the `PHOTOS` table. This trigger is a row-level trigger, meaning it executes once for each individual row that is deleted from the `PHOTOS` table. Upon the deletion of a row from the `PHOTOS` table, the trigger performs an `UPDATE` operation on the `MOUNTAIN` table. Specifically, it increments the value in the `PROMINENCE` column of the `MOUNTAIN` table by `100`. This update is applied only to the row in the `MOUNTAIN` table where the `ID` column matches the value of the `MOUNTAIN_ID` column from the row that was just deleted from the `PHOTOS` table. The `:OLD.MOUNTAIN_ID` refers to the value of the `MOUNTAIN_ID` column in the row of the `PHOTOS` table *before* it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_photos_cleanup\nAFTER DELETE ON PHOTOS\nFOR EACH ROW\nBEGIN\n    UPDATE MOUNTAIN \n    SET PROMINENCE = PROMINENCE + 100 \n    WHERE ID = :OLD.MOUNTAIN_ID;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "DELETE FROM PHOTOS WHERE ID = 1",
      "DELETE FROM PHOTOS WHERE MOUNTAIN_ID = 20",
      "DELETE FROM PHOTOS WHERE NAME = 'monkey'",
      "DELETE FROM PHOTOS WHERE CAMERA_LENS_ID = 10",
      "DELETE FROM PHOTOS WHERE COLOR = 'RBG'"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_photos_cleanup on the PHOTOS table. For each deleted row, update the MOUNTAIN table, incrementing the PROMINENCE column by 100 where the MOUNTAIN.ID equals :OLD.MOUNTAIN_ID.",
    "natural_language": "Construct an AFTER DELETE FOR EACH ROW trigger, which should be named trg_photos_cleanup, specifically on the PHOTOS table. For every single row that is subsequently deleted, you must carefully update the MOUNTAIN table by precisely incrementing the value in its PROMINENCE column by a full 100 units, but only in those specific records where the MOUNTAIN.ID column matches exactly the :OLD.MOUNTAIN_ID value from the recently removed row.",
    "id": 320
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_property_insert that is executed before an insert operation on the CUSTOMER_EVENTS table for each row being inserted. The trigger declares two local variables, v_property_count and v_resident_count, both of type NUMBER, to store the count of records from subsequent queries. The trigger first performs a SELECT COUNT(*) query on the PROPERTIES table to determine if a record with PROPERTY_ID matching the :NEW.PROPERTY_ID from the CUSTOMER_EVENTS table already exists. If no such record exists (v_property_count equals 0), it inserts a new record into the PROPERTIES table with the PROPERTY_ID set to :NEW.PROPERTY_ID, PROPERTY_TYPE_CODE set to 'apartment', PROPERTY_ADDRESS set to 'Unknown Address', and OTHER_DETAILS set to 'Auto-generated'. Next, the trigger performs another SELECT COUNT(*) query on the RESIDENTS table to check if a record exists with PROPERTY_ID, RESIDENT_ID, and DATE_MOVED_IN matching the corresponding :NEW.PROPERTY_ID, :NEW.RESIDENT_ID, and :NEW.DATE_MOVED_IN from the CUSTOMER_EVENTS table. If no such record exists (v_resident_count equals 0), it inserts a new record into the RESIDENTS table with PROPERTY_ID set to :NEW.PROPERTY_ID, RESIDENT_ID set to :NEW.RESIDENT_ID, DATE_MOVED_IN set to :NEW.DATE_MOVED_IN, DATE_MOVED_OUT set to NULL, and OTHER_DETAILS set to 'Auto-generated'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_property_insert\nBEFORE INSERT ON CUSTOMER_EVENTS\nFOR EACH ROW\nDECLARE\n    v_property_count NUMBER;\n    v_resident_count NUMBER;\nBEGIN\n    -- Check and insert into PROPERTIES if necessary\n    SELECT COUNT(*) INTO v_property_count FROM PROPERTIES WHERE PROPERTY_ID = :NEW.PROPERTY_ID;\n    IF v_property_count = 0 THEN\n        INSERT INTO PROPERTIES (PROPERTY_ID, PROPERTY_TYPE_CODE, PROPERTY_ADDRESS, OTHER_DETAILS) \n        VALUES (:NEW.PROPERTY_ID, 'apartment', 'Unknown Address', 'Auto-generated');\n    END IF;\n\n    -- Check and insert into RESIDENTS if necessary\n    SELECT COUNT(*) INTO v_resident_count FROM RESIDENTS \n    WHERE PROPERTY_ID = :NEW.PROPERTY_ID \n      AND RESIDENT_ID = :NEW.RESIDENT_ID \n      AND DATE_MOVED_IN = :NEW.DATE_MOVED_IN;\n      \n    IF v_resident_count = 0 THEN\n        INSERT INTO RESIDENTS (PROPERTY_ID, RESIDENT_ID, DATE_MOVED_IN, DATE_MOVED_OUT, OTHER_DETAILS) \n        VALUES (:NEW.PROPERTY_ID, :NEW.RESIDENT_ID, :NEW.DATE_MOVED_IN, NULL, 'Auto-generated');\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (201, 19, '2015-03-27 12:00:00', 605, 10, 1)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (202, 5, '2016-08-04 01:06:05', 879, 23, 80)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (203, 16, '2016-12-11 01:05:14', 629, 28, 14)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (204, 19, '2017-06-17 15:43:33', 605, 10, 1)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (205, 5, '2017-11-14 06:28:48', 879, 23, 80)"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_validate_property_insert on CUSTOMER_EVENTS. If the inserted PROPERTY_ID does not exist in the PROPERTIES table, insert a default property record. Then, if the combination of PROPERTY_ID, RESIDENT_ID, and DATE_MOVED_IN does not exist in the RESIDENTS table, insert a default resident record.",
    "natural_language": "Create a BEFORE INSERT row trigger called trg_validate_property_insert for the CUSTOMER_EVENTS table. First, check if the new PROPERTY_ID exists in the PROPERTIES table; if it does not, insert a default property. Next, verify if the combination of PROPERTY_ID, RESIDENT_ID, and DATE_MOVED_IN exists in the RESIDENTS table; if it does not, insert a default resident.",
    "id": 321
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_resident_dates that is defined to execute before any insert operation on the CUSTOMER_EVENTS table for each individual row being inserted, which declares a local variable v_resident_exists of type NUMBER, then performs a SELECT COUNT(*) query from the RESIDENTS table into that variable where the condition requires the RESIDENT_ID column in RESIDENTS to equal the new RESIDENT_ID value from the inserted row in CUSTOMER_EVENTS, the PROPERTY_ID column in RESIDENTS to equal the new PROPERTY_ID value, and the DATE_MOVED_IN column in RESIDENTS to equal the new DATE_MOVED_IN value, and subsequently, if the value of v_resident_exists is found to be exactly 0, the trigger raises an application error with error code -20001 and the message 'Referential integrity violation: No matching resident record found.' to prevent the insert operation.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_resident_dates\nBEFORE INSERT ON CUSTOMER_EVENTS\nFOR EACH ROW\nDECLARE\n    v_resident_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_resident_exists \n    FROM RESIDENTS \n    WHERE RESIDENT_ID = :NEW.RESIDENT_ID \n      AND PROPERTY_ID = :NEW.PROPERTY_ID \n      AND DATE_MOVED_IN = :NEW.DATE_MOVED_IN;\n    \n    IF v_resident_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Referential integrity violation: No matching resident record found.');\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (1000, 19, '2015-03-27 12:00:00', 605, 10, 1)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (1001, 5, '2017-06-17 15:43:33', 954, 6, 80)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (1002, 16, '2015-03-27 12:00:00', 879, 23, 14)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (1003, 25, '2017-06-17 15:43:33', 605, 10, 50)",
      "INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (1004, 30, '2017-06-17 15:43:33', 879, 23, 99)"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_sync_resident_dates on CUSTOMER_EVENTS. If a matching record (by RESIDENT_ID, PROPERTY_ID, and DATE_MOVED_IN) does not exist in the RESIDENTS table, raise an application error (-20001) to prevent the insert.",
    "natural_language": "How can I create a BEFORE INSERT row trigger called trg_sync_resident_dates on the CUSTOMER_EVENTS table that raises an application error (-20001) to prevent the insert if no matching record for RESIDENT_ID, PROPERTY_ID, and DATE_MOVED_IN is found in the RESIDENTS table?",
    "id": 322
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named `trg_archive_event_notes` that is defined to execute `AFTER` a `DELETE` operation occurs on the `CUSTOMER_EVENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning its body will execute once for every row that is deleted from the `CUSTOMER_EVENTS` table. The trigger declares a local PL/SQL variable named `v_note_count` of data type `NUMBER`. The execution block of the trigger first performs a `SELECT` statement to count the number of existing records in the `CUSTOMER_EVENT_NOTES` table. Specifically, it counts all rows where the `CUSTOMER_EVENT_ID` column matches the `CUSTOMER_EVENT_ID` value of the row that was just deleted from the `CUSTOMER_EVENTS` table. This `CUSTOMER_EVENT_ID` value from the deleted row is accessed using the `:OLD.CUSTOMER_EVENT_ID` pseudorecord. The result of this count operation is then stored into the `v_note_count` variable. Following this, a conditional `IF` statement checks if the value of `v_note_count` is greater than `0`. If this condition evaluates to `TRUE`, indicating that there are one or more associated notes in the `CUSTOMER_EVENT_NOTES` table for the deleted customer event, then a `DELETE` statement is executed. This `DELETE` statement removes all records from the `CUSTOMER_EVENT_NOTES` table where the `CUSTOMER_EVENT_ID` column matches the `CUSTOMER_EVENT_ID` value of the row that was just deleted from the `CUSTOMER_EVENTS` table, again accessed via `:OLD.CUSTOMER_EVENT_ID`. If the `v_note_count` is not greater than `0`, the `DELETE` statement is skipped, and no action is taken on the `CUSTOMER_EVENT_NOTES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_archive_event_notes\nAFTER DELETE ON CUSTOMER_EVENTS\nFOR EACH ROW\nDECLARE\n    v_note_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_note_count FROM CUSTOMER_EVENT_NOTES WHERE CUSTOMER_EVENT_ID = :OLD.CUSTOMER_EVENT_ID;\n    IF v_note_count > 0 THEN\n        DELETE FROM CUSTOMER_EVENT_NOTES WHERE CUSTOMER_EVENT_ID = :OLD.CUSTOMER_EVENT_ID;\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "DELETE FROM CUSTOMER_EVENTS WHERE CUSTOMER_EVENT_ID = 70",
      "DELETE FROM CUSTOMER_EVENTS WHERE CUSTOMER_EVENT_ID = 160",
      "DELETE FROM CUSTOMER_EVENTS WHERE CUSTOMER_EVENT_ID = 166"
    ],
    "summary": "Create an AFTER DELETE row trigger named trg_archive_event_notes on CUSTOMER_EVENTS. If the deleted CUSTOMER_EVENT_ID has associated notes in the CUSTOMER_EVENT_NOTES table, delete those notes.",
    "natural_language": "Construct an AFTER DELETE row trigger, which should be named trg_archive_event_notes, on the CUSTOMER_EVENTS table. This trigger must be designed to carefully check if the recently deleted CUSTOMER_EVENT_ID has any corresponding and potentially important notes still stored within the CUSTOMER_EVENT_NOTES table, and if such associated records are found, it must proceed to securely and completely delete all of those related notes.",
    "id": 323
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER UPDATE` row-level trigger named `trg_update_event_note_service` on the `CUSTOMER_EVENTS` table. This trigger executes after an `UPDATE` operation is performed on any row in the `CUSTOMER_EVENTS` table. For each row that is updated, the trigger first declares a local numeric variable `v_max_note_id`. It then populates `v_max_note_id` by querying the `CUSTOMER_EVENT_NOTES` table to find the maximum value of the `CUSTOMER_EVENT_NOTE_ID` column, adding 1 to it. If no records exist in `CUSTOMER_EVENT_NOTES`, `NVL(MAX(CUSTOMER_EVENT_NOTE_ID), 0)` ensures that `v_max_note_id` will be initialized to 1. Following this, the trigger evaluates a conditional statement: it checks if the `RESIDENT_ID` column in the newly updated row (`:NEW.RESIDENT_ID`) is different from the `RESIDENT_ID` column in the row before the update (`:OLD.RESIDENT_ID`), or if the `PROPERTY_ID` column in the newly updated row (`:NEW.PROPERTY_ID`) is different from the `PROPERTY_ID` column in the row before the update (`:OLD.PROPERTY_ID`). If either of these conditions is true, the trigger performs an `INSERT` operation into the `CUSTOMER_EVENT_NOTES` table. The `INSERT` statement populates the `CUSTOMER_EVENT_NOTE_ID` column with the value of `v_max_note_id`, the `CUSTOMER_EVENT_ID` column with the value from `:NEW.CUSTOMER_EVENT_ID`, the `SERVICE_TYPE_CODE` column with the static string literal 'Updated', the `RESIDENT_ID` column with the value from `:NEW.RESIDENT_ID`, the `PROPERTY_ID` column with the value from `:NEW.PROPERTY_ID`, and the `DATE_MOVED_IN` column with the value from `:NEW.DATE_MOVED_IN`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_event_note_service\nAFTER UPDATE ON CUSTOMER_EVENTS\nFOR EACH ROW\nDECLARE\n    v_max_note_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(CUSTOMER_EVENT_NOTE_ID), 0) + 1 INTO v_max_note_id FROM CUSTOMER_EVENT_NOTES;\n    IF :NEW.RESIDENT_ID != :OLD.RESIDENT_ID OR :NEW.PROPERTY_ID != :OLD.PROPERTY_ID THEN\n        INSERT INTO CUSTOMER_EVENT_NOTES (CUSTOMER_EVENT_NOTE_ID, CUSTOMER_EVENT_ID, SERVICE_TYPE_CODE, RESIDENT_ID, PROPERTY_ID, DATE_MOVED_IN) VALUES (v_max_note_id, :NEW.CUSTOMER_EVENT_ID, 'Updated', :NEW.RESIDENT_ID, :NEW.PROPERTY_ID, :NEW.DATE_MOVED_IN);\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "UPDATE CUSTOMER_EVENTS SET RESIDENT_ID = 11, PROPERTY_ID = 606 WHERE CUSTOMER_EVENT_ID = 70",
      "UPDATE CUSTOMER_EVENTS SET RESIDENT_ID = 24, PROPERTY_ID = 880 WHERE CUSTOMER_EVENT_ID = 160",
      "UPDATE CUSTOMER_EVENTS SET RESIDENT_ID = 29, PROPERTY_ID = 630 WHERE CUSTOMER_EVENT_ID = 166",
      "UPDATE CUSTOMER_EVENTS SET RESIDENT_ID = 10, PROPERTY_ID = 605 WHERE CUSTOMER_EVENT_ID = 70",
      "UPDATE CUSTOMER_EVENTS SET RESIDENT_ID = 23, PROPERTY_ID = 879 WHERE CUSTOMER_EVENT_ID = 160"
    ],
    "summary": "Create an AFTER UPDATE row trigger named trg_update_event_note_service on CUSTOMER_EVENTS. If the RESIDENT_ID or PROPERTY_ID is changed, insert a new record into CUSTOMER_EVENT_NOTES with a generated ID and SERVICE_TYPE_CODE set to 'Updated'.",
    "natural_language": "How can I create an AFTER UPDATE row trigger named trg_update_event_note_service on the CUSTOMER_EVENTS table that inserts a new record into CUSTOMER_EVENT_NOTES with a generated ID and a SERVICE_TYPE_CODE of 'Updated' whenever the RESIDENT_ID or PROPERTY_ID is changed?",
    "id": 324
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_resident_consistency that executes before an insert operation on the RESIDENTS table for each row being inserted. The trigger begins by declaring three local variables: v_event_count, v_property_count, and v_resident_count, all of type NUMBER, to store counts from subsequent queries. The trigger first performs a SELECT COUNT(*) query on the PROPERTIES table to determine the number of records with a PROPERTY_ID matching the PROPERTY_ID of the new row being inserted into the RESIDENTS table. If no such record exists (v_property_count equals 0), it inserts a new record into the PROPERTIES table with the PROPERTY_ID from the new row, a default PROPERTY_TYPE_CODE of 'house', a default PROPERTY_ADDRESS of 'Auto-created', and OTHER_DETAILS set to 'System'. Next, the trigger checks the RESIDENTS table for existing records with the same DATE_MOVED_IN, PROPERTY_ID, and RESIDENT_ID as the new row, storing the count in v_resident_count. If v_resident_count is greater than 0, indicating a matching resident record already exists, the trigger performs another SELECT COUNT(*) query on the CUSTOMER_EVENTS table to count records with the same RESIDENT_ID, PROPERTY_ID, and DATE_MOVED_IN as the new row, storing the result in v_event_count. If v_event_count equals 0, meaning no matching event record exists, the trigger inserts a new record into the CUSTOMER_EVENTS table with a CUSTOMER_EVENT_ID generated by selecting the maximum existing CUSTOMER_EVENT_ID and adding 1, a fixed CUSTOMER_ID of 1, the DATE_MOVED_IN, PROPERTY_ID, and RESIDENT_ID from the new row, and a fixed THING_ID of 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_resident_consistency\nBEFORE INSERT ON RESIDENTS\nFOR EACH ROW\nDECLARE\n    v_event_count NUMBER;\n    v_property_count NUMBER;\n    v_resident_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_property_count FROM PROPERTIES WHERE PROPERTY_ID = :NEW.PROPERTY_ID;\n    IF v_property_count = 0 THEN\n        INSERT INTO PROPERTIES (PROPERTY_ID, PROPERTY_TYPE_CODE, PROPERTY_ADDRESS, OTHER_DETAILS) VALUES (:NEW.PROPERTY_ID, 'house', 'Auto-created', 'System');\n    END IF;\n\n    SELECT COUNT(*) INTO v_resident_count FROM RESIDENTS WHERE DATE_MOVED_IN = :NEW.DATE_MOVED_IN AND PROPERTY_ID = :NEW.PROPERTY_ID AND RESIDENT_ID = :NEW.RESIDENT_ID;\n    IF v_resident_count > 0 THEN\n        SELECT COUNT(*) INTO v_event_count FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID AND DATE_MOVED_IN = :NEW.DATE_MOVED_IN;\n        IF v_event_count = 0 THEN\n            INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES ((SELECT NVL(MAX(CUSTOMER_EVENT_ID), 0) + 1 FROM CUSTOMER_EVENTS), 1, :NEW.DATE_MOVED_IN, :NEW.PROPERTY_ID, :NEW.RESIDENT_ID, 1);\n        END IF;\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "INSERT INTO RESIDENTS (RESIDENT_ID, PROPERTY_ID, DATE_MOVED_IN, DATE_MOVED_OUT, OTHER_DETAILS) VALUES (1, 1001, '2023-01-01 10:00:00', NULL, 'New Resident 1')",
      "INSERT INTO RESIDENTS (RESIDENT_ID, PROPERTY_ID, DATE_MOVED_IN, DATE_MOVED_OUT, OTHER_DETAILS) VALUES (2, 1002, '2023-02-01 11:00:00', NULL, 'New Resident 2')",
      "INSERT INTO RESIDENTS (RESIDENT_ID, PROPERTY_ID, DATE_MOVED_IN, DATE_MOVED_OUT, OTHER_DETAILS) VALUES (3, 1003, '2023-03-01 12:00:00', NULL, 'New Resident 3')",
      "INSERT INTO RESIDENTS (RESIDENT_ID, PROPERTY_ID, DATE_MOVED_IN, DATE_MOVED_OUT, OTHER_DETAILS) VALUES (4, 1004, '2023-04-01 13:00:00', NULL, 'New Resident 4')",
      "INSERT INTO RESIDENTS (RESIDENT_ID, PROPERTY_ID, DATE_MOVED_IN, DATE_MOVED_OUT, OTHER_DETAILS) VALUES (5, 1005, '2023-05-01 14:00:00', NULL, 'New Resident 5')"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_maintain_resident_consistency on RESIDENTS. If the inserted PROPERTY_ID does not exist in PROPERTIES, insert a default property. If a resident with the same key already exists but has no matching event in CUSTOMER_EVENTS, insert a default event record.",
    "natural_language": "How can I create a BEFORE INSERT row trigger called trg_maintain_resident_consistency on the RESIDENTS table to insert a default property if the new PROPERTY_ID isn't in PROPERTIES, and to insert a default event record if a resident with the same key exists but lacks a matching entry in CUSTOMER_EVENTS?",
    "id": 325
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named player_school_audit that is executed after an insert operation on the PLAYER table for each row affected by the insert. The trigger begins by declaring two local variables: v_school_name of type VARCHAR2(255) to store the name of the school, and v_count of type NUMBER to store the count of records. The trigger first attempts to select the SCHOOL column from the SCHOOL table where the SCHOOL_ID matches the SCHOOL_ID of the newly inserted row in the PLAYER table, storing the result in v_school_name. If no matching SCHOOL_ID is found, the NO_DATA_FOUND exception is raised, and the trigger exits without performing further actions. If the SCHOOL_ID exists, the trigger proceeds to count the number of records in the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the newly inserted row, storing the result in v_count. If v_count equals zero, indicating that the SCHOOL_ID does not already exist in the SCHOOL_DETAILS table, the trigger inserts a new record into the SCHOOL_DETAILS table with the SCHOOL_ID from the newly inserted row, and default values for the NICKNAME, COLORS, LEAGUE, CLASS, and DIVISION columns, specifically 'New Player Added', 'Audit Color', 'Audit League', 'Audit Class', and 'Audit Division'.",
    "plsql": "CREATE OR REPLACE TRIGGER player_school_audit\nAFTER INSERT ON PLAYER\nFOR EACH ROW\nDECLARE\n    v_school_name VARCHAR2(255);\n    v_count NUMBER;\nBEGIN\n    -- Check if the SCHOOL_ID exists in the SCHOOL table\n    BEGIN\n        SELECT SCHOOL INTO v_school_name FROM SCHOOL WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            -- If no matching SCHOOL_ID is found, exit the trigger\n            RETURN;\n    END;\n\n    -- Check if the SCHOOL_ID already exists in SCHOOL_DETAILS\n    SELECT COUNT(*) INTO v_count FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    \n    IF v_count = 0 THEN\n        INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION)\n        VALUES (:NEW.SCHOOL_ID, 'New Player Added', 'Audit Color', 'Audit League', 'Audit Class', 'Audit Division');\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (10, 'New Player 1', 'Team A', 18, 'Pitcher', 2)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (11, 'New Player 2', 'Team B', 19, 'Catcher', 3)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (12, 'New Player 3', 'Team C', 20, 'Outfielder', 4)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (13, 'New Player 4', 'Team D', 17, 'First Baseman', 1)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (14, 'New Player 5', 'Team E', 16, 'Shortstop', 5)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named player_school_audit on the PLAYER table. For each new row, get the school name from the SCHOOL table using the new SCHOOL_ID. If the school exists, check if its ID is in the SCHOOL_DETAILS table. If not found, insert a default record into SCHOOL_DETAILS with the new SCHOOL_ID and preset values for NICKNAME, COLORS, LEAGUE, CLASS, and DIVISION. If the school does not exist, exit the trigger.",
    "natural_language": "Set up a trigger on the PLAYER table that runs after new entries are added. For each fresh entry, look up the associated school's name. If you find a school, see if its details are already properly recorded. If those details seem to be missing, go ahead and put in a standard set of details for that school, filling in the usual fields. If the school itself isn't there, then just stop and don't do anything further.",
    "id": 326
  },
  {
    "ir": "Write an Oracle PL/SQL BEFORE INSERT row-level trigger named player_age_validator that fires for each new row being inserted into the PLAYER table, which contains a logic block that conditionally adjusts the value of the incoming AGE column for the new row using a CASE expression: if the provided :NEW.AGE value is greater than 20, it is set to 20; if it is less than 10, it is set to 10; otherwise, the original :NEW.AGE value is retained, thereby enforcing a boundary constraint that the AGE must be between 10 and 20 inclusive for all inserted records.",
    "plsql": "CREATE OR REPLACE TRIGGER player_age_validator\nBEFORE INSERT ON PLAYER\nFOR EACH ROW\nBEGIN\n    -- Adjust the age of the new player to be within 10 and 20\n    :NEW.AGE := CASE WHEN :NEW.AGE > 20 THEN 20 WHEN :NEW.AGE < 10 THEN 10 ELSE :NEW.AGE END;\n    -- Removed: SELECT AVG(AGE) INTO v_avg_age FROM PLAYER WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    -- This would cause a mutating table error (ORA-04091) in a BEFORE INSERT row-level trigger.\n    -- Removed: DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID AND NICKNAME = 'Old Record';\n    -- DML on other tables in a BEFORE INSERT trigger is generally discouraged and can lead to issues.\n    -- If this cleanup is necessary, it should be handled in an AFTER INSERT trigger or application logic.\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (4, 'New Player 1', 'Team A', 5, 'Catcher', 1)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (5, 'New Player 2', 'Team B', 25, 'Pitcher', 2)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (6, 'New Player 3', 'Team C', 15, 'Shortstop', 1)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (7, 'New Player 4', 'Team D', 10, 'First Baseman', 2)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (8, 'New Player 5', 'Team E', 20, 'Third Baseman', 1)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named player_age_validator on the PLAYER table. For each new row, enforce that the AGE column value is between 10 and 20 inclusive. If the provided AGE is greater than 20, set it to 20. If it is less than 10, set it to 10.",
    "natural_language": "Create a BEFORE INSERT row-level trigger called player_age_validator for the PLAYER table. For each new row, ensure the AGE value is between 10 and 20. If the AGE is greater than 20, change it to 20. If it is less than 10, change it to 10.",
    "id": 327
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named school_details_synchronizer that is executed after a delete operation on the SCHOOL table for each row affected. The trigger begins by declaring a variable v_max_year of type VARCHAR2(255) to store the maximum SCHOOL_YEAR associated with the deleted SCHOOL_ID. It then performs a SELECT statement to retrieve the maximum SCHOOL_YEAR from the SCHOOL_PERFORMANCE table where the SCHOOL_ID matches the SCHOOL_ID of the deleted row, storing the result in v_max_year. If no data is found, the exception handler sets v_max_year to NULL. Following this, the trigger deletes all rows from the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the deleted row. Subsequently, the trigger checks if v_max_year is not NULL, and if this condition is true, it deletes rows from the SCHOOL_PERFORMANCE table where the SCHOOL_ID matches the SCHOOL_ID of the deleted row and the SCHOOL_YEAR equals v_max_year.",
    "plsql": "CREATE OR REPLACE TRIGGER school_details_synchronizer\nAFTER DELETE ON SCHOOL\nFOR EACH ROW\nDECLARE\n    v_max_year VARCHAR2(255);\nBEGIN\n    -- Get the maximum SCHOOL_YEAR for the deleted SCHOOL_ID\n    BEGIN\n        SELECT MAX(SCHOOL_YEAR)\n        INTO v_max_year\n        FROM SCHOOL_PERFORMANCE\n        WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_max_year := NULL;\n    END;\n    \n    -- Delete from SCHOOL_DETAILS\n    DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    \n    -- Delete from SCHOOL_PERFORMANCE only if v_max_year is not NULL\n    IF v_max_year IS NOT NULL THEN\n        DELETE FROM SCHOOL_PERFORMANCE \n        WHERE SCHOOL_ID = :OLD.SCHOOL_ID \n        AND SCHOOL_YEAR = v_max_year;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 2",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 3",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 4",
      "DELETE FROM SCHOOL WHERE SCHOOL = 'Barker College'",
      "DELETE FROM SCHOOL WHERE LOCATION = 'Wahroonga'"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named school_details_synchronizer on the SCHOOL table. For each deleted row, find the maximum SCHOOL_YEAR for that SCHOOL_ID from the SCHOOL_PERFORMANCE table. Then delete all records for that SCHOOL_ID from the SCHOOL_DETAILS table. Finally, if a maximum year was found, delete the corresponding record from the SCHOOL_PERFORMANCE table for that SCHOOL_ID and maximum SCHOOL_YEAR.",
    "natural_language": "How can I create an AFTER DELETE row-level trigger called school_details_synchronizer on the SCHOOL table so that, for each deleted row, it finds the maximum SCHOOL_YEAR for that SCHOOL_ID from the SCHOOL_PERFORMANCE table, deletes all records for that SCHOOL_ID from the SCHOOL_DETAILS table, and then, if a maximum year was found, deletes the corresponding record from the SCHOOL_PERFORMANCE table for that SCHOOL_ID and maximum SCHOOL_YEAR?",
    "id": 328
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `player_team_normalizer` on the `PLAYER` table. This trigger executes before any `INSERT` or `UPDATE` operation on a row in the `PLAYER` table. It declares two local `VARCHAR2(255)` variables: `v_first_position` and `v_school_year`. The trigger first attempts to retrieve the `POSITION` of the player with the lowest `PLAYER_ID` among all players associated with the same `SCHOOL_ID` as the new or updated player (`:NEW.SCHOOL_ID`). This is achieved by selecting `POSITION` from a subquery that orders players by `PLAYER_ID` within the same `SCHOOL_ID` and then limiting the result to the first row using `ROWNUM = 1`. If no players are found for the given `SCHOOL_ID` (i.e., `NO_DATA_FOUND` exception occurs), `v_first_position` is set to the string literal 'Unknown'. Next, the trigger modifies the `TEAM` column of the new or updated row (`:NEW.TEAM`) by converting its value to uppercase using the `UPPER()` function. It also modifies the `POSITION` column of the new or updated row (`:NEW.POSITION`) by converting its value to initial capital letters using the `INITCAP()` function. Subsequently, it constructs a `v_school_year` string by concatenating the current year (obtained from `SYSDATE` using `TO_CHAR(SYSDATE, 'YYYY')`) with a hyphen and the last two digits of the year one year from now (obtained from `SYSDATE + 365` using `TO_CHAR(SYSDATE + 365, 'YY')`). Following this, the trigger attempts to insert a new record into the `SCHOOL_PERFORMANCE` table. The `SCHOOL_ID` for this new record is taken from the new or updated player's `SCHOOL_ID` (`:NEW.SCHOOL_ID`), the `SCHOOL_YEAR` is set to the previously generated `v_school_year`, the `CLASS_A` column is set to the string literal 'New Player', and the `CLASS_AA` column is set to the string literal 'Team Update'. If this `INSERT` operation fails due to a `DUP_VAL_ON_INDEX` exception (indicating that a record with the same `SCHOOL_ID` and `SCHOOL_YEAR` already exists), the trigger instead performs an `UPDATE` operation on the `SCHOOL_PERFORMANCE` table. This `UPDATE` sets the `CLASS_A` column to 'Updated Player' and the `CLASS_AA` column to 'Team Update' for the row where `SCHOOL_ID` matches `:NEW.SCHOOL_ID` and `SCHOOL_YEAR` matches `v_school_year`.",
    "plsql": "CREATE OR REPLACE TRIGGER player_team_normalizer\nBEFORE INSERT OR UPDATE ON PLAYER\nFOR EACH ROW\nDECLARE\n    v_first_position VARCHAR2(255);\n    v_school_year VARCHAR2(255);\nBEGIN\n    -- Get the first position for players in the same school, handling case where no other players exist\n    BEGIN\n        SELECT POSITION INTO v_first_position \n        FROM (SELECT POSITION FROM PLAYER \n              WHERE SCHOOL_ID = :NEW.SCHOOL_ID \n              ORDER BY PLAYER_ID) \n        WHERE ROWNUM = 1;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_first_position := 'Unknown';\n    END;\n    \n    :NEW.TEAM := UPPER(:NEW.TEAM);\n    :NEW.POSITION := INITCAP(:NEW.POSITION);\n    \n    -- Generate school year and handle potential duplicate key\n    v_school_year := TO_CHAR(SYSDATE, 'YYYY') || '-' || TO_CHAR(SYSDATE + 365, 'YY');\n    \n    BEGIN\n        INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR, CLASS_A, CLASS_AA)\n        VALUES (:NEW.SCHOOL_ID, v_school_year, 'New Player', 'Team Update');\n    EXCEPTION\n        WHEN DUP_VAL_ON_INDEX THEN\n            -- Record already exists for this school and year, update instead\n            UPDATE SCHOOL_PERFORMANCE \n            SET CLASS_A = 'Updated Player', CLASS_AA = 'Team Update'\n            WHERE SCHOOL_ID = :NEW.SCHOOL_ID AND SCHOOL_YEAR = v_school_year;\n    END;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (100, 'John Smith', 'new york yankees', 17, 'pitcher', 1)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (101, 'Jane Doe', 'boston red sox', 16, 'center fielder', 2)",
      "UPDATE PLAYER SET TEAM = 'los angeles dodgers', POSITION = 'first baseman' WHERE PLAYER_ID = 1",
      "UPDATE PLAYER SET TEAM = 'chicago cubs', AGE = 18 WHERE PLAYER_ID = 2",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (102, 'Alex Johnson', 'san francisco giants', 15, 'catcher', 3)"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named player_team_normalizer on the PLAYER table. For each new or updated row, find the POSITION of the first player (by lowest PLAYER_ID) in the same SCHOOL_ID, defaulting to 'Unknown'. Convert the new TEAM to uppercase and the new POSITION to initial caps. Generate a school year string (e.g., '2024-25'). Then, insert a record into SCHOOL_PERFORMANCE with the new SCHOOL_ID, the generated year, and preset class values. If a duplicate key error occurs, update the existing SCHOOL_PERFORMANCE record instead.",
    "natural_language": "Create a BEFORE INSERT OR UPDATE row-level trigger called player_team_normalizer on the PLAYER table. For each new or updated row, first find the POSITION of the earliest player (lowest PLAYER_ID) with the same SCHOOL_ID, using 'Unknown' if none is found. Then, convert the new TEAM value to uppercase and the new POSITION value to initial caps. Also, generate a school year string like '2024-25'. Finally, insert this data along with the new SCHOOL_ID and preset class values into the SCHOOL_PERFORMANCE table. If a duplicate key error happens, update the existing SCHOOL_PERFORMANCE record instead.",
    "id": 329
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_service that is executed automatically after a DELETE operation is performed on the SERVICES table. This trigger operates for each row that is deleted from the SERVICES table. Within the trigger's body, it performs a DELETE operation on the RESIDENTS_SERVICES table, specifically targeting rows where the SERVICE_ID column matches the SERVICE_ID of the row that was just deleted from the SERVICES table. The :OLD prefix is used to refer to the value of the SERVICE_ID column from the deleted row in the SERVICES table, ensuring that the deletion in the RESIDENTS_SERVICES table is directly linked to the corresponding SERVICE_ID of the deleted service.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_service\nAFTER DELETE ON SERVICES\nFOR EACH ROW\nBEGIN\n  DELETE FROM RESIDENTS_SERVICES\n  WHERE SERVICE_ID = :OLD.SERVICE_ID;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "DELETE FROM SERVICES WHERE SERVICE_ID = 10",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 11",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 13",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 49",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 41"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_service on the SERVICES table. For each deleted row, delete all related records from the RESIDENTS_SERVICES table where the SERVICE_ID matches the deleted service's ID.",
    "natural_language": "Please construct an AFTER DELETE row-level trigger designated as trg_delete_service on the SERVICES table. For every row that is deleted, the trigger must proceed to delete all associated records within the RESIDENTS_SERVICES table where the SERVICE_ID corresponds to the ID of the service that has been removed.",
    "id": 330
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_service_type` that is configured to execute AFTER an `UPDATE` operation occurs on any row within the `SERVICES` table. This trigger is a `FOR EACH ROW` trigger, meaning its body will execute once for every individual row that is updated in the `SERVICES` table. Upon activation, the trigger performs a single `INSERT` operation into the `RESIDENTS_SERVICES` table. The `INSERT` statement populates the following columns in the `RESIDENTS_SERVICES` table: the `RESIDENT_ID` column is set to the literal numeric value `6`; the `SERVICE_ID` column is set to the value of the `SERVICE_ID` column from the row that was just updated in the `SERVICES` table, referenced as `:NEW.SERVICE_ID`; the `DATE_MOVED_IN` column is set to the literal string value `'2017-06-17 15:43:33'`; the `PROPERTY_ID` column is set to the literal numeric value `954`; the `DATE_REQUESTED` column is set to the literal string value `'2023-10-01 00:00:00'`; the `DATE_PROVIDED` column is set to the literal string value `'2023-10-01 00:00:00'`; and the `OTHER_DETAILS` column is set to the literal string value `'Updated Service Type'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_service_type\nAFTER UPDATE ON SERVICES\nFOR EACH ROW\nBEGIN\n  -- To avoid ORA-02291, the values for RESIDENT_ID, PROPERTY_ID, and DATE_MOVED_IN\n  -- must exist as a primary key in the parent table referenced by the foreign key\n  -- FK_RESIDENTS_SERVICES_RESIDENT_ID_PROPERTY_ID_DATE_MOVED_IN.\n  -- Since the parent table schema is not provided, we use example values\n  -- from the RESIDENTS_SERVICES table itself, assuming they might exist\n  -- in the parent table.\n  -- Also, JSON_QUERY is not appropriate for a simple string literal.\n  INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n  VALUES (6, :NEW.SERVICE_ID, '2017-06-17 15:43:33', 954, '2023-10-01 00:00:00', '2023-10-01 00:00:00', 'Updated Service Type');\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "UPDATE SERVICES SET SERVICE_TYPE_CODE = 'Cleaning' WHERE SERVICE_ID = 10",
      "UPDATE SERVICES SET SERVICE_DETAILS = 'Updated' WHERE SERVICE_ID = 11",
      "UPDATE SERVICES SET ORGANIZATION_ID = 8 WHERE SERVICE_ID = 13",
      "UPDATE SERVICES SET SERVICE_TYPE_CODE = 'Check', SERVICE_DETAILS = 'Satisfied' WHERE SERVICE_ID = 49",
      "UPDATE SERVICES SET ORGANIZATION_ID = 7, SERVICE_TYPE_CODE = 'Moving Out' WHERE SERVICE_ID = 41"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_service_type on the SERVICES table that inserts a record into RESIDENTS_SERVICES with RESIDENT_ID=6, SERVICE_ID=:NEW.SERVICE_ID, DATE_MOVED_IN='2017-06-17 15:43:33', PROPERTY_ID=954, DATE_REQUESTED='2023-10-01 00:00:00', DATE_PROVIDED='2023-10-01 00:00:00', and OTHER_DETAILS='Updated Service Type'.",
    "natural_language": "Hey, can you set up a trigger called trg_update_service_type on the SERVICES table? It should fire after each row gets updated. What it needs to do is pop a new record into the RESIDENTS_SERVICES table. Use RESIDENT_ID as 6, grab the new SERVICE_ID, set DATE_MOVED_IN to '2017-06-17 15:43:33', PROPERTY_ID to 954, and both DATE_REQUESTED and DATE_PROVIDED to '2023-10-01 00:00:00'. Oh, and slap in 'Updated Service Type' for the OTHER_DETAILS. Thanks!",
    "id": 331
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_resident_service that is defined to execute automatically after a delete operation is performed on the RESIDENTS_SERVICES table, and within this trigger, declare a cursor named c_orphaned_services that selects the SERVICE_ID column from the SERVICES table for every row where there does not exist a corresponding row in the RESIDENTS_SERVICES table with a matching SERVICE_ID, then open that cursor and iterate through each fetched record, and for each record, execute a delete operation on the SERVICES table where the SERVICE_ID column equals the SERVICE_ID value from the current cursor record.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_resident_service\nAFTER DELETE ON RESIDENTS_SERVICES\nDECLARE\n  CURSOR c_orphaned_services IS\n    SELECT s.SERVICE_ID\n    FROM SERVICES s\n    WHERE NOT EXISTS (\n      SELECT 1\n      FROM RESIDENTS_SERVICES rs\n      WHERE rs.SERVICE_ID = s.SERVICE_ID\n    );\nBEGIN\n  FOR rec IN c_orphaned_services LOOP\n    DELETE FROM SERVICES\n    WHERE SERVICE_ID = rec.SERVICE_ID;\n  END LOOP;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "DELETE FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = 6 AND SERVICE_ID = 49",
      "DELETE FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = 23 AND SERVICE_ID = 41",
      "DELETE FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = 28 AND SERVICE_ID = 11",
      "DELETE FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = 1 AND SERVICE_ID = 10",
      "DELETE FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = 2 AND SERVICE_ID = 13"
    ],
    "summary": "Create an AFTER DELETE trigger named trg_delete_resident_service on the RESIDENTS_SERVICES table that uses a cursor to find SERVICE_ID values in SERVICES with no matching record in RESIDENTS_SERVICES, then deletes those orphaned records from the SERVICES table.",
    "natural_language": "Set up a trigger called trg_delete_resident_service to run after something gets removed from the RESIDENTS_SERVICES table. It should go through things and find SERVICE_ID entries in the SERVICES table that don't seem to be linked to anything in RESIDENTS_SERVICES anymore, then clean up those leftover records from SERVICES.",
    "id": 332
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_major_ranking_ins` on the `MAJOR_RANKING` table. This trigger executes automatically for each row *before* an `INSERT` operation is performed on the `MAJOR_RANKING` table. The trigger declares two local `NUMBER` variables: `v_univ_count` and `v_major_count`. Upon execution, the trigger first performs a `SELECT COUNT(*)` operation on the `UNIVERSITY` table to count the number of rows where the `UNIVERSITY_ID` column matches the `UNIVERSITY_ID` value of the new row being inserted into `MAJOR_RANKING` (referenced as `:NEW.UNIVERSITY_ID`). The result of this count is stored in the `v_univ_count` variable. Following this, a conditional `IF` statement checks if `v_univ_count` is equal to `0`. If `v_univ_count` is `0`, indicating that no university with the specified `UNIVERSITY_ID` exists in the `UNIVERSITY` table, the trigger then executes an `INSERT` statement into the `UNIVERSITY` table. This `INSERT` statement populates the `UNIVERSITY_ID` column with `:NEW.UNIVERSITY_ID`, the `UNIVERSITY_NAME` column with the concatenated string 'New University ' and the character representation of `:NEW.UNIVERSITY_ID` (obtained using `TO_CHAR(:NEW.UNIVERSITY_ID)`), the `CITY` column with the literal string 'Unknown', the `STATE` column with the literal string 'Unknown', the `TEAM_NAME` column with the concatenated string 'Team ' and the character representation of `:NEW.UNIVERSITY_ID`, the `AFFILIATION` column with the literal string 'Unknown', the `ENROLLMENT` column with the numeric value `0`, and the `HOME_CONFERENCE` column with the literal string 'Unknown'. After this, or if `v_univ_count` was not `0`, the trigger proceeds to perform another `SELECT COUNT(*)` operation, this time on the `MAJOR` table, to count the number of rows where the `MAJOR_ID` column matches the `MAJOR_ID` value of the new row being inserted into `MAJOR_RANKING` (referenced as `:NEW.MAJOR_ID`). The result of this count is stored in the `v_major_count` variable. Subsequently, another conditional `IF` statement checks if `v_major_count` is equal to `0`. If `v_major_count` is `0`, indicating that no major with the specified `MAJOR_ID` exists in the `MAJOR` table, the trigger then executes an `INSERT` statement into the `MAJOR` table. This `INSERT` statement populates the `MAJOR_ID` column with `:NEW.MAJOR_ID`, the `MAJOR_NAME` column with the concatenated string 'New Major ' and the character representation of `:NEW.MAJOR_ID` (obtained using `TO_CHAR(:NEW.MAJOR_ID)`), and the `MAJOR_CODE` column with the numeric value `9999`. The trigger then completes its execution.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_ranking_ins\nBEFORE INSERT ON MAJOR_RANKING\nFOR EACH ROW\nDECLARE\n    v_univ_count NUMBER;\n    v_major_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_univ_count FROM UNIVERSITY WHERE UNIVERSITY_ID = :NEW.UNIVERSITY_ID;\n    IF v_univ_count = 0 THEN\n        INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, TEAM_NAME, AFFILIATION, ENROLLMENT, HOME_CONFERENCE)\n        VALUES (:NEW.UNIVERSITY_ID, 'New University ' || TO_CHAR(:NEW.UNIVERSITY_ID), 'Unknown', 'Unknown', 'Team ' || TO_CHAR(:NEW.UNIVERSITY_ID), 'Unknown', 0, 'Unknown');\n    END IF;\n    SELECT COUNT(*) INTO v_major_count FROM MAJOR WHERE MAJOR_ID = :NEW.MAJOR_ID;\n    IF v_major_count = 0 THEN\n        INSERT INTO MAJOR (MAJOR_ID, MAJOR_NAME, MAJOR_CODE)\n        VALUES (:NEW.MAJOR_ID, 'New Major ' || TO_CHAR(:NEW.MAJOR_ID), 9999);\n    END IF;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "INSERT INTO MAJOR_RANKING (RANK, UNIVERSITY_ID, MAJOR_ID) VALUES (1, 4, 4)",
      "INSERT INTO MAJOR_RANKING (RANK, UNIVERSITY_ID, MAJOR_ID) VALUES (2, 5, 5)",
      "INSERT INTO MAJOR_RANKING (RANK, UNIVERSITY_ID, MAJOR_ID) VALUES (3, 6, 6)",
      "INSERT INTO MAJOR_RANKING (RANK, UNIVERSITY_ID, MAJOR_ID) VALUES (4, 7, 7)",
      "INSERT INTO MAJOR_RANKING (RANK, UNIVERSITY_ID, MAJOR_ID) VALUES (5, 8, 8)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_major_ranking_ins on the MAJOR_RANKING table. If the new UNIVERSITY_ID doesn't exist in the UNIVERSITY table, insert it with default values. If the new MAJOR_ID doesn't exist in the MAJOR table, insert it with default values.",
    "natural_language": "Construct a BEFORE INSERT FOR EACH ROW trigger, which should be named trg_major_ranking_ins, specifically for the MAJOR_RANKING table. This trigger must first check, in a detailed manner, whether the newly provided UNIVERSITY_ID value is already present within the UNIVERSITY table; if it is not found, the trigger must then proceed to insert this identifier into the UNIVERSITY table using a set of sensible default values. Subsequently, it must perform a similar, thorough verification for the new MAJOR_ID against the MAJOR table, and if that identifier is also absent, it must insert it into the MAJOR table, again employing appropriate default values.",
    "id": 333
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_overall_ranking_upd that is executed before an update operation on the OVERALL_RANKING table for each row being updated. The trigger evaluates the value of the REPUTATION_POINT column in the new version of the row (:NEW.REPUTATION_POINT). If the REPUTATION_POINT is greater than 10, it calculates the TOTAL column as the sum of REPUTATION_POINT, RESEARCH_POINT, CITATION_POINT, and an additional 5 points. If the REPUTATION_POINT is between 5 and 10 inclusive, it sets the TOTAL column to the sum of REPUTATION_POINT, RESEARCH_POINT, and CITATION_POINT without any additional points. If the REPUTATION_POINT is less than 5, it calculates the TOTAL column as the sum of REPUTATION_POINT, RESEARCH_POINT, and CITATION_POINT, subtracting 2 points. Additionally, if the RESEARCH_POINT column in the new version of the row (:NEW.RESEARCH_POINT) is greater than 5, it further increases the TOTAL column by 3 points. The trigger does not perform any other operations such as inserts, deletes, or selects, and it does not call any functions or perform any special operations.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_overall_ranking_upd\nBEFORE UPDATE ON OVERALL_RANKING\nFOR EACH ROW\nBEGIN\n    IF :NEW.REPUTATION_POINT > 10 THEN\n        :NEW.TOTAL := :NEW.REPUTATION_POINT + :NEW.RESEARCH_POINT + :NEW.CITATION_POINT + 5;\n    ELSIF :NEW.REPUTATION_POINT BETWEEN 5 AND 10 THEN\n        :NEW.TOTAL := :NEW.REPUTATION_POINT + :NEW.RESEARCH_POINT + :NEW.CITATION_POINT;\n    ELSE\n        :NEW.TOTAL := :NEW.REPUTATION_POINT + :NEW.RESEARCH_POINT + :NEW.CITATION_POINT - 2;\n    END IF;\n    IF :NEW.RESEARCH_POINT > 5 THEN\n        :NEW.TOTAL := :NEW.TOTAL + 3;\n    END IF;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "UPDATE OVERALL_RANKING SET REPUTATION_POINT = 12 WHERE UNIVERSITY_ID = 1",
      "UPDATE OVERALL_RANKING SET REPUTATION_POINT = 8 WHERE UNIVERSITY_ID = 2",
      "UPDATE OVERALL_RANKING SET REPUTATION_POINT = 3 WHERE UNIVERSITY_ID = 3",
      "UPDATE OVERALL_RANKING SET REPUTATION_POINT = 15 WHERE UNIVERSITY_ID = 1",
      "UPDATE OVERALL_RANKING SET REPUTATION_POINT = 6 WHERE UNIVERSITY_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_overall_ranking_upd on the OVERALL_RANKING table that calculates the TOTAL column based on REPUTATION_POINT value: add 5 if >10, subtract 2 if <5, otherwise use sum. Add 3 to TOTAL if RESEARCH_POINT > 5.",
    "natural_language": "Alright, so we need a trigger called trg_overall_ranking_upd that fires before any row gets updated in the OVERALL_RANKING table. Here's the deal for the TOTAL column: first, check the REPUTATION_POINT. If it's more than 10, toss in an extra 5. If it's less than 5, knock off 2. If it's somewhere in between, just use the sum as is. Oh, and one more thingif RESEARCH_POINT is above 5, throw another 3 into the TOTAL. Got it?",
    "id": 334
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_university_ins that fires automatically after each successful insertion of a new row into the UNIVERSITY table, and for each newly inserted row, it performs three separate MERGE operations into the MAJOR_RANKING table, each using a hard-coded set of values derived from the new university's ID; the first MERGE attempts to insert a record with a RANK of 1, a UNIVERSITY_ID equal to the newly inserted :NEW.UNIVERSITY_ID, and a MAJOR_ID of 1, but only if an identical record with matching RANK, UNIVERSITY_ID, and MAJOR_ID does not already exist in the MAJOR_RANKING table; the second MERGE attempts to insert a record with a RANK of 2, the same :NEW.UNIVERSITY_ID, and a MAJOR_ID of 2, again only if that specific combination is not already present; the third MERGE attempts to insert a record with a RANK of 3, the same :NEW.UNIVERSITY_ID, and a MAJOR_ID of 3, provided it is also not already present in the MAJOR_RANKING table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_university_ins\nAFTER INSERT ON UNIVERSITY\nFOR EACH ROW\nBEGIN\n    MERGE INTO MAJOR_RANKING dst\n    USING (SELECT 1 AS RANK, :NEW.UNIVERSITY_ID AS UNIVERSITY_ID, 1 AS MAJOR_ID FROM DUAL) src\n    ON (dst.RANK = src.RANK AND dst.UNIVERSITY_ID = src.UNIVERSITY_ID AND dst.MAJOR_ID = src.MAJOR_ID)\n    WHEN NOT MATCHED THEN\n        INSERT (RANK, UNIVERSITY_ID, MAJOR_ID)\n        VALUES (src.RANK, src.UNIVERSITY_ID, src.MAJOR_ID);\n\n    MERGE INTO MAJOR_RANKING dst\n    USING (SELECT 2 AS RANK, :NEW.UNIVERSITY_ID AS UNIVERSITY_ID, 2 AS MAJOR_ID FROM DUAL) src\n    ON (dst.RANK = src.RANK AND dst.UNIVERSITY_ID = src.UNIVERSITY_ID AND dst.MAJOR_ID = src.MAJOR_ID)\n    WHEN NOT MATCHED THEN\n        INSERT (RANK, UNIVERSITY_ID, MAJOR_ID)\n        VALUES (src.RANK, src.UNIVERSITY_ID, src.MAJOR_ID);\n\n    MERGE INTO MAJOR_RANKING dst\n    USING (SELECT 3 AS RANK, :NEW.UNIVERSITY_ID AS UNIVERSITY_ID, 3 AS MAJOR_ID FROM DUAL) src\n    ON (dst.RANK = src.RANK AND dst.UNIVERSITY_ID = src.UNIVERSITY_ID AND dst.MAJOR_ID = src.MAJOR_ID)\n    WHEN NOT MATCHED THEN\n        INSERT (RANK, UNIVERSITY_ID, MAJOR_ID)\n        VALUES (src.RANK, src.UNIVERSITY_ID, src.MAJOR_ID);\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, TEAM_NAME, AFFILIATION, ENROLLMENT, HOME_CONFERENCE) VALUES (100, 'Test University', 'Test City', 'Test State', 'Test Team', 'Private', 5000, 'Test Conference')",
      "INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE) VALUES (101, 'Another University', 'Another City', 'Another State')",
      "INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, TEAM_NAME, AFFILIATION, ENROLLMENT, HOME_CONFERENCE) VALUES (102, 'State College', 'Capital City', 'New State', 'Lions', 'Public', 15000, 'Big Conference')",
      "INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME) VALUES (103, 'Minimal University')",
      "INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, ENROLLMENT) VALUES (104, 'Tech Institute', 'Tech City', 'Tech State', 8000)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_university_ins on the UNIVERSITY table that performs three MERGE operations into MAJOR_RANKING for the new university, inserting records with RANK values 1, 2, 3 and corresponding MAJOR_ID values 1, 2, 3 if they don't already exist.",
    "natural_language": "Set up a trigger on the UNIVERSITY table for new entries that, after each insert, does a few MERGE operations into the MAJOR_RANKING table. It should add some records for the new university with the top few rank numbers and their associated major IDs, but only if those specific combinations aren't already there.",
    "id": 335
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_major_upd that is executed before an update operation on each row of the MAJOR table. This trigger checks if the new value of the MAJOR_CODE column is NULL, and if so, assigns it a default value of 9999. It also checks if the new value of the MAJOR_NAME column is NULL, and if so, assigns it the default string 'Unknown Major'. Additionally, if the new value of MAJOR_CODE is less than 1000, the trigger increases this value by adding 1000 to it. The trigger ensures that every update operation on the MAJOR table results in a non-null MAJOR_CODE and MAJOR_NAME, and that the MAJOR_CODE is adjusted to be at least 1000.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_upd\nBEFORE UPDATE ON MAJOR\nFOR EACH ROW\nBEGIN\n    IF :NEW.MAJOR_CODE IS NULL THEN\n        :NEW.MAJOR_CODE := 9999;\n    END IF;\n    IF :NEW.MAJOR_NAME IS NULL THEN\n        :NEW.MAJOR_NAME := 'Unknown Major';\n    END IF;\n    IF :NEW.MAJOR_CODE < 1000 THEN\n        :NEW.MAJOR_CODE := :NEW.MAJOR_CODE + 1000;\n    END IF;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "UPDATE MAJOR SET MAJOR_CODE = NULL, MAJOR_NAME = NULL WHERE MAJOR_ID = 1",
      "UPDATE MAJOR SET MAJOR_CODE = 500 WHERE MAJOR_ID = 2",
      "UPDATE MAJOR SET MAJOR_NAME = NULL WHERE MAJOR_ID = 3",
      "UPDATE MAJOR SET MAJOR_CODE = 2000 WHERE MAJOR_ID = 1",
      "UPDATE MAJOR SET MAJOR_CODE = 999, MAJOR_NAME = 'Test Major' WHERE MAJOR_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_major_upd on the MAJOR table. If the new MAJOR_CODE is NULL, set it to 9999. If the new MAJOR_NAME is NULL, set it to 'Unknown Major'. If the new MAJOR_CODE is less than 1000, add 1000 to it.",
    "natural_language": "Define a BEFORE UPDATE FOR EACH ROW trigger called trg_major_upd on the MAJOR table. For each update, set the new MAJOR_CODE to 9999 if it is NULL, set the new MAJOR_NAME to 'Unknown Major' if it is NULL, and add 1000 to the new MAJOR_CODE if it is less than 1000.",
    "id": 336
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_major_ranking_del that is a compound trigger designed to execute on the DELETE operation of the MAJOR_RANKING table. This trigger uses two collections, university_ids and major_ids, both of which are of the type id_list, a nested table of NUMBER, to store the UNIVERSITY_ID and MAJOR_ID values of the rows being deleted. The trigger consists of three sections: BEFORE STATEMENT, AFTER EACH ROW, and AFTER STATEMENT. In the BEFORE STATEMENT section, the trigger initializes the university_ids and major_ids collections by deleting any existing elements. In the AFTER EACH ROW section, the trigger appends the UNIVERSITY_ID and MAJOR_ID of each deleted row to the university_ids and major_ids collections, respectively, using the EXTEND method to increase the size of the collections and the COUNT method to determine the current number of elements. In the AFTER STATEMENT section, the trigger iterates over each element in the university_ids collection using a FOR loop. For each university_id, it declares a local variable v_count of type NUMBER and executes a SELECT COUNT(*) query on the MAJOR_RANKING table to count the number of remaining rows with the same UNIVERSITY_ID. If v_count is zero, indicating no remaining rows with that UNIVERSITY_ID, the trigger deletes the corresponding row from the UNIVERSITY table. Similarly, the trigger iterates over each element in the major_ids collection, performs a SELECT COUNT(*) query to count the remaining rows with the same MAJOR_ID in the MAJOR_RANKING table, and deletes the corresponding row from the MAJOR table if v_count is zero. This ensures that orphaned records in the UNIVERSITY and MAJOR tables are removed when all associated entries in the MAJOR_RANKING table are deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_ranking_del\nFOR DELETE ON MAJOR_RANKING\nCOMPOUND TRIGGER\n\n  TYPE id_list IS TABLE OF NUMBER;\n  university_ids id_list := id_list();\n  major_ids id_list := id_list();\n\n  BEFORE STATEMENT IS\n  BEGIN\n    university_ids.DELETE;\n    major_ids.DELETE;\n  END BEFORE STATEMENT;\n\n  AFTER EACH ROW IS\n  BEGIN\n    university_ids.EXTEND;\n    university_ids(university_ids.COUNT) := :OLD.UNIVERSITY_ID;\n\n    major_ids.EXTEND;\n    major_ids(major_ids.COUNT) := :OLD.MAJOR_ID;\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n  BEGIN\n    FOR i IN 1 .. university_ids.COUNT LOOP\n      DECLARE\n        v_count NUMBER;\n      BEGIN\n        SELECT COUNT(*) INTO v_count FROM MAJOR_RANKING WHERE UNIVERSITY_ID = university_ids(i);\n        IF v_count = 0 THEN\n          DELETE FROM UNIVERSITY WHERE UNIVERSITY_ID = university_ids(i);\n        END IF;\n      END;\n    END LOOP;\n\n    FOR i IN 1 .. major_ids.COUNT LOOP\n      DECLARE\n        v_count NUMBER;\n      BEGIN\n        SELECT COUNT(*) INTO v_count FROM MAJOR_RANKING WHERE MAJOR_ID = major_ids(i);\n        IF v_count = 0 THEN\n          DELETE FROM MAJOR WHERE MAJOR_ID = major_ids(i);\n        END IF;\n      END;\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_major_ranking_del;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 1 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 3 AND MAJOR_ID = 3",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 2 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 3 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 1 AND MAJOR_ID = 3"
    ],
    "summary": "Create a compound trigger named trg_major_ranking_del for DELETE operations on the MAJOR_RANKING table. In BEFORE STATEMENT, initialize two NUMBER collections. In AFTER EACH ROW, store deleted UNIVERSITY_ID and MAJOR_ID in the collections. In AFTER STATEMENT, for each stored UNIVERSITY_ID and MAJOR_ID, if no related rows remain in MAJOR_RANKING, delete the corresponding parent record from the UNIVERSITY or MAJOR table.",
    "natural_language": "Construct a compound trigger, which should be named trg_major_ranking_del, to specifically handle DELETE operations on the MAJOR_RANKING table. In the BEFORE STATEMENT section, you must carefully initialize two distinct NUMBER collections. Subsequently, in the AFTER EACH ROW section, you need to capture and securely store the deleted UNIVERSITY_ID and MAJOR_ID values within those previously initialized collections. Finally, in the AFTER STATEMENT section, for every single stored pair of UNIVERSITY_ID and MAJOR_ID, you must perform a thorough check to see if any related rows still persist in the MAJOR_RANKING table; if no such related rows remain, you are then required to delete the corresponding parent record from either the UNIVERSITY table or the MAJOR table.",
    "id": 337
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_company_name_lowercase` that is activated `BEFORE` an `INSERT` operation is performed on the `COMPANY` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will execute once for every individual row that is being inserted into the `COMPANY` table. The trigger's primary purpose is to modify the value of the `NAME` column for the new row (`:NEW.NAME`) before it is permanently stored in the table. Specifically, it assigns the lowercase version of the value originally provided for the `NAME` column in the new row (`:NEW.NAME`) back to the `NAME` column of that same new row. This transformation is achieved by calling the built-in SQL function `LOWER()`, which takes a string expression as input and returns the string with all alphabetic characters converted to lowercase. The `NAME` column is implicitly expected to be of a character data type (e.g., `VARCHAR2`, `NVARCHAR2`, `CHAR`). The `:NEW` pseudorecord represents the row data as it will appear after the `INSERT` operation, but before it is actually committed to the table, allowing for modifications to its column values.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_company_name_lowercase\nBEFORE INSERT ON COMPANY\nFOR EACH ROW\nBEGIN\n  :NEW.NAME := LOWER(:NEW.NAME);\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "DIRECTOR",
      "PRODUCER",
      "WRITER",
      "COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO COMPANY (ID, NAME, COUNTRY_CODE) VALUES (1, 'APPLE', 'US')",
      "INSERT INTO COMPANY (ID, NAME, COUNTRY_CODE) VALUES (2, 'MICROSOFT', 'US')",
      "INSERT INTO COMPANY (ID, NAME, COUNTRY_CODE) VALUES (3, 'GOOGLE', 'US')",
      "INSERT INTO COMPANY (ID, NAME, COUNTRY_CODE) VALUES (4, 'AMAZON', 'US')",
      "INSERT INTO COMPANY (ID, NAME, COUNTRY_CODE) VALUES (5, 'TESLA', 'US')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_insert_company_name_lowercase on the COMPANY table. Convert the new NAME value to lowercase before insertion.",
    "natural_language": "Set up a BEFORE INSERT FOR EACH ROW trigger called trg_insert_company_name_lowercase for the COMPANY table to change the new NAME value to lowercase before it is inserted.",
    "id": 338
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is executed automatically before an INSERT operation is performed on the DIRECTOR table. The trigger modifies the value of the NAME column in the row being inserted by converting the value to uppercase using the UPPER() function. The trigger uses the :NEW pseudo-record to access the NAME column of the row that is about to be inserted. Specifically, the :NEW.NAME reference represents the value of the NAME column in the new row being inserted into the DIRECTOR table. The UPPER() function is applied to this value, which converts all alphabetic characters in the NAME column to their uppercase equivalents. The modified uppercase value is then assigned back to :NEW.NAME, ensuring that the NAME column in the inserted row always contains an uppercase version of the original input. The trigger operates on each row being inserted into the DIRECTOR table, as indicated by the FOR EACH ROW clause, and does not include any conditional logic or additional operations beyond the uppercase conversion.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_director_name_uppercase\nBEFORE INSERT ON DIRECTOR\nFOR EACH ROW\nBEGIN\n  :NEW.NAME := UPPER(:NEW.NAME);\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "DIRECTOR",
      "PRODUCER",
      "WRITER",
      "COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', 'john doe', 'American', 'New York', 1970)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', 'jane smith', 'British', 'London', 1985)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (3, 'Male', 'peter jones', 'Australian', 'Sydney', 1962)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (4, 'Female', 'maria garcia', 'Spanish', 'Madrid', 1978)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (5, 'Male', 'li wei', 'Chinese', 'Beijing', 1990)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger on the DIRECTOR table. Convert the new NAME value to uppercase before insertion.",
    "natural_language": "Set up a trigger on the DIRECTOR table that runs before any new row is added. It should do something to make the NAME data look more standardized, maybe by adjusting the letter case in a certain way before it gets saved.",
    "id": 339
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is executed before an INSERT operation on the PRODUCER table and modifies the value of the BIRTH_CITY column in the row being inserted. The trigger uses the pseudo-record :NEW, which represents the new row being inserted into the table, and specifically accesses the BIRTH_CITY column of this record. The trigger applies the TRIM function to the value of :NEW.BIRTH_CITY, which removes any leading and trailing whitespace characters from the string. The modified value is then assigned back to the :NEW.BIRTH_CITY column, ensuring that the inserted value in the BIRTH_CITY column does not contain unnecessary whitespace at the beginning or end of the string. The trigger operates on each row being inserted into the PRODUCER table, as indicated by the FOR EACH ROW clause, and does not perform any conditional checks or additional operations beyond trimming the whitespace from the BIRTH_CITY column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_producer_birth_city_trim\nBEFORE INSERT ON PRODUCER\nFOR EACH ROW\nBEGIN\n  :NEW.BIRTH_CITY := TRIM(:NEW.BIRTH_CITY);\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "DIRECTOR",
      "PRODUCER",
      "WRITER",
      "COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', 'John Doe', 'American', ' New York ', 1970)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', 'Jane Smith', 'British', ' London ', 1985)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (3, 'Male', 'Peter Jones', 'Australian', ' Sydney ', 1960)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (4, 'Female', 'Mary Brown', 'Canadian', ' Toronto ', 1990)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (5, 'Male', 'David Green', 'German', ' Berlin ', 1975)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger on the PRODUCER table. Trim leading and trailing whitespace from the new BIRTH_CITY value before insertion.",
    "natural_language": "Create trigger to trim BIRTH_CITY whitespace before inserting into PRODUCER.",
    "id": 340
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that executes after an update operation on the `CMI_CROSS_REF_ID` column of the `COUNCIL_TAX` table for each row affected. The trigger begins by declaring a local variable `v_power_val` of type `NUMBER`, which will be used to store the square of a specific `MASTER_CUSTOMER_ID` value. When the trigger is fired, it first retrieves the `MASTER_CUSTOMER_ID` value from the `CMI_CROSS_REFERENCES` table where the `CMI_CROSS_REF_ID` matches the new value of the `CMI_CROSS_REF_ID` column in the updated row of the `COUNCIL_TAX` table. This `MASTER_CUSTOMER_ID` value is then squared using the `POWER` function, and the result is stored in the `v_power_val` variable. Next, the trigger updates the `CUSTOMER_MASTER_INDEX` table by setting the `CMI_DETAILS` column to a string that begins with the text 'Updated: ' followed by the string representation of the squared value stored in `v_power_val`. This update is applied to the row in the `CUSTOMER_MASTER_INDEX` table where the `MASTER_CUSTOMER_ID` matches the same `MASTER_CUSTOMER_ID` retrieved earlier from the `CMI_CROSS_REFERENCES` table based on the new `CMI_CROSS_REF_ID` value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_council_tax_cmi_update\nAFTER UPDATE OF CMI_CROSS_REF_ID ON COUNCIL_TAX\nFOR EACH ROW\nDECLARE\n  v_power_val NUMBER;\nBEGIN\n  SELECT POWER(MASTER_CUSTOMER_ID, 2) INTO v_power_val\n  FROM CMI_CROSS_REFERENCES\n  WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\n  UPDATE CUSTOMER_MASTER_INDEX\n  SET CMI_DETAILS = 'Updated: ' || TO_CHAR(v_power_val)\n  WHERE MASTER_CUSTOMER_ID = (SELECT MASTER_CUSTOMER_ID FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID);\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 101 WHERE COUNCIL_TAX_ID = 1",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 103 WHERE COUNCIL_TAX_ID = 2",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 104 WHERE COUNCIL_TAX_ID = 3",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 101 WHERE COUNCIL_TAX_ID = 2",
      "UPDATE COUNCIL_TAX SET CMI_CROSS_REF_ID = 103 WHERE COUNCIL_TAX_ID = 1"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger on the COUNCIL_TAX table for the CMI_CROSS_REF_ID column. For each updated row, retrieve the MASTER_CUSTOMER_ID from CMI_CROSS_REFERENCES using the new CMI_CROSS_REF_ID. Calculate the square of that MASTER_CUSTOMER_ID using the POWER function. Then, update the CUSTOMER_MASTER_INDEX table, setting the CMI_DETAILS column to 'Updated: ' concatenated with the squared value, where the MASTER_CUSTOMER_ID matches the retrieved ID.",
    "natural_language": "Please implement an AFTER UPDATE row-level trigger on the COUNCIL_TAX table, specifically for modifications to the CMI_CROSS_REF_ID column. For each row that is updated, the procedure should first obtain the corresponding MASTER_CUSTOMER_ID from the CMI_CROSS_REFERENCES table, utilizing the new CMI_CROSS_REF_ID value. Subsequently, compute the square of the retrieved MASTER_CUSTOMER_ID by applying the POWER function. Finally, execute an update on the CUSTOMER_MASTER_INDEX table, setting the CMI_DETAILS column to a string concatenation of 'Updated: ' and the calculated squared value, but only for the record whose MASTER_CUSTOMER_ID matches the identifier retrieved in the previous step.",
    "id": 341
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named `trg_rent_arrears_cleanup` that is executed automatically before a row is deleted from the `CMI_CROSS_REFERENCES` table. This trigger operates on a row-by-row basis, as indicated by the `FOR EACH ROW` clause. The trigger performs the following actions: it deletes rows from three separate tables`RENT_ARREARS`, `BENEFITS_OVERPAYMENTS`, and `COUNCIL_TAX`where the value in the `CMI_CROSS_REF_ID` column of each table matches the value of the `CMI_CROSS_REF_ID` column in the row being deleted from the `CMI_CROSS_REFERENCES` table. The `:OLD` pseudorecord is used to reference the value of the `CMI_CROSS_REF_ID` column in the row that is about to be deleted from the `CMI_CROSS_REFERENCES` table. Specifically, the first operation deletes rows from the `RENT_ARREARS` table where the `CMI_CROSS_REF_ID` column equals `:OLD.CMI_CROSS_REF_ID`. The second operation deletes rows from the `BENEFITS_OVERPAYMENTS` table where the `CMI_CROSS_REF_ID` column equals `:OLD.CMI_CROSS_REF_ID`. The third operation deletes rows from the `COUNCIL_TAX` table where the `CMI_CROSS_REF_ID` column equals `:OLD.CMI_CROSS_REF_ID`. This ensures that any related data in these three tables is removed when a corresponding row is deleted from the `CMI_CROSS_REFERENCES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_rent_arrears_cleanup\nBEFORE DELETE ON CMI_CROSS_REFERENCES\nFOR EACH ROW\nBEGIN\n  DELETE FROM RENT_ARREARS\n  WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  DELETE FROM BENEFITS_OVERPAYMENTS\n  WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n  DELETE FROM COUNCIL_TAX\n  WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 2",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 4",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 8",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 65",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 41"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_rent_arrears_cleanup on the CMI_CROSS_REFERENCES table. For each row being deleted, delete all related rows from the RENT_ARREARS, BENEFITS_OVERPAYMENTS, and COUNCIL_TAX tables where their CMI_CROSS_REF_ID column matches the :OLD.CMI_CROSS_REF_ID value from the row being deleted.",
    "natural_language": "Before deleting a row from CMI_CROSS_REFERENCES, delete related rows from RENT_ARREARS, BENEFITS_OVERPAYMENTS, and COUNCIL_TAX with matching CMI_CROSS_REF_ID.",
    "id": 342
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_cmi_ref_insert` that automatically executes `AFTER INSERT` operations on the `CMI_CROSS_REFERENCES` table, specifically `FOR EACH ROW` that is inserted. This trigger declares two local variables: `v_details` of type `VARCHAR2` with a maximum length of 255 characters, and `v_council_tax_id` of type `NUMBER`. The trigger's execution begins by attempting to `SELECT` the value from the `CMI_DETAILS` column into the `v_details` variable from the `CUSTOMER_MASTER_INDEX` table. This selection is conditioned by matching the `MASTER_CUSTOMER_ID` column in `CUSTOMER_MASTER_INDEX` with the `MASTER_CUSTOMER_ID` value of the newly inserted row in `CMI_CROSS_REFERENCES`, which is referenced as `:NEW.MASTER_CUSTOMER_ID`. If this `SELECT` statement does not find any matching row, a `NO_DATA_FOUND` exception is caught, and the trigger immediately `RETURN`s, ceasing further execution for that specific row insertion. If a matching row is found and `v_details` is populated, the trigger then proceeds to a conditional block. This block checks if the `LENGTH` of the `v_details` variable is `GREATER THAN 10`. If this condition is true, the trigger performs another `SELECT` statement. This `SELECT` statement calculates the maximum value of the `COUNCIL_TAX_ID` column from the `COUNCIL_TAX` table, uses the `NVL` function to treat a `NULL` maximum value as `0`, and then adds `1` to this result. The calculated value is then stored in the `v_council_tax_id` variable. Following this, an `INSERT` operation is performed into the `COUNCIL_TAX` table. The `INSERT` statement populates the `COUNCIL_TAX_ID` column with the value from `v_council_tax_id` and the `CMI_CROSS_REF_ID` column with the `CMI_CROSS_REF_ID` value of the newly inserted row in `CMI_CROSS_REFERENCES`, referenced as `:NEW.CMI_CROSS_REF_ID`. If the initial `LENGTH` condition for `v_details` is false (i.e., `LENGTH(v_details)` is not greater than 10), the `INSERT` operation into `COUNCIL_TAX` is skipped, and the trigger finishes execution for the current row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_cmi_ref_insert\nAFTER INSERT ON CMI_CROSS_REFERENCES\nFOR EACH ROW\nDECLARE\n  v_details VARCHAR2(255);\n  v_council_tax_id NUMBER;\nBEGIN\n  BEGIN\n    SELECT CMI_DETAILS INTO v_details\n    FROM CUSTOMER_MASTER_INDEX\n    WHERE MASTER_CUSTOMER_ID = :NEW.MASTER_CUSTOMER_ID;\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n      RETURN;\n  END;\n  \n  IF LENGTH(v_details) > 10 THEN\n    SELECT NVL(MAX(COUNCIL_TAX_ID), 0) + 1 INTO v_council_tax_id\n    FROM COUNCIL_TAX;\n    \n    INSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID)\n    VALUES (v_council_tax_id, :NEW.CMI_CROSS_REF_ID);\n  END IF;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) \nVALUES (9, 1, 'Housing')",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) \nVALUES (10, 2, 'Utilities')",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) \nVALUES (11, 3, 'Parking')",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) \nVALUES (12, 4, 'Rent')",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) \nVALUES (13, 5, 'Tax')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_cmi_ref_insert on the CMI_CROSS_REFERENCES table. For each new row, select the CMI_DETAILS from CUSTOMER_MASTER_INDEX using the new MASTER_CUSTOMER_ID. If no data is found, exit. If the length of the retrieved CMI_DETAILS is greater than 10, then calculate the next COUNCIL_TAX_ID (max existing ID + 1, defaulting to 0) and insert a new row into the COUNCIL_TAX table with this new ID and the new CMI_CROSS_REF_ID.",
    "natural_language": "Create trigger trg_cmi_ref_insert on CMI_CROSS_REFERENCES after insert. For each row, get CMI_DETAILS from CUSTOMER_MASTER_INDEX using new MASTER_CUSTOMER_ID. If found and length > 10, insert into COUNCIL_TAX with next COUNCIL_TAX_ID and the new CMI_CROSS_REF_ID.",
    "id": 343
  }
]