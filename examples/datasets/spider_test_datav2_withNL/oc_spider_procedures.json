[
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `DeleteArtistWorks` that accepts two parameters: an input parameter `p_artist_id` of data type `NUMBER`, which represents the unique identifier of an artist whose works are to be deleted, and an output parameter `p_deleted_count` of data type `NUMBER`, which will store the total number of records deleted by the procedure. The procedure begins by executing a `DELETE` statement on the `PAINTINGS` table. This `DELETE` operation removes all rows from the `PAINTINGS` table where the value in the `PAINTERID` column matches the value provided in the `p_artist_id` input parameter. Immediately following this deletion, the `p_deleted_count` output parameter is assigned the value of `SQL%ROWCOUNT`, which is a built-in SQL attribute that returns the number of rows affected by the most recently executed SQL statement (in this case, the `DELETE` from `PAINTINGS`). Subsequently, the procedure executes another `DELETE` statement, this time targeting the `SCULPTURES` table. This `DELETE` operation removes all rows from the `SCULPTURES` table where the value in the `SCULPTORID` column matches the value provided in the `p_artist_id` input parameter. After this second deletion, the `p_deleted_count` output parameter is updated by adding the value of `SQL%ROWCOUNT` (representing the number of rows deleted from `SCULPTURES`) to its current value, effectively accumulating the total count of deleted records from both tables.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteArtistWorks(\n    p_artist_id IN NUMBER,\n    p_deleted_count OUT NUMBER\n) AS\nBEGIN\n    DELETE FROM PAINTINGS WHERE PAINTERID = p_artist_id;\n    p_deleted_count := SQL%ROWCOUNT;\n    DELETE FROM SCULPTURES WHERE SCULPTORID = p_artist_id;\n    p_deleted_count := p_deleted_count + SQL%ROWCOUNT;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 111, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 222, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 333, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 555, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 999, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteArtistWorks that accepts an artist ID as input and returns the total number of deleted records. It deletes all rows from the PAINTINGS table where PAINTERID matches the input, and all rows from the SCULPTURES table where SCULPTORID matches the input, accumulating the count of deleted rows from both operations.",
    "natural_language": "What is the total number of records deleted by the stored procedure DeleteArtistWorks when it is given an artist ID, after it removes all matching entries from both the PAINTINGS and SCULPTURES tables?",
    "id": 1
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named delete_old_club_leaders that performs a single delete operation on the CLUB_LEADER table, specifically removing all rows where the value in the YEAR_JOIN column is less than the string literal '2016'.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_club_leaders\nIS\nBEGIN\n   DELETE FROM CLUB_LEADER\n   WHERE YEAR_JOIN < '2016';\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "BEGIN\n  delete_old_club_leaders;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named delete_old_club_leaders that deletes all rows from the CLUB_LEADER table where the YEAR_JOIN column value is less than '2016'.",
    "natural_language": "Develop a stored procedure called delete_old_club_leaders, which is designed to meticulously remove every single record from the CLUB_LEADER table, specifically targeting those entries where the value in the YEAR_JOIN column is definitively earlier than the year '2016'.",
    "id": 2
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_member_ages that performs a single update operation on the MEMBER table, specifically incrementing the value in the AGE column by one for every row in the table where the AGE column currently contains a non-null value, leaving rows with a null AGE value unchanged.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_member_ages\nIS\nBEGIN\n   UPDATE MEMBER\n   SET AGE = AGE + 1\n   WHERE AGE IS NOT NULL;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "BEGIN\n  update_member_ages;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named update_member_ages that updates the MEMBER table by incrementing the AGE column by one for every row where AGE is not null.",
    "natural_language": "How can I create a stored procedure called update_member_ages to increment the AGE by one for all records in the MEMBER table where AGE is not null?",
    "id": 3
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `assign_teacher_to_course` that accepts three input parameters: `p_course_id` of type `NUMBER`, representing the unique identifier of a course; `p_teacher_id` of type `NUMBER`, representing the unique identifier of a teacher; and `p_grade` of type `NUMBER`, representing the grade to be assigned. The procedure first declares two local variables: `v_course_exists` of type `NUMBER` and `v_teacher_exists` of type `NUMBER`. It then executes a `SELECT COUNT(*)` statement to determine if a course with the `COURSE_ID` matching the `p_course_id` input parameter exists in the `COURSE` table, storing the count in `v_course_exists`. Subsequently, it executes another `SELECT COUNT(*)` statement to determine if a teacher with the `TEACHER_ID` matching the `p_teacher_id` input parameter exists in the `TEACHER` table, storing the count in `v_teacher_exists`. Following these checks, the procedure evaluates a conditional `IF` statement. If both `v_course_exists` is greater than 0 (indicating the course exists) AND `v_teacher_exists` is greater than 0 (indicating the teacher exists), the procedure proceeds to execute a `MERGE` statement. This `MERGE` statement targets the `COURSE_ARRANGE` table, aliased as `ca`. The `USING` clause constructs a derived table from `DUAL`, providing the `p_course_id` as `course_id`, `p_teacher_id` as `teacher_id`, and `p_grade` as `grade`, aliased as `src`. The `ON` clause specifies the join condition for the `MERGE` operation as `ca.COURSE_ID = src.course_id AND ca.TEACHER_ID = src.teacher_id`. If a match is found based on this condition (`WHEN MATCHED THEN`), the `GRADE` column in the `COURSE_ARRANGE` table (`ca.GRADE`) is updated to the value of `src.grade`. If no match is found (`WHEN NOT MATCHED THEN`), a new row is inserted into the `COURSE_ARRANGE` table, populating the `COURSE_ID`, `TEACHER_ID`, and `GRADE` columns with the values from `src.course_id`, `src.teacher_id`, and `src.grade`, respectively. The procedure concludes after this conditional `MERGE` operation.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_teacher_to_course(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER\n) IS\n    v_course_exists NUMBER;\n    v_teacher_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_course_exists FROM COURSE WHERE COURSE_ID = p_course_id;\n    SELECT COUNT(*) INTO v_teacher_exists FROM TEACHER WHERE TEACHER_ID = p_teacher_id;\n    \n    IF v_course_exists > 0 AND v_teacher_exists > 0 THEN\n        MERGE INTO COURSE_ARRANGE ca\n        USING (SELECT p_course_id AS course_id, p_teacher_id AS teacher_id, p_grade AS grade FROM DUAL) src\n        ON (ca.COURSE_ID = src.course_id AND ca.TEACHER_ID = src.teacher_id)\n        WHEN MATCHED THEN\n            UPDATE SET ca.GRADE = src.grade\n        WHEN NOT MATCHED THEN\n            INSERT (ca.COURSE_ID, ca.TEACHER_ID, ca.GRADE)\n            VALUES (src.course_id, src.teacher_id, src.grade);\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  assign_teacher_to_course(1, 1, 3);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(2, 2, 5);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(3, 3, 1);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(1, 2, 4);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(2, 3, 2);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named assign_teacher_to_course that accepts a course ID, teacher ID, and grade. It first verifies the existence of the course and teacher in their respective tables. If both exist, it uses a MERGE statement on the COURSE_ARRANGE table to update the grade if a matching record exists, or insert a new record if no match is found.",
    "natural_language": "Compose a stored procedure designated as `assign_teacher_to_course`. This procedure shall accept three parameters: a course identifier, a teacher identifier, and a grade. Its initial operation is to validate the existence of the specified course and teacher within their respective database tables. Provided both entities are confirmed to exist, the procedure will subsequently execute a MERGE operation on the COURSE_ARRANGE table. This MERGE statement will update the grade for any pre-existing record that matches the provided identifiers. In the absence of such a matching record, the statement will insert a new entry.",
    "id": 4
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_teacher_info` that accepts three input parameters: `p_teacher_id` of type `NUMBER`, `p_new_name` of type `VARCHAR2`, and `p_new_hometown` of type `VARCHAR2`. The purpose of this procedure is to update information for a specific teacher identified by `p_teacher_id` in the `TEACHER` table.\n\nThe procedure begins by declaring two local variables: `v_current_age` of type `VARCHAR2(255)` and `v_formatted_name` of type `VARCHAR2(255)`.\n\nFirst, it executes a `SELECT` statement to retrieve the `AGE` column value from the `TEACHER` table for the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`. The retrieved `AGE` value is then stored into the local variable `v_current_age`.\n\nNext, it processes the `p_new_name` input parameter to create a formatted name. It constructs `v_formatted_name` by taking the first character of `p_new_name` using `SUBSTR(p_new_name, 1, 1)`, converting it to uppercase using the `UPPER()` function, and concatenating it with the rest of `p_new_name` starting from the second character using `SUBSTR(p_new_name, 2)`, which is converted to lowercase using the `LOWER()` function. This effectively capitalizes the first letter of the new name and makes the rest lowercase.\n\nSubsequently, an `UPDATE` statement is executed on the `TEACHER` table. This statement sets the `NAME` column to the value stored in `v_formatted_name` and the `HOMETOWN` column to the value of the input parameter `p_new_hometown`. This update is applied only to the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`.\n\nFollowing this, a conditional block is introduced using an `IF` statement. The condition checks if the value stored in `v_current_age`, after being explicitly cast to a `NUMBER` using `CAST(v_current_age AS NUMBER)`, is less than `65`.\n\nIf this condition evaluates to `TRUE`, another `UPDATE` statement is executed on the `TEACHER` table. This update sets the `AGE` column to a new value. The new `AGE` value is calculated by first casting `v_current_age` to a `NUMBER` using `CAST(v_current_age AS NUMBER)`, adding `1` to it, and then converting the result back to a `VARCHAR2` using the `TO_CHAR()` function. This update is also applied only to the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`.\n\nThe procedure then concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_teacher_info(\n    p_teacher_id IN NUMBER,\n    p_new_name IN VARCHAR2,\n    p_new_hometown IN VARCHAR2\n) IS\n    v_current_age VARCHAR2(255);\n    v_formatted_name VARCHAR2(255);\nBEGIN\n    SELECT AGE INTO v_current_age FROM TEACHER WHERE TEACHER_ID = p_teacher_id;\n    v_formatted_name := UPPER(SUBSTR(p_new_name, 1, 1)) || LOWER(SUBSTR(p_new_name, 2));\n    \n    UPDATE TEACHER \n    SET NAME = v_formatted_name, HOMETOWN = p_new_hometown\n    WHERE TEACHER_ID = p_teacher_id;\n    \n    IF CAST(v_current_age AS NUMBER) < 65 THEN\n        UPDATE TEACHER \n        SET AGE = TO_CHAR(CAST(v_current_age AS NUMBER) + 1)\n        WHERE TEACHER_ID = p_teacher_id;\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  update_teacher_info(1, 'Joseph Huts', 'Blackrod Urban District');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(2, 'Gustaaf Deloor', 'Manchester');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(3, 'Vicente Carretero', 'Farnworth Municipal Borough');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(1, 'John Smith', 'London');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(2, 'Alice Johnson', 'Bolton County Borough');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_teacher_info that accepts a teacher ID, a new name, and a new hometown. It retrieves the teacher's current age. It formats the new name to have the first letter uppercase and the rest lowercase. It updates the teacher's NAME and HOMETOWN. If the current age (cast to a number) is less than 65, it increments the age by one and updates the AGE column.",
    "natural_language": "Create procedure update_teacher_info to update a teacher's name and hometown using their ID. Format the new name properly. Get the teacher's current age. If under 65, increase age by one and update it.",
    "id": 5
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes two input parameters, p_course_id and p_teacher_id, both of type NUMBER, and performs the following operations: First, it declares a local variable v_arrangement_exists of type NUMBER to store the count of records. Then, it executes a SELECT statement to count the number of rows in the COURSE_ARRANGE table where the COURSE_ID column matches the value of p_course_id and the TEACHER_ID column matches the value of p_teacher_id, storing the result in v_arrangement_exists. Next, it evaluates a conditional statement to check if v_arrangement_exists is greater than zero, indicating that there is at least one matching record. If this condition is true, it executes a DELETE statement to remove all rows from the COURSE_ARRANGE table where the COURSE_ID column equals p_course_id and the TEACHER_ID column equals p_teacher_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_course_arrangement(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER\n) IS\n    v_arrangement_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_arrangement_exists FROM COURSE_ARRANGE WHERE COURSE_ID = p_course_id AND TEACHER_ID = p_teacher_id;\n    \n    IF v_arrangement_exists > 0 THEN\n        DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = p_course_id AND TEACHER_ID = p_teacher_id;\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  delete_course_arrangement(p_course_id => 2, p_teacher_id => 3);\nEND;",
      "BEGIN\n  delete_course_arrangement(p_course_id => 3, p_teacher_id => 5);\nEND;",
      "BEGIN\n  delete_course_arrangement(p_course_id => 2, p_teacher_id => 2);\nEND;",
      "BEGIN\n  delete_course_arrangement(p_course_id => 1, p_teacher_id => 1);\nEND;",
      "BEGIN\n  delete_course_arrangement(p_course_id => 99, p_teacher_id => 99);\nEND;"
    ],
    "summary": "Create a PL/SQL procedure that deletes records from the COURSE_ARRANGE table for a given course and teacher, but only if such an arrangement already exists.",
    "natural_language": "How can I create a PL/SQL procedure to delete records from the COURSE_ARRANGE table for a specific course and teacher, but only if that arrangement already exists?",
    "id": 6
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that updates the CUSTOMERS table by setting the PAYMENT_METHOD_CODE column to the value of the parameter p_payment_method for the row where the CUSTOMER_ID column matches the value of the parameter p_customer_id. The procedure is named update_customer_payment and takes two parameters: p_customer_id, which is of type NUMBER and represents the unique identifier of a customer, and p_payment_method, which is of type VARCHAR2 and specifies the new payment method code to be assigned to the customer. The procedure performs a single UPDATE operation on the CUSTOMERS table, modifying the PAYMENT_METHOD_CODE column based on the specified CUSTOMER_ID condition.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_customer_payment(p_customer_id NUMBER, p_payment_method VARCHAR2) IS\nBEGIN\n    UPDATE CUSTOMERS SET PAYMENT_METHOD_CODE = p_payment_method WHERE CUSTOMER_ID = p_customer_id;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  update_customer_payment(p_customer_id => 1, p_payment_method => 'Credit Card');\nEND;",
      "BEGIN\n  update_customer_payment(p_customer_id => 4, p_payment_method => 'Debit Card');\nEND;",
      "BEGIN\n  update_customer_payment(p_customer_id => 5, p_payment_method => 'PayPal');\nEND;",
      "BEGIN\n  update_customer_payment(p_customer_id => 1, p_payment_method => 'Bank Transfer');\nEND;",
      "BEGIN\n  update_customer_payment(p_customer_id => 4, p_payment_method => 'Credit Card');\nEND;"
    ],
    "summary": "Create a PL/SQL procedure named update_customer_payment to update a customer's payment method in the CUSTOMERS table based on their customer ID.",
    "natural_language": "Hey, can you whip up a PL/SQL procedure called update_customer_payment? We need it to change how a customer pays by updating their payment method in the CUSTOMERS table. Just find 'em using their customer ID.",
    "id": 7
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DELETE_OLD_ORDERS that accepts three parameters: an input parameter P_CUSTOMER_ID of type NUMBER to identify a specific customer, an input parameter P_DAYS_OLD of type NUMBER to specify an age threshold in days, and an output parameter P_DELETED_COUNT of type NUMBER to return the number of rows affected. The procedure performs a DELETE operation on the CUSTOMER_ORDERS table, targeting rows where the CUSTOMER_ID column matches the provided P_CUSTOMER_ID parameter and where the ORDER_DATE column, after being explicitly converted from a string to a DATE type using the TO_DATE function with the exact format model 'YYYY-MM-DD HH24:MI:SS', represents a date and time earlier than the current system date and time (SYSDATE) minus the number of days specified by P_DAYS_OLD. Following the deletion, the procedure assigns the number of rows deleted, obtained from the SQL%ROWCOUNT cursor attribute, to the output parameter P_DELETED_COUNT.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_orders(p_customer_id NUMBER, p_days_old NUMBER, p_deleted_count OUT NUMBER) IS\nBEGIN\n    DELETE FROM CUSTOMER_ORDERS \n    WHERE CUSTOMER_ID = p_customer_id \n    AND TO_DATE(ORDER_DATE, 'YYYY-MM-DD HH24:MI:SS') < SYSDATE - p_days_old;\n    \n    p_deleted_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(1, 30, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(4, 60, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(5, 90, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(1, 120, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(4, 180, v_deleted_count);\n  commit;\nEND;"
    ],
    "summary": "Create a PL/SQL procedure named DELETE_OLD_ORDERS that deletes a customer's orders older than a specified number of days and returns the count of deleted rows.",
    "natural_language": "Make a DELETE_OLD_ORDERS procedure to remove a customer's old orders and return the deletion count.",
    "id": 8
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `transfer_member_college` that accepts three parameters: `p_member_id`, which is an input parameter of type `NUMBER` representing the unique identifier of a member; `p_new_college_id`, which is an input parameter of type `NUMBER` representing the unique identifier of the college to which the member will be transferred; and `p_old_college_id`, which is an output parameter of type `NUMBER` that will store the unique identifier of the college the member was previously associated with. The procedure first performs a `SELECT` operation to retrieve the current `COLLEGE_ID` from the `MEMBER` table. This `SELECT` statement uses a `WHERE` clause to filter records where the `MEMBER_ID` column matches the value provided in the `p_member_id` input parameter. The retrieved `COLLEGE_ID` value is then assigned to the `p_old_college_id` output parameter. Following this, the procedure executes an `UPDATE` operation on the `MEMBER` table. This `UPDATE` statement sets the `COLLEGE_ID` column to the value provided in the `p_new_college_id` input parameter. The `UPDATE` operation is restricted by a `WHERE` clause, ensuring that only the record where the `MEMBER_ID` column matches the value of the `p_member_id` input parameter is modified.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_member_college(p_member_id NUMBER, p_new_college_id NUMBER, p_old_college_id OUT NUMBER) IS\nBEGIN\n  SELECT COLLEGE_ID INTO p_old_college_id FROM MEMBER WHERE MEMBER_ID = p_member_id;\n  UPDATE MEMBER SET COLLEGE_ID = p_new_college_id WHERE MEMBER_ID = p_member_id;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_college_id NUMBER;\nBEGIN\n  transfer_member_college(1, 2, v_old_college_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_college_id NUMBER;\nBEGIN\n  transfer_member_college(2, 3, v_old_college_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_college_id NUMBER;\nBEGIN\n  transfer_member_college(3, 1, v_old_college_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_college_id NUMBER;\nBEGIN\n  transfer_member_college(1, 3, v_old_college_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_college_id NUMBER;\nBEGIN\n  transfer_member_college(2, 1, v_old_college_id);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a PL/SQL procedure named transfer_member_college to transfer a member to a new college, returning their previous college ID via an OUT parameter.",
    "natural_language": "Develop a comprehensive PL/SQL procedure, which should be designated as transfer_member_college, to meticulously handle the process of transferring a specific member to an entirely new college; this procedure must also thoughtfully return the member's former college identifier through a dedicated OUT parameter.",
    "id": 9
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewLocation that accepts one input parameter, p_country_id of type VARCHAR2, which is used to specify the COUNTRY_ID for a new location record. The procedure begins by declaring a local variable v_new_location_id of type NUMBER. It then executes a SELECT statement on the LOCATIONS table to calculate a new unique identifier by retrieving the maximum existing value from the LOCATION_ID column and incrementing it by one, storing the result into the variable v_new_location_id. Following this, the procedure performs an INSERT operation into the LOCATIONS table, specifying the columns LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, and COUNTRY_ID. The inserted values are: the generated v_new_location_id for LOCATION_ID, the literal string '123 New Street' for STREET_ADDRESS, the literal string '12345' for POSTAL_CODE, the literal string 'New City' for CITY, the literal string 'New State' for STATE_PROVINCE, and the input parameter p_country_id for the COUNTRY_ID column.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewLocation(p_country_id IN VARCHAR2) AS\n  v_new_location_id NUMBER;\nBEGIN\n  -- Generate a new unique LOCATION_ID\n  SELECT MAX(LOCATION_ID) + 1 INTO v_new_location_id FROM LOCATIONS;\n\n  INSERT INTO LOCATIONS (LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID)\n  VALUES (v_new_location_id, '123 New Street', '12345', 'New City', 'New State', p_country_id);\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "LOCATIONS",
      "COUNTRIES"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewLocation('US');\nEND;",
      "BEGIN\n  InsertNewLocation('CA');\nEND;",
      "BEGIN\n  InsertNewLocation('DE');\nEND;",
      "BEGIN\n  InsertNewLocation('FR');\nEND;",
      "BEGIN\n  InsertNewLocation('GB');\nEND;"
    ],
    "summary": "Create a PL/SQL procedure named InsertNewLocation to insert a new location record with a generated ID and default address values, using a provided country ID.",
    "natural_language": "Make procedure InsertNewLocation to add a location. Generate its ID, use default address values, and take a country ID.",
    "id": 10
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_actor_cast` that accepts two input parameters: `para_aid` of data type `NUMBER` and `para_role` of data type `NUMBER`. The procedure's primary function is to manage records within the `CAST` table based on the value of the `para_role` parameter. It first evaluates a conditional statement: if the remainder of `para_role` divided by 2 is equal to 0 (i.e., `para_role` is an even number), the procedure executes an `INSERT` operation into the `CAST` table. This `INSERT` statement populates the `ID` column with the value of `para_aid`, the `MSID` column with `NULL`, the `AID` column with the value of `para_aid`, and the `ROLE` column with the value of `para_role`. If the first condition is false, the procedure then evaluates a second conditional statement: if the remainder of `para_role` divided by 3 is equal to 0 (i.e., `para_role` is a multiple of 3), the procedure performs a `DELETE` operation from the `CAST` table. This `DELETE` operation removes all rows where the `AID` column matches the value of `para_aid`. If both the first and second conditions are false, the procedure executes a default `INSERT` operation into the `CAST` table. This `INSERT` statement populates the `ID` column with the value of `para_aid`, the `MSID` column with `NULL`, the `AID` column with the value of `para_aid`, and the `ROLE` column with the value of `para_role` incremented by 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_actor_cast(para_aid NUMBER, para_role NUMBER) IS\nBEGIN\n  IF MOD(para_role, 2) = 0 THEN\n    INSERT INTO CAST (ID, MSID, AID, ROLE) VALUES (para_aid, NULL, para_aid, para_role);\n  ELSIF MOD(para_role, 3) = 0 THEN\n    DELETE FROM CAST WHERE AID = para_aid;\n  ELSE\n    INSERT INTO CAST (ID, MSID, AID, ROLE) VALUES (para_aid, NULL, para_aid, para_role + 1);\n  END IF;\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "MOVIE",
      "TV_SERIES",
      "DIRECTOR",
      "WRITER"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_actor_cast(101, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(102, 6);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(103, 9);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(104, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(105, 7);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_manage_actor_cast with parameters para_aid NUMBER and para_role NUMBER. If para_role is even, insert a record into the CAST table with ID=para_aid, MSID=NULL, AID=para_aid, ROLE=para_role. Else if para_role is divisible by 3, delete from CAST where AID=para_aid. Otherwise, insert a record with ID=para_aid, MSID=NULL, AID=para_aid, ROLE=para_role+1.",
    "natural_language": "Please construct a stored procedure designated as sp_manage_actor_cast, which accepts two numerical parameters: para_aid and para_role. The procedure's logic is as follows: Should the value of para_role be an even number, insert a new entry into the CAST table, specifying the ID as para_aid, MSID as NULL, AID as para_aid, and ROLE as para_role. Alternatively, if para_role is divisible by three, execute a deletion from the CAST table for all records where the AID matches the provided para_aid. In all other cases, insert a record with ID set to para_aid, MSID to NULL, AID to para_aid, and ROLE to the value of para_role incremented by one.",
    "id": 11
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_director_birth_year that accepts two input parameters: para_did of type NUMBER, which represents a director's identifier, and para_year of type NUMBER, which represents a birth year value. The procedure performs conditional logic on the DIRECTOR table based on the value of para_year. First, it checks if para_year is divisible by 4 using the MOD function; if MOD(para_year, 4) equals 0, it executes an UPDATE statement on the DIRECTOR table, setting the BIRTH_YEAR column to the value of para_year for the specific row where the DID column matches the input parameter para_did. If the first condition is false, it checks if para_year is divisible by 5 using the MOD function; if MOD(para_year, 5) equals 0, it executes a DELETE statement on the DIRECTOR table, removing the row where the DID column matches para_did. If neither condition is true, it executes an INSERT statement into the DIRECTOR table, specifying values for the DID, NAME, and BIRTH_YEAR columns: it inserts the value of para_did into DID, the literal string 'Unknown' into NAME, and the value of para_year into BIRTH_YEAR.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_director_birth_year(para_did NUMBER, para_year NUMBER) IS\nBEGIN\n  IF MOD(para_year, 4) = 0 THEN\n    UPDATE DIRECTOR SET BIRTH_YEAR = para_year WHERE DID = para_did;\n  ELSIF MOD(para_year, 5) = 0 THEN\n    DELETE FROM DIRECTOR WHERE DID = para_did;\n  ELSE\n    INSERT INTO DIRECTOR (DID, NAME, BIRTH_YEAR) VALUES (para_did, 'Unknown', para_year);\n  END IF;\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "MOVIE",
      "TV_SERIES",
      "DIRECTOR",
      "WRITER"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_director_birth_year(1, 2000);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(2, 2005);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(3, 2001);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(4, 2004);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(5, 2003);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_director_birth_year with parameters para_did NUMBER and para_year NUMBER. If para_year is divisible by 4, update DIRECTOR set BIRTH_YEAR=para_year where DID=para_did. Else if para_year is divisible by 5, delete from DIRECTOR where DID=para_did. Otherwise, insert into DIRECTOR (DID, NAME, BIRTH_YEAR) values (para_did, 'Unknown', para_year).",
    "natural_language": "How can I create a stored procedure called sp_update_director_birth_year that takes para_did NUMBER and para_year NUMBER as parameters, so that it updates the DIRECTOR's BIRTH_YEAR to para_year for a given DID if para_year is divisible by 4, deletes the director record if para_year is divisible by 5, or otherwise inserts a new record with the given DID, 'Unknown' for NAME, and the provided para_year?",
    "id": 12
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_movie_budget` that accepts two input parameters: `para_mid` of data type `NUMBER`, intended to represent a unique identifier for a movie, and `para_budget` of data type `VARCHAR2`, intended to represent the budget of a movie. The procedure's execution flow is determined by a conditional logic structure based on the value of `para_mid`. Specifically, it first evaluates if the remainder of `para_mid` divided by 2 is equal to 0, using the `MOD` function. If this condition is true, indicating that `para_mid` is an even number, the procedure performs an `UPDATE` operation on the `MOVIE` table. This update sets the value of the `BUDGET` column to the value provided in the `para_budget` parameter for all rows where the `MID` column matches the value provided in the `para_mid` parameter. If the first condition is false, the procedure then evaluates an `ELSIF` condition, checking if the remainder of `para_mid` divided by 3 is equal to 0, again using the `MOD` function. If this second condition is true, indicating that `para_mid` is a multiple of 3, the procedure executes a `DELETE` operation. This deletion removes all rows from the `MOVIE` table where the `MID` column matches the value provided in the `para_mid` parameter. If both the first and second conditions are false, meaning `para_mid` is neither an even number nor a multiple of 3, the procedure executes an `INSERT` operation. This insertion adds a new row into the `MOVIE` table, populating the `MID` column with the value from `para_mid`, the `TITLE` column with the literal string 'Untitled', the `RELEASE_YEAR` column with the literal numeric value 2023, and the `BUDGET` column with the value from `para_budget`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_movie_budget(para_mid NUMBER, para_budget VARCHAR2) IS\nBEGIN\n  IF MOD(para_mid, 2) = 0 THEN\n    UPDATE MOVIE SET BUDGET = para_budget WHERE MID = para_mid;\n  ELSIF MOD(para_mid, 3) = 0 THEN\n    DELETE FROM MOVIE WHERE MID = para_mid;\n  ELSE\n    INSERT INTO MOVIE (MID, TITLE, RELEASE_YEAR, BUDGET) VALUES (para_mid, 'Untitled', 2023, para_budget);\n  END IF;\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "MOVIE",
      "TV_SERIES",
      "DIRECTOR",
      "WRITER"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_movie_budget(2, '1000000');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_movie_budget(3, '500000');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_movie_budget(5, '750000');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_movie_budget(8, '2000000');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_movie_budget(9, '1500000');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_manage_movie_budget with parameters para_mid NUMBER and para_budget VARCHAR2. If para_mid is even, update MOVIE set BUDGET=para_budget where MID=para_mid. Else if para_mid is divisible by 3, delete from MOVIE where MID=para_mid. Otherwise, insert into MOVIE (MID, TITLE, RELEASE_YEAR, BUDGET) values (para_mid, 'Untitled', 2023, para_budget).",
    "natural_language": "Create a stored procedure, which should be named sp_manage_movie_budget, that accepts two distinct parameters: para_mid, defined as a NUMBER, and para_budget, defined as a VARCHAR2. Within this procedure, implement a detailed logic flow: if the provided para_mid is an even number, then meticulously update the MOVIE table by setting its BUDGET column to the supplied para_budget value specifically for the record where the MID matches para_mid. Alternatively, if the para_mid is not even but is instead perfectly divisible by 3, then carefully execute a deletion from the MOVIE table, removing precisely the row where the MID equals para_mid. In all other remaining scenarios, when para_mid is neither even nor divisible by three, perform a comprehensive insertion into the MOVIE table, populating the columns MID, TITLE, RELEASE_YEAR, and BUDGET with the values para_mid, the default title 'Untitled', the year 2023, and the provided para_budget, respectively.",
    "id": 13
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_tv_series` that accepts two input parameters: `para_sid` of data type `NUMBER` and `para_title` of data type `VARCHAR2`. The purpose of this procedure is to perform conditional data manipulation operations on the `TV_SERIES` table based on the value of `para_sid`. The procedure first evaluates a condition: if the remainder of `para_sid` divided by 2 is equal to 0 (i.e., `para_sid` is an even number), then it executes an `INSERT` operation. This `INSERT` operation adds a new row into the `TV_SERIES` table, populating the `SID` column with the value from `para_sid`, the `TITLE` column with the value from `para_title`, the `RELEASE_YEAR` column with the literal integer value `2023`, the `NUM_OF_SEASONS` column with the literal integer value `1`, the `NUM_OF_EPISODES` column with the literal integer value `10`, and the `BUDGET` column with the literal string value `'1000000'`. If the first condition is not met, the procedure then evaluates a second condition: if the remainder of `para_sid` divided by 3 is equal to 0 (i.e., `para_sid` is a multiple of 3), then it executes a `DELETE` operation. This `DELETE` operation removes all rows from the `TV_SERIES` table where the value in the `SID` column matches the value provided in `para_sid`. If neither of the preceding conditions is met, the procedure executes an `UPDATE` operation. This `UPDATE` operation modifies existing rows in the `TV_SERIES` table by setting the `TITLE` column to the value provided in `para_title`, specifically for those rows where the value in the `SID` column matches the value provided in `para_sid`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_tv_series(para_sid NUMBER, para_title VARCHAR2) IS\nBEGIN\n  IF MOD(para_sid, 2) = 0 THEN\n    INSERT INTO TV_SERIES (SID, TITLE, RELEASE_YEAR, NUM_OF_SEASONS, NUM_OF_EPISODES, BUDGET) VALUES (para_sid, para_title, 2023, 1, 10, '1000000');\n  ELSIF MOD(para_sid, 3) = 0 THEN\n    DELETE FROM TV_SERIES WHERE SID = para_sid;\n  ELSE\n    UPDATE TV_SERIES SET TITLE = para_title WHERE SID = para_sid;\n  END IF;\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "MOVIE",
      "TV_SERIES",
      "DIRECTOR",
      "WRITER"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_tv_series(2, 'New Series Title');\n  commit;\nEND;",
      "BEGIN\n  sp_manage_tv_series(3, 'Another Series Title');\n  commit;\nEND;",
      "BEGIN\n  sp_manage_tv_series(5, 'Updated Series Title');\n  commit;\nEND;",
      "BEGIN\n  sp_manage_tv_series(6, 'Series Title Six');\n  commit;\nEND;",
      "BEGIN\n  sp_manage_tv_series(9, 'Series Title Nine');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_manage_tv_series with parameters para_sid NUMBER and para_title VARCHAR2. If para_sid is even, insert into TV_SERIES (SID, TITLE, RELEASE_YEAR, NUM_OF_SEASONS, NUM_OF_EPISODES, BUDGET) values (para_sid, para_title, 2023, 1, 10, '1000000'). Else if para_sid is divisible by 3, delete from TV_SERIES where SID=para_sid. Otherwise, update TV_SERIES set TITLE=para_title where SID=para_sid.",
    "natural_language": "Construct a stored procedure designated as sp_manage_tv_series, which shall accept the parameters para_sid of type NUMBER and para_title of type VARCHAR2. The procedure's logic is defined as follows: should the value of para_sid be an even number, an insertion into the TV_SERIES table is to be performed, populating the columns SID, TITLE, RELEASE_YEAR, NUM_OF_SEASONS, NUM_OF_EPISODES, and BUDGET with the respective values para_sid, para_title, 2023, 1, 10, and '1000000'. Alternatively, if the value of para_sid is found to be divisible by three, a deletion from the TV_SERIES table is to be executed, specifically targeting the record where the SID column matches para_sid. In all other cases, an update operation on the TV_SERIES table is required, setting the TITLE column to the value of para_title for the record where SID equals para_sid.",
    "id": 14
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `consolidate_payment_records` that accepts four input parameters: `p_customer_id` of type `NUMBER`, `p_from_date` of type `VARCHAR2`, `p_to_date` of type `VARCHAR2`, and `p_min_amount` of type `NUMBER`. The procedure first declares three local variables: `v_total_payments` of type `NUMBER`, `v_payment_count` of type `NUMBER`, and `v_max_payment` of type `NUMBER`. It then executes a `SELECT` statement to retrieve aggregated payment information. This `SELECT` statement calculates the sum of `AMOUNT_PAYMENT` from the `PAYMENTS` table, the count of `PAYMENT_ID` from the `PAYMENTS` table, and the maximum `AMOUNT_PAYMENT` from the `PAYMENTS` table. These aggregated values are stored into the `v_total_payments`, `v_payment_count`, and `v_max_payment` variables, respectively. The `SELECT` statement joins the `PAYMENTS` table (aliased as `p`) with the `SETTLEMENTS` table (aliased as `s`) on `p.SETTLEMENT_ID = s.SETTLEMENT_ID`. It further joins `SETTLEMENTS` with the `CLAIMS` table (aliased as `c`) on `s.CLAIM_ID = c.CLAIM_ID`. Finally, it joins `CLAIMS` with the `CUSTOMER_POLICIES` table (aliased as `cp`) on `c.POLICY_ID = cp.POLICY_ID`. The data is filtered by several conditions in the `WHERE` clause: `cp.CUSTOMER_ID` must be equal to the input parameter `p_customer_id`. The `DATE_PAYMENT_MADE` column from the `PAYMENTS` table, after being converted to a `DATE` type using `TO_DATE` with the format mask 'YYYY-MM-DD', must fall between the `p_from_date` and `p_to_date` input parameters, both of which are also converted to `DATE` types using `TO_DATE` with the format mask 'YYYY-MM-DD'. Additionally, `p.AMOUNT_PAYMENT` must be greater than or equal to the input parameter `p_min_amount`.\n\nFollowing the `SELECT` statement, the procedure enters a conditional block.\nIf `v_total_payments` is greater than `1000000`, an `INSERT` statement is executed into the `PAYMENTS` table. The `PAYMENT_ID` is generated by selecting the maximum `PAYMENT_ID` from `PAYMENTS`, handling `NULL` with `NVL` to default to `0`, and adding `1`. The `SETTLEMENT_ID` is obtained by selecting the minimum `SETTLEMENT_ID` from the `SETTLEMENTS` table. The `PAYMENT_METHOD_CODE` is set to the literal string 'CONSOLIDATED'. The `DATE_PAYMENT_MADE` is set to the input parameter `p_to_date`. The `AMOUNT_PAYMENT` is set to the calculated `v_total_payments`.\nOtherwise, if `v_payment_count` is greater than `10`, an `INSERT` statement is executed into the `PAYMENTS` table. The `PAYMENT_ID` is generated by selecting the maximum `PAYMENT_ID` from `PAYMENTS`, handling `NULL` with `NVL` to default to `0`, and adding `1`. The `SETTLEMENT_ID` is obtained by selecting the maximum `SETTLEMENT_ID` from the `SETTLEMENTS` table. The `PAYMENT_METHOD_CODE` is set to the literal string 'SUMMARY'. The `DATE_PAYMENT_MADE` is set to the input parameter `p_to_date`. The `AMOUNT_PAYMENT` is set to the calculated `v_max_payment`.\nOtherwise (if neither of the above conditions is met), an `INSERT` statement is executed into the `PAYMENTS` table. The `PAYMENT_ID` is generated by selecting the maximum `PAYMENT_ID` from `PAYMENTS`, handling `NULL` with `NVL` to default to `0`, and adding `1`. The `SETTLEMENT_ID` is set to `NULL`. The `PAYMENT_METHOD_CODE` is set to the literal string 'NO_SETTLEMENT'. The `DATE_PAYMENT_MADE` is set to the input parameter `p_to_date`. The `AMOUNT_PAYMENT` is set to the calculated `v_total_payments`.\nFinally, a `COMMIT` statement is executed to make the changes permanent.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_payment_records(\n    p_customer_id IN NUMBER,\n    p_from_date IN VARCHAR2,\n    p_to_date IN VARCHAR2,\n    p_min_amount IN NUMBER\n) IS\n    v_total_payments NUMBER;\n    v_payment_count NUMBER;\n    v_max_payment NUMBER;\nBEGIN\n    SELECT \n        SUM(p.AMOUNT_PAYMENT),\n        COUNT(p.PAYMENT_ID),\n        MAX(p.AMOUNT_PAYMENT)\n    INTO v_total_payments, v_payment_count, v_max_payment\n    FROM PAYMENTS p\n    JOIN SETTLEMENTS s ON p.SETTLEMENT_ID = s.SETTLEMENT_ID\n    JOIN CLAIMS c ON s.CLAIM_ID = c.CLAIM_ID\n    JOIN CUSTOMER_POLICIES cp ON c.POLICY_ID = cp.POLICY_ID\n    WHERE cp.CUSTOMER_ID = p_customer_id\n    AND TO_DATE(p.DATE_PAYMENT_MADE, 'YYYY-MM-DD') BETWEEN TO_DATE(p_from_date, 'YYYY-MM-DD') AND TO_DATE(p_to_date, 'YYYY-MM-DD')\n    AND p.AMOUNT_PAYMENT >= p_min_amount;\n\n    IF v_total_payments > 1000000 THEN\n        INSERT INTO PAYMENTS (\n            PAYMENT_ID,\n            SETTLEMENT_ID,\n            PAYMENT_METHOD_CODE,\n            DATE_PAYMENT_MADE,\n            AMOUNT_PAYMENT\n        ) VALUES (\n            (SELECT NVL(MAX(PAYMENT_ID), 0) + 1 FROM PAYMENTS),\n            (SELECT MIN(SETTLEMENT_ID) FROM SETTLEMENTS),\n            'CONSOLIDATED',\n            p_to_date,\n            v_total_payments\n        );\n    ELSIF v_payment_count > 10 THEN\n        INSERT INTO PAYMENTS (\n            PAYMENT_ID,\n            SETTLEMENT_ID,\n            PAYMENT_METHOD_CODE,\n            DATE_PAYMENT_MADE,\n            AMOUNT_PAYMENT\n        ) VALUES (\n            (SELECT NVL(MAX(PAYMENT_ID), 0) + 1 FROM PAYMENTS),\n            (SELECT MAX(SETTLEMENT_ID) FROM SETTLEMENTS),\n            'SUMMARY',\n            p_to_date,\n            v_max_payment\n        );\n    ELSE\n        INSERT INTO PAYMENTS (\n            PAYMENT_ID,\n            SETTLEMENT_ID,\n            PAYMENT_METHOD_CODE,\n            DATE_PAYMENT_MADE,\n            AMOUNT_PAYMENT\n        ) VALUES (\n            (SELECT NVL(MAX(PAYMENT_ID), 0) + 1 FROM PAYMENTS),\n            NULL,\n            'NO_SETTLEMENT',\n            p_to_date,\n            v_total_payments\n        );\n    END IF;\n\n    COMMIT;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "BEGIN\n  consolidate_payment_records(1, '2017-01-01', '2017-12-31', 1000);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_payment_records(2, '2016-01-01', '2016-12-31', 5000);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_payment_records(3, '2018-01-01', '2018-12-31', 2000);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_payment_records(1, '2017-06-01', '2017-06-30', 1500);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_payment_records(2, '2017-08-01', '2017-08-31', 3000);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named consolidate_payment_records with parameters p_customer_id NUMBER, p_from_date VARCHAR2, p_to_date VARCHAR2, and p_min_amount NUMBER. Calculate total payments, payment count, and maximum payment for the customer within the date range where amount >= p_min_amount. If total payments > 1000000, insert a consolidated payment record with method 'CONSOLIDATED' using the minimum settlement ID. Else if payment count > 10, insert a summary payment record with method 'SUMMARY' using the maximum settlement ID and the maximum payment amount. Otherwise, insert a record with method 'NO_SETTLEMENT', NULL settlement ID, and the total payment amount. Commit the transaction.",
    "natural_language": "Create a stored procedure called consolidate_payment_records that takes a customer ID, a starting date, an ending date, and a minimum payment amount. For that customer and within that general timeframe, figure out the overall money paid, how many payments there were, and the single biggest payment, but only for payments that are reasonably large. If the total paid is a really huge sum, put in a new consolidated record marked 'CONSOLIDATED' using the earliest settlement ID you find. Or, if there were quite a lot of payments, then put in a summary record marked 'SUMMARY' using the latest settlement ID and that biggest payment amount. If neither of those cases fits, just put in a record marked 'NO_SETTLEMENT' with no settlement ID and the total amount. Finally, save all the changes.",
    "id": 15
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_event_summary` that accepts a single input parameter, `para_service_type`, which is of data type `VARCHAR2`. The purpose of this procedure is to identify events associated with a specific service type and, if such events exist, to associate 'Organizer' participants with those events, ensuring no duplicate associations are created.\n\nThe procedure begins by declaring a local variable `v_event_count` of data type `NUMBER`.\n\nThe first operation is a `SELECT` statement that calculates the total number of events associated with the service type specified by `para_service_type`. This `SELECT` statement retrieves data from the `EVENTS` table, aliased as `e`, and joins it with the `SERVICES` table, aliased as `s`. The join condition is `e.SERVICE_ID = s.SERVICE_ID`, linking events to their respective services. A `WHERE` clause filters these joined records based on the service type: `UPPER(s.SERVICE_TYPE_CODE) = UPPER(para_service_type)`. The `UPPER()` function is applied to both the `SERVICE_TYPE_CODE` column from the `SERVICES` table and the input parameter `para_service_type` to ensure a case-insensitive comparison. The result of this count is stored in the `v_event_count` variable.\n\nFollowing this, a conditional block (`IF v_event_count > 0 THEN ... END IF;`) is executed. This block proceeds only if `v_event_count` is greater than zero, meaning at least one event was found for the specified service type.\n\nInside this conditional block, an `INSERT` statement is performed. This `INSERT` statement adds new records into the `PARTICIPANTS_IN_EVENTS` table, populating the `EVENT_ID` and `PARTICIPANT_ID` columns. The values for these columns are derived from a nested `SELECT` statement.\n\nThe nested `SELECT` statement retrieves `EVENT_ID` from the `EVENTS` table (aliased as `e`) and `PARTICIPANT_ID` from the `PARTICIPANTS` table (aliased as `p`). It joins these two tables implicitly through its filtering conditions. The `PARTICIPANTS` table is filtered by `p.PARTICIPANT_TYPE_CODE = 'Organizer'`, ensuring that only participants designated as 'Organizer' are considered. The `EVENTS` table is filtered by `e.SERVICE_ID IN (SELECT SERVICE_ID FROM SERVICES WHERE UPPER(SERVICE_TYPE_CODE) = UPPER(para_service_type))`. This subquery identifies all `SERVICE_ID`s from the `SERVICES` table where the `SERVICE_TYPE_CODE`, after being converted to uppercase using `UPPER()`, matches the uppercase version of the `para_service_type` input parameter. This ensures that only events belonging to the specified service type are selected.\n\nCrucially, the `INSERT` statement also includes an `AND NOT EXISTS` clause to prevent the insertion of duplicate `EVENT_ID` and `PARTICIPANT_ID` pairs into the `PARTICIPANTS_IN_EVENTS` table. The `NOT EXISTS` subquery checks the `PARTICIPANTS_IN_EVENTS` table (aliased as `pie`) for any existing record where `pie.EVENT_ID` matches `e.EVENT_ID` from the outer `SELECT` and `pie.PARTICIPANT_ID` matches `p.PARTICIPANT_ID` from the outer `SELECT`. If such a record already exists, the `NOT EXISTS` condition evaluates to false, and the corresponding `EVENT_ID` and `PARTICIPANT_ID` pair is not inserted. If no such record exists, the `NOT EXISTS` condition evaluates to true, and the pair is inserted.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_event_summary(para_service_type VARCHAR2) IS\n   v_event_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_event_count\n   FROM EVENTS e\n   JOIN SERVICES s ON e.SERVICE_ID = s.SERVICE_ID\n   WHERE UPPER(s.SERVICE_TYPE_CODE) = UPPER(para_service_type);\n   \n   IF v_event_count > 0 THEN\n      INSERT INTO PARTICIPANTS_IN_EVENTS (EVENT_ID, PARTICIPANT_ID)\n      SELECT e.EVENT_ID, p.PARTICIPANT_ID\n      FROM EVENTS e\n      JOIN PARTICIPANTS p ON p.PARTICIPANT_TYPE_CODE = 'Organizer'\n      WHERE e.SERVICE_ID IN (SELECT SERVICE_ID FROM SERVICES WHERE UPPER(SERVICE_TYPE_CODE) = UPPER(para_service_type))\n      AND NOT EXISTS (\n         SELECT 1 FROM PARTICIPANTS_IN_EVENTS pie \n         WHERE pie.EVENT_ID = e.EVENT_ID \n         AND pie.PARTICIPANT_ID = p.PARTICIPANT_ID\n      );\n   END IF;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_event_summary('Marriage');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_event_summary('Death Proof');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_event_summary('Birth Proof');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_event_summary('marriage');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_event_summary('death proof');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_event_summary that accepts a VARCHAR2 parameter para_service_type. Count events for that service type (case-insensitive). If events exist, insert 'Organizer' participants into the PARTICIPANTS_IN_EVENTS table for those events, avoiding duplicate associations.",
    "natural_language": "Please construct a stored procedure designated as sp_event_summary, which shall accept a single VARCHAR2 input parameter named para_service_type. The procedure must calculate the total number of events corresponding to the specified service type, ensuring the comparison is case-insensitive. Should one or more events be identified, it is then required to insert participant records with the role 'Organizer' into the PARTICIPANTS_IN_EVENTS table for each relevant event, taking care to prevent the creation of duplicate associations.",
    "id": 16
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_participant_analysis that accepts a single input parameter para_participant_type of type VARCHAR2, which is used to specify a participant type code. The procedure first declares a local variable v_avg_event_id of type NUMBER. It then calculates the average EVENT_ID from the PARTICIPANTS_IN_EVENTS table, but only for those rows where the PARTICIPANT_ID is found in a subquery that selects PARTICIPANT_ID from the PARTICIPANTS table where the PARTICIPANT_TYPE_CODE column matches the input parameter para_participant_type; this calculated average is stored into the variable v_avg_event_id. Following this calculation, the procedure checks if v_avg_event_id is not NULL. If the condition is true, it executes a DELETE operation on the PARTICIPANTS_IN_EVENTS table, removing rows where two conditions are met simultaneously: the EVENT_ID is less than the calculated average v_avg_event_id, and the PARTICIPANT_ID is again found in the same subquery that selects PARTICIPANT_ID from the PARTICIPANTS table where PARTICIPANT_TYPE_CODE equals the input parameter para_participant_type.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_participant_analysis(para_participant_type VARCHAR2) IS\n   v_avg_event_id NUMBER;\nBEGIN\n   SELECT AVG(EVENT_ID) INTO v_avg_event_id\n   FROM PARTICIPANTS_IN_EVENTS\n   WHERE PARTICIPANT_ID IN (SELECT PARTICIPANT_ID FROM PARTICIPANTS WHERE PARTICIPANT_TYPE_CODE = para_participant_type);\n   \n   IF v_avg_event_id IS NOT NULL THEN\n      DELETE FROM PARTICIPANTS_IN_EVENTS\n      WHERE EVENT_ID < v_avg_event_id AND PARTICIPANT_ID IN (SELECT PARTICIPANT_ID FROM PARTICIPANTS WHERE PARTICIPANT_TYPE_CODE = para_participant_type);\n   END IF;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_participant_analysis('Organizer');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_participant_analysis('Attendee');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_participant_analysis('Speaker');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_participant_analysis('Volunteer');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_participant_analysis('Judge');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_participant_analysis that accepts a VARCHAR2 parameter para_participant_type. Calculate the average EVENT_ID for that participant type from the PARTICIPANTS_IN_EVENTS table. If the average is not NULL, delete rows from PARTICIPANTS_IN_EVENTS where the EVENT_ID is below that average and the PARTICIPANT_ID belongs to the specified type.",
    "natural_language": "Create a stored procedure called sp_participant_analysis that takes a kind of participant type as a parameter. Figure out the typical EVENT_ID for that general type of participant from the data. If that typical number exists, then clean up the table by removing entries where the EVENT_ID is on the lower side compared to that typical figure and where the PARTICIPANT_ID fits the described type.",
    "id": 17
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_service_participant_count that accepts a single parameter, para_service_type, of type VARCHAR2, which represents the service type code to be used in the procedure's logic. The procedure begins by declaring a local variable v_participant_count of type NUMBER to store the count of participants associated with the specified service type. It then executes a SELECT statement to count the number of participants who are linked to events that are associated with services matching the provided service type code. This is achieved by joining the PARTICIPANTS table with the PARTICIPANTS_IN_EVENTS table on the PARTICIPANT_ID column, then joining the resulting set with the EVENTS table on the EVENT_ID column, and finally joining with the SERVICES table on the SERVICE_ID column. The WHERE clause filters the results to include only those rows where the SERVICE_TYPE_CODE column in the SERVICES table, converted to uppercase using the UPPER() function, matches the uppercase version of the para_service_type parameter. The count result is stored in the v_participant_count variable. Following the SELECT operation, the procedure checks if the value of v_participant_count is less than 5 using an IF conditional statement. If this condition is true, the procedure performs an INSERT operation into the PARTICIPANTS table, adding a new row with a PARTICIPANT_ID value that is one greater than the current maximum PARTICIPANT_ID in the table, or 1 if the table is empty, determined using a subquery with the COALESCE() function. The new row is assigned a PARTICIPANT_TYPE_CODE of 'Volunteer' and PARTICIPANT_DETAILS of 'New Volunteer'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_service_participant_count(para_service_type VARCHAR2) IS\n   v_participant_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_participant_count\n   FROM PARTICIPANTS p\n   JOIN PARTICIPANTS_IN_EVENTS pie ON p.PARTICIPANT_ID = pie.PARTICIPANT_ID\n   JOIN EVENTS e ON pie.EVENT_ID = e.EVENT_ID\n   JOIN SERVICES s ON e.SERVICE_ID = s.SERVICE_ID\n   WHERE UPPER(s.SERVICE_TYPE_CODE) = UPPER(para_service_type);\n   \n   IF v_participant_count < 5 THEN\n      INSERT INTO PARTICIPANTS (PARTICIPANT_ID, PARTICIPANT_TYPE_CODE, PARTICIPANT_DETAILS)\n      VALUES ((SELECT COALESCE(MAX(PARTICIPANT_ID),0)+1 FROM PARTICIPANTS), 'Volunteer', 'New Volunteer');\n   END IF;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_service_participant_count('Marriage');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Death Proof');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Birth Proof');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Education');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Health');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_service_participant_count that accepts a VARCHAR2 parameter para_service_type. Count participants linked to events of that service type (case-insensitive). If the count is less than 5, insert a new 'Volunteer' participant into the PARTICIPANTS table with an ID one greater than the current maximum.",
    "natural_language": "Please construct a stored procedure designated as sp_service_participant_count, which shall accept a single VARCHAR2 input parameter named para_service_type. The procedure is to compute the total number of participants associated with events corresponding to the specified service type, disregarding case sensitivity. Should the resultant count be fewer than five, the procedure must then insert a new participant record into the PARTICIPANTS table. This new record shall be of the type 'Volunteer' and shall be assigned an ID value that is one greater than the current maximum ID present in the table.",
    "id": 18
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `aggregate_mountain_photos` that accepts four input parameters: `p_country_filter` of type `VARCHAR2`, `p_min_height` of type `NUMBER`, `p_brand_filter` of type `VARCHAR2`, and `p_color_filter` of type `VARCHAR2`. The procedure declares five local variables: `v_total_photos` of type `NUMBER`, `v_avg_height` of type `NUMBER`, `v_max_prominence` of type `NUMBER`, `v_lens_count` of type `NUMBER`, and `v_max_id` of type `NUMBER`.\n\nThe procedure begins by executing a `SELECT COUNT(*)` statement to determine the total number of photos that meet specific criteria. This count is stored in the `v_total_photos` variable. The selection criteria involve joining the `photos` table (aliased as `p`), the `mountain` table (aliased as `m`), and the `camera_lens` table (aliased as `cl`). The join conditions are `p.mountain_id = m.id` and `p.camera_lens_id = cl.id`. The `WHERE` clause filters these joined records where the `country` column in the `mountain` table matches the `p_country_filter` parameter, the `height` column in the `mountain` table is greater than or equal to the `p_min_height` parameter, the `brand` column in the `camera_lens` table matches the `p_brand_filter` parameter, and the `color` column in the `photos` table matches the `p_color_filter` parameter.\n\nNext, the procedure executes a `SELECT AVG(m.height)` statement to calculate the average height of mountains. This average is stored in the `v_avg_height` variable. The selection is performed on the `mountain` table (aliased as `m`), with the `WHERE` clause filtering records where the `country` column matches the `p_country_filter` parameter and the `height` column is greater than or equal to the `p_min_height` parameter.\n\nSubsequently, the procedure executes a `SELECT MAX(m.prominence)` statement to find the maximum prominence among mountains. This maximum value is stored in the `v_max_prominence` variable. The selection is performed on the `mountain` table (aliased as `m`), with the `WHERE` clause filtering records where the `country` column matches the `p_country_filter` parameter.\n\nFollowing this, the procedure executes a `SELECT COUNT(*)` statement to count the number of camera lenses. This count is stored in the `v_lens_count` variable. The selection is performed on the `camera_lens` table (aliased as `cl`), with the `WHERE` clause filtering records where the `brand` column matches the `p_brand_filter` parameter.\n\nThen, the procedure executes a `SELECT NVL(MAX(id), 0)` statement to determine the maximum `id` value currently present in the `photos` table. If no `id` values are found (i.e., the table is empty), the `NVL` function ensures that `0` is returned instead of `NULL`. This maximum ID is stored in the `v_max_id` variable.\n\nFinally, the procedure performs an `INSERT INTO photos` statement to add new records to the `photos` table. The `id` for each new record is generated by adding `ROWNUM` (which provides a sequential number for each row returned by the subquery) to the `v_max_id` variable. The `camera_lens_id` for each new record is determined by a subquery `(SELECT MIN(id) FROM camera_lens WHERE brand = p_brand_filter)`, which selects the minimum `id` from the `camera_lens` table where the `brand` matches the `p_brand_filter` parameter. The `mountain_id` for each new record is taken from the `id` column of the `mountain` table (aliased as `m`) in the main `SELECT` statement. The `color` for each new record is set to the value of the `p_color_filter` parameter. The `name` for each new record is constructed by concatenating the string literal 'agg_' with the `name` column from the `mountain` table. The `SELECT` statement for the `INSERT` retrieves data from the `mountain` table (aliased as `m`), filtering records where the `country` column matches the `p_country_filter` parameter and the `height` column is greater than or equal to the `p_min_height` parameter. Additionally, a `NOT EXISTS` subquery is used to ensure that a new photo is inserted only if there isn't already an existing photo in the `photos` table (aliased as `p2`) for the same `mountain_id` and `color` (matching `p_color_filter`).",
    "plsql": "CREATE OR REPLACE PROCEDURE aggregate_mountain_photos(\n    p_country_filter IN VARCHAR2,\n    p_min_height IN NUMBER,\n    p_brand_filter IN VARCHAR2,\n    p_color_filter IN VARCHAR2\n) IS\n    v_total_photos NUMBER;\n    v_avg_height NUMBER;\n    v_max_prominence NUMBER;\n    v_lens_count NUMBER;\n    v_max_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_photos\n    FROM photos p\n    JOIN mountain m ON p.mountain_id = m.id\n    JOIN camera_lens cl ON p.camera_lens_id = cl.id\n    WHERE m.country = p_country_filter\n    AND m.height >= p_min_height\n    AND cl.brand = p_brand_filter\n    AND p.color = p_color_filter;\n\n    SELECT AVG(m.height) INTO v_avg_height\n    FROM mountain m\n    WHERE m.country = p_country_filter\n    AND m.height >= p_min_height;\n\n    SELECT MAX(m.prominence) INTO v_max_prominence\n    FROM mountain m\n    WHERE m.country = p_country_filter;\n\n    SELECT COUNT(*) INTO v_lens_count\n    FROM camera_lens cl\n    WHERE cl.brand = p_brand_filter;\n\n    SELECT NVL(MAX(id), 0) INTO v_max_id FROM photos;\n\n    INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n    SELECT v_max_id + ROWNUM,\n           (SELECT MIN(id) FROM camera_lens WHERE brand = p_brand_filter),\n           m.id,\n           p_color_filter,\n           'agg_' || m.name\n    FROM mountain m\n    WHERE m.country = p_country_filter\n    AND m.height >= p_min_height\n    AND NOT EXISTS (\n        SELECT 1 FROM photos p2 \n        WHERE p2.mountain_id = m.id \n        AND p2.color = p_color_filter\n    );\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  aggregate_mountain_photos('Ethiopia', 4000, 'Sigma', 'RBG');\n  COMMIT;\nEND;",
      "BEGIN\n  aggregate_mountain_photos('Morocco', 4100, 'Sigma', 'RGB');\n  COMMIT;\nEND;",
      "BEGIN\n  aggregate_mountain_photos('Rwanda Uganda', 4100, 'Sigma', 'BGR');\n  COMMIT;\nEND;",
      "BEGIN\n  aggregate_mountain_photos('Ethiopia', 3000, 'Sigma', 'Grayscale');\n  COMMIT;\nEND;",
      "BEGIN\n  aggregate_mountain_photos('Morocco', 3500, 'Sigma', 'Sepia');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named aggregate_mountain_photos with parameters for country, minimum height, lens brand, and photo color. Calculate aggregate statistics: total photos, average mountain height, maximum prominence, and lens count. Then, insert new photo records for mountains meeting the country and height criteria, using the specified lens brand and color, and generating unique IDs, while preventing duplicates for the same mountain and color.",
    "natural_language": "Create a stored procedure called aggregate_mountain_photos that takes in some parameters like a country, a not-too-low height, a lens brand, and a photo color. Figure out some overall numbers: how many photos there are in total, the typical mountain height, the biggest prominence value, and how many lenses. Then, add a few new photo entries for mountains that are roughly in that country and are reasonably tall, using the given lens brand and that color, making sure each gets a unique ID and avoiding any repeats for the same mountain and a similar color.",
    "id": 19
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `transform_photo_records` that accepts four input parameters: a string parameter `p_brand_pattern` for matching camera lens brand names, a numeric parameter `p_height_limit` for mountain height comparison, a numeric parameter `p_prominence_min` for mountain prominence comparison, and a string parameter `p_color_to_change` for identifying and updating photo colors. The procedure first deletes records from the `photos` table where the `camera_lens_id` corresponds to any `id` from the `camera_lens` table whose `brand` column contains the `p_brand_pattern` string (using a `LIKE` pattern with wildcards `'%' || p_brand_pattern || '%'`), and where the `mountain_id` corresponds to any `id` from the `mountain` table where either the `height` is less than `p_height_limit` or the `prominence` is less than `p_prominence_min`, storing the number of deleted rows in the local variable `v_deleted_count`. It then retrieves the current maximum `id` value from the `photos` table, defaulting to 0 if none exist, into the local variable `v_max_id`. Next, it inserts new rows into the `photos` table with columns `id`, `camera_lens_id`, `mountain_id`, `color`, and `name` by selecting from a join of the `camera_lens` table (aliased as `cl`) and the `mountain` table (aliased as `m`) where the `mountain` `height` is greater than or equal to `p_height_limit`, the `camera_lens` `brand` contains the `p_brand_pattern` string, the `mountain` `prominence` is greater than or equal to `p_prominence_min`, and a pair does not already exist in the `photos` table (checked via a `NOT EXISTS` subquery that looks for a row in `photos` `p` where `p.camera_lens_id` equals `cl.id` and `p.mountain_id` equals `m.id`); for each selected row, the new `id` is generated as `v_max_id` plus the `ROWNUM`, the `color` is set to the input parameter `p_color_to_change`, and the `name` is constructed by concatenating the string `'trans_'` with the `camera_lens` `name`, an underscore, and the `mountain` `name`, storing the number of inserted rows in `v_inserted_count` using `SQL%ROWCOUNT`. Finally, the procedure updates existing records in the `photos` table by prepending the string `'OLD_'` to the `color` column and prepending `'archived_'` to the `name` column for any row where the current `color` equals the input parameter `p_color_to_change` and the `mountain_id` corresponds to a `mountain` `id` where the `height` is less than `p_height_limit`, storing the number of updated rows in `v_updated_count` using `SQL%ROWCOUNT`.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_photo_records(\n    p_brand_pattern IN VARCHAR2,\n    p_height_limit IN NUMBER,\n    p_prominence_min IN NUMBER,\n    p_color_to_change IN VARCHAR2\n) IS\n    v_deleted_count NUMBER;\n    v_inserted_count NUMBER;\n    v_updated_count NUMBER;\n    v_max_id NUMBER;\nBEGIN\n    DELETE FROM photos\n    WHERE camera_lens_id IN (\n        SELECT id FROM camera_lens\n        WHERE brand LIKE '%' || p_brand_pattern || '%'\n    )\n    AND mountain_id IN (\n        SELECT id FROM mountain\n        WHERE height < p_height_limit\n        OR prominence < p_prominence_min\n    )\n    RETURNING COUNT(*) INTO v_deleted_count;\n\n    -- Get the current maximum ID before inserting new records\n    SELECT NVL(MAX(id), 0) INTO v_max_id FROM photos;\n\n    INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n    SELECT v_max_id + ROWNUM, -- Generate unique IDs based on the max_id and ROWNUM\n           cl.id,\n           m.id,\n           p_color_to_change,\n           'trans_' || cl.name || '_' || m.name\n    FROM camera_lens cl\n    JOIN mountain m ON m.height >= p_height_limit\n    WHERE cl.brand LIKE '%' || p_brand_pattern || '%'\n    AND m.prominence >= p_prominence_min\n    AND NOT EXISTS (\n        SELECT 1 FROM photos p\n        WHERE p.camera_lens_id = cl.id\n        AND p.mountain_id = m.id\n    );\n\n    v_inserted_count := SQL%ROWCOUNT;\n\n    UPDATE photos\n    SET color = 'OLD_' || color,\n        name = 'archived_' || name\n    WHERE color = p_color_to_change\n    AND mountain_id IN (\n        SELECT id FROM mountain\n        WHERE height < p_height_limit\n    );\n\n    v_updated_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  transform_photo_records(p_brand_pattern => 'Sigma', p_height_limit => 4000, p_prominence_min => 1500, p_color_to_change => 'Blue');\nEND;",
      "BEGIN\n  transform_photo_records(p_brand_pattern => 'Canon', p_height_limit => 3000, p_prominence_min => 1000, p_color_to_change => 'Green');\nEND;",
      "BEGIN\n  transform_photo_records(p_brand_pattern => 'Nikon', p_height_limit => 5000, p_prominence_min => 2000, p_color_to_change => 'Red');\nEND;",
      "BEGIN\n  transform_photo_records(p_brand_pattern => 'Sony', p_height_limit => 4500, p_prominence_min => 1800, p_color_to_change => 'Yellow');\nEND;",
      "BEGIN\n  transform_photo_records(p_brand_pattern => 'Fuji', p_height_limit => 3500, p_prominence_min => 1200, p_color_to_change => 'Purple');\nEND;"
    ],
    "summary": "Create a stored procedure named transform_photo_records with parameters for lens brand pattern, height limit, prominence minimum, and target color. First, delete photos where the lens brand matches the pattern and the mountain's height or prominence is below the limits. Then, insert new photos for lens-mountain pairs meeting the height, prominence, and brand criteria, setting the color to the target and generating unique IDs. Finally, update existing photos with the target color for mountains below the height limit by prepending 'OLD_' to the color and 'archived_' to the name.",
    "natural_language": "Alright, so we need a stored procedure called transform_photo_records. It's gotta take in a lens brand pattern, a max height, a minimum prominence, and a target color. First off, trash any photos where the lens brand fits the pattern and the mountain's height or prominence is too low. Next, add new photos for any lens and mountain combo that hits the right height, prominence, and brand specsgive 'em the target color and whip up some unique IDs. Lastly, for photos of mountains that are under the height limit, update 'em by slapping 'OLD_' in front of the color and 'archived_' before the name.",
    "id": 20
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named analyze_photo_distribution that accepts four parameters: p_mountain_range of type VARCHAR2, p_aperture_max of type NUMBER, p_min_photos of type NUMBER, and p_target_color of type VARCHAR2. The procedure begins by declaring a cursor named mountain_cursor, which selects the id and name of mountains from the mountain table, along with a count of associated photos from the photos table, where the mountain's range matches the input parameter p_mountain_range. The cursor groups the results by mountain id and name, filtering to include only those mountains with a photo count less than the input parameter p_min_photos. The procedure then declares two local variables, v_lens_id and v_new_id, both of type NUMBER. It selects the id of a camera lens from the camera_lens table where the max_aperture is less than or equal to the input parameter p_aperture_max, limiting the result to the first row using ROWNUM = 1, and stores this id in the variable v_lens_id. The procedure enters a loop over the records in mountain_cursor. For each record, it calculates a new photo id by selecting the maximum id from the photos table, using NVL to default to 0 if no rows exist, and adding 1, storing the result in v_new_id. It then inserts a new row into the photos table with the calculated id, the selected camera lens id, the current mountain id, the input target color, and a name constructed by concatenating 'fill_', the mountain name, and the current date formatted as 'DDMM'. If the current mountain's photo count is zero, the procedure inserts an additional row into the photos table with an id incremented by 1, the same camera lens id, the current mountain id, a color of 'SECONDARY', and a name constructed by concatenating 'backup_' and the mountain name. After processing all mountains, the procedure deletes rows from the photos table where the mountain id is in the set of ids from the mountain table with a range matching p_mountain_range, and where no camera lens exists with an id matching the photo's camera lens id and a max_aperture less than or equal to p_aperture_max.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_photo_distribution(\n    p_mountain_range IN VARCHAR2,\n    p_aperture_max IN NUMBER,\n    p_min_photos IN NUMBER,\n    p_target_color IN VARCHAR2\n) IS\n    CURSOR mountain_cursor IS\n        SELECT m.id, m.name, COUNT(p.id) as photo_count\n        FROM mountain m\n        LEFT JOIN photos p ON m.id = p.mountain_id\n        WHERE m.range = p_mountain_range\n        GROUP BY m.id, m.name\n        HAVING COUNT(p.id) < p_min_photos;\n    \n    v_lens_id NUMBER;\n    v_new_id NUMBER;\nBEGIN\n    SELECT id INTO v_lens_id\n    FROM camera_lens\n    WHERE max_aperture <= p_aperture_max\n    AND ROWNUM = 1;\n\n    FOR mountain_rec IN mountain_cursor LOOP\n        SELECT NVL(MAX(id), 0) + 1 INTO v_new_id FROM photos;\n        \n        INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n        VALUES (\n            v_new_id,\n            v_lens_id,\n            mountain_rec.id,\n            p_target_color,\n            'fill_' || mountain_rec.name || '_' || TO_CHAR(SYSDATE, 'DDMM')\n        );\n        \n        IF mountain_rec.photo_count = 0 THEN\n            INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n            VALUES (\n                v_new_id + 1,\n                v_lens_id,\n                mountain_rec.id,\n            'SECONDARY',\n                'backup_' || mountain_rec.name\n            );\n        END IF;\n    END LOOP;\n    \n    DELETE FROM photos\n    WHERE mountain_id IN (\n        SELECT m.id\n        FROM mountain m\n        WHERE m.range = p_mountain_range\n        AND NOT EXISTS (\n            SELECT 1 FROM camera_lens cl \n            WHERE cl.id = photos.camera_lens_id\n            AND cl.max_aperture <= p_aperture_max\n        )\n    );\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  analyze_photo_distribution('Arsi Mountains', 2.8, 5, 'Blue');\n  commit;\nEND;",
      "BEGIN\n  analyze_photo_distribution('Toubkal Atlas', 2.8, 10, 'Red');\n  commit;\nEND;",
      "BEGIN\n  analyze_photo_distribution('Virunga Mountains', 2.8, 3, 'Green');\n  commit;\nEND;",
      "BEGIN\n  analyze_photo_distribution('Arsi Mountains', 2.8, 2, 'Yellow');\n  commit;\nEND;",
      "BEGIN\n  analyze_photo_distribution('Toubkal Atlas', 2.8, 8, 'Purple');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named analyze_photo_distribution. It accepts parameters for mountain range, maximum aperture, minimum photo count, and target color. For mountains in the specified range with fewer photos than the minimum, insert new photos using a lens with an aperture less than or equal to the maximum. If a mountain has zero photos, insert an additional backup photo. Finally, delete any photos for mountains in that range where the associated lens's aperture exceeds the maximum.",
    "natural_language": "Alright, so we need a stored procedure called 'analyze_photo_distribution'. It's gonna take in a mountain range, a max aperture, a minimum number of photos, and a target color. Here's the deal: for any mountains in that range that have fewer photos than the minimum, we gotta add new photos using a lens whose aperture isn't bigger than the max we gave. Oh, and if a mountain has zero photos at all, toss in an extra backup photo for good measure. Lastly, get rid of any photos for mountains in that range if the lens used has an aperture bigger than the maximum allowed.",
    "id": 21
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named synchronize_lens_mountains that accepts four parameters: p_country_name of type VARCHAR2, p_focal_min and p_focal_max of type NUMBER, and p_batch_size of type NUMBER. The procedure begins by initializing a local variable v_counter to zero, which will be used to count the number of insert operations performed. It then calculates the total number of mountains located in the specified country by executing a SELECT COUNT(*) query on the MOUNTAIN table where the COUNTRY column matches the p_country_name parameter, storing the result in the v_total_mountains variable. Similarly, it calculates the total number of camera lenses with focal lengths between p_focal_min and p_focal_max by executing a SELECT COUNT(*) query on the CAMERA_LENS table, storing the result in the v_total_lenses variable. The procedure retrieves the maximum ID value from the PHOTOS table using a SELECT NVL(MAX(ID), 0) query, storing the result in the v_max_id variable. The procedure then enters a nested loop structure, first iterating over camera lenses with focal lengths between p_focal_min and p_focal_max, ordered by ID, using a cursor named lens_rec. For each lens, it enters a second loop to iterate over mountains in the specified country whose ID modulo 3 matches the lens ID modulo 3, using a cursor named mountain_rec. Within the inner loop, the procedure increments v_counter by one and inserts a new row into the PHOTOS table with the following values: a unique ID calculated as v_max_id plus v_counter, the current lens ID, the current mountain ID, a COLOR value determined by the lens's focal length (WIDE for less than 30, TELE for greater than 100, NORMAL otherwise), and a NAME value concatenating the lens brand and mountain name. If v_counter reaches or exceeds p_batch_size, the procedure exits immediately using a RETURN statement. If the procedure completes the loops without reaching the batch size, it enters another loop to insert additional rows into the PHOTOS table until the batch size is met. In this loop, it inserts rows with a unique ID calculated as v_max_id plus v_counter plus the loop index, the minimum ID from the CAMERA_LENS table, the minimum ID from the MOUNTAIN table for the specified country, a COLOR value of 'DEFAULT', and a NAME value formatted as 'fallback_' followed by the current timestamp and loop index.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_lens_mountains(\n    p_country_name IN VARCHAR2,\n    p_focal_min IN NUMBER,\n    p_focal_max IN NUMBER,\n    p_batch_size IN NUMBER\n) IS\n    v_counter NUMBER := 0;\n    v_total_mountains NUMBER;\n    v_total_lenses NUMBER;\n    v_max_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_mountains\n    FROM MOUNTAIN\n    WHERE COUNTRY = p_country_name;\n    \n    SELECT COUNT(*) INTO v_total_lenses\n    FROM CAMERA_LENS\n    WHERE FOCAL_LENGTH_MM BETWEEN p_focal_min AND p_focal_max;\n    \n    SELECT NVL(MAX(ID), 0) INTO v_max_id FROM PHOTOS;\n    \n    FOR lens_rec IN (\n        SELECT ID, BRAND, NAME, FOCAL_LENGTH_MM\n        FROM CAMERA_LENS\n        WHERE FOCAL_LENGTH_MM BETWEEN p_focal_min AND p_focal_max\n        ORDER BY ID\n    ) LOOP\n        FOR mountain_rec IN (\n            SELECT ID, NAME\n            FROM MOUNTAIN\n            WHERE COUNTRY = p_country_name\n            AND MOD(ID, 3) = MOD(lens_rec.ID, 3)\n        ) LOOP\n            v_counter := v_counter + 1;\n            \n            INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME)\n            VALUES (\n                v_max_id + v_counter,\n                lens_rec.ID,\n                mountain_rec.ID,\n                CASE \n                    WHEN lens_rec.FOCAL_LENGTH_MM < 30 THEN 'WIDE'\n                    WHEN lens_rec.FOCAL_LENGTH_MM > 100 THEN 'TELE'\n                    ELSE 'NORMAL'\n                END,\n                lens_rec.BRAND || '_' || mountain_rec.NAME\n            );\n            \n            IF v_counter >= p_batch_size THEN\n                RETURN;\n            END IF;\n        END LOOP;\n    END LOOP;\n    \n    IF v_counter < p_batch_size THEN\n        FOR i IN 1..(p_batch_size - v_counter) LOOP\n            INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME)\n            VALUES (\n                v_max_id + v_counter + i,\n                (SELECT MIN(ID) FROM CAMERA_LENS),\n                (SELECT MIN(ID) FROM MOUNTAIN WHERE COUNTRY = p_country_name),\n                'DEFAULT',\n                'fallback_' || TO_CHAR(CURRENT_TIMESTAMP, 'HH24MISS') || '_' || i\n            );\n        END LOOP;\n    END IF;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  synchronize_lens_mountains('Ethiopia', 10, 50, 100);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Morocco', 20, 200, 50);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Rwanda Uganda', 30, 300, 200);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Ethiopia', 1, 500, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Morocco', 100, 400, 1000);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named synchronize_lens_mountains. It accepts parameters for country name, focal length range, and batch size. For lenses within the focal range and mountains in the specified country where their IDs modulo 3 match, insert new photos with a color based on focal length. Stop and return when the number of inserts reaches the batch size. If the batch size is not met, insert fallback photo records until it is.",
    "natural_language": "Create a stored procedure called synchronize_lens_mountains that takes a country name, a focal length range, and a batch size as parameters. For each matching lens and mountain where the lens focal length is within the range, the mountain is in the specified country, and their IDs modulo 3 are equal, insert a new photo with a color determined by the focal length. Halt and return once the number of inserted photos reaches the batch size. If the batch size is not met, insert fallback photo records until the batch size is fulfilled.",
    "id": 22
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_update_like_status that accepts five parameters: p_student_id of type NUMBER, p_liked_id of type NUMBER, p_action of type VARCHAR2, p_status of type VARCHAR2 as an OUT parameter, and p_affected of type NUMBER as an OUT parameter. The procedure performs operations on the LIKES table, which contains columns STUDENT_ID and LIKED_ID. The procedure begins by checking if the value of p_action is 'LIKE'. If it is, it executes a SELECT statement to count the number of rows in the LIKES table where STUDENT_ID matches p_student_id and LIKED_ID matches p_liked_id, storing the result in the variable v_exists. If v_exists is zero, indicating no existing like relationship, it inserts a new row into the LIKES table with STUDENT_ID set to p_student_id and LIKED_ID set to p_liked_id, then sets p_affected to 1 and p_status to 'LIKED'. If v_exists is not zero, it sets p_affected to 0 and p_status to 'ALREADY LIKED'. If p_action is 'UNLIKE', it deletes rows from the LIKES table where STUDENT_ID matches p_student_id and LIKED_ID matches p_liked_id, sets p_affected to the number of rows affected by the delete operation using SQL%ROWCOUNT, and sets p_status to 'UNLIKED'. If p_action is neither 'LIKE' nor 'UNLIKE', it sets p_affected to 0 and p_status to 'INVALID ACTION'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_update_like_status(\n    p_student_id IN NUMBER,\n    p_liked_id IN NUMBER,\n    p_action IN VARCHAR2,\n    p_status OUT VARCHAR2,\n    p_affected OUT NUMBER\n)\nIS\n    v_exists NUMBER;\nBEGIN\n    IF p_action = 'LIKE' THEN\n        SELECT COUNT(*) INTO v_exists FROM LIKES WHERE STUDENT_ID = p_student_id AND LIKED_ID = p_liked_id;\n        IF v_exists = 0 THEN\n            INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (p_student_id, p_liked_id);\n            p_affected := 1;\n            p_status := 'LIKED';\n        ELSE\n            p_affected := 0;\n            p_status := 'ALREADY LIKED';\n        END IF;\n    ELSIF p_action = 'UNLIKE' THEN\n        DELETE FROM LIKES WHERE STUDENT_ID = p_student_id AND LIKED_ID = p_liked_id;\n        p_affected := SQL%ROWCOUNT;\n        p_status := 'UNLIKED';\n    ELSE\n        p_affected := 0;\n        p_status := 'INVALID ACTION';\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\nBEGIN\n  proc_update_like_status(1510, 1689, 'LIKE', v_status, v_affected);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status || ', Affected: ' || v_affected);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\nBEGIN\n  proc_update_like_status(1510, 1689, 'UNLIKE', v_status, v_affected);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status || ', Affected: ' || v_affected);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\nBEGIN\n  proc_update_like_status(1247, 1101, 'LIKE', v_status, v_affected);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status || ', Affected: ' || v_affected);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\nBEGIN\n  proc_update_like_status(1381, 1510, 'LIKE', v_status, v_affected);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status || ', Affected: ' || v_affected);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\nBEGIN\n  proc_update_like_status(1689, 1381, 'FOLLOW', v_status, v_affected);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status || ', Affected: ' || v_affected);\nEND;"
    ],
    "summary": "Create a stored procedure named proc_update_like_status. It accepts parameters for student ID, liked ID, and an action ('LIKE' or 'UNLIKE'). If the action is 'LIKE', insert the like if it doesn't exist. If the action is 'UNLIKE', delete the like. Return the operation status and the number of affected rows via OUT parameters.",
    "natural_language": "How can I create a stored procedure called proc_update_like_status that takes a student ID, a liked ID, and an action ('LIKE' or 'UNLIKE') as parameters? The procedure should insert a like if the action is 'LIKE' and the like doesn't already exist, or delete the like if the action is 'UNLIKE'. How do I set it up to return the operation status and the number of affected rows through OUT parameters?",
    "id": 23
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_insert_friend_if_not_exists that accepts four parameters: p_student_id of type NUMBER, p_friend_id of type NUMBER, p_output_status of type OUT VARCHAR2, and p_output_affected of type OUT NUMBER, along with p_output_grade of type OUT NUMBER. The procedure begins by declaring a local variable v_exists of type NUMBER. It then performs a SELECT operation to count the number of rows in the FRIEND table where the STUDENT_ID column matches the value of p_student_id and the FRIEND_ID column matches the value of p_friend_id, storing the result in v_exists. The procedure uses an IF conditional statement to check if v_exists equals 0, indicating that no such friendship record exists. If true, it executes an INSERT operation to add a new row to the FRIEND table with STUDENT_ID set to p_student_id and FRIEND_ID set to p_friend_id, then sets p_output_affected to 1 and p_output_status to 'FRIEND ADDED'. If v_exists is not 0, meaning the friendship already exists, it sets p_output_affected to 0 and p_output_status to 'FRIEND EXISTS'. Regardless of the conditional outcome, the procedure assigns a value of 0 to p_output_grade, which serves as a placeholder since grade information is not relevant to the procedure's operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_insert_friend_if_not_exists(\n    p_student_id IN NUMBER,\n    p_friend_id IN NUMBER,\n    p_output_status OUT VARCHAR2,\n    p_output_affected OUT NUMBER,\n    p_output_grade OUT NUMBER\n)\nIS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM FRIEND WHERE STUDENT_ID = p_student_id AND FRIEND_ID = p_friend_id;\n    IF v_exists = 0 THEN\n        INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (p_student_id, p_friend_id);\n        p_output_affected := 1;\n        p_output_status := 'FRIEND ADDED';\n    ELSE\n        p_output_affected := 0;\n        p_output_status := 'FRIEND EXISTS';\n    END IF;\n\n    p_output_grade := 0; -- Placeholder as grade is not relevant here\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1101, 1641, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1247, 1501, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1101, 1911, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1381, 1510, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1247, 1641, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;"
    ],
    "summary": "Create a stored procedure named proc_insert_friend_if_not_exists. It accepts parameters for student ID and friend ID. Check if the friendship already exists. If not, insert it. Return a status message, the number of affected rows (0 or 1), and a placeholder grade value via OUT parameters.",
    "natural_language": "Hey, can you whip up a stored procedure called proc_insert_friend_if_not_exists? It needs to take a student ID and a friend ID. First, check if these two are already buddies. If they're not, go ahead and add the friendship. Then, spit back a status message, tell us if you added anyone (like 0 or 1 row), and also toss out a dummy grade value using those OUT parameters.",
    "id": 24
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_building_height that accepts three parameters: p_building_id of type VARCHAR2, which specifies the unique identifier of a building; p_new_height of type NUMBER, which indicates the new height to be set for the building; and p_old_height of type NUMBER, which is an output parameter intended to store the current height of the building before the update. The procedure begins by executing a SELECT statement to retrieve the current height of the building, identified by the BUILDING_ID column in the BUILDING table, and assigns this value to the p_old_height parameter. Following this, the procedure performs an UPDATE operation on the BUILDING table, setting the HEIGHT_FEET column to the value provided in p_new_height for the row where the BUILDING_ID matches the value of p_building_id. The procedure does not include any conditional logic or error handling and assumes that the BUILDING_ID provided corresponds to an existing record in the BUILDING table.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_building_height(\n    p_building_id IN VARCHAR2,\n    p_new_height IN NUMBER,\n    p_old_height OUT NUMBER\n) IS\nBEGIN\n    SELECT HEIGHT_FEET INTO p_old_height FROM BUILDING WHERE BUILDING_ID = p_building_id;\n    UPDATE BUILDING SET HEIGHT_FEET = p_new_height WHERE BUILDING_ID = p_building_id;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "DECLARE\n    v_old_height NUMBER;\nBEGIN\n    update_building_height('0', 150, v_old_height);\n    COMMIT;\nEND;",
      "DECLARE\n    v_old_height NUMBER;\nBEGIN\n    update_building_height('1', 165, v_old_height);\n    COMMIT;\nEND;",
      "DECLARE\n    v_old_height NUMBER;\nBEGIN\n    update_building_height('2', 210, v_old_height);\n    COMMIT;\nEND;",
      "DECLARE\n    v_old_height NUMBER;\nBEGIN\n    update_building_height('0', 148, v_old_height);\n    COMMIT;\nEND;",
      "DECLARE\n    v_old_height NUMBER;\nBEGIN\n    update_building_height('1', 162, v_old_height);\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_building_height. It accepts parameters for a building ID and a new height. Retrieve the current height into an OUT parameter, then update the building's height to the new value.",
    "natural_language": "Write a stored procedure called update_building_height that takes a building ID and a new height as parameters. Fetch the current height into an OUT parameter and then set the building's height to the new value.",
    "id": 25
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_process_student_distances` that does not accept any input parameters. This procedure begins by declaring a cursor named `cur_students` which selects the `STUID` and `CITY_CODE` columns from the `STUDENT` table. It also declares several local variables: `v_city1_code` of type `VARCHAR2(255)`, `v_city2_code` of type `VARCHAR2(255)`, `v_distance` of type `NUMBER`, `v_counter` of type `NUMBER` initialized to `0`, and `v_total_age` of type `NUMBER` initialized to `0`. The procedure then iterates through each record returned by the `cur_students` cursor. For each `rec` in `cur_students`, it first selects the `CITY_CODE` from the `STUDENT` table into `v_city1_code` where the `STUID` matches `rec.STUID`. Next, it selects the `CITY_CODE` from the `CITY` table into `v_city2_code` where the `STATE` column is equal to the literal string 'MD' and `ROWNUM` is equal to `1`, effectively picking one city code from Maryland. Subsequently, it selects the `DISTANCE` from the `DIRECT_DISTANCE` table into `v_distance` where `CITY1_CODE` matches `v_city1_code` and `CITY2_CODE` matches `v_city2_code`. Following this, a series of conditional operations are performed based on the value of `v_distance`. If `v_distance` is greater than `500`, the `MAJOR` column in the `STUDENT` table is updated by adding `100` to its current value for the student whose `STUID` matches `rec.STUID`, and `v_counter` is incremented by `1`. Else if `v_distance` is greater than `200` (but not greater than `500`), the `ADVISOR` column in the `STUDENT` table is updated by subtracting `50` from its current value for the student whose `STUID` matches `rec.STUID`, and `v_counter` is incremented by `2`. Else if `v_distance` is greater than `100` (but not greater than `200`), a row is deleted from the `STUDENT` table where the `STUID` matches `rec.STUID` and the `AGE` column is greater than `30`, and `v_counter` is incremented by `3`. Else if `v_distance` is greater than `50` (but not greater than `100`), a new row is inserted into the `STUDENT` table with `STUID` as `rec.STUID + 1000`, `LNAME` as 'New', `FNAME` as 'Student', `AGE` as `25`, `SEX` as 'M', `MAJOR` as `500`, `ADVISOR` as `1000`, and `CITY_CODE` as `v_city1_code`, and `v_counter` is incremented by `4`. Otherwise (if `v_distance` is `50` or less), the sum of the `AGE` column from the `STUDENT` table is selected into `v_total_age` for all students where `CITY_CODE` matches `v_city1_code`, and `v_counter` is incremented by `5`. The loop continues until all records from `cur_students` have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_process_student_distances IS\n   CURSOR cur_students IS SELECT STUID, CITY_CODE FROM STUDENT;\n   v_city1_code VARCHAR2(255);\n   v_city2_code VARCHAR2(255);\n   v_distance NUMBER;\n   v_counter NUMBER := 0;\n   v_total_age NUMBER := 0;\nBEGIN\n   FOR rec IN cur_students LOOP\n      SELECT CITY_CODE INTO v_city1_code FROM STUDENT WHERE STUID = rec.STUID;\n      SELECT CITY_CODE INTO v_city2_code FROM CITY WHERE STATE = 'MD' AND ROWNUM = 1;\n      SELECT DISTANCE INTO v_distance FROM DIRECT_DISTANCE WHERE CITY1_CODE = v_city1_code AND CITY2_CODE = v_city2_code;\n      IF v_distance > 500 THEN\n         UPDATE STUDENT SET MAJOR = MAJOR + 100 WHERE STUID = rec.STUID;\n         v_counter := v_counter + 1;\n      ELSIF v_distance > 200 THEN\n         UPDATE STUDENT SET ADVISOR = ADVISOR - 50 WHERE STUID = rec.STUID;\n         v_counter := v_counter + 2;\n      ELSIF v_distance > 100 THEN\n         DELETE FROM STUDENT WHERE STUID = rec.STUID AND AGE > 30;\n         v_counter := v_counter + 3;\n      ELSIF v_distance > 50 THEN\n         INSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, SEX, MAJOR, ADVISOR, CITY_CODE) VALUES (rec.STUID + 1000, 'New', 'Student', 25, 'M', 500, 1000, v_city1_code);\n         v_counter := v_counter + 4;\n      ELSE\n         SELECT SUM(AGE) INTO v_total_age FROM STUDENT WHERE CITY_CODE = v_city1_code;\n         v_counter := v_counter + 5;\n      END IF;\n   END LOOP;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_process_student_distances;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_process_student_distances` with no parameters. For each student, get their city code and a city code from Maryland. Find the distance between these cities. Based on the distance, perform different operations: if >500, update the student's MAJOR by adding 100; if >200, update ADVISOR by subtracting 50; if >100, delete the student if age >30; if >50, insert a new student record; otherwise, calculate the total age of students in that city. Maintain a counter that increments by different values (1,2,3,4,5) for each condition.",
    "natural_language": "Please construct a stored procedure designated as `sp_process_student_distances` that accepts no parameters. The procedure shall execute the following logic for each student record: retrieve the student's city code and a separate city code from the state of Maryland. Compute the geographical distance between these two cities. Subsequently, based on the calculated distance, execute distinct operations as follows: if the distance exceeds 500, increment the student's MAJOR field by 100; if the distance exceeds 200, decrement the ADVISOR field by 50; if the distance exceeds 100, remove the student record provided the student's age is greater than 30; if the distance exceeds 50, insert a new student record. For distances not meeting the preceding thresholds, compute the aggregate sum of ages for all students residing in the student's city. Furthermore, maintain a counter variable that is incremented by values of 1, 2, 3, 4, and 5 corresponding to each conditional branch, respectively.",
    "id": 26
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_analyze_city_relationships` that does not accept any input parameters. This procedure declares five local variables: `v_state_count` of type `NUMBER`, `v_city_count` of type `NUMBER`, `v_avg_distance` of type `NUMBER`, `v_max_age` of type `NUMBER`, and `v_min_age` of type `NUMBER`. The procedure begins by performing a series of `SELECT` statements to populate these variables. First, it calculates the count of distinct values in the `STATE` column from the `CITY` table and stores this count in `v_state_count`. Next, it counts all rows in the `CITY` table and stores this total in `v_city_count`. Subsequently, it computes the average value of the `DISTANCE` column from the `DIRECT_DISTANCE` table and assigns this average to `v_avg_distance`. Following this, it finds the maximum value of the `AGE` column from the `STUDENT` table and stores it in `v_max_age`. Finally, it determines the minimum value of the `AGE` column from the `STUDENT` table and assigns this minimum to `v_min_age`.\n\nAfter initializing these variables, the procedure proceeds with a series of conditional `IF-ELSIF-ELSE` statements based primarily on the value of `v_state_count`.\n\nThe first condition checks if `v_state_count` is greater than 5.\nIf this condition is true, the procedure executes an `UPDATE` statement on the `STUDENT` table. It sets the `MAJOR` column to the ceiling of its current value multiplied by 1.1 (i.e., `CEIL(MAJOR * 1.1)`) for all rows where the `AGE` column is greater than `v_max_age` minus 5.\n\nIf the first condition is false, the procedure then checks if `v_state_count` is greater than 3.\nIf this second condition is true, the procedure performs a `DELETE` operation on the `STUDENT` table. It removes all rows where the `AGE` column is less than `v_min_age` plus 2 AND the `SEX` column is equal to the string literal 'M'.\n\nIf the second condition is also false, the procedure proceeds to check if `v_state_count` is greater than 1.\nIf this third condition is true, the procedure executes an `INSERT` statement into the `STUDENT` table. It inserts a new row with the following values: `STUID` as 9998, `LNAME` as 'State', `FNAME` as 'Analyzer', `AGE` as 35, `SEX` as 'F', `MAJOR` as 700, `ADVISOR` as 8000, and `CITY_CODE` as 'BAL'.\n\nIf the third condition is false, the procedure then checks if `v_state_count` is greater than 0.\nIf this fourth condition is true, the procedure performs an `UPDATE` operation on the `CITY` table. It sets the `CITY_NAME` column to its current value with leading and trailing spaces removed (using the `TRIM` function) concatenated with the string literal '_UPD' (i.e., `TRIM(CITY_NAME) || '_UPD'`) for all rows where the `STATE` column is equal to the string literal 'PA'.\n\nIf the fourth condition is false, the procedure then checks if `v_city_count` is greater than 10.\nIf this fifth condition is true, the procedure executes a `DELETE` statement on the `DIRECT_DISTANCE` table. It removes all rows where the `DISTANCE` column is less than the value stored in `v_avg_distance`.\n\nIf all the preceding `IF` and `ELSIF` conditions are false, the procedure executes the `ELSE` block.\nIn the `ELSE` block, the procedure performs an `INSERT` statement into the `DIRECT_DISTANCE` table. It inserts a new row with `CITY1_CODE` as 'TEST', `CITY2_CODE` as 'TEST2', and `DISTANCE` as the value of `v_avg_distance` rounded to the nearest whole number (using the `ROUND` function).",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_analyze_city_relationships IS\n   v_state_count NUMBER;\n   v_city_count NUMBER;\n   v_avg_distance NUMBER;\n   v_max_age NUMBER;\n   v_min_age NUMBER;\n   v_result NUMBER;\nBEGIN\n   SELECT COUNT(DISTINCT STATE) INTO v_state_count FROM CITY;\n   SELECT COUNT(*) INTO v_city_count FROM CITY;\n   SELECT AVG(DISTANCE) INTO v_avg_distance FROM DIRECT_DISTANCE;\n   SELECT MAX(AGE) INTO v_max_age FROM STUDENT;\n   SELECT MIN(AGE) INTO v_min_age FROM STUDENT;\n   IF v_state_count > 5 THEN\n      UPDATE STUDENT SET MAJOR = CEIL(MAJOR * 1.1) WHERE AGE > v_max_age - 5;\n   ELSIF v_state_count > 3 THEN\n      DELETE FROM STUDENT WHERE AGE < v_min_age + 2 AND SEX = 'M';\n   ELSIF v_state_count > 1 THEN\n      INSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, SEX, MAJOR, ADVISOR, CITY_CODE) VALUES (9998, 'State', 'Analyzer', 35, 'F', 700, 8000, 'BAL');\n   ELSIF v_state_count > 0 THEN\n      UPDATE CITY SET CITY_NAME = TRIM(CITY_NAME) || '_UPD' WHERE STATE = 'PA';\n   ELSIF v_city_count > 10 THEN\n      DELETE FROM DIRECT_DISTANCE WHERE DISTANCE < v_avg_distance;\n   ELSE\n      INSERT INTO DIRECT_DISTANCE (CITY1_CODE, CITY2_CODE, DISTANCE) VALUES ('TEST', 'TEST2', ROUND(v_avg_distance));\n   END IF;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_analyze_city_relationships;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_analyze_city_relationships` with no parameters. Calculate and store the count of distinct states, total cities, average distance, and max/min student age. Based primarily on the state count, perform conditional operations: if >5, update student MAJOR for older students; if >3, delete young male students; if >1, insert a new student; if >0, update city names for state 'PA'; else if city count >10, delete distances below average; otherwise, insert a test distance record.",
    "natural_language": "Construct a stored procedure, which should be named `sp_analyze_city_relationships`, that accepts no input parameters. This procedure must meticulously compute and then persistently store several key metrics: the distinct number of states, the comprehensive total of all cities, the calculated average distance, and finally the maximum and minimum ages found among the student population. The subsequent logic should be driven principally by the count of distinct states, leading to a series of conditional operations. If this state count is determined to be greater than five, then proceed to update the MAJOR field for those students who are considered older. Should the count instead be greater than three, the operation must delete records for young male students. In the event the count is greater than one, the procedure is to insert a brand new student record. If the count is simply greater than zero, it should trigger an update to city names specifically for the state abbreviated as 'PA'. Alternatively, if none of the previous state-based conditions are met, then evaluate the total city count; if this count exceeds ten, delete all distance records that fall below the previously computed average distance. As a final default action, if no other condition applies, insert a single test record into the distance table.",
    "id": 27
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_consolidate_student_data that takes no parameters and processes each city record from the CITY table by iterating through a cursor named cur_cities that selects the CITY_CODE and STATE columns. For each city record, it performs four separate queries on the STUDENT table: it counts the number of students into variable v_student_count where the STUDENT.CITY_CODE matches the current city's CITY_CODE; it calculates the sum of the ADVISOR column into variable v_advisor_sum for those students; it calculates the average of the MAJOR column into variable v_major_avg; and it calculates the sum of the AGE column into variable v_age_total. Based on the value of v_student_count, it executes one of several conditional branches: if the count is greater than 20, it updates the STUDENT table, setting the ADVISOR column to the calculated average (v_advisor_sum divided by v_student_count) for students in that city where the AGE column is greater than 25; if the count is greater than 15 but not greater than 20, it deletes from the STUDENT table any student records for that city where the MAJOR column value is less than the calculated average v_major_avg; if the count is greater than 10 but not greater than 15, it first selects a single CITY_CODE into variable v_new_city from the CITY table where the STATE matches the current city's state and ROWNUM equals 1, then inserts a new record into the STUDENT table with STUID set to 9000 plus the current city's CITY_CODE, LNAME set to 'Consolidated', FNAME set to 'Student', AGE set to the rounded average age (v_age_total divided by v_student_count), SEX set to 'F', MAJOR set to the rounded average major v_major_avg, ADVISOR set to 9999, and CITY_CODE set to the selected v_new_city; if the count is greater than 5 but not greater than 10, it updates the CITY table, incrementing the LATITUDE column by 0.1 and decrementing the LONGITUDE column by 0.1 for the record matching the current city's CITY_CODE; if the count is greater than 0 but not greater than 5, it deletes from the DIRECT_DISTANCE table any rows where either CITY1_CODE or CITY2_CODE equals the current city's CITY_CODE; if the count is 0, it inserts a new record into the CITY table with CITY_CODE set to the concatenation of the current city's CITY_CODE and the string '_NEW', CITY_NAME set to 'Generated', STATE set to the current city's STATE, COUNTRY set to 'USA', and LATITUDE and LONGITUDE both set to 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_consolidate_student_data IS\n   CURSOR cur_cities IS SELECT CITY_CODE, STATE FROM CITY;\n   v_student_count NUMBER;\n   v_advisor_sum NUMBER;\n   v_major_avg NUMBER;\n   v_age_total NUMBER;\n   v_new_city VARCHAR2(255);\nBEGIN\n   FOR rec IN cur_cities LOOP\n      SELECT COUNT(*) INTO v_student_count FROM STUDENT WHERE CITY_CODE = rec.CITY_CODE;\n      SELECT SUM(ADVISOR) INTO v_advisor_sum FROM STUDENT WHERE CITY_CODE = rec.CITY_CODE;\n      SELECT AVG(MAJOR) INTO v_major_avg FROM STUDENT WHERE CITY_CODE = rec.CITY_CODE;\n      SELECT SUM(AGE) INTO v_age_total FROM STUDENT WHERE CITY_CODE = rec.CITY_CODE;\n      IF v_student_count > 20 THEN\n         UPDATE STUDENT SET ADVISOR = v_advisor_sum / v_student_count WHERE CITY_CODE = rec.CITY_CODE AND AGE > 25;\n      ELSIF v_student_count > 15 THEN\n         DELETE FROM STUDENT WHERE CITY_CODE = rec.CITY_CODE AND MAJOR < v_major_avg;\n      ELSIF v_student_count > 10 THEN\n         SELECT CITY_CODE INTO v_new_city FROM CITY WHERE STATE = rec.STATE AND ROWNUM = 1;\n         INSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, SEX, MAJOR, ADVISOR, CITY_CODE) VALUES (9000 + rec.CITY_CODE, 'Consolidated', 'Student', ROUND(v_age_total/v_student_count), 'F', ROUND(v_major_avg), 9999, v_new_city);\n      ELSIF v_student_count > 5 THEN\n         UPDATE CITY SET LATITUDE = LATITUDE + 0.1, LONGITUDE = LONGITUDE - 0.1 WHERE CITY_CODE = rec.CITY_CODE;\n      ELSIF v_student_count > 0 THEN\n         DELETE FROM DIRECT_DISTANCE WHERE CITY1_CODE = rec.CITY_CODE OR CITY2_CODE = rec.CITY_CODE;\n      ELSE\n         INSERT INTO CITY (CITY_CODE, CITY_NAME, STATE, COUNTRY, LATITUDE, LONGITUDE) VALUES (rec.CITY_CODE || '_NEW', 'Generated', rec.STATE, 'USA', 0, 0);\n      END IF;\n   END LOOP;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_consolidate_student_data;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_consolidate_student_data` with no parameters. For each city, count its students and calculate sums/averages of their ADVISOR, MAJOR, and AGE. Based on the student count, perform conditional operations: if >20, update ADVISOR for older students; if >15, delete students with MAJOR below average; if >10, insert a new student in a city from the same state; if >5, update the city's coordinates; if >0, delete related distances; if 0, insert a new city record.",
    "natural_language": "Create procedure sp_consolidate_student_data. For each city: count students, sum/avg ADVISOR, MAJOR, AGE. If count >20, update ADVISOR for older students. If >15, delete students with low MAJOR. If >10, insert new student in same-state city. If >5, update city coordinates. If >0, delete distances. If 0, insert city.",
    "id": 28
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named fn_update_leader_name that accepts three parameters: p_club_id of type NUMBER, p_new_name of type VARCHAR2, and p_old_name of type OUT VARCHAR2. The procedure begins by executing a SELECT statement to retrieve the current value of the TEAM_LEADER column from the CLUB table where the CLUB_ID column matches the value of the p_club_id parameter. The retrieved TEAM_LEADER value is then stored in the p_old_name OUT parameter. Following this, the procedure performs an UPDATE operation on the CLUB table, setting the TEAM_LEADER column to the value of the p_new_name parameter for the row where the CLUB_ID column equals the p_club_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE fn_update_leader_name(p_club_id NUMBER, p_new_name VARCHAR2, p_old_name OUT VARCHAR2) IS\nBEGIN\n    SELECT TEAM_LEADER INTO p_old_name FROM CLUB WHERE CLUB_ID = p_club_id;\n    UPDATE CLUB SET TEAM_LEADER = p_new_name WHERE CLUB_ID = p_club_id;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_name VARCHAR2(255);\nBEGIN\n  fn_update_leader_name(1, 'New Leader 1', v_old_name);\n  DBMS_OUTPUT.PUT_LINE('Old Leader Name: ' || v_old_name);\nEND;",
      "DECLARE\n  v_old_name VARCHAR2(255);\nBEGIN\n  fn_update_leader_name(3, 'New Leader 2', v_old_name);\n  DBMS_OUTPUT.PUT_LINE('Old Leader Name: ' || v_old_name);\nEND;",
      "DECLARE\n  v_old_name VARCHAR2(255);\nBEGIN\n  fn_update_leader_name(4, 'New Leader 3', v_old_name);\n  DBMS_OUTPUT.PUT_LINE('Old Leader Name: ' || v_old_name);\nEND;",
      "DECLARE\n  v_old_name VARCHAR2(255);\nBEGIN\n  fn_update_leader_name(1, 'Updated Leader A', v_old_name);\n  DBMS_OUTPUT.PUT_LINE('Old Leader Name: ' || v_old_name);\nEND;",
      "DECLARE\n  v_old_name VARCHAR2(255);\nBEGIN\n  fn_update_leader_name(3, 'Updated Leader B', v_old_name);\n  DBMS_OUTPUT.PUT_LINE('Old Leader Name: ' || v_old_name);\nEND;"
    ],
    "summary": "Create a stored procedure named `fn_update_leader_name` with parameters for club ID and new leader name, and an OUT parameter for the old leader name. Retrieve the current team leader for the given club ID into the OUT parameter, then update the club's team leader to the new name.",
    "natural_language": "Create procedure `fn_update_leader_name` with club ID and new leader name inputs, and an old leader name output. Fetch current leader into output, then update with new name.",
    "id": 29
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AddNewCourse that accepts five parameters: p_course_id of type NUMBER, p_starting_date of type VARCHAR2, p_course_name of type VARCHAR2, p_teacher_id of type NUMBER, and p_grade of type NUMBER. The procedure performs two main operations using the MERGE statement. First, it attempts to insert a new record into the COURSE table with the columns COURSE_ID, STARING_DATE, and COURSE, using the values provided by the parameters p_course_id, p_starting_date, and p_course_name, respectively. This insertion occurs only if there is no existing record in the COURSE table with a matching COURSE_ID. The MERGE statement uses a subquery from the DUAL table to provide the necessary values for the insertion. Second, the procedure attempts to insert a new record into the COURSE_ARRANGE table with the columns COURSE_ID, TEACHER_ID, and GRADE, using the values provided by the parameters p_course_id, p_teacher_id, and p_grade, respectively. This insertion occurs only if there is no existing record in the COURSE_ARRANGE table with matching COURSE_ID, TEACHER_ID, and GRADE values. Similar to the first operation, the MERGE statement uses a subquery from the DUAL table to provide the necessary values for the insertion. The procedure does not perform any updates, deletes, or selects, and it does not include any conditional statements beyond the matching conditions specified in the MERGE operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE AddNewCourse(\n    p_course_id IN NUMBER,\n    p_starting_date IN VARCHAR2,\n    p_course_name IN VARCHAR2,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER\n) AS\nBEGIN\n    -- Handle insertion into COURSE table\n    MERGE INTO COURSE c\n    USING (SELECT p_course_id AS course_id, p_starting_date AS starting_date, p_course_name AS course_name FROM DUAL) d\n    ON (c.COURSE_ID = d.course_id)\n    WHEN NOT MATCHED THEN\n        INSERT (COURSE_ID, STARING_DATE, COURSE)\n        VALUES (d.course_id, d.starting_date, d.course_name);\n    \n    -- Handle insertion into COURSE_ARRANGE table\n    MERGE INTO COURSE_ARRANGE ca\n    USING (SELECT p_course_id AS course_id, p_teacher_id AS teacher_id, p_grade AS grade FROM DUAL) d\n    ON (ca.COURSE_ID = d.course_id AND ca.TEACHER_ID = d.teacher_id AND ca.GRADE = d.grade)\n    WHEN NOT MATCHED THEN\n        INSERT (COURSE_ID, TEACHER_ID, GRADE)\n        VALUES (d.course_id, d.teacher_id, d.grade);\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  AddNewCourse(4, '8 May', 'History', 1, 4);\nEND;",
      "BEGIN\n  AddNewCourse(5, '9 May', 'Art', 2, 2);\nEND;",
      "BEGIN\n  AddNewCourse(6, '10 May', 'Music', 3, 1);\nEND;",
      "BEGIN\n  AddNewCourse(1, '5 May', 'Language Arts', 1, 3);\nEND;",
      "BEGIN\n  AddNewCourse(2, '6 May', 'Math', 5, 3);\nEND;"
    ],
    "summary": "Create a stored procedure named `AddNewCourse` with parameters for course ID, start date, course name, teacher ID, and grade. Use MERGE statements to insert a new course record if the ID doesn't exist, and to insert a new course arrangement record if the combination of course ID, teacher ID, and grade doesn't exist.",
    "natural_language": "Develop a stored procedure, to be named `AddNewCourse`, which must accept specific input parameters including a unique course identifier, the scheduled commencement date, the full title of the course, the assigned educator's identification number, and the associated academic grade level. This procedure should intelligently utilize MERGE operations to first insert a brand-new course entry into the database, but only under the condition that the provided course ID is not already present. Subsequently, it must employ another MERGE statement to carefully insert a fresh course arrangement record, specifically targeting the unique combination of the course ID, the teacher ID, and the grade, ensuring this particular arrangement does not already exist in the system.",
    "id": 30
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AssignTeacherToCourse that accepts four parameters: p_course_id of type NUMBER representing the unique identifier for a course, p_teacher_id of type NUMBER representing the unique identifier for a teacher, p_grade of type NUMBER indicating the grade level associated with the course, and p_course_name of type VARCHAR2 representing the name of the course. The procedure begins by declaring two local variables, v_course_exists and v_arrange_exists, both of type NUMBER, initialized to 0, to track the existence of records in the COURSE and COURSE_ARRANGE tables, respectively. The procedure first checks if a course arrangement already exists by executing a SELECT COUNT(*) query on the COURSE_ARRANGE table, filtering records where COURSE_ID matches p_course_id, TEACHER_ID matches p_teacher_id, and GRADE matches p_grade, and stores the result in v_arrange_exists. If v_arrange_exists equals 0, indicating no existing arrangement, it inserts a new record into the COURSE_ARRANGE table with the values of p_course_id, p_teacher_id, and p_grade for the columns COURSE_ID, TEACHER_ID, and GRADE, respectively. Next, the procedure checks if the course already exists by executing a SELECT COUNT(*) query on the COURSE table, filtering records where COURSE_ID matches p_course_id, and stores the result in v_course_exists. If v_course_exists equals 0, indicating no existing course, it inserts a new record into the COURSE table with the values of p_course_id, the current timestamp formatted as 'DD-MON-YYYY' for the STARING_DATE column, and p_course_name for the COURSE column.",
    "plsql": "CREATE OR REPLACE PROCEDURE AssignTeacherToCourse(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER,\n    p_course_name IN VARCHAR2\n) AS\n    v_course_exists NUMBER := 0;\n    v_arrange_exists NUMBER := 0;\nBEGIN\n    -- Check if course arrangement already exists\n    SELECT COUNT(*)\n    INTO v_arrange_exists\n    FROM COURSE_ARRANGE\n    WHERE COURSE_ID = p_course_id \n      AND TEACHER_ID = p_teacher_id \n      AND GRADE = p_grade;\n    \n    -- Insert into COURSE_ARRANGE only if it doesn't exist\n    IF v_arrange_exists = 0 THEN\n        INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE)\n        VALUES (p_course_id, p_teacher_id, p_grade);\n    END IF;\n    \n    -- Check if course already exists\n    SELECT COUNT(*)\n    INTO v_course_exists\n    FROM COURSE\n    WHERE COURSE_ID = p_course_id;\n    \n    -- Insert into COURSE only if it doesn't exist\n    IF v_course_exists = 0 THEN\n        INSERT INTO COURSE (COURSE_ID, STARING_DATE, COURSE)\n        VALUES (p_course_id, TO_CHAR(CURRENT_TIMESTAMP, 'DD-MON-YYYY'), p_course_name);\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  AssignTeacherToCourse(1, 1, 3, 'Language Arts');\n  commit;\nEND;",
      "BEGIN\n  AssignTeacherToCourse(2, 2, 1, 'Math');\n  commit;\nEND;",
      "BEGIN\n  AssignTeacherToCourse(3, 3, 5, 'Science');\n  commit;\nEND;",
      "BEGIN\n  AssignTeacherToCourse(1, 3, 1, 'Language Arts');\n  commit;\nEND;",
      "BEGIN\n  AssignTeacherToCourse(2, 1, 5, 'Math');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named AssignTeacherToCourse that takes a course ID, teacher ID, grade, and course name. First, check if the course arrangement (course ID, teacher ID, grade) already exists in the COURSE_ARRANGE table. If not, insert it. Then, check if the course ID exists in the COURSE table. If not, insert a new course record with the provided ID and name, setting the starting date to the current date in 'DD-MON-YYYY' format.",
    "natural_language": "Write a stored procedure called AssignTeacherToCourse that accepts a course ID, a teacher ID, a grade, and a course name. First, verify whether the combination of course ID, teacher ID, and grade is already present in the COURSE_ARRANGE table; if it is not, add it. Next, check if the course ID exists in the COURSE table; if it does not, insert a new record using the provided ID and name, and set the starting date to today's date formatted as 'DD-MON-YYYY'.",
    "id": 31
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateCourseDate that accepts four input parameters: a numeric parameter p_course_id representing a course identifier, a string parameter p_new_date representing a new date, a numeric parameter p_teacher_id representing a teacher identifier, and a numeric parameter p_grade representing a grade level. The procedure first executes a DELETE operation on the COURSE_ARRANGE table, removing any rows where the COURSE_ID column matches p_course_id, the TEACHER_ID column matches p_teacher_id, and the GRADE column matches p_grade. Following the deletion, the procedure performs an UPDATE operation on the COURSE table, setting the STARING_DATE column to the value of p_new_date and the COURSE column to the literal string 'Updated Course' for the row where the COURSE_ID column equals p_course_id. After the update, the procedure checks the SQL%ROWCOUNT attribute; if its value is zero, indicating no rows were updated in the COURSE table, the procedure raises an application error with error code -20001 and the message 'Course ID does not exist.'",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCourseDate(\n    p_course_id IN NUMBER,\n    p_new_date IN VARCHAR2,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER\n) AS\nBEGIN\n    DELETE FROM COURSE_ARRANGE\n    WHERE COURSE_ID = p_course_id AND TEACHER_ID = p_teacher_id AND GRADE = p_grade;\n    \n    UPDATE COURSE\n    SET STARING_DATE = p_new_date, COURSE = 'Updated Course'\n    WHERE COURSE_ID = p_course_id;\n    \n    IF SQL%ROWCOUNT = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Course ID does not exist.');\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCourseDate(1, '10 May', 3, 3);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(2, '11 May', 5, 1);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(3, '12 May', 2, 5);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(1, '13 May', 2, 3);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(2, '14 May', 3, 5);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateCourseDate that takes a course ID, a new date, a teacher ID, and a grade. First, delete the corresponding arrangement from the COURSE_ARRANGE table using the course ID, teacher ID, and grade. Then, update the COURSE table for that course ID, setting the starting date to the new date and the course name to 'Updated Course'. If no course was updated, raise an application error 'Course ID does not exist.'",
    "natural_language": "How can I create a stored procedure called UpdateCourseDate that accepts a course ID, a new date, a teacher ID, and a grade? The procedure should first remove the matching record from the COURSE_ARRANGE table using the provided course ID, teacher ID, and grade. Then, it should update the COURSE table for that course ID by setting the starting date to the new date and the course name to 'Updated Course'. What should happen if no course is updated? An application error with the message 'Course ID does not exist.' should be raised.",
    "id": 32
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named RemoveTeacherFromCourse that accepts four parameters: p_course_id of type NUMBER representing the unique identifier of a course, p_teacher_id of type NUMBER representing the unique identifier of a teacher, p_grade of type NUMBER indicating the grade level associated with the course, and p_course_name of type VARCHAR2 representing the name of the course. The procedure begins by checking the existence of a course with the given p_course_id in the COURSE table by counting the number of rows that match this COURSE_ID and storing the result in the variable v_course_exists. It then proceeds to delete any records from the COURSE_ARRANGE table where the COURSE_ID matches p_course_id, the TEACHER_ID matches p_teacher_id, and the GRADE matches p_grade, effectively removing the teacher from the course arrangement. Following this, the procedure checks if the course exists by evaluating if v_course_exists is greater than zero. If the course exists, it updates the COURSE table by setting the COURSE column to the value of p_course_name and the STARING_DATE column to the current timestamp formatted as 'DD-MON-YYYY' for the row where COURSE_ID matches p_course_id. If the course does not exist, it inserts a new row into the COURSE table with COURSE_ID set to p_course_id, STARING_DATE set to the current timestamp formatted as 'DD-MON-YYYY', and COURSE set to p_course_name. The procedure includes an exception handler for the DUP_VAL_ON_INDEX exception, which occurs when a unique constraint violation is detected during an insert operation. In such cases, it performs an update on the COURSE table, setting the COURSE column to p_course_name and the STARING_DATE column to the current timestamp formatted as 'DD-MON-YYYY' for the row where COURSE_ID matches p_course_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE RemoveTeacherFromCourse(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER,\n    p_course_name IN VARCHAR2\n) AS\n    v_course_exists NUMBER;\nBEGIN\n    -- Check if the course exists\n    SELECT COUNT(*) INTO v_course_exists\n    FROM COURSE\n    WHERE COURSE_ID = p_course_id;\n    \n    -- Remove teacher from course arrangement\n    DELETE FROM COURSE_ARRANGE\n    WHERE COURSE_ID = p_course_id \n      AND TEACHER_ID = p_teacher_id \n      AND GRADE = p_grade;\n    \n    -- Update course name if course exists, otherwise insert new course\n    IF v_course_exists > 0 THEN\n        UPDATE COURSE\n        SET COURSE = p_course_name,\n            STARING_DATE = TO_CHAR(CURRENT_TIMESTAMP, 'DD-MON-YYYY')\n        WHERE COURSE_ID = p_course_id;\n    ELSE\n        INSERT INTO COURSE (COURSE_ID, STARING_DATE, COURSE)\n        VALUES (p_course_id, TO_CHAR(CURRENT_TIMESTAMP, 'DD-MON-YYYY'), p_course_name);\n    END IF;\n    \nEXCEPTION\n    WHEN DUP_VAL_ON_INDEX THEN\n        -- Handle unique constraint violation by updating instead\n        UPDATE COURSE\n        SET COURSE = p_course_name,\n            STARING_DATE = TO_CHAR(CURRENT_TIMESTAMP, 'DD-MON-YYYY')\n        WHERE COURSE_ID = p_course_id;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  RemoveTeacherFromCourse(2, 3, 3, 'Language Arts');\n  commit;\nEND;",
      "BEGIN\n  RemoveTeacherFromCourse(3, 5, 1, 'Math');\n  commit;\nEND;",
      "BEGIN\n  RemoveTeacherFromCourse(1, 2, 5, 'Science');\n  commit;\nEND;",
      "BEGIN\n  RemoveTeacherFromCourse(2, 5, 3, 'Math');\n  commit;\nEND;",
      "BEGIN\n  RemoveTeacherFromCourse(3, 2, 1, 'Language Arts');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named RemoveTeacherFromCourse that takes a course ID, teacher ID, grade, and course name. First, check if the course exists. Then, delete the teacher's arrangement from the COURSE_ARRANGE table. If the course existed, update its name and set the starting date to the current date. If the course did not exist, insert a new course record with the provided details. Handle duplicate key violations during insert by updating the existing course record instead.",
    "natural_language": "Write a stored procedure called RemoveTeacherFromCourse that accepts a course ID, teacher ID, grade, and course name. First, verify the existence of the course. Next, remove the teacher's arrangement from the COURSE_ARRANGE table. If the course was found, update its name and set the starting date to today's date. If the course was not found, insert a new course record with the given details. During the insert, handle any duplicate key violations by updating the existing course record.",
    "id": 33
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AddTeacherAndCourse that accepts four input parameters: a numeric parameter p_teacher_id, a string parameter p_teacher_name, a numeric parameter p_course_id, and a string parameter p_course_name. The procedure first attempts to insert a new row into the TEACHER table using the p_teacher_id and p_teacher_name parameters, while also providing a static value of '30' for the AGE column and a static value of 'Unknown' for the HOMETOWN column; if this insertion fails due to a duplicate value on a unique or primary key constraint (DUP_VAL_ON_INDEX), the procedure instead updates the existing TEACHER table row identified by the p_teacher_id parameter, setting its NAME column to the value of the p_teacher_name parameter. The procedure then attempts to insert a new row into the COURSE table using the p_course_id and p_course_name parameters, while also generating a value for the STARING_DATE column by converting the current system timestamp to a string in the 'DD-MON-YYYY' format using the TO_CHAR and CURRENT_TIMESTAMP functions; if this insertion fails due to a duplicate value on a unique or primary key constraint (DUP_VAL_ON_INDEX), the procedure instead updates the existing COURSE table row identified by the p_course_id parameter, setting its COURSE column to the value of the p_course_name parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE AddTeacherAndCourse(\n    p_teacher_id IN NUMBER,\n    p_teacher_name IN VARCHAR2,\n    p_course_id IN NUMBER,\n    p_course_name IN VARCHAR2\n) AS\nBEGIN\n    BEGIN\n        INSERT INTO TEACHER (TEACHER_ID, NAME, AGE, HOMETOWN)\n        VALUES (p_teacher_id, p_teacher_name, '30', 'Unknown');\n    EXCEPTION\n        WHEN DUP_VAL_ON_INDEX THEN\n            UPDATE TEACHER\n            SET NAME = p_teacher_name\n            WHERE TEACHER_ID = p_teacher_id;\n    END;\n\n    BEGIN\n        INSERT INTO COURSE (COURSE_ID, STARING_DATE, COURSE)\n        VALUES (p_course_id, TO_CHAR(CURRENT_TIMESTAMP, 'DD-MON-YYYY'), p_course_name);\n    EXCEPTION\n        WHEN DUP_VAL_ON_INDEX THEN\n            UPDATE COURSE\n            SET COURSE = p_course_name\n            WHERE COURSE_ID = p_course_id;\n    END;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  AddTeacherAndCourse(4, 'John Doe', 4, 'History');\n  commit;\nEND;",
      "BEGIN\n  AddTeacherAndCourse(5, 'Jane Smith', 5, 'Geography');\n  commit;\nEND;",
      "BEGIN\n  AddTeacherAndCourse(6, 'Emily Johnson', 6, 'Physics');\n  commit;\nEND;",
      "BEGIN\n  AddTeacherAndCourse(7, 'Michael Brown', 7, 'Chemistry');\n  commit;\nEND;",
      "BEGIN\n  AddTeacherAndCourse(8, 'Sarah Davis', 8, 'Biology');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named AddTeacherAndCourse that takes a teacher ID, teacher name, course ID, and course name. For the teacher, insert a new record with the given ID and name, setting age to 30 and hometown to 'Unknown'. If a duplicate key exists, update the teacher's name. For the course, insert a new record with the given ID and name, setting the starting date to the current date. If a duplicate key exists, update the course's name.",
    "natural_language": "Write a stored procedure called AddTeacherAndCourse that accepts a teacher ID, teacher name, course ID, and course name. Insert a new teacher record using the provided ID and name, setting age to 30 and hometown to 'Unknown'. If the teacher ID already exists, update the teacher's name instead. Then, insert a new course record using the given ID and name, setting the starting date to today's date. If the course ID already exists, update the course's name.",
    "id": 34
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that deletes rows from the ORDERS table where the CUSTOMER_ID column matches the input parameter p_customer_id of type NUMBER and the DATE_ORDER_PLACED column is earlier than the input parameter p_cutoff_date of type VARCHAR2.",
    "plsql": "CREATE OR REPLACE PROCEDURE RemoveOldOrders(p_customer_id IN NUMBER, p_cutoff_date IN VARCHAR2) AS\nBEGIN\n  DELETE FROM ORDERS\n  WHERE CUSTOMER_ID = p_customer_id\n  AND DATE_ORDER_PLACED < p_cutoff_date;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "FINANCIAL_TRANSACTIONS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  RemoveOldOrders(12, '2015-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  RemoveOldOrders(8, '2018-06-01');\n  COMMIT;\nEND;",
      "BEGIN\n  RemoveOldOrders(1, '2020-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  RemoveOldOrders(5, '2010-12-31');\n  COMMIT;\nEND;",
      "BEGIN\n  RemoveOldOrders(7, '2022-07-15');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure that deletes orders from the ORDERS table for a specific customer ID where the order date is earlier than a provided cutoff date.",
    "natural_language": "Please construct a stored procedure to remove records from the ORDERS table. The procedure should accept a specific customer identifier and a cutoff date as parameters, and it must delete only those orders placed by the specified customer that have an order date prior to the provided cutoff.",
    "id": 35
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes two input parameters, p_order_id and p_product_id, both of type NUMBER, and performs the following operations: First, it calculates a new order item ID by selecting the maximum value of the ORDER_ITEM_ID column from the ORDER_ITEMS table, using the NVL function to handle nulls by defaulting to 0 if no rows exist, and then adds 1 to this maximum value to generate the next sequential order item ID, storing this result in a local variable v_order_item_id of type NUMBER. Next, it inserts a new row into the ORDER_ITEMS table with the following values: the newly calculated v_order_item_id for the ORDER_ITEM_ID column, the input parameter p_order_id for the ORDER_ID column, the input parameter p_product_id for the PRODUCT_ID column, a constant string '1' for the PRODUCT_QUANTITY column, and a NULL value for the OTHER_ORDER_ITEM_DETAILS column.",
    "plsql": "CREATE OR REPLACE PROCEDURE AddOrderItem(p_order_id IN NUMBER, p_product_id IN NUMBER) AS\n  v_order_item_id NUMBER;\nBEGIN\n  SELECT NVL(MAX(ORDER_ITEM_ID), 0) + 1\n    INTO v_order_item_id\n    FROM ORDER_ITEMS;\n    \n  INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, PRODUCT_QUANTITY, OTHER_ORDER_ITEM_DETAILS)\n  VALUES (v_order_item_id, p_order_id, p_product_id, '1', NULL);\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "FINANCIAL_TRANSACTIONS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  AddOrderItem(1, 4);\n  commit;\nEND;",
      "BEGIN\n  AddOrderItem(2, 10);\n  commit;\nEND;",
      "BEGIN\n  AddOrderItem(3, 5);\n  commit;\nEND;",
      "BEGIN\n  AddOrderItem(1, 5);\n  commit;\nEND;",
      "BEGIN\n  AddOrderItem(2, 4);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure that inserts a new order item. It takes an order ID and a product ID as numbers. It calculates the next order item ID by finding the maximum existing ID (defaulting to 0 if none) and adding 1. It then inserts a new row into ORDER_ITEMS with the new ID, the provided order and product IDs, a quantity of '1', and NULL for other details.",
    "natural_language": "Hey, can you whip up a stored procedure to add a new item to an order? It needs two number inputs: one for the order ID and one for the product ID. First, it's gotta figure out the next ID for the order item by grabbing the highest one already in there (or start at 0 if there's nothing) and then bumping it up by one. After that, just pop a new row into the ORDER_ITEMS table with that fresh ID, the order and product IDs we got, set the quantity to '1', and leave the other stuff as NULL.",
    "id": 36
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_complaint_assignments that accepts six parameters: p_complaint_type, p_status_filter, p_product_category, p_customer_type, p_staff_gender, and p_output. The first five parameters are input parameters of type VARCHAR2, and the last one, p_output, is an output parameter of type CLOB. The procedure begins by declaring four local variables of type NUMBER to store counts related to complaints, products, customers, and staff, and a CLOB variable to store JSON results. It then performs a series of SELECT COUNT(*) operations to determine the number of complaints with a specific complaint type code, the number of products with a specific product category code, the number of customers with a specific customer type code, and the number of staff with a specific gender. Based on these counts, the procedure executes different operations: if the complaint count exceeds 10, it constructs a JSON object containing complaint IDs for the specified complaint type and assigns it to p_output; if the product count exceeds 5, it inserts three new complaint records into the COMPLAINTS table with specific values for complaint outcome, status, type, and staff ID, and sets p_output to indicate complaints were created for products; if the customer count exceeds 3, it updates the COMPLAINTS table to set the complaint status code to the provided status filter for complaints associated with the specified customer type, and sets p_output to indicate customer complaints were updated; if the staff count exceeds 2, it deletes closed complaints from the COMPLAINTS table for staff members of the specified gender, and sets p_output to indicate closed complaints were deleted for staff; otherwise, it increases the price of products in the PRODUCTS table by 10% for the specified product category and sets p_output to indicate product prices were increased.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_complaint_assignments(\n    p_complaint_type IN VARCHAR2,\n    p_status_filter IN VARCHAR2,\n    p_product_category IN VARCHAR2,\n    p_customer_type IN VARCHAR2,\n    p_staff_gender IN VARCHAR2,\n    p_output OUT CLOB\n) IS\n    v_complaint_count NUMBER;\n    v_product_count NUMBER;\n    v_customer_count NUMBER;\n    v_staff_count NUMBER;\n    v_json_result CLOB;\nBEGIN\n    SELECT COUNT(*) INTO v_complaint_count FROM COMPLAINTS WHERE COMPLAINT_TYPE_CODE = p_complaint_type;\n    SELECT COUNT(*) INTO v_product_count FROM PRODUCTS WHERE PRODUCT_CATEGORY_CODE = p_product_category;\n    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMERS WHERE CUSTOMER_TYPE_CODE = p_customer_type;\n    SELECT COUNT(*) INTO v_staff_count FROM STAFF WHERE GENDER = p_staff_gender;\n    \n    IF v_complaint_count > 10 THEN\n        SELECT JSON_OBJECTAGG('complaint_id' VALUE c.COMPLAINT_ID RETURNING CLOB)\n        INTO v_json_result\n        FROM COMPLAINTS c\n        WHERE c.COMPLAINT_TYPE_CODE = p_complaint_type;\n        p_output := v_json_result;\n    ELSIF v_product_count > 5 THEN\n        INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_OUTCOME_CODE, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, STAFF_ID)\n        SELECT ROWNUM + 1000, p.PRODUCT_ID, c.CUSTOMER_ID, 'PENDING', 'New', p_complaint_type, s.STAFF_ID\n        FROM PRODUCTS p, CUSTOMERS c, STAFF s\n        WHERE p.PRODUCT_CATEGORY_CODE = p_product_category\n        AND c.CUSTOMER_TYPE_CODE = p_customer_type\n        AND s.GENDER = p_staff_gender\n        AND ROWNUM <= 3;\n        p_output := 'Complaints created for products';\n    ELSIF v_customer_count > 3 THEN\n        UPDATE COMPLAINTS \n        SET COMPLAINT_STATUS_CODE = p_status_filter\n        WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM CUSTOMERS WHERE CUSTOMER_TYPE_CODE = p_customer_type);\n        p_output := 'Customer complaints updated';\n    ELSIF v_staff_count > 2 THEN\n        DELETE FROM COMPLAINTS \n        WHERE STAFF_ID IN (SELECT STAFF_ID FROM STAFF WHERE GENDER = p_staff_gender)\n        AND COMPLAINT_STATUS_CODE = 'Closed';\n        p_output := 'Closed complaints deleted for staff';\n    ELSE\n        UPDATE PRODUCTS \n        SET PRODUCT_PRICE = PRODUCT_PRICE * 1.1\n        WHERE PRODUCT_CATEGORY_CODE = p_product_category;\n        p_output := 'Product prices increased';\n    END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Failure',\n        p_status_filter => 'Resolved',\n        p_product_category => 'Food',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '1',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Unusable',\n        p_status_filter => 'Pending',\n        p_product_category => 'Book',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '0',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Failure',\n        p_status_filter => 'New',\n        p_product_category => 'Hardware',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '1',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Unusable',\n        p_status_filter => 'Closed',\n        p_product_category => 'Food',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '0',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Failure',\n        p_status_filter => 'In Progress',\n        p_product_category => 'Book',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '1',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;"
    ],
    "summary": "Create a stored procedure named process_complaint_assignments. It takes five VARCHAR2 input parameters (complaint type, status filter, product category, customer type, staff gender) and one CLOB output parameter. It counts complaints, products, customers, and staff based on the input parameters. Based on these counts, it performs different actions: if complaint count > 10, output a JSON of complaint IDs; if product count > 5, insert three new complaints and output a message; if customer count > 3, update complaint statuses and output a message; if staff count > 2, delete closed complaints and output a message; otherwise, increase product prices by 10% and output a message.",
    "natural_language": "Hey, so I need you to whip up a stored procedure called 'process_complaint_assignments'. It's gotta take in five VARCHAR2 inputsthink stuff like the type of complaint, a status filter, product category, what kind of customer, and the staff's genderand spit out one CLOB. What it does is count up complaints, products, customers, and staff based on those inputs you give it. Then, depending on what those counts are, it does different things: if there are more than 10 complaints, it should give back a JSON list of the complaint IDs. If we've got over 5 products, it'll add three new complaint records and tell us it's done. If there are more than 3 customers, it updates the statuses on some complaints and lets us know. If there are more than 2 staff members, it cleans out the old, closed complaints and shoots us a message. And if none of those hit, just bump up all the product prices by 10% and send a confirmation.",
    "id": 37
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named analyze_complaint_metrics that accepts six parameters: an input string parameter p_date_threshold representing a date, an input string parameter p_outcome_code, an input string parameter p_type_code, an input string parameter p_gender_filter, an input number parameter p_analysis_type, and an output CLOB parameter p_metrics_json. The procedure begins by declaring and populating several variables with counts from database tables: v_recent_complaints is set to the count of rows from the COMPLAINTS table where the DATE_COMPLAINT_RAISED column, converted from a string to a date using the format 'YYYY-MM-DD HH24:MI:SS', is greater than the p_date_threshold parameter converted to a date with the same format; v_outcome_complaints is set to the count from COMPLAINTS where the COMPLAINT_OUTCOME_CODE column equals p_outcome_code; v_type_complaints is set to the count from COMPLAINTS where the COMPLAINT_TYPE_CODE column equals p_type_code; v_gender_staff is set to the count from the STAFF table where the GENDER column equals p_gender_filter; and v_product_complaints is set to the count of distinct PRODUCT_ID values from the COMPLAINTS table. The core logic is determined by the p_analysis_type parameter: if p_analysis_type equals 1, the procedure constructs a JSON object string in p_metrics_json by querying the STAFF table for STAFF_ID and a concatenated full name (FIRST_NAME || ' ' || LAST_NAME) for all staff where GENDER equals p_gender_filter, ordered by STAFF_ID, and formats each result as a key-value pair where the staff ID is the key and the full name is the value. If p_analysis_type equals 2, the procedure deletes rows from the PRODUCTS table where the PRODUCT_ID is not found in the set of distinct non-null PRODUCT_ID values from the COMPLAINTS table and the PRODUCT_PRICE is less than 10, then sets p_metrics_json to '{\"operation\": \"unused_products_deleted\"}'. If p_analysis_type equals 3, the procedure updates the COMPLAINTS table, setting the COMPLAINT_OUTCOME_CODE to p_outcome_code and the DATE_COMPLAINT_CLOSED to the current system date formatted as 'YYYY-MM-DD HH24:MI:SS', for rows where the COMPLAINT_STATUS_CODE is 'New' and the DATE_COMPLAINT_RAISED (converted to a date) is earlier than the p_date_threshold (converted to a date), then sets p_metrics_json to '{\"operation\": \"old_complaints_closed\"}'. If p_analysis_type equals 4, the procedure inserts new rows into the STAFF table, generating a STAFF_ID as 4000 plus a row number, using p_gender_filter for GENDER, constructing FIRST_NAME as 'Staff' concatenated with row number, LAST_NAME as 'Member' concatenated with row number, EMAIL_ADDRESS as 'staff' concatenated with row number and '@company.com', and PHONE_NUMBER as '800-' concatenated with a row number left-padded with zeros to four digits, with the number of rows inserted calculated as the greater of 1 or v_type_complaints divided by 10, then sets p_metrics_json to '{\"operation\": \"staff_members_added\"}'. If p_analysis_type equals 5, the procedure updates the CUSTOMERS table, setting ADDRESS_LINE_2 to 'Suite ' concatenated with the remainder of CUSTOMER_ID divided by 100, and PHONE_NUMBER to '1-800-' concatenated with the CUSTOMER_ID left-padded with zeros to six digits, for customers whose CUSTOMER_ID is in the set of distinct CUSTOMER_ID values from the COMPLAINTS table where COMPLAINT_TYPE_CODE equals p_type_code, then sets p_metrics_json to '{\"operation\": \"customer_info_updated\"}'. For any other value of p_analysis_type (the ELSE case), the procedure deletes rows from the COMPLAINTS table where COMPLAINT_OUTCOME_CODE equals p_outcome_code, COMPLAINT_STATUS_CODE is 'Closed', and the DATE_COMPLAINT_CLOSED (converted to a date) is earlier than the p_date_threshold (converted to a date), then sets p_metrics_json to '{\"operation\": \"archived_complaints_purged\"}'.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_complaint_metrics(\n    p_date_threshold IN VARCHAR2,\n    p_outcome_code IN VARCHAR2,\n    p_type_code IN VARCHAR2,\n    p_gender_filter IN VARCHAR2,\n    p_analysis_type IN NUMBER,\n    p_metrics_json OUT CLOB\n) IS\n    v_recent_complaints NUMBER;\n    v_outcome_complaints NUMBER;\n    v_type_complaints NUMBER;\n    v_gender_staff NUMBER;\n    v_product_complaints NUMBER;\n    v_json_string VARCHAR2(4000);\n    v_first BOOLEAN := TRUE;\nBEGIN\n    SELECT COUNT(*) INTO v_recent_complaints FROM COMPLAINTS WHERE TO_DATE(DATE_COMPLAINT_RAISED, 'YYYY-MM-DD HH24:MI:SS') > TO_DATE(p_date_threshold, 'YYYY-MM-DD HH24:MI:SS');\n    SELECT COUNT(*) INTO v_outcome_complaints FROM COMPLAINTS WHERE COMPLAINT_OUTCOME_CODE = p_outcome_code;\n    SELECT COUNT(*) INTO v_type_complaints FROM COMPLAINTS WHERE COMPLAINT_TYPE_CODE = p_type_code;\n    SELECT COUNT(*) INTO v_gender_staff FROM STAFF WHERE GENDER = p_gender_filter;\n    SELECT COUNT(DISTINCT PRODUCT_ID) INTO v_product_complaints FROM COMPLAINTS;\n    \n    IF p_analysis_type = 1 THEN\n        v_json_string := '{';\n        FOR rec IN (SELECT s.STAFF_ID, s.FIRST_NAME || ' ' || s.LAST_NAME AS full_name\n                    FROM STAFF s\n                    WHERE s.GENDER = p_gender_filter\n                    ORDER BY s.STAFF_ID)\n        LOOP\n            IF NOT v_first THEN\n                v_json_string := v_json_string || ',';\n            END IF;\n            v_json_string := v_json_string || '\"' || rec.STAFF_ID || '\":\"' || rec.full_name || '\"';\n            v_first := FALSE;\n        END LOOP;\n        v_json_string := v_json_string || '}';\n        p_metrics_json := v_json_string;\n    ELSIF p_analysis_type = 2 THEN\n        DELETE FROM PRODUCTS \n        WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM COMPLAINTS WHERE PRODUCT_ID IS NOT NULL)\n        AND PRODUCT_PRICE < 10;\n        p_metrics_json := '{\"operation\": \"unused_products_deleted\"}';\n    ELSIF p_analysis_type = 3 THEN\n        UPDATE COMPLAINTS \n        SET COMPLAINT_OUTCOME_CODE = p_outcome_code,\n            DATE_COMPLAINT_CLOSED = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE COMPLAINT_STATUS_CODE = 'New'\n        AND TO_DATE(DATE_COMPLAINT_RAISED, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(p_date_threshold, 'YYYY-MM-DD HH24:MI:SS');\n        p_metrics_json := '{\"operation\": \"old_complaints_closed\"}';\n    ELSIF p_analysis_type = 4 THEN\n        INSERT INTO STAFF (STAFF_ID, GENDER, FIRST_NAME, LAST_NAME, EMAIL_ADDRESS, PHONE_NUMBER)\n        SELECT ROWNUM + 4000, p_gender_filter, 'Staff' || ROWNUM, 'Member' || ROWNUM, 'staff' || ROWNUM || '@company.com', '800-' || LPAD(ROWNUM, 4, '0')\n        FROM DUAL\n        CONNECT BY ROWNUM <= GREATEST(1, v_type_complaints / 10);\n        p_metrics_json := '{\"operation\": \"staff_members_added\"}';\n    ELSIF p_analysis_type = 5 THEN\n        UPDATE CUSTOMERS \n        SET ADDRESS_LINE_2 = 'Suite ' || MOD(CUSTOMER_ID, 100),\n            PHONE_NUMBER = '1-800-' || LPAD(CUSTOMER_ID, 6, '0')\n        WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM COMPLAINTS WHERE COMPLAINT_TYPE_CODE = p_type_code);\n        p_metrics_json := '{\"operation\": \"customer_info_updated\"}';\n    ELSE\n        DELETE FROM COMPLAINTS \n        WHERE COMPLAINT_OUTCOME_CODE = p_outcome_code\n        AND COMPLAINT_STATUS_CODE = 'Closed'\n        AND TO_DATE(DATE_COMPLAINT_CLOSED, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(p_date_threshold, 'YYYY-MM-DD HH24:MI:SS');\n        p_metrics_json := '{\"operation\": \"archived_complaints_purged\"}';\n    END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n  v_metrics CLOB;\nBEGIN\n  analyze_complaint_metrics(\n    p_date_threshold => '2000-01-01 00:00:00',\n    p_outcome_code => 'OK',\n    p_type_code => 'Product Failure',\n    p_gender_filter => '1',\n    p_analysis_type => 1,\n    p_metrics_json => v_metrics\n  );\n  DBMS_OUTPUT.PUT_LINE(v_metrics);\nEND;",
      "DECLARE\n  v_metrics CLOB;\nBEGIN\n  analyze_complaint_metrics(\n    p_date_threshold => '2010-01-01 00:00:00',\n    p_outcome_code => 'Pending',\n    p_type_code => 'Product Unusable',\n    p_gender_filter => '0',\n    p_analysis_type => 2,\n    p_metrics_json => v_metrics\n  );\n  DBMS_OUTPUT.PUT_LINE(v_metrics);\nEND;",
      "DECLARE\n  v_metrics CLOB;\nBEGIN\n  analyze_complaint_metrics(\n    p_date_threshold => '2005-06-15 12:00:00',\n    p_outcome_code => 'Resolved',\n    p_type_code => 'Service Issue',\n    p_gender_filter => '1',\n    p_analysis_type => 3,\n    p_metrics_json => v_metrics\n  );\n  DBMS_OUTPUT.PUT_LINE(v_metrics);\nEND;",
      "DECLARE\n  v_metrics CLOB;\nBEGIN\n  analyze_complaint_metrics(\n    p_date_threshold => '2015-03-20 08:30:00',\n    p_outcome_code => 'Rejected',\n    p_type_code => 'Product Failure',\n    p_gender_filter => '0',\n    p_analysis_type => 4,\n    p_metrics_json => v_metrics\n  );\n  DBMS_OUTPUT.PUT_LINE(v_metrics);\nEND;",
      "DECLARE\n  v_metrics CLOB;\nBEGIN\n  analyze_complaint_metrics(\n    p_date_threshold => '2008-11-01 14:00:00',\n    p_outcome_code => 'OK',\n    p_type_code => 'Product Unusable',\n    p_gender_filter => '1',\n    p_analysis_type => 5,\n    p_metrics_json => v_metrics\n  );\n  DBMS_OUTPUT.PUT_LINE(v_metrics);\nEND;"
    ],
    "summary": "Create a stored procedure named analyze_complaint_metrics. It takes a date threshold, an outcome code, a type code, a gender filter, an analysis type number, and a CLOB output parameter for JSON. It calculates several counts from the database. Based on the analysis type parameter, it performs different operations: type 1 outputs a JSON of staff names; type 2 deletes unused cheap products; type 3 closes old 'New' complaints; type 4 inserts new staff members; type 5 updates customer information for those with specific complaints; otherwise, it purges archived complaints. Each operation sets a specific JSON output message.",
    "natural_language": "Alright, so we need a stored procedure called 'analyze_complaint_metrics'. It's gonna take in a few things: a cutoff date, an outcome code, a type code, a gender to filter by, a number that tells it what kind of analysis to run, and a CLOB parameter to spit out a JSON message. Basically, it crunches some numbers from the database to get various counts. Then, depending on that analysis type number, it does different stuff: if it's type 1, it gives back a JSON list of staff names. Type 2, it gets rid of cheap products nobody's using. Type 3, it closes out old complaints that are still marked as 'New'. Type 4, it adds some new staff members. Type 5, it updates info for customers who had certain complaints. If the number doesn't match any of those, it just cleans out old archived complaints. Each of these jobs will set a specific JSON message in that output parameter to say what went down.",
    "id": 38
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_data_relationships that accepts six parameters: p_consolidation_level of type NUMBER, p_target_category of type VARCHAR2, p_target_state of type VARCHAR2, p_threshold_value of type NUMBER, p_processing_flag of type VARCHAR2, and p_consolidation_summary of type OUT CLOB. The procedure begins by declaring several local variables: v_category_volume, v_state_density, v_complaint_intensity, v_staff_efficiency, and v_consolidation_score of type NUMBER, and v_summary_json of type CLOB. It then performs a series of SELECT statements to populate these variables: v_category_volume is set to the count of rows in the PRODUCTS table where PRODUCT_CATEGORY_CODE matches p_target_category; v_state_density is set to the count of rows in the CUSTOMERS table where STATE matches p_target_state; v_complaint_intensity is set to the count of rows in the COMPLAINTS table where COMPLAINT_STATUS_CODE is not 'Closed'; v_staff_efficiency is set to the count of distinct STAFF_IDs in the COMPLAINTS table where STAFF_ID is not null. The procedure calculates v_consolidation_score as the sum of v_category_volume and v_state_density divided by the greater of 1 or v_complaint_intensity. Based on the value of p_consolidation_level, the procedure executes different operations: if p_consolidation_level is 1, it aggregates product category codes and their counts into a JSON object stored in v_summary_json, which is then assigned to p_consolidation_summary; if p_consolidation_level is 2, it updates the PRODUCTS table to set PARENT_PRODUCT_ID based on PRODUCT_PRICE and assigns a JSON string indicating product hierarchy establishment to p_consolidation_summary; if p_consolidation_level is 3, it deletes rows from the COMPLAINTS table where COMPLAINT_STATUS_CODE is 'Closed', CUSTOMER_ID is in the CUSTOMERS table with matching STATE, and COMPLAINT_ID is less than p_threshold_value, then assigns a JSON string indicating historical complaints archived to p_consolidation_summary; if p_consolidation_level is 4, it inserts new rows into the CUSTOMERS table with generated values based on v_consolidation_score and assigns a JSON string indicating consolidated customers created to p_consolidation_summary; if p_consolidation_level is 5, it updates the STAFF table to set EMAIL_ADDRESS and PHONE_NUMBER for STAFF_IDs involved in complaints with a type code matching p_processing_flag, then assigns a JSON string indicating staff contacts consolidated to p_consolidation_summary; otherwise, it updates the COMPLAINTS table to set COMPLAINT_OUTCOME_CODE to 'CONSOLIDATED' and assigns STAFF_ID based on a calculation involving v_staff_efficiency for rows where COMPLAINT_STATUS_CODE is 'New' and PRODUCT_ID is in the PRODUCTS table with matching PRODUCT_CATEGORY_CODE, then assigns a JSON string indicating complaint assignments balanced to p_consolidation_summary.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_data_relationships(\n    p_consolidation_level IN NUMBER,\n    p_target_category IN VARCHAR2,\n    p_target_state IN VARCHAR2,\n    p_threshold_value IN NUMBER,\n    p_processing_flag IN VARCHAR2,\n    p_consolidation_summary OUT CLOB\n) IS\n    v_category_volume NUMBER;\n    v_state_density NUMBER;\n    v_complaint_intensity NUMBER;\n    v_staff_efficiency NUMBER;\n    v_consolidation_score NUMBER;\n    v_summary_json CLOB;\nBEGIN\n    SELECT COUNT(*) INTO v_category_volume FROM PRODUCTS WHERE PRODUCT_CATEGORY_CODE = p_target_category;\n    SELECT COUNT(*) INTO v_state_density FROM CUSTOMERS WHERE STATE = p_target_state;\n    SELECT COUNT(*) INTO v_complaint_intensity FROM COMPLAINTS WHERE COMPLAINT_STATUS_CODE != 'Closed';\n    SELECT COUNT(DISTINCT STAFF_ID) INTO v_staff_efficiency FROM COMPLAINTS WHERE STAFF_ID IS NOT NULL;\n    v_consolidation_score := (v_category_volume + v_state_density) / GREATEST(1, v_complaint_intensity);\n    \n    IF p_consolidation_level = 1 THEN\n        SELECT JSON_OBJECTAGG(PRODUCT_CATEGORY_CODE VALUE COUNT(*) RETURNING CLOB)\n        INTO v_summary_json\n        FROM PRODUCTS\n        GROUP BY PRODUCT_CATEGORY_CODE;\n        p_consolidation_summary := v_summary_json;\n    ELSIF p_consolidation_level = 2 THEN\n        UPDATE PRODUCTS \n        SET PARENT_PRODUCT_ID = CASE \n            WHEN PRODUCT_PRICE > p_threshold_value THEN PRODUCT_ID - 1000\n            ELSE PRODUCT_ID - 2000\n        END\n        WHERE PRODUCT_CATEGORY_CODE = p_target_category\n        AND PARENT_PRODUCT_ID IS NULL;\n        p_consolidation_summary := '{\"operation\": \"product_hierarchy_established\"}';\n    ELSIF p_consolidation_level = 3 THEN\n        DELETE FROM COMPLAINTS \n        WHERE COMPLAINT_STATUS_CODE = 'Closed'\n        AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM CUSTOMERS WHERE STATE = p_target_state)\n        AND COMPLAINT_ID < p_threshold_value;\n        p_consolidation_summary := '{\"operation\": \"historical_complaints_archived\"}';\n    ELSIF p_consolidation_level = 4 THEN\n        INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER)\n        SELECT ROWNUM + 7000, 'Consolidated Customer', 'Consolidated Address', 'Metro Area', p_target_state, 'consolidated' || ROWNUM || '@domain.com', '900-' || LPAD(ROWNUM, 4, '0')\n        FROM DUAL\n        CONNECT BY ROWNUM <= FLOOR(v_consolidation_score);\n        p_consolidation_summary := '{\"operation\": \"consolidated_customers_created\"}';\n    ELSIF p_consolidation_level = 5 THEN\n        UPDATE STAFF \n        SET EMAIL_ADDRESS = STAFF_ID || '@consolidated.company.com',\n            PHONE_NUMBER = '1-900-CONSOL-' || LPAD(STAFF_ID, 3, '0')\n        WHERE STAFF_ID IN (SELECT DISTINCT STAFF_ID FROM COMPLAINTS WHERE COMPLAINT_TYPE_CODE = p_processing_flag);\n        p_consolidation_summary := '{\"operation\": \"staff_contacts_consolidated\"}';\n    ELSE\n        UPDATE COMPLAINTS \n        SET COMPLAINT_OUTCOME_CODE = 'CONSOLIDATED',\n            STAFF_ID = MOD(COMPLAINT_ID, v_staff_efficiency) + 115\n        WHERE COMPLAINT_STATUS_CODE = 'New'\n        AND PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCTS WHERE PRODUCT_CATEGORY_CODE = p_target_category);\n        p_consolidation_summary := '{\"operation\": \"complaint_assignments_balanced\"}';\n    END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n    v_summary CLOB;\nBEGIN\n    consolidate_data_relationships(1, 'Food', 'Kansas', 100, 'Product Failure', v_summary);\n    DBMS_OUTPUT.PUT_LINE(v_summary);\nEND;",
      "DECLARE\n    v_summary CLOB;\nBEGIN\n    consolidate_data_relationships(2, 'Hardware', 'Tennessee', 50, 'Product Unusable', v_summary);\n    DBMS_OUTPUT.PUT_LINE(v_summary);\n    COMMIT;\nEND;",
      "DECLARE\n    v_summary CLOB;\nBEGIN\n    consolidate_data_relationships(3, 'Book', 'Hawaii', 500, 'Product Failure', v_summary);\n    DBMS_OUTPUT.PUT_LINE(v_summary);\n    COMMIT;\nEND;",
      "DECLARE\n    v_summary CLOB;\nBEGIN\n    consolidate_data_relationships(4, 'Food', 'Kansas', 75, 'Product Unusable', v_summary);\n    DBMS_OUTPUT.PUT_LINE(v_summary);\n    COMMIT;\nEND;",
      "DECLARE\n    v_summary CLOB;\nBEGIN\n    consolidate_data_relationships(5, 'Hardware', 'Tennessee', 200, 'Product Failure', v_summary);\n    DBMS_OUTPUT.PUT_LINE(v_summary);\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named consolidate_data_relationships. It takes a consolidation level number, target category, target state, threshold value, processing flag, and an output CLOB summary. It calculates metrics for product volume, customer density, open complaints, and staff efficiency. Based on the consolidation level, it performs different actions: level 1 aggregates product categories into JSON; level 2 establishes a product hierarchy; level 3 archives historical complaints; level 4 creates consolidated customers; level 5 updates staff contact details; otherwise, it balances complaint assignments by updating outcomes and staff IDs. Each action sets a specific JSON summary.",
    "natural_language": "What does the stored procedure named 'consolidate_data_relationships' do, and what parameters does it require? How does it calculate metrics for product volume, customer density, open complaints, and staff efficiency? What specific actions are performed at each consolidation level, from 1 to 5, and what happens for any other level? What type of summary does each action generate?",
    "id": 39
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_update_department` that accepts two input parameters: `p_department_id` of data type `NUMBER`, which represents the unique identifier for a department, and `p_budget_limit` of data type `NUMBER`, which represents a monetary threshold for the department's budget. The procedure performs a `DELETE` operation on the `DEPARTMENT` table. This `DELETE` operation targets rows in the `DEPARTMENT` table where two conditions are simultaneously met: first, the value in the `DEPARTMENT_ID` column of the `DEPARTMENT` table must be equal to the value provided in the `p_department_id` input parameter, and second, the value in the `BUDGET_IN_BILLIONS` column of the `DEPARTMENT` table must be strictly less than the value provided in the `p_budget_limit` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_department(p_department_id NUMBER, p_budget_limit NUMBER) IS\nBEGIN\n  DELETE FROM DEPARTMENT WHERE DEPARTMENT_ID = p_department_id AND BUDGET_IN_BILLIONS < p_budget_limit;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_department(1, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(2, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(3, 500);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(1, 15);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(2, 12);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_department that deletes a department. It takes a department ID and a budget limit as numbers. It deletes rows from the DEPARTMENT table where the DEPARTMENT_ID matches the input ID AND the BUDGET_IN_BILLIONS is less than the input budget limit.",
    "natural_language": "Delete a department by creating a stored procedure named sp_update_department. The procedure must accept a department ID and a budget limit as numbers. It should remove rows from the DEPARTMENT table where the DEPARTMENT_ID equals the provided ID and the BUDGET_IN_BILLIONS is below the given budget limit.",
    "id": 40
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_adjust_head_age that accepts two input parameters: a numeric parameter p_age_limit and a numeric parameter p_head_id, and executes a DELETE operation on the database table named HEAD, specifically removing any and all rows from that table where the value in the column HEAD_ID is exactly equal to the provided parameter p_head_id and, simultaneously, the value in the column AGE is strictly greater than the provided parameter p_age_limit.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_adjust_head_age(p_age_limit NUMBER, p_head_id NUMBER) IS\nBEGIN\n  DELETE FROM HEAD WHERE HEAD_ID = p_head_id AND AGE > p_age_limit;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_adjust_head_age(p_age_limit => 65, p_head_id => 1);\nEND;",
      "BEGIN\n  sp_adjust_head_age(p_age_limit => 70, p_head_id => 2);\nEND;",
      "BEGIN\n  sp_adjust_head_age(p_age_limit => 60, p_head_id => 3);\nEND;",
      "BEGIN\n  sp_adjust_head_age(p_age_limit => 100, p_head_id => 1);\nEND;",
      "BEGIN\n  sp_adjust_head_age(p_age_limit => 50, p_head_id => 2);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_adjust_head_age that deletes rows from the HEAD table where HEAD_ID equals the input p_head_id and AGE is greater than the input p_age_limit.",
    "natural_language": "Please construct a stored procedure designated as sp_adjust_head_age. This procedure shall execute the deletion of records from the HEAD table, specifically targeting those rows where the HEAD_ID column matches the provided input parameter p_head_id and where the AGE column exceeds the value supplied by the input parameter p_age_limit.",
    "id": 41
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_remove_management that accepts two parameters: p_department_id of type NUMBER and p_head_id of type NUMBER. The procedure performs a DELETE operation on the MANAGEMENT table, specifically targeting rows where the DEPARTMENT_ID column matches the value of p_department_id and the HEAD_ID column matches the value of p_head_id. The procedure does not include any conditional statements, function calls, or special operations beyond the DELETE statement, and it directly removes the specified records from the MANAGEMENT table based on the provided parameter values.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_remove_management(p_department_id NUMBER, p_head_id NUMBER) IS\nBEGIN\n  DELETE FROM MANAGEMENT WHERE DEPARTMENT_ID = p_department_id AND HEAD_ID = p_head_id;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_remove_management(2, 5);\nEND;",
      "BEGIN\n  sp_remove_management(15, 4);\nEND;",
      "BEGIN\n  sp_remove_management(1, 1);\nEND;",
      "BEGIN\n  sp_remove_management(3, 6);\nEND;",
      "BEGIN\n  sp_remove_management(10, 2);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_remove_management that deletes rows from the MANAGEMENT table where DEPARTMENT_ID equals the input p_department_id and HEAD_ID equals the input p_head_id.",
    "natural_language": "Please construct a stored procedure designated as sp_remove_management. This procedure shall delete records from the MANAGEMENT table for which the DEPARTMENT_ID column matches the provided parameter p_department_id and the HEAD_ID column matches the provided parameter p_head_id.",
    "id": 42
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_department_ranking that accepts two input parameters: a numeric parameter named p_ranking_limit and a numeric parameter named p_department_id, and executes a DELETE operation on the DEPARTMENT table, specifically targeting and removing rows where the DEPARTMENT_ID column value is exactly equal to the provided p_department_id parameter and, simultaneously, the RANKING column value is less than the provided p_ranking_limit parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_department_ranking(p_ranking_limit NUMBER, p_department_id NUMBER) IS\nBEGIN\n  DELETE FROM DEPARTMENT WHERE DEPARTMENT_ID = p_department_id AND RANKING < p_ranking_limit;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 2, p_department_id => 1);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 3, p_department_id => 2);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 1, p_department_id => 3);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 5, p_department_id => 1);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 0, p_department_id => 2);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_department_ranking that deletes rows from the DEPARTMENT table where DEPARTMENT_ID equals the input p_department_id and RANKING is less than the input p_ranking_limit.",
    "natural_language": "Hey, can you whip up a stored procedure called sp_update_department_ranking? It should clean out any rows from the DEPARTMENT table where the DEPARTMENT_ID matches the given p_department_id and the RANKING is lower than the p_ranking_limit we provide.",
    "id": 43
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_remove_old_heads` that accepts two input parameters: `p_age_limit` of data type `NUMBER` and `p_head_id` of data type `NUMBER`. The purpose of this procedure is to perform a data manipulation operation, specifically a `DELETE` statement, on the `HEAD` table. The `DELETE` operation targets rows within the `HEAD` table where two conditions are simultaneously met: first, the value in the `HEAD_ID` column of a given row must be equal to the value provided in the `p_head_id` input parameter; and second, the value in the `AGE` column of the same row must be strictly less than the value provided in the `p_age_limit` input parameter. The procedure does not return any value and its execution flow is straightforward, consisting solely of this single `DELETE` statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_remove_old_heads(p_age_limit NUMBER, p_head_id NUMBER) IS\nBEGIN\n  DELETE FROM HEAD WHERE HEAD_ID = p_head_id AND AGE < p_age_limit;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_remove_old_heads(70, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_old_heads(65, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_old_heads(80, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_old_heads(60, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_old_heads(75, 5);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_remove_old_heads that deletes rows from the HEAD table where HEAD_ID equals the input p_head_id and AGE is less than the input p_age_limit.",
    "natural_language": "Delete HEAD rows where HEAD_ID matches p_head_id and AGE is below p_age_limit via sp_remove_old_heads.",
    "id": 44
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that updates the COURSE_DESCRIPTION column in the COURSES table to a new specified value, using the parameters p_course_id, p_new_description, and p_author_id. The procedure takes three parameters: p_course_id of type NUMBER, which specifies the unique identifier of the course to be updated; p_new_description of type VARCHAR2, which provides the new description text to be set for the course; and p_author_id of type NUMBER, which identifies the author of the course. The procedure performs an UPDATE operation on the COURSES table, setting the COURSE_DESCRIPTION column to the value of p_new_description for the row where the COURSE_ID column matches the value of p_course_id and the AUTHOR_ID column matches the value of p_author_id. There are no conditional statements or function calls involved in this procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_course_description(p_course_id NUMBER, p_new_description VARCHAR2, p_author_id NUMBER) IS\nBEGIN\n  UPDATE COURSES SET COURSE_DESCRIPTION = p_new_description WHERE COURSE_ID = p_course_id AND AUTHOR_ID = p_author_id;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_course_description(1, 'Introduction to Databases', 8);\n  commit;\nEND;",
      "BEGIN\n  sp_update_course_description(2, 'Advanced Database Concepts', 6);\n  commit;\nEND;",
      "BEGIN\n  sp_update_course_description(3, 'Operating Systems Overview', 15);\n  commit;\nEND;",
      "BEGIN\n  sp_update_course_description(1, 'Database Fundamentals', 8);\n  commit;\nEND;",
      "BEGIN\n  sp_update_course_description(2, 'Database Management Systems', 6);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure that updates the COURSE_DESCRIPTION in the COURSES table to a new value (p_new_description) where COURSE_ID equals p_course_id and AUTHOR_ID equals p_author_id.",
    "natural_language": "Please construct a stored procedure to modify the COURSE_DESCRIPTION field within the COURSES table. The procedure shall assign the new value provided by the parameter `p_new_description`. This update is to be executed conditionally, applying only to those records where the COURSE_ID matches the parameter `p_course_id` and the AUTHOR_ID matches the parameter `p_author_id`.",
    "id": 45
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_insert_student_test that accepts three parameters: p_student_id of type NUMBER, p_date_test_taken of type VARCHAR2, and p_test_result of type VARCHAR2. The procedure begins by declaring a local variable v_registration_id of type NUMBER. It then executes a SELECT statement to retrieve the REGISTRATION_ID from the STUDENT_COURSE_ENROLMENT table where the STUDENT_ID column matches the value of the p_student_id parameter. The SELECT statement includes a condition to limit the result to the first row by using ROWNUM = 1. The retrieved REGISTRATION_ID is stored in the v_registration_id variable. Following this, the procedure performs an INSERT operation into the STUDENT_TESTS_TAKEN table, inserting a new row with the values of v_registration_id, p_date_test_taken, and p_test_result into the REGISTRATION_ID, DATE_TEST_TAKEN, and TEST_RESULT columns, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_insert_student_test(p_student_id NUMBER, p_date_test_taken VARCHAR2, p_test_result VARCHAR2) IS\n  v_registration_id NUMBER;\nBEGIN\n  SELECT REGISTRATION_ID INTO v_registration_id FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND ROWNUM = 1;\n  INSERT INTO STUDENT_TESTS_TAKEN (REGISTRATION_ID, DATE_TEST_TAKEN, TEST_RESULT) VALUES (v_registration_id, p_date_test_taken, p_test_result);\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_insert_student_test(11, '2024-01-15 10:30:00', 'Pass');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_student_test(15, '2024-01-16 14:45:00', 'Fail');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_student_test(10, '2024-01-17 09:15:00', 'Pass');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_student_test(11, '2024-01-18 16:20:00', 'Pass');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_student_test(15, '2024-01-19 11:00:00', 'Pass');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_insert_student_test that inserts a test record. It takes a student ID, test date, and result as input. It first retrieves the student's registration ID from the enrolment table and then inserts a new row into the student tests table with the retrieved registration ID and the provided test details.",
    "natural_language": "Create procedure sp_insert_student_test to add a test. Input: student ID, test date, result. Get the student's registration ID from enrolment, then insert into student tests.",
    "id": 46
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ManageChampionships` that does not accept any input parameters. This procedure iterates through each record in the `CHAMPIONSHIP` table. For each record, it retrieves the `INSTITUTION_ID` and `NUMBER_OF_CHAMPIONSHIPS` column values. Inside the loop, it evaluates the `NUMBER_OF_CHAMPIONSHIPS` value for the current record. If the `NUMBER_OF_CHAMPIONSHIPS` is strictly less than 5, the procedure executes an `UPDATE` statement on the `CHAMPIONSHIP` table, incrementing the `NUMBER_OF_CHAMPIONSHIPS` column by 1 for the row where the `INSTITUTION_ID` matches the `INSTITUTION_ID` of the current record being processed in the loop. If the `NUMBER_OF_CHAMPIONSHIPS` is not less than 5 but is instead between 5 and 10 (inclusive of both 5 and 10), the procedure executes a `DELETE` statement from the `CHAMPIONSHIP` table. This deletion targets rows where the `INSTITUTION_ID` matches the `INSTITUTION_ID` of the current record and where the `NUMBER_OF_CHAMPIONSHIPS` of the current record is an even number, as determined by the `MOD` function returning 0 when dividing `NUMBER_OF_CHAMPIONSHIPS` by 2. If neither of the previous conditions is met (meaning `NUMBER_OF_CHAMPIONSHIPS` is greater than 10), the procedure executes an `INSERT` statement into the `CHAMPIONSHIP` table. This `INSERT` statement creates a new record with the `INSTITUTION_ID` set to the `INSTITUTION_ID` of the current record, the `NICKNAME` column set to the literal string 'New Nickname', the `JOINED` column set to the integer value 2023, and the `NUMBER_OF_CHAMPIONSHIPS` column set to the integer value 0. This process continues for every record found in the initial `SELECT` statement from the `CHAMPIONSHIP` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageChampionships\nAS\nBEGIN\n  FOR rec IN (SELECT INSTITUTION_ID, NUMBER_OF_CHAMPIONSHIPS FROM CHAMPIONSHIP)\n  LOOP\n    IF rec.NUMBER_OF_CHAMPIONSHIPS < 5 THEN\n      UPDATE CHAMPIONSHIP SET NUMBER_OF_CHAMPIONSHIPS = NUMBER_OF_CHAMPIONSHIPS + 1 WHERE INSTITUTION_ID = rec.INSTITUTION_ID;\n    ELSIF rec.NUMBER_OF_CHAMPIONSHIPS BETWEEN 5 AND 10 THEN\n      DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = rec.INSTITUTION_ID AND MOD(rec.NUMBER_OF_CHAMPIONSHIPS, 2) = 0;\n    ELSE\n      INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS) VALUES (rec.INSTITUTION_ID, 'New Nickname', 2023, 0);\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  ManageChampionships;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named ManageChampionships with no parameters. For each record in the CHAMPIONSHIP table, check its number of championships. If less than 5, increment it by 1. If between 5 and 10 inclusive and the number is even, delete that record. If greater than 10, insert a new record for the same institution with a default nickname, joined year 2023, and championship count 0.",
    "natural_language": "Create a stored procedure called ManageChampionships without any parameters. Go through the CHAMPIONSHIP table and for each entry, look at how many championships it has. If it's not very many, say less than a handful, add one more. If the count is in that middle range, maybe between five and ten, and it's an even number, then just remove that entry. For the ones that have a lot, more than ten, put in a new record for that same institution with a common nickname, set the joined year to the current recent one, and start the championship count from scratch.",
    "id": 47
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AdjustChampionships that takes no parameters and processes every row in the CHAMPIONSHIP table by reading each row's INSTITUTION_ID and NUMBER_OF_CHAMPIONSHIPS columns. For each row fetched, the procedure executes conditional logic: if the NUMBER_OF_CHAMPIONSHIPS value is exactly zero, it performs an UPDATE on the CHAMPIONSHIP table, setting the NUMBER_OF_CHAMPIONSHIPS column to one for the specific row where the INSTITUTION_ID matches the current record's INSTITUTION_ID; if the NUMBER_OF_CHAMPIONSHIPS value is greater than ten, it performs a DELETE operation on the CHAMPIONSHIP table, removing the specific row where the INSTITUTION_ID matches the current record's INSTITUTION_ID; for all other cases where NUMBER_OF_CHAMPIONSHIPS is neither zero nor greater than ten, it performs an UPDATE on the CHAMPIONSHIP table, setting the NUMBER_OF_CHAMPIONSHIPS column to its current value incremented by one for the specific row where the INSTITUTION_ID matches the current record's INSTITUTION_ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE AdjustChampionships\nAS\nBEGIN\n  FOR rec IN (SELECT INSTITUTION_ID, NUMBER_OF_CHAMPIONSHIPS FROM CHAMPIONSHIP)\n  LOOP\n    IF rec.NUMBER_OF_CHAMPIONSHIPS = 0 THEN\n      UPDATE CHAMPIONSHIP SET NUMBER_OF_CHAMPIONSHIPS = 1 WHERE INSTITUTION_ID = rec.INSTITUTION_ID;\n    ELSIF rec.NUMBER_OF_CHAMPIONSHIPS > 10 THEN\n      DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = rec.INSTITUTION_ID;\n    ELSE\n      UPDATE CHAMPIONSHIP SET NUMBER_OF_CHAMPIONSHIPS = rec.NUMBER_OF_CHAMPIONSHIPS + 1 WHERE INSTITUTION_ID = rec.INSTITUTION_ID;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  AdjustChampionships;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named AdjustChampionships with no parameters. Process each row in the CHAMPIONSHIP table. If the number of championships is zero, set it to one. If it is greater than ten, delete the row. For all other cases, increment the number of championships by one.",
    "natural_language": "Create a stored procedure, which should be named AdjustChampionships, that accepts no input parameters. This procedure must systematically process every single row contained within the CHAMPIONSHIP table. For each record, if the current number of championships is precisely zero, it should be thoughtfully adjusted and set to one. Conversely, if the count is found to be substantially greater than ten, the entire row must be permanently deleted. In all other remaining cases, where the number is neither zero nor exceeds ten, the procedure should simply increment the existing championship count by one.",
    "id": 48
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateClaimSettlement` that is designed to modify a specific claim record within the `CLAIMS` table. This procedure accepts three parameters: `p_claim_id`, an `IN` parameter of type `NUMBER`, which represents the unique identifier of the claim to be updated; `p_new_amount_settled`, an `IN` parameter of type `NUMBER`, which specifies the new settlement amount to be assigned to the identified claim; and `p_success`, an `OUT` parameter of type `VARCHAR2`, which will communicate the outcome of the update operation.\n\nUpon execution, the procedure first performs an `UPDATE` operation on the `CLAIMS` table. This `UPDATE` statement sets the value of the `AMOUNT_SETTLED` column to the value provided by the `p_new_amount_settled` parameter. The `UPDATE` operation is conditionally applied, targeting only those rows where the value in the `CLAIM_ID` column matches the value supplied by the `p_claim_id` parameter.\n\nFollowing the `UPDATE` operation, the procedure evaluates the `SQL%ROWCOUNT` attribute. `SQL%ROWCOUNT` is a SQL pseudo-column that indicates the number of rows affected by the most recently executed SQL statement. If the value of `SQL%ROWCOUNT` is greater than `0`, meaning that at least one row in the `CLAIMS` table was successfully updated, the procedure assigns the string literal `'SUCCESS'` to the `p_success` `OUT` parameter. Conversely, if `SQL%ROWCOUNT` is not greater than `0` (i.e., it is `0`), indicating that no rows were updated (either because no claim with the specified `p_claim_id` was found or the update had no effect), the procedure assigns the string literal `'FAILURE'` to the `p_success` `OUT` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateClaimSettlement(\n  p_claim_id IN NUMBER,\n  p_new_amount_settled IN NUMBER,\n  p_success OUT VARCHAR2\n) AS\nBEGIN\n  UPDATE CLAIMS\n  SET AMOUNT_SETTLED = p_new_amount_settled\n  WHERE CLAIM_ID = p_claim_id;\n  \n  IF SQL%ROWCOUNT > 0 THEN\n    p_success := 'SUCCESS';\n  ELSE\n    p_success := 'FAILURE';\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 143, p_new_amount_settled => 1500, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 423, p_new_amount_settled => 2000, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 442, p_new_amount_settled => 1200, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 999, p_new_amount_settled => 500, p_success => v_success); -- Non-existent CLAIM_ID\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 143, p_new_amount_settled => 1000, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateClaimSettlement that updates a claim's settled amount. It takes a claim ID and a new amount as IN parameters and a success flag as an OUT parameter. Update the claim with the given ID. Set the success flag to 'SUCCESS' if a row was updated, otherwise set it to 'FAILURE'.",
    "natural_language": "Please construct a stored procedure designated as UpdateClaimSettlement. This procedure shall modify the settled amount for a specified claim. It must accept a claim identifier and a new monetary amount as input parameters, and it shall return a success indicator as an output parameter. The procedure is to update the claim record corresponding to the provided identifier. Subsequently, the success indicator should be assigned the value 'SUCCESS' if an update operation affects a database row; otherwise, it should be assigned the value 'FAILURE'.",
    "id": 49
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_mountain_photos` that accepts one input parameter, `p_country`, of data type `VARCHAR2`, which represents the country associated with mountains. The procedure begins by declaring a local variable `v_photo_count` of data type `NUMBER` to store the count of photos. It then proceeds to count the number of photos associated with mountains in the specified country. This count is achieved by executing a `SELECT` statement that retrieves the count of all rows from the `photos` table, aliased as `p`, joined with the `mountain` table, aliased as `m`, where the `mountain_id` column in the `photos` table matches the `id` column in the `mountain` table, and the `country` column in the `mountain` table matches the value provided in the `p_country` input parameter. The result of this count is stored in the `v_photo_count` variable.\n\nFollowing this, the procedure evaluates the value of `v_photo_count` using a conditional `IF-ELSIF-ELSE` block.\n\nIf `v_photo_count` is greater than 5, the procedure executes a `DELETE` operation. This operation removes rows from the `photos` table where the `mountain_id` column is present in a subquery's result set. The subquery selects the `id` column from the `mountain` table where the `country` column matches the `p_country` input parameter and the `height` column is less than 4000.\n\nIf `v_photo_count` is not greater than 5 but is greater than 0, the procedure executes an `INSERT` operation. This operation inserts a new row into the `photos` table, populating the `id`, `camera_lens_id`, `mountain_id`, `color`, and `name` columns.\nThe `id` column is populated by a subquery that calculates the maximum `id` value from the `photos` table and adds 1 to it.\nThe `camera_lens_id` column is populated by a subquery that selects the minimum `id` value from the `camera_lens` table where the `focal_length_mm` column is greater than 20.\nThe `mountain_id` column is populated by selecting the `id` column from the `mountain` table, aliased as `m`, where the `country` column matches the `p_country` input parameter and `ROWNUM` is equal to 1, effectively selecting the `id` of the first mountain found for that country.\nThe `color` column is set to the literal string 'RGB'.\nThe `name` column is constructed by concatenating the literal string 'auto_' with the `name` column from the `mountain` table, aliased as `m`, for the same mountain selected for `mountain_id`.\n\nIf `v_photo_count` is neither greater than 5 nor greater than 0 (meaning `v_photo_count` is 0), the procedure executes another `INSERT` operation. This operation inserts a new row into the `photos` table, populating the `id`, `camera_lens_id`, `mountain_id`, `color`, and `name` columns.\nThe `id` column is populated by a subquery that calculates the maximum `id` value from the `photos` table, adds 1 to it, and uses the `NVL` function to return 0 if `MAX(id)` is null, ensuring the first `id` is 1.\nThe `camera_lens_id` column is set to the literal numeric value 1.\nThe `mountain_id` column is populated by a subquery that selects the `id` column from the `mountain` table where the `country` column matches the `p_country` input parameter and `ROWNUM` is equal to 1, effectively selecting the `id` of the first mountain found for that country.\nThe `color` column is set to the literal string 'RGB'.\nThe `name` column is set to the literal string 'default'.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_mountain_photos(p_country IN VARCHAR2) IS\n    v_photo_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_photo_count\n    FROM photos p\n    JOIN mountain m ON p.mountain_id = m.id\n    WHERE m.country = p_country;\n    \n    IF v_photo_count > 5 THEN\n        DELETE FROM photos\n        WHERE mountain_id IN (SELECT id FROM mountain WHERE country = p_country AND height < 4000);\n    ELSIF v_photo_count > 0 THEN\n        INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n        SELECT (SELECT MAX(id) + 1 FROM photos), \n               (SELECT MIN(id) FROM camera_lens WHERE focal_length_mm > 20),\n               m.id,\n               'RGB',\n               'auto_' || m.name\n        FROM mountain m\n        WHERE m.country = p_country AND ROWNUM = 1;\n    ELSE\n        INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n        VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM photos), \n                1, \n                (SELECT id FROM mountain WHERE country = p_country AND ROWNUM = 1),\n                'RGB',\n                'default');\n    END IF;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  process_mountain_photos('Ethiopia');\nEND;",
      "BEGIN\n  process_mountain_photos('Morocco');\nEND;",
      "BEGIN\n  process_mountain_photos('Rwanda Uganda');\nEND;",
      "BEGIN\n  process_mountain_photos('USA');\nEND;",
      "BEGIN\n  process_mountain_photos('Nepal');\nEND;"
    ],
    "summary": "Create a stored procedure named process_mountain_photos that takes a country name as input. Count the photos for mountains in that country. If the count is greater than 5, delete photos for mountains in that country with height less than 4000. If the count is greater than 0 but not greater than 5, insert a new photo with an auto-generated name for the first mountain found. If the count is 0, insert a default-named photo for the first mountain found.",
    "natural_language": "Create a stored procedure called process_mountain_photos that accepts a country name. Figure out roughly how many mountain photos exist for that place. If there are quite a few, say more than a handful, remove the less impressive photos from mountains that aren't very tall. If there are only a small number of photos, maybe a few, then add a new auto-named photo for a notable mountain there. If there aren't really any photos at all, just put in a basic default photo for one of the mountains.",
    "id": 50
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sync_lens_data that accepts a single input parameter p_focal_length of type NUMBER, representing the focal length in millimeters. The procedure begins by declaring three local variables: v_brand_count of type NUMBER to store the count of distinct brands, v_current_user of type VARCHAR2(100) to store the current database user, and v_max_id of type NUMBER to store the maximum ID value from the PHOTOS table. The procedure assigns the current database user to v_current_user using the USER function. It then performs a SELECT statement to count the distinct brands from the CAMERA_LENS table where the FOCAL_LENGTH_MM column matches the input parameter p_focal_length, storing the result in v_brand_count. The procedure uses an IF conditional statement to check the value of v_brand_count. If v_brand_count is greater than or equal to 2, it executes a DELETE statement on the PHOTOS table, removing rows where the CAMERA_LENS_ID matches any ID from the CAMERA_LENS table with a FOCAL_LENGTH_MM equal to p_focal_length and a BRAND starting with the letter 'S'. If v_brand_count equals 1, the procedure performs a SELECT statement to find the maximum ID from the PHOTOS table, using the NVL function to default to 0 if no rows exist, and stores the result in v_max_id. It then executes an INSERT statement into the PHOTOS table, inserting new rows with the following values: ID as v_max_id plus the current row number (ROWNUM), CAMERA_LENS_ID as the ID from the CAMERA_LENS table where FOCAL_LENGTH_MM equals p_focal_length, MOUNTAIN_ID as the ID from the MOUNTAIN table for the first row (ROWNUM = 1), COLOR as 'SYNC', and NAME as the concatenation of v_current_user and '_sync'. The procedure concludes without any further operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_lens_data(p_focal_length IN NUMBER) IS\n    v_brand_count NUMBER;\n    v_current_user VARCHAR2(100);\n    v_max_id NUMBER;\nBEGIN\n    v_current_user := USER;\n    \n    SELECT COUNT(DISTINCT BRAND) INTO v_brand_count\n    FROM CAMERA_LENS\n    WHERE FOCAL_LENGTH_MM = p_focal_length;\n    \n    IF v_brand_count >= 2 THEN\n        DELETE FROM PHOTOS\n        WHERE CAMERA_LENS_ID IN (\n            SELECT ID FROM CAMERA_LENS \n            WHERE FOCAL_LENGTH_MM = p_focal_length \n            AND BRAND LIKE 'S%'\n        );\n    ELSIF v_brand_count = 1 THEN\n        SELECT NVL(MAX(ID), 0) INTO v_max_id FROM PHOTOS;\n        \n        INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME)\n        SELECT v_max_id + ROWNUM,\n               cl.ID,\n               (SELECT ID FROM MOUNTAIN WHERE ROWNUM = 1),\n               'SYNC',\n               v_current_user || '_sync'\n        FROM CAMERA_LENS cl\n        WHERE cl.FOCAL_LENGTH_MM = p_focal_length;\n    END IF;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  sync_lens_data(19);\n  commit;\nEND;",
      "BEGIN\n  sync_lens_data(30);\n  commit;\nEND;",
      "BEGIN\n  sync_lens_data(25);\n  commit;\nEND;",
      "BEGIN\n  sync_lens_data(35);\n  commit;\nEND;",
      "BEGIN\n  sync_lens_data(50);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sync_lens_data that accepts a focal length number. Count distinct brands for that focal length. If the count is 2 or more, delete photos linked to lenses of that focal length from brands starting with 'S'. If the count is exactly 1, insert new photo rows with a generated ID, the matching lens ID, a mountain ID, the color 'SYNC', and a name combining the current user and '_sync'.",
    "natural_language": "Make a stored procedure called sync_lens_data that takes a kind of focal length value. Figure out roughly how many different brands are associated with that focal length. If there are a couple or more brands, get rid of photos connected to lenses of that focal length from brands whose names are sort of like starting with 'S'. If there's basically just one brand, add some new photo entries. These should have a made-up ID, the corresponding lens ID, a mountain ID, the color set to 'SYNC', and a name that mixes the current user with something like '_sync'.",
    "id": 51
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_photo_colors that accepts a single input parameter p_mountain_range of type VARCHAR2, which represents the name of a mountain range. The procedure begins by declaring a local variable v_color_count of type NUMBER to store the count of distinct colors associated with photos linked to mountains in the specified range. It executes a SELECT statement to count the distinct colors from the photos table, joining it with the mountain table on the mountain_id column, and filters the results where the range column in the mountain table matches the input parameter p_mountain_range. The result is stored in v_color_count. The procedure then evaluates the value of v_color_count using an IF-ELSIF-ELSE conditional structure. If v_color_count is greater than 1, it performs an INSERT operation into the photos table, selecting new rows with a calculated id using the maximum current id from the photos table plus ROWNUM, a camera_lens_id from the camera_lens table where ROWNUM equals 1, the id of mountains from the mountain table where the range matches p_mountain_range and ROWNUM is less than or equal to 3, a fixed color value 'MIXED', and a name constructed by concatenating 'range_' with the mountain name. If v_color_count equals 1, it executes a DELETE operation on the photos table, removing rows where the mountain_id corresponds to mountains in the specified range with a prominence less than 2000. If v_color_count is zero, it performs another INSERT operation into the photos table, inserting a new row with an id calculated as the maximum current id from the photos table plus 1, a camera_lens_id from the camera_lens table where the focal_length_mm is 30 and ROWNUM equals 1, the id of a mountain from the mountain table where the range matches p_mountain_range and ROWNUM equals 1, a fixed color value 'NEW', and a fixed name 'first_photo'.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_photo_colors(p_mountain_range IN VARCHAR2) IS\n    v_color_count NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT p.color) INTO v_color_count\n    FROM photos p\n    JOIN mountain m ON p.mountain_id = m.id\n    WHERE m.range = p_mountain_range;\n    \n    IF v_color_count > 1 THEN\n        INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n        SELECT (SELECT MAX(id) + ROWNUM FROM photos),\n               (SELECT id FROM camera_lens WHERE ROWNUM = 1),\n               m.id,\n               'MIXED',\n               'range_' || m.name\n        FROM mountain m\n        WHERE m.range = p_mountain_range AND ROWNUM <= 3;\n    ELSIF v_color_count = 1 THEN\n        DELETE FROM photos\n        WHERE mountain_id IN (\n            SELECT id FROM mountain \n            WHERE range = p_mountain_range \n            AND prominence < 2000\n        );\n    ELSE\n        INSERT INTO photos (id, camera_lens_id, mountain_id, color, name)\n        VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM photos),\n                (SELECT id FROM camera_lens WHERE focal_length_mm = 30 AND ROWNUM = 1),\n                (SELECT id FROM mountain WHERE range = p_mountain_range AND ROWNUM = 1),\n                'NEW',\n                'first_photo');\n    END IF;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  manage_photo_colors('Arsi Mountains');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_photo_colors('Toubkal Atlas');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_photo_colors('Virunga Mountains');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_photo_colors('Himalayas');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_photo_colors('Alps');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named manage_photo_colors that accepts a mountain range name. Count distinct photo colors for that range. If the count is greater than 1, insert up to three new 'MIXED' color photos for mountains in that range. If the count equals 1, delete photos for mountains in that range with prominence under 2000. If the count is zero, insert a single new 'NEW' color photo for a lens with 30mm focal length and a mountain from that range.",
    "natural_language": "Create a stored procedure called manage_photo_colors that takes a mountain range name. Figure out roughly how many different photo colors there are for that area. If it seems like there are quite a few different colors, add a small number of new photos labeled 'MIXED' for some mountains there. If it looks like there's basically just one color type, get rid of photos for the less significant mountains in that range. If there don't appear to be any colors at all, put in a fresh 'NEW' color photo using a standard lens for one of the mountains.",
    "id": 52
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named p_manage_actor_musical_data that performs several operations on the ACTOR and MUSICAL tables. First, it declares two variables, v_actor_count and v_musical_count, both of type NUMBER, to store the count of actors older than 30 and musicals released after the year 2000, respectively. It also declares a cursor, cur_actors, which selects the ACTOR_ID, NAME, and AGE columns from the ACTOR table for actors older than 30. The procedure begins by executing a SELECT statement to count the number of actors older than 30 and stores this count in v_actor_count. It then executes another SELECT statement to count the number of musicals released after the year 2000, storing this count in v_musical_count. The procedure then evaluates a series of conditional statements. If v_actor_count is greater than 10, it iterates over each record in the cur_actors cursor, and for each actor, it deletes the corresponding row from the ACTOR table where the ACTOR_ID matches and the AGE is greater than 60. If v_actor_count is not greater than 10 but v_musical_count is less than 5, it inserts a new row into the MUSICAL table with a MUSICAL_ID that is one greater than the current maximum MUSICAL_ID, and sets the NAME to 'New Musical', YEAR to 2023, AWARD to 'None', CATEGORY to 'New Category', NOMINEE to 'New Nominee', and RESULT to 'Nominated'. If neither of the previous conditions is met, it updates the ACTOR table by setting the CHARACTER column to 'Updated Character' for all actors younger than 25. Finally, if v_actor_count is less than 5, it deletes all rows from the ACTOR table where the AGE is less than 20.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_manage_actor_musical_data IS\n    v_actor_count NUMBER;\n    v_musical_count NUMBER;\n    CURSOR cur_actors IS SELECT ACTOR_ID, NAME, AGE FROM ACTOR WHERE AGE > 30;\nBEGIN\n    SELECT COUNT(*) INTO v_actor_count FROM ACTOR WHERE AGE > 30;\n    SELECT COUNT(*) INTO v_musical_count FROM MUSICAL WHERE YEAR > 2000;\n\n    IF v_actor_count > 10 THEN\n        FOR actor_rec IN cur_actors LOOP\n            DELETE FROM ACTOR WHERE ACTOR_ID = actor_rec.ACTOR_ID AND AGE > 60;\n        END LOOP;\n    ELSIF v_musical_count < 5 THEN\n        INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT)\n        VALUES ((SELECT MAX(MUSICAL_ID) + 1 FROM MUSICAL), 'New Musical', 2023, 'None', 'New Category', 'New Nominee', 'Nominated');\n    ELSE\n        UPDATE ACTOR SET CHARACTER = 'Updated Character' WHERE AGE < 25;\n    END IF;\n\n    IF v_actor_count < 5 THEN\n        DELETE FROM ACTOR WHERE AGE < 20;\n    END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "BEGIN\n  p_manage_actor_musical_data;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named p_manage_actor_musical_data with no parameters. Count actors over 30 and musicals after 2000. If actor count > 10, delete actors over 60 from the cursor of actors over 30. Else if musical count < 5, insert a new 'New Musical' record. Else, update the character for actors under 25. Finally, if actor count < 5, delete actors under 20.",
    "natural_language": "Please construct a stored procedure designated as p_manage_actor_musical_data, which shall accept no parameters. The procedure is to perform the following operations: first, ascertain the count of actors whose age exceeds 30 years, and the count of musicals produced after the year 2000. Should the actor count be greater than 10, then delete those actors over 60 years of age from the cursor containing actors over 30. Alternatively, if the musical count is less than 5, insert a new record titled 'New Musical'. Otherwise, update the character information for actors under 25 years of age. Conclusively, if the actor count is determined to be less than 5, delete all actors under the age of 20.",
    "id": 53
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `p_actor_age_management` that does not accept any input parameters. This procedure declares two local numeric variables: `v_young_actors` and `v_old_actors`. It also declares a cursor named `cur_young_actors` which is designed to select the `ACTOR_ID` and `NAME` columns from the `ACTOR` table for all rows where the `AGE` column is less than 25. The procedure begins by executing a `SELECT COUNT(*)` statement to count the number of rows in the `ACTOR` table where the `AGE` column is less than 25, storing this count into the `v_young_actors` variable. Immediately following this, another `SELECT COUNT(*)` statement is executed to count the number of rows in the `ACTOR` table where the `AGE` column is greater than 50, storing this count into the `v_old_actors` variable.\n\nNext, the procedure enters a conditional block. If the value of `v_young_actors` is greater than 5, the procedure then iterates through each record returned by the `cur_young_actors` cursor. For each `young_actor_rec` obtained from the cursor, an `UPDATE` statement is executed on the `ACTOR` table, setting the `CHARACTER` column to the string literal 'Young Star' for the row where the `ACTOR_ID` column matches the `ACTOR_ID` from the current `young_actor_rec`.\n\nIf the condition `v_young_actors > 5` is false, the procedure proceeds to an `ELSIF` condition. If the value of `v_old_actors` is greater than 10, a `DELETE` statement is executed on the `ACTOR` table, removing all rows where the `AGE` column is greater than 60.\n\nIf both the `v_young_actors > 5` and `v_old_actors > 10` conditions are false, the procedure executes an `ELSE` block. Within this block, an `INSERT` statement is performed on the `ACTOR` table. The `ACTOR_ID` column is populated by a subquery that selects the maximum `ACTOR_ID` from the `ACTOR` table and adds 1 to it. The `NAME` column is set to the string literal 'New Actor'. The `MUSICAL_ID` column is set to the numeric value 1. The `CHARACTER` column is set to the string literal 'New Role'. The `DURATION` column is set to the string literal '2023'. The `AGE` column is set to the numeric value 30.\n\nFollowing this main conditional block, the procedure enters another independent conditional block. If the value of `v_young_actors` is less than 3, an `UPDATE` statement is executed on the `ACTOR` table. This `UPDATE` statement increments the value of the `AGE` column by 1 for all rows where the current `AGE` column value is less than 20.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_actor_age_management IS\n    v_young_actors NUMBER;\n    v_old_actors NUMBER;\n    CURSOR cur_young_actors IS SELECT ACTOR_ID, NAME FROM ACTOR WHERE AGE < 25;\nBEGIN\n    SELECT COUNT(*) INTO v_young_actors FROM ACTOR WHERE AGE < 25;\n    SELECT COUNT(*) INTO v_old_actors FROM ACTOR WHERE AGE > 50;\n\n    IF v_young_actors > 5 THEN\n        FOR young_actor_rec IN cur_young_actors LOOP\n            UPDATE ACTOR SET CHARACTER = 'Young Star' WHERE ACTOR_ID = young_actor_rec.ACTOR_ID;\n        END LOOP;\n    ELSIF v_old_actors > 10 THEN\n        DELETE FROM ACTOR WHERE AGE > 60;\n    ELSE\n        INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION, AGE)\n        VALUES ((SELECT MAX(ACTOR_ID) + 1 FROM ACTOR), 'New Actor', 1, 'New Role', '2023', 30);\n    END IF;\n\n    IF v_young_actors < 3 THEN\n        UPDATE ACTOR SET AGE = AGE + 1 WHERE AGE < 20;\n    END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "BEGIN\n  p_actor_age_management;\nEND;"
    ],
    "summary": "Create a stored procedure named p_actor_age_management with no parameters. Count actors under 25 and over 50. If young actors > 5, update their character to 'Young Star'. Else if old actors > 10, delete actors over 60. Else, insert a new actor record. Separately, if young actors < 3, increment the age of actors under 20 by 1.",
    "natural_language": "Create a stored procedure called p_actor_age_management without any parameters. Figure out roughly how many actors are fairly young and how many are getting up there in years. If there are quite a few of the younger ones, maybe update their character type to something like 'Young Star'. On the other hand, if there seems to be a significant number of older actors, consider removing the ones who are quite elderly. If neither case fits, just add a new actor record. Also, separately, if the count of young actors seems particularly low, nudge up the age for those who are still very young.",
    "id": 54
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named p_musical_nominee_update that first declares a local variable v_nominee_count of type NUMBER and a cursor named cur_nominees that selects the MUSICAL_ID and NOMINEE columns from the MUSICAL table for all rows where the NOMINEE column is NULL, then initializes v_nominee_count by performing a SELECT COUNT(*) query from the MUSICAL table where NOMINEE is NULL, then uses an IF-ELSIF-ELSE conditional block where if v_nominee_count is greater than zero, it opens the cur_nominees cursor and processes each record in a FOR LOOP, performing an UPDATE on the MUSICAL table to set the NOMINEE column to the literal string 'Pending Nominee' for each row where the MUSICAL_ID matches the MUSICAL_ID from the current cursor record, but if v_nominee_count equals zero, it executes a DELETE statement on the MUSICAL table to remove all rows where the YEAR column is less than 1990, and otherwise, if the previous conditions are not met, it executes an INSERT statement into the MUSICAL table, providing values for the columns MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, and RESULT, where the MUSICAL_ID value is derived from a subquery that selects the maximum MUSICAL_ID from the MUSICAL table and adds 1 to it, and the other values are the literal strings 'Future Musical', 2025, 'Future Award', 'Future Category', 'Future Nominee', and 'Nominated', respectively, and finally, after that main conditional block, the procedure checks another condition where if v_nominee_count is greater than 5, it performs an UPDATE on the MUSICAL table to set the RESULT column to the literal string 'Updated Result' for all rows where the YEAR column is greater than 2010.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_musical_nominee_update IS\n    v_nominee_count NUMBER;\n    CURSOR cur_nominees IS SELECT MUSICAL_ID, NOMINEE FROM MUSICAL WHERE NOMINEE IS NULL;\nBEGIN\n    SELECT COUNT(*) INTO v_nominee_count FROM MUSICAL WHERE NOMINEE IS NULL;\n\n    IF v_nominee_count > 0 THEN\n        FOR nominee_rec IN cur_nominees LOOP\n            UPDATE MUSICAL SET NOMINEE = 'Pending Nominee' WHERE MUSICAL_ID = nominee_rec.MUSICAL_ID;\n        END LOOP;\n    ELSIF v_nominee_count = 0 THEN\n        DELETE FROM MUSICAL WHERE YEAR < 1990;\n    ELSE\n        INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT)\n        VALUES ((SELECT MAX(MUSICAL_ID) + 1 FROM MUSICAL), 'Future Musical', 2025, 'Future Award', 'Future Category', 'Future Nominee', 'Nominated');\n    END IF;\n\n    IF v_nominee_count > 5 THEN\n        UPDATE MUSICAL SET RESULT = 'Updated Result' WHERE YEAR > 2010;\n    END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "BEGIN\n  p_musical_nominee_update;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named p_musical_nominee_update with no parameters. Count musicals with a NULL nominee. If count > 0, update those records to set nominee to 'Pending Nominee'. If count = 0, delete musicals released before 1990. Else, insert a new 'Future Musical' record. After this, if the count > 5, update the result for musicals after 2010 to 'Updated Result'.",
    "natural_language": "Count musicals with a NULL nominee. If the count is greater than zero, update those records to set the nominee to 'Pending Nominee'. If the count equals zero, delete musicals released before 1990. Otherwise, insert a new record for a 'Future Musical'. After this, if the count is greater than five, update the result for musicals released after 2010 to 'Updated Result'. Do all of this within a stored procedure named p_musical_nominee_update that takes no parameters.",
    "id": 55
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts five input parameters: a numeric parameter 'para_stuid' representing a student identifier, a string parameter 'para_pettype' representing a type of pet, a numeric parameter 'para_age' representing an age, a numeric parameter 'para_weight' representing a weight, and a numeric parameter 'para_major' representing a major code. The procedure first checks if a student with the provided 'para_stuid' exists in the STUDENT table by selecting the count of rows where the STUID column equals 'para_stuid' into the variable 'student_exists'. If 'student_exists' is greater than zero, indicating the student exists, the procedure then selects the count of rows in the HAS_PET table where the STUID column equals 'para_stuid' into the variable 'pet_count' to determine how many pets the student currently has. If 'pet_count' equals zero, meaning the student has no pets, the procedure checks if a pet with the exact combination of type and age provided in parameters 'para_pettype' and 'para_age' already exists in the PETS table by selecting the count of rows where the PETTYPE column equals 'para_pettype' and the PET_AGE column equals 'para_age' into the variable 'pet_exists'. If 'pet_exists' is greater than zero, the procedure calculates a new pet identifier by selecting the maximum existing PETID value from the PETS table, using the NVL function to default to 2000 if the maximum is null, and adding 1 to that result, storing it in the variable 'new_petid'. It then inserts a new row into the PETS table with columns PETID set to 'new_petid', PETTYPE set to 'para_pettype', PET_AGE set to 'para_age', and WEIGHT set to 'para_weight', and subsequently inserts a new row into the HAS_PET table with columns STUID set to 'para_stuid' and PETID set to 'new_petid' to establish the ownership relationship. If, however, 'pet_exists' is zero, the procedure calculates the average WEIGHT from the PETS table for all pets of the type specified in 'para_pettype', storing the result in the variable 'avg_weight'. If 'avg_weight' is greater than the input parameter 'para_weight', the procedure inserts a new row directly into the PETS table with columns PETID set to the value of 'para_stuid' plus 1000, PETTYPE set to 'para_pettype', PET_AGE set to 'para_age', and WEIGHT set to 'para_weight'. If 'avg_weight' is not greater than 'para_weight', the procedure deletes the student's record from the STUDENT table where the STUID column equals 'para_stuid'. If the initial 'pet_count' for the existing student is equal to 1, the procedure calculates the average PET_AGE for the pets owned by that specific student by joining the PETS table (aliased as 'p') and the HAS_PET table (aliased as 'hp') on the PETID column and selecting the average where 'hp.STUID' equals 'para_stuid', storing the result in the variable 'avg_weight'. If this calculated average age ('avg_weight') is greater than the input parameter 'para_age', the procedure deletes the ownership record from the HAS_PET table for that student where the STUID column equals 'para_stuid'. If the average age is not greater than 'para_age', the procedure inserts a new row into the PETS table with columns PETID set to the value of 'para_stuid' plus 2000, PETTYPE set to 'para_pettype', PET_AGE set to 'para_age', and WEIGHT set to 'para_weight'. If the initial 'pet_count' for the existing student is neither 0 nor 1 (meaning the student has two or more pets), the procedure deletes a single ownership record from the HAS_PET table for that student where the STUID column equals 'para_stuid', using the condition 'ROWNUM = 1' to limit the deletion to one arbitrary row. If the initial check finds that 'student_exists' is zero, meaning the student does not exist, the procedure inserts a new row into the STUDENT table with columns STUID set to 'para_stuid', LNAME set to the literal string 'Default', FNAME set to the literal string 'Student', AGE set to the input parameter 'para_age', and MAJOR set to the input parameter 'para_major'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_stuid NUMBER, para_pettype VARCHAR2, para_age NUMBER, para_weight NUMBER, para_major NUMBER) IS\npet_count NUMBER;\nstudent_exists NUMBER;\nnew_petid NUMBER;\npet_exists NUMBER;\navg_weight NUMBER;\nBEGIN\nSELECT COUNT(*) INTO student_exists FROM STUDENT WHERE STUID = para_stuid;\nIF student_exists > 0 THEN\nSELECT COUNT(*) INTO pet_count FROM HAS_PET WHERE STUID = para_stuid;\nIF pet_count = 0 THEN\nSELECT COUNT(*) INTO pet_exists FROM PETS WHERE PETTYPE = para_pettype AND PET_AGE = para_age;\nIF pet_exists > 0 THEN\nSELECT NVL(MAX(PETID), 2000) + 1 INTO new_petid FROM PETS;\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (new_petid, para_pettype, para_age, para_weight);\nINSERT INTO HAS_PET (STUID, PETID) VALUES (para_stuid, new_petid);\nELSE\nSELECT AVG(WEIGHT) INTO avg_weight FROM PETS WHERE PETTYPE = para_pettype;\nIF avg_weight > para_weight THEN\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (para_stuid + 1000, para_pettype, para_age, para_weight);\nELSE\nDELETE FROM STUDENT WHERE STUID = para_stuid;\nEND IF;\nEND IF;\nELSIF pet_count = 1 THEN\nSELECT AVG(PET_AGE) INTO avg_weight FROM PETS p JOIN HAS_PET hp ON p.PETID = hp.PETID WHERE hp.STUID = para_stuid;\nIF avg_weight > para_age THEN\nDELETE FROM HAS_PET WHERE STUID = para_stuid;\nELSE\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (para_stuid + 2000, para_pettype, para_age, para_weight);\nEND IF;\nELSE\nDELETE FROM HAS_PET WHERE STUID = para_stuid AND ROWNUM = 1;\nEND IF;\nELSE\nINSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, MAJOR) VALUES (para_stuid, 'Default', 'Student', para_age, para_major);\nEND IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1004, 'dog', 2, 15.5, 600);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1005, 'cat', 4, 8.2, 550);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1001, 'bird', 1, 0.5, 600);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1002, 'dog', 3, 25.0, 620);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(9999, 'rabbit', 2, 3.7, 580);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp' that adds a pet for a student. Inputs: student ID, pet type, age, weight, and major code. If the student exists, check their current pet count. If they have no pets, check if a pet with the same type and age exists. If it does, generate a new pet ID, insert the pet, and link it to the student. If it doesn't, compare the pet's weight to the average weight for its type. If the weight is lower, insert the pet with an ID based on the student ID. If not, delete the student. If the student has one pet, compare the input age to the student's average pet age. If the input age is lower, delete the pet link. If not, insert a new pet with an ID based on the student ID. If the student has two or more pets, delete one arbitrary pet link. If the student does not exist, insert a new default student record.",
    "natural_language": "Write a stored procedure called 'sp' to add a pet for a student. Use the student ID, pet type, age, weight, and major code as inputs. First, check if the student exists. If they do, examine their current number of pets. For a student with no pets, see if a pet with the same type and age already exists. If such a pet exists, generate a new pet ID, insert the pet, and link it to the student. If it doesn't, compare the pet's weight to the average weight for its type. Insert the pet with an ID based on the student ID if the weight is lower; otherwise, delete the student. For a student with one pet, compare the input age to the student's average pet age. Delete the pet link if the input age is lower; if not, insert a new pet with an ID based on the student ID. If the student has two or more pets, delete one arbitrary pet link. If the student does not exist, insert a new default student record.",
    "id": 56
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp that accepts two parameters: para_weight_limit of type NUMBER and para_age_limit of type NUMBER. The procedure begins by declaring a cursor named pet_cursor, which retrieves data from the PETS table joined with the HAS_PET table based on the PETID column, selecting PETID, PETTYPE, PET_AGE, WEIGHT, and STUID columns. It declares variables pet_rec of type pet_cursor%ROWTYPE, student_age of type NUMBER, pet_type_decoded of type VARCHAR2(50), and student_count of type NUMBER. The procedure opens the pet_cursor and enters a loop to fetch each record into pet_rec. It exits the loop when no more records are found. For each fetched record, it uses the DECODE function to translate the PETTYPE column value into 'canine' for 'dog', 'feline' for 'cat', or 'unknown' for other values, storing the result in pet_type_decoded. It attempts to select the AGE column from the STUDENT table where STUID matches pet_rec.STUID, storing the result in student_age, and handles the NO_DATA_FOUND exception by setting student_age to NULL. The procedure then evaluates several conditions based on pet_rec.WEIGHT, pet_rec.PET_AGE, and student_age. If pet_rec.WEIGHT exceeds para_weight_limit, it checks if pet_rec.PET_AGE exceeds para_age_limit and if student_age is greater than 20, deleting the record from HAS_PET where PETID matches pet_rec.PETID. If student_age is not greater than 20, it inserts a new record into PETS with PETID incremented by 5000, pet_type_decoded, pet_rec.PET_AGE, and pet_rec.WEIGHT. If pet_rec.PET_AGE does not exceed para_age_limit, it checks if student_age is not NULL, counts the number of students with the same age, and if student_count is greater than 1, deletes records from HAS_PET and PETS where PETID matches pet_rec.PETID. If student_count is not greater than 1, it inserts a new record into HAS_PET with STUID and PETID incremented by 6000. If student_age is NULL, it performs no operation. If pet_rec.WEIGHT does not exceed para_weight_limit, it checks if pet_rec.PET_AGE is less than para_age_limit, deleting records from HAS_PET and STUDENT where STUID matches pet_rec.STUID. If pet_rec.PET_AGE is not less than para_age_limit, it inserts a new record into PETS with PETID incremented by 7000, pet_type_decoded, pet_rec.PET_AGE incremented by 1, and pet_rec.WEIGHT incremented by 1. The procedure closes the pet_cursor after processing all records.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_weight_limit NUMBER, para_age_limit NUMBER) IS\nCURSOR pet_cursor IS SELECT p.PETID, p.PETTYPE, p.PET_AGE, p.WEIGHT, hp.STUID FROM PETS p JOIN HAS_PET hp ON p.PETID = hp.PETID;\npet_rec pet_cursor%ROWTYPE;\nstudent_age NUMBER;\npet_type_decoded VARCHAR2(50);\nstudent_count NUMBER;\nBEGIN\nOPEN pet_cursor;\nLOOP\nFETCH pet_cursor INTO pet_rec;\nEXIT WHEN pet_cursor%NOTFOUND;\nSELECT DECODE(pet_rec.PETTYPE, 'dog', 'canine', 'cat', 'feline', 'unknown') INTO pet_type_decoded FROM DUAL;\nBEGIN\nSELECT AGE INTO student_age FROM STUDENT WHERE STUID = pet_rec.STUID;\nEXCEPTION\nWHEN NO_DATA_FOUND THEN\nstudent_age := NULL;\nEND;\nIF pet_rec.WEIGHT > para_weight_limit THEN\nIF pet_rec.PET_AGE > para_age_limit THEN\nIF student_age > 20 THEN\nDELETE FROM HAS_PET WHERE PETID = pet_rec.PETID;\nELSE\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (pet_rec.PETID + 5000, pet_type_decoded, pet_rec.PET_AGE, pet_rec.WEIGHT);\nEND IF;\nELSE\nIF student_age IS NOT NULL THEN\nSELECT COUNT(*) INTO student_count FROM STUDENT WHERE AGE = student_age;\nIF student_count > 1 THEN\nDELETE FROM HAS_PET WHERE PETID = pet_rec.PETID;\nDELETE FROM PETS WHERE PETID = pet_rec.PETID;\nELSE\nINSERT INTO HAS_PET (STUID, PETID) VALUES (pet_rec.STUID, pet_rec.PETID + 6000);\nEND IF;\nELSE\n-- If student_age is NULL, skip this block or handle appropriately\nNULL;\nEND IF;\nEND IF;\nELSE\nIF pet_rec.PET_AGE < para_age_limit THEN\nDELETE FROM HAS_PET WHERE STUID = pet_rec.STUID;\nDELETE FROM STUDENT WHERE STUID = pet_rec.STUID;\nELSE\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (pet_rec.PETID + 7000, pet_type_decoded, pet_rec.PET_AGE + 1, pet_rec.WEIGHT + 1);\nEND IF;\nEND IF;\nEND LOOP;\nCLOSE pet_cursor;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN sp(10, 5); END;",
      "BEGIN sp(15, 10); END;",
      "BEGIN sp(5, 2); END;",
      "BEGIN sp(20, 1); END;",
      "BEGIN sp(8, 7); END;"
    ],
    "summary": "Create a stored procedure named 'sp' to process pet records. Inputs: a weight limit and an age limit. For each pet linked to a student, decode its type. If the pet's weight exceeds the limit, check its age and the student's age. If both the pet's age exceeds the limit and the student is over 20, delete the pet link. If the student is 20 or under, insert a new pet with an adjusted ID. If the pet's age does not exceed the limit, check if the student exists. If they do and more than one student shares that age, delete the pet and its link. Otherwise, insert a new pet link with adjusted IDs. If the pet's weight does not exceed the limit, check its age. If the age is below the limit, delete the student and their pet links. Otherwise, insert a new pet with an adjusted ID, age, and weight.",
    "natural_language": "How can I create a stored procedure named 'sp' that processes pet records based on a given weight limit and age limit? For each pet associated with a student, it should decode the pet's type. If a pet's weight is above the limit, how should the procedure check the pet's age and the student's age? If the pet is older than the age limit and the student is over 20, should it delete the pet link? If the student is 20 or younger, should it insert a new pet with an adjusted ID? If the pet's age is not over the limit, how does it check for the student's existence? If the student exists and more than one student shares that age, should it delete the pet and its link? Otherwise, should it insert a new pet link with adjusted IDs? If the pet's weight is not over the limit, how does it check the pet's age? If the age is below the limit, should it delete the student and all their pet links? Otherwise, should it insert a new pet with an adjusted ID, age, and weight?",
    "id": 57
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp that takes three parameters: para_petid of type NUMBER, para_stuid of type NUMBER, and para_age_threshold of type NUMBER. The procedure first checks if a student with the ID para_stuid exists in the STUDENT table by counting the number of records with STUID equal to para_stuid and storing the result in the variable student_exists. If the student exists (student_exists > 0), it then checks if there is a relationship between the student and a pet with the ID para_petid in the HAS_PET table by counting the records where STUID equals para_stuid and PETID equals para_petid, storing the result in has_relationship. If such a relationship exists (has_relationship > 0), it retrieves the pet's type, age, and weight from the PETS table where PETID equals para_petid, storing these values in pet_type, pet_age, and pet_weight, respectively. It then decodes the pet_type using the DECODE function to assign a descriptive string to decoded_type based on the pet type: 'loyal' for 'dog', 'independent' for 'cat', 'vocal' for 'bird', and 'other' for any other type. If the pet's age (pet_age) is greater than para_age_threshold, it counts the number of other pets the student owns by selecting from HAS_PET where STUID equals para_stuid and PETID is not equal to para_petid, storing the result in other_pets. If the student has other pets (other_pets > 0), it deletes the relationship between the student and the specific pet from HAS_PET where STUID equals para_stuid and PETID equals para_petid. If the student does not have other pets, it retrieves the student's age from the STUDENT table where STUID equals para_stuid, storing it in student_age. If the student's age is greater than 20, it inserts a new pet record into the PETS table with a new PETID (para_petid + 10000), the decoded pet type, the pet's age, and weight. If the student's age is 20 or less, it deletes all records from HAS_PET where PETID equals para_petid and then deletes the pet from the PETS table where PETID equals para_petid. If the pet's age is not greater than para_age_threshold, it checks if the pet's weight (pet_weight) is greater than 12. If so, it inserts a new relationship into HAS_PET with STUID equal to para_stuid + 1 and PETID equal to para_petid. If the pet's weight is not greater than 12, it deletes all records from HAS_PET where STUID equals para_stuid and then deletes the student from the STUDENT table where STUID equals para_stuid. If no relationship exists between the student and the pet (has_relationship = 0), it inserts a new relationship into HAS_PET with STUID equal to para_stuid and PETID equal to para_petid. If the student does not exist (student_exists = 0), it inserts a new student record into the STUDENT table with STUID equal to para_stuid, last name 'New', first name 'Student', age 19, and major 600.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_petid NUMBER, para_stuid NUMBER, para_age_threshold NUMBER) IS\n  pet_type         VARCHAR2(255);\n  pet_age          NUMBER;\n  pet_weight       NUMBER;\n  student_exists   NUMBER;\n  has_relationship NUMBER;\n  other_pets       NUMBER;\n  student_age      NUMBER;\n  decoded_type     VARCHAR2(50);\nBEGIN\n  SELECT COUNT(*) INTO student_exists FROM STUDENT WHERE STUID = para_stuid;\n\n  IF student_exists > 0 THEN\n    SELECT COUNT(*) INTO has_relationship FROM HAS_PET WHERE STUID = para_stuid AND PETID = para_petid;\n\n    IF has_relationship > 0 THEN\n      SELECT PETTYPE, PET_AGE, WEIGHT INTO pet_type, pet_age, pet_weight FROM PETS WHERE PETID = para_petid;\n      SELECT DECODE(pet_type, 'dog', 'loyal', 'cat', 'independent', 'bird', 'vocal', 'other') INTO decoded_type FROM DUAL;\n\n      IF pet_age > para_age_threshold THEN\n        SELECT COUNT(*) INTO other_pets FROM HAS_PET WHERE STUID = para_stuid AND PETID != para_petid;\n\n        IF other_pets > 0 THEN\n          -- Delete the specific pet-student relationship\n          DELETE FROM HAS_PET WHERE STUID = para_stuid AND PETID = para_petid;\n        ELSE\n          -- No other pets for this student, consider deleting the pet or student\n          SELECT AGE INTO student_age FROM STUDENT WHERE STUID = para_stuid;\n\n          IF student_age > 20 THEN\n            INSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (para_petid + 10000, decoded_type, pet_age, pet_weight);\n          ELSE\n            -- Delete child records in HAS_PET first before deleting from PETS\n            DELETE FROM HAS_PET WHERE PETID = para_petid;\n            DELETE FROM PETS WHERE PETID = para_petid;\n          END IF;\n        END IF;\n      ELSE\n        IF pet_weight > 12 THEN\n          INSERT INTO HAS_PET (STUID, PETID) VALUES (para_stuid + 1, para_petid);\n        ELSE\n          -- Delete child records in HAS_PET first before deleting from STUDENT\n          DELETE FROM HAS_PET WHERE STUID = para_stuid;\n          DELETE FROM STUDENT WHERE STUID = para_stuid;\n        END IF;\n      END IF;\n    ELSE\n      INSERT INTO HAS_PET (STUID, PETID) VALUES (para_stuid, para_petid);\n    END IF;\n  ELSE\n    INSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, MAJOR) VALUES (para_stuid, 'New', 'Student', 19, 600);\n  END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp(2001, 1001, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2002, 1002, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(9999, 9999, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2003, 1003, 0);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2001, 9998, 15);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp' to manage student-pet relationships. Inputs: a pet ID, a student ID, and an age threshold. If the student exists, check for a link to the pet. If a link exists, get the pet's details and decode its type. If the pet's age exceeds the threshold, check if the student has other pets. If they do, delete the link for this pet. If not, check the student's age. If the student is over 20, insert a new pet with an adjusted ID. If 20 or under, delete the pet and all its links. If the pet's age does not exceed the threshold, check its weight. If over 12, insert a new link with an adjusted student ID. If 12 or under, delete the student and all their pet links. If no link exists, create a new link. If the student does not exist, insert a new default student record.",
    "natural_language": "Create procedure 'sp' with pet ID, student ID, and age threshold. If student exists and has pet link: get pet details; if pet age > threshold, delete link if student has other pets, else if student >20 insert new pet, else delete pet. If pet age <= threshold and weight >12, insert new link; else delete student. If no link exists, create link. If student doesn't exist, insert default student.",
    "id": 58
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named relocate_boxes that accepts two parameters: p_source_warehouse and p_target_warehouse, both of which are of type NUMBER. The procedure is designed to move boxes from one warehouse to another. It begins by deleting rows from the BOXES table where the WAREHOUSE column matches the value of p_source_warehouse, but only if there exists at least one row in the WAREHOUSES table where the CODE column matches the value of p_target_warehouse. This ensures that the target warehouse is valid before proceeding with the deletion. After the deletion, the procedure inserts new rows into the BOXES table. These new rows are selected from the BOXES table where the WAREHOUSE column equals p_source_warehouse, and for each selected row, the CODE, CONTENTS, and VALUE columns are copied directly, while the WAREHOUSE column is set to the value of p_target_warehouse. This operation effectively relocates the boxes from the source warehouse to the target warehouse by first removing them from the source and then inserting them with the updated warehouse information.",
    "plsql": "CREATE OR REPLACE PROCEDURE relocate_boxes(p_source_warehouse NUMBER, p_target_warehouse NUMBER)\nIS\nBEGIN\n    DELETE FROM BOXES \n    WHERE WAREHOUSE = p_source_warehouse \n    AND EXISTS (SELECT 1 FROM WAREHOUSES WHERE CODE = p_target_warehouse);\n    \n    INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE)\n    SELECT CODE, CONTENTS, VALUE, p_target_warehouse\n    FROM BOXES\n    WHERE WAREHOUSE = p_source_warehouse;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "BEGIN\n  relocate_boxes(1, 2);\nEND;",
      "BEGIN\n  relocate_boxes(3, 1);\nEND;",
      "BEGIN\n  relocate_boxes(4, 3);\nEND;",
      "BEGIN\n  relocate_boxes(2, 4);\nEND;",
      "BEGIN\n  relocate_boxes(1, 3);\nEND;"
    ],
    "summary": "Create a stored procedure named 'relocate_boxes' to move all boxes from a source warehouse to a target warehouse. Inputs: source and target warehouse codes. First, delete boxes from the source warehouse, but only if the target warehouse exists. Then, insert those boxes into the BOXES table with their warehouse code updated to the target.",
    "natural_language": "Please construct a stored procedure designated as 'relocate_boxes'. The procedure's objective is to transfer all boxes from a specified source warehouse to a designated target warehouse. The required input parameters are the source and target warehouse codes. The procedure must first verify the existence of the target warehouse. Subsequently, it should delete the relevant box records from the source warehouse. Following this deletion, it must insert those same records into the BOXES table, updating the warehouse code to that of the target.",
    "id": 59
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_warehouse_capacity` that accepts two input parameters: `p_warehouse_code` of data type `NUMBER`, representing the unique identifier for a specific warehouse, and `p_new_capacity` of data type `NUMBER`, representing the new capacity value to be assigned to that warehouse. The procedure's primary action is to perform an `UPDATE` operation on the `WAREHOUSES` table. Specifically, it sets the value of the `CAPACITY` column to the value provided by the `p_new_capacity` parameter. This update is conditional and applies only to rows in the `WAREHOUSES` table where the `CODE` column matches the value provided by the `p_warehouse_code` parameter. Furthermore, an additional condition must be met for the update to occur: there must exist at least one record in the `BOXES` table where the `WAREHOUSE` column matches the `p_warehouse_code` parameter. This `EXISTS` subquery effectively checks if the warehouse identified by `p_warehouse_code` currently contains any boxes. If both conditions (matching `CODE` in `WAREHOUSES` and existence of associated boxes in `BOXES`) are true, the `CAPACITY` of that specific warehouse is updated.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_warehouse_capacity(p_warehouse_code NUMBER, p_new_capacity NUMBER)\nIS\nBEGIN\n    UPDATE WAREHOUSES \n    SET CAPACITY = p_new_capacity \n    WHERE CODE = p_warehouse_code \n    AND EXISTS (SELECT 1 FROM BOXES WHERE WAREHOUSE = p_warehouse_code);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 1, p_new_capacity => 10);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 3, p_new_capacity => 5);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 4, p_new_capacity => 8);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 1, p_new_capacity => 12);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 3, p_new_capacity => 6);\nEND;"
    ],
    "summary": "Create a stored procedure named 'update_warehouse_capacity' to update a warehouse's capacity. Inputs: a warehouse code and a new capacity value. Update the warehouse's capacity only if the warehouse exists and currently has at least one box stored in it.",
    "natural_language": "Develop a stored procedure, which should be named 'update_warehouse_capacity', to modify the maximum capacity of a specified warehouse. This procedure must accept two input parameters: the unique identifier code for the warehouse and the new numerical value for its capacity. The update operation should proceed only under the condition that the warehouse in question is present in our records and is currently holding at least one physical box within its storage space.",
    "id": 60
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named adjust_box_value that accepts two input parameters: a numeric parameter p_warehouse_code and a numeric parameter p_value_adjustment. The procedure performs an update operation on the BOXES table. It modifies the VALUE column for every row in the BOXES table by adding the value of the p_value_adjustment parameter to the existing VALUE column. This update is applied only to rows where the WAREHOUSE column value exactly matches the provided p_warehouse_code parameter. Furthermore, the update is conditional and will only affect rows if a corresponding record exists in the WAREHOUSES table; this is enforced by a subquery using the EXISTS clause that selects the constant value 1 from the WAREHOUSES table where its CODE column equals the input p_warehouse_code parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_box_value(p_warehouse_code NUMBER, p_value_adjustment NUMBER)\nIS\nBEGIN\n    UPDATE BOXES \n    SET VALUE = VALUE + p_value_adjustment \n    WHERE WAREHOUSE = p_warehouse_code \n    AND EXISTS (SELECT 1 FROM WAREHOUSES WHERE CODE = p_warehouse_code);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_box_value(1, 50);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_box_value(3, -30);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_box_value(4, 100);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_box_value(2, 25);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_box_value(1, 0);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named adjust_box_value that updates the BOXES table. It adds a specified adjustment value to the VALUE column for all rows where the WAREHOUSE column matches a given warehouse code, but only if that warehouse code exists in the WAREHOUSES table.",
    "natural_language": "Update BOXES.VALUE by adding an adjustment for a given warehouse, if it exists in WAREHOUSES.",
    "id": 61
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named generate_mill_inventory that accepts three input parameters: a string parameter p_mill_type for the type of mill, a numeric parameter p_year_threshold for the built year value, and a string parameter p_architect_name_pattern for a text pattern to match architect names. The procedure first declares four local numeric variables: v_matching_architects, v_mill_capacity, v_year_avg, and v_next_id. It then performs three separate queries: it counts the number of rows in the ARCHITECT table where the NAME column, converted to uppercase, contains the uppercase version of the p_architect_name_pattern string, storing the result in v_matching_architects; it calculates the average BUILT_YEAR from the MILL table for rows where BUILT_YEAR is not null, storing the result in v_year_avg; and it counts the number of rows in the MILL table where the TYPE column equals the p_mill_type parameter, storing the result in v_mill_capacity. Next, it retrieves the next available ID for the MILL table by selecting the maximum value from the ID column, using the NVL function to treat a null result as 0, adding 1, and storing the value in v_next_id. The procedure then enters a loop that iterates over a cursor query selecting the ID and NAME columns from the ARCHITECT table for all rows where the uppercase NAME contains the uppercase p_architect_name_pattern. For each architect record fetched by the loop, it executes an INSERT statement into the MILL table, specifying columns ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, and NOTES. The inserted values are: the current v_next_id for ID; the architect's ID from arch_rec.ID converted to a number using TO_NUMBER for ARCHITECT_ID; a concatenated string 'Generated Mill for ' plus the architect's name for NAME; the literal string 'Auto Location' for LOCATION; the input parameter p_mill_type for TYPE; the input parameter p_year_threshold for BUILT_YEAR; and the literal string 'System Generated Entry' for NOTES. After each insert, it increments the v_next_id variable by 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_mill_inventory(\n    p_mill_type VARCHAR2,\n    p_year_threshold NUMBER,\n    p_architect_name_pattern VARCHAR2\n) IS\n    v_matching_architects NUMBER;\n    v_mill_capacity NUMBER;\n    v_year_avg NUMBER;\n    v_next_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_matching_architects \n    FROM ARCHITECT \n    WHERE UPPER(NAME) LIKE UPPER('%' || p_architect_name_pattern || '%');\n    \n    SELECT AVG(BUILT_YEAR) INTO v_year_avg \n    FROM MILL \n    WHERE BUILT_YEAR IS NOT NULL;\n    \n    SELECT COUNT(*) INTO v_mill_capacity \n    FROM MILL \n    WHERE TYPE = p_mill_type;\n    \n    -- Get the next available ID for MILL table\n    SELECT NVL(MAX(ID), 0) + 1 INTO v_next_id FROM MILL;\n    \n    FOR arch_rec IN (SELECT ID, NAME FROM ARCHITECT WHERE UPPER(NAME) LIKE UPPER('%' || p_architect_name_pattern || '%')) LOOP\n        INSERT INTO MILL (ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, NOTES)\n        VALUES (v_next_id, TO_NUMBER(arch_rec.ID), 'Generated Mill for ' || arch_rec.NAME, 'Auto Location', p_mill_type, p_year_threshold, 'System Generated Entry');\n        v_next_id := v_next_id + 1;\n    END LOOP;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  generate_mill_inventory('Windmill', 1850, 'Frank');\n  COMMIT;\nEND;",
      "BEGIN\n  generate_mill_inventory('Watermill', 1900, 'Hadid');\n  COMMIT;\nEND;",
      "BEGIN\n  generate_mill_inventory('Tide Mill', 1800, 'Gehry');\n  COMMIT;\nEND;",
      "BEGIN\n  generate_mill_inventory('Post Mill', 1750, 'Wright');\n  COMMIT;\nEND;",
      "BEGIN\n  generate_mill_inventory('Smock Mill', 1825, 'a');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named generate_mill_inventory that inserts new mill records. It counts architects matching a name pattern, calculates the average built year from mills, and counts mills of a specified type. It then loops through matching architects, inserting a new mill for each with an auto-generated ID, using the provided mill type and year threshold, and default location/notes.",
    "natural_language": "Create procedure generate_mill_inventory to insert mill records. It counts architects by name pattern, gets average mill year, and counts mills by type. Then, for each matching architect, insert a new mill with auto ID, given type and year threshold, and default location/notes.",
    "id": 62
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_bridge_metrics` that accepts three input parameters: `p_min_length_feet` of type `NUMBER`, `p_location_filter` of type `VARCHAR2`, and `p_architect_nationality` of type `VARCHAR2`. The procedure begins by declaring three local variables: `v_bridge_count` of type `NUMBER`, `v_architect_exists` of type `NUMBER`, and `v_length_sum` of type `NUMBER`. The execution block starts by performing a `SELECT` operation to count the total number of records in the `BRIDGE` table where the `LENGTH_FEET` column is greater than or equal to the value provided in the `p_min_length_feet` parameter. The result of this count is stored into the `v_bridge_count` local variable. Next, another `SELECT` operation is executed to calculate the sum of the `LENGTH_METERS` column from the `BRIDGE` table. This sum is calculated for bridges that are associated with architects whose `NATIONALITY` matches the value provided in the `p_architect_nationality` parameter. This involves an `INNER JOIN` between the `BRIDGE` table (aliased as `B`) and the `ARCHITECT` table (aliased as `A`) on the condition that `B.ARCHITECT_ID` is equal to the numeric conversion of `A.ID` using the `TO_NUMBER()` function. The calculated sum is then stored into the `v_length_sum` local variable. Following this, a `DELETE` operation is performed on the `BRIDGE` table. Rows are deleted if their `LENGTH_FEET` column value is less than the `p_min_length_feet` parameter AND the uppercase version of their `LOCATION` column value, obtained using the `UPPER()` function, contains the uppercase version of the `p_location_filter` parameter as a substring, using the `LIKE` operator with wildcard characters (`%`). Finally, the procedure enters a `FOR` loop that iterates through a cursor. This cursor selects the `ID`, `NAME`, and `LENGTH_METERS` columns from the `BRIDGE` table for all records where the `LENGTH_FEET` column is greater than or equal to the `p_min_length_feet` parameter. For each `bridge_rec` fetched by this loop, a `SELECT` operation is performed to count the number of architects. This count is for architects (aliased as `A`) whose `NATIONALITY` matches the `p_architect_nationality` parameter and who are associated with the current bridge record (`bridge_rec.ID`). This involves an `INNER JOIN` between the `ARCHITECT` table (aliased as `A`) and the `BRIDGE` table (aliased as `B`) on the condition that the numeric conversion of `A.ID` using `TO_NUMBER()` is equal to `B.ARCHITECT_ID`. The `WHERE` clause further filters these results to `B.ID` being equal to `bridge_rec.ID` and `A.NATIONALITY` being equal to `p_architect_nationality`. The result of this count is stored into the `v_architect_exists` local variable. The loop continues until all relevant bridge records have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_bridge_metrics(\n    p_min_length_feet NUMBER,\n    p_location_filter VARCHAR2,\n    p_architect_nationality VARCHAR2\n) IS\n    v_bridge_count NUMBER;\n    v_architect_exists NUMBER;\n    v_length_sum NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_bridge_count \n    FROM BRIDGE \n    WHERE LENGTH_FEET >= p_min_length_feet;\n    \n    SELECT SUM(LENGTH_METERS) INTO v_length_sum \n    FROM BRIDGE B \n    JOIN ARCHITECT A ON B.ARCHITECT_ID = TO_NUMBER(A.ID)\n    WHERE A.NATIONALITY = p_architect_nationality;\n    \n    DELETE FROM BRIDGE \n    WHERE LENGTH_FEET < p_min_length_feet \n    AND UPPER(LOCATION) LIKE UPPER('%' || p_location_filter || '%');\n    \n    FOR bridge_rec IN (SELECT ID, NAME, LENGTH_METERS FROM BRIDGE WHERE LENGTH_FEET >= p_min_length_feet) LOOP\n        SELECT COUNT(*) INTO v_architect_exists \n        FROM ARCHITECT A \n        JOIN BRIDGE B ON TO_NUMBER(A.ID) = B.ARCHITECT_ID\n        WHERE B.ID = bridge_rec.ID AND A.NATIONALITY = p_architect_nationality;\n    END LOOP;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  process_bridge_metrics(200, 'Utah', 'American');\n  COMMIT;\nEND;",
      "BEGIN\n  process_bridge_metrics(100, 'National Park', 'Canadian');\n  COMMIT;\nEND;",
      "BEGIN\n  process_bridge_metrics(300, 'Chad', 'Iraqi, British');\n  COMMIT;\nEND;",
      "BEGIN\n  process_bridge_metrics(150, 'Plateau', 'American');\n  COMMIT;\nEND;",
      "BEGIN\n  process_bridge_metrics(250, 'Zion', 'Canadian');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named process_bridge_metrics that processes bridge data. It counts bridges longer than a minimum length and sums the length in meters for bridges by architects of a specified nationality. It then deletes bridges shorter than the minimum length and located in an area matching a filter. Finally, it loops through remaining long bridges and counts associated architects of the specified nationality for each.",
    "natural_language": "List the bridges longer than a minimum length and sum their length in meters for architects of a specified nationality. Then, delete bridges shorter than the minimum length and located in an area matching a filter. Finally, loop through the remaining long bridges and count associated architects of the specified nationality for each. Name this stored procedure 'process_bridge_metrics'.",
    "id": 63
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_architect_data that accepts three parameters: p_gender_target of type VARCHAR2, p_name_min_length of type NUMBER, and p_nationality_pattern of type VARCHAR2. The procedure begins by declaring several local variables: v_name_length and v_project_count of type NUMBER to store the length of an architect's name and the count of projects associated with an architect, respectively; v_nationality_match of type NUMBER to store the count of architects whose nationality matches a given pattern; and v_new_bridge_id of type NUMBER to store the ID for a new bridge record. The procedure first performs a SELECT operation to count the number of architects in the ARCHITECT table whose NATIONALITY column, converted to uppercase using the UPPER() function, contains the uppercase version of the p_nationality_pattern parameter, storing the result in v_nationality_match. It then enters a loop to iterate over each architect record in the ARCHITECT table where the GENDER column matches the p_gender_target parameter. Within the loop, it calculates the length of the current architect's NAME using the LENGTH() function and stores it in v_name_length. It then performs a SELECT operation to count the number of projects associated with the current architect by checking the ARCHITECT_ID column in both the BRIDGE and MILL tables, using a UNION ALL operation to combine results, and stores the count in v_project_count. The procedure then evaluates two conditions: if the name length is greater than or equal to p_name_min_length and the project count is zero, it deletes the architect's record from the ARCHITECT table using the DELETE statement; if the project count is greater than zero, it generates a new unique ID for a bridge by selecting the maximum ID from the BRIDGE table, using NVL() to handle null values, and incrementing it by one, storing the result in v_new_bridge_id. It then inserts a new record into the BRIDGE table with the generated ID, the current architect's ID, a name constructed by concatenating 'Memorial Bridge for ' with the architect's NAME, a fixed location 'Honor Location', and fixed lengths of 100 meters and 328 feet using the INSERT statement. The loop continues until all relevant architect records have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_architect_data(\n    p_gender_target VARCHAR2,\n    p_name_min_length NUMBER,\n    p_nationality_pattern VARCHAR2\n) IS\n    v_name_length NUMBER;\n    v_project_count NUMBER;\n    v_nationality_match NUMBER;\n    v_new_bridge_id NUMBER; -- Variable to hold the new bridge ID\nBEGIN\n    SELECT COUNT(*) INTO v_nationality_match \n    FROM ARCHITECT \n    WHERE UPPER(NATIONALITY) LIKE UPPER('%' || p_nationality_pattern || '%');\n    \n    FOR arch_rec IN (SELECT ID, NAME, GENDER, NATIONALITY FROM ARCHITECT WHERE GENDER = p_gender_target) LOOP\n        SELECT LENGTH(arch_rec.NAME) INTO v_name_length FROM DUAL;\n        \n        SELECT COUNT(*) INTO v_project_count \n        FROM (SELECT ARCHITECT_ID FROM BRIDGE WHERE ARCHITECT_ID = TO_NUMBER(arch_rec.ID)\n              UNION ALL \n              SELECT ARCHITECT_ID FROM MILL WHERE ARCHITECT_ID = TO_NUMBER(arch_rec.ID));\n        \n        IF v_name_length >= p_name_min_length AND v_project_count = 0 THEN\n            DELETE FROM ARCHITECT WHERE ID = arch_rec.ID;\n        ELSIF v_project_count > 0 THEN\n            -- Generate a unique ID for the new bridge\n            SELECT NVL(MAX(ID), 0) + 1 INTO v_new_bridge_id FROM BRIDGE;\n            \n            INSERT INTO BRIDGE (ID, ARCHITECT_ID, NAME, LOCATION, LENGTH_METERS, LENGTH_FEET)\n            VALUES (v_new_bridge_id, TO_NUMBER(arch_rec.ID), 'Memorial Bridge for ' || arch_rec.NAME, 'Honor Location', 100, 328);\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  consolidate_architect_data('male', 10, 'American');\n  commit;\nEND;",
      "BEGIN\n  consolidate_architect_data('female', 15, 'Canadian');\n  commit;\nEND;",
      "BEGIN\n  consolidate_architect_data('male', 12, 'British');\n  commit;\nEND;",
      "BEGIN\n  consolidate_architect_data('female', 8, 'Iraqi');\n  commit;\nEND;",
      "BEGIN\n  consolidate_architect_data('male', 5, 'American');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named consolidate_architect_data that processes architects. It counts architects with a nationality matching a pattern. It then loops through architects of a specified gender: if their name length meets a minimum and they have zero associated projects (from BRIDGE and MILL tables), delete them; if they have projects, generate a new bridge ID and insert a memorial bridge record for them.",
    "natural_language": "Alright, so we need a stored procedure called consolidate_architect_data to handle architect info. First off, it's gotta count up how many architects have a nationality that fits a certain pattern. Then, it should go through architects of a given gender one by one. For each one, check if their name is long enough and if they've got no projects linked to them (you'll need to look in the BRIDGE and MILL tables for that). If they're project-less, just delete their record. But if they do have projects, you gotta whip up a new bridge ID and stick a memorial bridge entry in for them.",
    "id": 64
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteBookReviews that accepts a single input parameter p_book_id of the NUMBER data type, which is used to identify a specific book, and executes a DELETE operation on the database table named REVIEW, targeting and removing all rows from that table where the value in the column BOOK_ID is exactly equal to the value provided by the input parameter p_book_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteBookReviews(p_book_id IN NUMBER) AS\nBEGIN\n  DELETE FROM REVIEW\n  WHERE BOOK_ID = p_book_id;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteBookReviews(1);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(2);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(3);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(4);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(5);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteBookReviews that deletes all rows from the REVIEW table where the BOOK_ID matches a given input parameter.",
    "natural_language": "Make a stored procedure called DeleteBookReviews that removes a bunch of reviews from the REVIEW table for books that are kind of like the one you give it.",
    "id": 65
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewReview that accepts a single input parameter p_book_id of type NUMBER, which represents the identifier of a book for which a new review record is to be created. The procedure begins by declaring a local variable v_review_id of type NUMBER. It then executes a SELECT statement on the REVIEW table to calculate the next available REVIEW_ID value; this is done by using the NVL function to find the maximum existing value in the REVIEW_ID column, substituting 0 if the column contains no values (i.e., if the table is empty), and then adding 1 to that result, storing the computed value into the local variable v_review_id. Following this calculation, the procedure performs an INSERT operation into the REVIEW table, specifying the columns REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, and RANK. It inserts a single row where the REVIEW_ID is set to the newly generated value from v_review_id, the BOOK_ID is set to the provided input parameter p_book_id, the RATING is set to the numeric literal 5.0, the READERS_IN_MILLION is set to the numeric literal 1.0, and the RANK is set to the numeric literal 100.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewReview(p_book_id IN NUMBER) AS\n  v_review_id NUMBER;\nBEGIN\n  SELECT NVL(MAX(REVIEW_ID), 0) + 1 INTO v_review_id FROM REVIEW;\n  INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK)\n  VALUES (v_review_id, p_book_id, 5.0, 1.0, 100);\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewReview(p_book_id => 1);\nEND;",
      "BEGIN\n  InsertNewReview(p_book_id => 2);\nEND;",
      "BEGIN\n  InsertNewReview(p_book_id => 3);\nEND;",
      "BEGIN\n  InsertNewReview(p_book_id => 4);\nEND;",
      "BEGIN\n  InsertNewReview(p_book_id => 5);\nEND;"
    ],
    "summary": "Create a stored procedure named InsertNewReview that accepts a book ID (NUMBER). It generates the next REVIEW_ID by finding the maximum existing value (or 0 if none) and adding 1. Then it inserts a new review into the REVIEW table with the generated ID, the provided book ID, a rating of 5.0, 1.0 million readers, and a rank of 100.",
    "natural_language": "Create procedure InsertNewReview with book ID parameter. Generate next REVIEW_ID as max existing plus one (or 1 if none). Insert review with new ID, given book ID, rating 5.0, 1M readers, rank 100.",
    "id": 66
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_conference_location that accepts two input parameters: a numeric parameter named p_conference_id and a string parameter named p_location of type VARCHAR2, and executes a single SQL UPDATE operation on the database table named CONFERENCE, specifically modifying the value in the LOCATION column for the row where the CONFERENCE_ID column value exactly matches the value provided in the p_conference_id parameter, setting that LOCATION column to the new string value supplied in the p_location parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_conference_location(p_conference_id NUMBER, p_location VARCHAR2) IS\nBEGIN\n  UPDATE CONFERENCE\n     SET LOCATION = p_location\n   WHERE CONFERENCE_ID = p_conference_id;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_conference_location(1, 'Singapore');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(2, 'Thailand');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(3, 'Australia');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(1, 'Malaysia');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(2, 'South Korea');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_conference_location that accepts a conference ID (NUMBER) and a location (VARCHAR2). It updates the CONFERENCE table, setting the LOCATION to the provided value for the row matching the given conference ID.",
    "natural_language": "Update conference location by ID.",
    "id": 67
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that updates the EDUCATION_SCORE column in the COUNTRIES table by decreasing its value by 2 for each row where the country does not have English as an official language. The procedure does not take any parameters. It performs an UPDATE operation on the COUNTRIES table, specifically targeting the EDUCATION_SCORE column. The condition for the update is determined by a subquery that checks for the existence of English as an official language in the OFFICIAL_LANGUAGES table. The subquery joins the OFFICIAL_LANGUAGES table with the LANGUAGES table using the LANGUAGE_ID column from OFFICIAL_LANGUAGES and the ID column from LANGUAGES. It filters rows where the COUNTRY_ID from OFFICIAL_LANGUAGES matches the ID from COUNTRIES and the NAME column from LANGUAGES, converted to single-byte characters using the TO_SINGLE_BYTE function, equals 'English'. If no such row exists for a given country, the EDUCATION_SCORE for that country is decreased by 2.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_education_for_non_english IS\nBEGIN\n  UPDATE COUNTRIES c\n     SET EDUCATION_SCORE = EDUCATION_SCORE - 2\n   WHERE NOT EXISTS (\n     SELECT 1\n       FROM OFFICIAL_LANGUAGES ol\n       JOIN LANGUAGES l ON ol.LANGUAGE_ID = l.ID\n      WHERE ol.COUNTRY_ID = c.ID\n        AND TO_SINGLE_BYTE(l.NAME) = 'English'\n   );\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_education_for_non_english;\n  commit;\nEND;"
    ],
    "summary": "Create a parameterless stored procedure that updates the COUNTRIES table. It decreases the EDUCATION_SCORE by 2 for each country where English is not listed as an official language. The check uses a subquery joining OFFICIAL_LANGUAGES and LANGUAGES tables, comparing the language name (converted to single-byte) to 'English'.",
    "natural_language": "Decrease the EDUCATION_SCORE by 2 for every country in the COUNTRIES table where English is not an official language. Use a subquery to join the OFFICIAL_LANGUAGES and LANGUAGES tables and check if the single-byte converted language name equals 'English'. Put this logic into a parameterless stored procedure.",
    "id": 68
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `CalculateOrderDelivery` that accepts three input parameters: `p_order_id` of type `NUMBER`, representing the unique identifier of an order; `p_employee_id` of type `NUMBER`, representing the unique identifier of an employee who is a driver; and `p_truck_id` of type `NUMBER`, representing the unique identifier of a truck. The procedure begins by declaring a local variable `v_order_count` of type `NUMBER` to store the count of existing order deliveries. It then executes a `SELECT` statement to count the number of rows in the `ORDER_DELIVERIES` table. This count is stored in the `v_order_count` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows based on two conditions: `ACTUAL_ORDER_ID` must be equal to the value provided in the `p_order_id` input parameter, and `DRIVER_EMPLOYEE_ID` must be equal to the value provided in the `p_employee_id` input parameter. Following this, an `IF` conditional statement checks if the value of `v_order_count` is equal to `0`. If this condition is true, indicating that no existing order delivery record matches the specified order ID and driver employee ID, then an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `ORDER_DELIVERIES` table. The values inserted into the columns are as follows: the `LOCATION_CODE` column receives the literal string 'New Location'; the `ACTUAL_ORDER_ID` column receives the value from the `p_order_id` input parameter; the `DELIVERY_STATUS_CODE` column receives the literal string 'Pending'; the `DRIVER_EMPLOYEE_ID` column receives the value from the `p_employee_id` input parameter; the `TRUCK_ID` column receives the value from the `p_truck_id` input parameter; and the `DELIVERY_DATE` column receives a formatted string representation of the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (current system date and time) into a string with the format 'YYYY-MM-DD HH24:MI:SS'.",
    "plsql": "CREATE OR REPLACE PROCEDURE CalculateOrderDelivery(\n  p_order_id IN NUMBER,\n  p_employee_id IN NUMBER,\n  p_truck_id IN NUMBER\n) AS\nBEGIN\n  DECLARE\n    v_order_count NUMBER;\n  BEGIN\n    SELECT COUNT(*)\n    INTO v_order_count\n    FROM ORDER_DELIVERIES\n    WHERE ACTUAL_ORDER_ID = p_order_id AND DRIVER_EMPLOYEE_ID = p_employee_id;\n\n    IF v_order_count = 0 THEN\n      INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE)\n      VALUES ('New Location', p_order_id, 'Pending', p_employee_id, p_truck_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\n  END;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ORDER_DELIVERIES",
      "CUSTOMERS",
      "CUSTOMER_ADDRESSES",
      "ADDRESSES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "BEGIN\n  CalculateOrderDelivery(1, 6, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(2, 4, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(3, 1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(4, 8, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(5, 3, 7);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named CalculateOrderDelivery that accepts an order ID, an employee ID, and a truck ID (all NUMBER). It checks if an order delivery record already exists for the given order and driver. If not, it inserts a new record into ORDER_DELIVERIES with the provided IDs, a status of 'Pending', a location of 'New Location', and the current date/time formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "How can I create a stored procedure named CalculateOrderDelivery that takes an order ID, an employee ID, and a truck ID (all as NUMBER) to check for an existing order delivery record for that order and driver, and if none exists, inserts a new record into ORDER_DELIVERIES with those IDs, a 'Pending' status, a 'New Location' location, and the current date and time formatted as 'YYYY-MM-DD HH24:MI:SS'?",
    "id": 69
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AssignTruckToOrder that accepts three input parameters: a numeric parameter p_truck_id representing a truck identifier, a numeric parameter p_order_id representing an order identifier, and a string parameter p_location_code representing a location code. The procedure contains a nested PL/SQL block that declares a local numeric variable v_truck_count. It first queries the TRUCKS table to count the number of rows where the TRUCK_ID column matches the input parameter p_truck_id, storing the result into v_truck_count. If the value of v_truck_count is greater than zero, indicating the specified truck exists, the procedure performs an INSERT operation into the ORDER_DELIVERIES table. The inserted row uses the input parameter p_location_code for the LOCATION_CODE column, the input parameter p_order_id for the ACTUAL_ORDER_ID column, the literal string 'Assigned' for the DELIVERY_STATUS_CODE column, a NULL value for the DRIVER_EMPLOYEE_ID column, the input parameter p_truck_id for the TRUCK_ID column, and for the DELIVERY_DATE column, it uses the TO_CHAR function to convert the current system date and time from SYSDATE into a string formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "plsql": "CREATE OR REPLACE PROCEDURE AssignTruckToOrder(\n  p_truck_id IN NUMBER,\n  p_order_id IN NUMBER,\n  p_location_code IN VARCHAR2\n) AS\nBEGIN\n  DECLARE\n    v_truck_count NUMBER;\n  BEGIN\n    SELECT COUNT(*)\n    INTO v_truck_count\n    FROM TRUCKS\n    WHERE TRUCK_ID = p_truck_id;\n\n    IF v_truck_count > 0 THEN\n      INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE)\n      VALUES (p_location_code, p_order_id, 'Assigned', NULL, p_truck_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\n  END;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ORDER_DELIVERIES",
      "CUSTOMERS",
      "CUSTOMER_ADDRESSES",
      "ADDRESSES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "BEGIN\n  AssignTruckToOrder(p_truck_id => 1, p_order_id => 1, p_location_code => '27 City Rd');\nEND;",
      "BEGIN\n  AssignTruckToOrder(p_truck_id => 2, p_order_id => 2, p_location_code => '123 Main St');\nEND;",
      "BEGIN\n  AssignTruckToOrder(p_truck_id => 3, p_order_id => 3, p_location_code => '456 Oak Ave');\nEND;",
      "BEGIN\n  AssignTruckToOrder(p_truck_id => 1, p_order_id => 11, p_location_code => '789 Pine Ln');\nEND;",
      "BEGIN\n  AssignTruckToOrder(p_truck_id => 2, p_order_id => 1, p_location_code => '101 Elm Rd');\nEND;"
    ],
    "summary": "Create a stored procedure named AssignTruckToOrder that accepts a truck ID, an order ID (both NUMBER), and a location code (VARCHAR2). It first checks if the truck exists. If it does, it inserts a record into ORDER_DELIVERIES with the provided data, a status of 'Assigned', a NULL driver ID, and the current date/time formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "How can I create a stored procedure called AssignTruckToOrder that takes a truck ID and an order ID as numbers, along with a location code as a string, checks for the truck's existence, and then inserts a delivery record with 'Assigned' status, a null driver, and the current timestamp?",
    "id": 70
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `CalculateEmployeeUsage` that accepts three input parameters: `p_employee_id` of data type `NUMBER`, representing the unique identifier for an employee; `p_truck_id` of data type `NUMBER`, representing the unique identifier for a truck; and `p_order_id` of data type `NUMBER`, representing the unique identifier for an order. The procedure begins by declaring a local variable named `v_usage_count` of data type `NUMBER` to store the result of a count operation. Subsequently, it executes a `SELECT` statement to count the number of rows in the `ORDER_DELIVERIES` table. This count is performed based on two conditions: the `DRIVER_EMPLOYEE_ID` column must be equal to the value provided in the `p_employee_id` input parameter, AND the `TRUCK_ID` column must be equal to the value provided in the `p_truck_id` input parameter. The result of this count operation is then stored into the `v_usage_count` local variable. Following this, a conditional `IF` statement evaluates whether the value of `v_usage_count` is equal to `0`. If this condition is true (meaning no existing record in `ORDER_DELIVERIES` matches the given employee and truck combination), the procedure proceeds to execute an `INSERT` statement. This `INSERT` statement adds a new row into the `ORDER_DELIVERIES` table. The values inserted into the respective columns are as follows: the `LOCATION_CODE` column receives the string literal `'Default Location'`; the `ACTUAL_ORDER_ID` column receives the value from the `p_order_id` input parameter; the `DELIVERY_STATUS_CODE` column receives the string literal `'Not Used'`; the `DRIVER_EMPLOYEE_ID` column receives the value from the `p_employee_id` input parameter; the `TRUCK_ID` column receives the value from the `p_truck_id` input parameter; and the `DELIVERY_DATE` column receives a formatted string representation of the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (current system date and time) into a string with the format 'YYYY-MM-DD HH24:MI:SS'. If the `v_usage_count` is not equal to `0`, the `INSERT` statement is skipped, and no further action is taken within the procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE CalculateEmployeeUsage(\n  p_employee_id IN NUMBER,\n  p_truck_id IN NUMBER,\n  p_order_id IN NUMBER\n) AS\nBEGIN\n  DECLARE\n    v_usage_count NUMBER;\n  BEGIN\n    SELECT COUNT(*)\n    INTO v_usage_count\n    FROM ORDER_DELIVERIES\n    WHERE DRIVER_EMPLOYEE_ID = p_employee_id AND TRUCK_ID = p_truck_id;\n\n    IF v_usage_count = 0 THEN\n      INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE)\n      VALUES ('Default Location', p_order_id, 'Not Used', p_employee_id, p_truck_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\n  END;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ORDER_DELIVERIES",
      "CUSTOMERS",
      "CUSTOMER_ADDRESSES",
      "ADDRESSES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "BEGIN\n  CalculateEmployeeUsage(1, 10, 5);\nEND;",
      "BEGIN\n  CalculateEmployeeUsage(2, 3, 8);\nEND;",
      "BEGIN\n  CalculateEmployeeUsage(6, 11, 1);\nEND;",
      "BEGIN\n  CalculateEmployeeUsage(4, 10, 3);\nEND;",
      "BEGIN\n  CalculateEmployeeUsage(1, 2, 11);\nEND;"
    ],
    "summary": "Create a stored procedure named CalculateEmployeeUsage that takes an employee ID, truck ID, and order ID as input. It checks if the employee-truck combination exists in the ORDER_DELIVERIES table. If not found, it inserts a new record with the provided order ID, default location, 'Not Used' status, and the current timestamp.",
    "natural_language": "Develop a stored procedure called CalculateEmployeeUsage, which is designed to accept three distinct input parameters: an employee ID, a truck ID, and an order ID. This procedure will meticulously verify whether the specific pairing of the provided employee and truck is already documented within the ORDER_DELIVERIES table. In the event that this particular combination is not located, the procedure will proceed to insert a completely new record. This new entry will incorporate the supplied order ID, a predetermined default location, a status explicitly set to 'Not Used', and will automatically capture the precise current timestamp for the insertion.",
    "id": 71
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AssignEmployeeToOrder that accepts three parameters: p_employee_id of type NUMBER, p_order_id of type NUMBER, and p_location_code of type VARCHAR2. The procedure begins by declaring a local variable v_employee_count of type NUMBER. It then executes a SELECT statement to count the number of rows in the EMPLOYEES table where the EMPLOYEE_ID column matches the value of the p_employee_id parameter, storing the result in the v_employee_count variable. Following this, the procedure evaluates an IF conditional statement to check if v_employee_count is greater than zero, indicating that an employee with the specified ID exists in the EMPLOYEES table. If this condition is true, the procedure performs an INSERT operation into the ORDER_DELIVERIES table, adding a new row with the following values: p_location_code for the LOCATION_CODE column, p_order_id for the ACTUAL_ORDER_ID column, the string 'Assigned' for the DELIVERY_STATUS_CODE column, p_employee_id for the DRIVER_EMPLOYEE_ID column, NULL for the TRUCK_ID column, and the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' for the DELIVERY_DATE column using the TO_CHAR function applied to SYSDATE.",
    "plsql": "CREATE OR REPLACE PROCEDURE AssignEmployeeToOrder(\n  p_employee_id IN NUMBER,\n  p_order_id IN NUMBER,\n  p_location_code IN VARCHAR2\n) AS\nBEGIN\n  DECLARE\n    v_employee_count NUMBER;\n  BEGIN\n    SELECT COUNT(*)\n    INTO v_employee_count\n    FROM EMPLOYEES\n    WHERE EMPLOYEE_ID = p_employee_id;\n\n    IF v_employee_count > 0 THEN\n      INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE)\n      VALUES (p_location_code, p_order_id, 'Assigned', p_employee_id, NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\n  END;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ORDER_DELIVERIES",
      "CUSTOMERS",
      "CUSTOMER_ADDRESSES",
      "ADDRESSES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "BEGIN\n  AssignEmployeeToOrder(1, 11, '27 City Rd');\n  COMMIT;\nEND;",
      "BEGIN\n  AssignEmployeeToOrder(2, 3, 'Main Warehouse');\n  COMMIT;\nEND;",
      "BEGIN\n  AssignEmployeeToOrder(3, 1, 'Downtown Depot');\n  COMMIT;\nEND;",
      "BEGIN\n  AssignEmployeeToOrder(4, 5, 'Northside Terminal');\n  COMMIT;\nEND;",
      "BEGIN\n  AssignEmployeeToOrder(6, 8, 'Southgate Logistics');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named AssignEmployeeToOrder that takes an employee ID, order ID, and location code as input. It verifies the employee exists in the EMPLOYEES table. If valid, it inserts a record into ORDER_DELIVERIES with the provided details, 'Assigned' status, NULL truck ID, and the current timestamp.",
    "natural_language": "Hey, can you whip up a stored procedure called AssignEmployeeToOrder? It needs to take an employee ID, an order ID, and a location code. First off, it's gotta check if that employee is actually in the EMPLOYEES table. If they're good to go, then pop a new record into the ORDER_DELIVERIES table. Use the details we gave it, set the status to 'Assigned', leave the truck ID as NULL for now, and stamp it with the current date and time.",
    "id": 72
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_department_by_ranking` that accepts two input parameters: `p_ranking_low` of data type `NUMBER` and `p_ranking_high` of data type `NUMBER`. The purpose of this procedure is to remove records from the `DEPARTMENT` table. Specifically, it performs a `DELETE` operation on the `DEPARTMENT` table. The deletion is conditional, targeting only those rows where the value in the `RANKING` column is within the inclusive range defined by the input parameters `p_ranking_low` and `p_ranking_high`. This means that any row in the `DEPARTMENT` table where the `RANKING` column's value is greater than or equal to `p_ranking_low` AND less than or equal to `p_ranking_high` will be permanently removed from the table.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_department_by_ranking(p_ranking_low NUMBER, p_ranking_high NUMBER)\nIS\nBEGIN\n    DELETE FROM DEPARTMENT\n    WHERE RANKING BETWEEN p_ranking_low AND p_ranking_high;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  delete_department_by_ranking(1, 2);\n  commit;\nEND;",
      "BEGIN\n  delete_department_by_ranking(2, 3);\n  commit;\nEND;",
      "BEGIN\n  delete_department_by_ranking(1, 3);\n  commit;\nEND;",
      "BEGIN\n  delete_department_by_ranking(1, 1);\n  commit;\nEND;",
      "BEGIN\n  delete_department_by_ranking(2, 2);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named delete_department_by_ranking that takes low and high ranking values as input. It deletes all records from the DEPARTMENT table where the RANKING column falls within the specified inclusive range.",
    "natural_language": "How can I create a stored procedure called delete_department_by_ranking that deletes all records from the DEPARTMENT table where the RANKING column is between a given low and high value, inclusive?",
    "id": 73
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `adjust_employee_count` that accepts two input parameters: `p_dept_id` of data type `NUMBER`, which represents the unique identifier for a department, and `p_factor` of data type `NUMBER`, which represents a multiplicative factor to be applied to the current number of employees. The procedure begins by declaring a local variable `v_current_employees` of data type `NUMBER` to temporarily store the retrieved employee count. It then executes a `SELECT` statement to retrieve the value from the `NUM_EMPLOYEES` column of the `DEPARTMENT` table. This retrieved value is stored into the `v_current_employees` variable. The selection is constrained by a `WHERE` clause, ensuring that only the row where the `DEPARTMENT_ID` column matches the value provided in the `p_dept_id` input parameter is considered. Following this, the procedure performs an `UPDATE` operation on the `DEPARTMENT` table. In this update, the `NUM_EMPLOYEES` column is set to a new value. This new value is calculated by multiplying the `v_current_employees` variable (which holds the original number of employees for the specified department) by the `p_factor` input parameter, and then rounding the result to the nearest whole number using the `ROUND` function. This update is also constrained by a `WHERE` clause, ensuring that only the row where the `DEPARTMENT_ID` column matches the value provided in the `p_dept_id` input parameter is modified.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_employee_count(p_dept_id NUMBER, p_factor NUMBER)\nIS\n    v_current_employees NUMBER;\nBEGIN\n    SELECT NUM_EMPLOYEES INTO v_current_employees\n    FROM DEPARTMENT\n    WHERE DEPARTMENT_ID = p_dept_id;\n    \n    UPDATE DEPARTMENT\n    SET NUM_EMPLOYEES = ROUND(v_current_employees * p_factor)\n    WHERE DEPARTMENT_ID = p_dept_id;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_employee_count(1, 1.1);\nEND;",
      "BEGIN\n  adjust_employee_count(2, 0.9);\nEND;",
      "BEGIN\n  adjust_employee_count(3, 1.05);\nEND;",
      "BEGIN\n  adjust_employee_count(1, 0.8);\nEND;",
      "BEGIN\n  adjust_employee_count(2, 1.2);\nEND;"
    ],
    "summary": "Create a stored procedure named adjust_employee_count that takes a department ID and a factor as input. It retrieves the current employee count for that department, multiplies it by the factor, rounds the result, and updates the NUM_EMPLOYEES column with the new value.",
    "natural_language": "Create procedure adjust_employee_count to update NUM_EMPLOYEES by multiplying current count by a factor for a given department.",
    "id": 74
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `validate_department_creation` that accepts two input parameters: `p_year_threshold` of type `VARCHAR2` and `p_min_employees` of type `NUMBER`. The purpose of this procedure is to identify and subsequently manage departments that meet specific criteria related to their creation year and number of employees.\n\nThe procedure begins by declaring a local variable `v_count` of type `NUMBER`, which will be used to store the count of departments matching the specified conditions.\n\nThe first operation performed is a `SELECT` statement. This statement queries the `DEPARTMENT` table to count the number of records that satisfy two conditions. The first condition checks if the `CREATION` column, after being explicitly converted to a `NUMBER` using the `TO_NUMBER()` function, is strictly less than the value of the `p_year_threshold` parameter, which is also explicitly converted to a `NUMBER` using `TO_NUMBER()`. The second condition checks if the `NUM_EMPLOYEES` column is strictly less than the value of the `p_min_employees` parameter. The result of this count is then stored into the `v_count` variable.\n\nFollowing this `SELECT` operation, a conditional block (`IF v_count > 0 THEN ... END IF;`) is executed. This block checks if the value stored in `v_count` is greater than zero. If `v_count` is indeed greater than zero, indicating that at least one department met the specified criteria, then a `DELETE` operation is performed.\n\nThe `DELETE` statement targets the `MANAGEMENT` table. Rows are deleted from the `MANAGEMENT` table where the `DEPARTMENT_ID` column matches any `DEPARTMENT_ID` found in a subquery. This subquery selects `DEPARTMENT_ID` from the `DEPARTMENT` table, applying the exact same two conditions as the initial `SELECT` statement: `TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)` and `NUM_EMPLOYEES < p_min_employees`. This effectively deletes all management records associated with departments that were created before the `p_year_threshold` and have fewer than `p_min_employees`.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_department_creation(p_year_threshold VARCHAR2, p_min_employees NUMBER)\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM DEPARTMENT\n    WHERE TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)\n    AND NUM_EMPLOYEES < p_min_employees;\n    \n    IF v_count > 0 THEN\n        DELETE FROM MANAGEMENT\n        WHERE DEPARTMENT_ID IN (\n            SELECT DEPARTMENT_ID\n            FROM DEPARTMENT\n            WHERE TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)\n            AND NUM_EMPLOYEES < p_min_employees\n        );\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  validate_department_creation('1900', 1000);\nEND;",
      "BEGIN\n  validate_department_creation('1950', 50000);\nEND;",
      "BEGIN\n  validate_department_creation('1800', 100);\nEND;",
      "BEGIN\n  validate_department_creation('2000', 200000);\nEND;",
      "BEGIN\n  validate_department_creation('1850', 5000);\nEND;"
    ],
    "summary": "Create a stored procedure named validate_department_creation that takes a year threshold and a minimum employee count as input. It counts departments created before the threshold with fewer than the minimum employees. If any are found, it deletes their associated records from the MANAGEMENT table.",
    "natural_language": "Create a stored procedure called validate_department_creation that uses a somewhat older year and a not-too-high employee number as parameters. It should figure out roughly how many departments were set up a while back, specifically those that don't have very many people working in them. If it finds a few such departments, it needs to clean up their related entries in the MANAGEMENT table.",
    "id": 75
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_party_payment_method` that accepts four parameters: `p_party_id` of type `NUMBER`, `p_new_payment_method` of type `VARCHAR2`, `p_email_filter` of type `VARCHAR2`, and `o_rows_updated` of type `NUMBER` which is an `OUT` parameter. The purpose of this procedure is to modify existing records within the `PARTIES` table. Specifically, it performs an `UPDATE` operation on the `PARTIES` table. For each row that satisfies the specified conditions, the `PAYMENT_METHOD_CODE` column will be set to the value provided by the `p_new_payment_method` parameter. The conditions for updating a row are as follows: the `PARTY_ID` column must exactly match the value provided by the `p_party_id` parameter, AND the `PARTY_EMAIL` column must contain the substring specified by the `p_email_filter` parameter. The `LIKE` operator is used for this substring matching, with wildcard characters (`%`) prepended and appended to the `p_email_filter` value, meaning the `PARTY_EMAIL` can contain the filter string anywhere within its value. After the `UPDATE` statement completes, the procedure assigns the number of rows that were successfully updated by the `UPDATE` statement to the `o_rows_updated` `OUT` parameter using the `SQL%ROWCOUNT` attribute.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_party_payment_method(p_party_id NUMBER, p_new_payment_method VARCHAR2, p_email_filter VARCHAR2, o_rows_updated OUT NUMBER)\nIS\nBEGIN\n    UPDATE PARTIES \n    SET PAYMENT_METHOD_CODE = p_new_payment_method \n    WHERE PARTY_ID = p_party_id \n    AND PARTY_EMAIL LIKE '%' || p_email_filter || '%';\n    o_rows_updated := SQL%ROWCOUNT;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS",
      "SERVICES"
    ],
    "call_sqls": [
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(1, 'Credit Card', 'enrico09', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(2, 'Cheque', 'brakus.aliya', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(3, 'Credit Card', 'frida57', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(1, 'Cheque', 'example.com', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(2, 'Credit Card', 'example.org', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;"
    ],
    "summary": "Create a stored procedure named update_party_payment_method that updates the PAYMENT_METHOD_CODE in the PARTIES table where PARTY_ID matches the input ID and PARTY_EMAIL contains a specified substring. Return the number of updated rows via an OUT parameter.",
    "natural_language": "How can I create a stored procedure called update_party_payment_method that updates the PAYMENT_METHOD_CODE in the PARTIES table for a given party ID and where the party's email contains a specific substring, and how do I return the count of affected rows through an OUT parameter?",
    "id": 76
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateBoxValue that accepts three parameters: p_box_code of type VARCHAR2, p_new_value of type NUMBER, and p_old_value of type OUT NUMBER, along with a fourth parameter p_updated of type OUT VARCHAR2. The procedure begins by selecting the VALUE column from the BOXES table where the CODE column matches the input parameter p_box_code, and assigns this selected VALUE to the output parameter p_old_value. It then updates the VALUE column in the BOXES table to the value provided in the p_new_value parameter for the row where the CODE column equals p_box_code. After successfully updating, it sets the output parameter p_updated to 'YES'. If no row is found with the specified CODE, the NO_DATA_FOUND exception is triggered, and the procedure sets the p_updated parameter to 'NO'.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateBoxValue(\n    p_box_code IN VARCHAR2,\n    p_new_value IN NUMBER,\n    p_old_value OUT NUMBER,\n    p_updated OUT VARCHAR2\n) AS\nBEGIN\n    SELECT VALUE INTO p_old_value FROM BOXES WHERE CODE = p_box_code;\n    UPDATE BOXES SET VALUE = p_new_value WHERE CODE = p_box_code;\n    p_updated := 'YES';\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        p_updated := 'NO';\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('0MN7', 200, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('4H8P', 300, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('4RT3', 220, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('0MN7', 250, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('4H8P', 180, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateBoxValue that retrieves the current VALUE from the BOXES table for a given CODE, updates it to a new value, and returns the old value and a 'YES'/'NO' success flag via OUT parameters.",
    "natural_language": "Please construct a stored procedure designated as 'UpdateBoxValue'. This procedure shall retrieve the existing VALUE entry from the BOXES table corresponding to a specified CODE. It must subsequently update this entry to a new provided value. The procedure is required to output the previous value along with a success indicator of 'YES' or 'NO' through designated OUT parameters.",
    "id": 77
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named TransferBox that accepts four parameters: an input parameter p_box_code of type VARCHAR2 representing the unique identifier of a box, an input parameter p_new_warehouse of type NUMBER representing the target warehouse identifier, an output parameter p_old_warehouse of type NUMBER to return the original warehouse location of the box, and an output parameter p_transferred of type VARCHAR2 to indicate the success or failure of the operation. The procedure first executes a SELECT statement to query the BOXES table, retrieving the value from the WAREHOUSE column for the specific row where the CODE column matches the input parameter p_box_code, and assigns this retrieved value to the output parameter p_old_warehouse. It then executes an UPDATE statement on the BOXES table, setting the WAREHOUSE column to the value of the input parameter p_new_warehouse for the row where the CODE column equals p_box_code. Following the update, the procedure sets the output parameter p_transferred to the string literal 'YES'. If the initial SELECT statement finds no rows in the BOXES table with a CODE matching p_box_code, a NO_DATA_FOUND exception is raised, and the exception handler sets the p_transferred output parameter to the string literal 'NO' without modifying the p_old_warehouse parameter or executing the UPDATE statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE TransferBox(\n    p_box_code IN VARCHAR2,\n    p_new_warehouse IN NUMBER,\n    p_old_warehouse OUT NUMBER,\n    p_transferred OUT VARCHAR2\n) AS\nBEGIN\n    SELECT WAREHOUSE INTO p_old_warehouse FROM BOXES WHERE CODE = p_box_code;\n    UPDATE BOXES SET WAREHOUSE = p_new_warehouse WHERE CODE = p_box_code;\n    p_transferred := 'YES';\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        p_transferred := 'NO';\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_warehouse NUMBER;\n  v_transferred VARCHAR2(3);\nBEGIN\n  TransferBox('0MN7', 2, v_old_warehouse, v_transferred);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_warehouse NUMBER;\n  v_transferred VARCHAR2(3);\nBEGIN\n  TransferBox('4H8P', 3, v_old_warehouse, v_transferred);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_warehouse NUMBER;\n  v_transferred VARCHAR2(3);\nBEGIN\n  TransferBox('4RT3', 1, v_old_warehouse, v_transferred);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_warehouse NUMBER;\n  v_transferred VARCHAR2(3);\nBEGIN\n  TransferBox('0MN7', 1, v_old_warehouse, v_transferred);\n  COMMIT;\nEND;",
      "DECLARE\n  v_old_warehouse NUMBER;\n  v_transferred VARCHAR2(3);\nBEGIN\n  TransferBox('4H8P', 4, v_old_warehouse, v_transferred);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named TransferBox that retrieves the current WAREHOUSE location for a given box CODE, updates it to a new warehouse, and returns the old location and a 'YES'/'NO' transfer status via OUT parameters.",
    "natural_language": "Hey, can you whip up a stored procedure called TransferBox? It needs to grab where a box (using its CODE) is currently stashed in the WAREHOUSE, move it to a new spot, and then spit back the old location and whether the transfer went through ('YES' or 'NO') using OUT parameters.",
    "id": 78
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_city_data that accepts three parameters: p_city_code of type VARCHAR2, p_distance_threshold of type NUMBER, and p_operation_mode of type NUMBER. The procedure begins by checking if a city with the code p_city_code exists in the CITY table by counting the rows where CITY_CODE matches p_city_code and storing the result in the variable v_city_exists. If no such city exists (v_city_exists equals 0), it inserts a new row into the CITY table with CITY_CODE set to p_city_code, CITY_NAME set to 'New City', STATE set to 'XX', COUNTRY set to 'USA', and both LATITUDE and LONGITUDE set to 0. If the city exists and p_operation_mode equals 1, it counts the number of rows in the DIRECT_DISTANCE table where either CITY1_CODE or CITY2_CODE matches p_city_code and stores the count in v_distance_count. If p_operation_mode equals 2, it deletes rows from the DIRECT_DISTANCE table where either CITY1_CODE or CITY2_CODE matches p_city_code and the DISTANCE is greater than p_distance_threshold. If p_operation_mode equals 3, it inserts new rows into the DIRECT_DISTANCE table with CITY1_CODE set to p_city_code, CITY2_CODE set to CITY_CODE from the CITY table where CITY_CODE does not equal p_city_code, and DISTANCE set to p_distance_threshold, limiting the insertion to 3 rows using ROWNUM. If p_operation_mode equals 4, it counts the number of students in the STUDENT table where CITY_CODE matches p_city_code and stores the count in v_student_count. If p_operation_mode equals 5, it deletes students from the STUDENT table where CITY_CODE matches p_city_code and AGE is greater than 25. If none of the specified operation modes match, it inserts a new row into the STUDENT table with STUID set to 9999, LNAME set to 'Generated', FNAME set to 'Student', AGE set to 20, SEX set to 'M', MAJOR set to 700, ADVISOR set to 8000, and CITY_CODE set to p_city_code. After executing the operation based on p_operation_mode, the procedure checks if p_operation_mode is even using the MOD function. If it is even, it updates the CITY table by increasing the LATITUDE by 0.1 for the city with CITY_CODE matching p_city_code. If p_operation_mode is odd, it deletes a city from the CITY table where CITY_CODE is not present in the STUDENT table and not present as CITY1_CODE in the DIRECT_DISTANCE table, limiting the deletion to one row using ROWNUM.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_city_data(\n    p_city_code VARCHAR2,\n    p_distance_threshold NUMBER,\n    p_operation_mode NUMBER\n) IS\n    v_city_exists NUMBER;\n    v_distance_count NUMBER;\n    v_student_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_city_exists\n    FROM CITY\n    WHERE CITY_CODE = p_city_code;\n    \n    IF v_city_exists = 0 THEN\n        INSERT INTO CITY (CITY_CODE, CITY_NAME, STATE, COUNTRY, LATITUDE, LONGITUDE)\n        VALUES (p_city_code, 'New City', 'XX', 'USA', 0, 0);\n    ELSIF p_operation_mode = 1 THEN\n        SELECT COUNT(*) INTO v_distance_count\n        FROM DIRECT_DISTANCE\n        WHERE CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code;\n    ELSIF p_operation_mode = 2 THEN\n        DELETE FROM DIRECT_DISTANCE\n        WHERE (CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code)\n        AND DISTANCE > p_distance_threshold;\n    ELSIF p_operation_mode = 3 THEN\n        INSERT INTO DIRECT_DISTANCE (CITY1_CODE, CITY2_CODE, DISTANCE)\n        SELECT p_city_code, CITY_CODE, p_distance_threshold\n        FROM CITY\n        WHERE CITY_CODE != p_city_code AND ROWNUM <= 3;\n    ELSIF p_operation_mode = 4 THEN\n        SELECT COUNT(*) INTO v_student_count\n        FROM STUDENT\n        WHERE CITY_CODE = p_city_code;\n    ELSIF p_operation_mode = 5 THEN\n        DELETE FROM STUDENT\n        WHERE CITY_CODE = p_city_code AND AGE > 25;\n    ELSE\n        INSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, SEX, MAJOR, ADVISOR, CITY_CODE)\n        VALUES (9999, 'Generated', 'Student', 20, 'M', 700, 8000, p_city_code);\n    END IF;\n    \n    IF MOD(p_operation_mode, 2) = 0 THEN\n        UPDATE CITY\n        SET LATITUDE = LATITUDE + 0.1\n        WHERE CITY_CODE = p_city_code;\n    ELSE\n        DELETE FROM CITY\n        WHERE CITY_CODE NOT IN (SELECT DISTINCT CITY_CODE FROM STUDENT)\n        AND CITY_CODE NOT IN (SELECT DISTINCT CITY1_CODE FROM DIRECT_DISTANCE)\n        AND ROWNUM = 1;\n    END IF;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  manage_city_data('NYC', 100, 0);\nEND;",
      "BEGIN\n  manage_city_data('BAL', 500, 1);\nEND;",
      "BEGIN\n  manage_city_data('PIT', 200, 2);\nEND;",
      "BEGIN\n  manage_city_data('PHL', 150, 3);\nEND;",
      "BEGIN\n  manage_city_data('WAS', 300, 5);\nEND;"
    ],
    "summary": "Create a stored procedure named manage_city_data that performs different operations based on an operation mode: insert a new city if it doesn't exist; for mode 1, count related distances; mode 2, delete distances above a threshold; mode 3, insert up to 3 new distance records; mode 4, count students; mode 5, delete students over age 25; default mode, insert a generated student. Finally, update latitude for even modes or delete an unused city for odd modes.",
    "natural_language": "Hey, can you whip up a stored procedure called manage_city_data? It should do different stuff depending on what mode you give it. Basically, first off, it should add a new city if that city isn't already there. Then, if the mode is 1, count up all the related distances. For mode 2, get rid of any distances that are above a certain limit. Mode 3 is for popping in up to three new distance records. If it's mode 4, count how many students there are. Mode 5 means deleting any students who are over 25 years old. And if it's any other mode (the default), just insert a new, made-up student. Oh, and one last thing: for even-numbered modes, update the latitude, and for odd-numbered modes, delete a city that's just sitting there unused.",
    "id": 79
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `distance_management` that accepts two input parameters: `p_city_code` of type `VARCHAR2`, representing a city's unique identifier, and `p_distance_limit` of type `NUMBER`, representing a numerical distance threshold.\n\nThe procedure begins by declaring three local variables: `v_distance_count` of type `NUMBER`, initialized to 0, intended to store a count of distances; `v_city_exists` of type `NUMBER`, intended to store a count indicating the existence of a city; and `v_student_count` of type `NUMBER`, intended to store a count of students.\n\nFirst, the procedure attempts to determine if a city with the provided `p_city_code` already exists in the `CITY` table. It executes a `SELECT COUNT(*)` statement, storing the result into the `v_city_exists` variable, from the `CITY` table where the `CITY_CODE` column matches the `p_city_code` input parameter.\n\nNext, a conditional block is executed based on the value of `v_city_exists`.\nIf `v_city_exists` is equal to 0 (meaning the city does not exist), the procedure performs an `INSERT` operation into the `CITY` table. It inserts a new row with the `CITY_CODE` set to `p_city_code`, `CITY_NAME` set to the literal string 'New City', `STATE` set to the literal string 'XX', `COUNTRY` set to the literal string 'USA', `LATITUDE` set to the numeric value 0, and `LONGITUDE` set to the numeric value 0.\n\nIf `v_city_exists` is not 0 (meaning the city exists), an `ELSIF` condition is evaluated: `MOD(p_distance_limit, 3) = 0`. This checks if the remainder of `p_distance_limit` divided by 3 is equal to 0.\nIf this condition is true, the procedure first executes a `SELECT COUNT(*)` statement, storing the result into the `v_distance_count` variable, from the `DIRECT_DISTANCE` table. The count includes rows where either the `CITY1_CODE` column matches `p_city_code` or the `CITY2_CODE` column matches `p_city_code`. Following this, it performs a `DELETE` operation on the `DIRECT_DISTANCE` table. It removes rows where the `CITY1_CODE` column matches `p_city_code` or the `CITY2_CODE` column matches `p_city_code`, AND the `DISTANCE` column is greater than the `p_distance_limit` input parameter.\n\nIf the `ELSIF` condition `MOD(p_distance_limit, 3) = 0` is false, the `ELSE` block is executed. In this block, the procedure performs an `INSERT` operation into the `DIRECT_DISTANCE` table. It inserts new rows with `CITY1_CODE` set to `p_city_code`, `CITY2_CODE` set to the `CITY_CODE` from the `CITY` table, and `DISTANCE` set to `p_distance_limit`. The rows to be inserted are selected from the `CITY` table where the `CITY_CODE` column is not equal to `p_city_code` and the `ROWNUM` pseudocolumn is less than or equal to 3, effectively selecting up to 3 distinct cities (excluding the input city) to create direct distance entries.\n\nAfter this initial conditional logic, the procedure proceeds to count students. It executes a `SELECT COUNT(*)` statement, storing the result into the `v_student_count` variable, from the `STUDENT` table where the `CITY_CODE` column matches the `p_city_code` input parameter.\n\nFinally, another conditional block is executed.\nIf `v_distance_count` (which was populated only if `MOD(p_distance_limit, 3) = 0` was true earlier) is greater than 5, the procedure performs an `UPDATE` operation on the `CITY` table. It sets the `LONGITUDE` column to its current value plus 0.5 for the row where the `CITY_CODE` column matches `p_city_code`.\n\nIf `v_distance_count` is not greater than 5, an `ELSIF` condition is evaluated: `v_student_count = 0`.\nIf this condition is true (meaning no students are associated with the city), the procedure performs two `DELETE` operations. First, it deletes rows from the `DIRECT_DISTANCE` table where either the `CITY1_CODE` column matches `p_city_code` or the `CITY2_CODE` column matches `p_city_code`. Second, it deletes rows from the `CITY` table where the `CITY_CODE` column matches `p_city_code`.",
    "plsql": "CREATE OR REPLACE PROCEDURE distance_management(\n    p_city_code VARCHAR2,\n    p_distance_limit NUMBER\n) IS\n    v_distance_count NUMBER := 0;\n    v_city_exists NUMBER;\n    v_student_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_city_exists\n    FROM CITY\n    WHERE CITY_CODE = p_city_code;\n    \n    IF v_city_exists = 0 THEN\n        INSERT INTO CITY (CITY_CODE, CITY_NAME, STATE, COUNTRY, LATITUDE, LONGITUDE)\n        VALUES (p_city_code, 'New City', 'XX', 'USA', 0, 0);\n    ELSIF MOD(p_distance_limit, 3) = 0 THEN\n        SELECT COUNT(*) INTO v_distance_count\n        FROM DIRECT_DISTANCE\n        WHERE CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code;\n        \n        DELETE FROM DIRECT_DISTANCE\n        WHERE (CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code)\n        AND DISTANCE > p_distance_limit;\n    ELSE\n        INSERT INTO DIRECT_DISTANCE (CITY1_CODE, CITY2_CODE, DISTANCE)\n        SELECT p_city_code, CITY_CODE, p_distance_limit\n        FROM CITY\n        WHERE CITY_CODE != p_city_code AND ROWNUM <= 3;\n    END IF;\n    \n    SELECT COUNT(*) INTO v_student_count\n    FROM STUDENT\n    WHERE CITY_CODE = p_city_code;\n    \n    IF v_distance_count > 5 THEN\n        UPDATE CITY\n        SET LONGITUDE = LONGITUDE + 0.5\n        WHERE CITY_CODE = p_city_code;\n    ELSIF v_student_count = 0 THEN\n        DELETE FROM DIRECT_DISTANCE\n        WHERE CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code;\n        \n        DELETE FROM CITY\n        WHERE CITY_CODE = p_city_code;\n    END IF;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  distance_management('BAL', 100);\n  COMMIT;\nEND;",
      "BEGIN\n  distance_management('NYC', 150);\n  COMMIT;\nEND;",
      "BEGIN\n  distance_management('PIT', 99);\n  COMMIT;\nEND;",
      "BEGIN\n  distance_management('LAX', 300);\n  COMMIT;\nEND;",
      "BEGIN\n  distance_management('CHI', 120);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named distance_management that inserts a new city if the provided code doesn't exist. If it exists and the distance limit is divisible by 3, count and delete distances greater than the limit; otherwise, insert up to 3 new distance records. Then count students for the city. If the distance count exceeds 5, update the city's longitude; if no students exist, delete all related distances and the city itself.",
    "natural_language": "How can I create a stored procedure called distance_management that first checks if a city code exists? If it doesn't, it should insert the new city. If it does exist and the distance limit is divisible by 3, how many distances greater than the limit should be counted and deleted? Otherwise, how should it insert up to three new distance records? After that, how many students are associated with the city? If the distance count exceeds 5, how should the city's longitude be updated? Finally, if no students exist for the city, how should all related distances and the city itself be deleted?",
    "id": 80
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_manage_book_reviews that accepts three parameters: para_book_id of type NUMBER representing the identifier of a book, para_rating of type NUMBER representing the rating of the book, and para_readers of type NUMBER representing the number of readers in millions. The procedure begins by selecting the count of reviews for the specified book_id from the REVIEW table and stores this count in the variable v_review_count. If v_review_count is greater than zero, indicating that reviews exist for the book, it updates the REVIEW table by setting the RATING column to para_rating and the READERS_IN_MILLION column to para_readers for the row where BOOK_ID matches para_book_id. If no reviews exist, it calculates the next review ID by selecting the maximum REVIEW_ID from the REVIEW table, using NVL to handle nulls, adds one to this value, and stores it in v_next_id. It then inserts a new row into the REVIEW table with REVIEW_ID set to v_next_id, BOOK_ID set to para_book_id, RATING set to para_rating, READERS_IN_MILLION set to para_readers, and RANK set to the floor value of para_rating multiplied by ten. The procedure includes conditional logic to delete any review from the REVIEW table where BOOK_ID matches para_book_id and RATING is less than five if para_rating is less than five. Additionally, it updates the RANK column by decrementing its value by one for rows where BOOK_ID matches para_book_id and READERS_IN_MILLION is greater than five if para_readers is greater than five. The procedure handles exceptions by rolling back any changes and re-raising the exception.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_book_reviews(para_book_id NUMBER, para_rating NUMBER, para_readers NUMBER) IS\n  v_review_count NUMBER;\n  v_next_id NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_review_count FROM REVIEW WHERE BOOK_ID = para_book_id;\n  \n  IF v_review_count > 0 THEN\n    UPDATE REVIEW SET RATING = para_rating, READERS_IN_MILLION = para_readers WHERE BOOK_ID = para_book_id;\n  ELSE\n    SELECT NVL(MAX(REVIEW_ID), 0) + 1 INTO v_next_id FROM REVIEW;\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) \n    VALUES (v_next_id, para_book_id, para_rating, para_readers, FLOOR(para_rating * 10));\n  END IF;\n  \n  IF para_rating < 5 THEN\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND RATING < 5;\n  END IF;\n  \n  IF para_readers > 5 THEN\n    UPDATE REVIEW SET RANK = RANK - 1 WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION > 5;\n  END IF;\n  \n  COMMIT;\nEXCEPTION\n  WHEN OTHERS THEN\n    ROLLBACK;\n    RAISE;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_book_reviews(1, 8.5, 4);\nEND;",
      "BEGIN\n  sp_manage_book_reviews(2, 4.2, 7);\nEND;",
      "BEGIN\n  sp_manage_book_reviews(3, 9.1, 3);\nEND;",
      "BEGIN\n  sp_manage_book_reviews(4, 6.7, 6);\nEND;",
      "BEGIN\n  sp_manage_book_reviews(5, 7.3, 2);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_manage_book_reviews that accepts a book ID, a rating, and a reader count. If reviews exist for the book, update its rating and reader count. Otherwise, insert a new review with a calculated rank. If the new rating is below 5, delete any existing review for that book with a rating below 5. If the new reader count exceeds 5, decrement the rank by one for that book's reviews where the reader count exceeds 5. Handle exceptions with rollback.",
    "natural_language": "Write a stored procedure called sp_manage_book_reviews that takes a book ID, a rating, and a reader count. Update the rating and reader count if reviews for the book already exist; otherwise, insert a new review with a computed rank. For any new rating under 5, remove existing reviews for that book with ratings below 5. If the new reader count is greater than 5, reduce the rank by one for that book's reviews where the reader count is above 5. Manage errors by rolling back changes.",
    "id": 81
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_book_info that accepts three input parameters: a numeric parameter para_book_id, a variable-length character parameter para_title, and a numeric parameter para_pages. The procedure first declares a local numeric variable v_book_exists. It begins execution by querying the BOOK table to count the number of rows where the BOOK_ID column matches the input para_book_id, storing the result into v_book_exists. If the count in v_book_exists is greater than zero, indicating the book exists, the procedure updates the existing row in the BOOK table, setting its TITLE column to the value of para_title and its PAGES column to the value of para_pages, specifically for the row where BOOK_ID equals para_book_id. If the count is zero, indicating the book does not exist, the procedure inserts a new row into the BOOK table with the following column values: BOOK_ID is set to para_book_id, TITLE is set to para_title, PAGES is set to para_pages, TYPE is set to the literal string 'Novel', CHAPTERS is set to the numeric literal 0, AUDIO is set to the literal string '0h 0m', and RELEASE is set to the literal string 'Unknown'. Following this insert or update, the procedure checks if the length of the input para_title exceeds 100 characters using the LENGTH function; if this condition is true, it deletes from the BOOK table the row where BOOK_ID equals para_book_id and the length of the TITLE column, again using the LENGTH function, is greater than 100. Finally, the procedure checks if the input para_pages is greater than 1000; if this condition is true, it updates the BOOK table, incrementing the CHAPTERS column by one for the row where BOOK_ID equals para_book_id and the PAGES column is greater than 1000.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_book_info(para_book_id NUMBER, para_title VARCHAR2, para_pages NUMBER) IS\n  v_book_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_book_exists FROM BOOK WHERE BOOK_ID = para_book_id;\n  \n  IF v_book_exists > 0 THEN\n    UPDATE BOOK SET TITLE = para_title, PAGES = para_pages WHERE BOOK_ID = para_book_id;\n  ELSE\n    INSERT INTO BOOK (BOOK_ID, TITLE, PAGES, TYPE, CHAPTERS, AUDIO, RELEASE) VALUES (para_book_id, para_title, para_pages, 'Novel', 0, '0h 0m', 'Unknown');\n  END IF;\n  \n  IF LENGTH(para_title) > 100 THEN\n    DELETE FROM BOOK WHERE BOOK_ID = para_book_id AND LENGTH(TITLE) > 100;\n  END IF;\n  \n  IF para_pages > 1000 THEN\n    UPDATE BOOK SET CHAPTERS = CHAPTERS + 1 WHERE BOOK_ID = para_book_id AND PAGES > 1000;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_book_info(1, 'A Dance with Dragons', 1016);\n  commit;\nEND;",
      "BEGIN\n  sp_update_book_info(2, 'The Winds of Winter', 1200);\n  commit;\nEND;",
      "BEGIN\n  sp_update_book_info(3, 'A Dream of Spring', 850);\n  commit;\nEND;",
      "BEGIN\n  sp_update_book_info(4, 'Fire & Blood', 736);\n  commit;\nEND;",
      "BEGIN\n  sp_update_book_info(5, 'The Hedge Knight', 150);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_book_info that accepts a book ID, title, and page count. If the book exists, update its title and pages. If it does not exist, insert it with default values for type, chapters, audio, and release. After the operation, if the title length exceeds 100 characters, delete that book. If the page count exceeds 1000, increment its chapters by one.",
    "natural_language": "How can I create a stored procedure named sp_update_book_info that takes a book ID, title, and page count, updates the book's title and pages if it exists, inserts it with defaults for type, chapters, audio, and release if it doesn't, then deletes the book if the title is over 100 characters, and increments its chapters by one if the page count exceeds 1000?",
    "id": 82
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_adjust_review_rank that accepts two input parameters: para_review_id of type NUMBER to identify a specific review record, and para_new_rank of type NUMBER representing a new rank value. The procedure first declares a local variable v_rank_difference of type NUMBER. It begins execution by selecting the current RANK value from the REVIEW table for the row where the REVIEW_ID column equals the para_review_id parameter, subtracting para_new_rank from it, and storing the result into v_rank_difference. If v_rank_difference is greater than zero, meaning the current rank is higher than the new rank, the procedure updates the REVIEW table, setting the RANK column to para_new_rank for the row where REVIEW_ID equals para_review_id. If v_rank_difference is not greater than zero, the procedure deletes the row from the REVIEW table where both REVIEW_ID equals para_review_id and the current RANK column value is less than para_new_rank. Following this conditional logic, the procedure checks if para_new_rank is less than 10; if true, it updates the REVIEW table by incrementing the READERS_IN_MILLION column by one for the row where REVIEW_ID equals para_review_id and the current RANK column value is less than 10. Finally, the procedure checks if para_new_rank is greater than 50; if true, it deletes the row from the REVIEW table where both REVIEW_ID equals para_review_id and the current RANK column value is greater than 50.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_adjust_review_rank(para_review_id NUMBER, para_new_rank NUMBER) IS\n  v_rank_difference NUMBER;\nBEGIN\n  SELECT RANK - para_new_rank INTO v_rank_difference FROM REVIEW WHERE REVIEW_ID = para_review_id;\n  \n  IF v_rank_difference > 0 THEN\n    UPDATE REVIEW SET RANK = para_new_rank WHERE REVIEW_ID = para_review_id;\n  ELSE\n    DELETE FROM REVIEW WHERE REVIEW_ID = para_review_id AND RANK < para_new_rank;\n  END IF;\n  \n  IF para_new_rank < 10 THEN\n    UPDATE REVIEW SET READERS_IN_MILLION = READERS_IN_MILLION + 1 WHERE REVIEW_ID = para_review_id AND RANK < 10;\n  END IF;\n  \n  IF para_new_rank > 50 THEN\n    DELETE FROM REVIEW WHERE REVIEW_ID = para_review_id AND RANK > 50;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp_adjust_review_rank(1, 15);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(2, 5);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(3, 55);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(1, 8);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(2, 45);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_adjust_review_rank that accepts a review ID and a new rank. Calculate the difference between the current and new rank. If the current rank is higher, update to the new rank. Otherwise, delete the review if its current rank is lower than the new rank. If the new rank is below 10, increment the reader count for that review if its current rank is below 10. If the new rank is above 50, delete the review if its current rank is above 50.",
    "natural_language": "Develop a stored procedure, which should be named sp_adjust_review_rank, that is designed to accept two distinct input parameters: a specific review ID and a proposed new rank value. Within this procedure, first compute the precise numerical difference between the review's existing, current rank and the provided new rank. Should the evaluation determine that the current rank is definitively higher than the new rank, proceed to update the review's record to reflect the new, lower rank. Conversely, if the analysis reveals that the current rank is unfortunately lower than the new rank, then the procedure must execute a complete deletion of that particular review entry. Furthermore, incorporate an additional conditional check: if the newly specified rank falls demonstrably below the threshold of 10, then the reader count associated with that review must be carefully incremented, but only under the condition that the review's current rank is also already below 10. Finally, implement a separate rule stating that if the newly proposed rank is significantly above 50, the procedure should delete the review, but this action is contingent upon the review's current rank also being above 50.",
    "id": 83
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_review_statistics` that accepts a single input parameter, `para_book_id`, of data type `NUMBER`. This procedure first declares two local variables: `v_avg_rating` of data type `NUMBER` and `v_total_readers` of data type `NUMBER`. The procedure then proceeds to execute two separate `SELECT` statements. The first `SELECT` statement calculates the average value of the `RATING` column from the `REVIEW` table, specifically for rows where the `BOOK_ID` column matches the value provided in `para_book_id`, and stores this calculated average into the `v_avg_rating` variable. The second `SELECT` statement calculates the sum of the `READERS_IN_MILLION` column from the `REVIEW` table, again only for rows where the `BOOK_ID` column matches the value of `para_book_id`, and stores this sum into the `v_total_readers` variable. Following these selections, the procedure enters a conditional block. If the value of `v_avg_rating` is strictly greater than 7, an `UPDATE` operation is performed on the `REVIEW` table. This `UPDATE` statement decrements the value in the `RANK` column by 1 for all rows where the `BOOK_ID` column matches `para_book_id` and the `RATING` column is strictly greater than 7. Otherwise (if `v_avg_rating` is not strictly greater than 7), a `DELETE` operation is executed on the `REVIEW` table. This `DELETE` statement removes all rows where the `BOOK_ID` column matches `para_book_id` and the `RATING` column is strictly less than 4. After this first conditional block, the procedure enters a second, independent conditional block. If the value of `v_total_readers` is strictly greater than 10, an `UPDATE` operation is performed on the `REVIEW` table. This `UPDATE` statement increments the value in the `READERS_IN_MILLION` column by 1 for all rows where the `BOOK_ID` column matches `para_book_id` and the `READERS_IN_MILLION` column is strictly greater than 10. Finally, the procedure enters a third, independent conditional block. If the value of `v_total_readers` is strictly less than 5, a `DELETE` operation is executed on the `REVIEW` table. This `DELETE` statement removes all rows where the `BOOK_ID` column matches `para_book_id` and the `READERS_IN_MILLION` column is strictly less than 5.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_review_statistics(para_book_id NUMBER) IS\n  v_avg_rating NUMBER;\n  v_total_readers NUMBER;\nBEGIN\n  SELECT AVG(RATING) INTO v_avg_rating FROM REVIEW WHERE BOOK_ID = para_book_id;\n  SELECT SUM(READERS_IN_MILLION) INTO v_total_readers FROM REVIEW WHERE BOOK_ID = para_book_id;\n  \n  IF v_avg_rating > 7 THEN\n    UPDATE REVIEW SET RANK = RANK - 1 WHERE BOOK_ID = para_book_id AND RATING > 7;\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND RATING < 4;\n  END IF;\n  \n  IF v_total_readers > 10 THEN\n    UPDATE REVIEW SET READERS_IN_MILLION = READERS_IN_MILLION + 1 WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION > 10;\n  END IF;\n  \n  IF v_total_readers < 5 THEN\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION < 5;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp_review_statistics(1);\nEND;",
      "BEGIN\n  sp_review_statistics(2);\nEND;",
      "BEGIN\n  sp_review_statistics(3);\nEND;",
      "BEGIN\n  sp_review_statistics(4);\nEND;",
      "BEGIN\n  sp_review_statistics(5);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_review_statistics that accepts a book ID. Calculate the average rating and total readers for that book. If the average rating exceeds 7, decrement the rank by one for all reviews of that book with a rating above 7. Otherwise, delete all reviews for that book with a rating below 4. If the total readers exceed 10, increment the reader count by one for all reviews of that book where the reader count exceeds 10. If the total readers are below 5, delete all reviews for that book where the reader count is below 5.",
    "natural_language": "What stored procedure logic should be implemented for a given book ID to calculate its average rating and total readers, then conditionally decrement the rank for high-rated reviews if the average is above 7, delete low-rated reviews if the average is 7 or below, increment the reader count for popular reviews if total readers exceed 10, and delete reviews with low reader counts if total readers are below 5?",
    "id": 84
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp5` that accepts two input parameters: `para_Product_Name`, which is of type `VARCHAR2` and represents the name of a product, and `para_New_Price`, which is of type `NUMBER` and represents a new price value. The procedure begins by declaring two local variables: `v_product_count` of type `NUMBER`, initialized to 0, to store the count of products matching the provided product name, and `v_complaint_count` of type `NUMBER`, also initialized to 0, to store the count of complaints associated with the product. The procedure then executes a `SELECT` statement to count the number of rows in the `PRODUCTS` table where the `PRODUCT_NAME` column matches the value of `para_Product_Name`, storing this count in `v_product_count`. Subsequently, another `SELECT` statement is executed to count the number of rows in the `COMPLAINTS` table where the `PRODUCT_ID` column is present in the set of `PRODUCT_ID` values retrieved from the `PRODUCTS` table for rows where `PRODUCT_NAME` matches `para_Product_Name`, storing this count in `v_complaint_count`. Following these counts, the procedure enters a conditional block. If `v_product_count` is greater than 0, indicating that one or more products with the specified `para_Product_Name` exist, a `DELETE` statement is executed to remove all rows from the `PRODUCTS` table where the `PRODUCT_NAME` column matches `para_Product_Name`. If the first condition is false, the procedure checks if `v_complaint_count` is greater than 5. If this condition is true, a `DELETE` statement is executed to remove all rows from the `COMPLAINTS` table where the `PRODUCT_ID` column is present in the set of `PRODUCT_ID` values retrieved from the `PRODUCTS` table for rows where `PRODUCT_NAME` matches `para_Product_Name`. If both previous conditions are false, an `INSERT` statement is executed. This `INSERT` statement populates the `PRODUCTS` table with new rows by selecting `PRODUCT_ID`, `PARENT_PRODUCT_ID`, `PRODUCT_CATEGORY_CODE`, `DATE_PRODUCT_FIRST_AVAILABLE`, `DATE_PRODUCT_DISCONTINUED`, `PRODUCT_NAME`, and `PRODUCT_DESCRIPTION` from existing rows in the `PRODUCTS` table where `PRODUCT_NAME` matches `para_Product_Name`. For the `PRODUCT_PRICE` column in these new rows, the value of `para_New_Price` is used instead of the original product price. After this initial conditional block, the procedure enters another independent conditional block. If the value of `para_New_Price` is greater than 100, a `DELETE` statement is executed to remove all rows from the `PRODUCTS` table where the `PRODUCT_NAME` column matches `para_Product_Name`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp5(para_Product_Name VARCHAR2, para_New_Price NUMBER) IS\n  v_product_count NUMBER := 0;\n  v_complaint_count NUMBER := 0;\nBEGIN\n  SELECT COUNT(*) INTO v_product_count FROM PRODUCTS WHERE PRODUCT_NAME = para_Product_Name;\n  SELECT COUNT(*) INTO v_complaint_count FROM COMPLAINTS WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCTS WHERE PRODUCT_NAME = para_Product_Name);\n  \n  IF v_product_count > 0 THEN\n    DELETE FROM PRODUCTS WHERE PRODUCT_NAME = para_Product_Name;\n  ELSIF v_complaint_count > 5 THEN\n    DELETE FROM COMPLAINTS WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCTS WHERE PRODUCT_NAME = para_Product_Name);\n  ELSE\n    INSERT INTO PRODUCTS (PRODUCT_ID, PARENT_PRODUCT_ID, PRODUCT_CATEGORY_CODE, DATE_PRODUCT_FIRST_AVAILABLE, DATE_PRODUCT_DISCONTINUED, PRODUCT_NAME, PRODUCT_DESCRIPTION, PRODUCT_PRICE)\n    SELECT PRODUCT_ID, PARENT_PRODUCT_ID, PRODUCT_CATEGORY_CODE, DATE_PRODUCT_FIRST_AVAILABLE, DATE_PRODUCT_DISCONTINUED, PRODUCT_NAME, PRODUCT_DESCRIPTION, para_New_Price\n    FROM PRODUCTS\n    WHERE PRODUCT_NAME = para_Product_Name;\n  END IF;\n  \n  IF para_New_Price > 100 THEN\n    DELETE FROM PRODUCTS WHERE PRODUCT_NAME = para_Product_Name;\n  END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp5('Chocolate', 50);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5('The Great Gatsby', 120);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5('Keyboard', 80);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5('Non-Existent Product', 90);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5('Mouse', 150);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp5 that accepts a product name and a new price. Count products with that name and associated complaints. If products exist, delete all products with that name. Otherwise, if complaints exceed 5, delete all complaints for products with that name. Otherwise, insert new product records using the existing product data but with the new price. Finally, if the new price exceeds 100, delete all products with that name.",
    "natural_language": "Alright, so we need a stored procedure, call it sp5. It's gonna take in a product name and a new price. First, check how many products have that name and how many complaints are tied to 'em. If there are any products with that name, just wipe out all those products. If there aren't any products, but the complaints are more than 5, then get rid of all the complaints for products with that name. If neither of those is true, then we gotta add new product records using the old product info but slap the new price on 'em. Oh, and one last thing  if the new price ends up being over 100, delete every product with that name again.",
    "id": 85
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `manage_order_status` that accepts one input parameter, `p_status`, which is of type `VARCHAR2`. This procedure declares four local variables: `v_order_id` of type `NUMBER`, `v_regular_id` of type `NUMBER`, `v_distributor_id` of type `NUMBER`, and `v_order_status` of type `VARCHAR2(255)`. The procedure then initiates a loop that iterates through a result set obtained by selecting the `ACTUAL_ORDER_ID`, `ORDER_STATUS_CODE`, and `REGULAR_ORDER_ID` columns from the `ACTUAL_ORDERS` table. The selection is filtered by a condition where the `ORDER_STATUS_CODE` column matches the value provided in the `p_status` input parameter. Within each iteration of this loop, the value of the `ACTUAL_ORDER_ID` column from the current record is assigned to the `v_order_id` variable, the value of the `REGULAR_ORDER_ID` column is assigned to the `v_regular_id` variable, and the value of the `ORDER_STATUS_CODE` column is assigned to the `v_order_status` variable after removing any leading or trailing whitespace using the `TRIM` function. Following these assignments, a `SELECT` statement is executed to retrieve the `DISTRIBUTER_ID` column from the `REGULAR_ORDERS` table into the `v_distributor_id` variable, where the selection is filtered by a condition where the `REGULAR_ORDER_ID` column matches the value stored in the `v_regular_id` variable. Subsequently, a conditional block is executed. If the value of the `v_order_status` variable is exactly 'Success', an `UPDATE` statement is performed on the `CUSTOMERS` table, setting the `PAYMENT_METHOD` column to 'Updated' for all rows where the `CUSTOMER_ID` column matches the value stored in the `v_distributor_id` variable. If the `v_order_status` variable is not 'Success' but is exactly 'Cancel', a `DELETE` statement is executed on the `ACTUAL_ORDER_PRODUCTS` table, removing all rows where the `ACTUAL_ORDER_ID` column matches the value stored in the `v_order_id` variable. If neither of the preceding conditions is met (i.e., `v_order_status` is neither 'Success' nor 'Cancel'), an `INSERT` statement is executed on the `PRODUCTS` table, adding a new row with the `PRODUCT_ID` column set to the value of `v_order_id` plus 4000, the `PRODUCT_NAME` column set to the literal string 'special product', the `PRODUCT_PRICE` column set to the numeric value 750.00, and the `PRODUCT_DESCRIPTION` column set to the literal string 'special offer'. The loop continues until all records matching the initial `SELECT` condition have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_order_status(p_status VARCHAR2)\nIS\n    v_order_id NUMBER;\n    v_regular_id NUMBER;\n    v_distributor_id NUMBER;\n    v_order_status VARCHAR2(255);\nBEGIN\n    FOR order_rec IN (SELECT ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID FROM ACTUAL_ORDERS WHERE ORDER_STATUS_CODE = p_status) LOOP\n        v_order_id := order_rec.ACTUAL_ORDER_ID;\n        v_regular_id := order_rec.REGULAR_ORDER_ID;\n        v_order_status := TRIM(order_rec.ORDER_STATUS_CODE);\n        \n        SELECT DISTRIBUTER_ID INTO v_distributor_id FROM REGULAR_ORDERS WHERE REGULAR_ORDER_ID = v_regular_id;\n        \n        IF v_order_status = 'Success' THEN\n            UPDATE CUSTOMERS SET PAYMENT_METHOD = 'Updated' WHERE CUSTOMER_ID = v_distributor_id;\n        ELSIF v_order_status = 'Cancel' THEN\n            DELETE FROM ACTUAL_ORDER_PRODUCTS WHERE ACTUAL_ORDER_ID = v_order_id;\n        ELSE\n            INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_NAME, PRODUCT_PRICE, PRODUCT_DESCRIPTION)\n            VALUES (v_order_id + 4000, 'special product', 750.00, 'special offer');\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "REGULAR_ORDERS",
      "CUSTOMERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  manage_order_status('Success');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_order_status('Cancel');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_order_status('Pending');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_order_status('Processing');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_order_status('Shipped');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `manage_order_status` that accepts a status parameter. For each order with that status, retrieve its details and the associated distributor ID. If the trimmed order status is 'Success', update the payment method for the matching customer. If it is 'Cancel', delete related order products. Otherwise, insert a new special product record.",
    "natural_language": "How can I create a stored procedure called `manage_order_status` that takes a status parameter, retrieves the details and distributor ID for each order with that status, and then, if the trimmed status is 'Success', updates the customer's payment method, or if it is 'Cancel', deletes the related order products, or otherwise inserts a new special product record?",
    "id": 86
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `handle_product_orders` that accepts a single input parameter, `p_product_name`, of type `VARCHAR2`. This procedure is designed to process product orders based on the provided product name. It declares three local variables: `v_product_id` of type `NUMBER` to store a product's identifier, `v_order_id` of type `NUMBER` to store an order's identifier, and `v_product_price` of type `NUMBER` to store a product's price. The procedure begins by iterating through a result set obtained from selecting the `PRODUCT_ID` and `PRODUCT_PRICE` columns from the `PRODUCTS` table. This selection is filtered by a condition where the `PRODUCT_NAME` column matches the value passed in the `p_product_name` input parameter. For each record (`prod_rec`) retrieved in this outer loop, the `PRODUCT_ID` is assigned to `v_product_id`, and the `PRODUCT_PRICE` is assigned to `v_product_price`. Subsequently, an inner loop is initiated. This inner loop iterates through a result set obtained from selecting the `ACTUAL_ORDER_ID` column from the `ACTUAL_ORDER_PRODUCTS` table. This selection is filtered by a condition where the `PRODUCT_ID` column matches the `v_product_id` obtained from the current iteration of the outer loop. For each record (`order_rec`) retrieved in this inner loop, the `ACTUAL_ORDER_ID` is assigned to `v_order_id`. Following this assignment, a conditional block is executed. If the `v_product_price` is greater than `1000`, then a `DELETE` operation is performed on the `ACTUAL_ORDERS` table, removing the row where the `ACTUAL_ORDER_ID` column matches the `v_order_id`. If the `v_product_price` is not greater than `1000` but is less than or equal to `1000`, then an `INSERT` operation is performed on the `CUSTOMERS` table. A new row is inserted with the `CUSTOMER_ID` set to the value of `v_order_id` plus `6000`, `PAYMENT_METHOD` set to the string literal 'New', `CUSTOMER_NAME` set to the string literal 'Generated Customer', `CUSTOMER_PHONE` set to the string literal '000-000-0000', `CUSTOMER_EMAIL` set to the string literal 'gen@example.com', and `DATE_BECAME_CUSTOMER` set to the string literal '2023-01-01 00:00:00'. If neither of the preceding conditions is met (i.e., `v_product_price` is not greater than `1000` and not less than or equal to `1000`), then an `UPDATE` operation is performed on the `PRODUCTS` table, setting the `PRODUCT_DESCRIPTION` column to the string literal 'special update' for the row where the `PRODUCT_ID` column matches the `v_product_id`. The inner loop continues until all relevant orders for the current product have been processed. The outer loop then continues until all products matching the `p_product_name` have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE handle_product_orders(p_product_name VARCHAR2)\nIS\n    v_product_id NUMBER;\n    v_order_id NUMBER;\n    v_product_price NUMBER;\nBEGIN\n    FOR prod_rec IN (SELECT PRODUCT_ID, PRODUCT_PRICE FROM PRODUCTS WHERE PRODUCT_NAME = p_product_name) LOOP\n        v_product_id := prod_rec.PRODUCT_ID;\n        v_product_price := prod_rec.PRODUCT_PRICE;\n        \n        FOR order_rec IN (SELECT ACTUAL_ORDER_ID FROM ACTUAL_ORDER_PRODUCTS WHERE PRODUCT_ID = v_product_id) LOOP\n            v_order_id := order_rec.ACTUAL_ORDER_ID;\n            \n            IF v_product_price > 1000 THEN\n                DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = v_order_id;\n            ELSIF v_product_price <= 1000 THEN\n                INSERT INTO CUSTOMERS (CUSTOMER_ID, PAYMENT_METHOD, CUSTOMER_NAME, CUSTOMER_PHONE, CUSTOMER_EMAIL, DATE_BECAME_CUSTOMER)\n                VALUES (v_order_id + 6000, 'New', 'Generated Customer', '000-000-0000', 'gen@example.com', '2023-01-01 00:00:00');\n            ELSE\n                UPDATE PRODUCTS SET PRODUCT_DESCRIPTION = 'special update' WHERE PRODUCT_ID = v_product_id;\n            END IF;\n        END LOOP;\n    END LOOP;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "REGULAR_ORDERS",
      "CUSTOMERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  handle_product_orders('dvds');\nEND;",
      "BEGIN\n  handle_product_orders('cloth');\nEND;",
      "BEGIN\n  handle_product_orders('electronics');\nEND;",
      "BEGIN\n  handle_product_orders('laptop');\nEND;",
      "BEGIN\n  handle_product_orders('book');\nEND;"
    ],
    "summary": "Create a stored procedure named `handle_product_orders` that accepts a product name. For each product with that name, process its related orders. If the product price is over 1000, delete the associated order. If the price is 1000 or less, insert a new customer record. Otherwise, update the product's description.",
    "natural_language": "Create a stored procedure called `handle_product_orders` that takes a product name. For items matching that name, work through their linked orders. If a product's cost is significantly high, remove the related order. If the price is more or less reasonable, add a new customer entry. In other cases, just adjust the product's details.",
    "id": 87
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_assign_head_to_dept` that accepts four input parameters: `p_dept_id` of type `NUMBER`, `p_head_id` of type `NUMBER`, `p_temp_flag` of type `VARCHAR2`, and `p_budget_factor` of type `NUMBER`. The procedure begins by declaring two local variables: `v_dept_budget` of type `NUMBER` and `v_head_age` of type `NUMBER`. It then performs a `SELECT` operation to retrieve the `BUDGET_IN_BILLIONS` column value from the `DEPARTMENT` table, storing this value into the `v_dept_budget` variable. This `SELECT` operation is conditioned on matching the `DEPARTMENT_ID` column in the `DEPARTMENT` table with the input parameter `p_dept_id`. Subsequently, another `SELECT` operation is executed to retrieve the `AGE` column value from the `HEAD` table, storing this value into the `v_head_age` variable. This `SELECT` operation is conditioned on matching the `HEAD_ID` column in the `HEAD` table with the input parameter `p_head_id`. Following these data retrievals, the procedure evaluates a conditional `IF` statement: if the value of `v_head_age` is greater than 65, an `INSERT` operation is performed into the `MANAGEMENT` table. This `INSERT` operation populates the `DEPARTMENT_ID` column with the value of `p_dept_id`, the `HEAD_ID` column with the value of `p_head_id`, and the `TEMPORARY_ACTING` column with the literal string 'Yes'. If the condition `v_head_age > 65` is not met (i.e., `v_head_age` is less than or equal to 65), an `INSERT` operation is performed into the `MANAGEMENT` table. This `INSERT` operation populates the `DEPARTMENT_ID` column with the value of `p_dept_id`, the `HEAD_ID` column with the value of `p_head_id`, and the `TEMPORARY_ACTING` column with the value of the input parameter `p_temp_flag`. Finally, regardless of the outcome of the conditional `IF` statement, a `DELETE` operation is performed on the `MANAGEMENT` table. This `DELETE` operation removes rows where the `DEPARTMENT_ID` column matches the value of `p_dept_id` AND the `HEAD_ID` column does NOT match the value of `p_head_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_assign_head_to_dept (\n    p_dept_id IN NUMBER,\n    p_head_id IN NUMBER,\n    p_temp_flag IN VARCHAR2,\n    p_budget_factor IN NUMBER\n)\nIS\n    v_dept_budget NUMBER;\n    v_head_age NUMBER;\nBEGIN\n    SELECT BUDGET_IN_BILLIONS INTO v_dept_budget FROM DEPARTMENT WHERE DEPARTMENT_ID = p_dept_id;\n    SELECT AGE INTO v_head_age FROM HEAD WHERE HEAD_ID = p_head_id;\n    IF v_head_age > 65 THEN\n        INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (p_dept_id, p_head_id, 'Yes');\n    ELSE\n        INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (p_dept_id, p_head_id, p_temp_flag);\n    END IF;\n    DELETE FROM MANAGEMENT WHERE DEPARTMENT_ID = p_dept_id AND HEAD_ID != p_head_id;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  proc_assign_head_to_dept(1, 5, 'No', 1.2);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_assign_head_to_dept(2, 4, 'Yes', 0.95);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_assign_head_to_dept(3, 6, 'No', 1.05);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_assign_head_to_dept(1, 3, 'No', 1.1);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_assign_head_to_dept(2, 1, 'Yes', 0.9);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_assign_head_to_dept` that accepts department ID, head ID, a temporary flag, and a budget factor. Retrieve the department budget and head's age. If the head's age is over 65, insert a management record with 'Yes' as the temporary flag. Otherwise, use the provided flag. Finally, delete any other management records for that department.",
    "natural_language": "Make a stored procedure called `proc_assign_head_to_dept` that takes a department ID, a head ID, a flag for temporary status, and a budget multiplier. Get the department's budget and the age of the head. If the head is somewhat older, like past 65, then put in a management record marking the temporary flag as 'Yes'. If not, just use the given flag. After that, clean up any other management entries for that particular department.",
    "id": 88
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_calculate_department_metrics that accepts four parameters: p_year_threshold of type NUMBER, p_ranking_limit of type NUMBER, p_min_age of type NUMBER, and p_flag_value of type VARCHAR2. The procedure begins by declaring two local variables, v_dept_count and v_total_budget, both of type NUMBER. It then executes a SELECT statement to count the number of departments and sum their budgets from the DEPARTMENT table where the CREATION year, converted to a number, is less than p_year_threshold and the RANKING is less than or equal to p_ranking_limit, storing the results in v_dept_count and v_total_budget. If v_dept_count is greater than zero, the procedure enters a nested loop structure. The outer loop iterates over records from the HEAD table where the AGE is greater than or equal to p_min_age, retrieving the HEAD_ID for each record. The inner loop iterates over records from the DEPARTMENT table where the RANKING is less than or equal to p_ranking_limit, retrieving the DEPARTMENT_ID for each record. Within the inner loop, a MERGE statement is executed on the MANAGEMENT table, using a source dataset constructed from the current DEPARTMENT_ID and HEAD_ID. If a matching row is not found in MANAGEMENT, a new row is inserted with the DEPARTMENT_ID, HEAD_ID, and TEMPORARY_ACTING set to p_flag_value. If a matching row is found, the TEMPORARY_ACTING column is updated to p_flag_value. After the loops, the procedure deletes any rows from the MANAGEMENT table where the TEMPORARY_ACTING column does not equal p_flag_value.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_calculate_department_metrics (\n    p_year_threshold IN NUMBER,\n    p_ranking_limit IN NUMBER,\n    p_min_age IN NUMBER,\n    p_flag_value IN VARCHAR2\n)\nIS\n    v_dept_count NUMBER;\n    v_total_budget NUMBER;\nBEGIN\n    SELECT COUNT(*), SUM(BUDGET_IN_BILLIONS) INTO v_dept_count, v_total_budget\n    FROM DEPARTMENT\n    WHERE TO_NUMBER(CREATION) < p_year_threshold\n    AND RANKING <= p_ranking_limit;\n    \n    IF v_dept_count > 0 THEN\n        FOR head_rec IN (SELECT HEAD_ID FROM HEAD WHERE AGE >= p_min_age) LOOP\n            FOR dept_rec IN (SELECT DEPARTMENT_ID FROM DEPARTMENT WHERE RANKING <= p_ranking_limit) LOOP\n                MERGE INTO MANAGEMENT m\n                USING (SELECT dept_rec.DEPARTMENT_ID as dept_id, head_rec.HEAD_ID as head_id FROM DUAL) src\n                ON (m.DEPARTMENT_ID = src.dept_id AND m.HEAD_ID = src.head_id)\n                WHEN NOT MATCHED THEN\n                    INSERT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING)\n                    VALUES (src.dept_id, src.head_id, p_flag_value)\n                WHEN MATCHED THEN\n                    UPDATE SET TEMPORARY_ACTING = p_flag_value;\n            END LOOP;\n        END LOOP;\n    END IF;\n    \n    DELETE FROM MANAGEMENT WHERE TEMPORARY_ACTING != p_flag_value;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  proc_calculate_department_metrics(p_year_threshold => 1900, p_ranking_limit => 5, p_min_age => 60, p_flag_value => 'Y');\nEND;",
      "BEGIN\n  proc_calculate_department_metrics(p_year_threshold => 2000, p_ranking_limit => 10, p_min_age => 50, p_flag_value => 'N');\nEND;",
      "BEGIN\n  proc_calculate_department_metrics(p_year_threshold => 1850, p_ranking_limit => 3, p_min_age => 70, p_flag_value => 'TRUE');\nEND;",
      "BEGIN\n  proc_calculate_department_metrics(p_year_threshold => 2020, p_ranking_limit => 1, p_min_age => 40, p_flag_value => 'ACTIVE');\nEND;",
      "BEGIN\n  proc_calculate_department_metrics(p_year_threshold => 1700, p_ranking_limit => 2, p_min_age => 80, p_flag_value => 'TEMP');\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_calculate_department_metrics` that accepts a year threshold, ranking limit, minimum age, and a flag value. Count and sum budgets for departments meeting the year and ranking criteria. If departments are found, for each head meeting the age criteria and each department meeting the ranking criteria, merge into the MANAGEMENT table, setting the flag. Finally, delete management records where the flag does not match.",
    "natural_language": "List departments meeting the year and ranking criteria by counting and summing their budgets. Then, for each department head meeting the age criteria and each department meeting the ranking criteria, merge them into the MANAGEMENT table and set the flag. Finally, delete any management records where the flag does not match. Do this by creating a stored procedure named `proc_calculate_department_metrics` that accepts a year threshold, ranking limit, minimum age, and a flag value.",
    "id": 89
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_device_quantity` that accepts two input parameters: `device_id_val` of data type `NUMBER` which represents the unique identifier of a device, and `new_quantity` of data type `NUMBER` which represents the new quantity to be assigned to the device. The procedure performs a single `UPDATE` operation on the `STOCK` table. This `UPDATE` operation sets the value of the `QUANTITY` column to the value provided by the `new_quantity` parameter. The `UPDATE` operation is conditional, applying only to those rows in the `STOCK` table where the value in the `DEVICE_ID` column exactly matches the value provided by the `device_id_val` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_device_quantity(device_id_val NUMBER, new_quantity NUMBER) IS\nBEGIN\n  UPDATE STOCK SET QUANTITY = new_quantity WHERE DEVICE_ID = device_id_val;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "BEGIN\n  update_device_quantity(1, 150);\nEND;",
      "BEGIN\n  update_device_quantity(2, 200);\nEND;",
      "BEGIN\n  update_device_quantity(3, 50);\nEND;",
      "BEGIN\n  update_device_quantity(6, 120);\nEND;",
      "BEGIN\n  update_device_quantity(1, 100);\nEND;"
    ],
    "summary": "Create a stored procedure named `update_device_quantity` that accepts a device ID and a new quantity. Update the stock table to set the quantity to the new value for the specified device.",
    "natural_language": "Hey, can you whip up a stored procedure called `update_device_quantity`? It should take a device ID and a new stock number. Then, just go into the stock table and update the quantity to that new number for the gadget with that specific ID.",
    "id": 90
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_update_customer_address`. This procedure is designed to modify customer address information within a database. It accepts two input parameters: `p_customer_id`, which is of data type `NUMBER` and represents the unique identifier of the customer whose address is to be updated, and `p_new_address_id`, also of data type `NUMBER`, which specifies the new address identifier to be assigned to the customer. Additionally, it provides two output parameters: `p_updated_rows`, of data type `NUMBER`, which will store the count of rows affected by the update operation, and `p_message`, of data type `VARCHAR2`, which will contain a descriptive message indicating the outcome of the operation. The procedure's execution begins by performing an `UPDATE` operation on the `CUSTOMERS` table. This `UPDATE` statement sets the value of the `CUSTOMER_ADDRESS_ID` column to the value provided by the `p_new_address_id` input parameter. The `WHERE` clause of this `UPDATE` statement restricts the operation to only those rows where the `CUSTOMER_ID` column matches the value supplied by the `p_customer_id` input parameter. Following the `UPDATE` operation, the procedure assigns the number of rows that were successfully updated by the preceding `UPDATE` statement to the `p_updated_rows` output parameter. This count is retrieved using the `SQL%ROWCOUNT` SQL attribute, which returns the number of rows processed by the most recently executed SQL statement. Subsequently, the procedure determines the value for the `p_message` output parameter using a `CASE` statement. If the value stored in `p_updated_rows` is greater than `0`, indicating that at least one row was updated, the `p_message` parameter is set to the string literal 'Address updated successfully.'. Conversely, if `p_updated_rows` is not greater than `0` (i.e., it is `0`), meaning no rows were updated, the `p_message` parameter is set to the string literal 'No update performed.'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_update_customer_address(p_customer_id IN NUMBER, p_new_address_id IN NUMBER, p_updated_rows OUT NUMBER, p_message OUT VARCHAR2)\nIS\nBEGIN\n    UPDATE CUSTOMERS SET CUSTOMER_ADDRESS_ID = p_new_address_id WHERE CUSTOMER_ID = p_customer_id;\n    p_updated_rows := SQL%ROWCOUNT;\n    p_message := CASE WHEN p_updated_rows > 0 THEN 'Address updated successfully.' ELSE 'No update performed.' END;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_update_customer_address(1, 1, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_update_customer_address(3, 2, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_update_customer_address(4, 3, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_update_customer_address(1, 2, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_update_customer_address(3, 3, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_update_customer_address` that updates the `CUSTOMER_ADDRESS_ID` for a given `CUSTOMER_ID` in the `CUSTOMERS` table. It takes the customer ID and new address ID as input and returns the number of updated rows and a success or failure message.",
    "natural_language": "Develop a comprehensive stored procedure, to be named `proc_update_customer_address`, which meticulously handles the updating of the `CUSTOMER_ADDRESS_ID` field for a specific, provided `CUSTOMER_ID` within the `CUSTOMERS` table. This procedure should gracefully accept both the customer's unique identifier and the new address ID as its input parameters, and subsequently return, in a detailed manner, the precise count of rows that were successfully updated along with a clear message indicating either a successful operation or a specific failure.",
    "id": 91
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_customer_status_update` that accepts five parameters: an input parameter `p_customer_id` of type NUMBER to identify a customer, an input parameter `p_new_status` of type VARCHAR2 to specify a desired status, an input parameter `p_threshold` of type NUMBER to define a financial limit, an output parameter `p_updated_rows` of type NUMBER to return the count of rows modified, and an output parameter `p_message` of type VARCHAR2 to provide a descriptive result message. The procedure begins by selecting the `AMOUNT_OUTSTANDING` column value from the `CUSTOMERS` table for the row where the `CUSTOMER_ID` column matches the input `p_customer_id` and stores this value into a local variable `v_outstanding`. It then evaluates a conditional statement: if the retrieved `v_outstanding` value is greater than the input `p_threshold` value, it executes an update on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the literal string 'Bad Customer' for the row where `CUSTOMER_ID` equals `p_customer_id`, assigns the number of rows affected by this update (using `SQL%ROWCOUNT`) to the output parameter `p_updated_rows`, and sets the output parameter `p_message` to the string 'Status updated to Bad Customer due to high outstanding amount.'. If the condition is not met (i.e., `v_outstanding` is less than or equal to `p_threshold`), the procedure executes a different update on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the value of the input parameter `p_new_status` for the row where `CUSTOMER_ID` equals `p_customer_id`, assigns the row count from this update to `p_updated_rows`, and sets `p_message` to the string 'Status updated to specified value.'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_customer_status_update(p_customer_id IN NUMBER, p_new_status IN VARCHAR2, p_threshold IN NUMBER, p_updated_rows OUT NUMBER, p_message OUT VARCHAR2)\nIS\n    v_outstanding NUMBER;\nBEGIN\n    SELECT AMOUNT_OUTSTANDING INTO v_outstanding FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    IF v_outstanding > p_threshold THEN\n        UPDATE CUSTOMERS SET CUSTOMER_STATUS_CODE = 'Bad Customer' WHERE CUSTOMER_ID = p_customer_id;\n        p_updated_rows := SQL%ROWCOUNT;\n        p_message := 'Status updated to Bad Customer due to high outstanding amount.';\n    ELSE\n        UPDATE CUSTOMERS SET CUSTOMER_STATUS_CODE = p_new_status WHERE CUSTOMER_ID = p_customer_id;\n        p_updated_rows := SQL%ROWCOUNT;\n        p_message := 'Status updated to specified value.';\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(1, 'Good Customer', 500, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(3, 'Regular Customer', 1000, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(4, 'VIP Customer', 2000, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(1, 'Preferred Customer', 300, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(3, 'New Customer', 5000, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_customer_status_update` that updates a customer's status in the `CUSTOMERS` table. It takes a customer ID, a new status, and a financial threshold as input. If the customer's outstanding amount exceeds the threshold, set their status to 'Bad Customer'. Otherwise, set it to the provided new status. Return the number of updated rows and a descriptive message.",
    "natural_language": "Write a stored procedure called `proc_customer_status_update` to update a customer's status in the `CUSTOMERS` table. Provide a customer ID, a new status, and a financial threshold. If the customer's outstanding amount is above the threshold, mark their status as 'Bad Customer'. If not, set it to the given new status. Return the count of updated rows along with a descriptive message.",
    "id": 92
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named INSERT_CATALOG_ATTRIBUTE that accepts four input parameters: a numeric parameter P_ENTRY_ID, a numeric parameter P_LEVEL_NUM, a numeric parameter P_ATTR_ID, and a string parameter P_ATTR_VALUE, and performs a single INSERT operation into the table named CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES, directly mapping the input parameters to the table's columns by inserting the value of P_ENTRY_ID into the CATALOG_ENTRY_ID column, the value of P_LEVEL_NUM into the CATALOG_LEVEL_NUMBER column, the value of P_ATTR_ID into the ATTRIBUTE_ID column, and the value of P_ATTR_VALUE into the ATTRIBUTE_VALUE column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_catalog_attribute(p_entry_id NUMBER, p_level_num NUMBER, p_attr_id NUMBER, p_attr_value VARCHAR2)\nIS\nBEGIN\n   INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE)\n   VALUES (p_entry_id, p_level_num, p_attr_id, p_attr_value);\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "BEGIN\n  insert_catalog_attribute(1, 1, 1, 'Value1');\nEND;",
      "BEGIN\n  insert_catalog_attribute(2, 8, 2, 'Value2');\nEND;",
      "BEGIN\n  insert_catalog_attribute(3, 1, 3, 'Value3');\nEND;",
      "BEGIN\n  insert_catalog_attribute(5, 8, 4, '1');\nEND;",
      "BEGIN\n  insert_catalog_attribute(15, 9, 3, '0');\nEND;"
    ],
    "summary": "Create a stored procedure named `INSERT_CATALOG_ATTRIBUTE` that inserts a new row into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. It accepts parameters for catalog entry ID, level number, attribute ID, and attribute value, and maps them directly to the table's columns.",
    "natural_language": "Write a stored procedure called `INSERT_CATALOG_ATTRIBUTE` to insert a new record into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. The procedure must take catalog entry ID, level number, attribute ID, and attribute value as parameters and insert them directly into the corresponding table columns.",
    "id": 93
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named delete_catalog_contents that accepts a single parameter p_catalog_name of type VARCHAR2. This procedure performs a delete operation on the CATALOG_CONTENTS table, specifically removing rows where a corresponding entry exists in the CATALOG_STRUCTURE table that matches the CATALOG_LEVEL_NUMBER of the CATALOG_CONTENTS row. The procedure uses a subquery to determine the existence of such entries by joining the CATALOG_STRUCTURE table with the CATALOGS table on the CATALOG_ID column. The subquery filters the results by checking if the CATALOG_LEVEL_NUMBER in CATALOG_STRUCTURE is equal to the CATALOG_LEVEL_NUMBER in CATALOG_CONTENTS and if the CATALOG_NAME in CATALOGS matches the value of the p_catalog_name parameter. The procedure does not perform any other operations such as updates, inserts, or function calls, and it does not include any conditional statements beyond the WHERE clause used in the DELETE operation.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_catalog_contents(p_catalog_name VARCHAR2)\nIS\nBEGIN\n   DELETE FROM CATALOG_CONTENTS cc\n   WHERE EXISTS (\n      SELECT 1 FROM CATALOG_STRUCTURE cs\n      JOIN CATALOGS c ON cs.CATALOG_ID = c.CATALOG_ID\n      WHERE cs.CATALOG_LEVEL_NUMBER = cc.CATALOG_LEVEL_NUMBER\n      AND c.CATALOG_NAME = p_catalog_name\n   );\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "BEGIN\n  delete_catalog_contents('Chocolate');\n  commit;\nEND;",
      "BEGIN\n  delete_catalog_contents('Coffee Bean');\n  commit;\nEND;",
      "BEGIN\n  delete_catalog_contents('Lemonade');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `delete_catalog_contents` that deletes rows from the `CATALOG_CONTENTS` table. It accepts a catalog name as input and deletes rows where a corresponding entry exists in the `CATALOG_STRUCTURE` table for that catalog name and matching level number.",
    "natural_language": "Write a stored procedure called `delete_catalog_contents` to remove rows from the `CATALOG_CONTENTS` table. Use a catalog name as the input parameter and delete only those rows that have a matching catalog name and level number in the `CATALOG_STRUCTURE` table.",
    "id": 94
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named merge_catalog_attributes that accepts two mandatory input parameters, both of the NUMBER data type: p_source_entry, which represents the source catalog entry identifier, and p_target_entry, which represents the target catalog entry identifier. The procedure performs a single data manipulation operation by inserting new rows into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table. The data for the insert is sourced from a SELECT query that retrieves all rows from the same CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID column exactly matches the value of the input parameter p_source_entry. For each row retrieved from this source query, the INSERT statement populates the new row's columns with the following values: the CATALOG_ENTRY_ID column is set to the value of the input parameter p_target_entry, the CATALOG_LEVEL_NUMBER column is set to the CATALOG_LEVEL_NUMBER value from the source row, the ATTRIBUTE_ID column is set to the ATTRIBUTE_ID value from the source row, and the ATTRIBUTE_VALUE column is set to the ATTRIBUTE_VALUE from the source row. This operation effectively copies all additional attribute records associated with the source catalog entry (p_source_entry) to the target catalog entry (p_target_entry).",
    "plsql": "CREATE OR REPLACE PROCEDURE merge_catalog_attributes(p_source_entry NUMBER, p_target_entry NUMBER)\nIS\nBEGIN\n   INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE)\n   SELECT p_target_entry, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE\n   FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES\n   WHERE CATALOG_ENTRY_ID = p_source_entry;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 5, p_target_entry => 15);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 15, p_target_entry => 11);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 11, p_target_entry => 5);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 5, p_target_entry => 5);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 1, p_target_entry => 2);\nEND;"
    ],
    "summary": "Create a stored procedure named `merge_catalog_attributes` that copies all additional attribute records from a source catalog entry to a target catalog entry in the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. It accepts the source and target entry IDs as input parameters.",
    "natural_language": "How can I create a stored procedure called `merge_catalog_attributes` that will copy all additional attribute records from a source catalog entry to a target catalog entry in the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table, using the source and target entry IDs as input parameters?",
    "id": 95
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AdjustBuildingFloors that takes no parameters and processes every row in the BUILDING table by first retrieving the BUILDING_ID and FLOORS columns for each building, then counting the number of associated records in the INSTITUTION table where the INSTITUTION.BUILDING_ID matches the current building's BUILDING_ID, storing this count in variable v_institution_count, and then applying conditional logic to update the FLOORS column in the BUILDING table for that specific BUILDING_ID: if the institution count is greater than 3, it checks if the current floors are less than 10 and, if true, increases floors by 2, otherwise increases floors by 1; if the institution count is between 1 and 3 inclusive, it checks if the current floors are less than 15 and, if true, increases floors by 1, otherwise leaves floors unchanged; if the institution count is 0, it decreases floors by 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE AdjustBuildingFloors\nAS\n  v_building_id VARCHAR2(255);\n  v_floors NUMBER;\n  v_institution_count NUMBER;\nBEGIN\n  FOR rec IN (SELECT BUILDING_ID, FLOORS FROM BUILDING)\n  LOOP\n    v_building_id := rec.BUILDING_ID;\n    v_floors := rec.FLOORS;\n\n    SELECT COUNT(*) INTO v_institution_count\n    FROM INSTITUTION\n    WHERE BUILDING_ID = v_building_id;\n\n    IF v_institution_count > 3 THEN\n      IF v_floors < 10 THEN\n        UPDATE BUILDING\n        SET FLOORS = v_floors + 2\n        WHERE BUILDING_ID = v_building_id;\n      ELSE\n        UPDATE BUILDING\n        SET FLOORS = v_floors + 1\n        WHERE BUILDING_ID = v_building_id;\n      END IF;\n    ELSIF v_institution_count BETWEEN 1 AND 3 THEN\n      IF v_floors < 15 THEN\n        UPDATE BUILDING\n        SET FLOORS = v_floors + 1\n        WHERE BUILDING_ID = v_building_id;\n      ELSE\n        UPDATE BUILDING\n        SET FLOORS = v_floors\n        WHERE BUILDING_ID = v_building_id;\n      END IF;\n    ELSE\n      UPDATE BUILDING\n      SET FLOORS = v_floors - 1\n      WHERE BUILDING_ID = v_building_id;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "BEGIN\n  AdjustBuildingFloors;\nEND;"
    ],
    "summary": "Create a stored procedure named AdjustBuildingFloors that processes each building. For each building, count its associated institutions. Update the building's floors: if institution count > 3, increase floors by 2 if current floors < 10, otherwise by 1; if institution count is 1 to 3, increase floors by 1 if current floors < 15, else leave unchanged; if institution count is 0, decrease floors by 1.",
    "natural_language": "Adjust the floors for each building by processing them with a stored procedure named AdjustBuildingFloors. For every building, count its institutions. If the count is greater than 3, add 2 floors when the current floors are below 10, otherwise add 1 floor. If the count is between 1 and 3, add 1 floor when the current floors are below 15, otherwise make no change. If the count is 0, reduce the floors by 1.",
    "id": 96
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateProteinSequenceLength` that does not accept any input parameters. This procedure declares three local variables: `v_common_name` of type `VARCHAR2` with a maximum length of 255 characters, `v_sequence_length` of type `NUMBER`, and `v_divergence` of type `NUMBER`. The procedure then initiates a loop that iterates through each row retrieved from the `PROTEIN` table. For each row, it selects the values from the `COMMON_NAME`, `SEQUENCE_LENGTH`, and `DIVERGENCE_FROM_HUMAN_LINEAGE` columns. Inside the loop, the value from the `COMMON_NAME` column of the current row is assigned to the `v_common_name` variable, the value from the `SEQUENCE_LENGTH` column is assigned to the `v_sequence_length` variable, and the value from the `DIVERGENCE_FROM_HUMAN_LINEAGE` column is assigned to the `v_divergence` variable. Following these assignments, a series of conditional checks are performed based on the `v_divergence` variable.\n\nThe first condition checks if `v_divergence` is greater than 500.\nIf this condition is true, a nested condition is evaluated:\n  If `v_sequence_length` is less than 2000, the `SEQUENCE_LENGTH` column in the `PROTEIN` table is updated by adding 100 to its current value for the row where the `COMMON_NAME` column matches the `v_common_name` variable.\n  Otherwise (if `v_sequence_length` is not less than 2000, meaning it is 2000 or greater), the `SEQUENCE_LENGTH` column in the `PROTEIN` table is updated by adding 50 to its current value for the row where the `COMMON_NAME` column matches the `v_common_name` variable.\n\nIf the initial condition (`v_divergence > 500`) is false, an `ELSIF` condition is evaluated:\n  This condition checks if `v_divergence` is between 300 and 500 (inclusive of both 300 and 500).\n  If this `ELSIF` condition is true, another nested condition is evaluated:\n    If `v_sequence_length` is less than 1500, the `SEQUENCE_LENGTH` column in the `PROTEIN` table is updated by adding 50 to its current value for the row where the `COMMON_NAME` column matches the `v_common_name` variable.\n    Otherwise (if `v_sequence_length` is not less than 1500, meaning it is 1500 or greater), the `SEQUENCE_LENGTH` column in the `PROTEIN` table is updated by adding 20 to its current value for the row where the `COMMON_NAME` column matches the `v_common_name` variable.\n\nIf both the initial `IF` condition and the `ELSIF` condition are false, the final `ELSE` block is executed:\n  In this case, the `SEQUENCE_LENGTH` column in the `PROTEIN` table is updated by adding 10 to its current value for the row where the `COMMON_NAME` column matches the `v_common_name` variable.\n\nThe loop continues to process all rows retrieved from the `PROTEIN` table, applying these conditional updates to the `SEQUENCE_LENGTH` column for each protein entry. After all rows have been processed, the loop terminates, and the procedure concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateProteinSequenceLength\nAS\n  v_common_name VARCHAR2(255);\n  v_sequence_length NUMBER;\n  v_divergence NUMBER;\nBEGIN\n  FOR rec IN (SELECT COMMON_NAME, SEQUENCE_LENGTH, DIVERGENCE_FROM_HUMAN_LINEAGE FROM PROTEIN)\n  LOOP\n    v_common_name := rec.COMMON_NAME;\n    v_sequence_length := rec.SEQUENCE_LENGTH;\n    v_divergence := rec.DIVERGENCE_FROM_HUMAN_LINEAGE;\n\n    IF v_divergence > 500 THEN\n      IF v_sequence_length < 2000 THEN\n        UPDATE PROTEIN\n        SET SEQUENCE_LENGTH = v_sequence_length + 100\n        WHERE COMMON_NAME = v_common_name;\n      ELSE\n        UPDATE PROTEIN\n        SET SEQUENCE_LENGTH = v_sequence_length + 50\n        WHERE COMMON_NAME = v_common_name;\n      END IF;\n    ELSIF v_divergence BETWEEN 300 AND 500 THEN\n      IF v_sequence_length < 1500 THEN\n        UPDATE PROTEIN\n        SET SEQUENCE_LENGTH = v_sequence_length + 50\n        WHERE COMMON_NAME = v_common_name;\n      ELSE\n        UPDATE PROTEIN\n        SET SEQUENCE_LENGTH = v_sequence_length + 20\n        WHERE COMMON_NAME = v_common_name;\n      END IF;\n    ELSE\n      UPDATE PROTEIN\n      SET SEQUENCE_LENGTH = v_sequence_length + 10\n      WHERE COMMON_NAME = v_common_name;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateProteinSequenceLength;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateProteinSequenceLength that iterates through each protein. Based on its divergence from human lineage, update its sequence length: if divergence > 500, add 100 to length if length < 2000, else add 50; if divergence is 300 to 500, add 50 if length < 1500, else add 20; otherwise, add 10.",
    "natural_language": "Create procedure UpdateProteinSequenceLength to loop proteins. For each: if divergence > 500, length < 2000 then add 100 else add 50; if divergence 300-500, length < 1500 then add 50 else add 20; else add 10.",
    "id": 97
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateInstitutionType that iterates over each record in the INSTITUTION table, which contains columns INSTITUTION_ID, TYPE, and ENROLLMENT. For each record, it assigns the values of these columns to local variables v_institution_id, v_type, and v_enrollment, respectively. The procedure then evaluates the value of v_enrollment. If v_enrollment is greater than 2000, it checks the current value of v_type. If v_type is 'Private', it updates the TYPE column of the current institution record to 'Public'. Otherwise, it updates the TYPE column to 'Private'. If v_enrollment is between 1000 and 2000 inclusive, it checks if v_type is 'Tribal'. If so, it updates the TYPE column to 'Public'. Otherwise, it updates the TYPE column to 'Tribal'. If v_enrollment is less than 1000, it updates the TYPE column to 'Private' for the current institution record. The procedure does not take any input parameters and does not return any values.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateInstitutionType\nAS\n  v_institution_id VARCHAR2(255);\n  v_type VARCHAR2(255);\n  v_enrollment NUMBER;\nBEGIN\n  FOR rec IN (SELECT INSTITUTION_ID, TYPE, ENROLLMENT FROM INSTITUTION)\n  LOOP\n    v_institution_id := rec.INSTITUTION_ID;\n    v_type := rec.TYPE;\n    v_enrollment := rec.ENROLLMENT;\n\n    IF v_enrollment > 2000 THEN\n      IF v_type = 'Private' THEN\n        UPDATE INSTITUTION\n        SET TYPE = 'Public'\n        WHERE INSTITUTION_ID = v_institution_id;\n      ELSE\n        UPDATE INSTITUTION\n        SET TYPE = 'Private'\n        WHERE INSTITUTION_ID = v_institution_id;\n      END IF;\n    ELSIF v_enrollment BETWEEN 1000 AND 2000 THEN\n      IF v_type = 'Tribal' THEN\n        UPDATE INSTITUTION\n        SET TYPE = 'Public'\n        WHERE INSTITUTION_ID = v_institution_id;\n      ELSE\n        UPDATE INSTITUTION\n        SET TYPE = 'Tribal'\n        WHERE INSTITUTION_ID = v_institution_id;\n      END IF;\n    ELSE\n      UPDATE INSTITUTION\n      SET TYPE = 'Private'\n      WHERE INSTITUTION_ID = v_institution_id;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateInstitutionType;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateInstitutionType that iterates through each institution. Update its type based on enrollment: if enrollment > 2000, set type to 'Public' if current type is 'Private', else to 'Private'; if enrollment is 1000 to 2000, set type to 'Public' if current type is 'Tribal', else to 'Tribal'; if enrollment < 1000, set type to 'Private'.",
    "natural_language": "Create a stored procedure called UpdateInstitutionType that goes through all the institutions. For each one, adjust its type depending on how many students are enrolled: if there are quite a lot of students, change the type to 'Public' if it's currently 'Private', otherwise make it 'Private'; if the enrollment is around a medium amount, set the type to 'Public' if it's currently 'Tribal', otherwise set it to 'Tribal'; if there are only a few students enrolled, then set the type to 'Private'.",
    "id": 98
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AdjustProteinDivergence that iterates over each row in the PROTEIN table, retrieving the COMMON_NAME, DIVERGENCE_FROM_HUMAN_LINEAGE, and SEQUENCE_IDENTITY_TO_HUMAN_PROTEIN columns for each record. The procedure uses a loop to process each record individually. For each record, it assigns the COMMON_NAME to a variable v_common_name of type VARCHAR2(255), the DIVERGENCE_FROM_HUMAN_LINEAGE to a variable v_divergence of type NUMBER, and the SEQUENCE_IDENTITY_TO_HUMAN_PROTEIN to a variable v_sequence_identity of type VARCHAR2(255). The procedure then evaluates the value of v_divergence using conditional statements. If v_divergence is greater than 600, it checks if v_sequence_identity is greater than '40%'. If true, it updates the DIVERGENCE_FROM_HUMAN_LINEAGE column in the PROTEIN table by subtracting 50 from v_divergence for the row where COMMON_NAME matches v_common_name. If v_sequence_identity is not greater than '40%', it subtracts 30 instead. If v_divergence is between 400 and 600 inclusive, it checks if v_sequence_identity is greater than '30%'. If true, it updates the DIVERGENCE_FROM_HUMAN_LINEAGE by subtracting 20 from v_divergence for the row where COMMON_NAME matches v_common_name. If v_sequence_identity is not greater than '30%', it subtracts 10 instead. If v_divergence is less than 400, it updates the DIVERGENCE_FROM_HUMAN_LINEAGE by subtracting 5 from v_divergence for the row where COMMON_NAME matches v_common_name. The procedure does not perform any other operations or function calls.",
    "plsql": "CREATE OR REPLACE PROCEDURE AdjustProteinDivergence\nAS\n  v_common_name VARCHAR2(255);\n  v_divergence NUMBER;\n  v_sequence_identity VARCHAR2(255);\nBEGIN\n  FOR rec IN (SELECT COMMON_NAME, DIVERGENCE_FROM_HUMAN_LINEAGE, SEQUENCE_IDENTITY_TO_HUMAN_PROTEIN FROM PROTEIN)\n  LOOP\n    v_common_name := rec.COMMON_NAME;\n    v_divergence := rec.DIVERGENCE_FROM_HUMAN_LINEAGE;\n    v_sequence_identity := rec.SEQUENCE_IDENTITY_TO_HUMAN_PROTEIN;\n\n    IF v_divergence > 600 THEN\n      IF v_sequence_identity > '40%' THEN\n        UPDATE PROTEIN\n        SET DIVERGENCE_FROM_HUMAN_LINEAGE = v_divergence - 50\n        WHERE COMMON_NAME = v_common_name;\n      ELSE\n        UPDATE PROTEIN\n        SET DIVERGENCE_FROM_HUMAN_LINEAGE = v_divergence - 30\n        WHERE COMMON_NAME = v_common_name;\n      END IF;\n    ELSIF v_divergence BETWEEN 400 AND 600 THEN\n      IF v_sequence_identity > '30%' THEN\n        UPDATE PROTEIN\n        SET DIVERGENCE_FROM_HUMAN_LINEAGE = v_divergence - 20\n        WHERE COMMON_NAME = v_common_name;\n      ELSE\n        UPDATE PROTEIN\n        SET DIVERGENCE_FROM_HUMAN_LINEAGE = v_divergence - 10\n        WHERE COMMON_NAME = v_common_name;\n      END IF;\n    ELSE\n      UPDATE PROTEIN\n      SET DIVERGENCE_FROM_HUMAN_LINEAGE = v_divergence - 5\n      WHERE COMMON_NAME = v_common_name;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "BEGIN\n  AdjustProteinDivergence;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named AdjustProteinDivergence that iterates through each protein. Based on its divergence and sequence identity to human protein, update its divergence: if divergence > 600, subtract 50 if sequence identity > '40%', else subtract 30; if divergence is 400 to 600, subtract 20 if sequence identity > '30%', else subtract 10; if divergence < 400, subtract 5.",
    "natural_language": "Hey, can you whip up a stored procedure called AdjustProteinDivergence that goes through all the proteins one by one? For each one, we gotta tweak its divergence based on how different it is from the human protein. Here's the deal: if the divergence is over 600, knock off 50 points if the sequence identity is better than '40%', otherwise just take off 30. If it's between 400 and 600, drop it by 20 if the sequence identity tops '30%', or just 10 if it doesn't. And for anything under 400, just subtract a flat 5.",
    "id": 99
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `DeleteSchoolDetails` that is designed to remove records from a database table. This procedure accepts one input parameter: `p_school_id`, which is of the `NUMBER` data type. The purpose of this parameter is to specify the unique identifier of the school whose details are to be deleted. The procedure performs a `DELETE` operation on the `SCHOOL_DETAILS` table. The deletion is conditional, meaning only specific rows will be affected. The condition for deletion is `SCHOOL_ID = p_school_id`, which means that any row in the `SCHOOL_DETAILS` table where the value in the `SCHOOL_ID` column exactly matches the value provided in the `p_school_id` input parameter will be targeted for removal.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteSchoolDetails (\n    p_school_id IN NUMBER\n) AS\nBEGIN\n    DELETE FROM SCHOOL_DETAILS\n    WHERE SCHOOL_ID = p_school_id;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteSchoolDetails(1);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(2);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(3);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(4);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(5);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteSchoolDetails that accepts a school ID parameter and deletes all records from the SCHOOL_DETAILS table where the SCHOOL_ID matches the provided parameter.",
    "natural_language": "Construct a stored procedure called DeleteSchoolDetails that is designed to take a school ID as its input parameter and meticulously remove every single associated record from the SCHOOL_DETAILS table, specifically targeting those entries where the SCHOOL_ID column perfectly corresponds to the provided identifier.",
    "id": 100
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `MergeSchoolInfo` that accepts three input parameters: `p_school_id` of data type `NUMBER`, `p_nickname` of data type `VARCHAR2`, and `p_colors` of data type `VARCHAR2`. The primary purpose of this procedure is to perform a conditional data modification operation on the `SCHOOL_DETAILS` table. This operation involves either updating an existing record or inserting a new record based on the presence of a matching `SCHOOL_ID`. The procedure utilizes a `MERGE` statement, which combines `INSERT` and `UPDATE` functionalities into a single SQL statement. The target table for this `MERGE` operation is `SCHOOL_DETAILS`, aliased as `sd`. The source for the `MERGE` operation is a subquery `(SELECT p_school_id AS sid FROM DUAL) src`. This subquery effectively creates a single-row, single-column virtual table where the column `sid` holds the value passed into the `p_school_id` parameter of the procedure. The `MERGE` statement's `ON` clause specifies the join condition between the target table `SCHOOL_DETAILS` and the source `src`. This condition is `sd.SCHOOL_ID = src.sid`, meaning that records in `SCHOOL_DETAILS` are matched with the source record if their `SCHOOL_ID` column value is equal to the `sid` value from the source (which is `p_school_id`).\n\nIf a match is found based on this condition (`WHEN MATCHED THEN`), the procedure executes an `UPDATE` operation on the matched row in the `SCHOOL_DETAILS` table. Specifically, it sets the `NICKNAME` column of the matched row to the value provided by the `p_nickname` parameter, and it sets the `COLORS` column of the matched row to the value provided by the `p_colors` parameter.\n\nIf no match is found based on the `ON` clause condition (`WHEN NOT MATCHED THEN`), the procedure executes an `INSERT` operation. A new row is inserted into the `SCHOOL_DETAILS` table. The `SCHOOL_ID` column of this new row is populated with the value from the `p_school_id` parameter, the `NICKNAME` column is populated with the value from the `p_nickname` parameter, and the `COLORS` column is populated with the value from the `p_colors` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE MergeSchoolInfo (\n    p_school_id IN NUMBER,\n    p_nickname IN VARCHAR2,\n    p_colors IN VARCHAR2\n) AS\nBEGIN\n    MERGE INTO SCHOOL_DETAILS sd\n    USING (SELECT p_school_id AS sid FROM DUAL) src\n    ON (sd.SCHOOL_ID = src.sid)\n    WHEN MATCHED THEN\n        UPDATE SET sd.NICKNAME = p_nickname, sd.COLORS = p_colors\n    WHEN NOT MATCHED THEN\n        INSERT (SCHOOL_ID, NICKNAME, COLORS)\n        VALUES (p_school_id, p_nickname, p_colors);\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "BEGIN\n  MergeSchoolInfo(1, 'Tigers', 'Blue and Gold');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(5, 'Eagles', 'Green and White');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(2, 'Auks', 'Dark Green and White');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(3, 'Buccaneers', 'Garnet and White');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(10, 'Lions', 'Purple and Black');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named MergeSchoolInfo that accepts a school ID (NUMBER), nickname (VARCHAR2), and colors (VARCHAR2). Use a MERGE statement to update the SCHOOL_DETAILS table if a matching SCHOOL_ID exists, setting NICKNAME and COLORS. If no match exists, insert a new row with the provided values.",
    "natural_language": "Hey, can you whip up a stored procedure called MergeSchoolInfo? It needs to take in a school ID (as a NUMBER), a nickname (as a VARCHAR2), and some colors (also a VARCHAR2). Here's the deal: use a MERGE statement to check the SCHOOL_DETAILS table. If you find a row with the same SCHOOL_ID, just go ahead and update its NICKNAME and COLORS. If that ID isn't there at all, no worriesjust pop in a brand new row with all the info we've got.",
    "id": 101
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_cargo_ship_missions that takes no parameters and begins by declaring a local variable v_ship_count of type NUMBER. The procedure first executes a SELECT statement to calculate a count of distinct SHIP_ID values from the SHIP table, where the TYPE column equals the string literal 'Cargo ship' and where a correlated subquery using EXISTS finds at least one matching row in the MISSION table for that SHIP_ID; this count is stored into the variable v_ship_count. The procedure then uses an IF-THEN-ELSE conditional block: if v_ship_count is greater than 5, it executes a DELETE operation on the MISSION table, removing rows where the SHIP_ID is found in a subquery selecting SHIP_ID from the SHIP table where TYPE is 'Cargo ship', and where the LAUNCHED_YEAR column is less than 1920. Otherwise, if v_ship_count is 5 or less, it executes an INSERT operation into the MISSION table, specifying columns MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, and FATE. The values for this INSERT are derived from a SELECT statement that queries the SHIP table for rows where TYPE is 'Cargo ship' and where a correlated subquery using NOT EXISTS confirms no matching row exists in the MISSION table for that SHIP_ID; the ROWNUM = 1 condition limits the result to a single row. For each selected ship row, the MISSION_ID is generated by a scalar subquery that selects the maximum existing MISSION_ID from the MISSION table, uses the NVL function to substitute 0 if the maximum is null, and adds 1; the SHIP_ID is taken directly from the ship row; the CODE column is constructed by concatenating the string 'CARGO-', the result of applying the LOWER function to a substring of the ship's NAME column from the first character for a length of three characters, and the string '-M'; the LAUNCHED_YEAR is set to the current year extracted from SYSDATE using the EXTRACT(YEAR FROM ...) function; the LOCATION is set to the string 'Cargo Port'; the SPEED_KNOTS is set to the number 15; and the FATE is set to the string 'Active'.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_cargo_ship_missions\nIS\n   v_ship_count NUMBER;\nBEGIN\n   SELECT COUNT(DISTINCT s.SHIP_ID)\n   INTO v_ship_count\n   FROM SHIP s\n   WHERE s.TYPE = 'Cargo ship'\n   AND EXISTS (SELECT 1 FROM MISSION m WHERE m.SHIP_ID = s.SHIP_ID);\n   \n   IF v_ship_count > 5 THEN\n      DELETE FROM MISSION\n      WHERE SHIP_ID IN (SELECT SHIP_ID FROM SHIP WHERE TYPE = 'Cargo ship')\n      AND LAUNCHED_YEAR < 1920;\n   ELSE\n      INSERT INTO MISSION (MISSION_ID, SHIP_ID, CODE, LAUNCHED_YEAR, LOCATION, SPEED_KNOTS, FATE)\n      SELECT (SELECT NVL(MAX(MISSION_ID), 0) + 1 FROM MISSION),\n             s.SHIP_ID,\n             'CARGO-' || LOWER(SUBSTR(s.NAME, 1, 3)) || '-M',\n             EXTRACT(YEAR FROM SYSDATE),\n             'Cargo Port',\n             15,\n             'Active'\n      FROM SHIP s\n      WHERE s.TYPE = 'Cargo ship'\n      AND NOT EXISTS (SELECT 1 FROM MISSION m WHERE m.SHIP_ID = s.SHIP_ID)\n      AND ROWNUM = 1;\n   END IF;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "BEGIN\n  process_cargo_ship_missions;\n  commit;\nEND;"
    ],
    "summary": "Create a parameterless stored procedure named process_cargo_ship_missions. Count cargo ships with missions. If the count exceeds 5, delete missions for cargo ships launched before 1920. Otherwise, insert a new mission for one cargo ship without an existing mission, generating a new MISSION_ID, a CODE based on the ship's name, and using current year, 'Cargo Port', 15, and 'Active' for other fields.",
    "natural_language": "Alright, so we need a stored procedure called process_cargo_ship_missions, no parameters. First, figure out how many cargo ships have missions. If there's more than five of 'em, get rid of all missions for cargo ships that were launched way back before 1920. If there aren't that many, then we gotta add a brand new mission for a cargo ship that doesn't already have one. For that new mission, whip up a fresh MISSION_ID, make a CODE based on the ship's name, and fill in the other details with the current year, 'Cargo Port', 15, and 'Active'.",
    "id": 102
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named merge_nationality_data that performs operations on the SHIP table based on the comparison of the number of ships with 'United Kingdom' and 'United States' nationalities. The procedure declares two local variables, v_uk_ships and v_us_ships, both of type NUMBER, to store the count of ships for each nationality. It begins by executing a SELECT statement to count the number of ships with the nationality 'United Kingdom' and stores this count in v_uk_ships. Similarly, it executes another SELECT statement to count the number of ships with the nationality 'United States' and stores this count in v_us_ships. The procedure then evaluates an IF statement to compare the values of v_uk_ships and v_us_ships. If the number of 'United Kingdom' ships is greater than the number of 'United States' ships, it executes a DELETE operation on the SHIP table. This DELETE operation removes rows where the SHIP_ID is found in a subquery that selects SHIP_IDs from the SHIP table, left-joined with the MISSION table on the SHIP_ID column, where the MISSION_ID is NULL and the nationality is 'United States'. If the number of 'United Kingdom' ships is not greater, the procedure executes an INSERT operation into the SHIP table. This INSERT operation adds a new row with the SHIP_ID set to one more than the current maximum SHIP_ID in the SHIP table, the NAME set to a string 'MERGE-' concatenated with the current system time formatted as 'HH24MISS', the TYPE set to 'Merged Type', the NATIONALITY set to 'United Kingdom', and the TONNAGE set to the rounded average tonnage of ships with the nationality 'United States' and tonnage greater than 3000.",
    "plsql": "CREATE OR REPLACE PROCEDURE merge_nationality_data\nIS\n   v_uk_ships NUMBER;\n   v_us_ships NUMBER;\nBEGIN\n   SELECT COUNT(*)\n   INTO v_uk_ships\n   FROM SHIP\n   WHERE NATIONALITY = 'United Kingdom';\n   \n   SELECT COUNT(*)\n   INTO v_us_ships\n   FROM SHIP\n   WHERE NATIONALITY = 'United States';\n   \n   IF v_uk_ships > v_us_ships THEN\n      DELETE FROM SHIP\n      WHERE SHIP_ID IN (SELECT s.SHIP_ID\n                       FROM SHIP s\n                       LEFT JOIN MISSION m ON s.SHIP_ID = m.SHIP_ID\n                       WHERE m.MISSION_ID IS NULL\n                       AND s.NATIONALITY = 'United States');\n   ELSE\n      INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE)\n      SELECT (SELECT NVL(MAX(SHIP_ID), 0) + 1 FROM SHIP),\n             'MERGE-' || TO_CHAR(SYSDATE, 'HH24MISS'),\n             'Merged Type',\n             'United Kingdom',\n             ROUND(AVG(TONNAGE))\n      FROM SHIP\n      WHERE NATIONALITY = 'United States'\n      AND TONNAGE > 3000;\n   END IF;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "BEGIN\n  merge_nationality_data;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named merge_nationality_data. Count ships from the United Kingdom and the United States. If UK ships outnumber US ships, delete US ships without missions. Otherwise, insert a new UK ship with an ID one greater than the max, a name based on the current time, 'Merged Type' as TYPE, and a tonnage equal to the rounded average of US ships with tonnage over 3000.",
    "natural_language": "Develop a stored procedure called merge_nationality_data, which will first determine the total number of vessels originating from the United Kingdom and then separately count those from the United States. Should the tally of British ships exceed the count of American ones, proceed to meticulously delete all United States ships that currently have no missions assigned to them. Conversely, if the American ships are equal in number or greater, you must instead insert a brand new United Kingdom ship, carefully assigning it an ID that is precisely one higher than the maximum existing ship ID, a unique name dynamically generated from the exact current system timestamp, a designated TYPE of 'Merged Type', and a tonnage calculated by taking the rounded mathematical average of the tonnage from all United States ships whose individual tonnage is specifically over 3000.",
    "id": 103
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_departments that accepts three parameters: p_source_dept_id of type NUMBER, p_target_dept_id of type NUMBER, and p_transfer_date of type VARCHAR2. This procedure is designed to consolidate employees from one department to another within a database. It begins by declaring a cursor named emp_cursor, which selects the employee_id and job_id columns from the employees table where the department_id matches the p_source_dept_id parameter. The procedure then enters a loop that iterates over each record fetched by the cursor. For each employee record, it performs the following operations: inserts a new record into the job_history table with the employee_id, the current timestamp formatted as 'YYYY-MM-DD' for the start_date, the p_transfer_date for the end_date, the job_id, and the p_source_dept_id as the department_id; deletes the employee record from the employees table where the employee_id matches the current record's employee_id; and inserts a new record into the employees table by selecting all columns except department_id from the existing employee record and setting the department_id to p_target_dept_id. After processing all employees, the procedure deletes the department record from the departments table where the department_id matches the p_source_dept_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_departments(p_source_dept_id NUMBER, p_target_dept_id NUMBER, p_transfer_date VARCHAR2)\nIS\n    CURSOR emp_cursor IS SELECT employee_id, job_id FROM employees WHERE department_id = p_source_dept_id;\nBEGIN\n    FOR rec IN emp_cursor LOOP\n        INSERT INTO job_history (employee_id, start_date, end_date, job_id, department_id) VALUES (rec.employee_id, TO_CHAR(LOCALTIMESTAMP, 'YYYY-MM-DD'), p_transfer_date, rec.job_id, p_source_dept_id);\n        DELETE FROM employees WHERE employee_id = rec.employee_id;\n        INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id) SELECT employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, p_target_dept_id FROM employees WHERE employee_id = rec.employee_id;\n    END LOOP;\n    DELETE FROM departments WHERE department_id = p_source_dept_id;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  consolidate_departments(10, 20, '2023-10-01');\n  commit;\nEND;",
      "BEGIN\n  consolidate_departments(20, 30, '2023-10-02');\n  commit;\nEND;",
      "BEGIN\n  consolidate_departments(30, 10, '2023-10-03');\n  commit;\nEND;",
      "BEGIN\n  consolidate_departments(10, 30, '2023-10-04');\n  commit;\nEND;",
      "BEGIN\n  consolidate_departments(20, 10, '2023-10-05');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named consolidate_departments that accepts source department ID, target department ID, and a transfer date (VARCHAR2). For each employee in the source department: record their job history with the transfer date as the end date, delete them, and re-insert them into the target department. Finally, delete the source department.",
    "natural_language": "How can I create a stored procedure called consolidate_departments that takes a source department ID, a target department ID, and a transfer date as a VARCHAR2, and for each employee in the source department, records their job history with the transfer date as the end date, deletes them, and then re-inserts them into the target department before finally deleting the source department?",
    "id": 104
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named migrate_management_chain that accepts three parameters: a numeric parameter p_old_manager_id representing the employee ID of a manager to be replaced, a numeric parameter p_new_manager_id representing the employee ID of the new manager, and a string parameter p_transition_date. The procedure first declares a cursor named dept_cursor that selects the department_id column from the departments table for all rows where the manager_id column equals the input parameter p_old_manager_id. It also declares a second cursor named emp_cursor that selects the employee_id column from the employees table for all rows where the manager_id column equals p_old_manager_id. The procedure then enters a loop that iterates over each record fetched by the dept_cursor. For each department record, it performs three operations: first, it inserts a new row into the job_history table by selecting data from the employees table where the employee_id equals p_old_manager_id; the inserted values are p_old_manager_id for the employee_id column, the current local timestamp converted to a 'YYYY-MM-DD' format string for the start_date column, the input parameter p_transition_date for the end_date column, the job_id from the employees table for the job_id column, and the department_id from the employees table for the department_id column. Second, it deletes the row from the departments table where the department_id matches the department_id from the current dept_cursor record. Third, it inserts a new row back into the departments table by selecting all columns from the departments table where the department_id matches the current dept_cursor record's department_id, but substitutes the p_new_manager_id value for the manager_id column in the new row. After processing all departments, the procedure enters a second loop that iterates over each record fetched by the emp_cursor. For each employee record, it performs three operations: first, it inserts a new row into the job_history table by selecting data from the employees table where the employee_id equals the current emp_cursor record's employee_id; the inserted values are the current emp_cursor record's employee_id for the employee_id column, the input parameter p_transition_date for the start_date column, a NULL value for the end_date column, the job_id from the employees table for the job_id column, and the department_id from the employees table for the department_id column. Second, it deletes the row from the employees table where the employee_id matches the current emp_cursor record's employee_id. Third, it inserts a new row back into the employees table by selecting all columns from the employees table where the employee_id matches the current emp_cursor record's employee_id, but substitutes the p_new_manager_id value for the manager_id column in the new row.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_management_chain(p_old_manager_id NUMBER, p_new_manager_id NUMBER, p_transition_date VARCHAR2)\nIS\n    CURSOR dept_cursor IS SELECT department_id FROM departments WHERE manager_id = p_old_manager_id;\n    CURSOR emp_cursor IS SELECT employee_id FROM employees WHERE manager_id = p_old_manager_id;\nBEGIN\n    FOR dept_rec IN dept_cursor LOOP\n        INSERT INTO job_history (employee_id, start_date, end_date, job_id, department_id) SELECT p_old_manager_id, TO_CHAR(LOCALTIMESTAMP, 'YYYY-MM-DD'), p_transition_date, job_id, department_id FROM employees WHERE employee_id = p_old_manager_id;\n        DELETE FROM departments WHERE department_id = dept_rec.department_id;\n        INSERT INTO departments (department_id, department_name, manager_id, location_id) SELECT department_id, department_name, p_new_manager_id, location_id FROM departments WHERE department_id = dept_rec.department_id;\n    END LOOP;\n    FOR emp_rec IN emp_cursor LOOP\n        INSERT INTO job_history (employee_id, start_date, end_date, job_id, department_id) SELECT emp_rec.employee_id, p_transition_date, NULL, job_id, department_id FROM employees WHERE employee_id = emp_rec.employee_id;\n        DELETE FROM employees WHERE employee_id = emp_rec.employee_id;\n        INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id) SELECT employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, p_new_manager_id, department_id FROM employees WHERE employee_id = emp_rec.employee_id;\n    END LOOP;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  migrate_management_chain(200, 100, '2023-01-01');\nEND;",
      "BEGIN\n  migrate_management_chain(201, 101, '2023-02-15');\nEND;",
      "BEGIN\n  migrate_management_chain(114, 102, '2023-03-10');\nEND;",
      "BEGIN\n  migrate_management_chain(0, 100, '2023-04-20');\nEND;",
      "BEGIN\n  migrate_management_chain(100, 200, '2023-05-05');\nEND;"
    ],
    "summary": "Create a stored procedure named migrate_management_chain that accepts an old manager ID, a new manager ID, and a transition date (VARCHAR2). For each department managed by the old manager: record the old manager's job history, delete the department, and re-insert it with the new manager. For each employee reporting to the old manager: record their job history starting on the transition date, delete them, and re-insert them reporting to the new manager.",
    "natural_language": "Develop a stored procedure, to be named migrate_management_chain, which must accept three distinct parameters: an old manager's identification number, a new manager's identification number, and a specific transition date provided as a VARCHAR2 string. For every single department that is currently under the supervision of the old manager, the procedure should meticulously perform the following sequence: first, it must create a permanent record of the old manager's job history within that department; subsequently, it should delete the existing department entry entirely; and finally, it must carefully re-insert that very same department, now officially assigning the new manager as its head. Furthermore, for each individual employee who directly reports to the old manager, the procedure is required to systematically capture their job history commencing precisely on the provided transition date, then proceed to delete their current record, and ultimately re-insert them into the system with their reporting relationship correctly updated to point to the new manager.",
    "id": 105
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named archive_historical_data that accepts three parameters: p_years_back of type NUMBER, p_department_filter of type NUMBER, and p_action_flag of type VARCHAR2. The procedure begins by declaring a local variable v_cutoff_date of type VARCHAR2(255) to store a date string, and a cursor named hist_cursor that selects employee_id and start_date from the job_history table where the department_id matches the p_department_filter parameter and the start_date is earlier than v_cutoff_date. Another local variable v_new_employee_id of type NUMBER is declared to hold a new employee ID. The procedure calculates v_cutoff_date by subtracting p_years_back years from the current local timestamp using the ADD_MONTHS function and formats it as 'YYYY-MM-DD'. If the p_action_flag parameter equals 'ARCHIVE', the procedure enters a loop over the hist_cursor, generating a new unique employee_id by selecting the maximum employee_id from the employees table and adding 1. It then inserts a new row into the employees table with the generated employee_id, static values for first_name, last_name, email, phone_number, and hire_date, and values from the job_history table for job_id and department_id, setting salary, commission_pct, and manager_id to 0. The procedure deletes the corresponding row from the job_history table using the employee_id and start_date from the cursor. If the p_action_flag parameter equals 'PURGE', the procedure deletes rows from the job_history table where the department_id matches p_department_filter and the start_date is earlier than v_cutoff_date.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_historical_data(p_years_back NUMBER, p_department_filter NUMBER, p_action_flag VARCHAR2)\nIS\n    v_cutoff_date VARCHAR2(255);\n    CURSOR hist_cursor IS SELECT employee_id, start_date FROM job_history WHERE department_id = p_department_filter AND start_date < v_cutoff_date;\n    v_new_employee_id NUMBER;\nBEGIN\n    v_cutoff_date := TO_CHAR(ADD_MONTHS(LOCALTIMESTAMP, -12 * p_years_back), 'YYYY-MM-DD');\n    IF p_action_flag = 'ARCHIVE' THEN\n        FOR rec IN hist_cursor LOOP\n            -- Generate a new unique employee_id\n            SELECT MAX(employee_id) + 1 INTO v_new_employee_id FROM employees;\n            INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id)\n            SELECT v_new_employee_id, 'ARCHIVED', 'EMPLOYEE', 'ARCHIVE', '000-000-0000', jh.start_date, jh.job_id, 0, 0, 0, jh.department_id\n            FROM job_history jh\n            WHERE jh.employee_id = rec.employee_id AND jh.start_date = rec.start_date;\n            DELETE FROM job_history WHERE employee_id = rec.employee_id AND start_date = rec.start_date;\n        END LOOP;\n    ELSIF p_action_flag = 'PURGE' THEN\n        DELETE FROM job_history WHERE department_id = p_department_filter AND start_date < v_cutoff_date;\n    END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  archive_historical_data(5, 10, 'ARCHIVE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(3, 20, 'PURGE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(2, 30, 'ARCHIVE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(4, 10, 'PURGE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(1, 20, 'ARCHIVE');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named archive_historical_data that archives or purges historical job data. It accepts parameters for years back, department filter, and action flag. For 'ARCHIVE' action: move qualifying job_history records to employees table with new IDs and static default values, then delete from job_history. For 'PURGE' action: directly delete qualifying job_history records. Qualification is based on department match and start date older than calculated cutoff.",
    "natural_language": "Create a stored procedure called archive_historical_data to archive or purge old job data. The procedure must take parameters for the number of years back, a department filter, and an action flag. If the action is 'ARCHIVE', move the qualifying job_history records to the employees table using new IDs and static default values, then delete those records from job_history. If the action is 'PURGE', directly delete the qualifying job_history records from job_history. Determine qualification by matching the department and checking if the start date is older than the calculated cutoff date.",
    "id": 106
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ProcessResidentService that accepts two input parameters: p_resident_id of type NUMBER, representing the unique identifier of a resident, and p_service_id of type NUMBER, representing the unique identifier of a service. The procedure begins by declaring four local variables: v_service_type of type VARCHAR2(255) to store the type of service, v_count of type NUMBER to store the count of existing records, v_property_id of type NUMBER to store the property ID associated with the resident, and v_date_moved_in of type VARCHAR2(255) to store the date the resident moved in. The procedure first executes a SELECT statement to count the number of records in the RESIDENTS_SERVICES table where the RESIDENT_ID matches p_resident_id and the SERVICE_ID matches p_service_id, storing the result in v_count. If v_count is zero, indicating no existing record for the specified resident and service, the procedure retrieves the SERVICE_TYPE_CODE from the SERVICES table where the SERVICE_ID matches p_service_id and stores it in v_service_type. It then attempts to retrieve the PROPERTY_ID and DATE_MOVED_IN from the RESIDENTS_SERVICES table for the given RESIDENT_ID, limiting the result to one row using ROWNUM = 1, and stores these values in v_property_id and v_date_moved_in, respectively. If no data is found, it assigns default values of 954 to v_property_id and '2017-06-17 15:43:33' to v_date_moved_in. The procedure then evaluates the value of v_service_type using an IF-ELSIF-ELSE conditional structure. If v_service_type is 'CLEANNING' (case-insensitive), it inserts a new record into the RESIDENTS_SERVICES table with the provided RESIDENT_ID, SERVICE_ID, the retrieved or default DATE_MOVED_IN, PROPERTY_ID, the current system date and time as DATE_REQUESTED, NULL as DATE_PROVIDED, and 'Pending' as OTHER_DETAILS. If v_service_type is 'CHECK', it inserts a new record with the same values but sets DATE_PROVIDED to the current system date and time and OTHER_DETAILS to 'Completed'. For any other service type, it inserts a record with OTHER_DETAILS set to 'Other' and DATE_PROVIDED as NULL.",
    "plsql": "CREATE OR REPLACE PROCEDURE ProcessResidentService(\n  p_resident_id IN NUMBER,\n  p_service_id IN NUMBER\n) AS\n  v_service_type VARCHAR2(255);\n  v_count NUMBER;\n  v_property_id NUMBER;\n  v_date_moved_in VARCHAR2(255);\nBEGIN\n  SELECT COUNT(*) INTO v_count\n  FROM RESIDENTS_SERVICES\n  WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = p_service_id;\n\n  IF v_count = 0 THEN\n    SELECT SERVICE_TYPE_CODE INTO v_service_type\n    FROM SERVICES\n    WHERE SERVICE_ID = p_service_id;\n\n    -- Get existing PROPERTY_ID and DATE_MOVED_IN for this resident to satisfy FK constraint\n    BEGIN\n      SELECT PROPERTY_ID, DATE_MOVED_IN INTO v_property_id, v_date_moved_in\n      FROM RESIDENTS_SERVICES\n      WHERE RESIDENT_ID = p_resident_id\n      AND ROWNUM = 1;\n    EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n        -- If no existing record for this resident, use example values that exist\n        v_property_id := 954;\n        v_date_moved_in := '2017-06-17 15:43:33';\n    END;\n\n    IF UPPER(v_service_type) = 'CLEANNING' THEN\n      INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n      VALUES (p_resident_id, p_service_id, v_date_moved_in, v_property_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL, 'Pending');\n    ELSIF UPPER(v_service_type) = 'CHECK' THEN\n      INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n      VALUES (p_resident_id, p_service_id, v_date_moved_in, v_property_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'Completed');\n    ELSE\n      INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n      VALUES (p_resident_id, p_service_id, v_date_moved_in, v_property_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL, 'Other');\n    END IF;\n  END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  ProcessResidentService(p_resident_id => 6, p_service_id => 10);\nEND;",
      "BEGIN\n  ProcessResidentService(p_resident_id => 23, p_service_id => 11);\nEND;",
      "BEGIN\n  ProcessResidentService(p_resident_id => 28, p_service_id => 13);\nEND;",
      "BEGIN\n  ProcessResidentService(p_resident_id => 6, p_service_id => 49);\nEND;",
      "BEGIN\n  ProcessResidentService(p_resident_id => 23, p_service_id => 41);\nEND;"
    ],
    "summary": "Create a stored procedure named ProcessResidentService that processes service requests for residents. It checks for existing resident-service records. If none exist, it retrieves service type and resident property/move-in details (with defaults if missing). Based on service type ('CLEANNING', 'CHECK', or other), it inserts a new record with appropriate status ('Pending', 'Completed', or 'Other') and date values.",
    "natural_language": "Create procedure ProcessResidentService to handle service requests. Check for existing records. If none, get service type and resident details. Insert new record with status ('Pending', 'Completed', or 'Other') and dates based on service type.",
    "id": 107
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `TransformServiceDetails` that accepts two input parameters: `p_resident_id` of type `NUMBER`, representing the unique identifier for a resident, and `p_service_id` of type `NUMBER`, representing the unique identifier for a service. The procedure declares four local variables: `v_service_details` of type `VARCHAR2(255)` to store service details, `v_other_details` of type `VARCHAR2(255)` to store other service-related details, `v_new_details` of type `VARCHAR2(255)` to store the transformed service details, and `v_record_exists` of type `NUMBER` initialized to `0` to indicate whether a record exists.\n\nThe procedure begins by executing a `SELECT` statement to retrieve data from the `SERVICES` and `RESIDENTS_SERVICES` tables. It selects the `SERVICE_DETAILS` column from the `SERVICES` table into `v_service_details` and the `OTHER_DETAILS` column from the `RESIDENTS_SERVICES` table into `v_other_details`. This `SELECT` statement performs a `LEFT JOIN` between `SERVICES` (aliased as `s`) and `RESIDENTS_SERVICES` (aliased as `rs`) on the condition that `s.SERVICE_ID` equals `rs.SERVICE_ID` and `rs.RESIDENT_ID` equals the input parameter `p_resident_id`. The `WHERE` clause further filters the results to records where `s.SERVICE_ID` equals the input parameter `p_service_id`.\n\nFollowing the data retrieval, the procedure enters a conditional logic block to determine the value of `v_new_details`.\nIf `v_service_details` is equal to the string literal 'Satisfied' AND `v_other_details` is NOT `NULL`, then `v_new_details` is assigned a value constructed by concatenating the uppercase version of the first three characters of `v_other_details` (obtained using `UPPER(SUBSTR(v_other_details, 1, 3))`) with the string literal '_COMPLETE'.\nElse if `v_service_details` IS `NULL`, then `v_new_details` is assigned the string literal 'UNKNOWN_STATUS'.\nOtherwise (if `v_service_details` is not 'Satisfied' and not `NULL`), `v_new_details` is assigned a value constructed by concatenating the lowercase version of `v_service_details` (obtained using `LOWER(v_service_details)`) with the string literal '_PROCESSED'.\n\nNext, the procedure executes another `SELECT` statement to check for the existence of a record in the `RESIDENTS_SERVICES` table. It counts the number of rows where `RESIDENT_ID` equals `p_resident_id` and `SERVICE_ID` equals `p_service_id`, storing this count in the `v_record_exists` variable.\n\nSubsequently, the procedure enters another conditional logic block based on the value of `v_record_exists`.\nIf `v_record_exists` is greater than `0` (meaning a matching record exists), the procedure executes an `UPDATE` statement on the `RESIDENTS_SERVICES` table. It sets the `OTHER_DETAILS` column to the value of `v_new_details` and the `DATE_PROVIDED` column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' (obtained using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`). This update is applied to the row(s) where `RESIDENT_ID` equals `p_resident_id` and `SERVICE_ID` equals `p_service_id`.\nElse (if `v_record_exists` is not greater than `0`, meaning no matching record exists), the procedure outputs a message to the `DBMS_OUTPUT` buffer indicating that no existing record was found for the given `RESIDENT_ID` and `SERVICE_ID`. The message is constructed by concatenating the string literal 'No existing record found for RESIDENT_ID: ', the value of `p_resident_id`, the string literal ', SERVICE_ID: ', and the value of `p_service_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE TransformServiceDetails(\n  p_resident_id IN NUMBER,\n  p_service_id IN NUMBER\n) AS\n  v_service_details VARCHAR2(255);\n  v_other_details VARCHAR2(255);\n  v_new_details VARCHAR2(255);\n  v_record_exists NUMBER := 0;\nBEGIN\n  SELECT s.SERVICE_DETAILS, rs.OTHER_DETAILS INTO v_service_details, v_other_details\n  FROM SERVICES s\n  LEFT JOIN RESIDENTS_SERVICES rs ON s.SERVICE_ID = rs.SERVICE_ID AND rs.RESIDENT_ID = p_resident_id\n  WHERE s.SERVICE_ID = p_service_id;\n\n  IF v_service_details = 'Satisfied' AND v_other_details IS NOT NULL THEN\n    v_new_details := UPPER(SUBSTR(v_other_details, 1, 3)) || '_COMPLETE';\n  ELSIF v_service_details IS NULL THEN\n    v_new_details := 'UNKNOWN_STATUS';\n  ELSE\n    v_new_details := LOWER(v_service_details) || '_PROCESSED';\n  END IF;\n\n  -- Check if record exists in RESIDENTS_SERVICES\n  SELECT COUNT(*) INTO v_record_exists\n  FROM RESIDENTS_SERVICES\n  WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = p_service_id;\n\n  IF v_record_exists > 0 THEN\n    -- Update existing record\n    UPDATE RESIDENTS_SERVICES\n    SET OTHER_DETAILS = v_new_details,\n        DATE_PROVIDED = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n    WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = p_service_id;\n  ELSE\n    -- Record doesn't exist, cannot insert due to foreign key constraints\n    -- Log or handle this case as needed\n    DBMS_OUTPUT.PUT_LINE('No existing record found for RESIDENT_ID: ' || p_resident_id || ', SERVICE_ID: ' || p_service_id);\n  END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  TransformServiceDetails(6, 49);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(23, 41);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(28, 11);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(6, 11);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(23, 49);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named TransformServiceDetails that transforms and updates service details for a resident. It retrieves service details and other details via a join. It generates new transformed details based on conditional logic comparing these values. Then it checks for an existing record. If exists: updates OTHER_DETAILS and DATE_PROVIDED. If not exists: outputs a message indicating no record found.",
    "natural_language": "Hey, can you whip up a stored procedure called TransformServiceDetails? Basically, it needs to grab a resident's service info by joining some tables, then cook up some new details based on a few if-then checks comparing the old values. After that, it should look to see if there's already a record for this. If it finds one, it'll just update the OTHER_DETAILS and DATE_PROVIDED fields. If it comes up empty, just have it spit out a message saying \"No record found.\"",
    "id": 108
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ConsolidateDuplicateServices` that accepts two input parameters: `p_resident_id` of type `NUMBER`, representing the unique identifier of a resident, and `p_target_service_id` of type `NUMBER`, representing the unique identifier of the service that will be retained after consolidation.\n\nThe procedure begins by declaring three local variables: `v_service_type` of type `VARCHAR2(255)` to store the service type code, `v_max_date` of type `VARCHAR2(255)` to store the maximum `DATE_REQUESTED`, `v_total_property_id` of type `NUMBER` to store the sum of `PROPERTY_ID` values, and `v_date_moved_in` of type `VARCHAR2(255)` to store the maximum `DATE_MOVED_IN`.\n\nNext, the procedure defines a cursor named `service_cursor`. This cursor selects `SERVICE_ID`, `DATE_REQUESTED`, and `PROPERTY_ID` from the `RESIDENTS_SERVICES` table, aliased as `rs`. It joins `RESIDENTS_SERVICES` with the `SERVICES` table, aliased as `s`, on the condition `rs.SERVICE_ID = s.SERVICE_ID`. The selection is filtered by two conditions: `rs.RESIDENT_ID` must be equal to the input parameter `p_resident_id`, and `s.SERVICE_TYPE_CODE` must be equal to the `SERVICE_TYPE_CODE` retrieved from the `SERVICES` table where `SERVICE_ID` matches the input parameter `p_target_service_id`.\n\nThe executable part of the procedure starts by querying the `SERVICES` table to retrieve the `SERVICE_TYPE_CODE` for the `SERVICE_ID` specified by `p_target_service_id`. This retrieved `SERVICE_TYPE_CODE` is then stored into the local variable `v_service_type`.\n\nSubsequently, the procedure performs another query on the `RESIDENTS_SERVICES` table. This query calculates the maximum `DATE_REQUESTED`, the sum of `PROPERTY_ID`, and the maximum `DATE_MOVED_IN` for all records where `RESIDENT_ID` matches `p_resident_id` and `SERVICE_ID` is present in the set of `SERVICE_ID`s from the `SERVICES` table whose `SERVICE_TYPE_CODE` matches the `v_service_type` previously determined. The results of these aggregate functions are stored into the local variables `v_max_date`, `v_total_property_id`, and `v_date_moved_in`, respectively.\n\nFollowing these selections, the procedure enters a `FOR` loop that iterates through each record returned by the `service_cursor`. For each `service_rec` fetched by the cursor, a `DELETE` operation is performed on the `RESIDENTS_SERVICES` table. This `DELETE` statement removes rows where `RESIDENT_ID` matches `p_resident_id` and `SERVICE_ID` matches the `SERVICE_ID` from the current `service_rec`. This effectively removes all existing service entries for the specified resident that belong to the same service type as the target service.\n\nFinally, after deleting the duplicate service entries, the procedure performs an `INSERT` operation into the `RESIDENTS_SERVICES` table. A new record is inserted with the following values: `RESIDENT_ID` is set to `p_resident_id`, `SERVICE_ID` is set to `p_target_service_id`, `DATE_MOVED_IN` is set to the value stored in `v_date_moved_in`, `PROPERTY_ID` is set to the value stored in `v_total_property_id`, `DATE_REQUESTED` is set to the value stored in `v_max_date`, `DATE_PROVIDED` is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')` function, and `OTHER_DETAILS` is set to the literal string 'Consolidated'. This insertion creates a single consolidated service entry for the resident, using the target service ID and aggregated information from the previously existing services of the same type.",
    "plsql": "CREATE OR REPLACE PROCEDURE ConsolidateDuplicateServices(\n  p_resident_id IN NUMBER,\n  p_target_service_id IN NUMBER\n) AS\n  v_service_type VARCHAR2(255);\n  v_max_date VARCHAR2(255);\n  v_total_property_id NUMBER;\n  v_date_moved_in VARCHAR2(255);\n  CURSOR service_cursor IS\n    SELECT rs.SERVICE_ID, rs.DATE_REQUESTED, rs.PROPERTY_ID\n    FROM RESIDENTS_SERVICES rs\n    JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n    WHERE rs.RESIDENT_ID = p_resident_id\n    AND s.SERVICE_TYPE_CODE = (SELECT SERVICE_TYPE_CODE FROM SERVICES WHERE SERVICE_ID = p_target_service_id);\nBEGIN\n  SELECT SERVICE_TYPE_CODE INTO v_service_type\n  FROM SERVICES\n  WHERE SERVICE_ID = p_target_service_id;\n\n  SELECT MAX(DATE_REQUESTED), SUM(PROPERTY_ID), MAX(DATE_MOVED_IN) INTO v_max_date, v_total_property_id, v_date_moved_in\n  FROM RESIDENTS_SERVICES\n  WHERE RESIDENT_ID = p_resident_id\n  AND SERVICE_ID IN (SELECT SERVICE_ID FROM SERVICES WHERE SERVICE_TYPE_CODE = v_service_type);\n\n  FOR service_rec IN service_cursor LOOP\n    DELETE FROM RESIDENTS_SERVICES\n    WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = service_rec.SERVICE_ID;\n  END LOOP;\n\n  INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n  VALUES (p_resident_id, p_target_service_id, v_date_moved_in, v_total_property_id, v_max_date, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'Consolidated');\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  ConsolidateDuplicateServices(6, 49);\n  COMMIT;\nEND;",
      "BEGIN\n  ConsolidateDuplicateServices(23, 41);\n  COMMIT;\nEND;",
      "BEGIN\n  ConsolidateDuplicateServices(28, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  ConsolidateDuplicateServices(6, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  ConsolidateDuplicateServices(23, 13);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named ConsolidateDuplicateServices that consolidates duplicate service records for a resident. It identifies all services of the same type as a target service. It aggregates their maximum DATE_REQUESTED, sum of PROPERTY_ID, and maximum DATE_MOVED_IN. It deletes all those duplicate service records. Finally, it inserts a single consolidated record using the target service ID and the aggregated values, with DATE_PROVIDED as current time and OTHER_DETAILS as 'Consolidated'.",
    "natural_language": "Create a stored procedure called ConsolidateDuplicateServices that handles some duplicate service entries for a resident. It finds services that are roughly the same type as a given main service. It then pulls together their most recent DATE_REQUESTED, adds up the PROPERTY_ID numbers, and takes the latest DATE_MOVED_IN. After that, it removes all those extra, similar service records. Finally, it puts in one combined record using the main service's ID and the gathered info, setting DATE_PROVIDED to now and marking OTHER_DETAILS as something like 'Consolidated'.",
    "id": 109
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ValidateAndCleanServices` that accepts two input parameters: `p_resident_id` of type `NUMBER`, representing the unique identifier of a resident, and `p_min_property_id` of type `NUMBER`, representing a minimum property identifier threshold. The procedure begins by declaring three local variables: `v_invalid_count` of type `NUMBER` to store the count of invalid service records, `v_valid_count` of type `NUMBER` to store the count of valid service records, and `v_service_id_to_keep` of type `NUMBER` to store the `SERVICE_ID` of a valid service record that will be retained or used for insertion.\n\nThe procedure first executes a `SELECT` statement to count the number of \"invalid\" service records associated with the `p_resident_id`. This count is stored in `v_invalid_count`. The `SELECT` statement queries the `RESIDENTS_SERVICES` table, aliased as `rs`, and joins it with the `SERVICES` table, aliased as `s`, on the condition `rs.SERVICE_ID = s.SERVICE_ID`. The filtering conditions for invalid records are: `rs.RESIDENT_ID` must equal `p_resident_id`, AND (`rs.PROPERTY_ID` must be less than `p_min_property_id` OR `rs.DATE_REQUESTED` must be `NULL` OR `s.SERVICE_DETAILS` must be `NULL`).\n\nNext, the procedure executes another `SELECT` statement to count the number of \"valid\" service records associated with the `p_resident_id`. This count is stored in `v_valid_count`. This `SELECT` statement also queries the `RESIDENTS_SERVICES` table (aliased as `rs`) and joins it with the `SERVICES` table (aliased as `s`) on `rs.SERVICE_ID = s.SERVICE_ID`. The filtering conditions for valid records are: `rs.RESIDENT_ID` must equal `p_resident_id`, AND `rs.PROPERTY_ID` must be greater than or equal to `p_min_property_id`, AND `rs.DATE_REQUESTED` must NOT be `NULL`, AND `s.SERVICE_DETAILS` must NOT be `NULL`.\n\nFollowing these counts, the procedure enters a conditional block: `IF v_invalid_count > 0 THEN`. This means the subsequent operations will only execute if at least one invalid service record was found.\n\nInside this conditional block, a `SELECT` statement is executed to find the maximum `SERVICE_ID` among the valid service records for the given `p_resident_id`. This maximum `SERVICE_ID` is stored in `v_service_id_to_keep`. The `SELECT` statement queries `RESIDENTS_SERVICES` (aliased as `rs`) joined with `SERVICES` (aliased as `s`) on `rs.SERVICE_ID = s.SERVICE_ID`. The conditions for selecting these records are: `rs.RESIDENT_ID` must equal `p_resident_id`, AND `rs.PROPERTY_ID` must be greater than or equal to `p_min_property_id`, AND `rs.DATE_REQUESTED` must NOT be `NULL`, AND `s.SERVICE_DETAILS` must NOT be `NULL`.\n\nSubsequently, a `DELETE` statement is executed to remove specific records from the `RESIDENTS_SERVICES` table. The records to be deleted are those where `RESIDENT_ID` equals `p_resident_id` AND (`PROPERTY_ID` is less than `p_min_property_id` OR `DATE_REQUESTED` is `NULL`). Note that this `DELETE` statement does not consider the `SERVICES` table or the `SERVICE_DETAILS` column for its deletion criteria, only `RESIDENTS_SERVICES` table columns.\n\nAfter the deletion, another nested conditional block is entered: `IF v_service_id_to_keep IS NOT NULL THEN`. This means an insertion will only occur if a valid `SERVICE_ID` was found and stored in `v_service_id_to_keep`.\n\nInside this nested conditional block, an `INSERT` statement is executed to add a new record into the `RESIDENTS_SERVICES` table. The columns being populated are `RESIDENT_ID`, `SERVICE_ID`, `DATE_MOVED_IN`, `PROPERTY_ID`, `DATE_REQUESTED`, `DATE_PROVIDED`, and `OTHER_DETAILS`. The values for these columns are derived as follows:\n- `RESIDENT_ID` is set to `p_resident_id`.\n- `SERVICE_ID` is set to `v_service_id_to_keep`.\n- `DATE_MOVED_IN` is set to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`.\n- `PROPERTY_ID` is set to the maximum `PROPERTY_ID` found in the `RESIDENTS_SERVICES` table for the given `p_resident_id`. This value is obtained from a subquery `SELECT MAX(PROPERTY_ID) FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = p_resident_id`.\n- `DATE_REQUESTED` is set to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`.\n- `DATE_PROVIDED` is set to `NULL`.\n- `OTHER_DETAILS` is set to a concatenated string 'Cleaned: ' followed by the value of `v_invalid_count` and then ' invalid'.",
    "plsql": "CREATE OR REPLACE PROCEDURE ValidateAndCleanServices(\n  p_resident_id IN NUMBER,\n  p_min_property_id IN NUMBER\n) AS\n  v_invalid_count NUMBER;\n  v_valid_count NUMBER;\n  v_service_id_to_keep NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_invalid_count\n  FROM RESIDENTS_SERVICES rs\n  JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n  WHERE rs.RESIDENT_ID = p_resident_id\n  AND (rs.PROPERTY_ID < p_min_property_id OR rs.DATE_REQUESTED IS NULL OR s.SERVICE_DETAILS IS NULL);\n\n  SELECT COUNT(*) INTO v_valid_count\n  FROM RESIDENTS_SERVICES rs\n  JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n  WHERE rs.RESIDENT_ID = p_resident_id\n  AND rs.PROPERTY_ID >= p_min_property_id\n  AND rs.DATE_REQUESTED IS NOT NULL\n  AND s.SERVICE_DETAILS IS NOT NULL;\n\n  IF v_invalid_count > 0 THEN\n    SELECT MAX(rs.SERVICE_ID) INTO v_service_id_to_keep\n    FROM RESIDENTS_SERVICES rs\n    JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n    WHERE rs.RESIDENT_ID = p_resident_id\n    AND rs.PROPERTY_ID >= p_min_property_id\n    AND rs.DATE_REQUESTED IS NOT NULL\n    AND s.SERVICE_DETAILS IS NOT NULL;\n\n    DELETE FROM RESIDENTS_SERVICES\n    WHERE RESIDENT_ID = p_resident_id\n    AND (PROPERTY_ID < p_min_property_id OR DATE_REQUESTED IS NULL);\n\n    IF v_service_id_to_keep IS NOT NULL THEN\n      INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n      SELECT p_resident_id, v_service_id_to_keep, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), MAX(PROPERTY_ID), TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL, 'Cleaned: ' || v_invalid_count || ' invalid'\n      FROM RESIDENTS_SERVICES\n      WHERE RESIDENT_ID = p_resident_id;\n    END IF;\n  END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  ValidateAndCleanServices(6, 500);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(23, 700);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(28, 800);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(6, 600);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(23, 900);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ValidateAndCleanServices that validates and cleans service records for a resident. It counts invalid records (PROPERTY_ID below threshold, or DATE_REQUESTED NULL, or SERVICE_DETAILS NULL) and valid records. If invalid records exist, it finds the maximum SERVICE_ID among valid records. It deletes the invalid records. If a valid SERVICE_ID was found, it inserts a new clean record using that ID, the maximum PROPERTY_ID for the resident, current timestamps, and a note about the cleanup count.",
    "natural_language": "Develop a comprehensive stored procedure called ValidateAndCleanServices, which meticulously validates and subsequently cleanses all service records associated with a specific resident. This procedure thoroughly examines the records, carefully counting both those deemed invalidwhere the PROPERTY_ID falls below a specified threshold, or the DATE_REQUESTED is null, or the SERVICE_DETAILS are missingand those that are valid. Should any invalid records be discovered, the procedure then diligently identifies the highest SERVICE_ID from among the valid entries. It proceeds to permanently delete all of the flawed, invalid records. Furthermore, if a valid SERVICE_ID was successfully located during this process, the procedure thoughtfully constructs and inserts a brand new, clean service record. This new record utilizes that identified ID, assigns the maximum PROPERTY_ID available for the resident, stamps it with the current date and time, and includes a detailed note documenting the total number of records cleaned up during this operation.",
    "id": 110
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_gymnast_profile that accepts three parameters: p_people_id of type NUMBER, p_name of type VARCHAR2, and p_total_score of type NUMBER with an OUT mode. The procedure performs two main operations. First, it inserts a new record into the PEOPLE table with the columns PEOPLE_ID, NAME, AGE, HEIGHT, and HOMETOWN. The PEOPLE_ID column is set to the value of the p_people_id parameter, the NAME column is set to the value of the p_name parameter, the AGE column is set to a constant value of 20, the HEIGHT column is set to a constant value of 1.75, and the HOMETOWN column is set to a constant value of 'Unknown'. Second, it inserts a new record into the GYMNAST table with the columns GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, and TOTAL_POINTS. The GYMNAST_ID column is set to the value of the p_people_id parameter, each of the FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS columns is set to a constant value of 9.0, and the TOTAL_POINTS column is set to a constant value of 54.0. Finally, the procedure assigns the constant value 54.0 to the p_total_score OUT parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_gymnast_profile(\n    p_people_id IN NUMBER,\n    p_name IN VARCHAR2,\n    p_total_score OUT NUMBER\n)\nIS\nBEGIN\n    INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE, HEIGHT, HOMETOWN)\n    VALUES (p_people_id, p_name, 20, 1.75, 'Unknown');\n    \n    INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS)\n    VALUES (p_people_id, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 54.0);\n    \n    p_total_score := 54.0;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "DECLARE\n  v_total_score NUMBER;\nBEGIN\n  insert_new_gymnast_profile(101, 'Alex Johnson', v_total_score);\n  DBMS_OUTPUT.PUT_LINE('Total Score: ' || v_total_score);\n  COMMIT;\nEND;",
      "DECLARE\n  v_total_score NUMBER;\nBEGIN\n  insert_new_gymnast_profile(102, 'Maria Garcia', v_total_score);\n  DBMS_OUTPUT.PUT_LINE('Total Score: ' || v_total_score);\n  COMMIT;\nEND;",
      "DECLARE\n  v_total_score NUMBER;\nBEGIN\n  insert_new_gymnast_profile(103, 'David Chen', v_total_score);\n  DBMS_OUTPUT.PUT_LINE('Total Score: ' || v_total_score);\n  COMMIT;\nEND;",
      "DECLARE\n  v_total_score NUMBER;\nBEGIN\n  insert_new_gymnast_profile(104, 'Sarah Miller', v_total_score);\n  DBMS_OUTPUT.PUT_LINE('Total Score: ' || v_total_score);\n  COMMIT;\nEND;",
      "DECLARE\n  v_total_score NUMBER;\nBEGIN\n  insert_new_gymnast_profile(105, 'James Wilson', v_total_score);\n  DBMS_OUTPUT.PUT_LINE('Total Score: ' || v_total_score);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_new_gymnast_profile that inserts a new gymnast profile. It takes an ID, a name, and an OUT parameter for total score. Insert into PEOPLE table with the given ID and name, setting AGE to 20, HEIGHT to 1.75, and HOMETOWN to 'Unknown'. Then insert into GYMNAST table with the same ID, setting all event points to 9.0 and TOTAL_POINTS to 54.0. Finally, set the OUT parameter to 54.0.",
    "natural_language": "Write a stored procedure called insert_new_gymnast_profile to insert a new gymnast profile. It should accept an ID, a name, and an OUT parameter for the total score. Insert a record into the PEOPLE table using the provided ID and name, and assign 20 to AGE, 1.75 to HEIGHT, and 'Unknown' to HOMETOWN. Then, insert a record into the GYMNAST table with the same ID, setting all event points to 9.0 and TOTAL_POINTS to 54.0. Finally, assign 54.0 to the OUT parameter.",
    "id": 111
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named remove_gymnast_record that accepts three parameters: p_gymnast_id of type NUMBER, p_deleted_name of type VARCHAR2 with IN OUT mode, and p_success_flag of type NUMBER with OUT mode. The procedure begins by executing a SELECT statement to retrieve the NAME column from the PEOPLE table where the PEOPLE_ID column matches the value of p_gymnast_id, and assigns this retrieved name to the p_deleted_name parameter. Next, it performs a DELETE operation on the GYMNAST table, removing the row where the GYMNAST_ID column equals the value of p_gymnast_id. Following this, another DELETE operation is executed on the PEOPLE table to remove the row where the PEOPLE_ID column matches the value of p_gymnast_id. Finally, the procedure sets the p_success_flag parameter to 1, indicating successful completion of the operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_gymnast_record(\n    p_gymnast_id IN NUMBER,\n    p_deleted_name IN OUT VARCHAR2,\n    p_success_flag OUT NUMBER\n)\nIS\nBEGIN\n    SELECT NAME\n    INTO p_deleted_name\n    FROM PEOPLE\n    WHERE PEOPLE_ID = p_gymnast_id;\n    \n    DELETE FROM GYMNAST WHERE GYMNAST_ID = p_gymnast_id;\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = p_gymnast_id;\n    \n    p_success_flag := 1;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_name VARCHAR2(255);\n  v_success_flag NUMBER;\nBEGIN\n  remove_gymnast_record(p_gymnast_id => 1, p_deleted_name => v_deleted_name, p_success_flag => v_success_flag);\n  DBMS_OUTPUT.PUT_LINE('Deleted Name: ' || v_deleted_name || ', Success Flag: ' || v_success_flag);\nEND;",
      "DECLARE\n  v_deleted_name VARCHAR2(255);\n  v_success_flag NUMBER;\nBEGIN\n  remove_gymnast_record(p_gymnast_id => 2, p_deleted_name => v_deleted_name, p_success_flag => v_success_flag);\n  DBMS_OUTPUT.PUT_LINE('Deleted Name: ' || v_deleted_name || ', Success Flag: ' || v_success_flag);\nEND;",
      "DECLARE\n  v_deleted_name VARCHAR2(255);\n  v_success_flag NUMBER;\nBEGIN\n  remove_gymnast_record(p_gymnast_id => 4, p_deleted_name => v_deleted_name, p_success_flag => v_success_flag);\n  DBMS_OUTPUT.PUT_LINE('Deleted Name: ' || v_deleted_name || ', Success Flag: ' || v_success_flag);\nEND;",
      "DECLARE\n  v_deleted_name VARCHAR2(255);\n  v_success_flag NUMBER;\nBEGIN\n  remove_gymnast_record(p_gymnast_id => 3, p_deleted_name => v_deleted_name, p_success_flag => v_success_flag);\n  DBMS_OUTPUT.PUT_LINE('Deleted Name: ' || v_deleted_name || ', Success Flag: ' || v_success_flag);\nEND;",
      "DECLARE\n  v_deleted_name VARCHAR2(255);\n  v_success_flag NUMBER;\nBEGIN\n  remove_gymnast_record(p_gymnast_id => 5, p_deleted_name => v_deleted_name, p_success_flag => v_success_flag);\n  DBMS_OUTPUT.PUT_LINE('Deleted Name: ' || v_deleted_name || ', Success Flag: ' || v_success_flag);\nEND;"
    ],
    "summary": "Create a stored procedure named remove_gymnast_record that deletes a gymnast's record. It takes a gymnast ID, an IN OUT parameter for the deleted name, and an OUT success flag. First, retrieve the name from the PEOPLE table using the ID and assign it to the name parameter. Then delete the record from the GYMNAST table, followed by the record from the PEOPLE table, both using the ID. Finally, set the success flag to 1.",
    "natural_language": "Develop a stored procedure called remove_gymnast_record, which is designed to meticulously and permanently delete a gymnast's entire record from the system. This procedure requires a gymnast ID as input, an IN OUT parameter intended to capture the full name of the individual being removed, and an OUT parameter to serve as a clear success indicator. Initially, the procedure must carefully retrieve the gymnast's detailed name from the comprehensive PEOPLE table by utilizing the provided ID, and then assign this retrieved information to the name parameter. Subsequently, it must proceed to delete the associated record from the specialized GYMNAST table, and immediately after, perform a second deletion from the broader PEOPLE table, both actions crucially using the same unique identifier. Upon the successful completion of these deletions, the procedure should definitively set the success flag to the value of 1 to confirm the operation's success.",
    "id": 112
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ManageChampionships that accepts a single input parameter p_year of type NUMBER, which represents a specific year. The procedure begins by declaring a local variable v_count of type NUMBER to store count results and a local variable v_institution_id of type NUMBER to hold institution identifiers. It then declares and opens a cursor named c_institutions, which selects the INSTITUTION_ID column from the INSTITUTION table for every row where the FOUNDED column exactly equals the provided p_year parameter. The procedure enters a loop to process each row from this cursor result set: it fetches a single INSTITUTION_ID value into the v_institution_id variable, and exits the loop when no more rows are found. For each fetched institution ID, it performs a SELECT COUNT(*) query on the CHAMPIONSHIP table into the v_count variable, counting all rows where the INSTITUTION_ID column matches the current v_institution_id. It then evaluates a conditional IF statement: if v_count is greater than zero, meaning at least one championship record exists for that institution, it executes a DELETE operation on the CHAMPIONSHIP table, removing all rows where INSTITUTION_ID equals v_institution_id. If v_count is zero, meaning no championship records exist, it executes an INSERT operation into the CHAMPIONSHIP table, specifying values for four columns: it sets INSTITUTION_ID to the current v_institution_id, sets NICKNAME to the literal string 'NewTeam', sets JOINED to the input parameter p_year, and sets NUMBER_OF_CHAMPIONSHIPS to the literal number 1. After the loop completes, the procedure closes the c_institutions cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageChampionships(p_year NUMBER) IS\n  v_count NUMBER;\n  v_institution_id NUMBER;\n  CURSOR c_institutions IS\n    SELECT INSTITUTION_ID FROM INSTITUTION WHERE FOUNDED = p_year;\nBEGIN\n  OPEN c_institutions;\n  LOOP\n    FETCH c_institutions INTO v_institution_id;\n    EXIT WHEN c_institutions%NOTFOUND;\n    \n    SELECT COUNT(*) INTO v_count FROM CHAMPIONSHIP WHERE INSTITUTION_ID = v_institution_id;\n    \n    IF v_count > 0 THEN\n      DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = v_institution_id;\n    ELSE\n      INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n      VALUES (v_institution_id, 'NewTeam', p_year, 1);\n    END IF;\n  END LOOP;\n  CLOSE c_institutions;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  ManageChampionships(1908);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1966);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1993);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1994);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1995);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ManageChampionships that processes institutions founded in a given year. For each institution founded in that year, check if it has any championship records. If it does, delete all its championship records. If it does not, insert a new championship record for it with a nickname of 'NewTeam', the given year as the joined date, and 1 championship.",
    "natural_language": "Compose a stored procedure designated as ManageChampionships to process institutions established within a specified year. For every institution founded in that particular year, verify the existence of associated championship records. Should such records exist, proceed to delete all championship entries for that institution. Conversely, if no championship records are present, insert a new championship record for the institution, assigning 'NewTeam' as the nickname, the provided year as the joined date, and a championship count of one.",
    "id": 113
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateInstitutionChampionships that accepts two input parameters: a numeric parameter p_institution_id representing an institution's identifier and a numeric parameter p_championships representing a number of championships. The procedure first declares two local numeric variables, v_count and v_joined. It then queries the CHAMPIONSHIP table to count the total number of rows and find the maximum value from the JOINED column for all rows where the INSTITUTION_ID column matches the input parameter p_institution_id, storing the count into v_count and the maximum JOINED value into v_joined. Following this query, the procedure executes a conditional IF statement: if the value in v_count is greater than zero, indicating that at least one matching record exists, it performs a DELETE operation on the CHAMPIONSHIP table, removing the row where the INSTITUTION_ID equals p_institution_id and the JOINED column equals the retrieved maximum value v_joined. If the condition evaluates to false, meaning v_count is zero and no matching records were found, the procedure instead executes an INSERT operation into the CHAMPIONSHIP table, creating a new row with the INSTITUTION_ID column set to the input p_institution_id, the NICKNAME column set to the literal string 'UpdatedTeam', the JOINED column set to the literal number 2023, and the NUMBER_OF_CHAMPIONSHIPS column set to the input parameter p_championships.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateInstitutionChampionships(p_institution_id NUMBER, p_championships NUMBER) IS\n  v_count NUMBER;\n  v_joined NUMBER;\nBEGIN\n  SELECT COUNT(*), MAX(JOINED) INTO v_count, v_joined FROM CHAMPIONSHIP WHERE INSTITUTION_ID = p_institution_id;\n  \n  IF v_count > 0 THEN\n    DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = p_institution_id AND JOINED = v_joined;\n  ELSE\n    INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n    VALUES (p_institution_id, 'UpdatedTeam', 2023, p_championships);\n  END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateInstitutionChampionships(1, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateInstitutionChampionships(2, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateInstitutionChampionships(3, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateInstitutionChampionships(1, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateInstitutionChampionships(2, 6);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateInstitutionChampionships that updates championship data for a given institution ID and a championships number. First, check if the institution has any championship records. If it does, delete the record with the latest joined date. If it does not, insert a new championship record with the given ID, a nickname of 'UpdatedTeam', a joined date of 2023, and the provided championships number.",
    "natural_language": "Update institution championships. If records exist, delete the latest. Otherwise, insert a new one with ID, 'UpdatedTeam', 2023, and the given number.",
    "id": 114
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `AdjustChampionships` that accepts a single input parameter, `p_year`, of data type `NUMBER`. This procedure is designed to process championship records based on the provided year. It declares two local variables: `v_count` of data type `NUMBER` to store the count of records, and `v_institution_id` of data type `NUMBER` to temporarily hold institution identifiers. The procedure defines an explicit cursor named `c_championships` which selects the `INSTITUTION_ID` column from the `CHAMPIONSHIP` table for all rows where the `JOINED` column is equal to the value passed in the `p_year` parameter.\n\nThe execution begins by opening the `c_championships` cursor. It then enters a loop to iterate through the results fetched by the cursor. In each iteration, it fetches the `INSTITUTION_ID` from the current cursor row into the `v_institution_id` variable. The loop terminates when no more rows are found by the cursor, as indicated by `c_championships%NOTFOUND`.\n\nInside the loop, for each `v_institution_id` fetched, the procedure executes a `SELECT` statement to count the number of records in the `INSTITUTION` table where the `INSTITUTION_ID` column matches the current `v_institution_id`. The result of this count is stored in the `v_count` variable.\n\nFollowing this, a conditional `IF` statement evaluates the `v_count`. If `v_count` is greater than 0, meaning an institution with the `v_institution_id` exists in the `INSTITUTION` table, the procedure executes a `DELETE` statement. This `DELETE` statement removes all rows from the `CHAMPIONSHIP` table where the `INSTITUTION_ID` column matches the current `v_institution_id`.\n\nIf `v_count` is not greater than 0 (i.e., `v_count` is 0), indicating that an institution with the `v_institution_id` does not exist in the `INSTITUTION` table, the procedure executes an `INSERT` statement. This `INSERT` statement adds a new row into the `CHAMPIONSHIP` table. The `INSTITUTION_ID` column is set to the current `v_institution_id`, the `NICKNAME` column is set to the literal string 'AdjustedTeam', the `JOINED` column is set to the value of the `p_year` parameter, and the `NUMBER_OF_CHAMPIONSHIPS` column is set to the numeric value 1.\n\nAfter the loop completes, the `c_championships` cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE AdjustChampionships(p_year NUMBER) IS\n  v_count NUMBER;\n  v_institution_id NUMBER;\n  CURSOR c_championships IS\n    SELECT INSTITUTION_ID FROM CHAMPIONSHIP WHERE JOINED = p_year;\nBEGIN\n  OPEN c_championships;\n  LOOP\n    FETCH c_championships INTO v_institution_id;\n    EXIT WHEN c_championships%NOTFOUND;\n    \n    SELECT COUNT(*) INTO v_count FROM INSTITUTION WHERE INSTITUTION_ID = v_institution_id;\n    \n    IF v_count > 0 THEN\n      DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = v_institution_id;\n    ELSE\n      INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n      VALUES (v_institution_id, 'AdjustedTeam', p_year, 1);\n    END IF;\n  END LOOP;\n  CLOSE c_championships;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  AdjustChampionships(1993);\n  COMMIT;\nEND;",
      "BEGIN\n  AdjustChampionships(1994);\n  COMMIT;\nEND;",
      "BEGIN\n  AdjustChampionships(1995);\n  COMMIT;\nEND;",
      "BEGIN\n  AdjustChampionships(2000);\n  COMMIT;\nEND;",
      "BEGIN\n  AdjustChampionships(2010);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named AdjustChampionships that adjusts championship records for a given year. For each championship record from that year, check if the associated institution exists. If the institution exists, delete all championship records for that institution. If the institution does not exist, insert a new championship record with the institution ID, a nickname of 'AdjustedTeam', the given year, and 1 championship.",
    "natural_language": "Hey, can you whip up a stored procedure called AdjustChampionships to tweak the championship records for a specific year? Here's the deal: for each record from that year, first see if the linked institution is still around. If it is, then wipe out all championship records for that institution. If it's not there, just add a new championship record using the institution's ID, set the nickname to 'AdjustedTeam', use the year we're working with, and put 1 for the championship count.",
    "id": 115
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ManageInstitutionData` that accepts one input parameter, `p_institution_id`, which is of type `NUMBER` and represents the unique identifier for an institution. The procedure first declares two local variables: `v_count` of type `NUMBER` to store a count of records, and `v_championships` of type `NUMBER` to store a sum of championship numbers. It then executes a `SELECT` statement to query the `CHAMPIONSHIP` table. This `SELECT` statement calculates two aggregate values: the total count of rows where the `INSTITUTION_ID` column matches the value provided in `p_institution_id`, and the sum of the `NUMBER_OF_CHAMPIONSHIPS` column for those same rows. The calculated count is stored into the `v_count` variable, and the calculated sum is stored into the `v_championships` variable. Following this, the procedure enters a conditional block. If the value of `v_count` is greater than 0, indicating that one or more records exist in the `CHAMPIONSHIP` table for the given `p_institution_id`, the procedure executes a `DELETE` statement. This `DELETE` statement removes all rows from the `CHAMPIONSHIP` table where the `INSTITUTION_ID` column matches the value of `p_institution_id`. If, however, the value of `v_count` is not greater than 0 (i.e., it is 0), indicating no existing records for the given `p_institution_id`, the procedure executes an `INSERT` statement. This `INSERT` statement adds a new row into the `CHAMPIONSHIP` table. The `INSTITUTION_ID` column of the new row is populated with the value from `p_institution_id`, the `NICKNAME` column is set to the string literal 'ManagedTeam', the `JOINED` column is set to the numeric literal 2023, and the `NUMBER_OF_CHAMPIONSHIPS` column is populated with the value stored in the `v_championships` variable (which would be 0 in this specific `ELSE` branch, as `v_count` was 0).",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageInstitutionData(p_institution_id NUMBER) IS\n  v_count NUMBER;\n  v_championships NUMBER;\nBEGIN\n  SELECT COUNT(*), SUM(NUMBER_OF_CHAMPIONSHIPS) INTO v_count, v_championships FROM CHAMPIONSHIP WHERE INSTITUTION_ID = p_institution_id;\n  \n  IF v_count > 0 THEN\n    DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = p_institution_id;\n  ELSE\n    INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n    VALUES (p_institution_id, 'ManagedTeam', 2023, v_championships);\n  END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  ManageInstitutionData(1);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageInstitutionData(2);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageInstitutionData(3);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageInstitutionData(10);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageInstitutionData(15);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named ManageInstitutionData that accepts an institution_id number. Count and sum the championships for that institution. If records exist, delete them. If no records exist, insert a new record with the institution_id, nickname 'ManagedTeam', joined year 2023, and the sum (which will be 0).",
    "natural_language": "Hey, can you whip up a stored procedure called ManageInstitutionData that takes an institution_id number? First, tally up and add together all the championships for that place. If you find any records, just wipe 'em out. If there's nothing there, pop in a new record using that institution_id, set the nickname to 'ManagedTeam', the joined year to 2023, and the sumwhich'll be zero.",
    "id": 116
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_merge_order_status that accepts three input parameters: a numeric parameter p_customer_id, a string parameter p_old_status, and a string parameter p_new_status. The procedure first declares a local numeric variable v_order_count. It begins execution by querying the CUSTOMER_ORDERS table to count the number of rows where the CUSTOMER_ID column matches the input parameter p_customer_id and the ORDER_STATUS_CODE column matches the input parameter p_old_status, storing this count in v_order_count. If the value of v_order_count is greater than zero, the procedure performs an INSERT operation into the CUSTOMER_ORDERS table, specifying columns ORDER_ID, CUSTOMER_ID, ORDER_DATE, and ORDER_STATUS_CODE. The data for this insert is selected from DUAL, where the ORDER_ID is derived from a subquery that calculates the next sequential integer by taking the maximum existing ORDER_ID value from the CUSTOMER_ORDERS table, using the NVL function to substitute zero if the maximum is null, and adding one; the CUSTOMER_ID is set to the input parameter p_customer_id; the ORDER_DATE is set to the current system timestamp via CURRENT_TIMESTAMP; and the ORDER_STATUS_CODE is set to the input parameter p_new_status. This insert is conditional and only executes if a subquery using WHERE NOT EXISTS finds no existing row in the CUSTOMER_ORDERS table where the CUSTOMER_ID equals p_customer_id and the ORDER_STATUS_CODE equals p_new_status. If the initial condition is not met (i.e., v_order_count is zero or less), the procedure executes an alternative INSERT statement into the CUSTOMER_ORDERS table with the same column list. This alternative insert uses a VALUES clause where ORDER_ID is again derived from the same subquery to get the next maximum value plus one, CUSTOMER_ID is set to p_customer_id, ORDER_DATE is set to CURRENT_TIMESTAMP, and ORDER_STATUS_CODE is hardcoded to the string literal 'DEFAULT'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_merge_order_status(p_customer_id IN NUMBER, p_old_status IN VARCHAR2, p_new_status IN VARCHAR2)\nIS\n   v_order_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_order_count FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_old_status;\n   \n   IF v_order_count > 0 THEN\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      SELECT (SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, p_new_status FROM DUAL\n      WHERE NOT EXISTS (SELECT 1 FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_new_status);\n   ELSE\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'DEFAULT');\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_merge_order_status(12, 'Part', 'Shipped');\nEND;",
      "BEGIN\n  proc_merge_order_status(3, 'Pending', 'Processing');\nEND;",
      "BEGIN\n  proc_merge_order_status(12, 'Shipped', 'Delivered');\nEND;",
      "BEGIN\n  proc_merge_order_status(5, 'Cancelled', 'Refunded');\nEND;",
      "BEGIN\n  proc_merge_order_status(8, 'Processing', 'Completed');\nEND;"
    ],
    "summary": "Create a stored procedure named proc_merge_order_status that accepts a customer_id number, an old_status string, and a new_status string. Count orders for the customer with the old status. If such orders exist, insert a new order with the new status for the customer, but only if an order with the new status doesn't already exist. If no orders with the old status exist, insert a new order with a status of 'DEFAULT'.",
    "natural_language": "Make a stored procedure called proc_merge_order_status that takes a customer_id, an old_status, and a new_status. Check for a decent number of the customer's orders that are in the old status. If you find some, then add a new order with the new status for that customer, but only if there aren't already a bunch of orders with that new status. If there are hardly any orders with the old status, just put in a new order with a status like 'DEFAULT'.",
    "id": 117
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_cleanup_orders that accepts three parameters: p_customer_id of type NUMBER, p_status_code of type VARCHAR2, and p_date_threshold of type VARCHAR2. The procedure begins by declaring two local variables, v_item_count and v_order_count, both of type NUMBER. It performs a SELECT operation to count the number of rows in the CUSTOMER_ORDERS table where the CUSTOMER_ID matches p_customer_id, the ORDER_STATUS_CODE matches p_status_code, and the ORDER_DATE is earlier than p_date_threshold, storing the result in v_order_count. If v_order_count is greater than zero, indicating that there are orders meeting the criteria, the procedure proceeds to count the number of rows in the ORDER_ITEMS table where the ORDER_ID corresponds to any order in the CUSTOMER_ORDERS table that matches the same conditions, storing this count in v_item_count. If v_item_count is greater than zero, the procedure deletes rows from the ORDER_ITEMS table where the ORDER_ID matches any order in the CUSTOMER_ORDERS table that meets the specified conditions. Following this, the procedure deletes rows from the CUSTOMER_ORDERS table where the CUSTOMER_ID matches p_customer_id, the ORDER_STATUS_CODE matches p_status_code, and the ORDER_DATE is earlier than p_date_threshold.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_cleanup_orders(p_customer_id IN NUMBER, p_status_code IN VARCHAR2, p_date_threshold IN VARCHAR2)\nIS\n   v_item_count NUMBER;\n   v_order_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_order_count FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_date_threshold;\n   \n   IF v_order_count > 0 THEN\n      SELECT COUNT(*) INTO v_item_count FROM ORDER_ITEMS oi WHERE EXISTS (SELECT 1 FROM CUSTOMER_ORDERS co WHERE co.ORDER_ID = oi.ORDER_ID AND co.CUSTOMER_ID = p_customer_id AND co.ORDER_STATUS_CODE = p_status_code AND co.ORDER_DATE < p_date_threshold);\n      \n      IF v_item_count > 0 THEN\n         DELETE FROM ORDER_ITEMS WHERE ORDER_ID IN (SELECT ORDER_ID FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_date_threshold);\n      END IF;\n      \n      DELETE FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_date_threshold;\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_cleanup_orders(12, 'Part', '2015-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(3, 'Part', '1995-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(12, 'Complete', '2020-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(25, 'Cancelled', '2022-06-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(100, 'Pending', '2000-12-31');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_cleanup_orders that accepts a customer_id number, a status_code string, and a date_threshold string. Count orders for the customer with the given status older than the threshold. If such orders exist, count their related items. If items exist, delete them. Then, delete the qualifying orders.",
    "natural_language": "Develop a stored procedure, to be named proc_cleanup_orders, which is designed to accept three distinct parameters: a numeric customer identifier, a textual status code, and a specific date threshold provided as a string. This procedure should meticulously calculate the total number of orders associated with the specified customer that possess the indicated status and were placed prior to the provided cutoff date. Should any such qualifying orders be found, it must then proceed to carefully tally all inventory items that are linked to those particular orders. In the event that related items are indeed present, the procedure must systematically and securely remove each of those item records. Subsequently, after ensuring the related items are handled, it must finally and completely delete all of the identified qualifying orders from the database.",
    "id": 118
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_analyze_customer_orders` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_status_filter` of type `VARCHAR2`, and `p_min_quantity` of type `VARCHAR2`. The purpose of this procedure is to analyze customer order data based on the provided filters and then insert a new record into the `CUSTOMER_ORDERS` table categorizing the customer's order volume.\n\nFirst, the procedure declares three local variables: `v_total_orders` of type `NUMBER` to store the count of distinct orders, `v_total_items` of type `NUMBER` to store the total count of order items, and `v_avg_quantity` of type `NUMBER` to store the average order quantity.\n\nNext, the procedure executes a `SELECT` statement to calculate these aggregate values. It counts the distinct `ORDER_ID` from the `CUSTOMER_ORDERS` table, counts the `ORDER_ITEM_ID` from the `ORDER_ITEMS` table, and calculates the average of the `ORDER_QUANTITY` column from the `ORDER_ITEMS` table after explicitly converting it to a `NUMBER` using `TO_NUMBER()`. These calculated values are then stored into the `v_total_orders`, `v_total_items`, and `v_avg_quantity` variables, respectively. The `SELECT` statement joins `CUSTOMER_ORDERS` (aliased as `co`) with `ORDER_ITEMS` (aliased as `oi`) using a `LEFT JOIN` on `co.ORDER_ID = oi.ORDER_ID`. The data is filtered by three conditions in the `WHERE` clause: `co.CUSTOMER_ID` must be equal to the input parameter `p_customer_id`, `co.ORDER_STATUS_CODE` must be equal to the input parameter `p_status_filter`, and `oi.ORDER_QUANTITY` must be greater than or equal to the input parameter `p_min_quantity`.\n\nFollowing the data retrieval, the procedure enters a conditional block (`IF-ELSIF-ELSE`) to determine the type of new order record to insert into the `CUSTOMER_ORDERS` table.\n\nThe first condition checks if `v_total_orders` is greater than 0 AND `v_avg_quantity` is greater than 5. If both conditions are true, a new row is inserted into the `CUSTOMER_ORDERS` table. The `ORDER_ID` for this new record is generated by selecting the maximum existing `ORDER_ID` from `CUSTOMER_ORDERS`, using `NVL(MAX(ORDER_ID),0)` to handle cases where no orders exist (defaulting to 0), and then adding 1 to it. The `CUSTOMER_ID` is set to the input parameter `p_customer_id`. The `ORDER_DATE` is set to the current timestamp using `CURRENT_TIMESTAMP`. The `ORDER_STATUS_CODE` is set to the literal string 'HIGH_VOLUME'.\n\nThe second condition, an `ELSIF`, is evaluated if the first condition is false. It checks if `v_total_orders` is greater than 0 AND `v_avg_quantity` is less than or equal to 5. If both these conditions are true, a new row is inserted into the `CUSTOMER_ORDERS` table. Similar to the previous `IF` block, the `ORDER_ID` is generated by `(SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS)`, the `CUSTOMER_ID` is set to `p_customer_id`, the `ORDER_DATE` is set to `CURRENT_TIMESTAMP`, and the `ORDER_STATUS_CODE` is set to the literal string 'LOW_VOLUME'.\n\nFinally, if neither of the above conditions is met (i.e., `v_total_orders` is not greater than 0), the `ELSE` block is executed. In this case, a new row is inserted into the `CUSTOMER_ORDERS` table. The `ORDER_ID` is generated by `(SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS)`, the `CUSTOMER_ID` is set to `p_customer_id`, the `ORDER_DATE` is set to `CURRENT_TIMESTAMP`, and the `ORDER_STATUS_CODE` is set to the literal string 'NO_DATA'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_analyze_customer_orders(p_customer_id IN NUMBER, p_status_filter IN VARCHAR2, p_min_quantity IN VARCHAR2)\nIS\n   v_total_orders NUMBER;\n   v_total_items NUMBER;\n   v_avg_quantity NUMBER;\nBEGIN\n   SELECT COUNT(DISTINCT co.ORDER_ID), COUNT(oi.ORDER_ITEM_ID), AVG(TO_NUMBER(oi.ORDER_QUANTITY))\n   INTO v_total_orders, v_total_items, v_avg_quantity\n   FROM CUSTOMER_ORDERS co\n   LEFT JOIN ORDER_ITEMS oi ON co.ORDER_ID = oi.ORDER_ID\n   WHERE co.CUSTOMER_ID = p_customer_id\n   AND co.ORDER_STATUS_CODE = p_status_filter\n   AND oi.ORDER_QUANTITY >= p_min_quantity;\n   \n   IF v_total_orders > 0 AND v_avg_quantity > 5 THEN\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'HIGH_VOLUME');\n   ELSIF v_total_orders > 0 AND v_avg_quantity <= 5 THEN\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'LOW_VOLUME');\n   ELSE\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'NO_DATA');\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 12, p_status_filter => 'Part', p_min_quantity => '1');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 3, p_status_filter => 'Part', p_min_quantity => '5');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 1, p_status_filter => 'Part', p_min_quantity => '1');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 12, p_status_filter => 'Completed', p_min_quantity => '1');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 99, p_status_filter => 'Pending', p_min_quantity => '1');\nEND;"
    ],
    "summary": "Create a stored procedure named proc_analyze_customer_orders that accepts a customer_id number, a status_filter string, and a min_quantity string. Calculate the total distinct orders, total items, and average quantity for the customer filtered by status and minimum quantity. Based on the results: if there are orders and average quantity > 5, insert a 'HIGH_VOLUME' order record. Else if there are orders and average quantity <= 5, insert a 'LOW_VOLUME' order record. Otherwise, insert a 'NO_DATA' order record.",
    "natural_language": "Compose a stored procedure designated as `proc_analyze_customer_orders`. This procedure shall accept three parameters: a numeric `customer_id`, a string `status_filter`, and a string `min_quantity`. Its function is to compute the total count of distinct orders, the aggregate number of items, and the mean quantity per order for the specified customer, applying filters based on order status and a minimum quantity threshold. Subsequently, based on the computed results: if orders exist and the average quantity exceeds five, the procedure must insert an order record classified as 'HIGH_VOLUME'. Alternatively, if orders exist but the average quantity is five or less, it shall insert a record classified as 'LOW_VOLUME'. In all other cases, a record classified as 'NO_DATA' must be inserted.",
    "id": 119
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_sync_order_items that accepts three parameters: p_order_id of type NUMBER, p_product_id of type NUMBER, and p_quantity of type VARCHAR2. The procedure first checks the ORDER_ITEMS table to determine if there is an existing record with the specified ORDER_ID matching p_order_id and PRODUCT_ID matching p_product_id by counting such records and storing the result in a local variable v_exists. If no such record exists (v_exists equals 0), the procedure inserts a new row into the ORDER_ITEMS table with ORDER_ITEM_ID set to one more than the current maximum ORDER_ITEM_ID in the table, or 1 if the table is empty, and assigns p_order_id to ORDER_ID, p_product_id to PRODUCT_ID, and p_quantity to ORDER_QUANTITY. If a record does exist (v_exists is not 0), the procedure deletes the existing record from the ORDER_ITEMS table where ORDER_ID equals p_order_id and PRODUCT_ID equals p_product_id, and then inserts a new row with the same logic for ORDER_ITEM_ID, assigning p_order_id to ORDER_ID, p_product_id to PRODUCT_ID, and p_quantity to ORDER_QUANTITY.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_sync_order_items(p_order_id IN NUMBER, p_product_id IN NUMBER, p_quantity IN VARCHAR2)\nIS\n   v_exists NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_exists FROM ORDER_ITEMS WHERE ORDER_ID = p_order_id AND PRODUCT_ID = p_product_id;\n   \n   IF v_exists = 0 THEN\n      INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n      VALUES ((SELECT NVL(MAX(ORDER_ITEM_ID),0) + 1 FROM ORDER_ITEMS), p_order_id, p_product_id, p_quantity);\n   ELSE\n      DELETE FROM ORDER_ITEMS WHERE ORDER_ID = p_order_id AND PRODUCT_ID = p_product_id;\n      INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n      VALUES ((SELECT NVL(MAX(ORDER_ITEM_ID),0) + 1 FROM ORDER_ITEMS), p_order_id, p_product_id, p_quantity);\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_sync_order_items(1, 13, '5');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(2, 10, '3');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(3, 11, '7');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(1, 11, '2');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(2, 13, '6');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_sync_order_items that accepts an order_id number, a product_id number, and a quantity string. Check if an item with the given order_id and product_id exists. If it does not exist, insert it. If it does exist, delete the old record and insert a new one with the provided data.",
    "natural_language": "Create a stored procedure called proc_sync_order_items that takes an order_id number, a product_id number, and a quantity string. You need to see if there's already an item for that order and product. If you can't find one, just add it in. If you do find one, get rid of that old entry and put in a fresh one with the new details.",
    "id": 120
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named Insert_Young_Gymnasts that performs a single insert operation into the GYMNAST table, sourcing data from the PEOPLE table by selecting the PEOPLE_ID column for all rows where the AGE column value is less than 20 and where the PEOPLE_ID value does not already exist in the GYMNAST table as a GYMNAST_ID; for each selected PEOPLE_ID, the procedure inserts a new row into GYMNAST, populating the GYMNAST_ID column with the selected PEOPLE_ID value, setting the columns FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS all to the numeric value 0, and consequently setting the TOTAL_POINTS column also to 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE Insert_Young_Gymnasts AS\nBEGIN\n  INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS)\n  SELECT PEOPLE_ID, 0, 0, 0, 0, 0, 0, 0\n  FROM PEOPLE\n  WHERE AGE < 20\n  AND PEOPLE_ID NOT IN (SELECT GYMNAST_ID FROM GYMNAST);\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  Insert_Young_Gymnasts;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named Insert_Young_Gymnasts that inserts into the GYMNAST table. For each person under 20 years old whose PEOPLE_ID is not already a GYMNAST_ID, insert a new row with that ID, setting all event points and TOTAL_POINTS to 0.",
    "natural_language": "Hey, can you whip up a stored procedure called Insert_Young_Gymnasts that adds folks to the GYMNAST table? Basically, for anyone under 20 whose PEOPLE_ID isn't already in there as a GYMNAST_ID, just pop 'em in. Set all their event scores and the total points to zero to start 'em off.",
    "id": 121
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named Delete_Tall_People that performs a delete operation on the PEOPLE table. This procedure does not take any parameters. It removes rows from the PEOPLE table where the HEIGHT column value is greater than 1.80 meters. Additionally, it ensures that the PEOPLE_ID column value of the rows being deleted is not present in the GYMNAST_ID column of the GYMNAST table. The procedure uses a DELETE statement with a WHERE clause that includes a condition to check the HEIGHT column and a subquery to exclude PEOPLE_IDs that exist in the GYMNAST table. The subquery selects GYMNAST_ID from the GYMNAST table to create a list of IDs that should not be deleted from the PEOPLE table. The logic flow involves checking each row in the PEOPLE table against these conditions and deleting only those rows that satisfy both the height condition and the exclusion condition based on the subquery.",
    "plsql": "CREATE OR REPLACE PROCEDURE Delete_Tall_People AS\nBEGIN\n  DELETE FROM PEOPLE\n  WHERE HEIGHT > 1.80\n  AND PEOPLE_ID NOT IN (SELECT GYMNAST_ID FROM GYMNAST);\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  Delete_Tall_People;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named Delete_Tall_People that deletes rows from the PEOPLE table where HEIGHT > 1.80 and the PEOPLE_ID is not found in the GYMNAST table's GYMNAST_ID column.",
    "natural_language": "Delete people taller than 1.80m who are not gymnasts.",
    "id": 122
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `p_update_employee_salary` that does not accept any input parameters. This procedure is designed to iterate through a specific set of employee records and update their salaries based on their respective department names. The procedure first declares a cursor named `c_emp`. This cursor selects the `EMPLOYEE_ID`, `SALARY`, and `DEPARTMENT_NAME` columns. It retrieves `EMPLOYEE_ID` and `SALARY` from the `EMPLOYEES` table, aliased as `e`, and `DEPARTMENT_NAME` from the `DEPARTMENTS` table, aliased as `d`. The join condition for these two tables is `e.DEPARTMENT_ID = d.DEPARTMENT_ID`, meaning records are linked where the `DEPARTMENT_ID` in the `EMPLOYEES` table matches the `DEPARTMENT_ID` in the `DEPARTMENTS` table. The cursor is declared `FOR UPDATE OF e.SALARY`, which indicates that the `SALARY` column of the `EMPLOYEES` table will be updated within the loop using the `WHERE CURRENT OF` clause. After the cursor declaration, a local numeric variable `v_new_salary` is declared to temporarily store the calculated new salary for each employee. The procedure then enters a loop that iterates through each record fetched by the `c_emp` cursor, assigning the current record's values to a record variable named `rec`. Inside this loop, a series of conditional statements (`IF-ELSIF-ELSE`) determine the new salary based on the `DEPARTMENT_NAME` of the current employee record (`rec.DEPARTMENT_NAME`). If `rec.DEPARTMENT_NAME` is 'Marketing', `v_new_salary` is calculated as `rec.SALARY` multiplied by 1.10 (a 10% increase). If `rec.DEPARTMENT_NAME` is 'Sales', `v_new_salary` is calculated as `rec.SALARY` multiplied by 1.15 (a 15% increase). If `rec.DEPARTMENT_NAME` is 'IT', `v_new_salary` is calculated as `rec.SALARY` multiplied by 1.12 (a 12% increase). For any other `DEPARTMENT_NAME` not explicitly listed, `v_new_salary` is calculated as `rec.SALARY` multiplied by 1.05 (a 5% increase). After calculating `v_new_salary`, an `UPDATE` statement is executed. This statement modifies the `EMPLOYEES` table, setting the `SALARY` column to the value stored in `v_new_salary`. The `WHERE CURRENT OF c_emp` clause ensures that only the specific row currently being processed by the `c_emp` cursor is updated. This process repeats for every employee record retrieved by the `c_emp` cursor until all records have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_update_employee_salary\nIS\n   CURSOR c_emp IS\n      SELECT e.EMPLOYEE_ID, e.SALARY, d.DEPARTMENT_NAME\n      FROM EMPLOYEES e\n      JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\n      FOR UPDATE OF e.SALARY;\n   v_new_salary NUMBER;\nBEGIN\n   FOR rec IN c_emp LOOP\n      IF rec.DEPARTMENT_NAME = 'Marketing' THEN\n         v_new_salary := rec.SALARY * 1.10;\n      ELSIF rec.DEPARTMENT_NAME = 'Sales' THEN\n         v_new_salary := rec.SALARY * 1.15;\n      ELSIF rec.DEPARTMENT_NAME = 'IT' THEN\n         v_new_salary := rec.SALARY * 1.12;\n      ELSE\n         v_new_salary := rec.SALARY * 1.05;\n      END IF;\n      UPDATE EMPLOYEES\n      SET SALARY = v_new_salary\n      WHERE CURRENT OF c_emp;\n   END LOOP;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "COUNTRIES",
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS",
      "REGIONS"
    ],
    "call_sqls": [
      "BEGIN\n  p_update_employee_salary;\nEND;"
    ],
    "summary": "Create a stored procedure named p_update_employee_salary with no parameters. Using a FOR UPDATE cursor, update employee salaries based on department: increase by 10% for Marketing, 15% for Sales, 12% for IT, and 5% for all other departments.",
    "natural_language": "Create procedure p_update_employee_salary. Use a FOR UPDATE cursor to raise salaries: Marketing 10%, Sales 15%, IT 12%, others 5%.",
    "id": 123
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that deletes records from two tables based on a given parameter. The procedure is named delete_institution_and_championship and it accepts a single input parameter, p_institution_id, which is of type NUMBER. This parameter represents the unique identifier of an institution. The procedure performs two delete operations. First, it deletes all rows from the CHAMPIONSHIP table where the INSTITUTION_ID column matches the value of p_institution_id. Next, it deletes the row from the INSTITUTION table where the INSTITUTION_ID column is equal to the value of p_institution_id. There are no conditional statements or function calls involved in this procedure. The logic flow is straightforward, executing the delete operation on the CHAMPIONSHIP table first, followed by the delete operation on the INSTITUTION table.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_institution_and_championship(p_institution_id NUMBER) IS\nBEGIN\n    DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = p_institution_id;\n    DELETE FROM INSTITUTION WHERE INSTITUTION_ID = p_institution_id;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  delete_institution_and_championship(1);\nEND;",
      "BEGIN\n  delete_institution_and_championship(2);\nEND;",
      "BEGIN\n  delete_institution_and_championship(3);\nEND;"
    ],
    "summary": "Create a stored procedure named delete_institution_and_championship that accepts a p_institution_id NUMBER parameter. Delete all related records from the CHAMPIONSHIP table first, then delete the institution from the INSTITUTION table.",
    "natural_language": "Delete the institution and its related championships by creating a stored procedure called delete_institution_and_championship that takes a p_institution_id NUMBER parameter. First, remove all associated records from the CHAMPIONSHIP table, then delete the institution from the INSTITUTION table.",
    "id": 124
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `merge_institution_data` that accepts four input parameters: `p_institution_id` of data type `NUMBER`, intended to represent a unique identifier for an institution; `p_name` of data type `VARCHAR2`, intended to represent the name of the institution; `p_team` of data type `VARCHAR2`, intended to represent the team associated with the institution; and `p_city` of data type `VARCHAR2`, intended to represent the city where the institution is located. The procedure begins by declaring a local variable `v_count` of data type `NUMBER`. It then executes a `SELECT` statement to count the number of rows in the `INSTITUTION` table where the `INSTITUTION_ID` column matches the value provided in the `p_institution_id` input parameter. The result of this count is stored in the `v_count` variable. Following this, the procedure evaluates a conditional `IF` statement: if the value of `v_count` is equal to `0`, indicating that no existing record in the `INSTITUTION` table has an `INSTITUTION_ID` matching `p_institution_id`, then an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `INSTITUTION` table, populating the `INSTITUTION_ID` column with the value from `p_institution_id`, the `NAME` column with the value from `p_name`, the `TEAM` column with the value from `p_team`, and the `CITY` column with the value from `p_city`. If `v_count` is not equal to `0`, meaning a record with the specified `INSTITUTION_ID` already exists, no further action is taken within the procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE merge_institution_data(p_institution_id NUMBER, p_name VARCHAR2, p_team VARCHAR2, p_city VARCHAR2) IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM INSTITUTION WHERE INSTITUTION_ID = p_institution_id;\n    IF v_count = 0 THEN\n        INSERT INTO INSTITUTION (INSTITUTION_ID, NAME, TEAM, CITY) VALUES (p_institution_id, p_name, p_team, p_city);\n    END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  merge_institution_data(4, 'University of Toronto', 'Varsity Blues', 'Toronto');\nEND;",
      "BEGIN\n  merge_institution_data(5, 'McGill University', 'Redbirds', 'Montreal');\nEND;",
      "BEGIN\n  merge_institution_data(1, 'University of British Columbia', 'Thunderbirds', 'Vancouver');\nEND;",
      "BEGIN\n  merge_institution_data(6, 'University of Waterloo', 'Warriors', 'Waterloo');\nEND;",
      "BEGIN\n  merge_institution_data(3, 'University of Alberta', 'Golden Bears', 'Edmonton');\nEND;"
    ],
    "summary": "Create a stored procedure named merge_institution_data with parameters p_institution_id NUMBER, p_name VARCHAR2, p_team VARCHAR2, p_city VARCHAR2. Insert a new institution record only if the provided INSTITUTION_ID does not already exist in the table.",
    "natural_language": "Create a stored procedure called merge_institution_data that takes in a few parameters like an institution number, a name, a team, and a city. Use it to add a new institution entry, but only do so if that specific institution number isn't already found in the table somewhere.",
    "id": 125
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_hex_batch` that accepts a single input parameter, `p_hex_ids`, which is a `SYS.ODCIVARCHAR2LIST` (an Oracle-defined collection type representing a list of `VARCHAR2` strings). The purpose of this procedure is to process a batch of hexadecimal string identifiers, convert them into numerical institution IDs, and then either insert new institution records or update existing ones in the `INSTITUTION` table based on these IDs.\n\nThe procedure declares two local variables: `v_raw_id` of type `RAW(8)` to temporarily store the raw binary representation of a hexadecimal string, and `v_institution_id` of type `NUMBER` to store the numerical institution ID derived from the raw value.\n\nThe core logic of the procedure is encapsulated within a `FOR` loop that iterates through each element in the `p_hex_ids` collection, from the first element up to the total count of elements in the list.\n\nInside the loop, for each `i`-th element of `p_hex_ids`:\n1. The `HEXTORAW` function is called to convert the current hexadecimal string `p_hex_ids(i)` into its raw binary representation, which is then assigned to the `v_raw_id` variable.\n2. The `UTL_RAW.CAST_TO_BINARY_INTEGER` function is called to convert the `v_raw_id` (raw binary value) into a `NUMBER` (binary integer), and this numerical value is assigned to the `v_institution_id` variable. This `v_institution_id` is intended to be the unique identifier for an institution.\n\nFollowing the conversion, a `MERGE` statement is executed to either insert or update records in the `INSTITUTION` table.\nThe `MERGE` statement uses a `USING` clause with a subquery `SELECT v_institution_id AS inst_id FROM dual`. This subquery effectively provides a single row with the calculated `v_institution_id` as `inst_id` for comparison.\nThe `ON` clause specifies the join condition for matching records: `i.INSTITUTION_ID = src.inst_id`. This means the `MERGE` operation will attempt to find a row in the `INSTITUTION` table where the `INSTITUTION_ID` column matches the `v_institution_id` derived from the current hexadecimal input.\n\nIf a match is found (`WHEN MATCHED THEN`):\nAn `UPDATE` operation is performed on the matched row in the `INSTITUTION` table.\nThe `NAME` column is updated to a string concatenated from 'Auto-' and the `v_institution_id`.\nThe `TEAM` column is updated to a string concatenated from 'Team-' and the `v_institution_id`.\n\nIf no match is found (`WHEN NOT MATCHED THEN`):\nAn `INSERT` operation is performed to add a new row into the `INSTITUTION` table.\nThe `INSTITUTION_ID` column is set to `v_institution_id`.\nThe `NAME` column is set to a string concatenated from 'Auto-' and the `v_institution_id`.\nThe `TEAM` column is set to a string concatenated from 'Team-' and the `v_institution_id`.\nThe `CITY` column is set to the literal string 'Unknown'.\nThe `PROVINCE` column is set to the literal string 'Unknown'.\nThe `FOUNDED` column is set to the numerical value `1900`.\nThe `AFFILIATION` column is set to the literal string 'Public'.\nThe `ENROLLMENT` column is set to the numerical value `10000`.\nThe `ENDOWMENT` column is set to the literal string '$0'.\nThe `STADIUM` column is set to the literal string 'Unknown Stadium'.\nThe `CAPACITY` column is set to the numerical value `1000`.\n\nThis process repeats for every hexadecimal ID provided in the `p_hex_ids` list, ensuring that each ID results in either an update to an existing institution record or the creation of a new one with default values and dynamically generated name and team based on the institution ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_hex_batch(p_hex_ids SYS.ODCIVARCHAR2LIST) IS\n    v_raw_id RAW(8);\n    v_institution_id NUMBER;\nBEGIN\n    FOR i IN 1..p_hex_ids.COUNT LOOP\n        v_raw_id := HEXTORAW(p_hex_ids(i));\n        v_institution_id := UTL_RAW.CAST_TO_BINARY_INTEGER(v_raw_id);\n        \n        MERGE INTO INSTITUTION i\n        USING (SELECT v_institution_id AS inst_id FROM dual) src\n        ON (i.INSTITUTION_ID = src.inst_id)\n        WHEN MATCHED THEN\n            UPDATE SET \n                i.NAME = 'Auto-' || v_institution_id,\n                i.TEAM = 'Team-' || v_institution_id\n        WHEN NOT MATCHED THEN\n            INSERT (INSTITUTION_ID, NAME, TEAM, CITY, PROVINCE, FOUNDED, AFFILIATION, ENROLLMENT, ENDOWMENT, STADIUM, CAPACITY)\n            VALUES (v_institution_id, 'Auto-' || v_institution_id, 'Team-' || v_institution_id, 'Unknown', 'Unknown', 1900, 'Public', 10000, '$0', 'Unknown Stadium', 1000);\n    END LOOP;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  process_hex_batch(SYS.ODCIVARCHAR2LIST('00000001', '00000002'));\n  COMMIT;\nEND;",
      "BEGIN\n  process_hex_batch(SYS.ODCIVARCHAR2LIST('0000000A'));\n  COMMIT;\nEND;",
      "BEGIN\n  process_hex_batch(SYS.ODCIVARCHAR2LIST('0000000F', '00000010', '00000011'));\n  COMMIT;\nEND;",
      "BEGIN\n  process_hex_batch(SYS.ODCIVARCHAR2LIST('00000064'));\n  COMMIT;\nEND;",
      "BEGIN\n  process_hex_batch(SYS.ODCIVARCHAR2LIST('00000003', '00000004', '00000005', '00000006'));\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `process_hex_batch` that accepts a list of hexadecimal strings. For each string, convert it to a raw value and then to a numerical institution ID. Use a MERGE statement to insert or update the INSTITUTION table with this ID. For updates, set NAME and TEAM to concatenated strings. For inserts, set all columns with the ID, concatenated strings, and default values.",
    "natural_language": "Hey, can you whip up a stored procedure called `process_hex_batch` that takes in a bunch of hex strings? For each one, we gotta turn it into a raw value and then figure out the numerical institution ID from that. Use a MERGE to either pop new rows into the INSTITUTION table or update existing ones with that ID. If we're updating, slap together some strings for the NAME and TEAM columns. For new inserts, fill all the columns: use the ID, those same concatenated strings, and just stick in the default values for the rest.",
    "id": 126
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_customer_orders` that accepts a single input parameter `p_customer_id` of type NUMBER, and begins by declaring local variables `v_order_count`, `v_total_quantity`, `v_first_order_id`, `v_last_order_id`, and `v_avg_quantity`, all of type NUMBER. The procedure first queries the `ORDER_ITEMS` table, using a subquery to select `ORDER_ID` values from the `CUSTOMER_ORDERS` table where the `CUSTOMER_ID` matches the input `p_customer_id`. It calculates the count of rows, the sum of the `ORDER_QUANTITY` column (converted to a NUMBER using `TO_NUMBER` and defaulting to 0 with `NVL` if null), the minimum `ORDER_ID`, and the maximum `ORDER_ID` from the `ORDER_ITEMS` table for those matching order IDs, storing these results into the variables `v_order_count`, `v_total_quantity`, `v_first_order_id`, and `v_last_order_id` respectively. If `v_order_count` is greater than zero, it calculates the average quantity `v_avg_quantity` by dividing `v_total_quantity` by `v_order_count`. It then evaluates a conditional block: if `v_total_quantity` is less than 5, it performs an INSERT into the `ORDER_ITEMS` table, specifying columns `ORDER_ITEM_ID`, `ORDER_ID`, `PRODUCT_ID`, and `ORDER_QUANTITY`, with values derived as `p_customer_id` multiplied by 100 for the item ID, `v_first_order_id` for the order ID, the number 1 for the product ID, and the character representation (using `TO_CHAR`) of the difference `5 - v_total_quantity` for the order quantity. If `v_total_quantity` is between 5 and 10 inclusive, it executes an UPDATE on the `CUSTOMER_ORDERS` table, setting the `ORDER_STATUS_CODE` column to the string 'Medium Volume' for rows where the `ORDER_ID` is found in a subquery result from the `ORDER_ITEMS` table limited to rows where `ORDER_ID` equals `v_first_order_id`. If `v_total_quantity` is greater than 10 and simultaneously `v_avg_quantity` is greater than 3, it performs a DELETE from the `ORDER_ITEMS` table for rows where `ORDER_ID` equals `v_last_order_id` and the numeric conversion of `ORDER_QUANTITY` is less than `v_avg_quantity`. If none of the previous conditions are met, it executes an INSERT into the `CUSTOMER_ORDERS` table, specifying columns `ORDER_ID`, `CUSTOMER_ID`, `ORDER_DATE`, and `ORDER_STATUS_CODE`, with values `p_customer_id` multiplied by 200 for the order ID, the input `p_customer_id` for the customer ID, a string representation of the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format (using `TO_CHAR` and `CURRENT_TIMESTAMP`) for the order date, and the string 'High Volume' for the status code. If the initial `v_order_count` is not greater than zero (i.e., zero), the procedure performs an INSERT into the `ORDER_ITEMS` table with columns `ORDER_ITEM_ID`, `ORDER_ID`, `PRODUCT_ID`, and `ORDER_QUANTITY`, using values `p_customer_id` multiplied by 300 for the item ID, the number 1 for the order ID, the number 1 for the product ID, and the string '1' for the order quantity.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_customer_orders(p_customer_id NUMBER)\nIS\n    v_order_count NUMBER;\n    v_total_quantity NUMBER;\n    v_first_order_id NUMBER;\n    v_last_order_id NUMBER;\n    v_avg_quantity NUMBER;\nBEGIN\n    SELECT COUNT(*), NVL(SUM(TO_NUMBER(ORDER_QUANTITY)), 0), MIN(ORDER_ID), MAX(ORDER_ID)\n    INTO v_order_count, v_total_quantity, v_first_order_id, v_last_order_id\n    FROM ORDER_ITEMS \n    WHERE ORDER_ID IN (SELECT ORDER_ID FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id);\n    \n    IF v_order_count > 0 THEN\n        v_avg_quantity := v_total_quantity / v_order_count;\n        \n        IF v_total_quantity < 5 THEN\n            INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n            VALUES (p_customer_id * 100, v_first_order_id, 1, TO_CHAR(5 - v_total_quantity));\n        ELSIF v_total_quantity BETWEEN 5 AND 10 THEN\n            UPDATE CUSTOMER_ORDERS \n            SET ORDER_STATUS_CODE = 'Medium Volume'\n            WHERE ORDER_ID IN (SELECT ORDER_ID FROM ORDER_ITEMS WHERE ORDER_ID = v_first_order_id);\n        ELSIF v_total_quantity > 10 AND v_avg_quantity > 3 THEN\n            DELETE FROM ORDER_ITEMS \n            WHERE ORDER_ID = v_last_order_id AND TO_NUMBER(ORDER_QUANTITY) < v_avg_quantity;\n        ELSE\n            INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n            VALUES (p_customer_id * 200, p_customer_id, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), 'High Volume');\n        END IF;\n    ELSE\n        INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n        VALUES (p_customer_id * 300, 1, 1, '1');\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  process_customer_orders(1);\n  COMMIT;\nEND;",
      "BEGIN\n  process_customer_orders(4);\n  COMMIT;\nEND;",
      "BEGIN\n  process_customer_orders(5);\n  COMMIT;\nEND;",
      "BEGIN\n  process_customer_orders(12);\n  COMMIT;\nEND;",
      "BEGIN\n  process_customer_orders(3);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `process_customer_orders` that accepts a customer ID. Calculate the count, total quantity, first, and last order ID from ORDER_ITEMS for that customer. If orders exist: if total quantity < 5, insert a new order item; if between 5 and 10, update the status of the first order to 'Medium Volume'; if > 10 and average quantity > 3, delete items from the last order where quantity is below average. Otherwise, insert a new high-volume customer order. If no orders exist, insert a default order item.",
    "natural_language": "Create a stored procedure called `process_customer_orders` that takes a customer ID. Figure out some numbers from their ORDER_ITEMS, like how many orders there are, the overall amount of items, and the earliest and latest order IDs. If the customer has any orders: when the total item count is pretty low, add a new order item; if it's a moderate amount, mark the first order as 'Medium Volume'; if it's a lot and the typical item count per order is decent, remove the less popular items from the most recent order. Otherwise, if none of those fit, put in a new order for a big spender. If the customer has no orders at all, just insert a basic default order item.",
    "id": 127
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_customer_payment_method that accepts a single input parameter p_customer_id of type NUMBER, which identifies a customer, and performs a series of operations to determine and set a customer's payment method based on their order history. The procedure first declares local variables v_order_count, v_total_quantity, v_first_order_id, v_last_order_id, and v_customer_exists, all of type NUMBER. It begins execution by querying the ORDER_ITEMS table to calculate aggregate data for all orders belonging to the specified customer: it counts the total number of order item rows, sums the ORDER_QUANTITY values (converting them from string to number using the TO_NUMBER function and handling potential nulls by using NVL to default to 0), and finds the minimum and maximum ORDER_ID values; this query uses a subquery in its WHERE clause to select only those ORDER_IDs that exist in the CUSTOMER_ORDERS table where the CUSTOMER_ID column matches the input parameter p_customer_id, and the results are stored into the respective local variables. Next, the procedure queries the CUSTOMERS table to check for the existence of the provided customer ID, storing the count of matching rows (either 0 or 1) into v_customer_exists. The core logic then uses conditional branching: if v_order_count is greater than 0 (meaning the customer has at least one order item), it checks whether the calculated v_total_quantity is even or odd by using the MOD function to compute the remainder when v_total_quantity is divided by 2; if the remainder is 0, it executes an UPDATE statement on the CUSTOMERS table, setting the PAYMENT_METHOD_CODE column to the literal string 'Even Quantity' for the row where CUSTOMER_ID equals p_customer_id; if the remainder is not 0, it updates the same row, setting PAYMENT_METHOD_CODE to 'Odd Quantity'. If, however, v_order_count is 0 (meaning the customer has no order items), a secondary conditional check is performed on v_customer_exists: if v_customer_exists is 0 (the customer does not exist in the CUSTOMERS table), it executes an INSERT statement into the CUSTOMERS table, creating a new row with CUSTOMER_ID set to the input parameter p_customer_id, ADDRESS_ID set to 1, PAYMENT_METHOD_CODE set to 'New Customer', and providing hardcoded default values for columns CUSTOMER_NUMBER ('000'), CUSTOMER_NAME ('New Name'), CUSTOMER_ADDRESS ('New Address'), CUSTOMER_PHONE ('000-000-0000'), and CUSTOMER_EMAIL ('new@example.com'); if v_customer_exists is not 0 (the customer exists but has no orders), it executes an UPDATE statement on the CUSTOMERS table, setting the PAYMENT_METHOD_CODE column to 'New Customer' for the row where CUSTOMER_ID equals p_customer_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_customer_payment_method(p_customer_id NUMBER)\nIS\n    v_order_count NUMBER;\n    v_total_quantity NUMBER;\n    v_first_order_id NUMBER;\n    v_last_order_id NUMBER;\n    v_customer_exists NUMBER;\nBEGIN\n    SELECT COUNT(*), NVL(SUM(TO_NUMBER(ORDER_QUANTITY)), 0), MIN(ORDER_ID), MAX(ORDER_ID)\n    INTO v_order_count, v_total_quantity, v_first_order_id, v_last_order_id\n    FROM ORDER_ITEMS \n    WHERE ORDER_ID IN (SELECT ORDER_ID FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id);\n    \n    SELECT COUNT(*)\n    INTO v_customer_exists\n    FROM CUSTOMERS\n    WHERE CUSTOMER_ID = p_customer_id;\n    \n    IF v_order_count > 0 THEN\n        IF MOD(v_total_quantity, 2) = 0 THEN\n            UPDATE CUSTOMERS \n            SET PAYMENT_METHOD_CODE = 'Even Quantity'\n            WHERE CUSTOMER_ID = p_customer_id;\n        ELSE\n            UPDATE CUSTOMERS \n            SET PAYMENT_METHOD_CODE = 'Odd Quantity'\n            WHERE CUSTOMER_ID = p_customer_id;\n        END IF;\n    ELSE\n        IF v_customer_exists = 0 THEN\n            INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL)\n            VALUES (p_customer_id, 1, 'New Customer', '000', 'New Name', 'New Address', '000-000-0000', 'new@example.com');\n        ELSE\n            UPDATE CUSTOMERS \n            SET PAYMENT_METHOD_CODE = 'New Customer'\n            WHERE CUSTOMER_ID = p_customer_id;\n        END IF;\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  update_customer_payment_method(p_customer_id => 1);\nEND;",
      "BEGIN\n  update_customer_payment_method(p_customer_id => 4);\nEND;",
      "BEGIN\n  update_customer_payment_method(p_customer_id => 5);\nEND;",
      "BEGIN\n  update_customer_payment_method(p_customer_id => 999);\nEND;",
      "BEGIN\n  update_customer_payment_method(p_customer_id => 12);\nEND;"
    ],
    "summary": "Create a stored procedure named `update_customer_payment_method` that accepts a customer ID. Calculate order count and total quantity for the customer. If orders exist, set the customer's payment method to 'Even Quantity' or 'Odd Quantity' based on whether the total is even or odd. If no orders exist: if the customer doesn't exist, insert a new customer with default values and 'New Customer' payment method; if the customer exists, update their payment method to 'New Customer'.",
    "natural_language": "Please construct a stored procedure designated as `update_customer_payment_method` that receives a customer ID as an input parameter. Subsequently, compute the total number of orders and the aggregate quantity of items for the specified customer. Should orders be present, assign the customer's payment method to either 'Even Quantity' or 'Odd Quantity', contingent upon whether the computed total quantity is an even or odd number, respectively. In the event that no orders are found, proceed as follows: if the customer record does not exist within the database, insert a new customer entry with default values and a payment method of 'New Customer'; conversely, if the customer record does exist, update their payment method to 'New Customer'.",
    "id": 128
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ADJUST_ORDER_ITEMS that accepts a single input parameter, p_product_id of type NUMBER, and performs a series of operations on the ORDER_ITEMS table based on aggregated data for that specific product ID. The procedure begins by querying the ORDER_ITEMS table to calculate four aggregate values for all rows where the PRODUCT_ID column matches the input p_product_id: it counts the total number of rows into variable v_order_count, sums the ORDER_QUANTITY values (first converting them from a string to a number with TO_NUMBER and defaulting to 0 with NVL if null) into variable v_total_quantity, and finds the minimum and maximum ORDER_ID values into variables v_first_order_id and v_last_order_id, respectively. If the v_order_count is greater than zero, indicating existing records for the product, the procedure executes a conditional block: if the calculated v_total_quantity is less than 5, it performs an INSERT into the ORDER_ITEMS table, creating a new row with an ORDER_ITEM_ID derived as p_product_id multiplied by 50, using the v_first_order_id as the ORDER_ID, the input p_product_id as the PRODUCT_ID, and an ORDER_QUANTITY calculated as the character string representation (using TO_CHAR) of the difference between 5 and v_total_quantity; if the v_total_quantity is between 5 and 10 inclusive (using the BETWEEN operator), it executes an UPDATE statement on the ORDER_ITEMS table, setting the ORDER_QUANTITY column to the character string representation of v_total_quantity multiplied by 2 for all rows where the PRODUCT_ID equals p_product_id; if the v_total_quantity is greater than 10, it executes a DELETE statement on the ORDER_ITEMS table, removing any rows where the PRODUCT_ID equals p_product_id and the ORDER_ID equals the v_last_order_id. If the initial query found no rows (v_order_count is zero), the procedure executes an alternative INSERT statement into the ORDER_ITEMS table, creating a new row with an ORDER_ITEM_ID derived as p_product_id multiplied by 75, a hardcoded ORDER_ID of 1, the input p_product_id as the PRODUCT_ID, and a hardcoded ORDER_QUANTITY of '1'.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_order_items(p_product_id NUMBER)\nIS\n    v_order_count NUMBER;\n    v_total_quantity NUMBER;\n    v_first_order_id NUMBER;\n    v_last_order_id NUMBER;\nBEGIN\n    SELECT COUNT(*), NVL(SUM(TO_NUMBER(ORDER_QUANTITY)), 0), MIN(ORDER_ID), MAX(ORDER_ID)\n    INTO v_order_count, v_total_quantity, v_first_order_id, v_last_order_id\n    FROM ORDER_ITEMS \n    WHERE PRODUCT_ID = p_product_id;\n    \n    IF v_order_count > 0 THEN\n        IF v_total_quantity < 5 THEN\n            INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n            VALUES (p_product_id * 50, v_first_order_id, p_product_id, TO_CHAR(5 - v_total_quantity));\n        ELSIF v_total_quantity BETWEEN 5 AND 10 THEN\n            UPDATE ORDER_ITEMS \n            SET ORDER_QUANTITY = TO_CHAR(v_total_quantity * 2)\n            WHERE PRODUCT_ID = p_product_id;\n        ELSE\n            DELETE FROM ORDER_ITEMS \n            WHERE PRODUCT_ID = p_product_id AND ORDER_ID = v_last_order_id;\n        END IF;\n    ELSE\n        INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n        VALUES (p_product_id * 75, 1, p_product_id, '1');\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_order_items(10);\n  commit;\nEND;",
      "BEGIN\n  adjust_order_items(11);\n  commit;\nEND;",
      "BEGIN\n  adjust_order_items(13);\n  commit;\nEND;",
      "BEGIN\n  adjust_order_items(14);\n  commit;\nEND;",
      "BEGIN\n  adjust_order_items(15);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `ADJUST_ORDER_ITEMS` that accepts a product ID. Calculate the count, total quantity, first, and last order ID for that product in ORDER_ITEMS. If records exist: if total quantity < 5, insert a new item to bring the total to 5; if between 5 and 10, double all quantities for that product; if > 10, delete items for the last order of that product. If no records exist, insert a default item for the product.",
    "natural_language": "Create a stored procedure, which should be named `ADJUST_ORDER_ITEMS`, that is designed to accept a specific product ID as its input parameter. This procedure must then perform a comprehensive analysis by meticulously calculating the total number of records, the aggregate sum of all quantities, and also identifying the very first and the very last order ID associated with that particular product within the ORDER_ITEMS table. In the scenario where such records are indeed found: if the meticulously calculated total quantity is determined to be less than five, the procedure must thoughtfully insert a brand new order item with a sufficient quantity to elegantly bring the cumulative total up to exactly five; if, however, the total quantity is found to be comfortably situated between five and ten, inclusive, the procedure should decisively double every single quantity value for all existing items of that product; and finally, if the total quantity exceeds ten, the procedure must carefully delete all items that belong to the most recent order placed for that specific product. Conversely, in the unfortunate event that no records whatsoever exist for the provided product ID, the procedure must gracefully insert a single default order item specifically for that product.",
    "id": 129
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `handle_customer_orders` that accepts a single input parameter, `p_customer_id`, of data type `NUMBER`. This procedure is designed to process customer order information and conditionally perform data manipulation language (DML) operations on the `CUSTOMER_ORDERS` table based on aggregated order item data.\n\nUpon execution, the procedure first declares four local variables: `v_order_count` of type `NUMBER` to store the total number of order items, `v_total_quantity` of type `NUMBER` to store the sum of order quantities, `v_first_order_id` of type `NUMBER` to store the minimum `ORDER_ID`, and `v_last_order_id` of type `NUMBER` to store the maximum `ORDER_ID`.\n\nNext, the procedure executes a `SELECT` statement to retrieve aggregated data from the `ORDER_ITEMS` table. This `SELECT` statement calculates the count of all rows, the sum of the `ORDER_QUANTITY` column (converted to a `NUMBER` using `TO_NUMBER` and defaulting to `0` if `SUM` returns `NULL` via `NVL`), the minimum value of the `ORDER_ID` column, and the maximum value of the `ORDER_ID` column. These aggregated values are then assigned to the respective local variables: `v_order_count`, `v_total_quantity`, `v_first_order_id`, and `v_last_order_id`. The `WHERE` clause of this `SELECT` statement filters the `ORDER_ITEMS` table to include only those rows where the `ORDER_ID` is present in a subquery. The subquery selects `ORDER_ID` values from the `CUSTOMER_ORDERS` table where the `CUSTOMER_ID` matches the input parameter `p_customer_id`.\n\nFollowing the data retrieval, the procedure enters a conditional block. It first checks if `v_order_count` is greater than `0`.\n\nIf `v_order_count` is greater than `0` (meaning the customer has existing order items), the procedure enters a nested conditional block:\n    - If `v_total_quantity` is less than `5`, an `INSERT` statement is executed. This statement adds a new row to the `CUSTOMER_ORDERS` table. The `ORDER_ID` is set to the value of `p_customer_id` multiplied by `100`. The `CUSTOMER_ID` is set to `p_customer_id`. The `ORDER_DATE` is set to the current timestamp, formatted as a string 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS')`. The `ORDER_STATUS_CODE` is set to the literal string 'Low Volume'.\n    - Else if `v_total_quantity` is between `5` and `10` (inclusive), an `UPDATE` statement is executed. This statement modifies the `CUSTOMER_ORDERS` table by setting the `ORDER_STATUS_CODE` to the literal string 'Medium Volume' for the row where the `ORDER_ID` matches the value stored in `v_first_order_id`.\n    - Else (if `v_total_quantity` is greater than `10`), a `DELETE` statement is executed. This statement removes rows from the `CUSTOMER_ORDERS` table where the `ORDER_ID` matches the value stored in `v_last_order_id`.\n\nIf `v_order_count` is not greater than `0` (meaning the customer has no existing order items), the procedure executes an `INSERT` statement. This statement adds a new row to the `CUSTOMER_ORDERS` table. The `ORDER_ID` is set to the value of `p_customer_id` multiplied by `200`. The `CUSTOMER_ID` is set to `p_customer_id`. The `ORDER_DATE` is set to the current timestamp, formatted as a string 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS')`. The `ORDER_STATUS_CODE` is set to the literal string 'New Order'.",
    "plsql": "CREATE OR REPLACE PROCEDURE handle_customer_orders(p_customer_id NUMBER)\nIS\n    v_order_count NUMBER;\n    v_total_quantity NUMBER;\n    v_first_order_id NUMBER;\n    v_last_order_id NUMBER;\nBEGIN\n    SELECT COUNT(*), NVL(SUM(TO_NUMBER(ORDER_QUANTITY)), 0), MIN(ORDER_ID), MAX(ORDER_ID)\n    INTO v_order_count, v_total_quantity, v_first_order_id, v_last_order_id\n    FROM ORDER_ITEMS \n    WHERE ORDER_ID IN (SELECT ORDER_ID FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id);\n    \n    IF v_order_count > 0 THEN\n        IF v_total_quantity < 5 THEN\n            INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n            VALUES (p_customer_id * 100, p_customer_id, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), 'Low Volume');\n        ELSIF v_total_quantity BETWEEN 5 AND 10 THEN\n            UPDATE CUSTOMER_ORDERS \n            SET ORDER_STATUS_CODE = 'Medium Volume'\n            WHERE ORDER_ID = v_first_order_id;\n        ELSE\n            DELETE FROM CUSTOMER_ORDERS \n            WHERE ORDER_ID = v_last_order_id;\n        END IF;\n    ELSE\n        INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n        VALUES (p_customer_id * 200, p_customer_id, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), 'New Order');\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  handle_customer_orders(1);\n  commit;\nEND;",
      "BEGIN\n  handle_customer_orders(4);\n  commit;\nEND;",
      "BEGIN\n  handle_customer_orders(5);\n  commit;\nEND;",
      "BEGIN\n  handle_customer_orders(12);\n  commit;\nEND;",
      "BEGIN\n  handle_customer_orders(3);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `handle_customer_orders` that accepts a customer ID. Calculate the count, total quantity, first, and last order ID from ORDER_ITEMS for that customer. If orders exist: if total quantity < 5, insert a new low-volume order; if between 5 and 10, update the first order's status to 'Medium Volume'; if > 10, delete the last order. If no orders exist, insert a new order with status 'New Order'.",
    "natural_language": "Write a stored procedure called `handle_customer_orders` that takes a customer ID. For that customer, determine the number of orders, the total quantity, and the first and last order ID from the ORDER_ITEMS table. If orders are found: when the total quantity is less than 5, add a new low-volume order; when it is between 5 and 10, change the status of the first order to 'Medium Volume'; when it exceeds 10, remove the last order. If no orders are found, insert a new order with the status 'New Order'.",
    "id": 130
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts four input parameters: a numeric parameter 'p_company_id' representing a company identifier, a numeric parameter 'p_station_id' representing a station identifier, a numeric parameter 'p_rank' representing a rank value, and a numeric parameter 'p_open_year' representing a year, though this last parameter is not used within the procedure's logic. The procedure begins by declaring a local numeric variable 'v_count'. It then executes a SELECT statement to query the 'STATION_COMPANY' table, counting the number of existing rows where the 'COMPANY_ID' column matches the input parameter 'p_company_id' and the 'STATION_ID' column matches the input parameter 'p_station_id', storing the result of this count into the variable 'v_count'. Following this query, an IF conditional statement evaluates whether the value of 'v_count' is equal to zero. If this condition is true, indicating that no matching record exists in the 'STATION_COMPANY' table for the given company and station combination, the procedure performs an INSERT operation into the 'STATION_COMPANY' table. This INSERT statement specifies values for three columns: it sets the 'STATION_ID' column to the value of the input parameter 'p_station_id', sets the 'COMPANY_ID' column to the value of the input parameter 'p_company_id', and sets the 'RANK_OF_THE_YEAR' column to the value of the input parameter 'p_rank'. If the condition in the IF statement is false, meaning 'v_count' is not zero and a matching record already exists, the procedure takes no further action and concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_company_id NUMBER, p_station_id NUMBER, p_rank NUMBER, p_open_year NUMBER) IS\n   v_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_count FROM STATION_COMPANY WHERE COMPANY_ID = p_company_id AND STATION_ID = p_station_id;\n   IF v_count = 0 THEN\n      INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (p_station_id, p_company_id, p_rank);\n   END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1, 1, 1, 1998);\n  commit;\nEND;",
      "BEGIN\n  sp(2, 2, 3, 1999);\n  commit;\nEND;",
      "BEGIN\n  sp(3, 3, 4, 2000);\n  commit;\nEND;",
      "BEGIN\n  sp(1, 2, 1, 1999);\n  commit;\nEND;",
      "BEGIN\n  sp(2, 3, 3, 2000);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp' that inserts a record into the STATION_COMPANY table for a given company and station if it does not already exist. The procedure accepts parameters for company ID, station ID, and rank. A fourth parameter for year is accepted but not used.",
    "natural_language": "How can I create a stored procedure named 'sp' that will insert a record into the STATION_COMPANY table for a specified company and station, but only if the record does not already exist? The procedure should accept parameters for company ID, station ID, and rank, and also accept a fourth parameter for year that is not used.",
    "id": 131
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that accepts four parameters: p_start_year and p_end_year, both of type NUMBER, representing the range of years to filter gas stations by their OPEN_YEAR; p_months_buffer, also of type NUMBER, which is used to create an interval but is not directly utilized in the procedure's logic; and p_company_filter, a NUMBER that specifies a company ID to exclude from deletion. The procedure defines a cursor named station_cursor that selects the STATION_ID from the GAS_STATION table where the OPEN_YEAR is between p_start_year and p_end_year, inclusive. It initializes an interval variable v_year_interval using the NUMTOYMINTERVAL function with p_months_buffer and 'MONTH' as arguments, although this interval is not used further in the procedure. The procedure opens the station_cursor and enters a loop to fetch each STATION_ID into the variable v_station_id. For each fetched STATION_ID, it executes a DELETE operation on the STATION_COMPANY table, removing rows where the STATION_ID matches v_station_id and the COMPANY_ID is not equal to p_company_filter. The loop continues until all records from the cursor are processed, at which point the cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_start_year NUMBER, p_end_year NUMBER, p_months_buffer NUMBER, p_company_filter NUMBER) IS\n   v_year_interval INTERVAL YEAR TO MONTH;\n   v_station_id NUMBER;\n   CURSOR station_cursor IS \n      SELECT STATION_ID FROM GAS_STATION WHERE OPEN_YEAR BETWEEN p_start_year AND p_end_year;\nBEGIN\n   v_year_interval := NUMTOYMINTERVAL(p_months_buffer, 'MONTH');\n   OPEN station_cursor;\n   LOOP\n      FETCH station_cursor INTO v_station_id;\n      EXIT WHEN station_cursor%NOTFOUND;\n      DELETE FROM STATION_COMPANY WHERE STATION_ID = v_station_id AND COMPANY_ID != p_company_filter;\n   END LOOP;\n   CLOSE station_cursor;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1990, 2000, 6, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2000, 2010, 12, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1995, 2005, 3, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1980, 1990, 24, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2010, 2020, 0, 3);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure that deletes records from the STATION_COMPANY table for all gas stations opened within a specified year range, excluding those linked to a specific company ID. The procedure accepts parameters for start year, end year, a months buffer (unused), and the company ID to exclude.",
    "natural_language": "Develop a stored procedure that meticulously removes entries from the STATION_COMPANY table, specifically targeting all gas stations whose opening dates fall entirely within a clearly defined span of years, while carefully ensuring that any stations associated with a particular, designated company identifier are preserved and excluded from this deletion. This procedure must formally accept input parameters for the inclusive starting year, the inclusive ending year, an optional buffer period in months which remains unused, and the precise company ID that should be exempted.",
    "id": 132
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_gymnast_rankings that accepts two input parameters: p_min_age of type NUMBER to define the lower age bound and p_max_age of type NUMBER to define the upper age bound. The procedure first declares local variables v_count, v_avg_total, v_max_total, v_min_total, and v_age_group, all of type NUMBER. It begins execution by querying the gymnast table joined with the people table on gymnast.gymnast_id equals people.people_id, filtering for rows where the people.age column value falls between the input parameters p_min_age and p_max_age; from this result set, it calculates and stores the total count of rows into v_count, the average of gymnast.total_points into v_avg_total, the maximum gymnast.total_points into v_max_total, and the minimum gymnast.total_points into v_min_total. It then computes v_age_group by taking the floor of the average of p_min_age and p_max_age.\n\nThe core logic uses nested conditional statements based on these aggregated values. If v_count is greater than 5, it proceeds to check if v_avg_total is greater than 57.5; if true, it then checks if v_max_total is greater than 58.5, and if so, it updates the gymnast table by increasing the total_points column by 0.1 specifically for gymnasts whose gymnast_id is found in a subquery that selects gymnast.gymnast_id from the gymnast and people join where people.age equals the computed v_age_group and gymnast.total_points equals the previously found v_max_total. If the v_max_total condition is not met (i.e., v_max_total is not greater than 58.5) but v_min_total is less than 56.5, then it updates the gymnast table by increasing total_points by 0.2 for gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age and gymnast.total_points is less than the computed v_avg_total. If neither the v_max_total > 58.5 nor the v_min_total < 56.5 conditions are true within the v_avg_total > 57.5 branch, it executes an update that rounds the total_points column to two decimal places using the ROUND function for all gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age.\n\nIf, in the outer v_count > 5 branch, the initial condition v_avg_total > 57.5 is false, the procedure then checks if v_count is greater than 8; if true, it evaluates whether the difference between v_max_total and v_min_total is greater than 2.0. If this range condition is true, it updates the gymnast table by setting total_points to the average of the current total_points and v_avg_total (i.e., (total_points + v_avg_total) / 2) for gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age and the absolute difference between gymnast.total_points and v_avg_total, calculated using the ABS function, is greater than 1.0. If the range condition v_max_total - v_min_total > 2.0 is false, it updates the gymnast table by increasing total_points by 0.05 for all gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age. If, within the v_count > 5 branch, the condition v_count > 8 is also false, it executes an update that sets total_points to the ceiling of total_points multiplied by 100, then divided by 100 (effectively rounding up to two decimal places) using the CEIL function, for gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age.\n\nIf the initial v_count > 5 condition is false (i.e., v_count is 5 or less), the procedure checks if v_avg_total is greater than 57.0; if true, it updates the gymnast table by multiplying total_points by 1.01 for all gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age. If v_avg_total is not greater than 57.0, it updates the gymnast table by increasing total_points by 0.3 for all gymnasts whose gymnast_id is in a subquery selecting gymnast.gymnast_id from the joined tables where people.age is between p_min_age and p_max_age.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_gymnast_rankings(\n    p_min_age IN NUMBER,\n    p_max_age IN NUMBER\n)\nIS\n    v_count NUMBER;\n    v_avg_total NUMBER;\n    v_max_total NUMBER;\n    v_min_total NUMBER;\n    v_age_group NUMBER;\nBEGIN\n    SELECT COUNT(*), AVG(g.total_points), MAX(g.total_points), MIN(g.total_points)\n    INTO v_count, v_avg_total, v_max_total, v_min_total\n    FROM gymnast g\n    JOIN people p ON g.gymnast_id = p.people_id\n    WHERE p.age BETWEEN p_min_age AND p_max_age;\n    \n    v_age_group := FLOOR((p_min_age + p_max_age) / 2);\n    \n    IF v_count > 5 THEN\n        IF v_avg_total > 57.5 THEN\n            IF v_max_total > 58.5 THEN\n                UPDATE gymnast \n                SET total_points = total_points + 0.1\n                WHERE gymnast_id IN (\n                    SELECT g.gymnast_id FROM gymnast g\n                    JOIN people p ON g.gymnast_id = p.people_id\n                    WHERE p.age = v_age_group AND g.total_points = v_max_total\n                );\n            ELSIF v_min_total < 56.5 THEN\n                UPDATE gymnast \n                SET total_points = total_points + 0.2\n                WHERE gymnast_id IN (\n                    SELECT g.gymnast_id FROM gymnast g\n                    JOIN people p ON g.gymnast_id = p.people_id\n                    WHERE p.age BETWEEN p_min_age AND p_max_age AND g.total_points < v_avg_total\n                );\n            ELSE\n                UPDATE gymnast \n                SET total_points = ROUND(total_points, 2)\n                WHERE gymnast_id IN (\n                    SELECT g.gymnast_id FROM gymnast g\n                    JOIN people p ON g.gymnast_id = p.people_id\n                    WHERE p.age BETWEEN p_min_age AND p_max_age\n                );\n            END IF;\n        ELSIF v_count > 8 THEN\n            IF v_max_total - v_min_total > 2.0 THEN\n                UPDATE gymnast \n                SET total_points = (total_points + v_avg_total) / 2\n                WHERE gymnast_id IN (\n                    SELECT g.gymnast_id FROM gymnast g\n                    JOIN people p ON g.gymnast_id = p.people_id\n                    WHERE p.age BETWEEN p_min_age AND p_max_age AND ABS(g.total_points - v_avg_total) > 1.0\n                );\n            ELSE\n                UPDATE gymnast \n                SET total_points = total_points + 0.05\n                WHERE gymnast_id IN (\n                    SELECT g.gymnast_id FROM gymnast g\n                    JOIN people p ON g.gymnast_id = p.people_id\n                    WHERE p.age BETWEEN p_min_age AND p_max_age\n                );\n            END IF;\n        ELSE\n            UPDATE gymnast \n            SET total_points = CEIL(total_points * 100) / 100\n            WHERE gymnast_id IN (\n                SELECT g.gymnast_id FROM gymnast g\n                JOIN people p ON g.gymnast_id = p.people_id\n                WHERE p.age BETWEEN p_min_age AND p_max_age\n            );\n        END IF;\n    ELSE\n        IF v_avg_total > 57.0 THEN\n            UPDATE gymnast \n            SET total_points = total_points * 1.01\n            WHERE gymnast_id IN (\n                SELECT g.gymnast_id FROM gymnast g\n                JOIN people p ON g.gymnast_id = p.people_id\n                WHERE p.age BETWEEN p_min_age AND p_max_age\n            );\n        ELSE\n            UPDATE gymnast \n            SET total_points = total_points + 0.3\n            WHERE gymnast_id IN (\n                SELECT g.gymnast_id FROM gymnast g\n                JOIN people p ON g.gymnast_id = p.people_id\n                WHERE p.age BETWEEN p_min_age AND p_max_age\n            );\n        END IF;\n    END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  update_gymnast_rankings(p_min_age => 18, p_max_age => 20);\nEND;",
      "BEGIN\n  update_gymnast_rankings(p_min_age => 21, p_max_age => 23);\nEND;",
      "BEGIN\n  update_gymnast_rankings(p_min_age => 24, p_max_age => 26);\nEND;",
      "BEGIN\n  update_gymnast_rankings(p_min_age => 19, p_max_age => 22);\nEND;",
      "BEGIN\n  update_gymnast_rankings(p_min_age => 20, p_max_age => 25);\nEND;"
    ],
    "summary": "Create a stored procedure named 'update_gymnast_rankings' that updates gymnast scores based on aggregated statistics (count, average, max, min) of gymnasts within a specified age range. The update logic uses nested conditional checks on these aggregates to determine whether to apply specific point increases, set points to an average, or perform rounding operations.",
    "natural_language": "How can I create a stored procedure called 'update_gymnast_rankings' that updates gymnast scores by using aggregated statisticslike count, average, maximum, and minimumfor gymnasts in a given age range, and then applies nested conditional checks on these aggregates to decide whether to increase points by specific amounts, set points to an average, or perform rounding operations?",
    "id": 133
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_proc1` that accepts two input parameters: `p_dept_id` of type `NUMBER`, representing a department identifier, and `p_new_location_id` of type `NUMBER`, representing a new location identifier. The procedure first declares three local variables: `v_emp_count` of type `NUMBER` to store the count of employees, `v_job_count` of type `NUMBER` to store the count of distinct jobs, and `v_location_id` of type `NUMBER` to store a location identifier.\n\nThe procedure begins by executing three `SELECT` statements. The first `SELECT` statement queries the `EMPLOYEES` table to count the number of employees whose `DEPARTMENT_ID` matches the input parameter `p_dept_id`. The result of this count is stored in the `v_emp_count` variable. The second `SELECT` statement queries the `JOBS` table to count the number of distinct `JOB_ID` values. The `JOB_ID` values considered for this count are those found in the `EMPLOYEES` table for employees whose `DEPARTMENT_ID` matches `p_dept_id`. The result of this count is stored in the `v_job_count` variable. The third `SELECT` statement queries the `DEPARTMENTS` table to retrieve the `LOCATION_ID` for the department whose `DEPARTMENT_ID` matches `p_dept_id`. This retrieved `LOCATION_ID` is stored in the `v_location_id` variable.\n\nFollowing these initial data retrievals, the procedure enters a conditional block (`IF-ELSIF-ELSE`).\nIf the value of `v_emp_count` is greater than 10, the procedure executes an `UPDATE` statement on the `DEPARTMENTS` table. This `UPDATE` statement sets the `LOCATION_ID` column to the value of the input parameter `p_new_location_id` for the row where `DEPARTMENT_ID` matches `p_dept_id`.\nIf the condition `v_emp_count > 10` is false, the procedure then checks if `v_job_count` is greater than 5. If this condition is true, the procedure executes a `DELETE` statement on the `EMPLOYEES` table. This `DELETE` statement removes all rows where the `DEPARTMENT_ID` matches `p_dept_id`.\nIf both previous conditions are false (i.e., `v_emp_count` is not greater than 10 AND `v_job_count` is not greater than 5), the procedure executes an `INSERT` statement into the `JOB_HISTORY` table. This `INSERT` statement populates the `EMPLOYEE_ID`, `START_DATE`, `END_DATE`, `JOB_ID`, and `DEPARTMENT_ID` columns. The values for `EMPLOYEE_ID`, `JOB_ID`, and `DEPARTMENT_ID` are selected from the `EMPLOYEES` table for all employees whose `DEPARTMENT_ID` matches `p_dept_id`. The `START_DATE` is set to the `CURRENT_DATE`, and the `END_DATE` is set to `NULL`.\n\nAfter this first conditional block, the procedure enters a second, independent conditional block (`IF-ELSE`).\nIf the value of `v_location_id` is not `NULL`, the procedure executes an `UPDATE` statement on the `LOCATIONS` table. This `UPDATE` statement sets the `CITY` column to the literal string 'Updated City' for the row where `LOCATION_ID` matches the value stored in `v_location_id`.\nIf the condition `v_location_id IS NOT NULL` is false (i.e., `v_location_id` is `NULL`), the procedure executes an `INSERT` statement into the `LOCATIONS` table. This `INSERT` statement inserts a new row with `LOCATION_ID` set to the value of `p_new_location_id`, `CITY` set to the literal string 'New City', and `COUNTRY_ID` set to the literal string 'US'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc1(p_dept_id NUMBER, p_new_location_id NUMBER) IS\n  v_emp_count NUMBER;\n  v_job_count NUMBER;\n  v_location_id NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_emp_count FROM EMPLOYEES WHERE DEPARTMENT_ID = p_dept_id;\n  SELECT COUNT(*) INTO v_job_count FROM JOBS WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = p_dept_id);\n  SELECT LOCATION_ID INTO v_location_id FROM DEPARTMENTS WHERE DEPARTMENT_ID = p_dept_id;\n  \n  IF v_emp_count > 10 THEN\n    UPDATE DEPARTMENTS SET LOCATION_ID = p_new_location_id WHERE DEPARTMENT_ID = p_dept_id;\n  ELSIF v_job_count > 5 THEN\n    DELETE FROM EMPLOYEES WHERE DEPARTMENT_ID = p_dept_id;\n  ELSE\n    INSERT INTO JOB_HISTORY (EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID) \n    SELECT EMPLOYEE_ID, CURRENT_DATE, NULL, JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = p_dept_id;\n  END IF;\n  \n  IF v_location_id IS NOT NULL THEN\n    UPDATE LOCATIONS SET CITY = 'Updated City' WHERE LOCATION_ID = v_location_id;\n  ELSE\n    INSERT INTO LOCATIONS (LOCATION_ID, CITY, COUNTRY_ID) VALUES (p_new_location_id, 'New City', 'US');\n  END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc1(90, 2000);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(10, 2100);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(20, 2200);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(30, 2300);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(40, 2400);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp_proc1' that manages department data. Based on employee count and distinct job count for a given department, it either updates the department's location, deletes its employees, or inserts their history into JOB_HISTORY. A separate conditional block then updates or inserts a location record based on the department's current location ID.",
    "natural_language": "Create a stored procedure called 'sp_proc1' to handle department information. It should look at how many employees are in a department and the different kinds of jobs they have. Based on those somewhat vague measures, it might change where the department is, remove its employees, or put a note about them in the JOB_HISTORY table. After that, another part of the procedure checks the department's location ID and decides whether to update an existing location record or add a new one.",
    "id": 134
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc2 that accepts two input parameters: a string parameter p_job_title of type VARCHAR2 and a numeric parameter p_salary_increase of type NUMBER. The procedure first declares a cursor named emp_cursor that selects the EMPLOYEE_ID and SALARY columns from the EMPLOYEES table for all employees whose JOB_ID matches any JOB_ID found in the JOBS table where the JOB_TITLE column equals the input parameter p_job_title; this cursor is declared with the FOR UPDATE clause. The procedure also declares two local numeric variables: v_total_salary and v_avg_salary. In the execution section, the procedure performs two separate queries: it calculates the sum of all SALARY values from the EMPLOYEES table for employees with the specified job title and stores the result into v_total_salary, and it calculates the average of all SALARY values for the same set of employees and stores the result into v_avg_salary. The procedure then opens a loop that iterates through each record fetched by the emp_cursor. For each employee record retrieved, if the employee's SALARY is less than the calculated average salary stored in v_avg_salary, the procedure updates the EMPLOYEES table, increasing that specific employee's SALARY by the amount specified in the p_salary_increase parameter, using the WHERE CURRENT OF emp_cursor clause to target the current cursor row. If the employee's SALARY is not less than the average (i.e., it is greater than or equal to the average), the procedure deletes that specific employee's record from the EMPLOYEES table using the WHERE CURRENT OF emp_cursor clause. After processing all employee records, the procedure checks the value of v_total_salary. If v_total_salary is greater than 100000, the procedure inserts a new row into the JOBS table, providing values for the columns JOB_ID as 'NEW_JOB', JOB_TITLE as the concatenation of the string 'New ' and the input parameter p_job_title, MIN_SALARY as 5000, and MAX_SALARY as 15000. If v_total_salary is not greater than 100000 (i.e., it is less than or equal to 100000), the procedure updates the JOBS table, increasing the MAX_SALARY column by 5000 for any row where the JOB_TITLE column equals the input parameter p_job_title.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc2(p_job_title VARCHAR2, p_salary_increase NUMBER) IS\n  CURSOR emp_cursor IS SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE JOB_ID IN (SELECT JOB_ID FROM JOBS WHERE JOB_TITLE = p_job_title) FOR UPDATE;\n  v_total_salary NUMBER;\n  v_avg_salary NUMBER;\nBEGIN\n  SELECT SUM(SALARY) INTO v_total_salary FROM EMPLOYEES WHERE JOB_ID IN (SELECT JOB_ID FROM JOBS WHERE JOB_TITLE = p_job_title);\n  SELECT AVG(SALARY) INTO v_avg_salary FROM EMPLOYEES WHERE JOB_ID IN (SELECT JOB_ID FROM JOBS WHERE JOB_TITLE = p_job_title);\n  \n  FOR emp_rec IN emp_cursor LOOP\n    IF emp_rec.SALARY < v_avg_salary THEN\n      UPDATE EMPLOYEES SET SALARY = SALARY + p_salary_increase WHERE CURRENT OF emp_cursor;\n    ELSE\n      DELETE FROM EMPLOYEES WHERE CURRENT OF emp_cursor;\n    END IF;\n  END LOOP;\n  \n  IF v_total_salary > 100000 THEN\n    INSERT INTO JOBS (JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY) VALUES ('NEW_JOB', 'New ' || p_job_title, 5000, 15000);\n  ELSE\n    UPDATE JOBS SET MAX_SALARY = MAX_SALARY + 5000 WHERE JOB_TITLE = p_job_title;\n  END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc2('President', 1000);\nEND;",
      "BEGIN\n  sp_proc2('Administration Vice President', 500);\nEND;",
      "BEGIN\n  sp_proc2('Administration Assistant', 200);\nEND;",
      "BEGIN\n  sp_proc2('Programmer', 750);\nEND;",
      "BEGIN\n  sp_proc2('Marketing Representative', 300);\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp_proc2' that processes employees with a specific job title. It calculates the total and average salary for these employees. It then loops through each employee: if their salary is below the average, it increases it by a specified amount; otherwise, it deletes the employee record. Finally, based on the initial total salary, it either inserts a new job or updates the max salary for the existing job title.",
    "natural_language": "How can I create a stored procedure named 'sp_proc2' that processes employees by a specific job title? The procedure should calculate the total and average salary for these employees, then loop through each one: if an employee's salary is below the average, how do I increase it by a given amount, and if it is not, how do I delete that employee's record? Finally, based on the initial total salary, how does the procedure decide whether to insert a new job or update the maximum salary for the existing job title?",
    "id": 135
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc3 that accepts two input parameters: a numeric parameter p_location_id and a string parameter p_new_city. The procedure begins by executing three separate SELECT COUNT(*) queries. The first query counts the number of rows in the DEPARTMENTS table where the LOCATION_ID column matches the input p_location_id, storing the result in variable v_dept_count. The second query counts the number of rows in the EMPLOYEES table where the DEPARTMENT_ID is found in the set of DEPARTMENT_ID values from the DEPARTMENTS table for rows with the specified LOCATION_ID, storing the result in variable v_emp_count. The third query counts the number of rows in the JOBS table where the JOB_ID is found in the set of JOB_ID values from the EMPLOYEES table for employees whose DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table for the specified LOCATION_ID, storing the result in variable v_job_count.\n\nFollowing these counts, the procedure uses an IF-ELSIF-ELSE conditional block. If v_dept_count is greater than 5, it executes an UPDATE statement on the LOCATIONS table, setting the CITY column to the value of p_new_city for the row where LOCATION_ID equals p_location_id. Otherwise, if v_emp_count is greater than 20, it executes a DELETE statement on the DEPARTMENTS table, removing all rows where LOCATION_ID equals p_location_id. If neither condition is true, it executes an INSERT statement into the DEPARTMENTS table, specifying columns DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, and LOCATION_ID. The value for DEPARTMENT_ID is derived from a subquery that calculates the maximum existing DEPARTMENT_ID plus one, DEPARTMENT_NAME is set to the literal string 'New Department', MANAGER_ID is set to NULL, and LOCATION_ID is set to the input p_location_id.\n\nSubsequently, the procedure uses a second IF-ELSE conditional block based on the v_job_count variable. If v_job_count is greater than 10, it executes an UPDATE statement on the JOBS table, setting the JOB_TITLE column to the literal string 'Updated Job' for rows where the JOB_ID is in the set of JOB_ID values from the EMPLOYEES table for employees whose DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table for the specified LOCATION_ID. If v_job_count is 10 or less, it executes a DELETE statement on the JOB_HISTORY table, removing rows where the DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table for the specified LOCATION_ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc3(p_location_id NUMBER, p_new_city VARCHAR2) IS\n  v_dept_count NUMBER;\n  v_emp_count NUMBER;\n  v_job_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_dept_count FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id;\n  SELECT COUNT(*) INTO v_emp_count FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id);\n  SELECT COUNT(*) INTO v_job_count FROM JOBS WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id));\n  \n  IF v_dept_count > 5 THEN\n    UPDATE LOCATIONS SET CITY = p_new_city WHERE LOCATION_ID = p_location_id;\n  ELSIF v_emp_count > 20 THEN\n    DELETE FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id;\n  ELSE\n    INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID) VALUES ((SELECT MAX(DEPARTMENT_ID)+1 FROM DEPARTMENTS), 'New Department', NULL, p_location_id);\n  END IF;\n  \n  IF v_job_count > 10 THEN\n    UPDATE JOBS SET JOB_TITLE = 'Updated Job' WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id));\n  ELSE\n    DELETE FROM JOB_HISTORY WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id);\n  END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc3(1700, 'New York');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1800, 'Los Angeles');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1000, 'Chicago');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1100, 'Houston');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1200, 'Phoenix');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc3 that accepts a location ID and a new city. Count departments at that location, employees in those departments, and jobs held by those employees. If the department count exceeds 5, update the location's city. Else, if the employee count exceeds 20, delete departments at that location. Otherwise, insert a new department. Then, if the job count exceeds 10, update those job titles. Otherwise, delete related job history records.",
    "natural_language": "What stored procedure, named sp_proc3, can be created to accept a location ID and a new city, count the departments at that location, the employees in those departments, and the jobs held by those employees, and then, if the department count exceeds 5, update the location's city, or else if the employee count exceeds 20, delete departments at that location, or otherwise insert a new department, and subsequently, if the job count exceeds 10, update those job titles, or otherwise delete the related job history records?",
    "id": 136
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc4 that accepts two parameters: p_manager_id of type NUMBER, representing the manager's ID, and p_new_salary of type NUMBER, representing the new salary amount. The procedure begins by declaring three local variables: v_emp_count, v_dept_count, and v_job_count, all of type NUMBER. It first executes a SELECT statement to count the number of employees in the EMPLOYEES table where the MANAGER_ID column matches the p_manager_id parameter, storing the result in v_emp_count. Next, it counts the number of departments in the DEPARTMENTS table with the same manager ID, storing this count in v_dept_count. It then counts the number of jobs in the JOBS table where the JOB_ID is found in a subquery that selects JOB_IDs from the EMPLOYEES table with the specified manager ID, storing this count in v_job_count. The procedure then evaluates a series of conditional statements: if v_emp_count is greater than 10, it updates the EMPLOYEES table, setting the SALARY column to p_new_salary for all rows where MANAGER_ID equals p_manager_id. If v_emp_count is not greater than 10 but v_dept_count is greater than 5, it deletes rows from the DEPARTMENTS table where MANAGER_ID matches p_manager_id. If neither of these conditions is met, it inserts new rows into the JOB_HISTORY table, selecting EMPLOYEE_ID, the current date as START_DATE, NULL as END_DATE, JOB_ID, and DEPARTMENT_ID from the EMPLOYEES table where MANAGER_ID equals p_manager_id. Following this, the procedure checks if v_job_count is greater than 15; if true, it updates the JOBS table by increasing the MIN_SALARY column by 1000 for rows where JOB_ID is in the subquery selecting JOB_IDs from the EMPLOYEES table with the specified manager ID. If v_job_count is not greater than 15, it deletes rows from the JOB_HISTORY table where EMPLOYEE_ID is in the subquery selecting EMPLOYEE_IDs from the EMPLOYEES table with the specified manager ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc4(p_manager_id NUMBER, p_new_salary NUMBER) IS\n  v_emp_count NUMBER;\n  v_dept_count NUMBER;\n  v_job_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_emp_count FROM EMPLOYEES WHERE MANAGER_ID = p_manager_id;\n  SELECT COUNT(*) INTO v_dept_count FROM DEPARTMENTS WHERE MANAGER_ID = p_manager_id;\n  SELECT COUNT(*) INTO v_job_count FROM JOBS WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE MANAGER_ID = p_manager_id);\n  \n  IF v_emp_count > 10 THEN\n    UPDATE EMPLOYEES SET SALARY = p_new_salary WHERE MANAGER_ID = p_manager_id;\n  ELSIF v_dept_count > 5 THEN\n    DELETE FROM DEPARTMENTS WHERE MANAGER_ID = p_manager_id;\n  ELSE\n    INSERT INTO JOB_HISTORY (EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID) \n    SELECT EMPLOYEE_ID, CURRENT_DATE, NULL, JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE MANAGER_ID = p_manager_id;\n  END IF;\n  \n  IF v_job_count > 15 THEN\n    UPDATE JOBS SET MIN_SALARY = MIN_SALARY + 1000 WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE MANAGER_ID = p_manager_id);\n  ELSE\n    DELETE FROM JOB_HISTORY WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE MANAGER_ID = p_manager_id);\n  END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc4(200, 25000);\n  commit;\nEND;",
      "BEGIN\n  sp_proc4(201, 18000);\n  commit;\nEND;",
      "BEGIN\n  sp_proc4(114, 22000);\n  commit;\nEND;",
      "BEGIN\n  sp_proc4(100, 26000);\n  commit;\nEND;",
      "BEGIN\n  sp_proc4(101, 19000);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc4 that accepts a manager ID and a new salary amount. Count employees, departments, and jobs under that manager. If the employee count exceeds 10, update their salaries. Else, if the department count exceeds 5, delete those departments. Otherwise, insert job history records for those employees. Then, if the job count exceeds 15, increase the minimum salary for those jobs. Otherwise, delete related job history records.",
    "natural_language": "Given a manager ID and a new salary amount, what steps does the stored procedure 'sp_proc4' perform? Specifically, how does it count the employees, departments, and jobs under that manager, and based on those counts, when does it update salaries, delete departments, insert job history, increase minimum salaries, or delete job history records?",
    "id": 137
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc5 that accepts two input parameters: a VARCHAR2 parameter p_country_id representing a country identifier and a VARCHAR2 parameter p_new_state representing a new state or province name. The procedure first executes three separate SELECT COUNT(*) queries: it stores the count of rows from the LOCATIONS table where the COUNTRY_ID column equals the input p_country_id into a local variable v_location_count; it stores the count of rows from the DEPARTMENTS table where the LOCATION_ID is found in the set of LOCATION_ID values from the LOCATIONS table for that same p_country_id into a local variable v_dept_count; and it stores the count of rows from the EMPLOYEES table where the DEPARTMENT_ID is found in the set of DEPARTMENT_ID values from the DEPARTMENTS table whose LOCATION_ID is in the set of LOCATION_ID values from the LOCATIONS table for that p_country_id into a local variable v_emp_count. The procedure then uses an IF-ELSIF-ELSE construct: if v_location_count is greater than 3, it performs an UPDATE on the LOCATIONS table, setting the STATE_PROVINCE column to the value of p_new_state for all rows where COUNTRY_ID equals p_country_id; otherwise, if v_dept_count is greater than 10, it performs a DELETE on the DEPARTMENTS table for all rows where LOCATION_ID is in the set of LOCATION_ID values from the LOCATIONS table for that p_country_id; otherwise, if neither condition is met, it performs an INSERT into the LOCATIONS table, specifying values for LOCATION_ID, CITY, and COUNTRY_ID, where the LOCATION_ID is calculated as the maximum existing LOCATION_ID from the LOCATIONS table incremented by 1, the CITY is set to the literal string 'New City', and the COUNTRY_ID is set to the input p_country_id. Following this, the procedure uses another IF-ELSE construct: if v_emp_count is greater than 20, it performs an UPDATE on the EMPLOYEES table, setting the COMMISSION_PCT column to its current value multiplied by 1.2 for all rows where the DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table whose LOCATION_ID is in the set of LOCATION_ID values from the LOCATIONS table for that p_country_id; otherwise, it performs a DELETE on the JOB_HISTORY table for all rows where the DEPARTMENT_ID is in that same set of DEPARTMENT_ID values.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc5(p_country_id VARCHAR2, p_new_state VARCHAR2) IS\n  v_location_count NUMBER;\n  v_dept_count NUMBER;\n  v_emp_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_location_count FROM LOCATIONS WHERE COUNTRY_ID = p_country_id;\n  SELECT COUNT(*) INTO v_dept_count FROM DEPARTMENTS WHERE LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE COUNTRY_ID = p_country_id);\n  SELECT COUNT(*) INTO v_emp_count FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE COUNTRY_ID = p_country_id));\n  \n  IF v_location_count > 3 THEN\n    UPDATE LOCATIONS SET STATE_PROVINCE = p_new_state WHERE COUNTRY_ID = p_country_id;\n  ELSIF v_dept_count > 10 THEN\n    DELETE FROM DEPARTMENTS WHERE LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE COUNTRY_ID = p_country_id);\n  ELSE\n    INSERT INTO LOCATIONS (LOCATION_ID, CITY, COUNTRY_ID) VALUES ((SELECT MAX(LOCATION_ID)+1 FROM LOCATIONS), 'New City', p_country_id);\n  END IF;\n  \n  IF v_emp_count > 20 THEN\n    UPDATE EMPLOYEES SET COMMISSION_PCT = COMMISSION_PCT * 1.2 WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE COUNTRY_ID = p_country_id));\n  ELSE\n    DELETE FROM JOB_HISTORY WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID IN (SELECT LOCATION_ID FROM LOCATIONS WHERE COUNTRY_ID = p_country_id));\n  END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc5('US', 'California');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc5('IT', 'Lazio');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc5('JP', 'Tokyo');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc5('UK', 'England');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc5('CA', 'Ontario');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc5 that accepts a country ID and a new state name. Count locations in that country, departments in those locations, and employees in those departments. If the location count exceeds 3, update the state for those locations. Else, if the department count exceeds 10, delete those departments. Otherwise, insert a new location. Then, if the employee count exceeds 20, increase their commission. Otherwise, delete related job history records.",
    "natural_language": "Create a comprehensive stored procedure, which shall be named sp_proc5, that is designed to accept a specific country identifier along with a completely new state name. This procedure must first meticulously calculate the total number of locations situated within the specified country, then proceed to count all the departments associated with those particular locations, and finally, tally every single employee working within those identified departments. Should the final count of locations be determined to surpass the threshold of three, the procedure must systematically update the state province for each of those locations to the newly provided state name. Alternatively, if the location count is not greater than three but the subsequent count of departments exceeds ten, then the procedure must carefully delete all of those departments. In the event that neither of these initial conditions is met, the procedure should instead insert a brand new location record using the provided parameters. Following this primary logic, the procedure must then evaluate the employee count; if this count is found to be greater than twenty, it must generously increase the commission percentage for each of those employees. Conversely, if the employee count is twenty or fewer, the procedure must thoroughly delete all related job history records for those employees.",
    "id": 138
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named adjust_championship_data that accepts three parameters: p_province of type VARCHAR2, p_enrollment_min of type NUMBER, and p_championship_adjust of type NUMBER. The procedure begins by declaring two local variables: v_institution_count and v_total_championships, both of type NUMBER. It then performs a SELECT operation to count the number of institutions located in the province specified by p_province and having an enrollment number greater than or equal to p_enrollment_min, storing the result in v_institution_count. Next, it executes another SELECT operation to calculate the total number of championships by summing the NUMBER_OF_CHAMPIONSHIPS column from the CHAMPIONSHIP table, joining it with the INSTITUTION table on the INSTITUTION_ID column, and applying the same province and enrollment conditions, storing the result in v_total_championships. The procedure then checks if v_institution_count is greater than zero and v_total_championships is not null. If both conditions are met, it further checks if the absolute value of v_total_championships exceeds the value of p_championship_adjust. If this condition is true, it performs a DELETE operation on the CHAMPIONSHIP table, removing all records where the INSTITUTION_ID matches any institution in the specified province with enrollment greater than or equal to p_enrollment_min.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_championship_data(\n    p_province IN VARCHAR2,\n    p_enrollment_min IN NUMBER,\n    p_championship_adjust IN NUMBER\n)\nIS\n    v_institution_count NUMBER;\n    v_total_championships NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_institution_count FROM INSTITUTION WHERE PROVINCE = p_province AND ENROLLMENT >= p_enrollment_min;\n    \n    SELECT SUM(NUMBER_OF_CHAMPIONSHIPS) INTO v_total_championships \n    FROM CHAMPIONSHIP c\n    JOIN INSTITUTION i ON c.INSTITUTION_ID = i.INSTITUTION_ID\n    WHERE i.PROVINCE = p_province AND i.ENROLLMENT >= p_enrollment_min;\n    \n    IF v_institution_count > 0 AND v_total_championships IS NOT NULL THEN\n        IF ABS(v_total_championships) > p_championship_adjust THEN\n            DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID IN (\n                SELECT INSTITUTION_ID FROM INSTITUTION \n                WHERE PROVINCE = p_province AND ENROLLMENT >= p_enrollment_min\n            );\n        END IF;\n    END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_championship_data('BC', 30000, 5);\nEND;",
      "BEGIN\n  adjust_championship_data('AB', 25000, 10);\nEND;",
      "BEGIN\n  adjust_championship_data('BC', 40000, 2);\nEND;",
      "BEGIN\n  adjust_championship_data('AB', 20000, 0);\nEND;",
      "BEGIN\n  adjust_championship_data('BC', 10000, 15);\nEND;"
    ],
    "summary": "Create a stored procedure named adjust_championship_data that accepts a province, a minimum enrollment, and a championship adjustment number. Count institutions in the province meeting the enrollment minimum and sum their total championships. If institutions exist and the total championships exceed the adjustment number, delete championship records for those institutions.",
    "natural_language": "How can I create a stored procedure called adjust_championship_data that takes a province, a minimum enrollment, and a championship adjustment number as inputs, counts the institutions in that province that meet the enrollment minimum, sums their total championships, and then, if such institutions exist and the total championships exceed the adjustment number, deletes the championship records for those institutions?",
    "id": 139
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named validate_and_clean_records that accepts three input parameters: p_name_pattern of type VARCHAR2, p_founded_year of type NUMBER, and p_championship_limit of type NUMBER. The procedure begins by declaring two local variables, v_pattern_count and v_championship_exists, both of type NUMBER. It then performs a SELECT operation to count the number of rows in the INSTITUTION table where the NAME column contains the substring specified by p_name_pattern, using the LIKE operator with wildcard characters. The result of this count is stored in the v_pattern_count variable. If v_pattern_count is greater than zero, indicating that there are matching institutions, the procedure proceeds to perform another SELECT operation. This second query counts the number of rows in the CHAMPIONSHIP table, joined with the INSTITUTION table on the INSTITUTION_ID column, where the FOUNDED column in the INSTITUTION table matches the value of p_founded_year and the NUMBER_OF_CHAMPIONSHIPS column in the CHAMPIONSHIP table exceeds the value of p_championship_limit. The result of this count is stored in the v_championship_exists variable. If v_championship_exists is greater than zero, indicating that there are championships meeting the specified criteria, the procedure executes a DELETE operation on the CHAMPIONSHIP table to remove all rows where the INSTITUTION_ID matches any institution founded in the year specified by p_founded_year. The procedure concludes without any further actions or output.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_and_clean_records(\n    p_name_pattern IN VARCHAR2,\n    p_founded_year IN NUMBER,\n    p_championship_limit IN NUMBER\n)\nIS\n    v_pattern_count NUMBER;\n    v_championship_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_pattern_count FROM INSTITUTION WHERE NAME LIKE '%' || p_name_pattern || '%';\n    \n    IF v_pattern_count > 0 THEN\n        SELECT COUNT(*) INTO v_championship_exists FROM CHAMPIONSHIP c\n        JOIN INSTITUTION i ON c.INSTITUTION_ID = i.INSTITUTION_ID\n        WHERE i.FOUNDED = p_founded_year AND c.NUMBER_OF_CHAMPIONSHIPS > p_championship_limit;\n        \n        IF v_championship_exists > 0 THEN\n            DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID IN (\n                SELECT INSTITUTION_ID FROM INSTITUTION WHERE FOUNDED = p_founded_year\n            );\n        END IF;\n    END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  validate_and_clean_records('University', 1908, 0);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('Calgary', 1966, 1);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('Alberta', 1908, 0);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('British', 1966, 1);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('Columbia', 1908, 0);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named validate_and_clean_records that accepts a name pattern, a founded year, and a championship limit. Count institutions whose name matches the pattern. If matches exist, count championships for institutions founded in that year exceeding the limit. If such championships exist, delete all championship records for institutions founded in that year.",
    "natural_language": "Develop a stored procedure called validate_and_clean_records which is designed to receive three distinct input parameters: a specific pattern for matching names, a particular year of founding, and a defined numerical limit for championships. The procedure should first meticulously count all academic institutions whose official names correspond precisely to the provided textual pattern. Should any such matching institutions be found, it must then proceed to calculate, with careful attention, the total number of championship titles held exclusively by those institutions that were established in the exact founding year supplied, but only for those cases where the championship count surpasses the stipulated limit. Finally, if and only if there are championship records meeting these stringent criteria, the procedure must comprehensively and permanently delete every single championship entry associated with all institutions founded in that very same year.",
    "id": 140
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_old_requests` that performs a data manipulation operation. This procedure does not accept any input parameters and does not return any values. The core operation of this procedure is to delete rows from a table named `RESIDENTS_SERVICES`. The deletion is conditional, targeting rows where the value in the `DATE_REQUESTED` column, after being explicitly converted to a `DATE` data type, is older than a specific point in time. The conversion of `DATE_REQUESTED` is performed using the `TO_DATE` function, which interprets the string value in `DATE_REQUESTED` according to the format mask `'YYYY-MM-DD HH24:MI:SS'`. This format mask specifies that the year is represented by four digits, the month by two digits, the day by two digits, the hour in 24-hour format by two digits, the minute by two digits, and the second by two digits. The specific point in time used for comparison is calculated by subtracting 24 months from the current date. This calculation is achieved using the `ADD_MONTHS` function, which takes `CURRENT_DATE` (representing the current date and time of the database server) as its first argument and `-24` as its second argument, effectively moving the date back by two years. Therefore, any row in the `RESIDENTS_SERVICES` table where the `DATE_REQUESTED` is more than two years in the past, based on the current date, will be removed from the table.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_requests AS\nBEGIN\n   DELETE FROM RESIDENTS_SERVICES\n   WHERE TO_DATE(DATE_REQUESTED, 'YYYY-MM-DD HH24:MI:SS') < ADD_MONTHS(CURRENT_DATE, -24);\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n   delete_old_requests;\nEND;"
    ],
    "summary": "Create a stored procedure named delete_old_requests with no parameters that deletes rows from the RESIDENTS_SERVICES table where the DATE_REQUESTED column (converted from string using format 'YYYY-MM-DD HH24:MI:SS') is older than 24 months from the current date.",
    "natural_language": "Create procedure delete_old_requests to remove RESIDENTS_SERVICES rows where DATE_REQUESTED is over 24 months old.",
    "id": 141
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes three parameters: p_resident_id of type NUMBER, p_service_id of type NUMBER, and p_other_details of type VARCHAR2. This procedure updates the RESIDENTS_SERVICES table by setting the OTHER_DETAILS column to the value provided in the p_other_details parameter for the row where the RESIDENT_ID column matches the value of p_resident_id and the SERVICE_ID column matches the value of p_service_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_service_details(\n   p_resident_id NUMBER,\n   p_service_id NUMBER,\n   p_other_details VARCHAR2\n) AS\nBEGIN\n   UPDATE RESIDENTS_SERVICES\n   SET OTHER_DETAILS = p_other_details\n   WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = p_service_id;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  update_service_details(6, 49, 'Very Satisfied');\n  commit;\nEND;",
      "BEGIN\n  update_service_details(23, 41, 'Needs Follow-up');\n  commit;\nEND;",
      "BEGIN\n  update_service_details(28, 11, 'Completed Successfully');\n  commit;\nEND;",
      "BEGIN\n  update_service_details(6, 11, 'Details Updated');\n  commit;\nEND;",
      "BEGIN\n  update_service_details(23, 49, 'Unsatisfied - Issue Resolved');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure that accepts p_resident_id NUMBER, p_service_id NUMBER, and p_other_details VARCHAR2. Update the RESIDENTS_SERVICES table, setting OTHER_DETAILS to p_other_details where RESIDENT_ID equals p_resident_id and SERVICE_ID equals p_service_id.",
    "natural_language": "Develop a stored procedure that takes in three distinct parameters: a numeric identifier for the resident called p_resident_id, a separate numeric identifier for the service named p_service_id, and a descriptive text parameter labeled p_other_details of type VARCHAR2. This procedure should meticulously update the RESIDENTS_SERVICES table by specifically modifying the OTHER_DETAILS column, assigning it the value provided in p_other_details, but only for those precise records where the RESIDENT_ID column matches the given p_resident_id and, simultaneously, the SERVICE_ID column is exactly equal to the supplied p_service_id.",
    "id": 142
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_country_data` that accepts three input parameters: `p_country` of type `VARCHAR2`, `p_age_min` of type `NUMBER`, and `p_gender_flag` of type `VARCHAR2`. The `p_country` parameter is intended to specify a particular country for data processing. The `p_age_min` parameter represents a minimum age threshold. The `p_gender_flag` parameter is used to indicate a specific gender, typically 'T' for true (male) or 'F' for false (female).\n\nThe procedure begins by declaring three local variables: `v_avg_age` of type `NUMBER` to store the average age, `v_max_age` of type `NUMBER` to store the maximum age, and `v_count` of type `NUMBER` to store the count of records.\n\nNext, it executes a `SELECT` statement to retrieve aggregated data from the `PEOPLE` table. This `SELECT` statement calculates the average of the `AGE` column, the maximum value of the `AGE` column, and the total count of rows. These calculated values are then stored into the `v_avg_age`, `v_max_age`, and `v_count` local variables, respectively. The selection of rows for this aggregation is filtered by two conditions: the `COUNTRY` column must match the value provided in the `p_country` input parameter, and the `IS_MALE` column must match the value provided in the `p_gender_flag` input parameter.\n\nFollowing this, the procedure enters a conditional block (`IF v_count > 0 THEN`). This block checks if the `v_count` variable, which holds the number of records found in the previous `SELECT` operation, is greater than zero.\n\nIf `v_count` is greater than zero (meaning records matching the `p_country` and `p_gender_flag` criteria were found), the procedure performs two operations:\n1. It executes an `INSERT` statement into the `PEOPLE` table. A new row is inserted with the following values:\n    - `PEOPLE_ID`: This is determined by a subquery `(SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE)`, which finds the current maximum `PEOPLE_ID` in the `PEOPLE` table and increments it by one to generate a new unique ID.\n    - `NAME`: Set to the literal string 'Average Age Person'.\n    - `COUNTRY`: Set to the value of the `p_country` input parameter.\n    - `IS_MALE`: Set to the value of the `p_gender_flag` input parameter.\n    - `AGE`: Set to the rounded value of `v_avg_age` using the `ROUND()` function.\n2. It executes a `DELETE` statement on the `WEDDING` table. Rows are deleted from `WEDDING` where either of the following conditions is met:\n    - The `MALE_ID` column is present in a subquery result. This subquery selects `PEOPLE_ID` from the `PEOPLE` table where the `COUNTRY` column matches `p_country`, the `IS_MALE` column is 'T' (indicating male), and the `AGE` column is less than the `p_age_min` input parameter.\n    - The `FEMALE_ID` column is present in another subquery result. This subquery selects `PEOPLE_ID` from the `PEOPLE` table where the `COUNTRY` column matches `p_country`, the `IS_MALE` column is 'F' (indicating female), and the `AGE` column is less than the `p_age_min` input parameter.\n\nIf `v_count` is not greater than zero (meaning no records matching the `p_country` and `p_gender_flag` criteria were found), the procedure executes the `ELSE` block. In this block, it performs a single `INSERT` statement into the `PEOPLE` table. A new row is inserted with the following values:\n- `PEOPLE_ID`: This is determined by a subquery `(SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE)`, which finds the current maximum `PEOPLE_ID` in the `PEOPLE` table and increments it by one to generate a new unique ID.\n- `NAME`: Set to the literal string 'Default Person'.\n- `COUNTRY`: Set to the value of the `p_country` input parameter.\n- `IS_MALE`: Set to the value of the `p_gender_flag` input parameter.\n- `AGE`: Set to the value of the `p_age_min` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_country_data(p_country VARCHAR2, p_age_min NUMBER, p_gender_flag VARCHAR2)\nIS\n    v_avg_age NUMBER;\n    v_max_age NUMBER;\n    v_count NUMBER;\nBEGIN\n    SELECT AVG(AGE), MAX(AGE), COUNT(*) INTO v_avg_age, v_max_age, v_count\n    FROM PEOPLE\n    WHERE COUNTRY = p_country AND IS_MALE = p_gender_flag;\n    \n    IF v_count > 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Average Age Person', p_country, p_gender_flag, ROUND(v_avg_age));\n        \n        DELETE FROM WEDDING\n        WHERE MALE_ID IN (SELECT PEOPLE_ID FROM PEOPLE WHERE COUNTRY = p_country AND IS_MALE = 'T' AND AGE < p_age_min)\n        OR FEMALE_ID IN (SELECT PEOPLE_ID FROM PEOPLE WHERE COUNTRY = p_country AND IS_MALE = 'F' AND AGE < p_age_min);\n    ELSE\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Default Person', p_country, p_gender_flag, p_age_min);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  process_country_data('United States', 18, 'T');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('Canada', 21, 'F');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('Sweden', 25, 'T');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('United States', 30, 'F');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('Germany', 20, 'T');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named process_country_data that accepts p_country VARCHAR2, p_age_min NUMBER, and p_gender_flag VARCHAR2. Calculate the average age, maximum age, and record count from the PEOPLE table for the given country and gender. If records exist, insert a new person named 'Average Age Person' with the rounded average age, then delete from the WEDDING table where MALE_ID or FEMALE_ID corresponds to people from that country and gender whose age is below p_age_min. If no records exist, insert a 'Default Person' with age p_age_min.",
    "natural_language": "Write a stored procedure called process_country_data that takes p_country VARCHAR2, p_age_min NUMBER, and p_gender_flag VARCHAR2. For the specified country and gender, compute the average age, maximum age, and total record count from the PEOPLE table. If records are found, insert a new person named 'Average Age Person' using the rounded average age, and then remove entries from the WEDDING table where either MALE_ID or FEMALE_ID matches people from that country and gender who are younger than p_age_min. If no records are found, insert a 'Default Person' with the age set to p_age_min.",
    "id": 143
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_insert_resident_service that accepts three input parameters: p_resident_id of type NUMBER, p_service_id of type NUMBER, and p_date_requested of type VARCHAR2, and performs a MERGE operation into the RESIDENTS_SERVICES table, aliased as rs, using a single-row source data set constructed from the input parameters via a SELECT statement from the DUAL table, aliasing p_resident_id as resident_id, p_service_id as service_id, and p_date_requested as date_requested, with the merge condition checking for a match where the existing rs.RESIDENT_ID equals the source resident_id and the existing rs.SERVICE_ID equals the source service_id; when a matching row is found, the procedure updates the existing row's DATE_REQUESTED column with the value from the source date_requested; when no matching row is found, the procedure inserts a new row into RESIDENTS_SERVICES, populating the RESIDENT_ID, SERVICE_ID, and DATE_REQUESTED columns with the values from the source resident_id, service_id, and date_requested respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_insert_resident_service(\n    p_resident_id IN NUMBER,\n    p_service_id IN NUMBER,\n    p_date_requested IN VARCHAR2\n)\nIS\nBEGIN\n    MERGE INTO RESIDENTS_SERVICES rs\n    USING (SELECT p_resident_id AS resident_id, p_service_id AS service_id, p_date_requested AS date_requested FROM DUAL) src\n    ON (rs.RESIDENT_ID = src.resident_id AND rs.SERVICE_ID = src.service_id)\n    WHEN MATCHED THEN\n        UPDATE SET rs.DATE_REQUESTED = src.date_requested\n    WHEN NOT MATCHED THEN\n        INSERT (RESIDENT_ID, SERVICE_ID, DATE_REQUESTED)\n        VALUES (src.resident_id, src.service_id, src.date_requested);\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "SERVICES",
      "RESIDENTS_SERVICES",
      "THINGS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 6, p_service_id => 49, p_date_requested => '2023-01-15 10:00:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 23, p_service_id => 41, p_date_requested => '2023-02-20 14:30:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 28, p_service_id => 11, p_date_requested => '2023-03-01 09:00:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 6, p_service_id => 49, p_date_requested => '2023-04-10 11:00:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 10, p_service_id => 10, p_date_requested => '2023-05-05 16:00:00');\nEND;"
    ],
    "summary": "Create a stored procedure named proc_insert_resident_service that accepts p_resident_id NUMBER, p_service_id NUMBER, and p_date_requested VARCHAR2. Perform a MERGE into RESIDENTS_SERVICES using the input parameters as the source. When a row matches on RESIDENT_ID and SERVICE_ID, update DATE_REQUESTED. When no match is found, insert a new row with the provided values.",
    "natural_language": "Create proc_insert_resident_service with inputs p_resident_id NUMBER, p_service_id NUMBER, p_date_requested VARCHAR2. MERGE into RESIDENTS_SERVICES. Match on RESIDENT_ID and SERVICE_ID to update DATE_REQUESTED. If no match, insert new row.",
    "id": 144
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_delete_customer_event_notes that accepts three parameters: p_event_id of type NUMBER, p_service_type of type VARCHAR2, and p_deleted_count of type OUT NUMBER. The procedure performs a delete operation on the CUSTOMER_EVENT_NOTES table, specifically targeting rows where the CUSTOMER_EVENT_ID column matches the value of the p_event_id parameter and the SERVICE_TYPE_CODE column matches the value of the p_service_type parameter. After executing the delete operation, the procedure assigns the number of rows deleted to the p_deleted_count parameter using the SQL%ROWCOUNT attribute, which provides the count of rows affected by the most recent SQL statement executed within the session.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_delete_customer_event_notes(\n    p_event_id IN NUMBER,\n    p_service_type IN VARCHAR2,\n    p_deleted_count OUT NUMBER\n)\nIS\nBEGIN\n    DELETE FROM CUSTOMER_EVENT_NOTES\n    WHERE CUSTOMER_EVENT_ID = p_event_id\n    AND SERVICE_TYPE_CODE = p_service_type;\n    p_deleted_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "SERVICES",
      "RESIDENTS_SERVICES",
      "THINGS"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(70, 'Cleanning', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(160, 'Check', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(166, 'Moving Out', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(428, 'Cleanning', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(70, 'Check', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;"
    ],
    "summary": "Create a stored procedure named proc_delete_customer_event_notes that accepts p_event_id NUMBER, p_service_type VARCHAR2, and an OUT parameter p_deleted_count NUMBER. Delete rows from CUSTOMER_EVENT_NOTES where CUSTOMER_EVENT_ID equals p_event_id and SERVICE_TYPE_CODE equals p_service_type. Return the number of deleted rows in p_deleted_count.",
    "natural_language": "Please construct a stored procedure designated as `proc_delete_customer_event_notes`. This procedure shall accept two input parameters: `p_event_id` of type NUMBER and `p_service_type` of type VARCHAR2. Additionally, it must include an OUT parameter named `p_deleted_count` of type NUMBER. The procedure's function is to remove all records from the `CUSTOMER_EVENT_NOTES` table where the `CUSTOMER_EVENT_ID` column matches the provided `p_event_id` and the `SERVICE_TYPE_CODE` column matches the provided `p_service_type`. Upon completion, the procedure must assign the total count of rows deleted to the `p_deleted_count` parameter.",
    "id": 145
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_update_service_details` that is designed to modify existing service records within a database table. This procedure accepts three parameters: `p_service_id`, an `IN` parameter of type `NUMBER`, which represents the unique identifier of the service whose details are to be updated; `p_new_details`, an `IN` parameter of type `VARCHAR2`, which provides the new textual description or details that will replace the current details for the specified service; and `p_rows_updated`, an `OUT` parameter of type `NUMBER`, which will return the count of rows that were successfully modified by the update operation. The core operation performed by this procedure is an `UPDATE` statement targeting the `SERVICES` table. Within this `UPDATE` statement, the `SERVICE_DETAILS` column is set to the value provided by the `p_new_details` parameter. This update is conditionally applied, meaning it only affects rows where the value in the `SERVICE_ID` column matches the value passed in the `p_service_id` parameter. Following the execution of the `UPDATE` statement, the procedure assigns the number of rows affected by the preceding `UPDATE` operation to the `p_rows_updated` `OUT` parameter. This count is obtained using the `SQL%ROWCOUNT` SQL attribute, which specifically returns the number of rows processed by the most recently executed SQL statement in the current session.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_update_service_details(\n    p_service_id IN NUMBER,\n    p_new_details IN VARCHAR2,\n    p_rows_updated OUT NUMBER\n)\nIS\nBEGIN\n    UPDATE SERVICES\n    SET SERVICE_DETAILS = p_new_details\n    WHERE SERVICE_ID = p_service_id;\n    p_rows_updated := SQL%ROWCOUNT;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "SERVICES",
      "RESIDENTS_SERVICES",
      "THINGS"
    ],
    "call_sqls": [
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 10, p_new_details => 'Updated details for service 10', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 11, p_new_details => 'New description for service 11', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 13, p_new_details => 'Service 13 details changed', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 49, p_new_details => 'Details for service 49 updated', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 41, p_new_details => 'Service 41 details modified', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_update_service_details` that updates the SERVICE_DETAILS column in the SERVICES table for a given SERVICE_ID. It takes an IN parameter for the service ID, an IN parameter for the new details, and an OUT parameter that returns the number of rows updated.",
    "natural_language": "Hey, can you whip up a stored procedure called `proc_update_service_details`? It's gotta update the SERVICE_DETAILS field in the SERVICES table whenever we give it a specific SERVICE_ID. We'll need to pass in the service ID and the new details, and it should spit back out how many rows it actually changed.",
    "id": 146
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ManageStudentCourseEnrollment` that accepts two input parameters: `p_student_id` of data type `NUMBER`, representing the unique identifier for a student, and `p_course_id` of data type `NUMBER`, representing the unique identifier for a course.\n\nThe procedure begins by declaring three local variables of data type `NUMBER`: `v_student_exists`, `v_course_exists`, and `v_enrollment_exists`, which will be used to store counts indicating the existence of a student, a course, and a student's enrollment in a course, respectively. It also declares a local variable `v_registration_id` of data type `NUMBER` to hold a generated registration identifier.\n\nFirst, the procedure executes a `SELECT COUNT(*)` statement to determine if a student with the `STUDENT_ID` matching the input parameter `p_student_id` exists in the `STUDENTS` table. The result of this count is stored in the `v_student_exists` variable.\n\nNext, it executes another `SELECT COUNT(*)` statement to determine if a course with the `COURSE_ID` matching the input parameter `p_course_id` exists in the `COURSES` table. The result of this count is stored in the `v_course_exists` variable.\n\nSubsequently, it executes a third `SELECT COUNT(*)` statement to determine if an existing enrollment record exists in the `STUDENT_COURSE_ENROLMENT` table for the student identified by `p_student_id` and the course identified by `p_course_id`. The result of this count is stored in the `v_enrollment_exists` variable.\n\nFollowing these checks, the procedure enters a conditional logic block:\n\n1.  **If `v_student_exists` is equal to `0` (meaning the student does not exist):** The procedure immediately terminates using a `RETURN` statement, performing no further actions.\n\n2.  **Else if `v_course_exists` is equal to `0` (meaning the course does not exist):** The procedure immediately terminates using a `RETURN` statement, performing no further actions.\n\n3.  **Else if `v_enrollment_exists` is equal to `0` (meaning the student is not currently enrolled in the specified course):**\n    *   The procedure calculates a new `REGISTRATION_ID` by executing a `SELECT NVL(MAX(REGISTRATION_ID), 0) + 1` statement from the `STUDENT_COURSE_ENROLMENT` table. This statement retrieves the maximum existing `REGISTRATION_ID`, replaces `NULL` with `0` if no records exist, and then increments the result by `1` to generate a unique new identifier. This calculated value is stored in the `v_registration_id` variable.\n    *   An `INSERT` statement is then executed to add a new record into the `STUDENT_COURSE_ENROLMENT` table. The new record includes the generated `v_registration_id` for the `REGISTRATION_ID` column, the input `p_student_id` for the `STUDENT_ID` column, the input `p_course_id` for the `COURSE_ID` column, and the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')` for the `DATE_OF_ENROLMENT` column.\n\n4.  **Else (meaning `v_student_exists` is not `0`, `v_course_exists` is not `0`, and `v_enrollment_exists` is not `0`, indicating an existing enrollment):**\n    *   A `DELETE` statement is executed to remove the existing enrollment record from the `STUDENT_COURSE_ENROLMENT` table where the `STUDENT_ID` matches `p_student_id` and the `COURSE_ID` matches `p_course_id`.\n\nFinally, the procedure concludes its execution.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageStudentCourseEnrollment(\n    p_student_id NUMBER,\n    p_course_id NUMBER\n) AS\n    v_student_exists NUMBER;\n    v_course_exists NUMBER;\n    v_enrollment_exists NUMBER;\n    v_registration_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM STUDENTS WHERE STUDENT_ID = p_student_id;\n    SELECT COUNT(*) INTO v_course_exists FROM COURSES WHERE COURSE_ID = p_course_id;\n    SELECT COUNT(*) INTO v_enrollment_exists FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n\n    IF v_student_exists = 0 THEN\n        RETURN;\n    ELSIF v_course_exists = 0 THEN\n        RETURN;\n    ELSIF v_enrollment_exists = 0 THEN\n        SELECT NVL(MAX(REGISTRATION_ID), 0) + 1 INTO v_registration_id FROM STUDENT_COURSE_ENROLMENT;\n        INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT)\n        VALUES (v_registration_id, p_student_id, p_course_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSE\n        DELETE FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  ManageStudentCourseEnrollment(1, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(2, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(3, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(2, 3);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `ManageStudentCourseEnrollment` that toggles a student's enrollment in a course. It accepts a student ID and a course ID. First, check if the student and course exist. If either does not exist, exit. If the student is not enrolled, generate a new registration ID and insert a new enrollment record with the current timestamp. If the student is already enrolled, delete the existing enrollment record.",
    "natural_language": "How can I create a stored procedure named `ManageStudentCourseEnrollment` that toggles a student's enrollment in a course? The procedure should accept a student ID and a course ID. First, how do I check if the student and course exist, and exit if either does not? If the student is not enrolled, how should I generate a new registration ID and insert a new enrollment record with the current timestamp? Conversely, if the student is already enrolled, how do I delete the existing enrollment record?",
    "id": 147
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateStudentCourseCompletion that accepts two parameters: p_student_id of type NUMBER, representing the unique identifier of a student, and p_course_id of type NUMBER, representing the unique identifier of a course. The procedure first declares a local variable v_enrollment_exists of type NUMBER to store the count of enrollments for the specified student and course, and another local variable v_completion_date of type VARCHAR2(255) to store the date of enrollment. The procedure begins by executing a SELECT statement to count the number of records in the STUDENT_COURSE_ENROLMENT table where the STUDENT_ID column matches p_student_id and the COURSE_ID column matches p_course_id, storing the result in v_enrollment_exists. If v_enrollment_exists equals 0, indicating no enrollment exists for the given student and course, the procedure terminates immediately using the RETURN statement. If v_enrollment_exists is not 0, the procedure proceeds to execute another SELECT statement to retrieve the DATE_OF_ENROLMENT from the STUDENT_COURSE_ENROLMENT table for the specified student and course, storing the result in v_completion_date. Subsequently, the procedure performs an UPDATE operation on the STUDENT_COURSE_ENROLMENT table, setting the DATE_OF_COMPLETION column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function applied to SYSDATE, for the row where STUDENT_ID matches p_student_id and COURSE_ID matches p_course_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateStudentCourseCompletion(\n    p_student_id NUMBER,\n    p_course_id NUMBER\n) AS\n    v_enrollment_exists NUMBER;\n    v_completion_date VARCHAR2(255);\nBEGIN\n    SELECT COUNT(*) INTO v_enrollment_exists FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n\n    IF v_enrollment_exists = 0 THEN\n        RETURN;\n    ELSE\n        SELECT DATE_OF_ENROLMENT INTO v_completion_date FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n        UPDATE STUDENT_COURSE_ENROLMENT\n        SET DATE_OF_COMPLETION = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateStudentCourseCompletion(11, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(15, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(10, 8);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(11, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(15, 2);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `UpdateStudentCourseCompletion` that sets the completion date for a student's course enrollment. It accepts a student ID and a course ID. First, check if the enrollment exists. If not, exit. If it exists, retrieve the enrollment date and update the enrollment record to set the completion date to the current system timestamp.",
    "natural_language": "Hey, can you whip up a stored procedure called `UpdateStudentCourseCompletion`? It needs to set the \"done\" date for when a student finishes a course. You'll give it a student ID and a course ID. First off, check if that student is even enrolled in that course. If they're not, just bail out. If they are, grab the date they started, and then update their record to mark it as completed right now.",
    "id": 148
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named RegisterNewStudent that accepts five parameters: p_login_name of type VARCHAR2 representing the login name of the student, p_password of type VARCHAR2 representing the student's password, p_personal_name of type VARCHAR2 representing the student's personal name, p_middle_name of type VARCHAR2 representing the student's middle name, and p_family_name of type VARCHAR2 representing the student's family name. The procedure begins by declaring a local variable v_student_id of type NUMBER to store the new student ID. It then executes a SELECT statement to retrieve the maximum value of the STUDENT_ID column from the STUDENTS table, using the NVL function to handle null values by defaulting to 0 if no rows exist, and adds 1 to this maximum value to generate a new unique student ID, which is stored in v_student_id. Following this, the procedure performs an INSERT operation into the STUDENTS table, specifying the columns STUDENT_ID, DATE_OF_REGISTRATION, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, and FAMILY_NAME. The values inserted are the newly generated v_student_id, the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function, and the values of the parameters p_login_name, p_password, p_personal_name, p_middle_name, and p_family_name, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE RegisterNewStudent(\n    p_login_name VARCHAR2,\n    p_password VARCHAR2,\n    p_personal_name VARCHAR2,\n    p_middle_name VARCHAR2,\n    p_family_name VARCHAR2\n) AS\n    v_student_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(STUDENT_ID), 0) + 1 INTO v_student_id FROM STUDENTS;\n\n    INSERT INTO STUDENTS (STUDENT_ID, DATE_OF_REGISTRATION, LOGIN_NAME, PASSWORD, PERSONAL_NAME, MIDDLE_NAME, FAMILY_NAME)\n    VALUES (v_student_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), p_login_name, p_password, p_personal_name, p_middle_name, p_family_name);\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  RegisterNewStudent('johndoe', 'password123', 'John', 'A.', 'Doe');\nEND;",
      "BEGIN\n  RegisterNewStudent('janedoe', 'securepass', 'Jane', 'B.', 'Doe');\nEND;",
      "BEGIN\n  RegisterNewStudent('peterpan', 'nevergrowup', 'Peter', NULL, 'Pan');\nEND;",
      "BEGIN\n  RegisterNewStudent('aliceinw', 'wonderland', 'Alice', 'L.', 'Kingsleigh');\nEND;",
      "BEGIN\n  RegisterNewStudent('bobtheb', 'builder', 'Bob', NULL, 'The Builder');\nEND;"
    ],
    "summary": "Create a stored procedure named `RegisterNewStudent` that inserts a new student record. It accepts parameters for login name, password, personal name, middle name, and family name. Generate a new student ID by incrementing the maximum existing ID. Insert the new record with the generated ID, the current timestamp for registration date, and the provided parameter values.",
    "natural_language": "Write a stored procedure called `RegisterNewStudent` to insert a new student. Take the login name, password, personal name, middle name, and family name as parameters. Generate the new student ID by adding one to the highest current ID. Insert the new record using this generated ID, the current time for the registration date, and the given parameter values.",
    "id": 149
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateCourseDetails that accepts three parameters: p_course_id of type NUMBER, p_course_name of type VARCHAR2, and p_course_description of type VARCHAR2. The procedure first declares a local variable v_course_exists of type NUMBER. It then executes a SELECT statement to count the number of rows in the COURSES table where the COURSE_ID column matches the value of the p_course_id parameter, storing the result in the v_course_exists variable. The procedure checks if v_course_exists equals 0, indicating that no course with the specified COURSE_ID exists in the COURSES table. If this condition is true, the procedure terminates immediately using the RETURN statement. If the condition is false, meaning a course with the specified COURSE_ID does exist, the procedure proceeds to execute an UPDATE statement on the COURSES table. This UPDATE statement sets the COURSE_NAME column to the value of the p_course_name parameter and the COURSE_DESCRIPTION column to the value of the p_course_description parameter for the row where the COURSE_ID column matches the value of the p_course_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCourseDetails(\n    p_course_id NUMBER,\n    p_course_name VARCHAR2,\n    p_course_description VARCHAR2\n) AS\n    v_course_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_course_exists FROM COURSES WHERE COURSE_ID = p_course_id;\n\n    IF v_course_exists = 0 THEN\n        RETURN;\n    ELSE\n        UPDATE COURSES\n        SET COURSE_NAME = p_course_name, COURSE_DESCRIPTION = p_course_description\n        WHERE COURSE_ID = p_course_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCourseDetails(1, 'Database Fundamentals', 'Introduction to database concepts and SQL');\nEND;",
      "BEGIN\n  UpdateCourseDetails(2, 'Advanced Database Systems', 'Deep dive into database optimization and administration');\nEND;",
      "BEGIN\n  UpdateCourseDetails(3, 'Operating Systems Internals', 'Core concepts of operating system design and implementation');\nEND;",
      "BEGIN\n  UpdateCourseDetails(1, 'Database Management 101', 'Updated course covering basic to intermediate database topics');\nEND;",
      "BEGIN\n  UpdateCourseDetails(999, 'Non-existent Course', 'This should not update anything');\nEND;"
    ],
    "summary": "Create a stored procedure named `UpdateCourseDetails` that updates the name and description of a course. It accepts a course ID, a new course name, and a new description. First, check if a course with the given ID exists. If not, exit. If it exists, update the COURSE_NAME and COURSE_DESCRIPTION columns for that course.",
    "natural_language": "Create procedure UpdateCourseDetails to update a course's name and description. Check if the course ID exists first. If not, exit. If yes, update COURSE_NAME and COURSE_DESCRIPTION for that ID.",
    "id": 150
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteStudent that accepts a single parameter p_student_id of type NUMBER, which represents the unique identifier of a student. The procedure begins by declaring a local variable v_student_exists of type NUMBER to store the count of students with the specified student ID. It executes a SELECT statement to count the number of records in the STUDENTS table where the STUDENT_ID column matches the value of p_student_id, storing the result in v_student_exists. The procedure then evaluates whether v_student_exists equals 0 using an IF statement. If v_student_exists is 0, indicating that no student with the given ID exists in the STUDENTS table, the procedure terminates immediately with a RETURN statement. If v_student_exists is not 0, meaning a student with the specified ID exists, the procedure proceeds to execute a DELETE statement on the STUDENT_COURSE_ENROLMENT table, removing all records where the STUDENT_ID column matches p_student_id. Following this, another DELETE statement is executed on the STUDENTS table to remove the record where the STUDENT_ID column matches p_student_id. The procedure concludes after these operations, having ensured that both the student and their course enrolments are deleted from the respective tables.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteStudent(\n    p_student_id NUMBER\n) AS\n    v_student_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM STUDENTS WHERE STUDENT_ID = p_student_id;\n\n    IF v_student_exists = 0 THEN\n        RETURN;\n    ELSE\n        DELETE FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id;\n        DELETE FROM STUDENTS WHERE STUDENT_ID = p_student_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteStudent(1);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(2);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(3);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(11);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(15);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteStudent that accepts a student ID. Check if the student exists. If not, exit. If they exist, first delete their enrolments from STUDENT_COURSE_ENROLMENT, then delete the student from the STUDENTS table.",
    "natural_language": "Create a stored procedure called DeleteStudent that takes a student ID. See if that student is around. If you can't find them, just stop. If they are there, first get rid of any of their course sign-ups from the STUDENT_COURSE_ENROLMENT table, and then remove the student record from the STUDENTS table.",
    "id": 151
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_employee_job_history that accepts three input parameters: p_employee_id of type NUMBER to identify a specific employee, p_new_job_id of type VARCHAR2 representing the new job identifier to assign, and p_effective_date of type VARCHAR2 indicating the date the change becomes effective. The procedure first queries the jobs table to count the number of rows where the job_id column matches the input parameter p_new_job_id, storing the result in a local variable v_job_exists. If the count in v_job_exists equals zero, indicating the new job identifier does not exist in the jobs table, the procedure terminates immediately without performing any further actions. If the job exists, the procedure then selects from the employees table the current job_id and department_id columns for the row where the employee_id column equals the input parameter p_employee_id, storing these values into local variables v_current_job and v_current_dept respectively. Next, the procedure inserts a new record into the job_history table, populating the employee_id column with the input p_employee_id, both the start_date and end_date columns with the input p_effective_date, the job_id column with the value from v_current_job, and the department_id column with the value from v_current_dept. Finally, the procedure updates the employees table, setting the job_id column to the input parameter p_new_job_id for the row where the employee_id column matches the input p_employee_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_employee_job_history(\n    p_employee_id IN NUMBER,\n    p_new_job_id IN VARCHAR2,\n    p_effective_date IN VARCHAR2\n) IS\n    v_current_job VARCHAR2(255);\n    v_current_dept NUMBER;\n    v_job_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_job_exists\n    FROM jobs\n    WHERE job_id = p_new_job_id;\n    \n    IF v_job_exists = 0 THEN\n        RETURN;\n    END IF;\n    \n    SELECT job_id, department_id\n    INTO v_current_job, v_current_dept\n    FROM employees\n    WHERE employee_id = p_employee_id;\n    \n    INSERT INTO job_history (employee_id, start_date, end_date, job_id, department_id)\n    VALUES (p_employee_id, p_effective_date, p_effective_date, v_current_job, v_current_dept);\n    \n    UPDATE employees\n    SET job_id = p_new_job_id\n    WHERE employee_id = p_employee_id;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  update_employee_job_history(p_employee_id => 100, p_new_job_id => 'AD_VP', p_effective_date => '2023-01-01');\n  commit;\nEND;",
      "BEGIN\n  update_employee_job_history(p_employee_id => 101, p_new_job_id => 'AD_PRES', p_effective_date => '2023-02-15');\n  commit;\nEND;",
      "BEGIN\n  update_employee_job_history(p_employee_id => 102, p_new_job_id => 'AD_ASST', p_effective_date => '2023-03-10');\n  commit;\nEND;",
      "BEGIN\n  update_employee_job_history(p_employee_id => 100, p_new_job_id => 'AD_ASST', p_effective_date => '2023-04-20');\n  commit;\nEND;",
      "BEGIN\n  update_employee_job_history(p_employee_id => 101, p_new_job_id => 'AD_VP', p_effective_date => '2023-05-05');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named update_employee_job_history that accepts an employee ID, a new job ID, and an effective date. Verify the new job exists. If not, exit. If it exists, get the employee's current job and department. Insert a record into job_history with the current details and the effective date for both start and end. Then update the employee's job to the new one.",
    "natural_language": "Update the employee's job history by creating a stored procedure called update_employee_job_history. This procedure must take an employee ID, a new job ID, and an effective date. First, check if the new job exists and exit if it does not. If the job exists, retrieve the employee's current job and department. Then, insert a record into the job_history table using the current details, setting the effective date for both the start and end dates. Finally, update the employee's job to the new one.",
    "id": 152
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_department_restructure that accepts three input parameters: a numeric parameter p_old_dept_id representing the source department identifier, a numeric parameter p_new_dept_id representing the target department identifier, and a string parameter p_cutoff_date representing a specific date boundary. The procedure begins by declaring a cursor named emp_cursor that selects the employee_id and job_id columns from the employees table for all rows where the department_id column matches the p_old_dept_id parameter and the hire_date column is earlier than the p_cutoff_date parameter. It then declares a record variable v_emp_record based on the row structure of this cursor. The procedure opens the cursor and enters a loop, fetching each row from the cursor into the v_emp_record variable. The loop continues until no more rows are found in the cursor. For each fetched record, the procedure performs two operations: first, it inserts a new row into the job_history table, populating the employee_id column with the value from v_emp_record.employee_id, the start_date and end_date columns both with the p_cutoff_date parameter value, the job_id column with the value from v_emp_record.job_id, and the department_id column with the p_old_dept_id parameter value; second, it updates the employees table, setting the department_id column to the p_new_dept_id parameter value for the row where the employee_id column matches v_emp_record.employee_id. After processing all cursor rows, the procedure closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_department_restructure(\n    p_old_dept_id IN NUMBER,\n    p_new_dept_id IN NUMBER,\n    p_cutoff_date IN VARCHAR2\n) IS\n    CURSOR emp_cursor IS\n        SELECT employee_id, job_id\n        FROM employees\n        WHERE department_id = p_old_dept_id\n        AND hire_date < p_cutoff_date;\n    \n    v_emp_record emp_cursor%ROWTYPE;\nBEGIN\n    OPEN emp_cursor;\n    LOOP\n        FETCH emp_cursor INTO v_emp_record;\n        EXIT WHEN emp_cursor%NOTFOUND;\n        \n        INSERT INTO job_history (employee_id, start_date, end_date, job_id, department_id)\n        VALUES (v_emp_record.employee_id, p_cutoff_date, p_cutoff_date, v_emp_record.job_id, p_old_dept_id);\n        \n        UPDATE employees\n        SET department_id = p_new_dept_id\n        WHERE employee_id = v_emp_record.employee_id;\n    END LOOP;\n    CLOSE emp_cursor;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  process_department_restructure(90, 100, '2024-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(60, 80, '2023-06-30');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(50, 40, '2024-03-15');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(30, 10, '2022-12-31');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(20, 30, '2024-05-20');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named process_department_restructure that accepts an old department ID, a new department ID, and a cutoff date. For each employee in the old department hired before the cutoff date, insert a record into job_history with the cutoff date and their current job, then update their department to the new one.",
    "natural_language": "Please construct a stored procedure designated as 'process_department_restructure'. This procedure shall accept three parameters: an old department identifier, a new department identifier, and a specified cutoff date. For every employee currently assigned to the old department whose hire date precedes the provided cutoff date, the procedure must perform the following operations in sequence: first, insert a corresponding record into the 'job_history' table, documenting the cutoff date and the employee's present job details; subsequently, update the employee's department assignment to the new department identifier.",
    "id": 153
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named add_pet_for_student that accepts three input parameters: a numeric parameter p_stuid representing a student identifier, a string parameter p_pettype representing the type of pet, and a numeric parameter p_pet_age representing the age of the pet. The procedure first declares a local numeric variable v_new_petid. It then performs a SELECT query on the pets table to calculate the next available pet identifier by taking the maximum existing value from the petid column and incrementing it by one, storing the result into the variable v_new_petid. Next, the procedure executes an INSERT statement into the pets table, specifying values for four columns: the petid column is set to the calculated v_new_petid, the pettype column is set to the input parameter p_pettype, the pet_age column is set to the input parameter p_pet_age, and the weight column is calculated as the product of the input parameter p_pet_age multiplied by four. Following this, the procedure executes a second INSERT statement into the has_pet table, inserting a new record where the stuid column is set to the input parameter p_stuid and the petid column is set to the newly generated v_new_petid.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_pet_for_student(p_stuid IN NUMBER, p_pettype IN VARCHAR2, p_pet_age IN NUMBER)\nIS\n    v_new_petid NUMBER;\nBEGIN\n    SELECT MAX(petid) + 1 INTO v_new_petid FROM pets;\n    \n    INSERT INTO pets (petid, pettype, pet_age, weight) VALUES (v_new_petid, p_pettype, p_pet_age, p_pet_age * 4);\n    INSERT INTO has_pet (stuid, petid) VALUES (p_stuid, v_new_petid);\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  add_pet_for_student(1001, 'dog', 3);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1002, 'cat', 2);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1001, 'rabbit', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1002, 'hamster', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1001, 'bird', 4);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named add_pet_for_student that accepts a student ID, pet type, and pet age. Generate a new pet ID by incrementing the maximum existing ID. Insert a new pet with the generated ID, type, age, and a weight calculated as age * 4. Then insert a record into has_pet linking the student and the new pet.",
    "natural_language": "Create procedure add_pet_for_student with student ID, pet type, and age. Generate new pet ID, insert pet (ID, type, age, weight as age*4), then link to student in has_pet.",
    "id": 154
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_pet_age` that accepts three input parameters: `p_petid` of type `NUMBER`, representing the unique identifier of a pet; `p_new_age` of type `NUMBER`, representing the proposed new age for the pet; and `p_stuid` of type `NUMBER`, representing the unique identifier of a student. The procedure first declares a local variable `v_current_age` of type `NUMBER` to temporarily store the pet's current age. It then performs a `SELECT` operation to retrieve the value from the `pet_age` column of the `pets` table, specifically for the row where the `petid` column matches the value provided in the `p_petid` input parameter, and stores this retrieved value into the `v_current_age` variable. Following this, the procedure evaluates a conditional `IF` statement: if the value stored in `v_current_age` is strictly less than the value provided in the `p_new_age` input parameter, then an `UPDATE` operation is executed on the `pets` table, setting the `pet_age` column to the value of `p_new_age` for the row where the `petid` column matches the value of `p_petid`. Otherwise, if `v_current_age` is not less than `p_new_age` (i.e., `v_current_age` is greater than or equal to `p_new_age`), a `DELETE` operation is performed on the `has_pet` table, removing the row where both the `petid` column matches the value of `p_petid` and the `stuid` column matches the value of `p_stuid`.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_pet_age(p_petid IN NUMBER, p_new_age IN NUMBER, p_stuid IN NUMBER)\nIS\n    v_current_age NUMBER;\nBEGIN\n    SELECT pet_age INTO v_current_age FROM pets WHERE petid = p_petid;\n    \n    IF v_current_age < p_new_age THEN\n        UPDATE pets SET pet_age = p_new_age WHERE petid = p_petid;\n    ELSE\n        DELETE FROM has_pet WHERE petid = p_petid AND stuid = p_stuid;\n    END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  update_pet_age(2001, 4, 1001);\nEND;",
      "BEGIN\n  update_pet_age(2002, 5, 1002);\nEND;",
      "BEGIN\n  update_pet_age(2003, 1, 1001);\nEND;",
      "BEGIN\n  update_pet_age(2001, 2, 1001);\nEND;",
      "BEGIN\n  update_pet_age(2002, 3, 1002);\nEND;"
    ],
    "summary": "Create a stored procedure named update_pet_age that accepts a pet ID, a new age, and a student ID. Get the pet's current age. If the new age is greater than the current age, update the pet's age. Otherwise, delete the link between the student and the pet from the has_pet table.",
    "natural_language": "How can I create a stored procedure called update_pet_age that takes a pet ID, a new age, and a student ID, retrieves the pet's current age, updates the age if the new age is higher, and otherwise removes the student-pet link from the has_pet table?",
    "id": 155
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named delete_student_pet that accepts three parameters: p_stuid of type NUMBER, p_petid of type NUMBER, and p_pettype of type VARCHAR2. The procedure performs two delete operations. First, it deletes rows from the has_pet table where the stuid column matches the value of p_stuid and the petid column matches the value of p_petid. Second, it deletes rows from the pets table where the petid column matches the value of p_petid and the pettype column matches the value of p_pettype.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_student_pet(p_stuid IN NUMBER, p_petid IN NUMBER, p_pettype IN VARCHAR2)\nIS\nBEGIN\n    DELETE FROM has_pet WHERE stuid = p_stuid AND petid = p_petid;\n    DELETE FROM pets WHERE petid = p_petid AND pettype = p_pettype;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  delete_student_pet(1001, 2001, 'cat');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1002, 2002, 'dog');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1001, 2003, 'cat');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1002, 2001, 'dog');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1001, 2002, 'cat');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named DELETE_STUDENT_PET that accepts parameters p_stuid (NUMBER), p_petid (NUMBER), and p_pettype (VARCHAR2). Delete from the HAS_PET table where STUID matches p_stuid and PETID matches p_petid. Then delete from the PETS table where PETID matches p_petid and PETTYPE matches p_pettype.",
    "natural_language": "How can I create a stored procedure named DELETE_STUDENT_PET that takes p_stuid (NUMBER), p_petid (NUMBER), and p_pettype (VARCHAR2) as parameters, so that it first deletes records from the HAS_PET table where STUID equals p_stuid and PETID equals p_petid, and then deletes from the PETS table where PETID equals p_petid and PETTYPE equals p_pettype?",
    "id": 156
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named TRANSFER_PET_OWNERSHIP that accepts three input parameters: p_old_stuid of type NUMBER, which represents the original student identifier from whom pet ownership is being transferred; p_new_stuid of type NUMBER, which represents the new student identifier to whom pet ownership is being assigned; and p_petid of type NUMBER, which identifies the specific pet whose ownership is being changed. The procedure performs a single UPDATE operation on the HAS_PET table. It modifies the STUID column, setting its value to the provided p_new_stuid parameter, but only for rows that satisfy two conditions in the WHERE clause: the existing STUID column value must exactly equal the p_old_stuid parameter, and the PETID column value must exactly equal the p_petid parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_pet_ownership(p_old_stuid IN NUMBER, p_new_stuid IN NUMBER, p_petid IN NUMBER)\nIS\nBEGIN\n    UPDATE has_pet SET stuid = p_new_stuid WHERE stuid = p_old_stuid AND petid = p_petid;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  transfer_pet_ownership(1001, 1002, 2001);\nEND;",
      "BEGIN\n  transfer_pet_ownership(1002, 1001, 2002);\nEND;",
      "BEGIN\n  transfer_pet_ownership(1001, 1002, 2003);\nEND;",
      "BEGIN\n  transfer_pet_ownership(1002, 1001, 2001);\nEND;",
      "BEGIN\n  transfer_pet_ownership(1001, 1001, 2002);\nEND;"
    ],
    "summary": "Create a stored procedure named TRANSFER_PET_OWNERSHIP with parameters p_old_stuid (NUMBER), p_new_stuid (NUMBER), and p_petid (NUMBER). Update the HAS_PET table, setting STUID to p_new_stuid where STUID equals p_old_stuid and PETID equals p_petid.",
    "natural_language": "Create a stored procedure called TRANSFER_PET_OWNERSHIP that takes p_old_stuid, p_new_stuid, and p_petid as NUMBER parameters. Update the HAS_PET table to set the STUID to p_new_stuid for the record where STUID matches p_old_stuid and PETID matches p_petid.",
    "id": 157
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `adjust_pet_weight` that accepts three input parameters: `p_petid` of type `NUMBER`, `p_weight_factor` of type `NUMBER`, and `p_stuid` of type `NUMBER`. The procedure first declares a local variable `v_current_weight` of type `NUMBER` to temporarily store a pet's current weight. It then executes a `SELECT` statement to retrieve the `weight` column value from the `pets` table for the row where the `petid` column matches the value provided in the `p_petid` input parameter. The retrieved `weight` value is then stored into the `v_current_weight` variable. Following this, the procedure evaluates a conditional `IF` statement. The condition checks if the product of `v_current_weight` and `p_weight_factor` is greater than the numeric literal `20`. If this condition evaluates to `TRUE`, the procedure executes an `UPDATE` statement on the `pets` table. This `UPDATE` statement sets the `weight` column to the calculated value of `v_current_weight` multiplied by `p_weight_factor` for the row where the `petid` column matches the value of `p_petid`. If the initial `IF` condition evaluates to `FALSE` (meaning `v_current_weight * p_weight_factor` is less than or equal to `20`), the procedure executes a `DELETE` statement. This `DELETE` statement removes rows from the `has_pet` table where the `petid` column matches the value of `p_petid` AND the `stuid` column matches the value of `p_stuid`.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_pet_weight(p_petid IN NUMBER, p_weight_factor IN NUMBER, p_stuid IN NUMBER)\nIS\n    v_current_weight NUMBER;\nBEGIN\n    SELECT weight INTO v_current_weight FROM pets WHERE petid = p_petid;\n    \n    IF v_current_weight * p_weight_factor > 20 THEN\n        UPDATE pets SET weight = v_current_weight * p_weight_factor WHERE petid = p_petid;\n    ELSE\n        DELETE FROM has_pet WHERE petid = p_petid AND stuid = p_stuid;\n    END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_pet_weight(2001, 1.5, 1001);\n  commit;\nEND;",
      "BEGIN\n  adjust_pet_weight(2002, 1.2, 1002);\n  commit;\nEND;",
      "BEGIN\n  adjust_pet_weight(2003, 2.0, 1001);\n  commit;\nEND;",
      "BEGIN\n  adjust_pet_weight(2001, 0.8, 1002);\n  commit;\nEND;",
      "BEGIN\n  adjust_pet_weight(2002, 1.1, 1001);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ADJUST_PET_WEIGHT with parameters p_petid (NUMBER), p_weight_factor (NUMBER), and p_stuid (NUMBER). Retrieve the current weight from PETS where PETID equals p_petid. If the current weight multiplied by p_weight_factor is greater than 20, update the PETS table with the new weight for that petid. Otherwise, delete from HAS_PET where PETID equals p_petid and STUID equals p_stuid.",
    "natural_language": "Make a stored procedure called ADJUST_PET_WEIGHT that takes a pet ID, a weight adjustment number, and a student ID. First, get the pet's current weight. If bumping that weight up by the adjustment factor seems like it would be a bit too heavysay, over a certain reasonable limitthen update the pet's record with that new, heavier weight. If not, then just remove the link between that specific pet and student from the records.",
    "id": 158
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ManageCatalogEntries that first queries the CATALOG_CONTENTS table to compute and store the total number of rows, the maximum value in the PRICE_IN_DOLLARS column, the minimum value in the PRICE_IN_DOLLARS column, and the average value of the PRICE_IN_DOLLARS column into local variables v_total_entries, v_max_price, v_min_price, and v_avg_price respectively. If the total number of entries (v_total_entries) is greater than 100, then for every row in the CATALOG_CONTENTS table where the PRICE_IN_DOLLARS value is greater than the calculated average price (v_avg_price), the procedure retrieves the corresponding CATALOG_ENTRY_ID and uses it to delete all matching rows from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID column matches the retrieved value. Otherwise, if the first condition is not met and the maximum price (v_max_price) is greater than 1000, then for every row in the CATALOG_CONTENTS table where the PRICE_IN_DOLLARS value equals the maximum price (v_max_price), the procedure retrieves the corresponding CATALOG_ENTRY_ID and uses it to delete all matching rows from the CATALOG_CONTENTS table itself where the CATALOG_ENTRY_ID column matches the retrieved value. If neither of the previous conditions is true, then for every row in the CATALOG_CONTENTS table where the PRICE_IN_DOLLARS value is less than 110% of the calculated minimum price (specifically, less than v_min_price multiplied by 1.1), the procedure retrieves the corresponding CATALOG_ENTRY_ID and uses it to delete all matching rows from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID column matches the retrieved value.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageCatalogEntries\nIS\n  v_count NUMBER;\n  v_max_price NUMBER;\n  v_min_price NUMBER;\n  v_avg_price NUMBER;\n  v_total_entries NUMBER;\nBEGIN\n  SELECT COUNT(*), MAX(PRICE_IN_DOLLARS), MIN(PRICE_IN_DOLLARS), AVG(PRICE_IN_DOLLARS)\n  INTO v_total_entries, v_max_price, v_min_price, v_avg_price\n  FROM CATALOG_CONTENTS;\n\n  IF v_total_entries > 100 THEN\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS > v_avg_price) LOOP\n      DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  ELSIF v_max_price > 1000 THEN\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS = v_max_price) LOOP\n      DELETE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  ELSE\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS < v_min_price * 1.1) LOOP\n      DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  END IF;\n  COMMIT;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  ManageCatalogEntries;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named MANAGECATALOGENTRIES. Calculate the total entries, maximum price, minimum price, and average price from CATALOG_CONTENTS. If total entries exceed 100, delete from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where CATALOG_ENTRY_ID corresponds to entries with price above average. Else if maximum price exceeds 1000, delete from CATALOG_CONTENTS where CATALOG_ENTRY_ID corresponds to entries with the maximum price. Otherwise, delete from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where CATALOG_ENTRY_ID corresponds to entries with price less than 110% of the minimum price.",
    "natural_language": "Create a stored procedure called MANAGECATALOGENTRIES. First, calculate the total number of entries, the maximum price, the minimum price, and the average price from the CATALOG_CONTENTS table. If the total entries are more than 100, then delete records from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where the CATALOG_ENTRY_ID matches entries with a price above the average. If the total is not over 100 but the maximum price is greater than 1000, then delete from CATALOG_CONTENTS where the CATALOG_ENTRY_ID matches entries with that maximum price. Otherwise, delete from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where the CATALOG_ENTRY_ID matches entries with a price less than 110% of the minimum price.",
    "id": 159
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `AnalyzeCatalogData` that performs an analysis and conditional data manipulation on catalog-related tables. The procedure does not accept any input parameters. It begins by declaring three local numeric variables: `v_high_price_count`, `v_low_price_count`, and `v_total_entries`, and one local numeric variable `v_avg_price`. The first operation is to query the `CATALOG_CONTENTS` table. It calculates the total number of entries by counting all rows and computes the average of the `PRICE_IN_DOLLARS` column across all entries. These two calculated values are then stored into the `v_total_entries` and `v_avg_price` variables, respectively. Following this, the procedure executes another query on the `CATALOG_CONTENTS` table to count the number of entries where the `PRICE_IN_DOLLARS` column is strictly greater than the `v_avg_price` previously calculated. This count is then assigned to the `v_high_price_count` variable. Subsequently, a third query is performed on the `CATALOG_CONTENTS` table to count the number of entries where the `PRICE_IN_DOLLARS` column is strictly less than the `v_avg_price`. This count is then assigned to the `v_low_price_count` variable. After these calculations, the procedure enters a conditional block. It checks if the value of `v_high_price_count` is strictly greater than the value of `v_low_price_count`. If this condition is true, the procedure enters a `FOR` loop. Inside this loop, it selects the `CATALOG_ENTRY_ID` for all entries from the `CATALOG_CONTENTS` table where the `PRICE_IN_DOLLARS` is strictly greater than `v_avg_price`. For each `CATALOG_ENTRY_ID` retrieved in this loop, it executes a `DELETE` statement on the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table, removing all rows where the `CATALOG_ENTRY_ID` matches the current `rec.CATALOG_ENTRY_ID`. If the initial condition (`v_high_price_count > v_low_price_count`) is false, the procedure executes the `ELSE` part of the conditional block. In this `ELSE` block, it enters a `FOR` loop. Inside this loop, it selects the `CATALOG_ENTRY_ID` for all entries from the `CATALOG_CONTENTS` table where the `PRICE_IN_DOLLARS` is strictly less than `v_avg_price`. For each `CATALOG_ENTRY_ID` retrieved in this loop, it executes a `DELETE` statement on the `CATALOG_CONTENTS` table, removing the row where the `CATALOG_ENTRY_ID` matches the current `rec.CATALOG_ENTRY_ID`. Finally, regardless of which branch of the conditional statement was executed, the procedure issues a `COMMIT` statement to make all changes permanent.",
    "plsql": "CREATE OR REPLACE PROCEDURE AnalyzeCatalogData\nIS\n  v_high_price_count NUMBER;\n  v_low_price_count NUMBER;\n  v_total_entries NUMBER;\n  v_avg_price NUMBER;\nBEGIN\n  SELECT COUNT(*), AVG(PRICE_IN_DOLLARS)\n  INTO v_total_entries, v_avg_price\n  FROM CATALOG_CONTENTS;\n\n  SELECT COUNT(*)\n  INTO v_high_price_count\n  FROM CATALOG_CONTENTS\n  WHERE PRICE_IN_DOLLARS > v_avg_price;\n\n  SELECT COUNT(*)\n  INTO v_low_price_count\n  FROM CATALOG_CONTENTS\n  WHERE PRICE_IN_DOLLARS < v_avg_price;\n\n  IF v_high_price_count > v_low_price_count THEN\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS > v_avg_price) LOOP\n      DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  ELSE\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS < v_avg_price) LOOP\n      DELETE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  END IF;\n  COMMIT;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  AnalyzeCatalogData;\nEND;"
    ],
    "summary": "Create a stored procedure named ANALYZECATALOGDATA with no parameters. Calculate total entries and average price from CATALOG_CONTENTS. Count entries with price above average and below average. If the count of high-price entries exceeds low-price entries, delete from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where CATALOG_ENTRY_ID corresponds to high-price entries. Otherwise, delete from CATALOG_CONTENTS where CATALOG_ENTRY_ID corresponds to low-price entries. Commit the changes.",
    "natural_language": "Can you create a stored procedure called ANALYZECATALOGDATA with no parameters? It should calculate the total number of entries and the average price from the CATALOG_CONTENTS table. Then, count how many entries have a price above that average and how many have a price below it. If the count of high-price entries is greater than the count of low-price entries, delete the corresponding entries from CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES where the CATALOG_ENTRY_ID matches the high-price entries. Otherwise, delete the corresponding entries from CATALOG_CONTENTS where the CATALOG_ENTRY_ID matches the low-price entries. Finally, commit the changes.",
    "id": 160
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `CatalogPriceAdjustment` that performs conditional data manipulation on catalog-related tables. The procedure begins by declaring three local numeric variables: `v_max_price` to store the maximum price, `v_min_price` to store the minimum price, and `v_avg_price` to store the average price. It then executes a `SELECT` statement to retrieve the maximum, minimum, and average values of the `PRICE_IN_DOLLARS` column from the `CATALOG_CONTENTS` table. These aggregated values are then assigned respectively to the `v_max_price`, `v_min_price`, and `v_avg_price` variables. Following this data retrieval, the procedure enters a conditional block.\n\nThe first condition checks if the `v_max_price` is greater than 1000. If this condition is true, the procedure initiates a `FOR` loop. This loop iterates over a result set obtained by selecting the `CATALOG_ENTRY_ID` from the `CATALOG_CONTENTS` table where the `PRICE_IN_DOLLARS` column is equal to the `v_max_price`. For each `CATALOG_ENTRY_ID` retrieved in this loop, a `DELETE` statement is executed to remove the corresponding row from the `CATALOG_CONTENTS` table where the `CATALOG_ENTRY_ID` matches the `CATALOG_ENTRY_ID` of the current record (`rec.CATALOG_ENTRY_ID`).\n\nIf the first condition (`v_max_price > 1000`) is false, the procedure proceeds to an `ELSIF` condition, which checks if the `v_min_price` is less than 100. If this `ELSIF` condition is true, the procedure initiates another `FOR` loop. This loop iterates over a result set obtained by selecting the `CATALOG_ENTRY_ID` from the `CATALOG_CONTENTS` table where the `PRICE_IN_DOLLARS` column is equal to the `v_min_price`. For each `CATALOG_ENTRY_ID` retrieved in this loop, a `DELETE` statement is executed to remove the corresponding row from the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table where the `CATALOG_ENTRY_ID` matches the `CATALOG_ENTRY_ID` of the current record (`rec.CATALOG_ENTRY_ID`).\n\nIf both the first condition and the `ELSIF` condition are false, the procedure executes the `ELSE` block. Within this `ELSE` block, a final `FOR` loop is initiated. This loop iterates over a result set obtained by selecting the `CATALOG_ENTRY_ID` from the `CATALOG_CONTENTS` table where the `PRICE_IN_DOLLARS` column is less than the `v_avg_price`. For each `CATALOG_ENTRY_ID` retrieved in this loop, a `DELETE` statement is executed to remove the corresponding row from the `CATALOG_CONTENTS` table where the `CATALOG_ENTRY_ID` matches the `CATALOG_ENTRY_ID` of the current record (`rec.CATALOG_ENTRY_ID`). After the conditional logic is fully executed, regardless of which branch was taken, the procedure issues a `COMMIT` statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE CatalogPriceAdjustment\nIS\n  v_max_price NUMBER;\n  v_min_price NUMBER;\n  v_avg_price NUMBER;\nBEGIN\n  SELECT MAX(PRICE_IN_DOLLARS), MIN(PRICE_IN_DOLLARS), AVG(PRICE_IN_DOLLARS)\n  INTO v_max_price, v_min_price, v_avg_price\n  FROM CATALOG_CONTENTS;\n\n  IF v_max_price > 1000 THEN\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS = v_max_price) LOOP\n      DELETE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  ELSIF v_min_price < 100 THEN\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS = v_min_price) LOOP\n      DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  ELSE\n    FOR rec IN (SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS < v_avg_price) LOOP\n      DELETE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = rec.CATALOG_ENTRY_ID;\n    END LOOP;\n  END IF;\n  COMMIT;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  CatalogPriceAdjustment;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named CatalogPriceAdjustment. Calculate the maximum, minimum, and average price from the CATALOG_CONTENTS table. If the maximum price is greater than 1000, delete all entries from CATALOG_CONTENTS with that maximum price. Else, if the minimum price is less than 100, delete corresponding entries from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table. Otherwise, delete entries from CATALOG_CONTENTS where the price is below the average. Commit the changes.",
    "natural_language": "What stored procedure named CatalogPriceAdjustment can be created to calculate the maximum, minimum, and average price from the CATALOG_CONTENTS table, and then, if the maximum price exceeds 1000, delete all entries with that price from CATALOG_CONTENTS, or else, if the minimum price is below 100, delete the corresponding entries from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, or otherwise, delete entries from CATALOG_CONTENTS where the price is below the average, before committing the changes?",
    "id": 161
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_church_open_date that accepts two parameters: p_church_id of type NUMBER, representing the unique identifier of a church, and p_new_open_date of type NUMBER, representing the new date to be set for the church's opening. The procedure begins by declaring three local variables: v_church_name, v_organized_by, and v_continuation_of, all of type VARCHAR2(255), intended to store the name, organizer, and continuation information of the church, respectively. It then executes a SELECT statement to retrieve the NAME, ORGANIZED_BY, and CONTINUATION_OF columns from the CHURCH table for the row where CHURCH_ID matches the provided p_church_id, storing these values into the corresponding local variables. Following this, the procedure evaluates the length of the church's name using the LENGTH function. If the length of v_church_name exceeds 10 characters, it performs an UPDATE operation on the CHURCH table, setting the OPEN_DATE column to the value of p_new_open_date for the row with CHURCH_ID equal to p_church_id. If the length of v_church_name is 10 or fewer characters, it checks the length of v_organized_by. If the length of v_organized_by exceeds 5 characters, it updates the OPEN_DATE column to p_new_open_date plus 1 for the specified church ID. If neither condition is met, it updates the OPEN_DATE column to p_new_open_date plus 2 for the church with the given ID. The procedure concludes after executing the appropriate conditional update based on the evaluated lengths.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_church_open_date(p_church_id NUMBER, p_new_open_date NUMBER) IS\n    v_church_name VARCHAR2(255);\n    v_organized_by VARCHAR2(255);\n    v_continuation_of VARCHAR2(255);\nBEGIN\n    SELECT NAME, ORGANIZED_BY, CONTINUATION_OF\n    INTO v_church_name, v_organized_by, v_continuation_of\n    FROM CHURCH\n    WHERE CHURCH_ID = p_church_id;\n\n    IF LENGTH(v_church_name) > 10 THEN\n        UPDATE CHURCH\n        SET OPEN_DATE = p_new_open_date\n        WHERE CHURCH_ID = p_church_id;\n    ELSIF LENGTH(v_organized_by) > 5 THEN\n        UPDATE CHURCH\n        SET OPEN_DATE = p_new_open_date + 1\n        WHERE CHURCH_ID = p_church_id;\n    ELSE\n        UPDATE CHURCH\n        SET OPEN_DATE = p_new_open_date + 2\n        WHERE CHURCH_ID = p_church_id;\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  update_church_open_date(1, 1840);\n  commit;\nEND;",
      "BEGIN\n  update_church_open_date(2, 1841);\n  commit;\nEND;",
      "BEGIN\n  update_church_open_date(3, 1842);\n  commit;\nEND;",
      "BEGIN\n  update_church_open_date(1, 1843);\n  commit;\nEND;",
      "BEGIN\n  update_church_open_date(2, 1844);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named update_church_open_date that accepts a church ID and a new open date. Retrieve the church's name, organizer, and continuation info. If the name length exceeds 10, update the open date to the new date. Else, if the organizer's length exceeds 5, update the open date to the new date plus 1. Otherwise, update the open date to the new date plus 2.",
    "natural_language": "Please construct a stored procedure designated as 'update_church_open_date'. This procedure shall accept two input parameters: a church identifier and a new open date. Within the procedure, first retrieve the church's name, organizer, and continuation information. Subsequently, implement the following conditional logic: if the length of the church name exceeds ten characters, update the open date to the provided new date. Alternatively, if the length of the organizer's name exceeds five characters, update the open date to the new date incremented by one day. In all other cases, update the open date to the new date incremented by two days.",
    "id": 162
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_old_weddings` that accepts one input parameter, `p_year`, which is of `NUMBER` data type and represents a specific year. The purpose of this procedure is to identify and delete wedding records from the `WEDDING` table that occurred before the year specified by `p_year`.\n\nThe procedure begins by declaring three local variables: `v_church_id` of `NUMBER` type, `v_male_id` of `NUMBER` type, and `v_female_id` of `NUMBER` type. These variables are used to temporarily store the `CHURCH_ID`, `MALE_ID`, and `FEMALE_ID` values, respectively, for each wedding record being processed.\n\nThe core logic of the procedure involves iterating through a result set obtained from a `SELECT` statement. This `SELECT` statement retrieves the `CHURCH_ID`, `MALE_ID`, and `FEMALE_ID` columns from the `WEDDING` table for all rows where the `YEAR` column's value is strictly less than the value provided in the `p_year` parameter.\n\nFor each record (`rec`) returned by this `SELECT` statement, the procedure performs the following actions:\n1. The value of `rec.CHURCH_ID` is assigned to the local variable `v_church_id`.\n2. The value of `rec.MALE_ID` is assigned to the local variable `v_male_id`.\n3. The value of `rec.FEMALE_ID` is assigned to the local variable `v_female_id`.\n\nFollowing these assignments, a conditional `IF-ELSIF-ELSE` block is executed to determine how to delete the current wedding record from the `WEDDING` table. The deletion strategy depends on the nullability of the `v_church_id` and `v_male_id` variables:\n\n- **IF `v_church_id` IS NOT NULL**: If the `CHURCH_ID` for the current wedding record is not null, a `DELETE` statement is executed. This `DELETE` statement removes rows from the `WEDDING` table where the `CHURCH_ID` column matches the value of `v_church_id`, the `MALE_ID` column matches the value of `v_male_id`, and the `FEMALE_ID` column matches the value of `v_female_id`. This condition implies that the `CHURCH_ID` is a significant part of the unique identifier for the wedding.\n\n- **ELSIF `v_male_id` IS NOT NULL**: If the `CHURCH_ID` is null, but the `MALE_ID` for the current wedding record is not null, a different `DELETE` statement is executed. This `DELETE` statement removes rows from the `WEDDING` table where the `MALE_ID` column matches the value of `v_male_id` and the `FEMALE_ID` column matches the value of `v_female_id`. This condition suggests that `MALE_ID` and `FEMALE_ID` together form a unique identifier when `CHURCH_ID` is absent.\n\n- **ELSE**: If both `v_church_id` and `v_male_id` are null, the final `DELETE` statement is executed. This `DELETE` statement removes rows from the `WEDDING` table where the `FEMALE_ID` column matches the value of `v_female_id`. This implies that `FEMALE_ID` alone is used as the identifier for deletion when both `CHURCH_ID` and `MALE_ID` are null.\n\nThis loop continues until all wedding records with a `YEAR` less than `p_year` have been processed and potentially deleted based on the described conditional logic.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_weddings(p_year NUMBER) IS\n    v_church_id NUMBER;\n    v_male_id NUMBER;\n    v_female_id NUMBER;\nBEGIN\n    FOR rec IN (SELECT CHURCH_ID, MALE_ID, FEMALE_ID FROM WEDDING WHERE YEAR < p_year) LOOP\n        v_church_id := rec.CHURCH_ID;\n        v_male_id := rec.MALE_ID;\n        v_female_id := rec.FEMALE_ID;\n\n        IF v_church_id IS NOT NULL THEN\n            DELETE FROM WEDDING WHERE CHURCH_ID = v_church_id AND MALE_ID = v_male_id AND FEMALE_ID = v_female_id;\n        ELSIF v_male_id IS NOT NULL THEN\n            DELETE FROM WEDDING WHERE MALE_ID = v_male_id AND FEMALE_ID = v_female_id;\n        ELSE\n            DELETE FROM WEDDING WHERE FEMALE_ID = v_female_id;\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  delete_old_weddings(2010);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2012);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2014);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2015);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2016);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named delete_old_weddings that accepts a year parameter. For each wedding record with a year less than the provided year, retrieve its church, male, and female IDs. If the church ID is not null, delete the wedding using all three IDs. Else, if the male ID is not null, delete using the male and female IDs. Otherwise, delete using only the female ID.",
    "natural_language": "Create a stored procedure to delete some older wedding records. It should take a year as input. For weddings from before that general time period, get the associated church, groom, and bride details. If there's a church linked to the wedding, use that along with the other IDs to remove it. If not, but there is a groom listed, use those two IDs. If neither applies, just use the bride's ID to delete whatever records might be there.",
    "id": 163
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_people_country that accepts two input parameters: a numeric parameter p_people_id to identify a specific person and a string parameter p_new_country to provide a new country value. The procedure begins by querying the PEOPLE table, selecting the NAME and IS_MALE columns for the single row where the PEOPLE_ID column matches the provided p_people_id parameter, and storing these values into local variables v_name and v_is_male. It then evaluates a conditional logic flow: first, it checks if the uppercase conversion of the v_is_male variable equals the string 'T'; if true, it executes an update statement on the PEOPLE table, setting the COUNTRY column to the value of the p_new_country parameter for the row where PEOPLE_ID equals p_people_id. If the first condition is false, it checks if the character length of the v_name variable is greater than 5; if true, it executes a different update statement, setting the COUNTRY column to a concatenated string formed by appending the literal ' - Updated' to the p_new_country parameter value, again for the row where PEOPLE_ID equals p_people_id. If neither condition is true, it executes a final update statement, setting the COUNTRY column to the literal string 'Unknown' for the specified row where PEOPLE_ID equals p_people_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_people_country(p_people_id NUMBER, p_new_country VARCHAR2) IS\n    v_name VARCHAR2(255);\n    v_is_male VARCHAR2(255);\nBEGIN\n    SELECT NAME, IS_MALE INTO v_name, v_is_male FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\n\n    IF UPPER(v_is_male) = 'T' THEN\n        UPDATE PEOPLE SET COUNTRY = p_new_country WHERE PEOPLE_ID = p_people_id;\n    ELSIF LENGTH(v_name) > 5 THEN\n        UPDATE PEOPLE SET COUNTRY = p_new_country || ' - Updated' WHERE PEOPLE_ID = p_people_id;\n    ELSE\n        UPDATE PEOPLE SET COUNTRY = 'Unknown' WHERE PEOPLE_ID = p_people_id;\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  update_people_country(1, 'USA');\n  commit;\nEND;",
      "BEGIN\n  update_people_country(2, 'Norway');\n  commit;\nEND;",
      "BEGIN\n  update_people_country(3, 'Australia');\n  commit;\nEND;",
      "BEGIN\n  update_people_country(1, 'Mexico');\n  commit;\nEND;",
      "BEGIN\n  update_people_country(2, 'Japan');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named update_people_country that accepts a person ID and a new country. Retrieve the person's name and gender flag. If the gender is 'T', update their country to the new country. Else, if the name length is greater than 5, update their country to the new country appended with ' - Updated'. Otherwise, update their country to 'Unknown'.",
    "natural_language": "Make a stored procedure called update_people_country that takes a person's ID and a different country. Get the person's name and their gender indicator. If the gender seems to be 'T', then change their country to the new one. Otherwise, if the name looks kind of long, maybe more than a few characters, update the country to the new one with something like ' - Updated' added on. If neither of those vague conditions fits, just set the country to something like 'Unknown'.",
    "id": 164
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `transfer_church_organization` that accepts two input parameters: `p_church_id` of type `NUMBER`, representing the unique identifier of a church, and `p_new_organizer` of type `VARCHAR2`, representing the name of the new organizer for the church. The procedure begins by declaring two local variables: `v_name` of type `VARCHAR2(255)` to store the name of the church, and `v_open_date` of type `NUMBER` to store the opening date of the church. It then executes a `SELECT` statement to retrieve the `NAME` and `OPEN_DATE` columns from the `CHURCH` table, storing these values into the `v_name` and `v_open_date` variables, respectively. This selection is filtered by a `WHERE` clause, ensuring that only the row where the `CHURCH_ID` column matches the input parameter `p_church_id` is considered. Following this data retrieval, the procedure enters a conditional logic block. The first condition checks if the value stored in `v_open_date` is less than `1900`. If this condition is true, an `UPDATE` statement is executed on the `CHURCH` table, setting the `ORGANIZED_BY` column to the value provided in the `p_new_organizer` parameter. This update is applied only to the row where the `CHURCH_ID` column matches `p_church_id`. If the first condition is false, the procedure proceeds to an `ELSIF` condition. This second condition checks if the `LENGTH` of the `v_name` variable (which holds the church's name) is greater than `10`. If this condition is true, an `UPDATE` statement is executed on the `CHURCH` table, setting the `ORGANIZED_BY` column to a concatenated string consisting of the `p_new_organizer` parameter value followed by the literal string ' - Historical'. This update is also applied only to the row where the `CHURCH_ID` column matches `p_church_id`. If both the first and second conditions are false, the procedure executes the `ELSE` block. Within this block, an `UPDATE` statement is performed on the `CHURCH` table, setting the `ORGANIZED_BY` column to the literal string 'Unknown'. This final update is similarly restricted to the row where the `CHURCH_ID` column matches `p_church_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_church_organization(p_church_id NUMBER, p_new_organizer VARCHAR2) IS\n    v_name VARCHAR2(255);\n    v_open_date NUMBER;\nBEGIN\n    SELECT NAME, OPEN_DATE INTO v_name, v_open_date FROM CHURCH WHERE CHURCH_ID = p_church_id;\n\n    IF v_open_date < 1900 THEN\n        UPDATE CHURCH SET ORGANIZED_BY = p_new_organizer WHERE CHURCH_ID = p_church_id;\n    ELSIF LENGTH(v_name) > 10 THEN\n        UPDATE CHURCH SET ORGANIZED_BY = p_new_organizer || ' - Historical' WHERE CHURCH_ID = p_church_id;\n    ELSE\n        UPDATE CHURCH SET ORGANIZED_BY = 'Unknown' WHERE CHURCH_ID = p_church_id;\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  transfer_church_organization(1, 'New Organizer A');\nEND;",
      "BEGIN\n  transfer_church_organization(2, 'New Organizer B');\nEND;",
      "BEGIN\n  transfer_church_organization(3, 'New Organizer C');\nEND;",
      "BEGIN\n  transfer_church_organization(1, 'Another Organizer');\nEND;",
      "BEGIN\n  transfer_church_organization(2, 'Yet Another Organizer');\nEND;"
    ],
    "summary": "Create a stored procedure named transfer_church_organization that accepts a church ID and a new organizer name. Retrieve the church's name and open date. If the open date is before 1900, update the organizer to the new name. Else, if the name length is greater than 10, update the organizer to the new name appended with ' - Historical'. Otherwise, update the organizer to 'Unknown'.",
    "natural_language": "Compose a stored procedure designated as 'transfer_church_organization' that shall accept two parameters: a church identifier and the name of a new organizer. The procedure must first retrieve the name of the specified church and its date of opening. Subsequently, implement the following conditional logic: if the retrieved opening date precedes the year 1900, the organizer field is to be updated with the provided new name. Alternatively, if the length of the church's name exceeds ten characters, the update shall assign the new name concatenated with the suffix ' - Historical'. In all other cases, the organizer field must be updated to the value 'Unknown'.",
    "id": 165
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp2` that accepts three input parameters: `para_Course_ID` of type `NUMBER`, `para_Starting_Date` of type `VARCHAR2`, and `para_Course` of type `VARCHAR2`. The procedure first declares a local variable `v_MaxGrade` of type `NUMBER`. It then executes a `SELECT` statement to retrieve the maximum value from the `GRADE` column in the `COURSE_ARRANGE` table, specifically for rows where the `COURSE_ID` column matches the value provided in the `para_Course_ID` input parameter. This retrieved maximum grade value is then stored into the `v_MaxGrade` local variable. Following this, the procedure evaluates a conditional `IF` statement: if the value of `v_MaxGrade` is greater than `3`, it proceeds to execute a `MERGE` statement. This `MERGE` statement targets the `COURSE` table, using a source derived from the `DUAL` table which effectively creates a single row containing the values from `para_Course_ID` aliased as `COURSE_ID`, `para_Starting_Date` aliased as `STARING_DATE`, and `para_Course` aliased as `COURSE`. The `MERGE` operation attempts to match rows in the `COURSE` table with this source row based on the condition where the `COURSE_ID` column in the `COURSE` table equals the `COURSE_ID` from the source. If a match is found (`WHEN MATCHED`), the `STARING_DATE` column in the `COURSE` table is updated with the `STARING_DATE` value from the source, and the `COURSE` column in the `COURSE` table is updated with the `COURSE` value from the source. If no match is found (`WHEN NOT MATCHED`), a new row is inserted into the `COURSE` table with values for `COURSE_ID`, `STARING_DATE`, and `COURSE` taken from the corresponding columns in the source. If the initial `IF` condition evaluates to false (i.e., `v_MaxGrade` is not greater than `3`), the procedure executes a `DELETE` statement that removes all rows from the `COURSE` table where the `COURSE_ID` column matches the value provided in the `para_Course_ID` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp2(para_Course_ID NUMBER, para_Starting_Date VARCHAR2, para_Course VARCHAR2) IS\n  v_MaxGrade NUMBER;\nBEGIN\n  SELECT MAX(GRADE) INTO v_MaxGrade FROM COURSE_ARRANGE WHERE COURSE_ID = para_Course_ID;\n\n  IF v_MaxGrade > 3 THEN\n    MERGE INTO COURSE c\n    USING (SELECT para_Course_ID AS COURSE_ID, para_Starting_Date AS STARING_DATE, para_Course AS COURSE FROM DUAL) src\n    ON (c.COURSE_ID = src.COURSE_ID)\n    WHEN MATCHED THEN\n      UPDATE SET c.STARING_DATE = src.STARING_DATE,\n                 c.COURSE = src.COURSE\n    WHEN NOT MATCHED THEN\n      INSERT (COURSE_ID, STARING_DATE, COURSE)\n      VALUES (src.COURSE_ID, src.STARING_DATE, src.COURSE);\n  ELSE\n    DELETE FROM COURSE WHERE COURSE_ID = para_Course_ID;\n  END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  sp2(2, '10 May', 'History');\nEND;",
      "BEGIN\n  sp2(3, '11 May', 'Art');\nEND;",
      "BEGIN\n  sp2(1, '12 May', 'Music');\nEND;",
      "BEGIN\n  sp2(2, '13 May', 'Geography');\nEND;",
      "BEGIN\n  sp2(3, '14 May', 'Physics');\nEND;"
    ],
    "summary": "Create a stored procedure named sp2 that takes a course ID (number), starting date (string), and course name (string). Find the maximum grade for that course ID from the COURSE_ARRANGE table. If the maximum grade is greater than 3, merge the data into the COURSE table, updating the existing record or inserting a new one. Otherwise, delete all records for that course ID from the COURSE table.",
    "natural_language": "Develop a stored procedure called sp2 that accepts three input parameters: a numeric course identifier, a starting date expressed as a string, and a string representing the course's name. The procedure should first determine the highest grade associated with the provided course ID by querying the COURSE_ARRANGE table. In the event that this maximum grade exceeds the value of 3, the procedure must perform a merge operation into the COURSE table, which will either update the current entry for that course or insert a completely new record if one does not already exist. Conversely, if the maximum grade is found to be 3 or lower, the procedure should proceed to remove every single record corresponding to that specific course ID from the COURSE table.",
    "id": 166
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp4 that accepts three input parameters: a numeric parameter para_Course_ID, a numeric parameter para_Teacher_ID, and a numeric parameter para_Grade. The procedure begins by declaring a local variable v_CourseName of type VARCHAR2 with a maximum length of 255 characters. It then executes a SELECT statement to query the COURSE table, specifically retrieving the value from the COURSE column for the single row where the COURSE_ID column matches the input parameter para_Course_ID, and stores this retrieved course name into the local variable v_CourseName. Following this retrieval, the procedure evaluates a conditional IF statement that checks if the length of the string stored in v_CourseName is greater than 8 characters. If this condition is true, the procedure performs a DELETE operation on the COURSE_ARRANGE table, removing any rows where the COURSE_ID column equals the input para_Course_ID and simultaneously the TEACHER_ID column equals the input para_Teacher_ID. If the condition is false (meaning the length of v_CourseName is 8 characters or fewer), the procedure instead performs an INSERT operation into the COURSE_ARRANGE table, creating a new row with the column COURSE_ID set to the input para_Course_ID, the column TEACHER_ID set to the input para_Teacher_ID, and the column GRADE set to the input para_Grade.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp4(para_Course_ID NUMBER, para_Teacher_ID NUMBER, para_Grade NUMBER) IS\n  v_CourseName VARCHAR2(255);\nBEGIN\n  SELECT COURSE INTO v_CourseName FROM COURSE WHERE COURSE_ID = para_Course_ID;\n  IF LENGTH(v_CourseName) > 8 THEN\n    DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = para_Course_ID AND TEACHER_ID = para_Teacher_ID;\n  ELSE\n    INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (para_Course_ID, para_Teacher_ID, para_Grade);\n  END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  sp4(1, 3, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(2, 5, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(3, 2, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(1, 1, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(2, 3, 2);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp4 that takes a course ID, teacher ID, and grade (all numbers). Retrieve the course name for the given course ID from the COURSE table. If the course name length is greater than 8, delete the corresponding record from the COURSE_ARRANGE table. Otherwise, insert a new record into COURSE_ARRANGE with the provided IDs and grade.",
    "natural_language": "How can I create a stored procedure named sp4 that, given a course ID, teacher ID, and grade (all as numbers), retrieves the course name for that ID from the COURSE table and then, if the course name length exceeds 8, deletes the matching record from COURSE_ARRANGE, otherwise inserts a new record into COURSE_ARRANGE with the provided IDs and grade?",
    "id": 167
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp5 that accepts three parameters: para_Teacher_ID of type NUMBER, para_Course_ID of type NUMBER, and para_Hometown of type VARCHAR2. The procedure begins by declaring a local variable v_AgeCount of type NUMBER. It then performs a SELECT operation to count the number of rows in the TEACHER table where the TEACHER_ID column matches the value of para_Teacher_ID and the LENGTH of the AGE column is exactly 2 characters. The result of this count is stored in the v_AgeCount variable. The procedure then evaluates the value of v_AgeCount using an IF statement. If v_AgeCount is greater than 0, indicating that there is at least one teacher with a two-character age, the procedure executes an UPDATE operation on the TEACHER table, setting the HOMETOWN column to the value of para_Hometown for the row where TEACHER_ID matches para_Teacher_ID. Subsequently, it performs a DELETE operation on the COURSE_ARRANGE table, removing any rows where both TEACHER_ID matches para_Teacher_ID and COURSE_ID matches para_Course_ID. If v_AgeCount is not greater than 0, meaning no teacher with a two-character age exists, the procedure performs an INSERT operation into the TEACHER table, adding a new row with TEACHER_ID set to para_Teacher_ID, NAME set to 'New Teacher', AGE set to '30', and HOMETOWN set to para_Hometown.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp5(para_Teacher_ID NUMBER, para_Course_ID NUMBER, para_Hometown VARCHAR2) IS\n  v_AgeCount NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_AgeCount FROM TEACHER WHERE TEACHER_ID = para_Teacher_ID AND LENGTH(AGE) = 2;\n  IF v_AgeCount > 0 THEN\n    UPDATE TEACHER SET HOMETOWN = para_Hometown WHERE TEACHER_ID = para_Teacher_ID;\n    DELETE FROM COURSE_ARRANGE WHERE TEACHER_ID = para_Teacher_ID AND COURSE_ID = para_Course_ID;\n  ELSE\n    INSERT INTO TEACHER (TEACHER_ID, NAME, AGE, HOMETOWN) VALUES (para_Teacher_ID, 'New Teacher', '30', para_Hometown);\n  END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  sp5(1, 2, 'New York');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(2, 3, 'Los Angeles');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(3, 1, 'Chicago');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(4, 2, 'Houston');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(5, 3, 'Phoenix');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp5 that takes a teacher ID (number), course ID (number), and hometown (string). Count how many teachers have the given ID and an age field with exactly two characters. If the count is greater than zero, update that teacher's hometown and delete their corresponding record from COURSE_ARRANGE. Otherwise, insert a new teacher record with default values and the provided hometown.",
    "natural_language": "Alright, so we need a stored procedure, call it sp5. It's gonna take a teacher's ID (that's a number), a course ID (also a number), and a hometown (as text). Here's what it does: first, it checks how many teachers match that ID and have an age that's exactly two digits long. If it finds any, it updates that teacher's hometown to the new one and removes their entry from the COURSE_ARRANGE table. If it doesn't find any matches, it just adds a new teacher record using default stuff and the hometown we provided.",
    "id": 168
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_institutions that takes no parameters and begins by declaring a local variable v_count of type NUMBER. The procedure first executes a SELECT statement to count the number of rows in the INSTITUTION table where the INSTITUTION_ID column is greater than 100, storing the result in v_count. It then uses an IF conditional statement to check if v_count equals 0. If this condition is true, the procedure performs an INSERT operation into the CHAMPIONSHIP table, specifying the columns INSTITUTION_ID, NICKNAME, JOINED, and NUMBER_OF_CHAMPIONSHIPS. The data to insert is selected from the INSTITUTION table using a subquery: for each row in INSTITUTION where the INSTITUTION_ID is not already present in the CHAMPIONSHIP table (as determined by the subquery SELECT INSTITUTION_ID FROM CHAMPIONSHIP), the procedure selects the INSTITUTION_ID, uses the SUBSTR function to take the first 10 characters of the TEAM column to form the NICKNAME, uses the EXTRACT function to get the current year from the system timestamp via CURRENT_TIMESTAMP for the JOINED column, and hard-codes the value 0 for the NUMBER_OF_CHAMPIONSHIPS column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_institutions\nIS\n   v_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_count FROM INSTITUTION WHERE INSTITUTION_ID > 100;\n   IF v_count = 0 THEN\n      INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n      SELECT INSTITUTION_ID, SUBSTR(TEAM, 1, 10), EXTRACT(YEAR FROM CURRENT_TIMESTAMP), 0\n      FROM INSTITUTION\n      WHERE INSTITUTION_ID NOT IN (SELECT INSTITUTION_ID FROM CHAMPIONSHIP);\n   END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_institutions;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_new_institutions with no parameters. Count institutions with ID greater than 100. If the count is zero, insert new records into the CHAMPIONSHIP table for institutions not already present, using the first 10 characters of the team name as a nickname, the current year as the joined date, and 0 for championships.",
    "natural_language": "How can I create a stored procedure called 'insert_new_institutions' that takes no parameters, counts institutions with an ID greater than 100, and if that count is zero, inserts new records into the CHAMPIONSHIP table for any institutions not already there, using the first 10 characters of the team name as the nickname, the current year as the joined date, and 0 for championships?",
    "id": 169
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewMovie that accepts three input parameters: a string parameter p_title for the movie title, a numeric parameter p_release_year for the movie's release year, and a string parameter p_budget for the movie's budget. The procedure performs a single INSERT operation into a table named MOVIE. The INSERT statement specifies the columns MID, TITLE, RELEASE_YEAR, and BUDGET. The value for the MID column is derived by executing a subquery on the MOVIE table; this subquery selects the maximum existing value from the MID column, applies the NVL function to convert a potential NULL result (if the table is empty) to 0, and then adds 1 to this result to generate a new, sequential identifier. The values for the TITLE, RELEASE_YEAR, and BUDGET columns are populated directly from the input parameters p_title, p_release_year, and p_budget, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewMovie(\n  p_title VARCHAR2,\n  p_release_year NUMBER,\n  p_budget VARCHAR2\n) AS\nBEGIN\n  INSERT INTO MOVIE (MID, TITLE, RELEASE_YEAR, BUDGET)\n  VALUES ((SELECT NVL(MAX(MID), 0) + 1 FROM MOVIE), p_title, p_release_year, p_budget);\nEND;",
    "database_name": "imdb",
    "tables": [
      "MOVIE",
      "TV_SERIES",
      "WRITER",
      "WRITTEN_BY",
      "MADE_BY"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewMovie('The Great Adventure', 2023, '$150,000,000');\nEND;",
      "BEGIN\n  InsertNewMovie('Mystery of the Old House', 2022, '$50,000,000');\nEND;",
      "BEGIN\n  InsertNewMovie('Space Odyssey', 1968, '$12,000,000');\nEND;",
      "BEGIN\n  InsertNewMovie('The Silent Witness', 2024, '$75,000,000');\nEND;",
      "BEGIN\n  InsertNewMovie('Fantasy Realm', 2021, '$200,000,000');\nEND;"
    ],
    "summary": "Create a stored procedure named InsertNewMovie that takes a movie title (string), release year (number), and budget (string). Insert a new record into the MOVIE table, generating a new sequential ID by finding the maximum existing ID and adding 1.",
    "natural_language": "Hey, can you whip up a stored procedure called InsertNewMovie? It needs to handle a movie's title (as a string), the year it came out (as a number), and its budget (as a string). Just pop a new row into the MOVIE table. For the ID, figure out the highest ID already in there and just bump it up by one to get the next number.",
    "id": 170
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `add_new_country` that accepts four input parameters: `para_name` of type `VARCHAR2`, `para_population` of type `NUMBER`, `para_area` of type `NUMBER`, and `para_languages` of type `VARCHAR2`. The purpose of this procedure is to insert a new record into the `COUNTRY` table. The `COUNTRY_ID` column for the new record is determined by first querying the `COUNTRY` table to find the maximum existing `COUNTRY_ID` value. If no records exist in the `COUNTRY` table, `NVL` (Null Value Logic) function ensures that `0` is used instead of `NULL`. This maximum value (or `0`) is then incremented by `1` to generate a unique `COUNTRY_ID` for the new record. The `NAME` column of the new record is populated with the value provided by the `para_name` parameter. The `POPULATION` column is populated with the value from the `para_population` parameter. The `AREA` column is populated with the value from the `para_area` parameter. Finally, the `LANGUAGES` column is populated with the value from the `para_languages` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_country(para_name VARCHAR2, para_population NUMBER, para_area NUMBER, para_languages VARCHAR2) IS \nBEGIN \n  INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) \n  VALUES ((SELECT NVL(MAX(COUNTRY_ID), 0) + 1 FROM COUNTRY), para_name, para_population, para_area, para_languages); \nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  add_new_country('France', 65273511, 643801, 'French');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Germany', 83019200, 357022, 'German');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Japan', 126476461, 377975, 'Japanese');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Canada', 37589262, 9984670, 'English French');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Australia', 25364307, 7692024, 'English');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ADD_NEW_COUNTRY to insert a new country. It takes parameters for name, population, area, and languages. Generate a new COUNTRY_ID by finding the maximum existing ID, using 0 if none exist, and adding 1. Insert all values into the COUNTRY table.",
    "natural_language": "Hey, can you whip up a stored procedure called ADD_NEW_COUNTRY to add a new country? It needs to take in the country's name, how many people live there, its size, and the languages spoken. For the ID, just grab the highest one already in there, start from 0 if the table's empty, and bump it up by one. Then just shove all that info into the COUNTRY table.",
    "id": 171
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ADD_ROLLER_COASTER that accepts six input parameters: a string parameter PARA_NAME, a string parameter PARA_PARK, a numeric parameter PARA_COUNTRY_ID, a numeric parameter PARA_LENGTH, a numeric parameter PARA_HEIGHT, and a string parameter PARA_SPEED, and performs a single INSERT operation into the ROLLER_COASTER table, where the ROLLER_COASTER_ID column value is derived by executing a subquery on the same ROLLER_COASTER table to find the current maximum value in the ROLLER_COASTER_ID column, using the NVL function to return 0 if no maximum is found, and then adding 1 to that result, the NAME column is populated with the PARA_NAME parameter value, the PARK column is populated with the PARA_PARK parameter value, the COUNTRY_ID column is populated with the PARA_COUNTRY_ID parameter value, the LENGTH column is populated with the PARA_LENGTH parameter value, the HEIGHT column is populated with the PARA_HEIGHT parameter value, the SPEED column is populated with the PARA_SPEED parameter value, the OPENED column is populated by extracting the four-digit year component from the current system timestamp using the EXTRACT function with the YEAR element on the SYSTIMESTAMP value, and the STATUS column is populated with the literal string value 'Under Construction'.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_roller_coaster(para_name VARCHAR2, para_park VARCHAR2, para_country_id NUMBER, para_length NUMBER, para_height NUMBER, para_speed VARCHAR2) IS \nBEGIN \n  INSERT INTO ROLLER_COASTER (ROLLER_COASTER_ID, NAME, PARK, COUNTRY_ID, LENGTH, HEIGHT, SPEED, OPENED, STATUS) \n  VALUES ((SELECT NVL(MAX(ROLLER_COASTER_ID), 0) + 1 FROM ROLLER_COASTER), para_name, para_park, para_country_id, para_length, para_height, para_speed, EXTRACT(YEAR FROM SYSTIMESTAMP), 'Under Construction'); \nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  add_roller_coaster('The Goliath', 'Six Flags Great America', 1, 4500, 165, '72');\n  commit;\nEND;",
      "BEGIN\n  add_roller_coaster('Fury 325', 'Carowinds', 2, 6602, 325, '95');\n  commit;\nEND;",
      "BEGIN\n  add_roller_coaster('Steel Vengeance', 'Cedar Point', 3, 5740, 205, '74');\n  commit;\nEND;",
      "BEGIN\n  add_roller_coaster('Kingda Ka', 'Six Flags Great Adventure', 1, 3118, 456, '128');\n  commit;\nEND;",
      "BEGIN\n  add_roller_coaster('Millennium Force', 'Cedar Point', 2, 6595, 310, '93');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ADD_ROLLER_COASTER to insert a new roller coaster. It takes parameters for name, park, country ID, length, height, and speed. Generate a new ROLLER_COASTER_ID by finding the maximum existing ID, using 0 if none exist, and adding 1. Set the OPENED column to the current year and the STATUS column to 'Under Construction'. Insert all values into the ROLLER_COASTER table.",
    "natural_language": "Hey, can you whip up a stored procedure called ADD_ROLLER_COASTER to add a new coaster? It needs the coaster's name, which park it's in, the country ID, plus how long, tall, and fast it is. For the ID, just grab the highest one already there, start at 0 if there's none, and bump it up by 1. Set the OPENED date to this year and mark the STATUS as 'Under Construction'. Then just plug all that info into the ROLLER_COASTER table.",
    "id": 172
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_country_population` that accepts two input parameters: `para_country_id` of data type `NUMBER`, which represents the unique identifier for a country, and `para_new_population` of data type `NUMBER`, which represents the new population value to be assigned to that country. The procedure's sole operation is to perform an `UPDATE` statement on the `COUNTRY` table. This `UPDATE` statement modifies the `POPULATION` column, setting its value to the value provided by the `para_new_population` parameter. The `UPDATE` operation is conditionally applied, affecting only those rows in the `COUNTRY` table where the value in the `COUNTRY_ID` column matches the value provided by the `para_country_id` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_country_population(para_country_id NUMBER, para_new_population NUMBER) IS \nBEGIN \n  UPDATE COUNTRY SET POPULATION = para_new_population WHERE COUNTRY_ID = para_country_id; \nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  update_country_population(1, 8300000);\n  commit;\nEND;",
      "BEGIN\n  update_country_population(2, 5300000);\n  commit;\nEND;",
      "BEGIN\n  update_country_population(3, 9100000);\n  commit;\nEND;",
      "BEGIN\n  update_country_population(1, 8400000);\n  commit;\nEND;",
      "BEGIN\n  update_country_population(2, 5400000);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named UPDATE_COUNTRY_POPULATION to update a country's population. It takes a country ID and a new population value. Update the POPULATION column in the COUNTRY table for the row matching the given country ID.",
    "natural_language": "Please construct a stored procedure designated as UPDATE_COUNTRY_POPULATION. This procedure shall be responsible for modifying the population data of a specified country. It must accept two input parameters: a country identifier and a new population figure. The procedure's operation is to update the POPULATION column within the COUNTRY table for the record corresponding to the provided country ID.",
    "id": 173
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes a single parameter, para_roller_coaster_id of type NUMBER, and performs a delete operation on the ROLLER_COASTER table. The procedure removes the row from the ROLLER_COASTER table where the value in the ROLLER_COASTER_ID column matches the value provided in the para_roller_coaster_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_roller_coaster(para_roller_coaster_id NUMBER) IS \nBEGIN \n  DELETE FROM ROLLER_COASTER WHERE ROLLER_COASTER_ID = para_roller_coaster_id; \nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  delete_roller_coaster(1);\n  commit;\nEND;",
      "BEGIN\n  delete_roller_coaster(2);\n  commit;\nEND;",
      "BEGIN\n  delete_roller_coaster(3);\n  commit;\nEND;",
      "BEGIN\n  delete_roller_coaster(4);\n  commit;\nEND;",
      "BEGIN\n  delete_roller_coaster(5);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure to delete a roller coaster. It takes a roller coaster ID as a parameter. Delete the row from the ROLLER_COASTER table where the ROLLER_COASTER_ID matches the given parameter.",
    "natural_language": "Develop a stored procedure that permanently removes a roller coaster record from the database. This procedure should accept a single input parameter, specifically the unique identifier for the roller coaster. The procedure's logic must locate and delete the corresponding entry in the ROLLER_COASTER table where the ROLLER_COASTER_ID column value precisely matches the provided identifier parameter.",
    "id": 174
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes two parameters, para_roller_coaster_id of type NUMBER and para_new_status of type VARCHAR2, and updates the STATUS column in the ROLLER_COASTER table to the value of para_new_status for the row where the ROLLER_COASTER_ID column matches the value of para_roller_coaster_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_roller_coaster_status(para_roller_coaster_id NUMBER, para_new_status VARCHAR2) IS \nBEGIN \n  UPDATE ROLLER_COASTER SET STATUS = para_new_status WHERE ROLLER_COASTER_ID = para_roller_coaster_id; \nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  update_roller_coaster_status(1, 'Under Maintenance');\n  commit;\nEND;",
      "BEGIN\n  update_roller_coaster_status(2, 'Closed');\n  commit;\nEND;",
      "BEGIN\n  update_roller_coaster_status(3, 'Operating');\n  commit;\nEND;",
      "BEGIN\n  update_roller_coaster_status(1, 'Closed');\n  commit;\nEND;",
      "BEGIN\n  update_roller_coaster_status(2, 'Under Maintenance');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure to update a roller coaster's status. It takes a roller coaster ID and a new status as parameters. Update the STATUS column in the ROLLER_COASTER table for the row where the ROLLER_COASTER_ID matches the given ID.",
    "natural_language": "Develop a comprehensive stored procedure that meticulously updates the operational status of a specific roller coaster. This procedure should accept two distinct input parameters: the unique identifier for the targeted roller coaster and the precise new status value to be assigned. The core logic must execute an update command on the ROLLER_COASTER table, specifically modifying the STATUS column for the single record whose ROLLER_COASTER_ID perfectly corresponds to the provided identifier.",
    "id": 175
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_church_continuation` that accepts three input parameters: `p_church_id` of type `NUMBER`, representing a church identifier; `p_continuation_name` of type `VARCHAR2`, representing the name of a church from which another church might be a continuation; and `p_organizer` of type `VARCHAR2`, representing the organizer of a church. The procedure first declares two local variables: `v_exists` of type `NUMBER`, intended to store a count, and `v_year` of type `NUMBER`, intended to store a year. It then performs a `SELECT` operation to count the number of rows in the `CHURCH` table where the `CONTINUATION_OF` column matches the value provided in the `p_continuation_name` parameter, storing this count into the `v_exists` variable. Subsequently, it performs another `SELECT` operation on the `DUAL` table to extract the year component from the current system date (`CURRENT_DATE`) using the `EXTRACT(YEAR FROM ...)` function, storing this year into the `v_year` variable. Following these data retrieval operations, the procedure enters a conditional block. If the value of `v_exists` is greater than 2, it executes a `DELETE` statement, removing rows from the `CHURCH` table where the `CHURCH_ID` column matches the value provided in the `p_church_id` parameter. If the condition `v_exists > 2` is false, the procedure checks if `v_exists` is equal to 1. If `v_exists` is equal to 1, it executes an `INSERT` statement, adding a new row to the `CHURCH` table with the following values: `p_church_id` for the `CHURCH_ID` column, the literal string 'New Branch' for the `NAME` column, `p_organizer` for the `ORGANIZED_BY` column, `v_year` for the `OPEN_DATE` column, and `p_continuation_name` for the `CONTINUATION_OF` column. If neither `v_exists > 2` nor `v_exists = 1` is true (meaning `v_exists` is 0 or any other value not covered by the previous conditions), the procedure executes a final `INSERT` statement, adding a new row to the `CHURCH` table with the following values: `p_church_id + 100` for the `CHURCH_ID` column, the literal string 'Main Church' for the `NAME` column, `p_organizer` for the `ORGANIZED_BY` column, `v_year` for the `OPEN_DATE` column, and `NULL` for the `CONTINUATION_OF` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_church_continuation(\n    p_church_id NUMBER,\n    p_continuation_name VARCHAR2,\n    p_organizer VARCHAR2\n)\nIS\n    v_exists NUMBER;\n    v_year NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM CHURCH WHERE CONTINUATION_OF = p_continuation_name;\n    SELECT EXTRACT(YEAR FROM CURRENT_DATE) INTO v_year FROM DUAL;\n    IF v_exists > 2 THEN\n        DELETE FROM CHURCH WHERE CHURCH_ID = p_church_id;\n    ELSIF v_exists = 1 THEN\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n        VALUES (p_church_id, 'New Branch', p_organizer, v_year, p_continuation_name);\n    ELSE\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n        VALUES (p_church_id + 100, 'Main Church', p_organizer, v_year, NULL);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  process_church_continuation(1, 'Church of Christ', 'Wycam Clark');\nEND;",
      "BEGIN\n  process_church_continuation(2, 'Independent Church', ' Hoton');\nEND;",
      "BEGIN\n  process_church_continuation(3, 'Pure Church of Christ', 'Ezra Booth');\nEND;",
      "BEGIN\n  process_church_continuation(4, 'Church of the Latter Day Saint...', 'John Smith');\nEND;",
      "BEGIN\n  process_church_continuation(5, 'Another Continuation', 'Jane Doe');\nEND;"
    ],
    "summary": "Create a stored procedure named `process_church_continuation` that accepts a church ID, a continuation name, and an organizer. It checks how many churches already list the given name as their continuation. If more than two exist, delete the church with the given ID. If exactly one exists, insert a new 'New Branch' church record with the current year as the open date. Otherwise, insert a new 'Main Church' record with a modified ID and a NULL continuation field.",
    "natural_language": "Create procedure `process_church_continuation` with church ID, continuation name, and organizer. If the name appears for over two churches, delete the given ID. If exactly one, insert a 'New Branch' record with this year's open date. Otherwise, insert a 'Main Church' record with a modified ID and NULL continuation.",
    "id": 176
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_wedding_records that accepts three parameters: p_church_id of type NUMBER, p_year_limit of type NUMBER, and p_country_filter of type VARCHAR2. The procedure begins by declaring two local variables, v_male_count and v_female_count, both of type NUMBER. It then executes a SELECT statement to count the number of male individuals in the PEOPLE table where the COUNTRY column matches the value of p_country_filter and the IS_MALE column is 'T', storing the result in v_male_count. Similarly, it counts the number of female individuals in the PEOPLE table with the same COUNTRY filter and IS_MALE column set to 'F', storing this count in v_female_count. The procedure then evaluates a series of conditional statements: if v_male_count is greater than v_female_count, it deletes records from the WEDDING table where the CHURCH_ID matches p_church_id and the YEAR is less than p_year_limit. If v_female_count is greater than v_male_count, it inserts a new record into the WEDDING table with the CHURCH_ID set to p_church_id, MALE_ID and FEMALE_ID both set to PEOPLE_ID and PEOPLE_ID + 1 respectively from the first male individual in the PEOPLE table matching the COUNTRY filter, and the YEAR set to the current year extracted from the system date. If the counts are equal, it deletes all records from the WEDDING table where the CHURCH_ID matches p_church_id, and inserts a new record into the PEOPLE table with PEOPLE_ID set to one greater than the current maximum PEOPLE_ID, NAME set to 'Balanced Entry', COUNTRY set to p_country_filter, IS_MALE set to 'T', and AGE set to 30.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_wedding_records(\n    p_church_id NUMBER,\n    p_year_limit NUMBER,\n    p_country_filter VARCHAR2\n)\nIS\n    v_male_count NUMBER;\n    v_female_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_male_count FROM PEOPLE WHERE COUNTRY = p_country_filter AND IS_MALE = 'T';\n    SELECT COUNT(*) INTO v_female_count FROM PEOPLE WHERE COUNTRY = p_country_filter AND IS_MALE = 'F';\n    IF v_male_count > v_female_count THEN\n        DELETE FROM WEDDING WHERE CHURCH_ID = p_church_id AND YEAR < p_year_limit;\n    ELSIF v_female_count > v_male_count THEN\n        INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n        SELECT p_church_id, PEOPLE_ID, PEOPLE_ID + 1, EXTRACT(YEAR FROM CURRENT_DATE)\n        FROM PEOPLE WHERE COUNTRY = p_country_filter AND IS_MALE = 'T' AND ROWNUM = 1;\n    ELSE\n        DELETE FROM WEDDING WHERE CHURCH_ID = p_church_id;\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Balanced Entry', p_country_filter, 'T', 30);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  manage_wedding_records(1, 2010, 'United States');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(2, 2015, 'Canada');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(3, 2000, 'Sweden');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(1, 2020, 'United Kingdom');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(5, 2018, 'Australia');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `manage_wedding_records` that accepts a church ID, a year limit, and a country filter. It counts males and females from that country. If there are more males, delete old weddings for that church before the year limit. If there are more females, insert a new wedding record for the current year using the first matching male and female. If counts are equal, delete all weddings for that church and insert a new 'Balanced Entry' person record.",
    "natural_language": "Alright, so we need a stored procedure called `manage_wedding_records`. You'll feed it a church ID, a cutoff year, and a country to filter by. First, it tallies up how many guys and gals are from that country. If there are more dudes, it wipes out any old weddings for that church that happened before the year limit. If there are more ladies, it adds a fresh wedding record for this year, pairing up the first available guy and girl from the list. If the counts are dead even, it does a clean sweepdeletes all weddings for that church and then pops in a new 'Balanced Entry' person record.",
    "id": 177
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sync_people_weddings that accepts three parameters: p_country of type VARCHAR2, p_min_age of type NUMBER, and p_church_id of type NUMBER. The procedure begins by declaring two local variables, v_people_exists and v_wedding_exists, both of type NUMBER. It then executes a SELECT statement to count the number of rows in the PEOPLE table where the COUNTRY column matches the value of p_country and the AGE column is greater than or equal to p_min_age, storing the result in v_people_exists. Another SELECT statement counts the number of rows in the WEDDING table where the CHURCH_ID column matches p_church_id, storing this count in v_wedding_exists. The procedure then evaluates a series of conditional statements: if v_people_exists is greater than 10, it deletes up to 5 rows from the PEOPLE table where the COUNTRY matches p_country, the AGE is greater than or equal to p_min_age, and the ROWNUM is less than or equal to 5. If v_wedding_exists equals 0 and v_people_exists is at least 2, it inserts a new row into the WEDDING table with the CHURCH_ID set to p_church_id, the MALE_ID set to the PEOPLE_ID of the first male person from the PEOPLE table matching the specified country and age criteria, the FEMALE_ID set to the PEOPLE_ID of the first female person from the same criteria, and the YEAR set to the current year extracted from the system date. If neither of the previous conditions is met, the procedure inserts two new rows into the PEOPLE table: the first with a PEOPLE_ID one greater than the current maximum PEOPLE_ID, the NAME 'Sync Person', the specified country, male gender, and the specified minimum age; the second with a PEOPLE_ID two greater than the current maximum PEOPLE_ID, the NAME 'Sync Partner', the specified country, female gender, and the specified minimum age.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_people_weddings(\n    p_country VARCHAR2,\n    p_min_age NUMBER,\n    p_church_id NUMBER\n)\nIS\n    v_people_exists NUMBER;\n    v_wedding_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_people_exists FROM PEOPLE WHERE COUNTRY = p_country AND AGE >= p_min_age;\n    SELECT COUNT(*) INTO v_wedding_exists FROM WEDDING WHERE CHURCH_ID = p_church_id;\n    IF v_people_exists > 10 THEN\n        DELETE FROM PEOPLE WHERE COUNTRY = p_country AND AGE >= p_min_age AND ROWNUM <= 5;\n    ELSIF v_wedding_exists = 0 AND v_people_exists >= 2 THEN\n        INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n        SELECT p_church_id, \n               (SELECT PEOPLE_ID FROM PEOPLE WHERE COUNTRY = p_country AND IS_MALE = 'T' AND AGE >= p_min_age AND ROWNUM = 1),\n               (SELECT PEOPLE_ID FROM PEOPLE WHERE COUNTRY = p_country AND IS_MALE = 'F' AND AGE >= p_min_age AND ROWNUM = 1),\n               EXTRACT(YEAR FROM CURRENT_DATE)\n        FROM DUAL;\n    ELSE\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Sync Person', p_country, 'T', p_min_age);\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 2 FROM PEOPLE), 'Sync Partner', p_country, 'F', p_min_age);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  sync_people_weddings('United States', 18, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sync_people_weddings('Canada', 25, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  sync_people_weddings('Sweden', 30, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sync_people_weddings('United States', 21, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sync_people_weddings('Canada', 40, 10);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `sync_people_weddings` that accepts a country, a minimum age, and a church ID. It counts people from that country above the age and weddings for that church. If more than 10 people exist, delete up to 5 of them. If no weddings exist and at least 2 people exist, create a wedding for the current year using the first matching male and female. Otherwise, insert two new 'Sync' person records.",
    "natural_language": "Create procedure sync_people_weddings with country, min age, church id. Count people from country above age and weddings for church. If people > 10, delete 5. If weddings = 0 and people >= 2, create wedding this year using first male and female. Else, insert two 'Sync' persons.",
    "id": 178
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_church_operations that accepts three input parameters: a numeric parameter p_year, a variable-length string parameter p_organizer_pattern, and a variable-length string parameter p_country. The procedure begins by declaring two local numeric variables, v_church_records and v_people_records. It first queries the CHURCH table to count the number of records where the OPEN_DATE column equals the p_year parameter value, storing the result in v_church_records. It then queries the PEOPLE table to count the number of records where the COUNTRY column equals the p_country parameter value, storing the result in v_people_records. The procedure then executes a conditional IF-ELSIF-ELSE block. If v_church_records is greater than 3, it deletes from the CHURCH table all rows where the OPEN_DATE equals p_year and the ORGANIZED_BY column contains the p_organizer_pattern string (using a LIKE pattern with wildcards '%' before and after the pattern). Following this deletion, it inserts a new record into the CHURCH table with a CHURCH_ID calculated as the maximum existing CHURCH_ID plus one, a NAME of 'Consolidated Church', an ORGANIZED_BY value of 'System', and an OPEN_DATE set to the current year extracted from the system date using the EXTRACT(YEAR FROM CURRENT_DATE) function. If the first condition is false and v_people_records is greater than v_church_records, the procedure deletes from the WEDDING table all rows where the CHURCH_ID matches any CHURCH_ID from the CHURCH table where OPEN_DATE equals p_year. It then inserts into the PEOPLE table new records by selecting from the PEOPLE table where COUNTRY equals p_country, limiting the selection to the first two rows (using ROWNUM <= 2), and transforming the data by adding 1000 to the original PEOPLE_ID value while keeping the original NAME, COUNTRY, IS_MALE, and AGE values. If neither of the previous conditions is true, the procedure executes an ELSE block which first deletes from the PEOPLE table all rows where COUNTRY equals p_country, and then deletes from the WEDDING table all rows where the CHURCH_ID is found in the result set of a subquery selecting CHURCH_ID from the CHURCH table where OPEN_DATE equals p_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_church_operations(\n    p_year NUMBER,\n    p_organizer_pattern VARCHAR2,\n    p_country VARCHAR2\n)\nIS\n    v_church_records NUMBER;\n    v_people_records NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_church_records FROM CHURCH WHERE OPEN_DATE = p_year;\n    SELECT COUNT(*) INTO v_people_records FROM PEOPLE WHERE COUNTRY = p_country;\n    IF v_church_records > 3 THEN\n        DELETE FROM CHURCH WHERE OPEN_DATE = p_year AND ORGANIZED_BY LIKE '%' || p_organizer_pattern || '%';\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE)\n        VALUES ((SELECT MAX(CHURCH_ID) + 1 FROM CHURCH), 'Consolidated Church', 'System', EXTRACT(YEAR FROM CURRENT_DATE));\n    ELSIF v_people_records > v_church_records THEN\n        DELETE FROM WEDDING WHERE CHURCH_ID IN (SELECT CHURCH_ID FROM CHURCH WHERE OPEN_DATE = p_year);\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        SELECT PEOPLE_ID + 1000, NAME, COUNTRY, IS_MALE, AGE\n        FROM PEOPLE WHERE COUNTRY = p_country AND ROWNUM <= 2;\n    ELSE\n        DELETE FROM PEOPLE WHERE COUNTRY = p_country;\n        DELETE FROM WEDDING WHERE CHURCH_ID IN (SELECT CHURCH_ID FROM CHURCH WHERE OPEN_DATE = p_year);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  consolidate_church_operations(1831, 'Clark', 'Canada');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1832, 'Booth', 'United States');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1836, 'Hoton', 'Sweden');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1840, 'Smith', 'United Kingdom');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1820, 'Jones', 'Australia');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `consolidate_church_operations` that accepts a year, an organizer name pattern, and a country. It counts churches opened in that year and people from that country. If more than 3 churches exist, delete those matching the organizer pattern and insert a new 'Consolidated Church'. If more people exist than churches, delete weddings for churches from that year and duplicate the first two people with modified IDs. Otherwise, delete all people from the country and weddings for churches from that year.",
    "natural_language": "Create a stored procedure called `consolidate_church_operations` that takes a year, a kind of organizer name, and a country. It should figure out roughly how many churches started around that year and get a count of individuals associated with that country. If there are quite a few churches, maybe more than a handful, remove the ones that sort of match the organizer description and add a new 'Consolidated Church' entry. If the number of people seems notably larger than the church count, then clean up the wedding records for churches from that general time and copy the first couple of people with tweaked IDs. If neither of those cases fits, just clear out all the people linked to that country and remove the wedding info for churches from around that year.",
    "id": 179
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `CalculateUniversityScores` that does not accept any parameters. This procedure is designed to calculate and update a `TOTAL` score for each university based on its `REPUTATION_POINT`, `RESEARCH_POINT`, and `CITATION_POINT` values. The procedure begins by declaring a local cursor named `c_university` which selects the `UNIVERSITY_ID` from the `UNIVERSITY` table. It also declares several local variables: `v_university_id` of type `NUMBER` to store the university identifier, `v_reputation_point` of type `NUMBER` to store the reputation score, `v_research_point` of type `NUMBER` to store the research score, `v_citation_point` of type `NUMBER` to store the citation score, and `v_total_score` of type `NUMBER` to store the calculated total score.\n\nThe procedure then opens the `c_university` cursor. It enters a loop that fetches each `UNIVERSITY_ID` from the `c_university` cursor into the `v_university_id` variable. The loop continues until no more rows are found in the cursor, at which point it exits. Inside the loop, for each `v_university_id` fetched, the procedure executes a `SELECT` statement to retrieve the `REPUTATION_POINT`, `RESEARCH_POINT`, and `CITATION_POINT` columns from the `OVERALL_RANKING` table. These values are then stored into the `v_reputation_point`, `v_research_point`, and `v_citation_point` variables, respectively, for the row where `UNIVERSITY_ID` matches the current `v_university_id`.\n\nFollowing this, a conditional logic block determines how `v_total_score` is calculated:\n1. If `v_reputation_point` is greater than `3`, `v_total_score` is calculated as `v_reputation_point` multiplied by `2`, plus `v_research_point`, plus `v_citation_point`.\n2. Else if `v_research_point` is greater than `2`, `v_total_score` is calculated as `v_reputation_point`, plus `v_research_point` multiplied by `2`, plus `v_citation_point`.\n3. Otherwise (if neither of the above conditions is met), `v_total_score` is calculated as `v_reputation_point`, plus `v_research_point`, plus `v_citation_point` multiplied by `2`.\n\nAfter `v_total_score` is determined, an `UPDATE` statement is executed. This statement updates the `TOTAL` column in the `OVERALL_RANKING` table to the newly calculated `v_total_score` for the row where `UNIVERSITY_ID` matches the current `v_university_id`. After processing all universities, the loop terminates, and the `c_university` cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE CalculateUniversityScores IS\n  CURSOR c_university IS\n    SELECT UNIVERSITY_ID FROM UNIVERSITY;\n  v_university_id NUMBER;\n  v_reputation_point NUMBER;\n  v_research_point NUMBER;\n  v_citation_point NUMBER;\n  v_total_score NUMBER;\nBEGIN\n  OPEN c_university;\n  LOOP\n    FETCH c_university INTO v_university_id;\n    EXIT WHEN c_university%NOTFOUND;\n    SELECT REPUTATION_POINT, RESEARCH_POINT, CITATION_POINT\n    INTO v_reputation_point, v_research_point, v_citation_point\n    FROM OVERALL_RANKING\n    WHERE UNIVERSITY_ID = v_university_id;\n    \n    IF v_reputation_point > 3 THEN\n      v_total_score := v_reputation_point * 2 + v_research_point + v_citation_point;\n    ELSIF v_research_point > 2 THEN\n      v_total_score := v_reputation_point + v_research_point * 2 + v_citation_point;\n    ELSE\n      v_total_score := v_reputation_point + v_research_point + v_citation_point * 2;\n    END IF;\n    \n    UPDATE OVERALL_RANKING SET TOTAL = v_total_score WHERE UNIVERSITY_ID = v_university_id;\n  END LOOP;\n  CLOSE c_university;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  CalculateUniversityScores;\n  commit;\nEND;"
    ],
    "summary": "Create a parameterless stored procedure named `CalculateUniversityScores`. For each university, fetch its reputation, research, and citation points. Calculate a total score: if reputation > 3, weight it double; else if research > 2, weight research double; otherwise, weight citations double. Update the `OVERALL_RANKING` table with the calculated total for each university.",
    "natural_language": "Create a stored procedure called `CalculateUniversityScores` without parameters. For every university, retrieve its reputation, research, and citation points. Compute a total score by applying these rules: double the weight of reputation if it's greater than 3; otherwise, double the weight of research if it's greater than 2; if neither applies, double the weight of citations. Use this calculated total to update the `OVERALL_RANKING` table for each corresponding university.",
    "id": 180
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `AdjustEnrollmentByState` that does not accept any input parameters. This procedure first declares a cursor named `c_state` which is designed to select all distinct values from the `STATE` column of the `UNIVERSITY` table. It also declares a local variable `v_state` of type `VARCHAR2(255)` to hold the state name fetched from the cursor, and another local variable `v_enrollment_adjustment` of type `NUMBER` to store the calculated enrollment adjustment value. The procedure then opens the `c_state` cursor. It enters a loop where it fetches one `STATE` value at a time from `c_state` into the `v_state` variable. The loop continues until no more rows are found in the cursor, at which point it exits. Inside this main loop, a conditional block determines the value of `v_enrollment_adjustment`: if `v_state` is equal to the string literal 'Illinois', `v_enrollment_adjustment` is set to `100`; if `v_state` is equal to the string literal 'Wisconsin', `v_enrollment_adjustment` is set to `200`; for any other value of `v_state`, `v_enrollment_adjustment` is set to `50`. Following this conditional assignment, an inner `FOR` loop is initiated. This inner loop iterates over each row returned by a `SELECT` statement that retrieves the `UNIVERSITY_ID` and `ENROLLMENT` columns from the `UNIVERSITY` table where the `STATE` column matches the current `v_state`. For each row (`r`) retrieved by this inner `SELECT` statement, an `UPDATE` operation is performed on the `UNIVERSITY` table. This `UPDATE` statement sets the `ENROLLMENT` column to the sum of the current `ENROLLMENT` value (from `r.ENROLLMENT`) and the `v_enrollment_adjustment` value. The `UPDATE` is applied to the specific row where the `UNIVERSITY_ID` column matches `r.UNIVERSITY_ID`. After the inner `FOR` loop completes for a given `v_state`, the main loop continues to fetch the next distinct state. Once the main loop finishes (when `c_state%NOTFOUND` is true), the `c_state` cursor is explicitly closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE AdjustEnrollmentByState IS\n  CURSOR c_state IS\n    SELECT DISTINCT STATE FROM UNIVERSITY;\n  v_state VARCHAR2(255);\n  v_enrollment_adjustment NUMBER;\nBEGIN\n  OPEN c_state;\n  LOOP\n    FETCH c_state INTO v_state;\n    EXIT WHEN c_state%NOTFOUND;\n    \n    IF v_state = 'Illinois' THEN\n      v_enrollment_adjustment := 100;\n    ELSIF v_state = 'Wisconsin' THEN\n      v_enrollment_adjustment := 200;\n    ELSE\n      v_enrollment_adjustment := 50;\n    END IF;\n    \n    FOR r IN (SELECT UNIVERSITY_ID, ENROLLMENT FROM UNIVERSITY WHERE STATE = v_state) LOOP\n      UPDATE UNIVERSITY SET ENROLLMENT = r.ENROLLMENT + v_enrollment_adjustment WHERE UNIVERSITY_ID = r.UNIVERSITY_ID;\n    END LOOP;\n  END LOOP;\n  CLOSE c_state;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  AdjustEnrollmentByState;\nEND;"
    ],
    "summary": "Create a stored procedure named AdjustEnrollmentByState with no parameters. For each distinct state in the UNIVERSITY table, calculate an enrollment adjustment: 100 for 'Illinois', 200 for 'Wisconsin', and 50 for all others. Then, for each university in that state, update its ENROLLMENT by adding the calculated adjustment.",
    "natural_language": "Hey, can you whip up a stored procedure called AdjustEnrollmentByState that doesn't need any parameters? Here's the deal: look at all the different states in the UNIVERSITY table. For each one, figure out an enrollment bump: give Illinois an extra 100, Wisconsin gets 200, and every other state gets 50. Then, for every university in a given state, just add that state's bump to its current ENROLLMENT number.",
    "id": 181
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named CalculateMajorPopularity that iterates over each major in the MAJOR table by using a cursor named c_major, which selects the MAJOR_ID from the MAJOR table. For each major, it retrieves the number of universities and the total rank associated with that major from the MAJOR_RANKING table, storing these values in the variables v_university_count and v_total_rank, respectively. If the count of universities, v_university_count, is greater than zero, it calculates the average rank, v_average_rank, by dividing v_total_rank by v_university_count; otherwise, it sets v_average_rank to zero. Based on the value of v_average_rank, it updates the MAJOR_CODE in the MAJOR table for the current MAJOR_ID: if v_average_rank is less than 5, it increments MAJOR_CODE by 1; if v_average_rank is between 5 and 10 inclusive, it increments MAJOR_CODE by 2; otherwise, it increments MAJOR_CODE by 3. The procedure continues this process for each major until all records have been processed, at which point it closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE CalculateMajorPopularity IS\n  CURSOR c_major IS\n    SELECT MAJOR_ID FROM MAJOR;\n  v_major_id NUMBER;\n  v_university_count NUMBER;\n  v_total_rank NUMBER;\n  v_average_rank NUMBER;\nBEGIN\n  OPEN c_major;\n  LOOP\n    FETCH c_major INTO v_major_id;\n    EXIT WHEN c_major%NOTFOUND;\n    \n    SELECT COUNT(UNIVERSITY_ID), SUM(RANK)\n    INTO v_university_count, v_total_rank\n    FROM MAJOR_RANKING\n    WHERE MAJOR_ID = v_major_id;\n    \n    IF v_university_count > 0 THEN\n      v_average_rank := v_total_rank / v_university_count;\n    ELSE\n      v_average_rank := 0;\n    END IF;\n    \n    IF v_average_rank < 5 THEN\n      UPDATE MAJOR SET MAJOR_CODE = MAJOR_CODE + 1 WHERE MAJOR_ID = v_major_id;\n    ELSIF v_average_rank BETWEEN 5 AND 10 THEN\n      UPDATE MAJOR SET MAJOR_CODE = MAJOR_CODE + 2 WHERE MAJOR_ID = v_major_id;\n    ELSE\n      UPDATE MAJOR SET MAJOR_CODE = MAJOR_CODE + 3 WHERE MAJOR_ID = v_major_id;\n    END IF;\n  END LOOP;\n  CLOSE c_major;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  CalculateMajorPopularity;\nEND;"
    ],
    "summary": "Create a stored procedure named CalculateMajorPopularity. For each major, calculate the average rank from the MAJOR_RANKING table. Based on the average rank, update the MAJOR_CODE in the MAJOR table: increment by 1 if average rank < 5, by 2 if between 5 and 10 inclusive, and by 3 otherwise.",
    "natural_language": "Create a stored procedure called CalculateMajorPopularity. For every major, compute the average rank from the MAJOR_RANKING table. Then, update the MAJOR_CODE in the MAJOR table based on that average: increase it by 1 if the average rank is below 5, by 2 if it is between 5 and 10 inclusive, and by 3 otherwise.",
    "id": 182
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateUniversityAffiliation that declares an explicit cursor named c_university to select the UNIVERSITY_ID column of type NUMBER and the AFFILIATION column of type VARCHAR2(255) from the UNIVERSITY table, then opens this cursor and enters a loop where it fetches each row's values into local variables v_university_id and v_affiliation, exiting the loop when no more rows are found, and for each fetched row, checks if the v_affiliation value starts with the string 'Private' using the LIKE operator, and if true, executes an UPDATE statement on the UNIVERSITY table to set the AFFILIATION column to the exact string 'Private' for the specific row where the UNIVERSITY_ID column equals the current v_university_id value, or else if the v_affiliation value starts with the string 'Public', executes an UPDATE to set AFFILIATION to 'Public' for that matching UNIVERSITY_ID, or else for any other affiliation value, executes an UPDATE to set AFFILIATION to 'Other' for that matching UNIVERSITY_ID, and after the loop ends, closes the cursor c_university.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateUniversityAffiliation IS\n  CURSOR c_university IS\n    SELECT UNIVERSITY_ID, AFFILIATION FROM UNIVERSITY;\n  v_university_id NUMBER;\n  v_affiliation VARCHAR2(255);\nBEGIN\n  OPEN c_university;\n  LOOP\n    FETCH c_university INTO v_university_id, v_affiliation;\n    EXIT WHEN c_university%NOTFOUND;\n    \n    IF v_affiliation LIKE 'Private%' THEN\n      UPDATE UNIVERSITY SET AFFILIATION = 'Private' WHERE UNIVERSITY_ID = v_university_id;\n    ELSIF v_affiliation LIKE 'Public%' THEN\n      UPDATE UNIVERSITY SET AFFILIATION = 'Public' WHERE UNIVERSITY_ID = v_university_id;\n    ELSE\n      UPDATE UNIVERSITY SET AFFILIATION = 'Other' WHERE UNIVERSITY_ID = v_university_id;\n    END IF;\n  END LOOP;\n  CLOSE c_university;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateUniversityAffiliation;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateUniversityAffiliation. For each university, check its AFFILIATION value. Update the AFFILIATION column to 'Private' if it starts with 'Private', to 'Public' if it starts with 'Public', and to 'Other' for all other cases.",
    "natural_language": "Create a stored procedure called UpdateUniversityAffiliation. For each university, look at its AFFILIATION entry. Change the AFFILIATION to something like 'Private' if it begins with that sort of term, to 'Public' if it seems to start with that, and for anything else that doesn't really fit those, set it to 'Other'.",
    "id": 183
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_process_claim_payment that accepts a single input parameter p_claim_id of type NUMBER, which identifies a specific claim, and then performs the following operations: first, it declares two local variables, v_payment_id and v_count, both of type NUMBER, initializing v_count to zero; it then queries the PAYMENTS table to find the current maximum value in the PAYMENT_ID column, uses the NVL function to convert a potential NULL result to zero, adds one to this value, and stores the result in v_payment_id to generate the next sequential payment identifier; subsequently, it opens a cursor FOR LOOP that selects the SETTLEMENT_ID and AMOUNT_SETTLED columns from the SETTLEMENTS table for every row where the CLAIM_ID column matches the provided input parameter p_claim_id; for each record fetched from this cursor, it executes an INSERT statement into the PAYMENTS table, populating the PAYMENT_ID column with the current value of v_payment_id, the SETTLEMENT_ID column with the rec.SETTLEMENT_ID from the cursor, the PAYMENT_METHOD_CODE column with the literal string 'BankTransfer', the DATE_PAYMENT_MADE column with the current system date converted to a string in 'YYYY-MM-DD' format using the TO_CHAR and SYSDATE functions, and the AMOUNT_PAYMENT column with the rec.AMOUNT_SETTLED from the cursor; after each insert, it increments the v_payment_id variable by one and increments the v_count variable by one to track the number of processed settlements; after the loop completes, it checks if v_count is equal to zero, and if so, it uses DBMS_OUTPUT.PUT_LINE to display a message stating 'No settlements found for claim ID: ' concatenated with the value of p_claim_id; the procedure includes an EXCEPTION handler that catches any exception with the WHEN OTHERS clause and simply re-raises the caught exception using the RAISE statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_process_claim_payment(p_claim_id NUMBER) IS\n   v_payment_id NUMBER;\n   v_count NUMBER := 0;\nBEGIN\n   -- Get the next payment ID by finding the maximum existing ID and adding 1\n   SELECT NVL(MAX(PAYMENT_ID), 0) + 1 INTO v_payment_id FROM PAYMENTS;\n   \n   FOR rec IN (SELECT s.SETTLEMENT_ID, s.AMOUNT_SETTLED\n               FROM SETTLEMENTS s\n               WHERE s.CLAIM_ID = p_claim_id)\n   LOOP\n      INSERT INTO PAYMENTS (PAYMENT_ID, SETTLEMENT_ID, PAYMENT_METHOD_CODE, DATE_PAYMENT_MADE, AMOUNT_PAYMENT)\n      VALUES (v_payment_id, rec.SETTLEMENT_ID, 'BankTransfer', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), rec.AMOUNT_SETTLED);\n      \n      v_payment_id := v_payment_id + 1;\n      v_count := v_count + 1;\n   END LOOP;\n   \n   IF v_count = 0 THEN\n      DBMS_OUTPUT.PUT_LINE('No settlements found for claim ID: ' || p_claim_id);\n   END IF;\nEXCEPTION\n   WHEN OTHERS THEN\n      RAISE;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "BEGIN\n   sp_process_claim_payment(143);\n   COMMIT;\nEND;",
      "BEGIN\n   sp_process_claim_payment(423);\n   COMMIT;\nEND;",
      "BEGIN\n   sp_process_claim_payment(442);\n   COMMIT;\nEND;",
      "BEGIN\n   sp_process_claim_payment(486);\n   COMMIT;\nEND;",
      "BEGIN\n   sp_process_claim_payment(621);\n   COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_process_claim_payment that accepts a claim ID (p_claim_id). For each settlement linked to that claim, insert a payment record into the PAYMENTS table with a sequentially generated PAYMENT_ID, 'BankTransfer' as the method, today's date, and the settled amount. If no settlements are found, output a message. Include an exception handler to re-raise any errors.",
    "natural_language": "Make a stored procedure called sp_process_claim_payment that takes a claim ID. For any settlements connected to that claim, add entries to the PAYMENTS table. Use a generated number for the payment ID, put 'BankTransfer' as the method, use today's date, and the amount that was settled. If there aren't really any settlements to speak of, then show a message. Also, handle any unexpected problems that might come up.",
    "id": 184
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_validate_policy_claims that performs two distinct operations. First, it declares a local variable v_xml_result of type XMLTYPE. It then executes a SELECT statement using the XMLQUERY function to process a hard-coded XML document. The XML document is constructed in-line using XMLTYPE and contains a root element POLICIES with two child POLICY elements. The first POLICY element has a POLICY_ID child with value 119 and a CLAIMS child containing a single CLAIM_ID child with value 143. The second POLICY element has a POLICY_ID child with value 141 and an empty CLAIMS child element. The XMLQUERY expression uses an XQuery FLWOR expression to filter this XML: it selects all POLICY nodes from the document, and for each one, it applies a condition where the count of its child CLAIMS nodes must be greater than zero, returning only the POLICY nodes that satisfy this condition. The result of this query, which is an XML fragment containing the filtered policies wrapped in a new policies root element, is assigned to the local variable v_xml_result by selecting from the DUAL table. The second operation is a DELETE statement that removes rows from the CUSTOMER_POLICIES table, aliased as cp. The deletion condition uses a NOT EXISTS subquery: for each row in CUSTOMER_POLICIES, it checks the CLAIMS table, aliased as c, to see if there is at least one row where the CLAIMS.POLICY_ID column matches the CUSTOMER_POLICIES.POLICY_ID column from the outer query. If no matching row exists in the CLAIMS table for a given policy, that row is deleted from the CUSTOMER_POLICIES table.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_validate_policy_claims IS\n   v_xml_result XMLTYPE;\nBEGIN\n   SELECT XMLQUERY(\n      '<policies>\n         {\n            for $p in //POLICY\n            where count($p/CLAIMS) > 0\n            return $p\n         }\n       </policies>'\n      PASSING XMLTYPE(\n         '<POLICIES>\n            <POLICY>\n               <POLICY_ID>119</POLICY_ID>\n               <CLAIMS>\n                  <CLAIM_ID>143</CLAIM_ID>\n               </CLAIMS>\n            </POLICY>\n            <POLICY>\n               <POLICY_ID>141</POLICY_ID>\n               <CLAIMS/>\n            </POLICY>\n         </POLICIES>'\n      )\n      RETURNING CONTENT\n   )\n   INTO v_xml_result\n   FROM DUAL;\n\n   DELETE FROM CUSTOMER_POLICIES cp\n   WHERE NOT EXISTS (\n      SELECT 1 FROM CLAIMS c WHERE c.POLICY_ID = cp.POLICY_ID\n   );\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_validate_policy_claims;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_validate_policy_claims. First, use XMLQUERY to filter an inline XML document, selecting only POLICY elements that have at least one CLAIMS child, and store the result in an XMLTYPE variable. Second, delete records from the CUSTOMER_POLICIES table where no corresponding claim exists in the CLAIMS table for the same POLICY_ID.",
    "natural_language": "Alright, so we need to whip up a stored procedure called sp_validate_policy_claims. First off, grab that inline XML doc and use XMLQUERY to pick out just the POLICY bits that have at least one CLAIMS tag hanging off 'em, and shove that result into an XMLTYPE variable. After that, we gotta clean up the CUSTOMER_POLICIES table by getting rid of any records where there's no matching claim in the CLAIMS table for the same POLICY_ID.",
    "id": 185
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `InsertOldestConferenceParticipation` that does not accept any input parameters and does not return any values. This procedure first declares a local variable named `v_conference_id` of data type `NUMBER` to temporarily store a conference identifier. The procedure then executes a `SELECT` statement to retrieve a single `CONFERENCE_ID` value from the `CONFERENCE` table. This `SELECT` statement is designed to find the `CONFERENCE_ID` associated with the earliest year recorded in the `CONFERENCE` table. Specifically, it selects `CONFERENCE_ID` from `CONFERENCE` where the `YEAR` column matches the minimum `YEAR` found across all records in the `CONFERENCE` table, as determined by a subquery `(SELECT MIN(YEAR) FROM CONFERENCE)`. In cases where multiple conferences might exist in the same earliest year, the `ROWNUM = 1` condition is applied to arbitrarily select only one such `CONFERENCE_ID`. The retrieved `CONFERENCE_ID` is then stored into the `v_conference_id` local variable. Following this, the procedure executes an `INSERT` statement to populate the `CONFERENCE_PARTICIPATION` table. This `INSERT` statement inserts new records into the `CONFERENCE_PARTICIPATION` table by selecting data from the `STAFF` table. For each record inserted, the `CONFERENCE_ID` column is populated with the value stored in the `v_conference_id` variable, the `STAFF_ID` column is populated with the `STAFF_ID` from the `STAFF` table, and the `ROLE` column is populated with the literal string value `'Participant'`. The `SELECT` statement that provides the data for the `INSERT` operation filters records from the `STAFF` table, including only those staff members where the `AGE` column has a value greater than `40`.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertOldestConferenceParticipation\nIS\n   v_conference_id NUMBER;\nBEGIN\n   SELECT CONFERENCE_ID INTO v_conference_id\n   FROM CONFERENCE\n   WHERE YEAR = (SELECT MIN(YEAR) FROM CONFERENCE)\n   AND ROWNUM = 1;\n   \n   INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE)\n   SELECT v_conference_id, STAFF_ID, 'Participant'\n   FROM STAFF\n   WHERE AGE > 40;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  InsertOldestConferenceParticipation;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named InsertOldestConferenceParticipation with no parameters. It inserts records into CONFERENCE_PARTICIPATION for all staff over 40, assigning them the role 'Participant' for the conference with the earliest year (selecting one if multiple exist).",
    "natural_language": "Please construct a stored procedure designated as 'InsertOldestConferenceParticipation'. This procedure shall accept no parameters. Its function is to insert entries into the CONFERENCE_PARTICIPATION table for every staff member whose age exceeds 40 years. Each inserted record must assign the role 'Participant' and associate the staff member with the conference occurring in the earliest available year; in instances where multiple conferences share this earliest year, a single conference must be selected for the association.",
    "id": 186
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteYoungStaffParticipation that performs a delete operation on the CONFERENCE_PARTICIPATION table. This procedure does not take any parameters. The operation deletes rows from the CONFERENCE_PARTICIPATION table where the STAFF_ID column matches any STAFF_ID found in the STAFF table for staff members whose AGE column value is less than 25. The procedure begins by executing a DELETE statement targeting the CONFERENCE_PARTICIPATION table. Within the WHERE clause of this DELETE statement, a subquery is used to select STAFF_IDs from the STAFF table. This subquery filters the STAFF table to include only those rows where the AGE column is less than 25, effectively identifying staff members who are younger than 25 years old. The main DELETE operation then removes all records from the CONFERENCE_PARTICIPATION table that have a STAFF_ID matching any of the STAFF_IDs returned by the subquery. The procedure does not perform any other operations, such as updates, inserts, or function calls, and does not include any conditional statements beyond the subquery condition.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteYoungStaffParticipation\nIS\nBEGIN\n   DELETE FROM CONFERENCE_PARTICIPATION\n   WHERE STAFF_ID IN (SELECT STAFF_ID FROM STAFF WHERE AGE < 25);\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteYoungStaffParticipation;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteYoungStaffParticipation with no parameters. It deletes records from the CONFERENCE_PARTICIPATION table for any staff member whose age is less than 25.",
    "natural_language": "How can I create a stored procedure called DeleteYoungStaffParticipation, with no parameters, to delete records from the CONFERENCE_PARTICIPATION table for staff members under the age of 25?",
    "id": 187
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateStaffNationality that does not take any parameters and is designed to update the STAFF table. The procedure sets the NATIONALITY column to the value 'International' for all rows where the INSTITUTION_ID column equals 1. The procedure begins by declaring a local variable v_new_nationality of type VARCHAR2 with a maximum length of 255 characters, initializing it with the string 'International'. The main operation within the procedure is an UPDATE statement that modifies the STAFF table. Specifically, it changes the NATIONALITY column to the value stored in v_new_nationality for every row that satisfies the condition of having an INSTITUTION_ID equal to 1. The procedure does not include any conditional logic, function calls, or special operations beyond the basic assignment and update of values.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateStaffNationality\nIS\n   v_new_nationality VARCHAR2(255) := 'International';\nBEGIN\n   UPDATE STAFF\n   SET NATIONALITY = v_new_nationality\n   WHERE INSTITUTION_ID = 1;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateStaffNationality;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateStaffNationality with no parameters. It updates the STAFF table, setting the NATIONALITY to 'International' for all records where INSTITUTION_ID equals 1.",
    "natural_language": "Create a stored procedure called UpdateStaffNationality that doesn't need any inputs. It should adjust the STAFF table, changing the NATIONALITY to 'International' for those records where the INSTITUTION_ID is around the common default value.",
    "id": 188
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewCountryRecord that accepts two input parameters: a character string parameter named p_country_name and a numeric parameter named p_population. The procedure first declares a local numeric variable named v_new_id. It then executes a SELECT statement on the COUNTRY table to calculate a new identifier by taking the maximum existing value from the COUNTRY_ID column, using the COALESCE function to substitute a value of 0 if the maximum is null, and adding 1 to that result, storing the final calculated value into the local variable v_new_id. Following this calculation, the procedure performs an INSERT operation into the COUNTRY table, specifying the columns COUNTRY_ID, NAME, POPULATION, AREA, and LANGUAGES. The inserted values are: the newly generated v_new_id for COUNTRY_ID, the input parameter p_country_name for NAME, the input parameter p_population for POPULATION, a literal numeric value of 0 for AREA, and a literal character string 'Unknown' for the LANGUAGES column.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewCountryRecord(\n  p_country_name IN VARCHAR2,\n  p_population IN NUMBER\n)\nIS\n  v_new_id NUMBER;\nBEGIN\n  SELECT COALESCE(MAX(COUNTRY_ID), 0) + 1 INTO v_new_id FROM COUNTRY;\n  \n  INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES)\n  VALUES (v_new_id, p_country_name, p_population, 0, 'Unknown');\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewCountryRecord('France', 65000000);\nEND;",
      "BEGIN\n  InsertNewCountryRecord('Germany', 83000000);\nEND;",
      "BEGIN\n  InsertNewCountryRecord('Spain', 47000000);\nEND;",
      "BEGIN\n  InsertNewCountryRecord('Italy', 59000000);\nEND;",
      "BEGIN\n  InsertNewCountryRecord('United Kingdom', 67000000);\nEND;"
    ],
    "summary": "Create a stored procedure named InsertNewCountryRecord that accepts parameters p_country_name (VARCHAR2) and p_population (NUMBER). It generates a new COUNTRY_ID as the maximum existing ID plus one, then inserts a new country record with the provided name and population, setting AREA to 0 and LANGUAGES to 'Unknown'.",
    "natural_language": "Write a stored procedure called InsertNewCountryRecord that takes p_country_name (VARCHAR2) and p_population (NUMBER) as parameters. Have it generate a new COUNTRY_ID by adding one to the current maximum ID, then insert a new record using the given name and population, setting AREA to 0 and LANGUAGES to 'Unknown'.",
    "id": 189
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `DeleteCoastersByStatus` that accepts two input parameters: `p_status_pattern`, which is of data type `VARCHAR2` and is intended to represent a pattern to match against the status of roller coasters, and `p_country_id`, which is of data type `NUMBER` and is intended to represent the unique identifier of a country. The procedure's sole operation is to perform a `DELETE` statement on the `ROLLER_COASTER` table. This `DELETE` operation targets rows in the `ROLLER_COASTER` table where two conditions are met simultaneously. The first condition requires that the value in the `STATUS` column of the `ROLLER_COASTER` table matches the pattern constructed by concatenating a wildcard character (`%`), the value provided in the `p_status_pattern` input parameter, and another wildcard character (`%`). This effectively means that the `STATUS` column must contain the `p_status_pattern` string anywhere within its value. The second condition requires that the value in the `COUNTRY_ID` column of the `ROLLER_COASTER` table is exactly equal to the value provided in the `p_country_id` input parameter. Only those rows that satisfy both of these conditions will be removed from the `ROLLER_COASTER` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteCoastersByStatus(\n  p_status_pattern IN VARCHAR2,\n  p_country_id IN NUMBER\n)\nIS\nBEGIN\n  DELETE FROM ROLLER_COASTER\n  WHERE STATUS LIKE '%' || p_status_pattern || '%'\n    AND COUNTRY_ID = p_country_id;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteCoastersByStatus('Operating', 1);\nEND;",
      "BEGIN\n  DeleteCoastersByStatus('Closed', 2);\nEND;",
      "BEGIN\n  DeleteCoastersByStatus('Under Construction', 3);\nEND;",
      "BEGIN\n  DeleteCoastersByStatus('SBNO', 1);\nEND;",
      "BEGIN\n  DeleteCoastersByStatus('Operating', 3);\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteCoastersByStatus that accepts parameters p_status_pattern (VARCHAR2) and p_country_id (NUMBER). It deletes records from the ROLLER_COASTER table where the STATUS contains the provided pattern and the COUNTRY_ID matches the provided value.",
    "natural_language": "Delete roller coasters where status matches pattern and country matches ID.",
    "id": 190
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateCoasterParkNames` that accepts two input parameters: `p_old_park_part` of data type `VARCHAR2`, which represents a substring to be found within existing park names, and `p_new_park_part` of data type `VARCHAR2`, which represents the replacement substring for `p_old_park_part`. The procedure performs a single `UPDATE` operation on the `ROLLER_COASTER` table. This `UPDATE` statement modifies the `PARK` column for all rows where the `PARK` column's current value contains the substring specified by `p_old_park_part`. The modification involves replacing all occurrences of the substring `p_old_park_part` within the `PARK` column's value with the substring specified by `p_new_park_part`. This replacement is achieved using the `REPLACE` SQL function, which takes three arguments: the original string (`PARK` column), the substring to be replaced (`p_old_park_part`), and the replacement substring (`p_new_park_part`). The `WHERE` clause filters the rows to be updated by checking if the `PARK` column `LIKE`s a pattern constructed by concatenating the wildcard character `%`, the value of `p_old_park_part`, and another wildcard character `%`. This `LIKE` condition ensures that only rows where the `PARK` column explicitly contains `p_old_park_part` are considered for the update.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCoasterParkNames(\n  p_old_park_part IN VARCHAR2,\n  p_new_park_part IN VARCHAR2\n)\nIS\nBEGIN\n  UPDATE ROLLER_COASTER\n  SET PARK = REPLACE(PARK, p_old_park_part, p_new_park_part)\n  WHERE PARK LIKE '%' || p_old_park_part || '%';\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCoasterParkNames('Valley', 'Park');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateCoasterParkNames('Boardwalk', 'Promenade');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateCoasterParkNames('Mt.', 'Mountain');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateCoasterParkNames('Olympus', 'Peak');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateCoasterParkNames('Happy', 'Joyful');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateCoasterParkNames that updates the PARK column in the ROLLER_COASTER table. It replaces all occurrences of a specified old substring (p_old_park_part) with a new substring (p_new_park_part) in the PARK values that contain the old substring.",
    "natural_language": "Hey, can you whip up a stored procedure called UpdateCoasterParkNames? What it needs to do is go into the ROLLER_COASTER table and fix up the PARK column. Basically, if a park name has a certain old bit of text (that's p_old_park_part), swap it out for a new bit (p_new_park_part) wherever it shows up.",
    "id": 191
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named MergeCountryPopulationData that accepts two parameters: p_country_name of type VARCHAR2, which represents the name of a country, and p_population_adjustment of type NUMBER, which indicates the adjustment to be made to the population of the specified country. The procedure performs a MERGE operation on the COUNTRY table. It uses a subquery to select the provided country name from the DUAL table, aliasing it as country_name, and matches it against the NAME column in the COUNTRY table, ensuring case insensitivity by applying the UPPER() function to both the NAME column and the input parameter. If a match is found (WHEN MATCHED), the procedure updates the POPULATION column of the matched row by adding the value of p_population_adjustment to the current population. If no match is found (WHEN NOT MATCHED), the procedure inserts a new row into the COUNTRY table with the following values: COUNTRY_ID is set to one more than the current maximum COUNTRY_ID in the table, or 1 if the table is empty, using the COALESCE() function to handle nulls; NAME is set to the value of p_country_name; POPULATION is set to the value of p_population_adjustment; AREA is set to 0; and LANGUAGES is set to 'Unknown'.",
    "plsql": "CREATE OR REPLACE PROCEDURE MergeCountryPopulationData(\n  p_country_name IN VARCHAR2,\n  p_population_adjustment IN NUMBER\n)\nIS\nBEGIN\n  MERGE INTO COUNTRY c\n  USING (SELECT p_country_name AS country_name FROM DUAL) src\n  ON (UPPER(c.NAME) = UPPER(src.country_name))\n  WHEN MATCHED THEN\n    UPDATE SET c.POPULATION = c.POPULATION + p_population_adjustment\n  WHEN NOT MATCHED THEN\n    INSERT (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES)\n    VALUES ((SELECT COALESCE(MAX(COUNTRY_ID), 0) + 1 FROM COUNTRY), \n            p_country_name, p_population_adjustment, 0, 'Unknown');\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  MergeCountryPopulationData('Austria', 100000);\nEND;",
      "BEGIN\n  MergeCountryPopulationData('Finland', -50000);\nEND;",
      "BEGIN\n  MergeCountryPopulationData('Sweden', 25000);\nEND;",
      "BEGIN\n  MergeCountryPopulationData('Germany', 1000000);\nEND;",
      "BEGIN\n  MergeCountryPopulationData('France', 500000);\nEND;"
    ],
    "summary": "Create a stored procedure named MergeCountryPopulationData that merges data into the COUNTRY table. For a given country name (p_country_name), if it exists (case-insensitive match), update its population by adding p_population_adjustment. If it does not exist, insert a new row with a generated COUNTRY_ID, the given name, the adjustment as the population, an AREA of 0, and 'Unknown' for LANGUAGES.",
    "natural_language": "Develop a stored procedure called MergeCountryPopulationData that is designed to merge data into the COUNTRY table. For any specified country name, provided as the parameter p_country_name, if an entry for that country already exists in the tableusing a case-insensitive comparison to find a matchthen you should update its current population figure by incrementing it with the value supplied in the p_population_adjustment parameter. Conversely, if no such country is found, the procedure must insert a completely new row, which will include a uniquely generated COUNTRY_ID, the provided country name, the adjustment value set as the initial population, a default AREA of 0, and the LANGUAGES column populated with the placeholder text 'Unknown'.",
    "id": 192
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `InsertMovieRating` that accepts three input parameters: `p_mid` of type `NUMBER`, representing a movie identifier; `p_rid` of type `NUMBER`, representing a reviewer identifier; and `p_stars` of type `NUMBER`, representing the rating in stars. The procedure begins by declaring two local variables: `v_movie_count` of type `NUMBER` and `v_reviewer_count` of type `NUMBER`. It then proceeds to execute a `SELECT` statement to count the number of rows in the `MOVIE` table where the `MID` column matches the value provided in the `p_mid` input parameter, storing the result in `v_movie_count`. Subsequently, it executes another `SELECT` statement to count the number of rows in the `REVIEWER` table where the `RID` column matches the value provided in the `p_rid` input parameter, storing this result in `v_reviewer_count`. Following these checks, the procedure evaluates a conditional `IF` statement. If `v_movie_count` is greater than 0 AND `v_reviewer_count` is greater than 0, indicating that both the movie and the reviewer already exist in their respective tables, the procedure executes an `INSERT` statement to add a new record into the `RATING` table. This `INSERT` statement populates the `RID` column with the value from `p_rid`, the `MID` column with the value from `p_mid`, the `STARS` column with the value from `p_stars`, and the `RATINGDATE` column with the current system date formatted as 'YYYY-MM-DD' using the `TO_CHAR` function applied to `SYSDATE`. If the initial `IF` condition is false, the procedure then evaluates an `ELSIF` condition. If `v_movie_count` is equal to 0, meaning the movie does not exist, the procedure first executes an `INSERT` statement to add a new record into the `MOVIE` table. This `INSERT` statement populates the `MID` column with the value from `p_mid`, the `TITLE` column with the literal string 'Unknown Movie', the `YEAR` column with the year extracted from the current system date using `EXTRACT(YEAR FROM SYSDATE)`, and the `DIRECTOR` column with the literal string 'Unknown Director'. After inserting the new movie, the procedure then executes a second `INSERT` statement to add a new record into the `RATING` table, populating the `RID` column with `p_rid`, the `MID` column with `p_mid`, the `STARS` column with `p_stars`, and the `RATINGDATE` column with the current system date formatted as 'YYYY-MM-DD' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`. If both the initial `IF` and the `ELSIF` conditions are false, implying that `v_movie_count` is not 0 but `v_reviewer_count` must be 0 (since the `v_movie_count > 0 AND v_reviewer_count > 0` condition was false and `v_movie_count = 0` was also false), the procedure executes an `ELSE` block. Within this `ELSE` block, it first executes an `INSERT` statement to add a new record into the `REVIEWER` table. This `INSERT` statement populates the `RID` column with the value from `p_rid` and the `NAME` column with the literal string 'Anonymous Reviewer'. After inserting the new reviewer, the procedure then executes a second `INSERT` statement to add a new record into the `RATING` table, populating the `RID` column with `p_rid`, the `MID` column with `p_mid`, the `STARS` column with `p_stars`, and the `RATINGDATE` column with the current system date formatted as 'YYYY-MM-DD' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertMovieRating(\n    p_mid IN NUMBER,\n    p_rid IN NUMBER,\n    p_stars IN NUMBER\n) AS\n    v_movie_count NUMBER;\n    v_reviewer_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_movie_count FROM MOVIE WHERE MID = p_mid;\n    SELECT COUNT(*) INTO v_reviewer_count FROM REVIEWER WHERE RID = p_rid;\n    \n    IF v_movie_count > 0 AND v_reviewer_count > 0 THEN\n        INSERT INTO RATING (RID, MID, STARS, RATINGDATE)\n        VALUES (p_rid, p_mid, p_stars, TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n    ELSIF v_movie_count = 0 THEN\n        INSERT INTO MOVIE (MID, TITLE, YEAR, DIRECTOR)\n        VALUES (p_mid, 'Unknown Movie', EXTRACT(YEAR FROM SYSDATE), 'Unknown Director');\n        INSERT INTO RATING (RID, MID, STARS, RATINGDATE)\n        VALUES (p_rid, p_mid, p_stars, TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n    ELSE\n        INSERT INTO REVIEWER (RID, NAME)\n        VALUES (p_rid, 'Anonymous Reviewer');\n        INSERT INTO RATING (RID, MID, STARS, RATINGDATE)\n        VALUES (p_rid, p_mid, p_stars, TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "BEGIN\n  InsertMovieRating(101, 201, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  InsertMovieRating(102, 202, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  InsertMovieRating(103, 203, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  InsertMovieRating(104, 204, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  InsertMovieRating(105, 205, 2);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named InsertMovieRating to insert a movie rating. Check if the movie (p_mid) and reviewer (p_rid) exist. If both exist, insert the rating. If the movie doesn't exist, first insert a default movie record, then insert the rating. If the reviewer doesn't exist, first insert a default reviewer record, then insert the rating. The RATINGDATE is set to the current date.",
    "natural_language": "Hey, can you whip up a stored procedure called InsertMovieRating to add a movie rating? First, you gotta check if the movie (using p_mid) and the reviewer (using p_rid) are already in the system. If they're both there, just pop the rating in. If the movie's not found, you'll need to add a basic movie record first, then put the rating in. Same deal if the reviewer's missingadd a default reviewer record, then the rating. Oh, and set the RATINGDATE to today's date.",
    "id": 193
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateReviewerRatings that accepts three input parameters: p_old_rid of type NUMBER representing the original reviewer ID, p_new_rid of type NUMBER representing the new reviewer ID, and p_min_stars of type NUMBER representing a minimum star rating threshold. The procedure first declares two local variables: v_rating_count of type NUMBER and v_new_name of type VARCHAR2 with a length of 255 characters. It begins execution by querying the RATING table to count the number of rows where the RID column equals the input parameter p_old_rid and the STARS column is greater than or equal to the input parameter p_min_stars, storing the result in v_rating_count. If the value of v_rating_count is greater than zero, the procedure proceeds to query the REVIEWER table, selecting the NAME column for the row where the RID column equals the input parameter p_new_rid, and stores this value in v_new_name. Following this, the procedure deletes all rows from the RATING table where the RID column equals p_old_rid and the STARS column is greater than or equal to p_min_stars. Subsequently, it inserts new rows into the RATING table, specifying columns RID, MID, STARS, and RATINGDATE, by selecting data from the RATING table where the RID column equals p_old_rid and the STARS column is greater than or equal to p_min_stars, but for each selected row, it uses p_new_rid as the value for the RID column in the new insert, while the MID, STARS, and RATINGDATE values are copied directly from the selected rows.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateReviewerRatings(\n    p_old_rid IN NUMBER,\n    p_new_rid IN NUMBER,\n    p_min_stars IN NUMBER\n) AS\n    v_rating_count NUMBER;\n    v_new_name VARCHAR2(255);\nBEGIN\n    SELECT COUNT(*) INTO v_rating_count \n    FROM RATING \n    WHERE RID = p_old_rid AND STARS >= p_min_stars;\n    \n    IF v_rating_count > 0 THEN\n        SELECT NAME INTO v_new_name FROM REVIEWER WHERE RID = p_new_rid;\n        \n        DELETE FROM RATING \n        WHERE RID = p_old_rid AND STARS >= p_min_stars;\n        \n        INSERT INTO RATING (RID, MID, STARS, RATINGDATE)\n        SELECT p_new_rid, MID, STARS, RATINGDATE\n        FROM RATING \n        WHERE RID = p_old_rid AND STARS >= p_min_stars;\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateReviewerRatings(201, 202, 3);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(203, 201, 4);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(202, 203, 1);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(201, 202, 5);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(203, 201, 2);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateReviewerRatings to transfer ratings from one reviewer (p_old_rid) to another (p_new_rid). It transfers only ratings with stars greater than or equal to p_min_stars. First, verify the new reviewer's name exists. Then, delete the qualifying ratings for the old reviewer and insert them with the new reviewer's ID.",
    "natural_language": "Create procedure UpdateReviewerRatings to move ratings from reviewer p_old_rid to p_new_rid for ratings with at least p_min_stars. Check new reviewer exists first, then delete old ratings and insert them under the new ID.",
    "id": 194
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named MergeDuplicateMovies that accepts three input parameters: p_source_mid of type NUMBER representing the movie ID to be merged away, p_target_mid of type NUMBER representing the movie ID to be kept, and p_keep_ratings of type VARCHAR2 specifying which set of user ratings to preserve. The procedure first queries the MOVIE table to count rows where the MID column equals p_source_mid, storing the result in variable v_source_exists, and similarly counts rows where MID equals p_target_mid, storing the result in v_target_exists. If both counts are exactly one, confirming both source and target movies exist uniquely, the procedure proceeds based on the p_keep_ratings value: if p_keep_ratings is 'SOURCE', it deletes all rows from the RATING table where the MID column equals p_target_mid, then updates all rows in the RATING table where MID equals p_source_mid, changing their MID to p_target_mid; if p_keep_ratings is 'TARGET', it deletes all rows from the RATING table where MID equals p_source_mid; for any other value of p_keep_ratings, it deletes all rows from the RATING table where MID equals p_source_mid and also deletes all rows where MID equals p_target_mid. Finally, after handling the ratings, the procedure deletes the row from the MOVIE table where the MID column equals p_source_mid.",
    "plsql": "CREATE OR REPLACE PROCEDURE MergeDuplicateMovies(\n    p_source_mid IN NUMBER,\n    p_target_mid IN NUMBER,\n    p_keep_ratings IN VARCHAR2\n) AS\n    v_source_exists NUMBER;\n    v_target_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_source_exists FROM MOVIE WHERE MID = p_source_mid;\n    SELECT COUNT(*) INTO v_target_exists FROM MOVIE WHERE MID = p_target_mid;\n    \n    IF v_source_exists = 1 AND v_target_exists = 1 THEN\n        IF p_keep_ratings = 'SOURCE' THEN\n            DELETE FROM RATING WHERE MID = p_target_mid;\n            UPDATE RATING SET MID = p_target_mid WHERE MID = p_source_mid;\n        ELSIF p_keep_ratings = 'TARGET' THEN\n            DELETE FROM RATING WHERE MID = p_source_mid;\n        ELSE\n            DELETE FROM RATING WHERE MID = p_source_mid;\n            DELETE FROM RATING WHERE MID = p_target_mid;\n        END IF;\n        \n        DELETE FROM MOVIE WHERE MID = p_source_mid;\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "BEGIN\n  MergeDuplicateMovies(101, 102, 'SOURCE');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(103, 104, 'TARGET');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(105, 106, 'NONE');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(107, 108, 'SOURCE');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(109, 110, 'TARGET');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named MergeDuplicateMovies to merge two movie records. It confirms both source (p_source_mid) and target (p_target_mid) movies exist. Based on the p_keep_ratings parameter ('SOURCE', 'TARGET', or other), it manages the RATING table to keep the specified ratings, delete others, and updates ratings to point to the target movie ID. Finally, it deletes the source movie record.",
    "natural_language": "How can I create a stored procedure named MergeDuplicateMovies to merge two movie records, ensuring both the source (p_source_mid) and target (p_target_mid) movies exist, and based on the p_keep_ratings parameter ('SOURCE', 'TARGET', or other), manage the RATING table to keep the specified ratings, delete others, update ratings to point to the target movie ID, and finally delete the source movie record?",
    "id": 195
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named transfer_customer_data that accepts five parameters: p_source_customer_id and p_target_customer_id of type NUMBER, which represent the IDs of the source and target customers respectively; p_new_address_line, p_new_city, and p_new_zip of type VARCHAR2, which represent the new address line, city, and zip code for the target customer. The procedure begins by declaring a local variable v_max_address_id of type NUMBER to store the maximum address ID currently present in the ADDRESSES table. It then retrieves the maximum value of the ADDRESS_ID column from the ADDRESSES table and stores it in v_max_address_id. Next, the procedure inserts a new row into the ADDRESSES table with the ADDRESS_ID set to v_max_address_id plus one, LINE_1_NUMBER_BUILDING set to p_new_address_line, CITY set to p_new_city, ZIP_POSTCODE set to p_new_zip, STATE_PROVINCE_COUNTY set to 'Unknown', and COUNTRY set to 'USA'. Following this, the procedure deletes all rows from the CUSTOMER_PAYMENTS table where the CUSTOMER_ID matches p_source_customer_id. It then deletes the row from the CUSTOMERS table where the CUSTOMER_ID matches p_source_customer_id. Finally, the procedure inserts a new row into the CUSTOMER_PAYMENTS table with CUSTOMER_ID set to p_target_customer_id, DATETIME_PAYMENT set to '2023-10-10 10:10:10', PAYMENT_METHOD_CODE set to 'Transfer', and AMOUNT_PAYMENT set to 1000, using a SELECT statement from the DUAL table.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_customer_data(\n    p_source_customer_id IN NUMBER,\n    p_target_customer_id IN NUMBER,\n    p_new_address_line IN VARCHAR2,\n    p_new_city IN VARCHAR2,\n    p_new_zip IN VARCHAR2\n)\nIS\n    v_max_address_id NUMBER;\nBEGIN\n    SELECT MAX(ADDRESS_ID) INTO v_max_address_id FROM ADDRESSES;\n    \n    INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY)\n    VALUES (v_max_address_id + 1, p_new_address_line, p_new_city, p_new_zip, 'Unknown', 'USA');\n    \n    DELETE FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = p_source_customer_id;\n    \n    DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = p_source_customer_id;\n    \n    INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT)\n    SELECT p_target_customer_id, '2023-10-10 10:10:10', 'Transfer', 1000 FROM DUAL;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "ADDRESSES"
    ],
    "call_sqls": [
      "BEGIN\n  transfer_customer_data(1, 3, '123 New Street', 'New City', '12345');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(3, 4, '456 Old Road', 'Old City', '67890');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(4, 1, '789 Main Ave', 'Main City', '11223');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(1, 4, '321 Side St', 'Side City', '44556');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(3, 1, '654 Back Ln', 'Back City', '77889');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named transfer_customer_data that transfers data from a source customer to a target customer. It accepts source and target customer IDs, and a new address (line, city, zip). The procedure generates a new address ID, inserts the new address into the ADDRESSES table with default state and country, deletes the source customer's payment records and the customer record, and inserts a default payment record for the target customer.",
    "natural_language": "Create a comprehensive stored procedure named transfer_customer_data that meticulously handles the transfer of all relevant data from a specified source customer to a designated target customer. This procedure must gracefully accept the unique identifiers for both the source and target customers, along with a complete new address comprising the street line, the city, and the postal zip code. Internally, it will first generate a fresh, unique address identifier. Subsequently, it will insert the provided new address details into the ADDRESSES table, thoughtfully applying default values for the state and country fields. Following this, it will permanently remove all existing payment records associated with the source customer and then delete the source customer's main record itself. Finally, to ensure continuity, the procedure will insert a single, standardized default payment record specifically for the identified target customer.",
    "id": 196
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ADD_NEW_CUSTOMER that accepts five input parameters: a first name as a variable-length string (P_FIRST_NAME), a last name as a variable-length string (P_LAST_NAME), an email address as a variable-length string (P_EMAIL), a phone number as a variable-length string (P_PHONE), and an outstanding monetary amount as a number (P_AMOUNT_OUTSTANDING). The procedure first declares a local variable V_NEW_CUSTOMER_ID of type NUMBER. It begins execution by querying the CUSTOMERS table to find the maximum existing value in the CUSTOMER_ID column, increments that maximum value by one, and stores the result into the local variable V_NEW_CUSTOMER_ID. It then performs an INSERT operation into the CUSTOMERS table, creating a new row with the following column values: the generated V_NEW_CUSTOMER_ID for CUSTOMER_ID, the input parameter P_FIRST_NAME for FIRST_NAME, P_LAST_NAME for LAST_NAME, P_EMAIL for EMAIL_ADDRESS, P_PHONE for PHONE_NUMBER, and P_AMOUNT_OUTSTANDING for AMOUNT_OUTSTANDING. Following this, the procedure executes a second INSERT into the ADDRESSES table using a subquery in the VALUES clause; the subquery selects the maximum existing ADDRESS_ID from the ADDRESSES table, increments it by one, and uses this calculated value for the ADDRESS_ID column, while the remaining columns are populated with literal string values: 'Default Address' for LINE_1_NUMBER_BUILDING, 'Default City' for CITY, '00000' for ZIP_POSTCODE, 'Default State' for STATE_PROVINCE_COUNTY, and 'USA' for COUNTRY. Finally, the procedure executes a DELETE operation on the CUSTOMER_PAYMENTS table, removing any and all rows where the CUSTOMER_ID column matches the newly generated V_NEW_CUSTOMER_ID value.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_customer(\n    p_first_name IN VARCHAR2,\n    p_last_name IN VARCHAR2,\n    p_email IN VARCHAR2,\n    p_phone IN VARCHAR2,\n    p_amount_outstanding IN NUMBER\n)\nIS\n    v_new_customer_id NUMBER;\nBEGIN\n    SELECT MAX(CUSTOMER_ID) + 1 INTO v_new_customer_id FROM CUSTOMERS;\n    \n    INSERT INTO CUSTOMERS (CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL_ADDRESS, PHONE_NUMBER, AMOUNT_OUTSTANDING)\n    VALUES (v_new_customer_id, p_first_name, p_last_name, p_email, p_phone, p_amount_outstanding);\n    \n    INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY)\n    SELECT MAX(ADDRESS_ID) + 1, 'Default Address', 'Default City', '00000', 'Default State', 'USA' FROM ADDRESSES;\n    \n    DELETE FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = v_new_customer_id;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "ADDRESSES"
    ],
    "call_sqls": [
      "BEGIN\n  add_new_customer('John', 'Doe', 'john.doe@example.com', '123-456-7890', 500);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Jane', 'Smith', 'jane.smith@example.com', '098-765-4321', 1000);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Alice', 'Johnson', 'alice.johnson@example.com', '555-123-4567', 750);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Bob', 'Brown', 'bob.brown@example.com', '444-555-6666', 250);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Charlie', 'Davis', 'charlie.davis@example.com', '333-222-1111', 1250);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ADD_NEW_CUSTOMER that adds a new customer. It accepts first name, last name, email, phone, and outstanding amount. The procedure generates a new customer ID, inserts the customer into the CUSTOMERS table, inserts a default address into the ADDRESSES table with a generated ID, and deletes any existing payment records for the new customer ID.",
    "natural_language": "Hey, can you whip up a stored procedure called ADD_NEW_CUSTOMER to add a new customer? It should take in their first name, last name, email, phone number, and any money they owe. The procedure needs to cook up a new customer ID, drop their info into the CUSTOMERS table, also pop a default address with a fresh ID into the ADDRESSES table, and get rid of any old payment records tied to that new customer ID.",
    "id": 197
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_address` that accepts five input parameters: `p_customer_id` of type `NUMBER`, `p_new_address_line` of type `VARCHAR2`, `p_new_city` of type `VARCHAR2`, `p_new_zip` of type `VARCHAR2`, and `p_country` of type `VARCHAR2`. The purpose of this procedure is to manage customer address and payment information.\n\nThe procedure begins by declaring a local variable `v_max_address_id` of type `NUMBER`.\n\nThe first operation performed is a `SELECT` statement that retrieves the maximum value from the `ADDRESS_ID` column of the `ADDRESSES` table. This maximum value is then stored into the `v_max_address_id` local variable.\n\nFollowing this, an `INSERT` statement is executed to add a new record into the `ADDRESSES` table. The `ADDRESS_ID` column for this new record is populated with the value of `v_max_address_id` incremented by 1. The `LINE_1_NUMBER_BUILDING` column is populated with the value provided by the `p_new_address_line` input parameter. The `CITY` column is populated with the value from the `p_new_city` input parameter. The `ZIP_POSTCODE` column receives the value from the `p_new_zip` input parameter. The `STATE_PROVINCE_COUNTY` column is explicitly set to the string literal 'Unknown'. The `COUNTRY` column is populated with the value from the `p_country` input parameter.\n\nNext, a `DELETE` statement is executed to remove records from the `CUSTOMER_PAYMENTS` table. This deletion is conditional, targeting all rows where the `CUSTOMER_ID` column matches the value provided by the `p_customer_id` input parameter.\n\nImmediately after, another `DELETE` statement is executed, this time targeting the `CUSTOMERS` table. This deletion is also conditional, removing all rows where the `CUSTOMER_ID` column matches the value provided by the `p_customer_id` input parameter.\n\nFinally, an `INSERT` statement is executed to add a new record into the `CUSTOMER_PAYMENTS` table. The `CUSTOMER_ID` column for this new record is populated with the value from the `p_customer_id` input parameter. The `DATETIME_PAYMENT` column is populated with the string literal '2023-10-10 10:10:10'. The `PAYMENT_METHOD_CODE` column is populated with the string literal 'Update'. The `AMOUNT_PAYMENT` column is populated with the numeric literal 500. This `INSERT` statement uses `FROM DUAL` to generate a single row for insertion.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_address(\n    p_customer_id IN NUMBER,\n    p_new_address_line IN VARCHAR2,\n    p_new_city IN VARCHAR2,\n    p_new_zip IN VARCHAR2,\n    p_country IN VARCHAR2\n)\nIS\n    v_max_address_id NUMBER;\nBEGIN\n    SELECT MAX(ADDRESS_ID) INTO v_max_address_id FROM ADDRESSES;\n    \n    INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY)\n    VALUES (v_max_address_id + 1, p_new_address_line, p_new_city, p_new_zip, 'Unknown', p_country);\n    \n    DELETE FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = p_customer_id;\n    \n    DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    \n    INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT)\n    SELECT p_customer_id, '2023-10-10 10:10:10', 'Update', 500 FROM DUAL;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "ADDRESSES"
    ],
    "call_sqls": [
      "BEGIN\n  update_address(1, '123 Main St', 'Anytown', '12345', 'USA');\nEND;",
      "BEGIN\n  update_address(3, '456 Oak Ave', 'Otherville', '67890', 'Canada');\nEND;",
      "BEGIN\n  update_address(4, '789 Pine Ln', 'Somewhere', '11223', 'UK');\nEND;",
      "BEGIN\n  update_address(1, '10 Downing St', 'London', 'SW1A 2AA', 'UK');\nEND;",
      "BEGIN\n  update_address(3, '999 Elm Rd', 'New City', '54321', 'USA');\nEND;"
    ],
    "summary": "Create a stored procedure named update_address that updates a customer's address and related data. It accepts a customer ID, new address line, city, zip, and country. The procedure generates a new address ID, inserts the new address into the ADDRESSES table with a default state, deletes the customer's payment records and the customer record, and inserts a default payment record for the same customer ID.",
    "natural_language": "Hey, can you whip up a stored procedure called update_address that'll handle changing a customer's address and stuff? It needs to take the customer's ID, the new street, city, zip code, and country. Here's what it should do: cook up a fresh address ID, plop the new address into the ADDRESSES table (just use a default state), wipe out the customer's old payment history and their customer record, and then set up a basic default payment for that same customer ID.",
    "id": 198
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `optimize_movie_catalog` that does not accept any input parameters. This procedure declares five local numeric variables: `v_classic_movies`, `v_modern_movies`, `v_contemporary_movies`, `v_unrated_movies`, and `v_highly_rated_movies`. The procedure begins by populating these variables with counts derived from the `MOVIE` and `RATING` tables. Specifically, `v_classic_movies` is assigned the total number of records in the `MOVIE` table where the `YEAR` column is less than 1970. `v_modern_movies` is assigned the total number of records in the `MOVIE` table where the `YEAR` column is between 1970 and 1999, inclusive. `v_contemporary_movies` is assigned the total number of records in the `MOVIE` table where the `YEAR` column is greater than or equal to 2000. `v_unrated_movies` is assigned the total number of records in the `MOVIE` table where the `MID` (Movie ID) column does not exist in the distinct `MID` values found in the `RATING` table, effectively counting movies that have no ratings. `v_highly_rated_movies` is assigned the count of distinct `MID` values from the `RATING` table where the `STARS` column is greater than or equal to 4, representing the number of unique movies that have received at least one rating of 4 stars or more.\n\nFollowing these initial data retrievals, the procedure enters a series of nested conditional logic blocks. The primary condition checks if `v_classic_movies` is greater than `v_modern_movies`.\n\nIf `v_classic_movies` is indeed greater than `v_modern_movies`, a nested condition is evaluated:\n    If `v_contemporary_movies` is greater than `v_classic_movies`, another nested condition is evaluated:\n        If `v_unrated_movies` is greater than 5, then records are deleted from the `MOVIE` table where the `MID` does not exist in the `MID` values from the `RATING` table (i.e., unrated movies) AND the `YEAR` column is less than 1950.\n        Else if `v_unrated_movies` is greater than 2, then a new record is inserted into the `RATING` table. The `RID` (Reviewer ID) is set to 989, `MID` is selected from the `MOVIE` table for movies that are unrated (i.e., `MID` not in `SELECT MID FROM RATING`), `STARS` is set to 3, and `RATINGDATE` is set to the current system date formatted as 'YYYY-MM-DD' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`. This insertion is limited to the first 3 such movies found by `ROWNUM <= 3`.\n        Else (if `v_unrated_movies` is 2 or less), records are deleted from the `RATING` table where the `STARS` column is equal to 1 AND the `MID` exists in the `MID` values from the `MOVIE` table where the `YEAR` column is less than 1960.\n    Else if `v_contemporary_movies` is less than `v_modern_movies`, another nested condition is evaluated:\n        If `v_highly_rated_movies` is greater than 10, then records are deleted from the `MOVIE` table where the `MID` does not exist in the `MID` values from the `RATING` table where `STARS` is greater than or equal to 3.\n        Else (if `v_highly_rated_movies` is 10 or less), a new record is inserted into the `MOVIE` table with `MID` set to 996, `TITLE` set to 'Classic Revival', `YEAR` set to 1955, and `DIRECTOR` set to 'Vintage Director'.\n    Else (if `v_contemporary_movies` is equal to `v_classic_movies` and not less than `v_modern_movies`), another nested condition is evaluated:\n        If `v_unrated_movies` is greater than 3, then records are deleted from the `REVIEWER` table where the `RID` does not exist in the `RID` values from the `RATING` table where `STARS` is greater than or equal to 2.\n        Else (if `v_unrated_movies` is 3 or less), a new record is inserted into the `REVIEWER` table with `RID` set to 988 and `NAME` set to 'Classic Film Expert'.\n\nElse if `v_modern_movies` is greater than `v_contemporary_movies` (this is the `ELSIF` branch of the primary condition), another nested condition is evaluated:\n    If `v_highly_rated_movies` is greater than 8, then records are deleted from the `RATING` table where the `STARS` column is less than or equal to 2 AND the `MID` exists in the `MID` values from the `MOVIE` table where the `YEAR` column is between 1980 and 1990, inclusive.\n    Else (if `v_highly_rated_movies` is 8 or less), a new record is inserted into the `RATING` table with `RID` set to 987, `MID` set to 101, `STARS` set to 5, and `RATINGDATE` set to the current system date formatted as 'YYYY-MM-DD' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`.\n\nElse (if `v_classic_movies` is not greater than `v_modern_movies` AND `v_modern_movies` is not greater than `v_contemporary_movies`), another nested condition is evaluated:\n    If `v_unrated_movies` is greater than `v_highly_rated_movies`, then records are deleted from the `MOVIE` table where the `YEAR` column is less than 1940 AND the `MID` does not exist in the `MID` values from the `RATING` table (i.e., unrated movies).\n    Else (if `v_unrated_movies` is less than or equal to `v_highly_rated_movies`), a new record is inserted into the `MOVIE` table with `MID` set to 995, `TITLE` set to 'Balanced Cinema', `YEAR` set to 1985, and `DIRECTOR` set to 'Equilibrium Director'.",
    "plsql": "CREATE OR REPLACE PROCEDURE optimize_movie_catalog\nIS\n   v_classic_movies NUMBER;\n   v_modern_movies NUMBER;\n   v_contemporary_movies NUMBER;\n   v_unrated_movies NUMBER;\n   v_highly_rated_movies NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_classic_movies FROM MOVIE WHERE YEAR < 1970;\n   SELECT COUNT(*) INTO v_modern_movies FROM MOVIE WHERE YEAR BETWEEN 1970 AND 1999;\n   SELECT COUNT(*) INTO v_contemporary_movies FROM MOVIE WHERE YEAR >= 2000;\n   SELECT COUNT(*) INTO v_unrated_movies FROM MOVIE WHERE MID NOT IN (SELECT DISTINCT MID FROM RATING);\n   SELECT COUNT(DISTINCT MID) INTO v_highly_rated_movies FROM RATING WHERE STARS >= 4;\n   \n   IF v_classic_movies > v_modern_movies THEN\n      IF v_contemporary_movies > v_classic_movies THEN\n         IF v_unrated_movies > 5 THEN\n            DELETE FROM MOVIE WHERE MID NOT IN (SELECT MID FROM RATING) AND YEAR < 1950;\n         ELSIF v_unrated_movies > 2 THEN\n            INSERT INTO RATING (RID, MID, STARS, RATINGDATE) SELECT 989, MID, 3, TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM MOVIE WHERE MID NOT IN (SELECT MID FROM RATING) AND ROWNUM <= 3;\n         ELSE\n            DELETE FROM RATING WHERE STARS = 1 AND MID IN (SELECT MID FROM MOVIE WHERE YEAR < 1960);\n         END IF;\n      ELSIF v_contemporary_movies < v_modern_movies THEN\n         IF v_highly_rated_movies > 10 THEN\n            DELETE FROM MOVIE WHERE MID NOT IN (SELECT MID FROM RATING WHERE STARS >= 3);\n         ELSE\n            INSERT INTO MOVIE (MID, TITLE, YEAR, DIRECTOR) VALUES (996, 'Classic Revival', 1955, 'Vintage Director');\n         END IF;\n      ELSE\n         IF v_unrated_movies > 3 THEN\n            DELETE FROM REVIEWER WHERE RID NOT IN (SELECT RID FROM RATING WHERE STARS >= 2);\n         ELSE\n            INSERT INTO REVIEWER (RID, NAME) VALUES (988, 'Classic Film Expert');\n         END IF;\n      END IF;\n   ELSIF v_modern_movies > v_contemporary_movies THEN\n      IF v_highly_rated_movies > 8 THEN\n         DELETE FROM RATING WHERE STARS <= 2 AND MID IN (SELECT MID FROM MOVIE WHERE YEAR BETWEEN 1980 AND 1990);\n      ELSE\n         INSERT INTO RATING (RID, MID, STARS, RATINGDATE) VALUES (987, 101, 5, TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n      END IF;\n   ELSE\n      IF v_unrated_movies > v_highly_rated_movies THEN\n         DELETE FROM MOVIE WHERE YEAR < 1940 AND MID NOT IN (SELECT MID FROM RATING);\n      ELSE\n         INSERT INTO MOVIE (MID, TITLE, YEAR, DIRECTOR) VALUES (995, 'Balanced Cinema', 1985, 'Equilibrium Director');\n      END IF;\n   END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "BEGIN\n  optimize_movie_catalog;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named optimize_movie_catalog with no parameters. It calculates counts of classic, modern, contemporary, unrated, and highly-rated movies. Based on complex nested comparisons of these counts, it conditionally performs operations: deleting unrated or low-rated movies, inserting default ratings for unrated movies, inserting new movies, deleting inactive reviewers, or inserting new reviewers.",
    "natural_language": "Create a comprehensive stored procedure, which should be named optimize_movie_catalog, that does not accept any parameters. This procedure meticulously calculates the precise counts for several distinct movie categories: classic films, modern films, contemporary films, unrated films, and highly-rated films. Subsequently, it engages in a sophisticated, multi-layered evaluation by performing complex nested comparisons of these meticulously gathered counts. Based on the intricate outcomes of these detailed comparisons, it then conditionally executes a series of specific database operations. These operations may include, but are not limited to, the deletion of unrated or low-rated movies, the insertion of default rating values for those movies lacking a rating, the insertion of entirely new movie entries, the deletion of reviewers who have been inactive, or the insertion of new reviewers into the system.",
    "id": 199
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateCatalogPrice that accepts three input parameters: p_catalog_entry_id, p_new_price_in_dollars, and p_catalog_level_number, all of which are of the NUMBER data type. The procedure updates the CATALOG_CONTENTS table by setting the PRICE_IN_DOLLARS column to the value provided in the p_new_price_in_dollars parameter. This update operation is performed only for the row where the CATALOG_ENTRY_ID column matches the value of the p_catalog_entry_id parameter and the CATALOG_LEVEL_NUMBER column matches the value of the p_catalog_level_number parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCatalogPrice(\n    p_catalog_entry_id IN NUMBER,\n    p_new_price_in_dollars IN NUMBER,\n    p_catalog_level_number IN NUMBER\n) AS\nBEGIN\n    UPDATE CATALOG_CONTENTS\n    SET PRICE_IN_DOLLARS = p_new_price_in_dollars\n    WHERE CATALOG_ENTRY_ID = p_catalog_entry_id\n    AND CATALOG_LEVEL_NUMBER = p_catalog_level_number;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCatalogPrice(1, 250.00, 1);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(2, 700.00, 8);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(3, 400.00, 1);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(1, 300.00, 8);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(2, 750.00, 1);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateCatalogPrice that updates the price of a specific catalog entry. It accepts a catalog entry ID, a new price, and a catalog level number. The procedure updates the PRICE_IN_DOLLARS in the CATALOG_CONTENTS table for the row matching both the provided entry ID and level number.",
    "natural_language": "Update catalog price for a given entry ID and level.",
    "id": 200
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteCatalogEntry that is designed to remove specific entries from the CATALOG_CONTENTS table based on given criteria. This procedure accepts three parameters: p_catalog_entry_id, p_catalog_level_number, and p_deleted_rows. The first parameter, p_catalog_entry_id, is of type NUMBER and represents the unique identifier of the catalog entry to be deleted. The second parameter, p_catalog_level_number, also of type NUMBER, specifies the level number of the catalog entry that needs to be matched for deletion. The third parameter, p_deleted_rows, is an OUT parameter of type NUMBER, which will be used to return the count of rows that were deleted during the execution of the procedure. The procedure begins by executing a DELETE operation on the CATALOG_CONTENTS table, targeting rows where the CATALOG_ENTRY_ID column matches the value of p_catalog_entry_id and the CATALOG_LEVEL_NUMBER column matches the value of p_catalog_level_number. After the DELETE operation is performed, the procedure assigns the number of rows affected by the DELETE operation to the p_deleted_rows parameter using the SQL%ROWCOUNT attribute, which provides the count of rows processed by the most recent SQL statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteCatalogEntry(\n    p_catalog_entry_id IN NUMBER,\n    p_catalog_level_number IN NUMBER,\n    p_deleted_rows OUT NUMBER\n) AS\nBEGIN\n    DELETE FROM CATALOG_CONTENTS\n    WHERE CATALOG_ENTRY_ID = p_catalog_entry_id\n    AND CATALOG_LEVEL_NUMBER = p_catalog_level_number;\n    \n    p_deleted_rows := SQL%ROWCOUNT;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_rows NUMBER;\nBEGIN\n  DeleteCatalogEntry(1, 1, v_deleted_rows);\n  DBMS_OUTPUT.PUT_LINE('Deleted rows: ' || v_deleted_rows);\nEND;",
      "DECLARE\n  v_deleted_rows NUMBER;\nBEGIN\n  DeleteCatalogEntry(2, 8, v_deleted_rows);\n  DBMS_OUTPUT.PUT_LINE('Deleted rows: ' || v_deleted_rows);\nEND;",
      "DECLARE\n  v_deleted_rows NUMBER;\nBEGIN\n  DeleteCatalogEntry(3, 1, v_deleted_rows);\n  DBMS_OUTPUT.PUT_LINE('Deleted rows: ' || v_deleted_rows);\nEND;",
      "DECLARE\n  v_deleted_rows NUMBER;\nBEGIN\n  DeleteCatalogEntry(5, 8, v_deleted_rows);\n  DBMS_OUTPUT.PUT_LINE('Deleted rows: ' || v_deleted_rows);\nEND;",
      "DECLARE\n  v_deleted_rows NUMBER;\nBEGIN\n  DeleteCatalogEntry(15, 9, v_deleted_rows);\n  DBMS_OUTPUT.PUT_LINE('Deleted rows: ' || v_deleted_rows);\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteCatalogEntry that deletes rows from the CATALOG_CONTENTS table where CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER match the input parameters. Return the number of deleted rows via an OUT parameter.",
    "natural_language": "Make a stored procedure called DeleteCatalogEntry that removes a few rows from the CATALOG_CONTENTS table when the CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER are somewhat similar to the given inputs. Have it send back roughly how many rows were taken out using an OUT parameter.",
    "id": 201
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateComplaintStatus that accepts two input parameters: a numeric parameter named p_complaint_id and a variable-length character string parameter named p_new_status, and executes a single SQL UPDATE statement targeting the COMPLAINTS table, specifically setting the value of the column named COMPLAINT_STATUS_CODE to the value provided in the p_new_status input parameter for the specific row where the value of the column named COMPLAINT_ID is exactly equal to the numeric value provided in the p_complaint_id input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateComplaintStatus(\n  p_complaint_id IN NUMBER,\n  p_new_status IN VARCHAR2\n) AS\nBEGIN\n  UPDATE COMPLAINTS\n  SET COMPLAINT_STATUS_CODE = p_new_status\n  WHERE COMPLAINT_ID = p_complaint_id;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateComplaintStatus(1, 'Resolved');\nEND;",
      "BEGIN\n  UpdateComplaintStatus(2, 'Pending Review');\nEND;",
      "BEGIN\n  UpdateComplaintStatus(3, 'Closed');\nEND;",
      "BEGIN\n  UpdateComplaintStatus(1, 'New');\nEND;",
      "BEGIN\n  UpdateComplaintStatus(2, 'Escalated');\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateComplaintStatus that updates the COMPLAINT_STATUS_CODE in the COMPLAINTS table for the row where COMPLAINT_ID matches the input parameter.",
    "natural_language": "Please construct a stored procedure designated as 'UpdateComplaintStatus'. Its function is to modify the 'COMPLAINT_STATUS_CODE' field within the 'COMPLAINTS' table, specifically for the record whose 'COMPLAINT_ID' corresponds to the value supplied as an input parameter.",
    "id": 202
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AssignComplaintToStaff that accepts two input parameters: p_complaint_id of type NUMBER, which represents the unique identifier of a complaint, and p_staff_id of type NUMBER, which represents the unique identifier of a staff member. The procedure performs an update operation on the COMPLAINTS table, specifically targeting the STAFF_ID column. It sets the STAFF_ID column to the value provided in the p_staff_id parameter for the row where the COMPLAINT_ID column matches the value provided in the p_complaint_id parameter. This operation effectively assigns the specified staff member to the specified complaint by updating the relevant record in the COMPLAINTS table.",
    "plsql": "CREATE OR REPLACE PROCEDURE AssignComplaintToStaff(\n  p_complaint_id IN NUMBER,\n  p_staff_id IN NUMBER\n) AS\nBEGIN\n  UPDATE COMPLAINTS\n  SET STAFF_ID = p_staff_id\n  WHERE COMPLAINT_ID = p_complaint_id;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  AssignComplaintToStaff(1, 115);\n  COMMIT;\nEND;",
      "BEGIN\n  AssignComplaintToStaff(2, 116);\n  COMMIT;\nEND;",
      "BEGIN\n  AssignComplaintToStaff(3, 117);\n  COMMIT;\nEND;",
      "BEGIN\n  AssignComplaintToStaff(1, 120);\n  COMMIT;\nEND;",
      "BEGIN\n  AssignComplaintToStaff(2, 114);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named AssignComplaintToStaff that updates the STAFF_ID in the COMPLAINTS table for the row where COMPLAINT_ID matches the input parameter.",
    "natural_language": "How can I create a stored procedure called AssignComplaintToStaff that will update the STAFF_ID in the COMPLAINTS table for the specific complaint identified by a given COMPLAINT_ID?",
    "id": 203
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp1` that accepts three input parameters: `para_title` of type `VARCHAR2`, `para_type` of type `VARCHAR2`, and `para_rating` of type `NUMBER`. The procedure's logic is controlled by a conditional statement that evaluates the value of `para_rating`. If the value of `para_rating` is strictly greater than 5, the procedure executes a `DELETE` operation. This `DELETE` operation targets rows in the `REVIEW` table where two conditions are met: first, the `RATING` column's value is less than the value provided in `para_rating`, and second, the `BOOK_ID` column's value matches the `BOOK_ID` retrieved from the `BOOK` table. The `BOOK_ID` for this second condition is determined by a subquery that selects the `BOOK_ID` from the `BOOK` table where the `TITLE` column's value is equal to the `para_title` parameter. If the value of `para_rating` is not strictly greater than 5 (i.e., it is less than or equal to 5), the procedure executes an `INSERT` operation into the `REVIEW` table. This `INSERT` operation populates the `REVIEW_ID`, `BOOK_ID`, `RATING`, `READERS_IN_MILLION`, and `RANK` columns. The `REVIEW_ID` is generated by a subquery that calculates the next available `REVIEW_ID` by selecting the maximum existing `REVIEW_ID` from the `REVIEW` table, using the `NVL` function to treat a `NULL` result (meaning no existing `REVIEW_ID`s) as 0, and then adding 1 to that result. The `BOOK_ID` is obtained by a subquery that selects the `BOOK_ID` from the `BOOK` table where the `TITLE` column's value matches the `para_title` parameter. The `RATING` column is populated with the value of the `para_rating` parameter. The `READERS_IN_MILLION` column is set to a fixed value of `1.0`. The `RANK` column is set to a fixed value of `10`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp1(para_title VARCHAR2, para_type VARCHAR2, para_rating NUMBER) IS\nBEGIN\n  IF para_rating > 5 THEN\n    DELETE FROM REVIEW WHERE RATING < para_rating AND BOOK_ID = (SELECT BOOK_ID FROM BOOK WHERE TITLE = para_title);\n  ELSE\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      (SELECT BOOK_ID FROM BOOK WHERE TITLE = para_title),\n      para_rating,\n      1.0,\n      10\n    );\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp1('A Game of Thrones', 'Novel', 6);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Clash of Kings', 'Novel', 4);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Storm of Swords', 'Novel', 7);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Game of Thrones', 'Novel', 3);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Clash of Kings', 'Novel', 8);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp1 that conditionally modifies the REVIEW table. If the input rating is greater than 5, delete reviews with a lower rating for a book matching the input title. Otherwise, insert a new review for that book with the input rating, a fixed readers value of 1.0, and a fixed rank of 10. Generate the new REVIEW_ID automatically.",
    "natural_language": "Make a stored procedure called sp1 that handles the REVIEW table in a conditional way. If the provided rating seems on the higher side, get rid of some of the less favorable reviews for a book with a title like the one given. Otherwise, just add a new review entry for that book using the provided rating, setting readers to a typical value like 1.0 and rank to something around 10. The REVIEW_ID should be created automatically.",
    "id": 204
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp2 that accepts three parameters: para_book_id of type NUMBER, para_chapters of type NUMBER, and para_rank of type NUMBER. The procedure begins by evaluating the value of para_rank. If para_rank is less than 20, it performs an INSERT operation into the REVIEW table. The INSERT statement adds a new row with the following values: REVIEW_ID, which is determined by selecting the maximum REVIEW_ID from the REVIEW table and adding 1, defaulting to 1 if no rows exist; BOOK_ID, which is set to the value of para_book_id; RATING, which is hardcoded to 5.0; READERS_IN_MILLION, which is hardcoded to 2.0; and RANK, which is set to the value of para_rank. If para_rank is 20 or greater, the procedure executes a DELETE operation on the REVIEW table, removing all rows where the BOOK_ID matches para_book_id and the RANK is greater than para_rank. The procedure does not return any values and does not handle any exceptions.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp2(para_book_id NUMBER, para_chapters NUMBER, para_rank NUMBER) IS\nBEGIN\n  IF para_rank < 20 THEN\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      para_book_id,\n      5.0,\n      2.0,\n      para_rank\n    );\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND RANK > para_rank;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp2(para_book_id => 1, para_chapters => 73, para_rank => 15);\nEND;",
      "BEGIN\n  sp2(para_book_id => 2, para_chapters => 70, para_rank => 25);\nEND;",
      "BEGIN\n  sp2(para_book_id => 3, para_chapters => 82, para_rank => 10);\nEND;",
      "BEGIN\n  sp2(para_book_id => 1, para_chapters => 73, para_rank => 30);\nEND;",
      "BEGIN\n  sp2(para_book_id => 4, para_chapters => 60, para_rank => 18);\nEND;"
    ],
    "summary": "Create a stored procedure named sp2 that conditionally modifies the REVIEW table. If the input rank is less than 20, insert a new review with the input book_id and rank, a fixed rating of 5.0, and a fixed readers value of 2.0. Otherwise, delete reviews for the input book_id where the rank is greater than the input rank. Generate the new REVIEW_ID automatically.",
    "natural_language": "Create a stored procedure called sp2 that handles the REVIEW table in a conditional way. If the provided rank is on the lower side, say, not very high, then add a new review entry for the given book. Use a pretty good fixed rating and a modest number for readers. Otherwise, if the rank is higher, clean up by removing some of the older, less prominent reviews for that book where their rank is above a certain threshold. Make sure new review IDs are created automatically.",
    "id": 205
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp3` that accepts three input parameters: `para_book_id` of data type `NUMBER`, `para_title` of data type `VARCHAR2`, and `para_readers` of data type `NUMBER`. The procedure implements a conditional logic based on the value of the `para_readers` parameter. Specifically, if the value of `para_readers` is strictly greater than 3, the procedure executes an `INSERT` operation. This `INSERT` operation adds a new row into the `REVIEW` table. The values for the columns in the new row are determined as follows: for the `REVIEW_ID` column, it calculates the maximum existing `REVIEW_ID` in the `REVIEW` table using a subquery `(SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW)`. The `NVL` function ensures that if `MAX(REVIEW_ID)` returns `NULL` (meaning the table is empty), it defaults to 0 before adding 1, effectively generating a sequential ID. For the `BOOK_ID` column, it uses the value provided by the `para_book_id` input parameter. For the `RATING` column, it inserts a fixed literal value of `7.0`. For the `READERS_IN_MILLION` column, it uses the value provided by the `para_readers` input parameter. For the `RANK` column, it inserts a fixed literal value of `15`. Conversely, if the value of `para_readers` is not strictly greater than 3 (i.e., it is less than or equal to 3), the procedure executes a `DELETE` operation. This `DELETE` operation removes rows from the `REVIEW` table where two conditions are met simultaneously: the value in the `BOOK_ID` column matches the value provided by the `para_book_id` input parameter, AND the value in the `READERS_IN_MILLION` column is strictly less than the value provided by the `para_readers` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp3(para_book_id NUMBER, para_title VARCHAR2, para_readers NUMBER) IS\nBEGIN\n  IF para_readers > 3 THEN\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      para_book_id,\n      7.0,\n      para_readers,\n      15\n    );\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION < para_readers;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp3(1, 'A Game of Thrones', 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(2, 'A Clash of Kings', 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(3, 'A Storm of Swords', 4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(4, 'A Feast for Crows', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(5, 'A Dance with Dragons', 6);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp3 with parameters para_book_id (NUMBER), para_title (VARCHAR2), and para_readers (NUMBER). If para_readers > 3, insert a new row into the REVIEW table. Generate a new REVIEW_ID as the maximum existing ID plus one (defaulting to 1 if the table is empty). Set BOOK_ID to para_book_id, RATING to 7.0, READERS_IN_MILLION to para_readers, and RANK to 15. Otherwise (if para_readers <= 3), delete rows from REVIEW where BOOK_ID equals para_book_id and READERS_IN_MILLION is less than para_readers.",
    "natural_language": "Create a stored procedure called sp3 that takes a book ID, a title, and a reader count. If the reader count seems pretty high, like more than a few, then add a new review entry. For the new review's ID, just take whatever the biggest current ID is and add one to it, or start at 1 if there aren't any yet. Use the provided book ID, set the rating to a decent score, set the readers to the given number, and assign a middling rank. On the other hand, if the reader count is on the lower side, say about three or fewer, then go ahead and remove any existing reviews for that book where the reader count is even lower than the number provided.",
    "id": 206
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp4` that accepts three input parameters: `para_title` of type `VARCHAR2`, `para_audio` of type `VARCHAR2`, and `para_rank` of type `NUMBER`. The procedure's logic is controlled by a conditional statement based on the value of `para_rank`. If the value of `para_rank` is less than 10, the procedure executes an `INSERT` operation into the `REVIEW` table. This `INSERT` statement populates the `REVIEW_ID`, `BOOK_ID`, `RATING`, `READERS_IN_MILLION`, and `RANK` columns. The `REVIEW_ID` is determined by selecting the maximum existing `REVIEW_ID` from the `REVIEW` table, using the `NVL` function to treat a `NULL` result as 0, and then adding 1 to this value, effectively generating a new sequential ID. The `BOOK_ID` is obtained by performing a `SELECT` query on the `BOOK` table, retrieving the `BOOK_ID` where the `TITLE` column matches the `para_title` input parameter. The `RATING` column is set to a fixed value of 8.0. The `READERS_IN_MILLION` column is set to a fixed value of 4.0. The `RANK` column is populated with the value of the `para_rank` input parameter. If the value of `para_rank` is not less than 10 (i.e., it is 10 or greater), the procedure executes a `DELETE` operation on the `REVIEW` table. This `DELETE` operation targets rows where the `BOOK_ID` matches the `BOOK_ID` retrieved from the `BOOK` table by selecting the `BOOK_ID` where the `TITLE` column equals the `para_title` input parameter, and additionally where the `RANK` column in the `REVIEW` table is greater than the `para_rank` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp4(para_title VARCHAR2, para_audio VARCHAR2, para_rank NUMBER) IS\nBEGIN\n  IF para_rank < 10 THEN\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      (SELECT BOOK_ID FROM BOOK WHERE TITLE = para_title),\n      8.0,\n      4.0,\n      para_rank\n    );\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = (SELECT BOOK_ID FROM BOOK WHERE TITLE = para_title) AND RANK > para_rank;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp4('A Game of Thrones', '33h 53m', 5);\nEND;",
      "BEGIN\n  sp4('A Clash of Kings', '37h 17m', 12);\nEND;",
      "BEGIN\n  sp4('A Storm of Swords', '47h 37m', 8);\nEND;",
      "BEGIN\n  sp4('A Game of Thrones', '33h 53m', 15);\nEND;",
      "BEGIN\n  sp4('A Clash of Kings', '37h 17m', 7);\nEND;"
    ],
    "summary": "Create a stored procedure named sp4 with parameters para_title (VARCHAR2), para_audio (VARCHAR2), and para_rank (NUMBER). If para_rank < 10, insert a new row into the REVIEW table. Generate a new REVIEW_ID as the maximum existing ID plus one (defaulting to 1 if empty). Set BOOK_ID by looking up the BOOK_ID from the BOOK table where TITLE equals para_title. Set RATING to 8.0, READERS_IN_MILLION to 4.0, and RANK to para_rank. Otherwise (if para_rank >= 10), delete rows from REVIEW where the BOOK_ID matches the lookup from BOOK (TITLE = para_title) and the RANK column is greater than para_rank.",
    "natural_language": "Please construct a stored procedure designated as 'sp4'. This procedure shall accept three input parameters: 'para_title' of type VARCHAR2, 'para_audio' of type VARCHAR2, and 'para_rank' of type NUMBER. The procedure's logic is to be implemented as follows: Should the value of 'para_rank' be less than 10, a new record is to be inserted into the REVIEW table. The REVIEW_ID for this new record must be generated by incrementing the current maximum REVIEW_ID value by one; if the table is presently empty, the default value of 1 shall be applied. The BOOK_ID is to be derived by querying the BOOK table for the BOOK_ID associated with the TITLE that matches the provided 'para_title' parameter. The RATING column shall be set to 8.0, the READERS_IN_MILLION column to 4.0, and the RANK column to the supplied 'para_rank' value. Conversely, if the value of 'para_rank' is greater than or equal to 10, the procedure must delete all entries from the REVIEW table where the BOOK_ID corresponds to the BOOK_ID obtained from the BOOK table (via the same title lookup using 'para_title') and where the existing RANK value exceeds the provided 'para_rank' parameter.",
    "id": 207
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp5` that accepts three input parameters: `para_book_id` of type `NUMBER`, `para_pages` of type `NUMBER`, and `para_rating` of type `NUMBER`. The procedure's logic is controlled by a conditional statement. It first evaluates if the value of `para_rating` is strictly greater than 6. If this condition is true, the procedure executes an `INSERT` operation into the `REVIEW` table. For this `INSERT` statement, the `REVIEW_ID` column is populated by first querying the `REVIEW` table to find the maximum existing `REVIEW_ID` value, using the `MAX()` aggregate function, and then applying the `NVL()` function to handle cases where no `REVIEW_ID` exists (returning 0 if `MAX(REVIEW_ID)` is null), and finally incrementing this result by 1. The `BOOK_ID` column is populated with the value provided by the `para_book_id` input parameter. The `RATING` column is populated with the value provided by the `para_rating` input parameter. The `READERS_IN_MILLION` column is assigned a fixed literal value of 5.0. The `RANK` column is assigned a fixed literal value of 12. If the initial condition (`para_rating > 6`) is false (meaning `para_rating` is less than or equal to 6), the procedure executes a `DELETE` operation from the `REVIEW` table. This `DELETE` operation targets rows where the `BOOK_ID` column matches the value provided by the `para_book_id` input parameter AND the `RATING` column has a value strictly less than the value provided by the `para_rating` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp5(para_book_id NUMBER, para_pages NUMBER, para_rating NUMBER) IS\nBEGIN\n  IF para_rating > 6 THEN\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      para_book_id,\n      para_rating,\n      5.0,\n      12\n    );\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND RATING < para_rating;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp5(1, 704, 7);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(2, 768, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(3, 992, 8);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(4, 500, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(5, 350, 9);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp5 with parameters para_book_id (NUMBER), para_pages (NUMBER), and para_rating (NUMBER). If para_rating > 6, insert a new row into the REVIEW table. Generate a new REVIEW_ID as the maximum existing ID plus one (defaulting to 1 if empty). Set BOOK_ID to para_book_id, RATING to para_rating, READERS_IN_MILLION to 5.0, and RANK to 12. Otherwise (if para_rating <= 6), delete rows from REVIEW where BOOK_ID equals para_book_id and RATING is less than para_rating.",
    "natural_language": "Develop a stored procedure called sp5, which should be carefully designed to accept three distinct numeric parameters: para_book_id, para_pages, and para_rating. In scenarios where the provided para_rating value is determined to be greater than six, the procedure must perform an insertion of a completely new record into the REVIEW table. This new REVIEW_ID must be intelligently generated by calculating the maximum existing ID currently in the table and then incrementing it by one, thoughtfully defaulting to a starting value of 1 if the table is found to be entirely empty. For this new entry, the BOOK_ID should be precisely set to the incoming para_book_id, the RATING should be accurately assigned the para_rating value, the READERS_IN_MILLION column should be explicitly populated with the constant 5.0, and the RANK should be firmly established as 12. Conversely, if the para_rating is found to be less than or equal to six, the procedure must instead execute a deletion, meticulously removing all rows from the REVIEW table where the BOOK_ID perfectly matches the supplied para_book_id and where the existing RATING is strictly lower than the provided para_rating value.",
    "id": 208
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_delete_course_arrange` that accepts four input parameters: `p_course_id` of data type `NUMBER`, representing the unique identifier for a course; `p_teacher_id` of data type `NUMBER`, representing the unique identifier for a teacher; `p_grade` of data type `NUMBER`, representing the grade level; and `p_course_filter` of data type `VARCHAR2`, representing a string used to filter courses by their name. The procedure performs a `DELETE` operation on the `COURSE_ARRANGE` table. Rows are deleted from `COURSE_ARRANGE` only if all of the following conditions are met: the `COURSE_ID` column in `COURSE_ARRANGE` matches the value provided in the `p_course_id` input parameter; the `TEACHER_ID` column in `COURSE_ARRANGE` matches the value provided in the `p_teacher_id` input parameter; the `GRADE` column in `COURSE_ARRANGE` matches the value provided in the `p_grade` input parameter; AND an `EXISTS` subquery evaluates to true. The `EXISTS` subquery checks for the presence of at least one row in the `COURSE` table where two conditions are simultaneously satisfied: the `COURSE_ID` column in the `COURSE` table matches the value provided in the `p_course_id` input parameter, AND the `COURSE` column in the `COURSE` table, after being converted to lowercase using the `LOWER()` function, contains the substring formed by converting the `p_course_filter` input parameter to lowercase using the `LOWER()` function, effectively performing a case-insensitive partial match using the `LIKE` operator with wildcard characters (`%`) at the beginning and end of the filtered string.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_delete_course_arrange(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER,\n    p_course_filter IN VARCHAR2\n)\nIS\nBEGIN\n    DELETE FROM COURSE_ARRANGE\n    WHERE COURSE_ID = p_course_id\n    AND TEACHER_ID = p_teacher_id\n    AND GRADE = p_grade\n    AND EXISTS (\n        SELECT 1 FROM COURSE\n        WHERE COURSE_ID = p_course_id\n        AND LOWER(COURSE) LIKE '%' || LOWER(p_course_filter) || '%'\n    );\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE"
    ],
    "call_sqls": [
      "BEGIN\n  proc_delete_course_arrange(2, 3, 3, 'Math');\n  commit;\nEND;",
      "BEGIN\n  proc_delete_course_arrange(3, 5, 1, 'Science');\n  commit;\nEND;",
      "BEGIN\n  proc_delete_course_arrange(2, 2, 5, 'Language Arts');\n  commit;\nEND;",
      "BEGIN\n  proc_delete_course_arrange(3, 3, 5, 'Math');\n  commit;\nEND;",
      "BEGIN\n  proc_delete_course_arrange(2, 5, 1, 'Science');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_delete_course_arrange with parameters p_course_id (NUMBER), p_teacher_id (NUMBER), p_grade (NUMBER), and p_course_filter (VARCHAR2). Delete rows from the COURSE_ARRANGE table where COURSE_ID equals p_course_id, TEACHER_ID equals p_teacher_id, GRADE equals p_grade, and a subquery condition is met. The subquery checks that a row exists in the COURSE table where its COURSE_ID equals p_course_id and its COURSE column (converted to lowercase) contains the lowercase string from p_course_filter.",
    "natural_language": "Please construct a stored procedure designated as 'proc_delete_course_arrange'. This procedure must accept the following parameters: p_course_id of type NUMBER, p_teacher_id of type NUMBER, p_grade of type NUMBER, and p_course_filter of type VARCHAR2. The procedure's function is to perform a deletion of records from the COURSE_ARRANGE table. The deletion criteria stipulate that the COURSE_ID must match the provided p_course_id, the TEACHER_ID must match p_teacher_id, and the GRADE must match p_grade. Furthermore, an additional condition must be satisfied via a subquery. This subquery must verify the existence of a corresponding entry in the COURSE table where the COURSE_ID is equal to p_course_id and the COURSE column, when converted to lowercase, contains the lowercase string supplied by the p_course_filter parameter.",
    "id": 209
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_update_course_grade that accepts four parameters: p_course_id, p_teacher_id, p_new_grade, and p_old_grade, all of which are of type NUMBER. The procedure performs an update operation on the COURSE_ARRANGE table, specifically targeting the GRADE column. The update sets the GRADE column to the value provided by the p_new_grade parameter. This update is conditional, requiring that the COURSE_ID column matches the value of the p_course_id parameter, the TEACHER_ID column matches the value of the p_teacher_id parameter, and the current GRADE column value matches the p_old_grade parameter. The procedure does not include any function calls, special operations, or conditional statements beyond the WHERE clause conditions used to filter the rows for updating.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_update_course_grade(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER,\n    p_new_grade IN NUMBER,\n    p_old_grade IN NUMBER\n)\nIS\nBEGIN\n    UPDATE COURSE_ARRANGE\n    SET GRADE = p_new_grade\n    WHERE COURSE_ID = p_course_id\n    AND TEACHER_ID = p_teacher_id\n    AND GRADE = p_old_grade;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE"
    ],
    "call_sqls": [
      "BEGIN\n    proc_update_course_grade(2, 3, 4, 3);\n    COMMIT;\nEND;",
      "BEGIN\n    proc_update_course_grade(3, 5, 2, 1);\n    COMMIT;\nEND;",
      "BEGIN\n    proc_update_course_grade(2, 2, 5, 5);\n    COMMIT;\nEND;",
      "BEGIN\n    proc_update_course_grade(1, 1, 3, 2);\n    COMMIT;\nEND;",
      "BEGIN\n    proc_update_course_grade(3, 2, 4, 5);\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_update_course_grade with parameters p_course_id (NUMBER), p_teacher_id (NUMBER), p_new_grade (NUMBER), and p_old_grade (NUMBER). Update the COURSE_ARRANGE table, setting the GRADE column to p_new_grade where COURSE_ID equals p_course_id, TEACHER_ID equals p_teacher_id, and the current GRADE equals p_old_grade.",
    "natural_language": "Make a stored procedure called proc_update_course_grade that takes in a few number parameters for the course, the teacher, and the new and old grades. It should update the COURSE_ARRANGE table to set the grade to the new value, but only for those records that seem to match the given course and teacher and where the current grade is roughly the same as the specified old grade.",
    "id": 210
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateVolumeIssueDate that accepts two input parameters: a numeric parameter named p_volume_id and a string parameter named p_new_issue_date of type VARCHAR2, and executes an UPDATE operation on the database table named VOLUME, specifically modifying the value in the column named ISSUE_DATE to the value provided in the p_new_issue_date parameter, but only for the single row in the VOLUME table where the value in the column named VOLUME_ID is exactly equal to the numeric value provided in the p_volume_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateVolumeIssueDate(\n    p_volume_id IN NUMBER,\n    p_new_issue_date IN VARCHAR2\n) AS\nBEGIN\n    UPDATE VOLUME\n    SET ISSUE_DATE = p_new_issue_date\n    WHERE VOLUME_ID = p_volume_id;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateVolumeIssueDate(1, '15 January 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(2, '22 January 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(3, '29 January 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(1, '5 February 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(2, '12 February 2024');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateVolumeIssueDate that updates the ISSUE_DATE column in the VOLUME table for the row where VOLUME_ID matches the provided numeric input parameter.",
    "natural_language": "How can I create a stored procedure called UpdateVolumeIssueDate to update the ISSUE_DATE in the VOLUME table for the row with a specific VOLUME_ID?",
    "id": 211
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ProcessArchitectBridges that performs a series of conditional checks and operations on the ARCHITECT, BRIDGE, and MILL tables. The procedure begins by declaring several local variables of type NUMBER, including v_architect_count, v_bridge_count, v_avg_length, v_max_length, v_min_length, v_total_length, v_year_count, v_mill_exists, and v_processed, which is initialized to 0. The procedure first executes a SELECT statement to count the number of rows in the ARCHITECT table and stores the result in v_architect_count. If v_architect_count is greater than 0, it proceeds to count the number of rows in the BRIDGE table, storing the result in v_bridge_count. If v_bridge_count exceeds 10, it calculates the average of the LENGTH_METERS column in the BRIDGE table and assigns it to v_avg_length. If v_avg_length is greater than 50, it finds the maximum value of LENGTH_METERS in the BRIDGE table and stores it in v_max_length. If v_max_length is greater than 100, it retrieves the minimum value of LENGTH_METERS from the BRIDGE table into v_min_length. If v_min_length is less than 30, it calculates the sum of LENGTH_METERS in the BRIDGE table and assigns it to v_total_length. If v_total_length exceeds 500, it counts the distinct values in the BUILT_YEAR column of the MILL table and stores the result in v_year_count. If v_year_count is greater than 5, it counts the number of rows in the MILL table where ARCHITECT_ID is not null and stores the result in v_mill_exists. If v_mill_exists is greater than 0, it sets v_processed to 1; otherwise, it sets v_processed to 2. If v_year_count is not greater than 5, it sets v_processed to 3. If v_total_length is not greater than 500, it sets v_processed to 4. If v_min_length is not less than 30, it sets v_processed to 5. If v_max_length is not greater than 100, it sets v_processed to 6. If v_avg_length is not greater than 50, it sets v_processed to 7. If v_bridge_count is not greater than 10, it sets v_processed to 8. If v_architect_count is not greater than 0, it sets v_processed to 9. Finally, the procedure inserts a new row into the MILL table with a randomly generated ID between 1 and 1000, a null ARCHITECT_ID, a LOCATION value of 'System', a NAME value concatenated with 'Processed_' and the value of v_processed, a TYPE value of 'Report', a BUILT_YEAR value of 2024, and a NOTES value concatenated with 'Count: ' and the value of v_architect_count.",
    "plsql": "CREATE OR REPLACE PROCEDURE ProcessArchitectBridges IS\n  v_architect_count NUMBER;\n  v_bridge_count NUMBER;\n  v_avg_length NUMBER;\n  v_max_length NUMBER;\n  v_min_length NUMBER;\n  v_total_length NUMBER;\n  v_year_count NUMBER;\n  v_mill_exists NUMBER;\n  v_processed NUMBER := 0;\nBEGIN\n  SELECT COUNT(*) INTO v_architect_count FROM ARCHITECT;\n  \n  IF v_architect_count > 0 THEN\n    SELECT COUNT(*) INTO v_bridge_count FROM BRIDGE;\n    \n    IF v_bridge_count > 10 THEN\n      SELECT AVG(LENGTH_METERS) INTO v_avg_length FROM BRIDGE;\n      \n      IF v_avg_length > 50 THEN\n        SELECT MAX(LENGTH_METERS) INTO v_max_length FROM BRIDGE;\n        \n        IF v_max_length > 100 THEN\n          SELECT MIN(LENGTH_METERS) INTO v_min_length FROM BRIDGE;\n          \n          IF v_min_length < 30 THEN\n            SELECT SUM(LENGTH_METERS) INTO v_total_length FROM BRIDGE;\n            \n            IF v_total_length > 500 THEN\n              SELECT COUNT(DISTINCT BUILT_YEAR) INTO v_year_count FROM MILL;\n              \n              IF v_year_count > 5 THEN\n                SELECT COUNT(*) INTO v_mill_exists FROM MILL WHERE ARCHITECT_ID IS NOT NULL;\n                \n                IF v_mill_exists > 0 THEN\n                  v_processed := 1;\n                ELSE\n                  v_processed := 2;\n                END IF;\n              ELSE\n                v_processed := 3;\n              END IF;\n            ELSE\n              v_processed := 4;\n            END IF;\n          ELSE\n            v_processed := 5;\n          END IF;\n        ELSE\n          v_processed := 6;\n        END IF;\n      ELSE\n        v_processed := 7;\n      END IF;\n    ELSE\n      v_processed := 8;\n    END IF;\n  ELSE\n    v_processed := 9;\n  END IF;\n  \n  INSERT INTO MILL (ID, ARCHITECT_ID, LOCATION, NAME, TYPE, BUILT_YEAR, NOTES)\n  VALUES (CEIL(DBMS_RANDOM.VALUE(1, 1000)), NULL, 'System', 'Processed_' || v_processed, 'Report', 2024, 'Count: ' || v_architect_count);\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  ProcessArchitectBridges;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ProcessArchitectBridges that performs a series of conditional checks on the ARCHITECT, BRIDGE, and MILL tables. Based on the results, it assigns a status code (1-9) to a variable and inserts a new record into the MILL table with a name containing the status and notes containing the architect count.",
    "natural_language": "Write a stored procedure called ProcessArchitectBridges to run conditional checks on the ARCHITECT, BRIDGE, and MILL tables. Then, assign a status code from 1 to 9 to a variable and insert a new record into the MILL table, setting the name to include the status and the notes to contain the architect count.",
    "id": 212
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `TransformArchitectData` that performs a series of conditional checks on data from the `ARCHITECT` table and related tables (`BRIDGE`, `MILL`), ultimately determining a `v_final_status` code, and then inserts a new record into the `MILL` table based on the results.\n\nThe procedure begins by declaring several local variables:\n- `v_id_check` of type `VARCHAR2(255)`: This variable is intended to store the `ID` of an architect for subsequent checks.\n- `v_name_length` of type `NUMBER`: This variable will store the length of an architect's `NAME`.\n- `v_nationality_length` of type `NUMBER`: This variable will store the length of an architect's `NATIONALITY`.\n- `v_gender_code` of type `NUMBER`: This variable will store a numeric representation of an architect's `GENDER`.\n- `v_bridge_exists` of type `NUMBER`: This variable will store the count of `BRIDGE` records associated with an architect.\n- `v_mill_exists` of type `NUMBER`: This variable will store the count of `MILL` records associated with an architect.\n- `v_combined_count` of type `NUMBER`: This variable will store the sum of `v_bridge_exists` and `v_mill_exists`.\n- `v_metric_value` of type `NUMBER`: This variable will store the ceiling of the average `LENGTH_METERS` from `BRIDGE` records.\n- `v_final_status` of type `NUMBER`, initialized to `0`: This variable will store a status code indicating the outcome of the conditional checks.\n\nThe execution flow starts by attempting to retrieve the `ID` of the first architect found in the `ARCHITECT` table (using `ROWNUM = 1`) and storing it in `v_id_check`.\n\nNext, a series of nested conditional `IF` statements are executed:\n\n1.  **First Condition:** It checks if the `LENGTH` of `v_id_check` is greater than `0`.\n    *   If `TRUE`:\n        *   It retrieves the `LENGTH` of the `NAME` column from the `ARCHITECT` table for the architect whose `ID` matches `v_id_check` and stores it in `v_name_length`.\n        *   **Second Condition:** It checks if `v_name_length` is greater than `10`.\n            *   If `TRUE`:\n                *   It retrieves the `LENGTH` of the `NATIONALITY` column from the `ARCHITECT` table for the architect whose `ID` matches `v_id_check` and stores it in `v_nationality_length`.\n                *   **Third Condition:** It checks if `v_nationality_length` is greater than `5`.\n                    *   If `TRUE`:\n                        *   It retrieves the `GENDER` column from the `ARCHITECT` table for the architect whose `ID` matches `v_id_check`. It then uses the `DECODE` function to convert the `GENDER` value: 'male' becomes `1`, 'female' becomes `2`, and any other value becomes `0`. This decoded value is stored in `v_gender_code`.\n                        *   **Fourth Condition:** It checks if `v_gender_code` is greater than `0`.\n                            *   If `TRUE`:\n                                *   It counts the number of records in the `BRIDGE` table where the `ARCHITECT_ID` matches the numeric conversion of `v_id_check` (using `TO_NUMBER(v_id_check)`) and stores this count in `v_bridge_exists`.\n                                *   **Fifth Condition:** It checks if `v_bridge_exists` is greater than `0`.\n                                    *   If `TRUE`:\n                                        *   It counts the number of records in the `MILL` table where the `ARCHITECT_ID` matches the numeric conversion of `v_id_check` and stores this count in `v_mill_exists`.\n                                        *   **Sixth Condition:** It checks if `v_mill_exists` is greater than `0`.\n                                            *   If `TRUE`:\n                                                *   It calculates the sum of `v_bridge_exists` and `v_mill_exists` and stores it in `v_combined_count` (using `FROM DUAL` for a simple calculation).\n                                                *   **Seventh Condition:** It checks if `v_combined_count` is greater than `1`.\n                                                    *   If `TRUE`:\n                                                        *   It calculates the ceiling of the average `LENGTH_METERS` from the `BRIDGE` table for records where `ARCHITECT_ID` matches the numeric conversion of `v_id_check`. This value is stored in `v_metric_value`.\n                                                        *   **Eighth Condition:** It checks if `v_metric_value` is greater than `50`.\n                                                            *   If `TRUE`: `v_final_status` is set to `200`.\n                                                            *   If `FALSE`: `v_final_status` is set to `201`.\n                                                    *   If `FALSE` (i.e., `v_combined_count` is not greater than `1`): `v_final_status` is set to `202`.\n                                            *   If `FALSE` (i.e., `v_mill_exists` is not greater than `0`): `v_final_status` is set to `203`.\n                                    *   If `FALSE` (i.e., `v_bridge_exists` is not greater than `0`): `v_final_status` is set to `204`.\n                            *   If `FALSE` (i.e., `v_gender_code` is not greater than `0`): `v_final_status` is set to `205`.\n                    *   If `FALSE` (i.e., `v_nationality_length` is not greater than `5`): `v_final_status` is set to `206`.\n            *   If `FALSE` (i.e., `v_name_length` is not greater than `10`): `v_final_status` is set to `207`.\n    *   If `FALSE` (i.e., `LENGTH(v_id_check)` is not greater than `0`): `v_final_status` is set to `208`.\n\nFinally, after all conditional checks have been performed and `v_final_status` has been assigned a value, the procedure executes an `INSERT` statement into the `MILL` table. This `INSERT` statement selects data from the `ARCHITECT` table where the `ID` matches `v_id_check`. The columns inserted are:\n- `ID`: A randomly generated number between `1000` and `2000` (inclusive), rounded up to the nearest integer using `CEIL(DBMS_RANDOM.VALUE(1000, 2000))`.\n- `ARCHITECT_ID`: The `ID` from the `ARCHITECT` table, converted to a number using `TO_NUMBER(ID)`.\n- `LOCATION`: The literal string `'Transformed'`.\n- `NAME`: The concatenation of the literal string `'Arch_'` and the `ID` from the `ARCHITECT` table.\n- `TYPE`: The literal string `'Data'`.\n- `BUILT_YEAR`: The literal number `2024`.\n- `NOTES`: The concatenation of the literal string `'Status: '` and the final value of `v_final_status`.",
    "plsql": "CREATE OR REPLACE PROCEDURE TransformArchitectData IS\n  v_id_check VARCHAR2(255);\n  v_name_length NUMBER;\n  v_nationality_length NUMBER;\n  v_gender_code NUMBER;\n  v_bridge_exists NUMBER;\n  v_mill_exists NUMBER;\n  v_combined_count NUMBER;\n  v_metric_value NUMBER;\n  v_final_status NUMBER := 0;\nBEGIN\n  SELECT ID INTO v_id_check FROM ARCHITECT WHERE ROWNUM = 1;\n  \n  IF LENGTH(v_id_check) > 0 THEN\n    SELECT LENGTH(NAME) INTO v_name_length FROM ARCHITECT WHERE ID = v_id_check;\n    \n    IF v_name_length > 10 THEN\n      SELECT LENGTH(NATIONALITY) INTO v_nationality_length FROM ARCHITECT WHERE ID = v_id_check;\n      \n      IF v_nationality_length > 5 THEN\n        SELECT DECODE(GENDER, 'male', 1, 'female', 2, 0) INTO v_gender_code FROM ARCHITECT WHERE ID = v_id_check;\n        \n        IF v_gender_code > 0 THEN\n          SELECT COUNT(*) INTO v_bridge_exists FROM BRIDGE WHERE ARCHITECT_ID = TO_NUMBER(v_id_check);\n          \n          IF v_bridge_exists > 0 THEN\n            SELECT COUNT(*) INTO v_mill_exists FROM MILL WHERE ARCHITECT_ID = TO_NUMBER(v_id_check);\n            \n            IF v_mill_exists > 0 THEN\n              SELECT v_bridge_exists + v_mill_exists INTO v_combined_count FROM DUAL;\n              \n              IF v_combined_count > 1 THEN\n                SELECT CEIL(AVG(LENGTH_METERS)) INTO v_metric_value FROM BRIDGE WHERE ARCHITECT_ID = TO_NUMBER(v_id_check);\n                \n                IF v_metric_value > 50 THEN\n                  v_final_status := 200;\n                ELSE\n                  v_final_status := 201;\n                END IF;\n              ELSE\n                v_final_status := 202;\n              END IF;\n            ELSE\n              v_final_status := 203;\n            END IF;\n          ELSE\n            v_final_status := 204;\n          END IF;\n        ELSE\n          v_final_status := 205;\n        END IF;\n      ELSE\n        v_final_status := 206;\n      END IF;\n    ELSE\n      v_final_status := 207;\n    END IF;\n  ELSE\n    v_final_status := 208;\n  END IF;\n  \n  INSERT INTO MILL (ID, ARCHITECT_ID, LOCATION, NAME, TYPE, BUILT_YEAR, NOTES)\n  SELECT CEIL(DBMS_RANDOM.VALUE(1000, 2000)), TO_NUMBER(ID), 'Transformed', 'Arch_' || ID, 'Data', 2024, 'Status: ' || v_final_status\n  FROM ARCHITECT WHERE ID = v_id_check;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  TransformArchitectData;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named TransformArchitectData that retrieves an architect ID and performs a series of nested conditional checks on the architect's name length, nationality length, gender, and associated bridge and mill records. It assigns a final status code (200-208) and inserts a new record into the MILL table with the architect's data and the final status in the notes.",
    "natural_language": "Create a stored procedure called TransformArchitectData that gets an architect ID and does a bunch of checks on things like how long the name is, the length of the nationality, the gender, and some related bridge and mill info. Based on all that, it figures out a final status code from a range of options and puts a new entry into the MILL table with the architect's details and that status in the notes field.",
    "id": 213
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateMusicalAwards that declares an explicit cursor named c_musicals to select the MUSICAL_ID, AWARD, and RESULT columns from the MUSICAL table for every row where the RESULT column has the exact string value 'Nominated', declares three local variables v_musical_id, v_award, and v_result using the %TYPE attribute to match the data types of the MUSICAL.MUSICAL_ID, MUSICAL.AWARD, and MUSICAL.RESULT columns respectively, opens a FOR loop that fetches each record from the c_musicals cursor into an implicit record variable musical_rec, within the loop body assigns the musical_rec.MUSICAL_ID field to the v_musical_id variable, assigns the musical_rec.AWARD field to the v_award variable, assigns the literal string 'Won' to the v_result variable, and executes an UPDATE statement on the MUSICAL table that sets the RESULT column to the value of v_result ('Won') for the specific row where the MUSICAL_ID column equals the current v_musical_id value and the AWARD column equals the current v_award value.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateMusicalAwards\nIS\n  CURSOR c_musicals IS\n    SELECT MUSICAL_ID, AWARD, RESULT\n    FROM MUSICAL\n    WHERE RESULT = 'Nominated';\n  v_musical_id MUSICAL.MUSICAL_ID%TYPE;\n  v_award MUSICAL.AWARD%TYPE;\n  v_result MUSICAL.RESULT%TYPE;\nBEGIN\n  FOR musical_rec IN c_musicals LOOP\n    v_musical_id := musical_rec.MUSICAL_ID;\n    v_award := musical_rec.AWARD;\n    v_result := 'Won';\n    UPDATE MUSICAL\n    SET RESULT = v_result\n    WHERE MUSICAL_ID = v_musical_id AND AWARD = v_award;\n  END LOOP;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateMusicalAwards;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateMusicalAwards that uses a cursor to loop through all 'Nominated' records in the MUSICAL table and updates each one's RESULT column to 'Won'.",
    "natural_language": "Write a stored procedure called UpdateMusicalAwards that employs a cursor to iterate through every 'Nominated' record in the MUSICAL table and change each RESULT column to 'Won'.",
    "id": 214
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewActor that declares local variables v_actor_id as NUMBER, v_name as VARCHAR2(255) initialized to the literal string 'Lin-Manuel Miranda', v_musical_id as NUMBER initialized to 1, v_character as VARCHAR2(255) initialized to 'Alexander Hamilton', v_duration as VARCHAR2(255) initialized to '2015', and v_age as NUMBER initialized to 35, then executes a SELECT statement on the ACTOR table to retrieve the maximum existing value from the ACTOR_ID column, increments that maximum value by one, and stores the result into the v_actor_id variable, and subsequently performs an INSERT operation into the ACTOR table, populating the columns ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION, and AGE with the values from the variables v_actor_id, v_name, v_musical_id, v_character, v_duration, and v_age respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewActor\nIS\n  v_actor_id NUMBER;\n  v_name VARCHAR2(255) := 'Lin-Manuel Miranda';\n  v_musical_id NUMBER := 1;\n  v_character VARCHAR2(255) := 'Alexander Hamilton';\n  v_duration VARCHAR2(255) := '2015';\n  v_age NUMBER := 35;\nBEGIN\n  SELECT MAX(ACTOR_ID) + 1 INTO v_actor_id FROM ACTOR;\n\n  INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION, AGE)\n  VALUES (v_actor_id, v_name, v_musical_id, v_character, v_duration, v_age);\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewActor;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named InsertNewActor that generates a new ACTOR_ID by incrementing the current maximum, then inserts a new actor record with predefined values for name, musical_id, character, duration, and age.",
    "natural_language": "Create a stored procedure, which should be named InsertNewActor, that meticulously generates a brand new ACTOR_ID by carefully calculating and then incrementing the current maximum value found in the table. Following this, the procedure must comprehensively insert a complete new actor record, utilizing a set of clearly predefined values for the essential fields: the actor's full name, the associated musical_id, the specific character they will portray, the total performance duration, and finally, the actor's precise age.",
    "id": 215
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateActorMusical` that does not accept any input parameters. This procedure declares a local cursor named `c_actors` which is designed to select two specific columns, `ACTOR_ID` and `MUSICAL_ID`, from the `ACTOR` table. The selection criteria for this cursor are limited to rows where the `MUSICAL_ID` column has a value equal to `1`. The procedure also declares two local variables: `v_actor_id`, which is typed to match the `ACTOR_ID` column of the `ACTOR` table, and `v_musical_id`, which is typed to match the `MUSICAL_ID` column of the `ACTOR` table. The core logic of the procedure involves iterating through each record returned by the `c_actors` cursor using a `FOR...LOOP` construct, with each record being temporarily stored in an implicit record variable named `actor_rec`. Inside this loop, for each `actor_rec`, the value of `actor_rec.ACTOR_ID` is assigned to the local variable `v_actor_id`. Subsequently, the literal integer value `2` is assigned to the local variable `v_musical_id`. Following these assignments, an `UPDATE` operation is performed on the `ACTOR` table. This `UPDATE` statement sets the `MUSICAL_ID` column to the current value stored in `v_musical_id` (which is `2`). The `UPDATE` operation is conditionally applied only to those rows in the `ACTOR` table where the `ACTOR_ID` column matches the current value stored in `v_actor_id`. This entire process of assigning values and performing the `UPDATE` is repeated for every record fetched by the `c_actors` cursor until all qualifying records have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateActorMusical\nIS\n  CURSOR c_actors IS\n    SELECT ACTOR_ID, MUSICAL_ID\n    FROM ACTOR\n    WHERE MUSICAL_ID = 1;\n  v_actor_id ACTOR.ACTOR_ID%TYPE;\n  v_musical_id ACTOR.MUSICAL_ID%TYPE;\nBEGIN\n  FOR actor_rec IN c_actors LOOP\n    v_actor_id := actor_rec.ACTOR_ID;\n    v_musical_id := 2;\n    UPDATE ACTOR\n    SET MUSICAL_ID = v_musical_id\n    WHERE ACTOR_ID = v_actor_id;\n  END LOOP;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateActorMusical;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateActorMusical with no parameters. Use a cursor to select ACTOR_ID and MUSICAL_ID from the ACTOR table where MUSICAL_ID is 1. For each record, update the ACTOR table to set MUSICAL_ID to 2 for the matching ACTOR_ID.",
    "natural_language": "Create a stored procedure called UpdateActorMusical that doesn't take any inputs. It should go through a selection of actors who have been in a certain popular musical. For those actors, change their assignment to another well-known musical production.",
    "id": 216
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_dog_status that accepts two parameters: p_dog_id of type NUMBER, which represents the unique identifier of a dog, and p_status of type VARCHAR2, which indicates the current status of the dog. The procedure performs conditional operations based on the value of p_status. If p_status is 'ADOPTED', it updates the DOGS table by setting the DATE_ADOPTED column to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS', for the row where DOG_ID matches the value of p_dog_id. If p_status is 'DEPARTED', it updates the DOGS table by setting the DATE_DEPARTED column to the current system date and time, formatted similarly, for the row where DOG_ID equals p_dog_id. If p_status is neither 'ADOPTED' nor 'DEPARTED', it deletes the row from the DOGS table where DOG_ID matches p_dog_id. The procedure uses conditional logic with an IF statement to determine which operation to perform based on the value of p_status.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_dog_status(p_dog_id NUMBER, p_status VARCHAR2)\nIS\nBEGIN\n   IF p_status = 'ADOPTED' THEN\n      UPDATE DOGS SET DATE_ADOPTED = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') WHERE DOG_ID = p_dog_id;\n   ELSIF p_status = 'DEPARTED' THEN\n      UPDATE DOGS SET DATE_DEPARTED = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') WHERE DOG_ID = p_dog_id;\n   ELSE\n      DELETE FROM DOGS WHERE DOG_ID = p_dog_id;\n   END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  update_dog_status(p_dog_id => 1, p_status => 'ADOPTED');\nEND;",
      "BEGIN\n  update_dog_status(p_dog_id => 2, p_status => 'DEPARTED');\nEND;",
      "BEGIN\n  update_dog_status(p_dog_id => 3, p_status => 'ADOPTED');\nEND;",
      "BEGIN\n  update_dog_status(p_dog_id => 1, p_status => 'DEPARTED');\nEND;",
      "BEGIN\n  update_dog_status(p_dog_id => 2, p_status => 'DELETED');\nEND;"
    ],
    "summary": "Create a stored procedure named update_dog_status that accepts a dog ID (NUMBER) and a status (VARCHAR2). If the status is 'ADOPTED', update the DOGS table to set DATE_ADOPTED to the current date/time (formatted as 'YYYY-MM-DD HH24:MI:SS') for the matching dog. If the status is 'DEPARTED', update DATE_DEPARTED similarly. For any other status, delete the dog's record.",
    "natural_language": "Write a stored procedure called update_dog_status that takes a dog ID (NUMBER) and a status (VARCHAR2). For a status of 'ADOPTED', update the DATE_ADOPTED column in the DOGS table to the current date and time (formatted as 'YYYY-MM-DD HH24:MI:SS') for the specified dog. For a status of 'DEPARTED', update the DATE_DEPARTED column in the same way. If the status is anything else, remove that dog's record from the table.",
    "id": 217
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `calculate_treatment_costs` that accepts two input parameters: `p_dog_id` of data type `NUMBER`, representing the unique identifier of a dog, and `p_professional_id` of data type `NUMBER`, representing the unique identifier of a professional. The procedure begins by declaring a local variable `v_total_cost` of data type `NUMBER` and initializing it to `0`. The core logic of the procedure involves two main operations. First, it executes a `SELECT` statement to calculate the sum of `COST_OF_TREATMENT` from the `TREATMENTS` table. This sum is then stored into the `v_total_cost` variable. The `SELECT` statement includes a `WHERE` clause that filters the `TREATMENTS` table to include only those records where the `DOG_ID` column matches the value provided in the `p_dog_id` input parameter AND the `PROFESSIONAL_ID` column matches the value provided in the `p_professional_id` input parameter. After calculating the total cost, the procedure proceeds to `INSERT` a new record into the `CHARGES` table. For the `CHARGE_ID` column, it determines the value by executing a subquery that selects the maximum existing `CHARGE_ID` from the `CHARGES` table, uses the `NVL` function to treat a `NULL` result (meaning no existing `CHARGE_ID`s) as `0`, and then adds `1` to this result to generate a new, unique identifier. The `CHARGE_TYPE` column is populated with the literal string `'Treatment Cost'`. Finally, the `CHARGE_AMOUNT` column is populated with the value stored in the `v_total_cost` variable, which represents the sum of treatment costs calculated in the preceding `SELECT` statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_treatment_costs(p_dog_id NUMBER, p_professional_id NUMBER)\nIS\n   v_total_cost NUMBER := 0;\nBEGIN\n   SELECT SUM(COST_OF_TREATMENT) INTO v_total_cost FROM TREATMENTS WHERE DOG_ID = p_dog_id AND PROFESSIONAL_ID = p_professional_id;\n   INSERT INTO CHARGES (CHARGE_ID, CHARGE_TYPE, CHARGE_AMOUNT)\n   VALUES ((SELECT NVL(MAX(CHARGE_ID),0) + 1 FROM CHARGES), 'Treatment Cost', v_total_cost);\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 14, p_professional_id => 9);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 4, p_professional_id => 10);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 14, p_professional_id => 4);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 4, p_professional_id => 9);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 14, p_professional_id => 10);\nEND;"
    ],
    "summary": "Create a stored procedure named calculate_treatment_costs that accepts a dog ID and a professional ID (both NUMBER). Calculate the total cost by summing COST_OF_TREATMENT from the TREATMENTS table for the matching dog and professional. Insert a new record into the CHARGES table with a new CHARGE_ID (max existing ID + 1), a CHARGE_TYPE of 'Treatment Cost', and the calculated total as CHARGE_AMOUNT.",
    "natural_language": "How can I create a stored procedure named calculate_treatment_costs that takes a dog ID and a professional ID as NUMBER inputs, sums the COST_OF_TREATMENT from the TREATMENTS table for that specific dog and professional, and then inserts a new record into the CHARGES table with a new CHARGE_ID (the maximum existing ID plus one), a CHARGE_TYPE of 'Treatment Cost', and the calculated total as the CHARGE_AMOUNT?",
    "id": 218
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named assign_professional_to_dog that accepts two mandatory input parameters: p_dog_id of type NUMBER, which identifies a specific dog, and p_professional_id of type NUMBER, which identifies a specific professional. The procedure performs a single INSERT operation into the TREATMENTS table. It constructs a new row for this table by populating the following columns: for the TREATMENT_ID column, it executes a subquery to calculate the value by selecting the current maximum value from the TREATMENT_ID column in the TREATMENTS table, applying the NVL function to that result to convert any NULL value to 0, and then adding 1 to this result; for the DOG_ID column, it uses the value of the input parameter p_dog_id; for the PROFESSIONAL_ID column, it uses the value of the input parameter p_professional_id; for the TREATMENT_TYPE_CODE column, it inserts the literal string 'EXAM'; for the DATE_OF_TREATMENT column, it uses the TO_CHAR function to convert the current system date and time from the SYSDATE function into a string formatted as 'YYYY-MM-DD HH24:MI:SS'; and for the COST_OF_TREATMENT column, it inserts the literal numeric value 100.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_professional_to_dog(p_dog_id NUMBER, p_professional_id NUMBER)\nIS\nBEGIN\n   INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT)\n   VALUES ((SELECT NVL(MAX(TREATMENT_ID),0) + 1 FROM TREATMENTS), p_dog_id, p_professional_id, 'EXAM', TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 100);\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 1, p_professional_id => 1);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 2, p_professional_id => 2);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 3, p_professional_id => 3);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 14, p_professional_id => 9);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 4, p_professional_id => 10);\nEND;"
    ],
    "summary": "Create a stored procedure named assign_professional_to_dog that accepts a dog ID and a professional ID (both NUMBER). Insert a new record into the TREATMENTS table with a new TREATMENT_ID (max existing ID + 1), the provided dog and professional IDs, a TREATMENT_TYPE_CODE of 'EXAM', the current date/time (formatted as 'YYYY-MM-DD HH24:MI:SS'), and a COST_OF_TREATMENT of 100.",
    "natural_language": "Create procedure assign_professional_to_dog with dog ID and professional ID. Insert into TREATMENTS using next TREATMENT_ID, given IDs, 'EXAM' type, current timestamp, and cost 100.",
    "id": 219
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_owner_email that accepts two input parameters: a numeric parameter p_owner_id which specifies the unique identifier of an owner record, and a string parameter p_new_email which provides the new email address text. The procedure executes a single SQL UPDATE operation targeting the OWNERS table. It modifies the EMAIL_ADDRESS column for the specific row where the OWNER_ID column value is exactly equal to the provided p_owner_id parameter. The new value assigned to the EMAIL_ADDRESS column is the result of applying the LOWER function to the p_new_email input parameter, which converts all alphabetical characters within the email string to their lowercase equivalents before the update is performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_owner_email(p_owner_id NUMBER, p_new_email VARCHAR2)\nIS\nBEGIN\n   UPDATE OWNERS SET EMAIL_ADDRESS = LOWER(p_new_email) WHERE OWNER_ID = p_owner_id;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  update_owner_email(1, 'NEW_EMAIL@EXAMPLE.COM');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(3, 'jaclyn.new@example.org');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(4, 'tre.hamill.updated@example.net');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(11, 'owner11.newemail@domain.com');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(15, 'test.user@test.org');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_owner_email that accepts an owner ID (NUMBER) and a new email (VARCHAR2). Update the OWNERS table to set the EMAIL_ADDRESS to the lowercase version of the provided new email for the row matching the owner ID.",
    "natural_language": "How can I create a stored procedure called update_owner_email that takes an owner ID (NUMBER) and a new email (VARCHAR2) as parameters, and then updates the OWNERS table to set the EMAIL_ADDRESS to the lowercase version of the provided new email for the specific owner ID?",
    "id": 220
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_organization_services that takes no parameters and begins by declaring local variables: v_organization_id, v_parent_organization_id, v_service_id, and v_customer_event_note_id as NUMBER; v_organization_details, v_service_type_code, v_service_details, v_date_moved_in, v_date_requested, v_date_provided, and v_other_details as VARCHAR2(255); and v_resident_id, v_property_id, v_customer_event_id, v_customer_id, and v_thing_id as NUMBER. The procedure first executes a cursor FOR loop that selects records from a join of the organizations table (aliased as o) and the services table (aliased as s) on the condition that o.organization_id equals s.organization_id, retrieving the columns o.organization_id, o.parent_organization_id, o.organization_details, s.service_id, s.service_type_code, and s.service_details for each row. For each record from this join, the procedure assigns the selected column values to the corresponding local variables v_organization_id, v_parent_organization_id, v_organization_details, v_service_id, v_service_type_code, and v_service_details. Then, for each current service, it opens a nested cursor FOR loop over the residents_services table (aliased as rs), selecting the columns rs.resident_id, rs.property_id, rs.date_moved_in, rs.date_requested, rs.date_provided, and rs.other_details where rs.service_id equals the current v_service_id value. For each resident service record, it assigns the selected column values to the local variables v_resident_id, v_property_id, v_date_moved_in, v_date_requested, v_date_provided, and v_other_details. Next, within a BEGIN-EXCEPTION block, it attempts to select a single row from the customer_events table into the variables v_customer_event_id, v_customer_id, and v_thing_id where the resident_id, property_id, and date_moved_in columns match the current v_resident_id, v_property_id, and v_date_moved_in values, using the condition ROWNUM = 1 to limit the result to one row; if no data is found (NO_DATA_FOUND exception), it sets v_customer_event_id, v_customer_id, and v_thing_id to NULL and uses CONTINUE to skip to the next iteration of the inner loop; if too many rows are found (TOO_MANY_ROWS exception), it re-executes the same SELECT statement with ROWNUM = 1 to fetch one arbitrary row. Following this lookup, the procedure evaluates the value of v_other_details: if it equals the string 'Pending', it updates the residents_services table, setting the date_provided column to the current system date (SYSDATE) where the resident_id, property_id, date_moved_in, and service_id columns match the current v_resident_id, v_property_id, v_date_moved_in, and v_service_id values; if v_other_details equals 'Reviewed', it deletes from the residents_services table where the resident_id, property_id, date_moved_in, and service_id columns match the current v_resident_id, v_property_id, v_date_moved_in, and v_service_id values; for any other value of v_other_details, it first queries the customer_event_notes table to calculate a new primary key by selecting the maximum value of the customer_event_note_id column, using the NVL function to substitute 0 if the maximum is NULL, and adding 1, storing the result in v_customer_event_note_id, and then inserts a new row into the customer_event_notes table with the columns customer_event_note_id, customer_event_id, service_type_code, resident_id, property_id, and date_moved_in populated with the values from v_customer_event_note_id, v_customer_event_id, v_service_type_code, v_resident_id, v_property_id, and v_date_moved_in respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_organization_services\nIS\n   v_organization_id NUMBER;\n   v_parent_organization_id NUMBER;\n   v_organization_details VARCHAR2(255);\n   v_service_id NUMBER;\n   v_service_type_code VARCHAR2(255);\n   v_service_details VARCHAR2(255);\n   v_resident_id NUMBER;\n   v_property_id NUMBER;\n   v_date_moved_in VARCHAR2(255);\n   v_date_requested VARCHAR2(255);\n   v_date_provided VARCHAR2(255);\n   v_other_details VARCHAR2(255);\n   v_customer_event_id NUMBER;\n   v_customer_id NUMBER;\n   v_thing_id NUMBER;\n   v_customer_event_note_id NUMBER;\nBEGIN\n   FOR rec IN (SELECT o.organization_id, o.parent_organization_id, o.organization_details, s.service_id, s.service_type_code, s.service_details FROM organizations o JOIN services s ON o.organization_id = s.organization_id)\n   LOOP\n      v_organization_id := rec.organization_id;\n      v_parent_organization_id := rec.parent_organization_id;\n      v_organization_details := rec.organization_details;\n      v_service_id := rec.service_id;\n      v_service_type_code := rec.service_type_code;\n      v_service_details := rec.service_details;\n      FOR res_rec IN (SELECT rs.resident_id, rs.property_id, rs.date_moved_in, rs.date_requested, rs.date_provided, rs.other_details FROM residents_services rs WHERE rs.service_id = v_service_id)\n      LOOP\n         v_resident_id := res_rec.resident_id;\n         v_property_id := res_rec.property_id;\n         v_date_moved_in := res_rec.date_moved_in;\n         v_date_requested := res_rec.date_requested;\n         v_date_provided := res_rec.date_provided;\n         v_other_details := res_rec.other_details;\n         \n         BEGIN\n            SELECT customer_event_id, customer_id, thing_id \n            INTO v_customer_event_id, v_customer_id, v_thing_id \n            FROM customer_events \n            WHERE resident_id = v_resident_id \n              AND property_id = v_property_id \n              AND date_moved_in = v_date_moved_in\n              AND ROWNUM = 1;\n         EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n               v_customer_event_id := NULL;\n               v_customer_id := NULL;\n               v_thing_id := NULL;\n               CONTINUE;\n            WHEN TOO_MANY_ROWS THEN\n               SELECT customer_event_id, customer_id, thing_id \n               INTO v_customer_event_id, v_customer_id, v_thing_id \n               FROM customer_events \n               WHERE resident_id = v_resident_id \n                 AND property_id = v_property_id \n                 AND date_moved_in = v_date_moved_in\n                 AND ROWNUM = 1;\n         END;\n         \n         IF v_other_details = 'Pending' THEN\n            UPDATE residents_services \n            SET date_provided = SYSDATE \n            WHERE resident_id = v_resident_id \n              AND property_id = v_property_id \n              AND date_moved_in = v_date_moved_in \n              AND service_id = v_service_id;\n         ELSIF v_other_details = 'Reviewed' THEN\n            DELETE FROM residents_services \n            WHERE resident_id = v_resident_id \n              AND property_id = v_property_id \n              AND date_moved_in = v_date_moved_in \n              AND service_id = v_service_id;\n         ELSE\n            SELECT NVL(MAX(customer_event_note_id),0) + 1 \n            INTO v_customer_event_note_id \n            FROM customer_event_notes;\n            \n            INSERT INTO customer_event_notes \n            (customer_event_note_id, customer_event_id, service_type_code, resident_id, property_id, date_moved_in) \n            VALUES \n            (v_customer_event_note_id, v_customer_event_id, v_service_type_code, v_resident_id, v_property_id, v_date_moved_in);\n         END IF;\n      END LOOP;\n   END LOOP;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "RESIDENTS_SERVICES",
      "SERVICES",
      "ORGANIZATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  process_organization_services;\nEND;"
    ],
    "summary": "Create a stored procedure named process_organization_services with no parameters. For each organization-service pair from a join of the organizations and services tables, process its related resident service records. For each resident service, attempt to find a matching customer event. Based on the resident service's other_details field: if 'Pending', update its date_provided to SYSDATE; if 'Reviewed', delete the resident service record; otherwise, generate a new ID and insert a corresponding record into the customer_event_notes table.",
    "natural_language": "Create a stored procedure called process_organization_services without any parameters. For every organization and service combination from joining the organizations and services tables, process its associated resident service records. For each resident service, try to locate a matching customer event. Then, based on the 'other_details' field of the resident service: if it is 'Pending', update its date_provided to the current system date; if it is 'Reviewed', delete that resident service record; for any other case, generate a new identifier and insert a matching record into the customer_event_notes table.",
    "id": 221
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `analyze_resident_events` that does not accept any input parameters. This procedure is designed to iterate through each record in the `residents` table and perform various operations based on the data found.\n\nFirst, the procedure declares several local variables to temporarily store data retrieved from tables or computed during execution. These variables include:\n- `v_resident_id` of type `NUMBER`, intended to hold the unique identifier for a resident.\n- `v_property_id` of type `NUMBER`, intended to hold the unique identifier for a property.\n- `v_date_moved_in` of type `VARCHAR2(255)`, intended to hold the date a resident moved into a property.\n- `v_date_moved_out` of type `VARCHAR2(255)`, intended to hold the date a resident moved out of a property.\n- `v_other_details` of type `VARCHAR2(255)`, intended to hold additional details about a resident's record.\n- `v_customer_event_id` of type `NUMBER`, intended to hold the unique identifier for a customer event.\n- `v_customer_id` of type `NUMBER`, intended to hold the unique identifier for a customer.\n- `v_thing_id` of type `NUMBER`, intended to hold an identifier for a \"thing\" associated with a customer event.\n- `v_service_id` of type `NUMBER`, intended to hold the unique identifier for a service.\n- `v_service_type_code` of type `VARCHAR2(255)`, intended to hold the type code for a service.\n- `v_organization_id` of type `NUMBER`, intended to hold the unique identifier for an organization.\n- `v_service_details` of type `VARCHAR2(255)`, intended to hold details about a service.\n- `v_parent_organization_id` of type `NUMBER`, intended to hold the unique identifier for a parent organization.\n- `v_organization_details` of type `VARCHAR2(255)`, intended to hold details about an organization.\n- `v_customer_event_note_id` of type `NUMBER`, which is declared but not used in the provided code.\n- `v_new_thing_id` of type `NUMBER`, intended to hold a potentially updated `thing_id` value.\n\nThe core logic of the procedure is encapsulated within a `FOR` loop that iterates over a cursor. This cursor selects `resident_id`, `property_id`, `date_moved_in`, `date_moved_out`, and `other_details` from the `residents` table, aliased as `r`. For each record retrieved by this loop, the corresponding column values are assigned to the local variables `v_resident_id`, `v_property_id`, `v_date_moved_in`, `v_date_moved_out`, and `v_other_details`.\n\nInside this loop, a nested `BEGIN...END` block attempts to retrieve specific information from the `customer_events` table. It selects `customer_event_id`, `customer_id`, and `thing_id` into the variables `v_customer_event_id`, `v_customer_id`, and `v_thing_id`, respectively. This selection is conditioned on matching `resident_id` with `v_resident_id`, `property_id` with `v_property_id`, and `date_moved_in` with `v_date_moved_in`. If no matching record is found in `customer_events` for the current resident's details, the `NO_DATA_FOUND` exception is caught, and no action is taken, allowing the loop to proceed to the next resident.\n\nIf a matching `customer_event` record is found, the procedure then enters a conditional block:\n1.  **If `v_date_moved_out` is `NULL`**: This condition suggests the resident is still moved in.\n    -   The procedure selects `service_id`, `service_type_code`, `organization_id`, and `service_details` into `v_service_id`, `v_service_type_code`, `v_organization_id`, and `v_service_details` from the `services` table. The `service_id` is determined by selecting the minimum `service_id` available in the `services` table.\n    -   A nested `BEGIN...END` block then attempts to retrieve `parent_organization_id` and `organization_details` into `v_parent_organization_id` and `v_organization_details` from the `organizations` table, where `organization_id` matches `v_organization_id`. If no data is found for the organization, `v_parent_organization_id` and `v_organization_details` are explicitly set to `NULL`.\n    -   Finally, a new record is inserted into the `residents_services` table. The values inserted are: `v_resident_id` for `resident_id`, `v_service_id` for `service_id`, `v_date_moved_in` for `date_moved_in`, `v_property_id` for `property_id`, the current system date (`SYSDATE`) for `date_requested`, `NULL` for `date_provided`, and the string literal `'Pending'` for `other_details`.\n2.  **Else if `v_other_details` is `NOT NULL`**: This condition is checked if `v_date_moved_out` is not `NULL`.\n    -   The variable `v_new_thing_id` is calculated by incrementing `v_thing_id` by 1.\n    -   A nested `DECLARE...BEGIN...END` block is used to validate the existence of this `v_new_thing_id` in a hypothetical `things` table. A local variable `v_temp` of type `NUMBER` is declared. The procedure attempts to select the literal value `1` into `v_temp` from the `things` table where `thing_id` matches `v_new_thing_id`. This effectively checks if a record with `v_new_thing_id` exists in the `things` table.\n    -   If the `SELECT` statement successfully finds a matching `thing_id`, indicating the parent key exists, the `thing_id` column in the `customer_events` table is updated to `v_new_thing_id` for the record where `customer_event_id` matches `v_customer_event_id`.\n    -   If `NO_DATA_FOUND` occurs during the `SELECT` from the `things` table, meaning the parent key does not exist, the `UPDATE` operation is skipped, and no action is taken within this exception handler.\n3.  **Else (if `v_date_moved_out` is not `NULL` AND `v_other_details` is `NULL`)**:\n    -   All records from the `customer_event_notes` table are deleted where `customer_event_id` matches `v_customer_event_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_resident_events\nIS\n   v_resident_id NUMBER;\n   v_property_id NUMBER;\n   v_date_moved_in VARCHAR2(255);\n   v_date_moved_out VARCHAR2(255);\n   v_other_details VARCHAR2(255);\n   v_customer_event_id NUMBER;\n   v_customer_id NUMBER;\n   v_thing_id NUMBER;\n   v_service_id NUMBER;\n   v_service_type_code VARCHAR2(255);\n   v_organization_id NUMBER;\n   v_service_details VARCHAR2(255);\n   v_parent_organization_id NUMBER;\n   v_organization_details VARCHAR2(255);\n   v_customer_event_note_id NUMBER;\n   v_new_thing_id NUMBER;\nBEGIN\n   FOR rec IN (SELECT r.resident_id, r.property_id, r.date_moved_in, r.date_moved_out, r.other_details FROM residents r)\n   LOOP\n      v_resident_id := rec.resident_id;\n      v_property_id := rec.property_id;\n      v_date_moved_in := rec.date_moved_in;\n      v_date_moved_out := rec.date_moved_out;\n      v_other_details := rec.other_details;\n      BEGIN\n         SELECT customer_event_id, customer_id, thing_id INTO v_customer_event_id, v_customer_id, v_thing_id \n         FROM customer_events \n         WHERE resident_id = v_resident_id AND property_id = v_property_id AND date_moved_in = v_date_moved_in;\n         \n         IF v_date_moved_out IS NULL THEN\n            SELECT service_id, service_type_code, organization_id, service_details INTO v_service_id, v_service_type_code, v_organization_id, v_service_details \n            FROM services \n            WHERE service_id = (SELECT MIN(service_id) FROM services);\n            \n            BEGIN\n               SELECT parent_organization_id, organization_details INTO v_parent_organization_id, v_organization_details \n               FROM organizations \n               WHERE organization_id = v_organization_id;\n            EXCEPTION\n               WHEN NO_DATA_FOUND THEN\n                  v_parent_organization_id := NULL;\n                  v_organization_details := NULL;\n            END;\n            \n            INSERT INTO residents_services (resident_id, service_id, date_moved_in, property_id, date_requested, date_provided, other_details) \n            VALUES (v_resident_id, v_service_id, v_date_moved_in, v_property_id, SYSDATE, NULL, 'Pending');\n         ELSIF v_other_details IS NOT NULL THEN\n            -- Check if the incremented thing_id would be valid before updating\n            v_new_thing_id := v_thing_id + 1;\n            -- Assuming there's a THINGS table that THING_ID references\n            -- We need to verify the new value exists in the parent table\n            DECLARE\n               v_temp NUMBER;\n            BEGIN\n               SELECT 1 INTO v_temp FROM things WHERE thing_id = v_new_thing_id;\n               -- If we get here, the parent key exists\n               UPDATE customer_events SET thing_id = v_new_thing_id WHERE customer_event_id = v_customer_event_id;\n            EXCEPTION\n               WHEN NO_DATA_FOUND THEN\n                  -- Parent key doesn't exist, skip the update\n                  NULL;\n            END;\n         ELSE\n            DELETE FROM customer_event_notes WHERE customer_event_id = v_customer_event_id;\n         END IF;\n      EXCEPTION\n         WHEN NO_DATA_FOUND THEN\n            -- Handle the case where no matching customer event is found\n            NULL; -- No action needed, continue with the next iteration\n      END;\n   END LOOP;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "RESIDENTS_SERVICES",
      "SERVICES",
      "ORGANIZATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  analyze_resident_events;\nEND;"
    ],
    "summary": "Create a stored procedure named analyze_resident_events with no parameters. For each resident, attempt to find a matching customer event. If found: 1) If the resident's date_moved_out is NULL, find the minimum service ID, get its organization details, and insert a new 'Pending' record into residents_services. 2) If other_details is NOT NULL, attempt to update the customer event's thing_id to the next value, but only if that new ID exists in a things table. 3) Otherwise, delete all notes for that customer event.",
    "natural_language": "Create a stored procedure, which should be named analyze_resident_events, that does not accept any parameters. This procedure must meticulously process each resident record. For every resident, it should diligently attempt to locate a corresponding customer event. Upon a successful match, a detailed sequence of conditional actions must be executed: Firstly, if the resident's date_moved_out field is explicitly NULL, the procedure must carefully identify the absolute minimum service ID, retrieve the comprehensive details of the associated organization, and subsequently insert a brand new record with a status of 'Pending' into the residents_services table. Secondly, if the resident's other_details field is decidedly NOT NULL, the procedure should then endeavor to update the thing_id within the matched customer event to the very next sequential value, but this update must only proceed cautiously if that specific new identifier can be verified as already existing within a separate things table. Finally, in all other scenarios where the preceding conditions are not met, the procedure must thoroughly and completely delete every single note entry that is linked to that particular customer event.",
    "id": 222
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewUniversity that accepts four input parameters: p_university_name of type VARCHAR2, p_city of type VARCHAR2, p_state of type VARCHAR2, and p_enrollment of type NUMBER. The procedure performs an insertion operation into the UNIVERSITY table, which consists of five columns: UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, and ENROLLMENT. The UNIVERSITY_ID column is assigned a value derived from a subquery that selects the maximum value of UNIVERSITY_ID from the UNIVERSITY table, applies the NVL function to handle null cases by defaulting to 0, and then increments this value by 1 to generate a new unique identifier for the university being inserted. The UNIVERSITY_NAME column is populated with the value provided in the p_university_name parameter, the CITY column is populated with the value from the p_city parameter, the STATE column is populated with the value from the p_state parameter, and the ENROLLMENT column is populated with the value from the p_enrollment parameter. The procedure does not include any conditional logic or additional operations beyond the insertion into the table.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewUniversity(\n    p_university_name IN VARCHAR2,\n    p_city IN VARCHAR2,\n    p_state IN VARCHAR2,\n    p_enrollment IN NUMBER\n) AS\nBEGIN\n    INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, ENROLLMENT)\n    VALUES ((SELECT NVL(MAX(UNIVERSITY_ID), 0) + 1 FROM UNIVERSITY), p_university_name, p_city, p_state, p_enrollment);\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewUniversity('University of Chicago', 'Chicago', 'Illinois', 17000);\nEND;",
      "BEGIN\n  InsertNewUniversity('Northwestern University', 'Evanston', 'Illinois', 22000);\nEND;",
      "BEGIN\n  InsertNewUniversity('University of Wisconsin-Madison', 'Madison', 'Wisconsin', 45000);\nEND;",
      "BEGIN\n  InsertNewUniversity('Marquette University', 'Milwaukee', 'Wisconsin', 11000);\nEND;",
      "BEGIN\n  InsertNewUniversity('DePaul University', 'Chicago', 'Illinois', 22000);\nEND;"
    ],
    "summary": "Create a stored procedure named InsertNewUniversity that accepts university name, city, state, and enrollment as parameters. Insert a new record into the UNIVERSITY table, generating a new UNIVERSITY_ID by taking the maximum existing ID (or 0 if none) and adding 1.",
    "natural_language": "How can I create a stored procedure called InsertNewUniversity that takes university name, city, state, and enrollment as parameters to insert a new record into the UNIVERSITY table, generating a new UNIVERSITY_ID by adding 1 to the maximum existing ID or using 1 if no records exist?",
    "id": 223
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateUniversityEnrollment that accepts four input parameters: a numeric parameter p_university_id to identify a specific university, a numeric parameter p_new_enrollment representing the desired enrollment figure to be set, a numeric parameter p_min_enrollment defining the lower acceptable bound for enrollment, and a numeric parameter p_max_enrollment defining the upper acceptable bound for enrollment. The procedure's logic begins by evaluating a conditional IF statement that checks whether the value of the p_new_enrollment parameter falls within the inclusive range specified by the p_min_enrollment and p_max_enrollment parameters, using the BETWEEN operator. If and only if this condition evaluates to TRUE, the procedure executes an UPDATE operation on the UNIVERSITY table. This update statement modifies the ENROLLMENT column for the specific row where the UNIVERSITY_ID column value matches the input parameter p_university_id, setting that row's ENROLLMENT column value to the value provided in the p_new_enrollment parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateUniversityEnrollment(\n    p_university_id IN NUMBER,\n    p_new_enrollment IN NUMBER,\n    p_min_enrollment IN NUMBER,\n    p_max_enrollment IN NUMBER\n) AS\nBEGIN\n    IF p_new_enrollment BETWEEN p_min_enrollment AND p_max_enrollment THEN\n        UPDATE UNIVERSITY\n        SET ENROLLMENT = p_new_enrollment\n        WHERE UNIVERSITY_ID = p_university_id;\n    END IF;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateUniversityEnrollment(1, 2600, 2000, 3000);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateUniversityEnrollment(2, 4500, 4000, 5000);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateUniversityEnrollment(3, 1200, 800, 1500);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateUniversityEnrollment(1, 2800, 2500, 3500);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateUniversityEnrollment(2, 4200, 4000, 5000);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateUniversityEnrollment that accepts a university ID, a new enrollment value, and minimum/maximum enrollment bounds. Update the university's enrollment to the new value only if the new value falls within the specified inclusive range.",
    "natural_language": "Construct a stored procedure, which we shall name UpdateUniversityEnrollment, that is designed to receive several input parameters: a specific identifier for the university, a freshly proposed figure for its total enrollment, and additionally, both a lower threshold and an upper threshold to define acceptable enrollment boundaries. This procedure should then carefully update the university's recorded enrollment to the newly supplied value, but it must perform this update only under the precise condition that the new enrollment value is comfortably situated within the inclusive range established by the provided minimum and maximum bounds.",
    "id": 224
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteUniversityByEnrollment that accepts four input parameters: a numeric parameter p_min_enrollment representing the lower bound of an enrollment range, a numeric parameter p_max_enrollment representing the upper bound of an enrollment range, a string parameter p_city representing a city name, and a string parameter p_state representing a state name, and executes a DELETE operation on the UNIVERSITY table, removing all rows where the ENROLLMENT column value falls inclusively between the p_min_enrollment and p_max_enrollment parameters, and simultaneously the CITY column value exactly matches the p_city parameter, and simultaneously the STATE column value exactly matches the p_state parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteUniversityByEnrollment(\n    p_min_enrollment IN NUMBER,\n    p_max_enrollment IN NUMBER,\n    p_city IN VARCHAR2,\n    p_state IN VARCHAR2\n) AS\nBEGIN\n    DELETE FROM UNIVERSITY\n    WHERE ENROLLMENT BETWEEN p_min_enrollment AND p_max_enrollment\n    AND CITY = p_city\n    AND STATE = p_state;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteUniversityByEnrollment(1000, 3000, 'Rock Island', 'Illinois');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(2000, 5000, 'Aurora', 'Illinois');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(500, 1500, 'Beloit', 'Wisconsin');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(2500, 4500, 'Aurora', 'Wisconsin');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(1000, 2000, 'Rock Island', 'Wisconsin');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteUniversityByEnrollment that accepts minimum enrollment, maximum enrollment, city, and state parameters. Delete all universities where the enrollment is within the specified range and the city and state match the provided values.",
    "natural_language": "Develop a stored procedure called DeleteUniversityByEnrollment that is designed to accept four input parameters: a minimum enrollment figure, a maximum enrollment figure, a city name, and a state abbreviation. This procedure should thoroughly identify and permanently remove all university records for which the student enrollment count falls inclusively between the provided minimum and maximum values, and where both the city and the state precisely correspond to the given parameter values.",
    "id": 225
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_city_name that accepts three parameters: p_city_code of type VARCHAR2, p_new_city_name of type VARCHAR2, and p_success of type NUMBER as an OUT parameter. The procedure begins by declaring a local variable v_city_exists of type NUMBER. It then performs a SELECT operation to count the number of rows in the CITY table where the CITY_CODE column matches the value of the p_city_code parameter, storing the result in the v_city_exists variable. The procedure uses an IF conditional statement to check if v_city_exists is greater than 0, indicating that a city with the specified city code exists. If the condition is true, it executes an UPDATE operation on the CITY table, setting the CITY_NAME column to the value of the p_new_city_name parameter for the row where CITY_CODE matches p_city_code. After successfully updating the city name, the procedure assigns the value 1 to the p_success OUT parameter to indicate success. If the condition is false, meaning no city with the specified city code exists, the procedure assigns the value 0 to the p_success OUT parameter to indicate failure.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_city_name(\n    p_city_code IN VARCHAR2,\n    p_new_city_name IN VARCHAR2,\n    p_success OUT NUMBER\n) IS\n    v_city_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_city_exists\n    FROM CITY\n    WHERE CITY_CODE = p_city_code;\n    \n    IF v_city_exists > 0 THEN\n        UPDATE CITY\n        SET CITY_NAME = p_new_city_name\n        WHERE CITY_CODE = p_city_code;\n        p_success := 1;\n    ELSE\n        p_success := 0;\n    END IF;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "DECLARE\n  v_success NUMBER;\nBEGIN\n  update_city_name('BAL', 'Baltimore_New', v_success);\nEND;",
      "DECLARE\n  v_success NUMBER;\nBEGIN\n  update_city_name('PIT', 'Pittsburgh_New', v_success);\nEND;",
      "DECLARE\n  v_success NUMBER;\nBEGIN\n  update_city_name('PHL', 'Philadelphia_New', v_success);\nEND;",
      "DECLARE\n  v_success NUMBER;\nBEGIN\n  update_city_name('NYC', 'New York City', v_success);\nEND;",
      "DECLARE\n  v_success NUMBER;\nBEGIN\n  update_city_name('WAS', 'Washington_DC', v_success);\nEND;"
    ],
    "summary": "Create a stored procedure named update_city_name that updates a city's name based on its code. It takes a city code and a new name as input. It checks if the city exists. If it does, it updates the name and returns 1 for success. If not, it returns 0 for failure.",
    "natural_language": "Write a stored procedure called update_city_name to change a city's name using its code. Provide the city code and the new name. Check for the city's existence first. If found, update the name and return 1. If not found, return 0.",
    "id": 226
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_book_chapters that is designed to update the number of chapters for a specific book in the BOOK table. This procedure accepts two input parameters: p_book_id of type NUMBER, which specifies the unique identifier of the book whose chapter count is to be updated, and p_new_chapters of type NUMBER, which indicates the new number of chapters to be set for the specified book. Additionally, it has one output parameter: p_old_chapters of type NUMBER, which is used to return the current number of chapters before the update is performed. The procedure begins by executing a SELECT statement to retrieve the current value of the CHAPTERS column from the BOOK table for the row where the BOOK_ID matches the value provided in p_book_id. This retrieved value is then stored in the output parameter p_old_chapters. Following this, the procedure performs an UPDATE operation on the BOOK table, setting the CHAPTERS column to the value specified in p_new_chapters for the row where the BOOK_ID matches the provided p_book_id. The procedure does not include any conditional logic or function calls beyond these operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_book_chapters(p_book_id NUMBER, p_new_chapters NUMBER, p_old_chapters OUT NUMBER) IS\nBEGIN\n    SELECT CHAPTERS INTO p_old_chapters FROM BOOK WHERE BOOK_ID = p_book_id;\n    UPDATE BOOK SET CHAPTERS = p_new_chapters WHERE BOOK_ID = p_book_id;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_chapters NUMBER;\nBEGIN\n  update_book_chapters(p_book_id => 1, p_new_chapters => 75, p_old_chapters => v_old_chapters);\n  DBMS_OUTPUT.PUT_LINE('Old Chapters: ' || v_old_chapters);\nEND;",
      "DECLARE\n  v_old_chapters NUMBER;\nBEGIN\n  update_book_chapters(p_book_id => 2, p_new_chapters => 72, p_old_chapters => v_old_chapters);\n  DBMS_OUTPUT.PUT_LINE('Old Chapters: ' || v_old_chapters);\nEND;",
      "DECLARE\n  v_old_chapters NUMBER;\nBEGIN\n  update_book_chapters(p_book_id => 3, p_new_chapters => 85, p_old_chapters => v_old_chapters);\n  DBMS_OUTPUT.PUT_LINE('Old Chapters: ' || v_old_chapters);\nEND;",
      "DECLARE\n  v_old_chapters NUMBER;\nBEGIN\n  update_book_chapters(p_book_id => 1, p_new_chapters => 73, p_old_chapters => v_old_chapters);\n  DBMS_OUTPUT.PUT_LINE('Old Chapters: ' || v_old_chapters);\nEND;",
      "DECLARE\n  v_old_chapters NUMBER;\nBEGIN\n  update_book_chapters(p_book_id => 2, p_new_chapters => 70, p_old_chapters => v_old_chapters);\n  DBMS_OUTPUT.PUT_LINE('Old Chapters: ' || v_old_chapters);\nEND;"
    ],
    "summary": "Create a stored procedure named update_book_chapters that updates a book's chapter count. It takes a book ID and a new chapter count as input. It returns the old chapter count via an OUT parameter before performing the update.",
    "natural_language": "Make a stored procedure called update_book_chapters that changes how many chapters a book has. It needs a book identifier and a different number for the chapters. Before it changes the count, it should give back the previous number it had through a special output.",
    "id": 227
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_student_interactions that accepts two input parameters: p_student_id of type NUMBER, which identifies a specific student, and p_action of type VARCHAR2, which specifies the operation to perform. The procedure begins by declaring four local NUMBER variables: v_friend_count, v_likes_given, v_likes_received, and v_total_interactions. It then executes three separate SELECT COUNT(*) queries: the first query counts rows in the FRIEND table where the STUDENT_ID column equals the input p_student_id, storing the result in v_friend_count; the second query counts rows in the LIKES table where the STUDENT_ID column equals p_student_id, storing the result in v_likes_given; the third query counts rows in the LIKES table where the LIKED_ID column equals p_student_id, storing the result in v_likes_received. The procedure calculates v_total_interactions by summing the three count variables. The core logic uses an IF-ELSIF-ELSE structure that evaluates the p_action parameter after converting it to uppercase using the UPPER function. If the action is 'BOOST', it checks v_total_interactions: if greater than 20, it inserts a new row into the FRIEND table with the provided p_student_id as STUDENT_ID and a randomly generated integer between 1000 and 2000 (using FLOOR(DBMS_RANDOM.VALUE(1000, 2000))) as FRIEND_ID; if greater than 10 but not greater than 20, it inserts a new row into the LIKES table with p_student_id as STUDENT_ID and a similar random integer as LIKED_ID; if 10 or less, it deletes all rows from the FRIEND table where the STUDENT_ID column equals p_student_id. If the action is 'REDUCE', it checks v_total_interactions: if less than 5, it deletes all rows from the LIKES table where the STUDENT_ID column equals p_student_id; otherwise, it deletes a single row from the FRIEND table where both STUDENT_ID equals p_student_id and FRIEND_ID equals a randomly generated integer between 1000 and 2000. For any other action value, the procedure inserts a new row into the HIGHSCHOOLER table with a randomly generated ID between 1000 and 2000, the NAME column set to 'NewStudent', and the GRADE column set to 9.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_student_interactions(\n    p_student_id IN NUMBER,\n    p_action IN VARCHAR2\n) IS\n    v_friend_count NUMBER;\n    v_likes_given NUMBER;\n    v_likes_received NUMBER;\n    v_total_interactions NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_friend_count\n    FROM FRIEND\n    WHERE STUDENT_ID = p_student_id;\n\n    SELECT COUNT(*) INTO v_likes_given\n    FROM LIKES\n    WHERE STUDENT_ID = p_student_id;\n\n    SELECT COUNT(*) INTO v_likes_received\n    FROM LIKES\n    WHERE LIKED_ID = p_student_id;\n\n    v_total_interactions := v_friend_count + v_likes_given + v_likes_received;\n\n    IF UPPER(p_action) = 'BOOST' THEN\n        IF v_total_interactions > 20 THEN\n            INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (p_student_id, FLOOR(DBMS_RANDOM.VALUE(1000, 2000)));\n        ELSIF v_total_interactions > 10 THEN\n            INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (p_student_id, FLOOR(DBMS_RANDOM.VALUE(1000, 2000)));\n        ELSE\n            DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id;\n        END IF;\n    ELSIF UPPER(p_action) = 'REDUCE' THEN\n        IF v_total_interactions < 5 THEN\n            DELETE FROM LIKES WHERE STUDENT_ID = p_student_id;\n        ELSE\n            DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id AND FRIEND_ID = FLOOR(DBMS_RANDOM.VALUE(1000, 2000));\n        END IF;\n    ELSE\n        INSERT INTO HIGHSCHOOLER (ID, NAME, GRADE) VALUES (FLOOR(DBMS_RANDOM.VALUE(1000, 2000)), 'NewStudent', 9);\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "BEGIN\n  manage_student_interactions(p_student_id => 1101, p_action => 'BOOST');\nEND;",
      "BEGIN\n  manage_student_interactions(p_student_id => 1247, p_action => 'REDUCE');\nEND;",
      "BEGIN\n  manage_student_interactions(p_student_id => 1025, p_action => 'OTHER');\nEND;",
      "BEGIN\n  manage_student_interactions(p_student_id => 1316, p_action => 'boost');\nEND;",
      "BEGIN\n  manage_student_interactions(p_student_id => 1510, p_action => 'reduce');\nEND;"
    ],
    "summary": "Create a stored procedure named manage_student_interactions that performs actions based on a student's total interactions (friends, likes given, likes received). For a 'BOOST' action: if interactions >20, add a random friend; if >10, add a random like; if <=10, delete all friends. For a 'REDUCE' action: if interactions <5, delete all likes given; otherwise, delete a random friend. For any other action, insert a new default student.",
    "natural_language": "Create procedure manage_student_interactions. For 'BOOST': if interactions >20, add random friend; if >10, add random like; if <=10, delete all friends. For 'REDUCE': if interactions <5, delete all likes given; else, delete random friend. For other actions, insert default student.",
    "id": 228
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_social_connections that accepts two input parameters, p_student_id of type NUMBER and p_friend_id of type NUMBER, and performs a series of operations to manage social connections between high school students. The procedure first queries the HIGHSCHOOLER table to verify the existence of the provided student IDs, storing the count of records with an ID equal to p_student_id into variable v_student_exists and the count of records with an ID equal to p_friend_id into variable v_friend_exists. If both counts are greater than zero, indicating both students exist, the procedure checks the FRIEND table for an existing friendship from the first student to the second by selecting the count of rows where the STUDENT_ID column equals p_student_id and the FRIEND_ID column equals p_friend_id into variable v_friendship_exists; if this count is zero, it inserts a new row into the FRIEND table with those column values. It then performs a similar check for the reverse friendship direction by selecting the count of rows where STUDENT_ID equals p_friend_id and FRIEND_ID equals p_student_id into the same variable; if this count is zero, it inserts another row into the FRIEND table with the reversed IDs. If either the p_student_id or p_friend_id does not exist in the HIGHSCHOOLER table, the procedure deletes all rows from the FRIEND table where either the STUDENT_ID column equals p_student_id or the FRIEND_ID column equals p_student_id. Subsequently, if both student IDs were confirmed to exist, the procedure checks the LIKES table for an existing 'like' relationship by selecting the count of rows where the STUDENT_ID column equals p_student_id and the LIKED_ID column equals p_friend_id into variable v_like_exists; if this count is zero, it inserts a new row into the LIKES table with those column values. If either student ID was not found to exist, the procedure deletes all rows from the LIKES table where either the STUDENT_ID column equals p_student_id or the LIKED_ID column equals p_student_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_social_connections(\n    p_student_id IN NUMBER,\n    p_friend_id IN NUMBER\n) IS\n    v_student_exists NUMBER;\n    v_friend_exists NUMBER;\n    v_friendship_exists NUMBER;\n    v_like_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM HIGHSCHOOLER WHERE ID = p_student_id;\n    SELECT COUNT(*) INTO v_friend_exists FROM HIGHSCHOOLER WHERE ID = p_friend_id;\n\n    IF v_student_exists > 0 AND v_friend_exists > 0 THEN\n        -- Check if friendship already exists\n        SELECT COUNT(*) INTO v_friendship_exists \n        FROM FRIEND \n        WHERE STUDENT_ID = p_student_id AND FRIEND_ID = p_friend_id;\n        \n        IF v_friendship_exists = 0 THEN\n            INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (p_student_id, p_friend_id);\n        END IF;\n        \n        -- Check if reverse friendship already exists\n        SELECT COUNT(*) INTO v_friendship_exists \n        FROM FRIEND \n        WHERE STUDENT_ID = p_friend_id AND FRIEND_ID = p_student_id;\n        \n        IF v_friendship_exists = 0 THEN\n            INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (p_friend_id, p_student_id);\n        END IF;\n    ELSE\n        DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id OR FRIEND_ID = p_student_id;\n    END IF;\n\n    IF v_student_exists > 0 AND v_friend_exists > 0 THEN\n        -- Check if like relationship already exists\n        SELECT COUNT(*) INTO v_like_exists \n        FROM LIKES \n        WHERE STUDENT_ID = p_student_id AND LIKED_ID = p_friend_id;\n        \n        IF v_like_exists = 0 THEN\n            INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (p_student_id, p_friend_id);\n        END IF;\n    ELSE\n        DELETE FROM LIKES WHERE STUDENT_ID = p_student_id OR LIKED_ID = p_student_id;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "BEGIN\n  manage_social_connections(1510, 1689);\nEND;",
      "BEGIN\n  manage_social_connections(1381, 1510);\nEND;",
      "BEGIN\n  manage_social_connections(1689, 1381);\nEND;",
      "BEGIN\n  manage_social_connections(1000, 2000);\nEND;",
      "BEGIN\n  manage_social_connections(1510, 9999);\nEND;"
    ],
    "summary": "Create a stored procedure named manage_social_connections to manage friendships and likes between two students. If both students exist, it establishes mutual friendships and a 'like' if they don't already exist. If either student does not exist, it deletes all friendships and likes involving the first student.",
    "natural_language": "Write a stored procedure called manage_social_connections to handle friendships and likes between two students. If both students are present, set up mutual friendships and a 'like' unless they already exist. If either student is missing, remove all friendships and likes associated with the first student.",
    "id": 229
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named adjust_student_grades that accepts a single input parameter p_student_id of type NUMBER, which represents the unique identifier of a student. The procedure begins by declaring two local variables: v_grade and v_friend_count, both of type NUMBER. It then retrieves the current grade of the student with the specified ID from the HIGHSCHOOLER table and stores it in the v_grade variable. Next, it calculates the number of friends associated with the student by counting the entries in the FRIEND table where the STUDENT_ID matches the provided p_student_id, storing this count in the v_friend_count variable. The procedure then evaluates the student's grade using conditional logic. If the student's grade is greater than 8, it checks the number of friends. If the student has more than 10 friends, it increases the student's grade by 1 in the HIGHSCHOOLER table. If the student has 10 or fewer friends, it deletes all entries from the FRIEND table where STUDENT_ID matches p_student_id. If the student's grade is 8 or less, the procedure checks the number of friends again. If the student has fewer than 5 friends, it decreases the student's grade by 1 in the HIGHSCHOOLER table. If the student has 5 or more friends, it deletes all entries from the LIKES table where STUDENT_ID matches p_student_id. If the grade does not meet any of the specified conditions, the procedure inserts a new row into the HIGHSCHOOLER table with a randomly generated ID between 1000 and 2000, a name 'NewStudent', and a grade of 9.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_student_grades(\n    p_student_id IN NUMBER\n) IS\n    v_grade NUMBER;\n    v_friend_count NUMBER;\nBEGIN\n    SELECT GRADE INTO v_grade FROM HIGHSCHOOLER WHERE ID = p_student_id;\n\n    SELECT COUNT(*) INTO v_friend_count\n    FROM FRIEND\n    WHERE STUDENT_ID = p_student_id;\n\n    IF v_grade > 8 THEN\n        IF v_friend_count > 10 THEN\n            UPDATE HIGHSCHOOLER SET GRADE = v_grade + 1 WHERE ID = p_student_id;\n        ELSE\n            DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id;\n        END IF;\n    ELSIF v_grade <= 8 THEN\n        IF v_friend_count < 5 THEN\n            UPDATE HIGHSCHOOLER SET GRADE = v_grade - 1 WHERE ID = p_student_id;\n        ELSE\n            DELETE FROM LIKES WHERE STUDENT_ID = p_student_id;\n        END IF;\n    ELSE\n        INSERT INTO HIGHSCHOOLER (ID, NAME, GRADE) VALUES (FLOOR(DBMS_RANDOM.VALUE(1000, 2000)), 'NewStudent', 9);\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_student_grades(1510);\nEND;",
      "BEGIN\n  adjust_student_grades(1689);\nEND;",
      "BEGIN\n  adjust_student_grades(1381);\nEND;",
      "BEGIN\n  adjust_student_grades(1101);\nEND;",
      "BEGIN\n  adjust_student_grades(1247);\nEND;"
    ],
    "summary": "Create a stored procedure named adjust_student_grades that adjusts a student's status based on their grade and friend count. For grades >8: if friends >10, increase grade by 1; otherwise, delete all friends. For grades <=8: if friends <5, decrease grade by 1; otherwise, delete all likes given. If no conditions match, insert a new default student.",
    "natural_language": "Formulate a stored procedure designated as `adjust_student_grades` to modify a student's standing contingent upon their academic grade and quantity of associates. For scholars with a grade exceeding eight: should their associate count surpass ten, increment the grade by one; if not, expunge all associated records. For scholars with a grade of eight or below: should their associate count be fewer than five, decrement the grade by one; otherwise, remove all records of likes issued. In the event that none of the stipulated conditions are satisfied, insert a new student record with default parameters.",
    "id": 230
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_student_likes that accepts two input parameters: p_student_id of type NUMBER and p_liked_id of type NUMBER. The procedure first declares two local NUMBER variables, v_student_exists and v_liked_exists. It begins execution by querying the HIGHSCHOOLER table to count rows where the ID column equals p_student_id, storing the result in v_student_exists, and then performs another query on the same table to count rows where the ID column equals p_liked_id, storing that result in v_liked_exists. The procedure then uses an IF-THEN-ELSE conditional block: if both v_student_exists and v_liked_exists are greater than zero, meaning both provided IDs exist in the HIGHSCHOOLER table, it performs a MERGE operation into the LIKES table (aliased as L). The MERGE uses a source subquery selecting the input parameters as STUDENT_ID and LIKED_ID from the DUAL table (aliased as S) and matches on the condition that L.STUDENT_ID equals S.STUDENT_ID and L.LIKED_ID equals S.LIKED_ID; when no matching row is found in the target LIKES table, it inserts a new row using the source's STUDENT_ID and LIKED_ID values. If the initial condition is not met (meaning at least one of the provided IDs does not exist in HIGHSCHOOLER), the ELSE branch executes a DELETE statement on the LIKES table, removing any rows where the STUDENT_ID column equals p_student_id or the LIKED_ID column equals p_liked_id. Following this, the procedure executes a second, independent IF-THEN-ELSE block that checks only if v_student_exists is greater than zero. If true, it performs another MERGE operation, this time into the FRIEND table (aliased as F). This MERGE uses a source subquery selecting p_student_id as STUDENT_ID and p_liked_id as FRIEND_ID from DUAL (aliased as S) and matches on the condition F.STUDENT_ID equals S.STUDENT_ID and F.FRIEND_ID equals S.FRIEND_ID; when no match is found, it inserts a new row with the source's STUDENT_ID and FRIEND_ID values. If v_student_exists is not greater than zero, the ELSE branch executes a DELETE statement on the FRIEND table, removing any rows where the STUDENT_ID column equals p_student_id or the FRIEND_ID column equals p_liked_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_student_likes(\n    p_student_id IN NUMBER,\n    p_liked_id IN NUMBER\n) IS\n    v_student_exists NUMBER;\n    v_liked_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM HIGHSCHOOLER WHERE ID = p_student_id;\n    SELECT COUNT(*) INTO v_liked_exists FROM HIGHSCHOOLER WHERE ID = p_liked_id;\n\n    IF v_student_exists > 0 AND v_liked_exists > 0 THEN\n        MERGE INTO LIKES L\n        USING (SELECT p_student_id AS STUDENT_ID, p_liked_id AS LIKED_ID FROM DUAL) S\n        ON (L.STUDENT_ID = S.STUDENT_ID AND L.LIKED_ID = S.LIKED_ID)\n        WHEN NOT MATCHED THEN\n            INSERT (STUDENT_ID, LIKED_ID) VALUES (S.STUDENT_ID, S.LIKED_ID);\n    ELSE\n        DELETE FROM LIKES WHERE STUDENT_ID = p_student_id OR LIKED_ID = p_liked_id;\n    END IF;\n\n    IF v_student_exists > 0 THEN\n        MERGE INTO FRIEND F\n        USING (SELECT p_student_id AS STUDENT_ID, p_liked_id AS FRIEND_ID FROM DUAL) S\n        ON (F.STUDENT_ID = S.STUDENT_ID AND F.FRIEND_ID = S.FRIEND_ID)\n        WHEN NOT MATCHED THEN\n            INSERT (STUDENT_ID, FRIEND_ID) VALUES (S.STUDENT_ID, S.FRIEND_ID);\n    ELSE\n        DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id OR FRIEND_ID = p_liked_id;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "BEGIN\n  manage_student_likes(1510, 1689);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(1381, 1510);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(1247, 1101);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(9999, 1510);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(1510, 9999);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named manage_student_likes that accepts a student ID and a liked ID. Check if both IDs exist in the HIGHSCHOOLER table. If they do, insert a like relationship into the LIKES table if it doesn't already exist. If at least one ID does not exist, delete any likes involving either ID. Then, if the student ID exists, insert a friend relationship into the FRIEND table if it doesn't already exist. If the student ID does not exist, delete any friend relationships involving either ID.",
    "natural_language": "Create procedure manage_student_likes with student ID and liked ID. If both IDs are in HIGHSCHOOLER, add to LIKES if new. Otherwise, delete their likes. If student ID exists, add to FRIENDS if new. Otherwise, delete their friends.",
    "id": 231
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named add_bandmate_to_performance that accepts three input parameters: a numeric parameter p_song_id, a numeric parameter p_bandmate_id, and a string parameter p_stage_position. The procedure first declares two local numeric variables, v_song_exists and v_bandmate_exists, initializing both to zero. It then queries the SONGS table to count the number of rows where the SONGID column equals the input parameter p_song_id, storing the result in v_song_exists. If the value of v_song_exists is zero, indicating the song does not exist, the procedure inserts a new row into the SONGS table, populating the SONGID column with p_song_id and the TITLE column with the concatenated string 'Default Song ' followed by the p_song_id value. Next, the procedure queries the BAND table to count the number of rows where the ID column equals the input parameter p_bandmate_id, storing the result in v_bandmate_exists. If the value of v_bandmate_exists is zero, indicating the bandmate does not exist, the procedure inserts a new row into the BAND table, populating the ID column with p_bandmate_id, the FIRSTNAME column with the string 'Default', and the LASTNAME column with the concatenated string 'Bandmate ' followed by the p_bandmate_id value. Finally, the procedure inserts a new row into the PERFORMANCE table, setting the SONGID column to the input parameter p_song_id, the BANDMATE column to the input parameter p_bandmate_id, and the STAGEPOSITION column to the input parameter p_stage_position.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_bandmate_to_performance(\n    p_song_id NUMBER,\n    p_bandmate_id NUMBER,\n    p_stage_position VARCHAR2\n)\nIS\n    v_song_exists NUMBER := 0;\n    v_bandmate_exists NUMBER := 0;\nBEGIN\n    -- Check if song exists\n    SELECT COUNT(*)\n    INTO v_song_exists\n    FROM SONGS\n    WHERE SONGID = p_song_id;\n    \n    -- If song doesn't exist, create a default song record\n    IF v_song_exists = 0 THEN\n        INSERT INTO SONGS (SONGID, TITLE)\n        VALUES (p_song_id, 'Default Song ' || p_song_id);\n    END IF;\n    \n    -- Check if bandmate exists\n    SELECT COUNT(*)\n    INTO v_bandmate_exists\n    FROM BAND\n    WHERE ID = p_bandmate_id;\n    \n    -- If bandmate doesn't exist, create a default bandmate record\n    IF v_bandmate_exists = 0 THEN\n        INSERT INTO BAND (ID, FIRSTNAME, LASTNAME)\n        VALUES (p_bandmate_id, 'Default', 'Bandmate ' || p_bandmate_id);\n    END IF;\n    \n    -- Insert into PERFORMANCE table\n    INSERT INTO PERFORMANCE (SONGID, BANDMATE, STAGEPOSITION)\n    VALUES (p_song_id, p_bandmate_id, p_stage_position);\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "BAND",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "BEGIN\n  add_bandmate_to_performance(p_song_id => 1, p_bandmate_id => 101, p_stage_position => 'Center Stage');\nEND;",
      "BEGIN\n  add_bandmate_to_performance(p_song_id => 2, p_bandmate_id => 102, p_stage_position => 'Left Wing');\nEND;",
      "BEGIN\n  add_bandmate_to_performance(p_song_id => 3, p_bandmate_id => 103, p_stage_position => 'Right Wing');\nEND;",
      "BEGIN\n  add_bandmate_to_performance(p_song_id => 4, p_bandmate_id => 104, p_stage_position => 'Back Left');\nEND;",
      "BEGIN\n  add_bandmate_to_performance(p_song_id => 5, p_bandmate_id => 105, p_stage_position => 'Back Right');\nEND;"
    ],
    "summary": "Create a stored procedure named add_bandmate_to_performance that accepts a song ID, a bandmate ID, and a stage position. If the song ID does not exist in the SONGS table, insert it with a default title. If the bandmate ID does not exist in the BAND table, insert it with default first and last names. Finally, insert a record into the PERFORMANCE table with the provided IDs and stage position.",
    "natural_language": "Create a stored procedure called add_bandmate_to_performance that takes a song ID, a bandmate ID, and a stage position. If that song ID isn't found in the SONGS table, put it in there with a generic title. Similarly, if that bandmate ID isn't in the BAND table, add a new entry with some placeholder names. Then, just add a new record to the PERFORMANCE table using those IDs and the given stage position.",
    "id": 232
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_adjust_grades` that accepts four input parameters and one output parameter. The first input parameter, `p_classroom`, is of type `NUMBER` and represents a specific classroom identifier. The second input parameter, `p_grade_adjustment`, is also of type `NUMBER` and represents the value by which grades should be adjusted. The third input parameter, `p_teacher_last`, is of type `VARCHAR2` and represents the last name of a teacher. The fourth input parameter, `p_teacher_first`, is of type `VARCHAR2` and represents the first name of a teacher. The single output parameter, `p_result_count`, is of type `NUMBER` and will store the count of students found in the specified classroom.\n\nUpon execution, the procedure first declares a local variable `v_student_count` of type `NUMBER` to temporarily store the count of students. It then performs a `SELECT` operation to count the number of rows in the `LIST` table where the `CLASSROOM` column matches the value provided in the `p_classroom` input parameter. The result of this count is stored in the `v_student_count` variable.\n\nFollowing this, the procedure evaluates a conditional statement:\nIf the value of `v_student_count` is greater than `0`, indicating that students were found in the specified classroom, the procedure executes an `UPDATE` operation. This `UPDATE` operation modifies the `LIST` table by setting the `GRADE` column to its current value plus the `p_grade_adjustment` value for all rows where the `CLASSROOM` column matches the `p_classroom` input parameter.\nIf the value of `v_student_count` is not greater than `0` (i.e., it is `0` or less, implying no students were found in the specified classroom), the procedure executes an `INSERT` operation. This `INSERT` operation adds a new row into the `TEACHERS` table. The `LASTNAME` column of the new row is populated with the value from `p_teacher_last`, the `FIRSTNAME` column is populated with the value from `p_teacher_first`, and the `CLASSROOM` column is populated with the value from `p_classroom`.\n\nFinally, regardless of whether an `UPDATE` or `INSERT` operation was performed, the procedure assigns the final value of `v_student_count` to the `p_result_count` output parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_adjust_grades (\n    p_classroom IN NUMBER,\n    p_grade_adjustment IN NUMBER,\n    p_teacher_last IN VARCHAR2,\n    p_teacher_first IN VARCHAR2,\n    p_result_count OUT NUMBER\n)\nIS\n    v_student_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_student_count\n    FROM LIST\n    WHERE CLASSROOM = p_classroom;\n\n    IF v_student_count > 0 THEN\n        UPDATE LIST\n        SET GRADE = GRADE + p_grade_adjustment\n        WHERE CLASSROOM = p_classroom;\n    ELSE\n        INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM)\n        VALUES (p_teacher_last, p_teacher_first, p_classroom);\n    END IF;\n\n    p_result_count := v_student_count;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "DECLARE\n  v_result_count NUMBER;\nBEGIN\n  proc_adjust_grades(101, 5, 'Smith', 'John', v_result_count);\n  DBMS_OUTPUT.PUT_LINE('Result Count: ' || v_result_count);\nEND;",
      "DECLARE\n  v_result_count NUMBER;\nBEGIN\n  proc_adjust_grades(102, 3, 'Johnson', 'Emily', v_result_count);\n  DBMS_OUTPUT.PUT_LINE('Result Count: ' || v_result_count);\nEND;",
      "DECLARE\n  v_result_count NUMBER;\nBEGIN\n  proc_adjust_grades(103, 2, 'Williams', 'Michael', v_result_count);\n  DBMS_OUTPUT.PUT_LINE('Result Count: ' || v_result_count);\nEND;",
      "DECLARE\n  v_result_count NUMBER;\nBEGIN\n  proc_adjust_grades(104, 4, 'Brown', 'Jessica', v_result_count);\n  DBMS_OUTPUT.PUT_LINE('Result Count: ' || v_result_count);\nEND;",
      "DECLARE\n  v_result_count NUMBER;\nBEGIN\n  proc_adjust_grades(105, 1, 'Davis', 'Christopher', v_result_count);\n  DBMS_OUTPUT.PUT_LINE('Result Count: ' || v_result_count);\nEND;"
    ],
    "summary": "Create a stored procedure named proc_adjust_grades that accepts a classroom number, a grade adjustment value, and a teacher's first and last name. It returns the count of students in that classroom. If students are found, increase their grades by the adjustment value. If no students are found, insert a new teacher record with the provided name and classroom. Return the student count.",
    "natural_language": "Hey, can you whip up a stored procedure called proc_adjust_grades? It needs to take a classroom number, a number to bump up grades by, and a teacher's first and last name. It should spit back how many kids are in that room. If there are any students, just go ahead and add that adjustment value to all their grades. If the room's empty, though, pop in a new teacher record using the name and classroom number we gave you. Just give me back the student count in the end.",
    "id": 233
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_teacher_course_assignments that does not take any parameters and performs operations based on the number of courses in the COURSE table. It first declares several local variables: v_course_count, v_teacher_count, v_grade_value, v_temp_course_id, v_temp_teacher_id, v_cos_result, and v_loop_counter, all of type NUMBER, with v_loop_counter initialized to 0. The procedure begins by selecting the total count of rows from the COURSE table into v_course_count and the total count of rows from the TEACHER table into v_teacher_count. If v_course_count is greater than 5, it enters a loop iterating from 1 to v_course_count. Within this loop, it calculates the cosine of the loop index i, storing the result in v_cos_result. Depending on the value of v_cos_result, it performs different operations: if v_cos_result is greater than 0.8, it selects the COURSE_ID from the COURSE table where COURSE_ID equals i into v_temp_course_id and deletes from the COURSE_ARRANGE table where COURSE_ID matches v_temp_course_id; if v_cos_result is between 0.6 and 0.8, it selects the COURSE_ID into v_temp_course_id, calculates v_grade_value as the truncated product of v_cos_result and 10, and inserts a new row into COURSE_ARRANGE with COURSE_ID as v_temp_course_id, TEACHER_ID as 1, and GRADE as v_grade_value; if v_cos_result is between 0.4 and 0.6, it performs a similar operation but multiplies v_cos_result by 5 and sets TEACHER_ID to 2; if v_cos_result is between 0.2 and 0.4, it multiplies v_cos_result by 3 and sets TEACHER_ID to 3; if v_cos_result is between 0 and 0.2, it multiplies v_cos_result by 2 and sets TEACHER_ID to 4; otherwise, it calculates v_grade_value as the absolute value of the truncated v_cos_result, sets TEACHER_ID to 5, and inserts the row. After each iteration, it increments v_loop_counter by 1. If v_course_count is greater than 3 but not more than 5, it iterates over each teacher record ordered by age, calculates the cosine of the TEACHER_ID, and based on the result, inserts a row into COURSE_ARRANGE with COURSE_ID set to a specific value and GRADE calculated using the modulus of the teacher's age. If v_cos_result is greater than 0.7, it sets COURSE_ID to 1 and GRADE to the modulus of age by 4 plus 1; if between 0.5 and 0.7, it sets COURSE_ID to 2 and GRADE to the modulus of age by 3 plus 1; if between 0.3 and 0.5, it sets COURSE_ID to 3 and GRADE to the modulus of age by 2 plus 1; otherwise, it sets COURSE_ID to 4 and GRADE to the teacher's age minus 25. If v_course_count is 3 or less, it iterates from 1 to 3, calculates the cosine of twice the loop index, and if the result is positive, inserts a row into COURSE_ARRANGE with COURSE_ID and TEACHER_ID both set to the loop index and GRADE set to the truncated product of the cosine result and 100.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_teacher_course_assignments\nIS\n   v_course_count NUMBER;\n   v_teacher_count NUMBER;\n   v_grade_value NUMBER;\n   v_temp_course_id NUMBER;\n   v_temp_teacher_id NUMBER;\n   v_cos_result NUMBER;\n   v_loop_counter NUMBER := 0;\nBEGIN\n   SELECT COUNT(*) INTO v_course_count FROM COURSE;\n   SELECT COUNT(*) INTO v_teacher_count FROM TEACHER;\n   \n   IF v_course_count > 5 THEN\n      FOR i IN 1..v_course_count LOOP\n         v_cos_result := COS(i);\n         IF v_cos_result > 0.8 THEN\n            SELECT COURSE_ID INTO v_temp_course_id FROM COURSE WHERE COURSE_ID = i;\n            DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = v_temp_course_id;\n         ELSIF v_cos_result > 0.6 THEN\n            SELECT COURSE_ID INTO v_temp_course_id FROM COURSE WHERE COURSE_ID = i;\n            v_grade_value := TRUNC(v_cos_result * 10);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (v_temp_course_id, 1, v_grade_value);\n         ELSIF v_cos_result > 0.4 THEN\n            SELECT COURSE_ID INTO v_temp_course_id FROM COURSE WHERE COURSE_ID = i;\n            v_grade_value := TRUNC(v_cos_result * 5);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (v_temp_course_id, 2, v_grade_value);\n         ELSIF v_cos_result > 0.2 THEN\n            SELECT COURSE_ID INTO v_temp_course_id FROM COURSE WHERE COURSE_ID = i;\n            v_grade_value := TRUNC(v_cos_result * 3);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (v_temp_course_id, 3, v_grade_value);\n         ELSIF v_cos_result > 0 THEN\n            SELECT COURSE_ID INTO v_temp_course_id FROM COURSE WHERE COURSE_ID = i;\n            v_grade_value := TRUNC(v_cos_result * 2);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (v_temp_course_id, 4, v_grade_value);\n         ELSE\n            SELECT COURSE_ID INTO v_temp_course_id FROM COURSE WHERE COURSE_ID = i;\n            v_grade_value := ABS(TRUNC(v_cos_result));\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (v_temp_course_id, 5, v_grade_value);\n         END IF;\n         v_loop_counter := v_loop_counter + 1;\n      END LOOP;\n   ELSIF v_course_count > 3 THEN\n      FOR teacher_rec IN (SELECT TEACHER_ID, AGE FROM TEACHER ORDER BY TO_NUMBER(AGE)) LOOP\n         v_cos_result := COS(teacher_rec.TEACHER_ID);\n         IF v_cos_result > 0.7 THEN\n            v_grade_value := MOD(TO_NUMBER(teacher_rec.AGE), 4) + 1;\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (1, teacher_rec.TEACHER_ID, v_grade_value);\n         ELSIF v_cos_result > 0.5 THEN\n            v_grade_value := MOD(TO_NUMBER(teacher_rec.AGE), 3) + 1;\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (2, teacher_rec.TEACHER_ID, v_grade_value);\n         ELSIF v_cos_result > 0.3 THEN\n            v_grade_value := MOD(TO_NUMBER(teacher_rec.AGE), 2) + 1;\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (3, teacher_rec.TEACHER_ID, v_grade_value);\n         ELSE\n            v_grade_value := TO_NUMBER(teacher_rec.AGE) - 25;\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (4, teacher_rec.TEACHER_ID, v_grade_value);\n         END IF;\n      END LOOP;\n   ELSE\n      FOR i IN 1..3 LOOP\n         v_cos_result := COS(i * 2);\n         IF v_cos_result > 0 THEN\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, i, TRUNC(v_cos_result * 100));\n         END IF;\n      END LOOP;\n   END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  process_teacher_course_assignments;\nEND;"
    ],
    "summary": "Create a stored procedure named process_teacher_course_assignments with no parameters. Count the courses and teachers. If course count > 5, loop through courses, calculate cosine of the index, and based on its value, either delete from or insert into the COURSE_ARRANGE table with specific teacher IDs and calculated grades. If course count is between 3 and 5, loop through teachers ordered by age, calculate cosine of teacher ID, and insert into COURSE_ARRANGE with specific course IDs and grades based on age. If course count <= 3, loop from 1 to 3, calculate cosine of twice the index, and if positive, insert into COURSE_ARRANGE.",
    "natural_language": "Please construct a stored procedure designated as 'process_teacher_course_assignments' that accepts no parameters. The procedure shall commence by determining the total counts of courses and teachers. Should the course count exceed five, the procedure must iterate through each course. For each iteration, compute the cosine of the current index. Depending on the resultant cosine value, execute either a deletion from or an insertion into the COURSE_ARRANGE table, utilizing specified teacher identifiers and derived grade values. If the course count is greater than or equal to three and less than or equal to five, iterate through teachers in ascending order of age. For each teacher, calculate the cosine of the teacher's identifier and perform an insertion into the COURSE_ARRANGE table with designated course identifiers and grades determined by the teacher's age. In the event the course count is three or fewer, iterate from one to three. For each iteration, compute the cosine of twice the index value. If the computed cosine is positive, proceed with an insertion into the COURSE_ARRANGE table.",
    "id": 234
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `transform_course_data_based_on_teachers` that does not accept any input parameters. This procedure declares several local variables: `v_total_teachers` of type `NUMBER` to store the count of teachers, `v_average_age` of type `NUMBER` to store the average age of teachers, `v_cos_value` of type `NUMBER` to store the result of a cosine calculation, `v_grade_calc` of type `NUMBER` to store a calculated grade value, and `v_counter` of type `NUMBER` initialized to `0` to act as a loop counter.\n\nThe procedure begins by executing two `SELECT` statements:\n1. It retrieves the total number of records from the `TEACHER` table and stores this count in the `v_total_teachers` variable.\n2. It calculates the average of the `AGE` column from the `TEACHER` table, explicitly converting the `AGE` column to a `NUMBER` type using `TO_NUMBER(AGE)` before averaging, and stores this average in the `v_average_age` variable.\n\nFollowing these initial data retrievals, the procedure enters a conditional block based on the value of `v_total_teachers`:\n\n**Condition 1: `IF v_total_teachers > 10 THEN`**\nIf the total number of teachers is greater than 10, the procedure executes a `FOR` loop that iterates from `1` up to the value of `v_total_teachers`. Inside this loop, for each iteration `i`:\n   - It calculates the cosine of `i` using the `COS(i)` function and stores the result in `v_cos_value`.\n   - It then enters a nested conditional block based on `v_cos_value`:\n     - **`IF v_cos_value > 0.9 THEN`**:\n       - It deletes records from the `COURSE_ARRANGE` table where `COURSE_ID` matches the current loop variable `i` AND `GRADE` is greater than `4`.\n       - It calculates `v_grade_calc` by truncating the result of `v_cos_value` multiplied by `100` using `TRUNC(v_cos_value * 100)`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `MOD(i, 5) + 1` (the remainder of `i` divided by 5, plus 1), and `GRADE` set to `v_grade_calc`.\n     - **`ELSIF v_cos_value > 0.7 THEN`**:\n       - It deletes records from the `COURSE_ARRANGE` table where `COURSE_ID` matches `i` AND `GRADE` is less than `2`.\n       - It calculates `v_grade_calc` by truncating the result of `v_cos_value` multiplied by `50` using `TRUNC(v_cos_value * 50)`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `MOD(i, 4) + 1`, and `GRADE` set to `v_grade_calc`.\n     - **`ELSIF v_cos_value > 0.5 THEN`**:\n       - It deletes records from the `COURSE_ARRANGE` table where `COURSE_ID` matches `i` AND `GRADE` is equal to `3`.\n       - It calculates `v_grade_calc` by truncating the result of `v_cos_value` multiplied by `25` using `TRUNC(v_cos_value * 25)`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `MOD(i, 3) + 1`, and `GRADE` set to `v_grade_calc`.\n     - **`ELSIF v_cos_value > 0.3 THEN`**:\n       - It deletes all records from the `COURSE_ARRANGE` table where `COURSE_ID` matches `i`.\n       - It calculates `v_grade_calc` by truncating the result of `v_cos_value` multiplied by `10` using `TRUNC(v_cos_value * 10)`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `MOD(i, 2) + 1`, and `GRADE` set to `v_grade_calc`.\n     - **`ELSIF v_cos_value > 0.1 THEN`**:\n       - It calculates `v_grade_calc` by truncating the result of `v_cos_value` multiplied by `5` using `TRUNC(v_cos_value * 5)`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `i`, and `GRADE` set to `v_grade_calc`.\n     - **`ELSE` (if `v_cos_value` is `0.1` or less)**:\n       - It calculates `v_grade_calc` by truncating the absolute value of `v_cos_value` multiplied by `2` using `TRUNC(ABS(v_cos_value) * 2)`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `v_total_teachers - i + 1`, and `GRADE` set to `v_grade_calc`.\n   - After the nested conditional block, `v_counter` is incremented by `1`.\n\n**Condition 2: `ELSIF v_total_teachers > 5 THEN`**\nIf the total number of teachers is not greater than 10 but is greater than 5, the procedure executes a `FOR` loop that iterates through each `COURSE_ID` from the `COURSE` table, ordered by `COURSE_ID`. For each `course_rec` (representing a row from the `COURSE` table) in this loop:\n   - It calculates the cosine of `course_rec.COURSE_ID` multiplied by `2` using `COS(course_rec.COURSE_ID * 2)` and stores the result in `v_cos_value`.\n   - It then enters a nested conditional block based on `v_cos_value`:\n     - **`IF v_cos_value > 0.6 THEN`**:\n       - It deletes all records from the `COURSE_ARRANGE` table where `COURSE_ID` matches `course_rec.COURSE_ID`.\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `course_rec.COURSE_ID`, `TEACHER_ID` set to `1`, and `GRADE` set to the truncated result of `v_cos_value` multiplied by `20` using `TRUNC(v_cos_value * 20)`.\n     - **`ELSIF v_cos_value > 0.3 THEN`**:\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `course_rec.COURSE_ID`, `TEACHER_ID` set to `2`, and `GRADE` set to the truncated result of `v_cos_value` multiplied by `15` using `TRUNC(v_cos_value * 15)`.\n     - **`ELSE` (if `v_cos_value` is `0.3` or less)**:\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `course_rec.COURSE_ID`, `TEACHER_ID` set to `3`, and `GRADE` set to the truncated result of the absolute value of `v_cos_value` multiplied by `10` using `TRUNC(ABS(v_cos_value) * 10)`.\n\n**Condition 3: `ELSE` (if `v_total_teachers` is `5` or less)**\nIf the total number of teachers is not greater than 5, the procedure executes a `FOR` loop that iterates from `1` to `3`. Inside this loop, for each iteration `i`:\n   - It calculates the cosine of `i` multiplied by `3` using `COS(i * 3)` and stores the result in `v_cos_value`.\n   - It then checks if `v_cos_value` is greater than `0`:\n     - **`IF v_cos_value > 0 THEN`**:\n       - It inserts a new record into the `COURSE_ARRANGE` table with `COURSE_ID` set to `i`, `TEACHER_ID` set to `i + 1`, and `GRADE` set to the truncated result of `v_cos_value` multiplied by `30` using `TRUNC(v_cos_value * 30)`.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_course_data_based_on_teachers\nIS\n   v_total_teachers NUMBER;\n   v_average_age NUMBER;\n   v_cos_value NUMBER;\n   v_grade_calc NUMBER;\n   v_counter NUMBER := 0;\nBEGIN\n   SELECT COUNT(*) INTO v_total_teachers FROM TEACHER;\n   SELECT AVG(TO_NUMBER(AGE)) INTO v_average_age FROM TEACHER;\n   \n   IF v_total_teachers > 10 THEN\n      FOR i IN 1..v_total_teachers LOOP\n         v_cos_value := COS(i);\n         IF v_cos_value > 0.9 THEN\n            DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = i AND GRADE > 4;\n            v_grade_calc := TRUNC(v_cos_value * 100);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, MOD(i, 5) + 1, v_grade_calc);\n         ELSIF v_cos_value > 0.7 THEN\n            DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = i AND GRADE < 2;\n            v_grade_calc := TRUNC(v_cos_value * 50);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, MOD(i, 4) + 1, v_grade_calc);\n         ELSIF v_cos_value > 0.5 THEN\n            DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = i AND GRADE = 3;\n            v_grade_calc := TRUNC(v_cos_value * 25);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, MOD(i, 3) + 1, v_grade_calc);\n         ELSIF v_cos_value > 0.3 THEN\n            DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = i;\n            v_grade_calc := TRUNC(v_cos_value * 10);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, MOD(i, 2) + 1, v_grade_calc);\n         ELSIF v_cos_value > 0.1 THEN\n            v_grade_calc := TRUNC(v_cos_value * 5);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, i, v_grade_calc);\n         ELSE\n            v_grade_calc := TRUNC(ABS(v_cos_value) * 2);\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, v_total_teachers - i + 1, v_grade_calc);\n         END IF;\n         v_counter := v_counter + 1;\n      END LOOP;\n   ELSIF v_total_teachers > 5 THEN\n      FOR course_rec IN (SELECT COURSE_ID FROM COURSE ORDER BY COURSE_ID) LOOP\n         v_cos_value := COS(course_rec.COURSE_ID * 2);\n         IF v_cos_value > 0.6 THEN\n            DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = course_rec.COURSE_ID;\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (course_rec.COURSE_ID, 1, TRUNC(v_cos_value * 20));\n         ELSIF v_cos_value > 0.3 THEN\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (course_rec.COURSE_ID, 2, TRUNC(v_cos_value * 15));\n         ELSE\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (course_rec.COURSE_ID, 3, TRUNC(ABS(v_cos_value) * 10));\n         END IF;\n      END LOOP;\n   ELSE\n      FOR i IN 1..3 LOOP\n         v_cos_value := COS(i * 3);\n         IF v_cos_value > 0 THEN\n            INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE) VALUES (i, i + 1, TRUNC(v_cos_value * 30));\n         END IF;\n      END LOOP;\n   END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  transform_course_data_based_on_teachers;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named transform_course_data_based_on_teachers with no parameters. Count the teachers and calculate their average age. If teacher count > 10, loop from 1 to the count, calculate cosine of the index, and based on its value, delete from and insert into the COURSE_ARRANGE table with specific teacher IDs and calculated grades. If teacher count is between 5 and 10, loop through courses, calculate cosine of twice the course ID, and based on its value, delete from and insert into COURSE_ARRANGE. If teacher count <= 5, loop from 1 to 3, calculate cosine of three times the index, and if positive, insert into COURSE_ARRANGE.",
    "natural_language": "Create a stored procedure called transform_course_data_based_on_teachers with no parameters. Figure out roughly how many teachers there are and get a ballpark average for their age. If there are quite a few teachers, say more than a handful, go through a bunch of steps, compute some cosine values for the indices, and depending on those results, clean out and then add some entries to the COURSE_ARRANGE table for certain teachers with estimated grades. If the teacher count is just a moderate number, loop over the courses, work out the cosine for a multiple of the course ID, and based on whether that value looks good, delete and insert records into COURSE_ARRANGE. If there are only a small number of teachers, just run a short loop a few times, check if the cosine for a tripled index is positive, and if it seems okay, put some data into COURSE_ARRANGE.",
    "id": 235
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_delete_old_addresses` that accepts three input parameters: `para_address_type` of data type `VARCHAR2`, `para_date_from` of data type `VARCHAR2`, and `para_date_to` of data type `VARCHAR2`. The purpose of this procedure is to delete records from the `PARTY_ADDRESSES` table. The deletion operation is performed based on a set of conditions. Specifically, a record will be deleted if its `ADDRESS_TYPE_CODE` column value exactly matches the value provided in the `para_address_type` parameter. Additionally, two date-based conditions must be met. The first date condition requires that the value in the `DATE_ADDRESS_FROM` column, after being converted from a string to a date using the format mask 'YYYY-MM-DD HH24:MI:SS', must be strictly less than the value of the `para_date_from` parameter, which is also converted from a string to a date using the same format mask 'YYYY-MM-DD HH24:MI:SS'. The second date condition requires that the value in the `DATE_ADDRESS_TO` column, after being converted from a string to a date using the format mask 'YYYY-MM-DD HH24:MI:SS', must be strictly less than the value of the `para_date_to` parameter, which is similarly converted from a string to a date using the format mask 'YYYY-MM-DD HH24:MI:SS'. All three conditions (address type match, `DATE_ADDRESS_FROM` before `para_date_from`, and `DATE_ADDRESS_TO` before `para_date_to`) must be true for a row to be deleted from the `PARTY_ADDRESSES` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_delete_old_addresses(para_address_type VARCHAR2, para_date_from VARCHAR2, para_date_to VARCHAR2) IS\nBEGIN\nDELETE FROM PARTY_ADDRESSES \nWHERE ADDRESS_TYPE_CODE = para_address_type \nAND TO_DATE(DATE_ADDRESS_FROM, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(para_date_from, 'YYYY-MM-DD HH24:MI:SS') \nAND TO_DATE(DATE_ADDRESS_TO, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(para_date_to, 'YYYY-MM-DD HH24:MI:SS');\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_delete_old_addresses('Residence', '2018-01-01 00:00:00', '2018-03-01 00:00:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_delete_old_addresses('Billing', '2017-06-01 00:00:00', '2018-06-01 00:00:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_delete_old_addresses('Delivery', '2015-12-31 23:59:59', '2017-12-31 23:59:59');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_delete_old_addresses('Residence', '2019-05-15 12:00:00', '2020-01-01 00:00:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_delete_old_addresses('Billing', '2016-07-04 14:30:00', '2017-07-04 14:30:00');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_delete_old_addresses that deletes records from the PARTY_ADDRESSES table where ADDRESS_TYPE_CODE matches the input parameter, and both DATE_ADDRESS_FROM and DATE_ADDRESS_TO (converted from strings using format 'YYYY-MM-DD HH24:MI:SS') are earlier than their respective input date parameters.",
    "natural_language": "Develop a stored procedure, which should be named sp_delete_old_addresses, that is responsible for the deletion of records from the PARTY_ADDRESSES table. This procedure must specifically target entries where the ADDRESS_TYPE_CODE column precisely corresponds to the value provided through its input parameter. Furthermore, it must verify that both the DATE_ADDRESS_FROM and DATE_ADDRESS_TO fields, after being carefully converted from their string representations using the explicit format 'YYYY-MM-DD HH24:MI:SS', are definitively earlier than the distinct date parameters that are also supplied as inputs to the procedure.",
    "id": 236
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_insert_party_form that accepts three parameters: para_party_id of type NUMBER, para_form_id of type NUMBER, and para_status_code of type VARCHAR2. The procedure performs an insertion operation into the PARTY_FORMS table, specifically inserting a new row with the values provided by the parameters. The PARTY_ID column is set to the value of para_party_id, the FORM_ID column is set to the value of para_form_id, and the FORM_STATUS_CODE column is set to the value of para_status_code. There are no conditional statements, function calls, or special operations involved in this procedure; it simply inserts the provided values directly into the specified columns of the PARTY_FORMS table.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_insert_party_form(para_party_id NUMBER, para_form_id NUMBER, para_status_code VARCHAR2) IS\nBEGIN\nINSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, FORM_STATUS_CODE) VALUES (para_party_id, para_form_id, para_status_code);\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_insert_party_form(1, 1, 'Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(2, 2, 'Partially Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(3, 3, 'Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(1, 2, 'Partially Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(2, 3, 'Completed');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_insert_party_form that inserts a new row into the PARTY_FORMS table using the three input parameters for PARTY_ID, FORM_ID, and FORM_STATUS_CODE.",
    "natural_language": "Create procedure sp_insert_party_form to insert into PARTY_FORMS using PARTY_ID, FORM_ID, FORM_STATUS_CODE.",
    "id": 237
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_update_form_description` that accepts three input parameters: `para_form_type` of data type `VARCHAR2`, intended to represent the type code of a form; `para_form_name` of data type `VARCHAR2`, intended to represent the name of a form; and `para_new_description` of data type `VARCHAR2`, intended to represent the new description to be assigned to a form. The procedure performs a single `UPDATE` operation on the `FORMS` table. Specifically, it sets the value of the `FORM_DESCRIPTION` column to the value provided in the `para_new_description` parameter. This update is conditionally applied only to those rows in the `FORMS` table where the value in the `FORM_TYPE_CODE` column exactly matches the value provided in the `para_form_type` parameter AND the value in the `FORM_NAME` column exactly matches the value provided in the `para_form_name` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_form_description(para_form_type VARCHAR2, para_form_name VARCHAR2, para_new_description VARCHAR2) IS\nBEGIN\nUPDATE FORMS SET FORM_DESCRIPTION = para_new_description WHERE FORM_TYPE_CODE = para_form_type AND FORM_NAME = para_form_name;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_form_description('Basic', 'SSN Application', 'Updated description for SSN Application form');\nEND;",
      "BEGIN\n  sp_update_form_description('Complex', 'Marriage Certificate', 'New detailed description for Marriage Certificate');\nEND;",
      "BEGIN\n  sp_update_form_description('Basic', 'Divorce Certificate', 'Revised description for Divorce Certificate form');\nEND;",
      "BEGIN\n  sp_update_form_description('Complex', 'SSN Application', 'Complex version SSN form description update');\nEND;",
      "BEGIN\n  sp_update_form_description('Basic', 'Marriage Certificate', 'Basic marriage certificate form description');\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_form_description that updates the FORM_DESCRIPTION column in the FORMS table to a new value, but only for rows where FORM_TYPE_CODE and FORM_NAME match the input parameters.",
    "natural_language": "Please construct a stored procedure designated as sp_update_form_description. Its function is to modify the FORM_DESCRIPTION column within the FORMS table, assigning a new specified value. This update shall be applied exclusively to those records for which the FORM_TYPE_CODE and FORM_NAME correspond precisely to the provided input parameters.",
    "id": 238
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_delete_completed_forms that accepts three input parameters: para_date_started of type VARCHAR2, which represents a date and time string for the start date threshold; para_date_completed of type VARCHAR2, which represents a date and time string for the completion date threshold; and para_status_code of type VARCHAR2, which represents a specific form status code. The procedure performs a DELETE operation on the PARTY_FORMS table. It deletes all rows from the PARTY_FORMS table where the following three conditions are simultaneously met: first, the DATE_COMPLETION_STARTED column, after being converted from a string to a DATE data type using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS', yields a date that is earlier than the date derived by converting the para_date_started parameter string to a DATE using the same TO_DATE function and format model; second, the DATE_FULLY_COMPLETED column, after being converted from a string to a DATE data type using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS', yields a date that is earlier than the date derived by converting the para_date_completed parameter string to a DATE using the same TO_DATE function and format model; and third, the FORM_STATUS_CODE column value is exactly equal to the value provided in the para_status_code parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_delete_completed_forms(para_date_started VARCHAR2, para_date_completed VARCHAR2, para_status_code VARCHAR2) IS\nBEGIN\n  DELETE FROM PARTY_FORMS\n  WHERE TO_DATE(DATE_COMPLETION_STARTED, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(para_date_started, 'YYYY-MM-DD HH24:MI:SS')\n    AND TO_DATE(DATE_FULLY_COMPLETED, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(para_date_completed, 'YYYY-MM-DD HH24:MI:SS')\n    AND FORM_STATUS_CODE = para_status_code;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_delete_completed_forms('2017-12-10 00:00:00', '2018-02-01 00:00:00', 'Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-12-15 12:00:00', '2018-02-10 10:00:00', 'Partially Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-12-01 00:00:00', '2018-01-01 00:00:00', 'Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-11-01 00:00:00', '2018-03-01 00:00:00', 'Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-12-20 00:00:00', '2018-02-20 00:00:00', 'Partially Completed');\nEND;"
    ],
    "summary": "Create a stored procedure named sp_delete_completed_forms that deletes records from the PARTY_FORMS table where DATE_COMPLETION_STARTED and DATE_FULLY_COMPLETED (converted from strings using format 'YYYY-MM-DD HH24:MI:SS') are earlier than their respective input date thresholds, and FORM_STATUS_CODE matches the input parameter.",
    "natural_language": "Write a stored procedure called sp_delete_completed_forms to remove records from the PARTY_FORMS table where the converted DATE_COMPLETION_STARTED and DATE_FULLY_COMPLETED dates (using the format 'YYYY-MM-DD HH24:MI:SS') are before their given input date thresholds and the FORM_STATUS_CODE equals the provided input parameter.",
    "id": 239
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_catalog that accepts three input parameters: a numeric parameter p_catalog_level, a numeric parameter p_price_threshold, and a string parameter p_new_name. The procedure begins by declaring a cursor named cur_catalog that selects the CATALOG_ENTRY_ID and PRICE_IN_DOLLARS columns from the CATALOG_CONTENTS table for all rows where the CATALOG_LEVEL_NUMBER column equals the input p_catalog_level, with the FOR UPDATE clause to lock the selected rows. It also declares local numeric variables v_entry_id, v_price, and v_attr_exists. The procedure opens the cursor and enters a loop, fetching each row's CATALOG_ENTRY_ID into v_entry_id and PRICE_IN_DOLLARS into v_price. The loop exits when no more rows are found. For each fetched row, if the v_price is greater than the input p_price_threshold, it updates the current row in the CATALOG_CONTENTS table, setting the CATALOG_ENTRY_NAME column to the input p_new_name using the WHERE CURRENT OF clause. It then queries the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, counting the number of rows where the CATALOG_ENTRY_ID equals the current v_entry_id and stores the result in v_attr_exists. If v_attr_exists is greater than zero, it updates the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, setting the ATTRIBUTE_VALUE column to '1' for the row where CATALOG_ENTRY_ID equals v_entry_id. If v_attr_exists is zero, it inserts a new row into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES with columns CATALOG_ENTRY_ID set to v_entry_id, CATALOG_LEVEL_NUMBER set to p_catalog_level, ATTRIBUTE_ID set to 1, and ATTRIBUTE_VALUE set to '0'. If the v_price is less than the input p_price_threshold, it deletes from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table any row where the CATALOG_ENTRY_ID equals the current v_entry_id. If the v_price is neither greater than nor less than p_price_threshold (i.e., it is equal), it updates the current row in the CATALOG_CONTENTS table, setting the PRICE_IN_EUROS column to its current value multiplied by 1.1 using the WHERE CURRENT OF clause. After processing all rows, the procedure closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_catalog(p_catalog_level NUMBER, p_price_threshold NUMBER, p_new_name VARCHAR2) IS\n  CURSOR cur_catalog IS SELECT CATALOG_ENTRY_ID, PRICE_IN_DOLLARS FROM CATALOG_CONTENTS WHERE CATALOG_LEVEL_NUMBER = p_catalog_level FOR UPDATE;\n  v_entry_id NUMBER;\n  v_price NUMBER;\n  v_attr_exists NUMBER;\nBEGIN\n  OPEN cur_catalog;\n  LOOP\n    FETCH cur_catalog INTO v_entry_id, v_price;\n    EXIT WHEN cur_catalog%NOTFOUND;\n    IF v_price > p_price_threshold THEN\n      UPDATE CATALOG_CONTENTS SET CATALOG_ENTRY_NAME = p_new_name WHERE CURRENT OF cur_catalog;\n      SELECT COUNT(*) INTO v_attr_exists FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = v_entry_id;\n      IF v_attr_exists > 0 THEN\n        UPDATE CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES SET ATTRIBUTE_VALUE = '1' WHERE CATALOG_ENTRY_ID = v_entry_id;\n      ELSE\n        INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE) VALUES (v_entry_id, p_catalog_level, 1, '0');\n      END IF;\n    ELSIF v_price < p_price_threshold THEN\n      DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = v_entry_id;\n    ELSE\n      UPDATE CATALOG_CONTENTS SET PRICE_IN_EUROS = PRICE_IN_EUROS * 1.1 WHERE CURRENT OF cur_catalog;\n    END IF;\n  END LOOP;\n  CLOSE cur_catalog;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_catalog(1, 100, 'Premium Item');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(8, 500, 'High Value Product');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(1, 50, 'Updated Name');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(5, 1000, 'Luxury Edition');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(2, 250, 'Mid-Range Product');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_catalog that uses a cursor to process catalog entries at a specified level. For each entry: if its price exceeds a threshold, update its name and set a related attribute to '1' (inserting a default row if needed); if the price is below the threshold, delete related attributes; if equal, increase its euro price by 10%. Use row locking during processing.",
    "natural_language": "Create a stored procedure called sp_update_catalog. Use a cursor to go through catalog entries at a given level. For each entry, lock the row. If the price is above a threshold, update the entry's name and set a related attribute to '1', inserting a default row first if it doesn't exist. If the price is below the threshold, delete any related attributes. If the price equals the threshold, increase its euro price by 10 percent.",
    "id": 240
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_catalog` that accepts three input parameters: `p_parent_id` of type `NUMBER`, `p_capacity` of type `VARCHAR2`, and `p_attribute_id` of type `NUMBER`. The procedure begins by declaring several local variables: `v_max_id` of type `NUMBER`, `v_new_id` of type `NUMBER`, `v_level` of type `NUMBER`, `v_name` of type `VARCHAR2(255)`, and `v_stock` of type `VARCHAR2(255)`.\n\nThe procedure first executes a `SELECT` statement to retrieve the maximum value from the `CATALOG_ENTRY_ID` column in the `CATALOG_CONTENTS` table and stores this value into the `v_max_id` variable. Subsequently, it calculates a new ID by adding 1 to `v_max_id` and assigns this result to the `v_new_id` variable.\n\nNext, it performs another `SELECT` statement on the `CATALOG_CONTENTS` table. This query retrieves the value of the `CATALOG_LEVEL_NUMBER` column, increments it by 1, and stores the result in the `v_level` variable. It also concatenates the string '_child' to the value of the `CATALOG_ENTRY_NAME` column and stores this new string in the `v_name` variable. Additionally, it retrieves the value of the `PRODUCT_STOCK_NUMBER` column and stores it in the `v_stock` variable. This `SELECT` operation is filtered by a `WHERE` clause, ensuring that only the row where the `CATALOG_ENTRY_ID` column matches the input parameter `p_parent_id` is considered.\n\nFollowing these selections, the procedure executes an `INSERT` statement to add a new row into the `CATALOG_CONTENTS` table. The values inserted are: `v_new_id` for `CATALOG_ENTRY_ID`, `v_level` for `CATALOG_LEVEL_NUMBER`, `p_parent_id` for `PARENT_ENTRY_ID`, `v_name` for `CATALOG_ENTRY_NAME`, `v_stock` for `PRODUCT_STOCK_NUMBER`, and `p_capacity` for `CAPACITY`.\n\nImmediately after, another `INSERT` statement is executed, this time adding a new row into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. The values inserted are: `v_new_id` for `CATALOG_ENTRY_ID`, `v_level` for `CATALOG_LEVEL_NUMBER`, `p_attribute_id` for `ATTRIBUTE_ID`, and the literal string '1' for `ATTRIBUTE_VALUE`.\n\nSubsequently, an `UPDATE` statement is performed on the `CATALOG_CONTENTS` table. This statement sets the `NEXT_ENTRY_ID` column to the value of `v_new_id` for the row where the `CATALOG_ENTRY_ID` column matches the input parameter `p_parent_id`.\n\nFinally, the procedure executes a `DELETE` statement to remove rows from the `CATALOG_CONTENTS` table. This deletion is conditional, targeting rows where the value of the `CAPACITY` column is less than the input parameter `p_capacity` AND the value of the `CATALOG_LEVEL_NUMBER` column is equal to the `v_level` variable.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_catalog(p_parent_id NUMBER, p_capacity VARCHAR2, p_attribute_id NUMBER) IS\n  v_max_id NUMBER;\n  v_new_id NUMBER;\n  v_level NUMBER;\n  v_name VARCHAR2(255);\n  v_stock VARCHAR2(255);\nBEGIN\n  SELECT MAX(CATALOG_ENTRY_ID) INTO v_max_id FROM CATALOG_CONTENTS;\n  v_new_id := v_max_id + 1;\n  SELECT CATALOG_LEVEL_NUMBER + 1, CATALOG_ENTRY_NAME || '_child', PRODUCT_STOCK_NUMBER INTO v_level, v_name, v_stock FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_parent_id;\n  INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, CAPACITY) VALUES (v_new_id, v_level, p_parent_id, v_name, v_stock, p_capacity);\n  INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE) VALUES (v_new_id, v_level, p_attribute_id, '1');\n  UPDATE CATALOG_CONTENTS SET NEXT_ENTRY_ID = v_new_id WHERE CATALOG_ENTRY_ID = p_parent_id;\n  DELETE FROM CATALOG_CONTENTS WHERE CAPACITY < p_capacity AND CATALOG_LEVEL_NUMBER = v_level;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_catalog(p_parent_id => 1, p_capacity => '2', p_attribute_id => 4);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 2, p_capacity => '5', p_attribute_id => 3);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 3, p_capacity => '1', p_attribute_id => 2);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 1, p_capacity => '8', p_attribute_id => 4);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 2, p_capacity => '3', p_attribute_id => 3);\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_manage_catalog` that inserts a new child catalog entry based on a parent ID, copies and modifies data from the parent (level+1, name+'_child'), inserts a corresponding attribute record, updates the parent's next entry pointer, and deletes entries at the new level where capacity is below a provided threshold.",
    "natural_language": "Create a comprehensive stored procedure, to be named `sp_manage_catalog`, which performs a detailed sequence of operations. This procedure should first insert a new child catalog entry by referencing a specified parent ID. It must then meticulously copy and subsequently modify the parent's data, specifically incrementing the level by one and appending the suffix '_child' to the name. Following this, the procedure is required to insert a corresponding attribute record linked to the new child entry. Subsequently, it must update the parent catalog entry's pointer to correctly reference this new child as the next entry. Finally, the procedure should conclude by thoroughly deleting any existing catalog entries at the newly created child level where their recorded capacity falls beneath a provided, specific threshold value.",
    "id": 241
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_adjust_prices` that accepts two input parameters: `p_catalog_level`, which is of data type `NUMBER` and represents a specific catalog level number, and `p_price_factor`, which is also of data type `NUMBER` and represents a multiplier to be applied to prices.\n\nThe procedure first declares a cursor named `cur_catalog`. This cursor is designed to select `CATALOG_ENTRY_ID` and `PRICE_IN_DOLLARS` from the `CATALOG_CONTENTS` table. The selection is filtered by a condition where the `CATALOG_LEVEL_NUMBER` column in the `CATALOG_CONTENTS` table matches the value provided in the `p_catalog_level` input parameter. The `FOR UPDATE` clause indicates that the rows retrieved by this cursor are intended for subsequent updates within the same transaction.\n\nTwo local variables are declared: `v_entry_id` of data type `NUMBER` to temporarily store the `CATALOG_ENTRY_ID` fetched from the cursor, and `v_price` of data type `NUMBER` to temporarily store the `PRICE_IN_DOLLARS` fetched from the cursor.\n\nThe procedure then opens the `cur_catalog` cursor. It enters a loop that continuously fetches rows from `cur_catalog` into the `v_entry_id` and `v_price` variables. The loop terminates when no more rows are found by the cursor, as indicated by `cur_catalog%NOTFOUND`.\n\nInside the loop, for each fetched row, a conditional logic block is executed:\n1. If the value of `v_price` (which represents `PRICE_IN_DOLLARS` for the current row) is greater than 500, then an `UPDATE` operation is performed on the `CATALOG_CONTENTS` table. Specifically, the `PRICE_IN_DOLLARS` column for the current row (identified by `WHERE CURRENT OF cur_catalog`) is updated by multiplying its existing value by the `p_price_factor` input parameter.\n2. Else if the value of `v_price` is between 200 and 500 (inclusive), then an `UPDATE` operation is performed on the `CATALOG_CONTENTS` table. In this case, the `PRICE_IN_EUROS` column for the current row (identified by `WHERE CURRENT OF cur_catalog`) is updated by multiplying its existing value by the `p_price_factor` input parameter.\n3. Else (if `v_price` is neither greater than 500 nor between 200 and 500, implying it is less than or equal to 200), an `UPDATE` operation is performed on the `CATALOG_CONTENTS` table. Here, the `PRICE_IN_POUNDS` column for the current row (identified by `WHERE CURRENT OF cur_catalog`) is updated by multiplying its existing value by the `p_price_factor` input parameter.\n\nAfter the loop finishes processing all rows, the `cur_catalog` cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_adjust_prices(p_catalog_level NUMBER, p_price_factor NUMBER) IS\n  CURSOR cur_catalog IS SELECT CATALOG_ENTRY_ID, PRICE_IN_DOLLARS FROM CATALOG_CONTENTS WHERE CATALOG_LEVEL_NUMBER = p_catalog_level FOR UPDATE;\n  v_entry_id NUMBER;\n  v_price NUMBER;\nBEGIN\n  OPEN cur_catalog;\n  LOOP\n    FETCH cur_catalog INTO v_entry_id, v_price;\n    EXIT WHEN cur_catalog%NOTFOUND;\n    IF v_price > 500 THEN\n      UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = PRICE_IN_DOLLARS * p_price_factor WHERE CURRENT OF cur_catalog;\n    ELSIF v_price BETWEEN 200 AND 500 THEN\n      UPDATE CATALOG_CONTENTS SET PRICE_IN_EUROS = PRICE_IN_EUROS * p_price_factor WHERE CURRENT OF cur_catalog;\n    ELSE\n      UPDATE CATALOG_CONTENTS SET PRICE_IN_POUNDS = PRICE_IN_POUNDS * p_price_factor WHERE CURRENT OF cur_catalog;\n    END IF;\n  END LOOP;\n  CLOSE cur_catalog;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_adjust_prices(1, 1.1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_adjust_prices(8, 0.9);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_adjust_prices(1, 1.05);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_adjust_prices(2, 1.15);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_adjust_prices(5, 0.85);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_adjust_prices` that updates prices for all entries at a specified catalog level. Use a cursor with FOR UPDATE. If the dollar price is above 500, update the dollar price. If between 200 and 500 inclusive, update the euro price. Otherwise, update the pound price. Apply the provided multiplier factor in each case.",
    "natural_language": "How can I create a stored procedure called `sp_adjust_prices` that uses a cursor with FOR UPDATE to adjust prices for all entries at a given catalog level? It should update the dollar price if it's above 500, the euro price if it's between 200 and 500 inclusive, and the pound price otherwise, applying a provided multiplier factor in each case.",
    "id": 242
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_update_attributes` that accepts three input parameters: `p_catalog_level` of type `NUMBER`, `p_attribute_id` of type `NUMBER`, and `p_new_value` of type `VARCHAR2`. The purpose of this procedure is to iterate through catalog entries at a specific catalog level and either update an existing additional attribute or insert a new one for each entry.\n\nThe procedure begins by declaring a cursor named `cur_catalog`. This cursor is defined to select the `CATALOG_ENTRY_ID` column from the `CATALOG_CONTENTS` table. The selection is filtered by a condition where the `CATALOG_LEVEL_NUMBER` column in `CATALOG_CONTENTS` is equal to the value provided in the `p_catalog_level` input parameter. The `FOR UPDATE` clause is used with this cursor, indicating that the rows fetched by this cursor are intended to be modified later in the transaction.\n\nTwo local variables are declared: `v_entry_id` of type `NUMBER` to temporarily store the `CATALOG_ENTRY_ID` fetched from the cursor, and `v_attr_exists` of type `NUMBER` to store a count indicating whether a specific attribute exists for a catalog entry.\n\nThe procedure then opens the `cur_catalog` cursor. Following this, it enters a `LOOP` construct to process each row returned by the cursor. Inside the loop, it attempts to `FETCH` the next `CATALOG_ENTRY_ID` from `cur_catalog` into the `v_entry_id` variable. An `EXIT WHEN cur_catalog%NOTFOUND` statement immediately follows, which terminates the loop if no more rows are found in the cursor.\n\nFor each `v_entry_id` fetched, the procedure executes a `SELECT COUNT(*)` statement. This statement counts the number of rows in the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table where the `CATALOG_ENTRY_ID` column matches the current `v_entry_id` and the `ATTRIBUTE_ID` column matches the value provided in the `p_attribute_id` input parameter. The result of this count is stored in the `v_attr_exists` variable.\n\nImmediately after the count, an `IF` conditional statement checks the value of `v_attr_exists`.\nIf `v_attr_exists` is greater than 0, meaning an additional attribute with the specified `ATTRIBUTE_ID` already exists for the current `CATALOG_ENTRY_ID`, the procedure executes an `UPDATE` statement. This `UPDATE` statement modifies the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table, setting the `ATTRIBUTE_VALUE` column to the value provided in the `p_new_value` input parameter. The update is applied to rows where the `CATALOG_ENTRY_ID` matches `v_entry_id` and the `ATTRIBUTE_ID` matches `p_attribute_id`.\nIf `v_attr_exists` is not greater than 0 (i.e., it is 0), meaning the additional attribute does not exist for the current `CATALOG_ENTRY_ID`, the procedure executes an `INSERT` statement. This `INSERT` statement adds a new row into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. The values inserted are `v_entry_id` for `CATALOG_ENTRY_ID`, `p_catalog_level` for `CATALOG_LEVEL_NUMBER`, `p_attribute_id` for `ATTRIBUTE_ID`, and `p_new_value` for `ATTRIBUTE_VALUE`.\n\nThe loop continues until all rows from `cur_catalog` have been processed. After the loop finishes, the procedure `CLOSE`s the `cur_catalog` cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_attributes(p_catalog_level NUMBER, p_attribute_id NUMBER, p_new_value VARCHAR2) IS\n  CURSOR cur_catalog IS SELECT CATALOG_ENTRY_ID FROM CATALOG_CONTENTS WHERE CATALOG_LEVEL_NUMBER = p_catalog_level FOR UPDATE;\n  v_entry_id NUMBER;\n  v_attr_exists NUMBER;\nBEGIN\n  OPEN cur_catalog;\n  LOOP\n    FETCH cur_catalog INTO v_entry_id;\n    EXIT WHEN cur_catalog%NOTFOUND;\n    SELECT COUNT(*) INTO v_attr_exists FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = v_entry_id AND ATTRIBUTE_ID = p_attribute_id;\n    IF v_attr_exists > 0 THEN\n      UPDATE CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES SET ATTRIBUTE_VALUE = p_new_value WHERE CATALOG_ENTRY_ID = v_entry_id AND ATTRIBUTE_ID = p_attribute_id;\n    ELSE\n      INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE) VALUES (v_entry_id, p_catalog_level, p_attribute_id, p_new_value);\n    END IF;\n  END LOOP;\n  CLOSE cur_catalog;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_attributes(1, 2, 'New Value 1');\n  commit;\nEND;",
      "BEGIN\n  sp_update_attributes(8, 3, 'New Value 2');\n  commit;\nEND;",
      "BEGIN\n  sp_update_attributes(1, 4, 'New Value 3');\n  commit;\nEND;",
      "BEGIN\n  sp_update_attributes(8, 2, 'New Value 4');\n  commit;\nEND;",
      "BEGIN\n  sp_update_attributes(1, 3, 'New Value 5');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_update_attributes` that, for every catalog entry at a specified level, checks if a given attribute ID exists. If it exists, update its value. If it does not exist, insert a new attribute record with the given ID, level, and new value. Use a cursor with FOR UPDATE.",
    "natural_language": "Write a stored procedure called `sp_update_attributes`. Use a cursor with FOR UPDATE to go through every catalog entry at a given level. For each entry, check if a specific attribute ID exists. If it exists, update its value. If it does not exist, insert a new record with the provided ID, level, and new value.",
    "id": 243
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_stock` that accepts two input parameters: `p_catalog_level` of type `NUMBER` representing a specific catalog level number, and `p_stock_threshold` of type `VARCHAR2` representing a stock threshold value that might be a numeric string. The procedure first declares a cursor named `cur_catalog` which selects the `CATALOG_ENTRY_ID` and `PRODUCT_STOCK_NUMBER` columns from the `CATALOG_CONTENTS` table. This selection is filtered by rows where the `CATALOG_LEVEL_NUMBER` column matches the value provided in the `p_catalog_level` input parameter. The `FOR UPDATE` clause is used with this cursor, indicating that the rows fetched by this cursor are intended for subsequent modification (deletion or update) within the same transaction. The procedure also declares several local variables: `v_entry_id` of type `NUMBER` to store the `CATALOG_ENTRY_ID`, `v_stock` of type `VARCHAR2(255)` to store the `PRODUCT_STOCK_NUMBER`, `v_stock_numeric` of type `NUMBER` to hold the numeric part extracted from `v_stock`, and `v_threshold_numeric` of type `NUMBER` to store the numeric conversion of `p_stock_threshold`.\n\nUpon execution, the procedure first attempts to convert the `p_stock_threshold` input parameter to a numeric value and store it in `v_threshold_numeric` using the `TO_NUMBER` function. If this conversion results in a `VALUE_ERROR` (e.g., if `p_stock_threshold` is not a valid number), `v_threshold_numeric` is set to `0`.\n\nNext, the procedure opens the `cur_catalog` cursor. It then enters a loop to process each row fetched by the cursor. In each iteration, it fetches the `CATALOG_ENTRY_ID` into `v_entry_id` and `PRODUCT_STOCK_NUMBER` into `v_stock` from the `cur_catalog` cursor. The loop continues until no more rows are found, as indicated by `cur_catalog%NOTFOUND`.\n\nInside the loop, for each fetched `v_stock` value, the procedure attempts to extract the leading numeric part from the `v_stock` string. This is achieved using the `REGEXP_SUBSTR` function with the regular expression `'^\\d+'`, which matches one or more digits at the beginning of the string. The extracted numeric string is then converted to a `NUMBER` using `TO_NUMBER` and stored in `v_stock_numeric`. If this conversion results in a `VALUE_ERROR` (e.g., if `v_stock` does not start with a number), `v_stock_numeric` is set to `0`.\n\nFollowing the extraction and conversion, a conditional check is performed:\n1. If `v_stock_numeric` is greater than `v_threshold_numeric`, the procedure executes a `DELETE` statement on the `CATALOG_CONTENTS` table. The `WHERE CURRENT OF cur_catalog` clause ensures that only the currently fetched row by `cur_catalog` is deleted.\n2. Otherwise (if `v_stock_numeric` is not greater than `v_threshold_numeric`), the procedure executes an `UPDATE` statement on the `CATALOG_CONTENTS` table. The `PRODUCT_STOCK_NUMBER` column is updated to a new value. This new value is constructed by first adding `10` to `v_stock_numeric`, converting the result back to a `VARCHAR2` using `TO_CHAR`, and then concatenating it with the non-numeric suffix of the original `v_stock` string. The suffix is obtained by finding the position of the first space in `v_stock` using `INSTR(v_stock, ' ')` and then extracting the substring from that position onwards using `SUBSTR(v_stock, INSTR(v_stock, ' '))`. The `WHERE CURRENT OF cur_catalog` clause ensures that only the currently fetched row by `cur_catalog` is updated.\n\nAfter the loop finishes processing all rows, the procedure closes the `cur_catalog` cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_stock(p_catalog_level NUMBER, p_stock_threshold VARCHAR2) IS\n  CURSOR cur_catalog IS \n    SELECT CATALOG_ENTRY_ID, PRODUCT_STOCK_NUMBER \n    FROM CATALOG_CONTENTS \n    WHERE CATALOG_LEVEL_NUMBER = p_catalog_level \n    FOR UPDATE;\n  v_entry_id NUMBER;\n  v_stock VARCHAR2(255);\n  v_stock_numeric NUMBER;\n  v_threshold_numeric NUMBER;\nBEGIN\n  -- Convert threshold once\n  BEGIN\n    v_threshold_numeric := TO_NUMBER(p_stock_threshold);\n  EXCEPTION\n    WHEN VALUE_ERROR THEN\n      v_threshold_numeric := 0;\n  END;\n\n  OPEN cur_catalog;\n  LOOP\n    FETCH cur_catalog INTO v_entry_id, v_stock;\n    EXIT WHEN cur_catalog%NOTFOUND;\n    \n    -- Extract numeric part from stock string (e.g., '89 cp' -> 89)\n    BEGIN\n      v_stock_numeric := TO_NUMBER(REGEXP_SUBSTR(v_stock, '^\\d+'));\n    EXCEPTION\n      WHEN VALUE_ERROR THEN\n        v_stock_numeric := 0;\n    END;\n    \n    IF v_stock_numeric > v_threshold_numeric THEN\n      DELETE FROM CATALOG_CONTENTS WHERE CURRENT OF cur_catalog;\n    ELSE\n      UPDATE CATALOG_CONTENTS \n      SET PRODUCT_STOCK_NUMBER = TO_CHAR(v_stock_numeric + 10) || SUBSTR(v_stock, INSTR(v_stock, ' '))\n      WHERE CURRENT OF cur_catalog;\n    END IF;\n  END LOOP;\n  CLOSE cur_catalog;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_stock(p_catalog_level => 1, p_stock_threshold => '50');\nEND;",
      "BEGIN\n  sp_manage_stock(p_catalog_level => 8, p_stock_threshold => '100');\nEND;",
      "BEGIN\n  sp_manage_stock(p_catalog_level => 1, p_stock_threshold => '20');\nEND;",
      "BEGIN\n  sp_manage_stock(p_catalog_level => 8, p_stock_threshold => '75');\nEND;",
      "BEGIN\n  sp_manage_stock(p_catalog_level => 1, p_stock_threshold => 'invalid_threshold');\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_manage_stock` to process entries at a given catalog level. Convert a stock threshold parameter to a number (default 0 on error). For each entry, extract the leading numeric part of its stock number (default 0 on error). If the extracted number exceeds the threshold, delete the entry. Otherwise, update the stock number by adding 10 to its numeric prefix and preserving any suffix.",
    "natural_language": "Compose a stored procedure designated as `sp_manage_stock` to process inventory entries for a specified catalog level. The procedure shall accept a stock threshold parameter, converting it to a numeric value with a default of zero should an error occur during conversion. For each entry, the leading numeric segment of its stock number is to be isolated, defaulting to zero in the event of an error. Should this extracted numeric value surpass the provided threshold, the corresponding entry is to be deleted. Conversely, if the value does not exceed the threshold, the entry's stock number must be updated by incrementing its numeric prefix by ten while retaining any subsequent alphanumeric suffix.",
    "id": 244
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named MODIFY_ARCHITECT_RECORDS that accepts two input parameters: a string parameter P_NATIONALITY of type VARCHAR2, which specifies a nationality to filter architect records, and a string parameter P_NAME_SUFFIX of type VARCHAR2, which provides a text suffix to be appended to names. The procedure begins by declaring three local NUMBER variables: V_ARCHITECT_COUNT, V_AVG_NAME_LENGTH, and V_NATIONALITY_COUNT. It first executes a SELECT statement to count the total number of rows in the ARCHITECT table where the NATIONALITY column exactly matches the input P_NATIONALITY, storing the result in V_ARCHITECT_COUNT. It then executes a second SELECT statement to calculate the average character length of all values in the NAME column of the ARCHITECT table, storing the result in V_AVG_NAME_LENGTH. A third SELECT statement counts the number of distinct values present in the NATIONALITY column across the entire ARCHITECT table, storing the result in V_NATIONALITY_COUNT. The core logic uses a conditional IF-ELSIF-ELSE block. If the value of V_ARCHITECT_COUNT is greater than 5, the procedure performs an UPDATE operation on the ARCHITECT table, setting the NAME column to its current value concatenated with a single space and then the input P_NAME_SUFFIX, but only for rows where the NATIONALITY column equals P_NATIONALITY. If the first condition is false and V_AVG_NAME_LENGTH is greater than 12, the procedure executes a DELETE operation on the ARCHITECT table, removing rows where the character length of the NAME column is greater than the calculated V_AVG_NAME_LENGTH and the NATIONALITY column equals P_NATIONALITY. If neither of the first two conditions is met, the procedure enters a nested IF-ELSE block. Within this block, if V_NATIONALITY_COUNT is greater than 3, an INSERT operation is performed on the ARCHITECT table, adding a new row with specific values: the ID column is set to the string 'MOD_' concatenated with the current system date and time formatted as 'YYYYMMDDHH24MISS' using the TO_CHAR function with SYSDATE, the NAME column is set to the input P_NAME_SUFFIX concatenated with the string ' Diverse', the NATIONALITY column is set to 'Multinational', and the GENDER column is set to 'female'. If V_NATIONALITY_COUNT is 3 or less, a DELETE operation is executed on the ARCHITECT table, removing rows where the NATIONALITY value is not found in the list of distinct nationalities limited to the first two distinct nationalities retrieved by the subquery `SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2`.",
    "plsql": "CREATE OR REPLACE PROCEDURE modify_architect_records(\n    p_nationality VARCHAR2,\n    p_name_suffix VARCHAR2\n) IS\n    v_architect_count NUMBER;\n    v_avg_name_length NUMBER;\n    v_nationality_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_architect_count FROM ARCHITECT WHERE NATIONALITY = p_nationality;\n    SELECT AVG(LENGTH(NAME)) INTO v_avg_name_length FROM ARCHITECT;\n    SELECT COUNT(DISTINCT NATIONALITY) INTO v_nationality_count FROM ARCHITECT;\n    \n    IF v_architect_count > 5 THEN\n        UPDATE ARCHITECT SET NAME = NAME || ' ' || p_name_suffix WHERE NATIONALITY = p_nationality;\n    ELSIF v_avg_name_length > 12 THEN\n        DELETE FROM ARCHITECT WHERE LENGTH(NAME) > v_avg_name_length AND NATIONALITY = p_nationality;\n    ELSE\n        IF v_nationality_count > 3 THEN\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('MOD_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_suffix || ' Diverse', 'Multinational', 'female');\n        ELSE\n            DELETE FROM ARCHITECT WHERE NATIONALITY NOT IN (SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2);\n        END IF;\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT"
    ],
    "call_sqls": [
      "BEGIN\n  modify_architect_records('American', 'Jr.');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('Canadian', 'Sr.');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('Iraqi, British', 'III');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('British', 'IV');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('French', 'V');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `MODIFY_ARCHITECT_RECORDS` that takes a nationality and a name suffix. First, count architects with that nationality, calculate the average name length, and count distinct nationalities. If the specific nationality count >5, append the suffix to their names. Else if average name length >12, delete architects of that nationality with names longer than the average. Else, if distinct nationality count >3, insert a new 'Multinational'/'female' architect with a generated ID. Otherwise, delete architects whose nationality is not among the first two distinct nationalities found.",
    "natural_language": "Create procedure MODIFY_ARCHITECT_RECORDS with nationality and suffix parameters. Count architects by nationality, get average name length, and count distinct nationalities. If nationality count >5, append suffix to their names. Else if average length >12, delete architects of that nationality with long names. Else if distinct nationalities >3, insert a new 'Multinational'/'female' architect. Otherwise, delete architects not in the top two nationalities.",
    "id": 245
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named balance_architect_gender that accepts two parameters: p_gender of type VARCHAR2, which specifies the gender to be used in certain operations, and p_name_pattern of type VARCHAR2, which is used as a pattern for naming and filtering operations. The procedure begins by declaring three local variables: v_male_count, v_female_count, and v_total_count, all of type NUMBER, to store the counts of male architects, female architects, and the total number of architects, respectively. Another variable, v_gender_ratio of type NUMBER, is declared to store the ratio between male and female counts. The procedure first executes a SELECT statement to count the number of male architects in the ARCHITECT table where the GENDER column equals 'male', storing the result in v_male_count. It then performs a similar SELECT operation to count female architects where the GENDER column equals 'female', storing the result in v_female_count. A third SELECT statement counts all rows in the ARCHITECT table, storing the result in v_total_count. The procedure then enters a conditional logic block. If the count of male architects (v_male_count) is greater than the count of female architects (v_female_count), it calculates the gender ratio by dividing v_male_count by the greater of v_female_count or 1, using the GREATEST function to avoid division by zero. If this ratio exceeds 2, it inserts a new row into the ARCHITECT table with a generated ID based on the current date and time, a NAME formed by appending ' Balance Female' to p_name_pattern, a NATIONALITY of 'Balanced', and a GENDER of 'female'. If the ratio is not greater than 2, it updates the NAME column of up to two male architects by appending ' (Male Dominant)' to their existing names, where the GENDER is 'male'. If the count of female architects is greater than the count of male architects, the procedure calculates the gender ratio by dividing v_female_count by the greater of v_male_count or 1. If this ratio exceeds 2, it inserts a new row into the ARCHITECT table with a generated ID, a NAME formed by appending ' Balance Male' to p_name_pattern, a NATIONALITY of 'Balanced', and a GENDER of 'male'. If the ratio is not greater than 2, it deletes one row from the ARCHITECT table where the GENDER is 'female', the NAME does not match the pattern specified by p_name_pattern, and the row number is 1. If the counts of male and female architects are equal, the procedure checks if the total count of architects is divisible by 3 using the MOD function. If it is, it updates the NATIONALITY column to 'Equilibrium' for all architects where the GENDER matches p_gender. If the total count is not divisible by 3, it inserts a new row into the ARCHITECT table with a generated ID, a NAME formed by appending ' Equilibrium' to p_name_pattern, a NATIONALITY of 'Equal', and a GENDER matching p_gender.",
    "plsql": "CREATE OR REPLACE PROCEDURE balance_architect_gender(\n    p_gender VARCHAR2,\n    p_name_pattern VARCHAR2\n) IS\n    v_male_count NUMBER;\n    v_female_count NUMBER;\n    v_total_count NUMBER;\n    v_gender_ratio NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_male_count FROM ARCHITECT WHERE GENDER = 'male';\n    SELECT COUNT(*) INTO v_female_count FROM ARCHITECT WHERE GENDER = 'female';\n    SELECT COUNT(*) INTO v_total_count FROM ARCHITECT;\n    \n    IF v_male_count > v_female_count THEN\n        v_gender_ratio := v_male_count / GREATEST(v_female_count, 1);\n        IF v_gender_ratio > 2 THEN\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('BAL_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_pattern || ' Balance Female', 'Balanced', 'female');\n        ELSE\n            UPDATE ARCHITECT SET NAME = NAME || ' (Male Dominant)' WHERE GENDER = 'male' AND ROWNUM <= 2;\n        END IF;\n    ELSIF v_female_count > v_male_count THEN\n        v_gender_ratio := v_female_count / GREATEST(v_male_count, 1);\n        IF v_gender_ratio > 2 THEN\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('BAL_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_pattern || ' Balance Male', 'Balanced', 'male');\n        ELSE\n            DELETE FROM ARCHITECT WHERE GENDER = 'female' AND NAME NOT LIKE '%' || p_name_pattern || '%' AND ROWNUM = 1;\n        END IF;\n    ELSE\n        IF MOD(v_total_count, 3) = 0 THEN\n            UPDATE ARCHITECT SET NATIONALITY = 'Equilibrium' WHERE GENDER = p_gender;\n        ELSE\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('EQ_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_pattern || ' Equilibrium', 'Equal', p_gender);\n        END IF;\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT"
    ],
    "call_sqls": [
      "BEGIN\n  balance_architect_gender('female', 'New Architect');\nEND;",
      "BEGIN\n  balance_architect_gender('male', 'Rising Star');\nEND;",
      "BEGIN\n  balance_architect_gender('female', 'Balanced Design');\nEND;",
      "BEGIN\n  balance_architect_gender('male', 'Innovative Mind');\nEND;",
      "BEGIN\n  balance_architect_gender('female', 'Creative Force');\nEND;"
    ],
    "summary": "Create a stored procedure named balance_architect_gender that accepts a gender parameter (p_gender) and a name pattern parameter (p_name_pattern). It counts male, female, and total architects. Based on the counts, it performs conditional logic: if male count > female count and the ratio exceeds 2, insert a new female 'Balanced' architect using the name pattern; otherwise, update up to two male names. If female count > male count and the ratio exceeds 2, insert a new male 'Balanced' architect; otherwise, delete one female not matching the name pattern. If counts are equal and total count is divisible by 3, update nationality to 'Equilibrium' for architects matching p_gender; otherwise, insert a new 'Equal' architect with the gender and name pattern.",
    "natural_language": "Develop a stored procedure, to be named balance_architect_gender, which thoughtfully accepts two distinct input parameters: one for gender, designated as p_gender, and another for a name pattern, designated as p_name_pattern. This procedure will meticulously calculate and analyze the current counts of male architects, female architects, and the overall total. Following this detailed analysis, it will execute a series of conditional operations with careful logic: if the count of male architects is found to be greater than the count of female architects and, moreover, the ratio significantly exceeds two, then the procedure will gracefully insert a brand new female architect, specifically labeled as 'Balanced', utilizing the provided name pattern. Conversely, if that high ratio condition is not met, it will instead proceed to update the names of up to two existing male architects. In the alternative scenario, where the count of female architects surpasses the count of male architects and the ratio again substantially exceeds two, it will sympathetically insert a new male 'Balanced' architect; otherwise, it will deliberately delete a single female architect whose name does not conform to the specified pattern. Finally, in the elegantly balanced case where the male and female counts are precisely equal, and if the total count is neatly divisible by three, the procedure will update the nationality to 'Equilibrium' for all architects matching the input p_gender parameter; if that divisibility condition is not satisfied, it will compassionately insert a new architect, designated as 'Equal', assigning the provided gender and name pattern.",
    "id": 246
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `transform_architect_data` that accepts three input parameters: `p_transformation_mode` of type `NUMBER`, `p_nationality_filter` of type `VARCHAR2`, and `p_name_modifier` of type `VARCHAR2`.\n\nThe procedure begins by declaring four local variables: `v_architect_exists` of type `NUMBER`, `v_name_length_avg` of type `NUMBER`, `v_nationality_count` of type `NUMBER`, and `v_gender_distribution` of type `NUMBER`.\n\nNext, it performs four initial `SELECT` operations:\n1. It queries the `ARCHITECT` table to count the number of rows where the `NATIONALITY` column matches the value provided in `p_nationality_filter`. The result of this count is stored in the `v_architect_exists` variable.\n2. It calculates the average length of all `NAME` values in the `ARCHITECT` table using the `LENGTH()` function. This average length is stored in the `v_name_length_avg` variable.\n3. It counts the number of distinct `NATIONALITY` values present in the `ARCHITECT` table. This count is stored in the `v_nationality_count` variable.\n4. It counts the number of distinct `GENDER` values present in the `ARCHITECT` table. This count is stored in the `v_gender_distribution` variable.\n\nFollowing these initial data retrievals, the procedure enters a conditional block based on the value of `p_transformation_mode`:\n\n**If `p_transformation_mode` is equal to 1:**\n    * It checks if `v_architect_exists` is greater than 0.\n        * If true (meaning architects with the specified nationality exist), it updates the `ARCHITECT` table. For all rows where the `NATIONALITY` column matches `p_nationality_filter`, the `NAME` column is modified by prepending the value of `p_name_modifier` followed by a space to the existing `NAME`.\n        * If false (meaning no architects with the specified nationality exist), it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_1_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Transformed'. The `NATIONALITY` column is set to `p_nationality_filter`. The `GENDER` column is set to 'male'.\n\n**Else if `p_transformation_mode` is equal to 2:**\n    * It checks if `v_name_length_avg` is greater than 15.\n        * If true, it deletes rows from the `ARCHITECT` table where the length of the `NAME` column (calculated using `LENGTH(NAME)`) is greater than `v_name_length_avg` AND the `NATIONALITY` column matches `p_nationality_filter`.\n        * If false, it updates the `ARCHITECT` table. For all rows where the length of the `NAME` column (calculated using `LENGTH(NAME)`) is less than `v_name_length_avg`, the `NATIONALITY` column is modified by appending '_Extended' to its current value, which is `p_nationality_filter`.\n\n**Else if `p_transformation_mode` is equal to 3:**\n    * It checks if `v_nationality_count` is greater than 3.\n        * If true, it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_3_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Diverse'. The `NATIONALITY` column is set to 'Multinational'. The `GENDER` column is set to 'female'.\n        * If false, it deletes rows from the `ARCHITECT` table where the `NATIONALITY` column is NOT present in the set of the first two distinct nationalities found in the `ARCHITECT` table (determined by `SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2`).\n\n**Else if `p_transformation_mode` is equal to 4:**\n    * It checks if `v_gender_distribution` is equal to 2.\n        * If true, it updates the `ARCHITECT` table. For all rows where the `NATIONALITY` column matches `p_nationality_filter`, the `NAME` column is modified by converting its value to initial capital letters using the `INITCAP()` function.\n        * If false, it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_4_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Gender Balanced'. The `NATIONALITY` column is set to `p_nationality_filter`. The `GENDER` column is set to 'female'.\n\n**Else (if `p_transformation_mode` does not match any of the above values):**\n    * It deletes rows from the `ARCHITECT` table where the `ID` column is NOT present in the set of the first three `ID` values found in the `ARCHITECT` table (determined by `SELECT ID FROM ARCHITECT WHERE ROWNUM <= 3`).",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_architect_data(\n    p_transformation_mode NUMBER,\n    p_nationality_filter VARCHAR2,\n    p_name_modifier VARCHAR2\n) IS\n    v_architect_exists NUMBER;\n    v_name_length_avg NUMBER;\n    v_nationality_count NUMBER;\n    v_gender_distribution NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_architect_exists FROM ARCHITECT WHERE NATIONALITY = p_nationality_filter;\n    SELECT AVG(LENGTH(NAME)) INTO v_name_length_avg FROM ARCHITECT;\n    SELECT COUNT(DISTINCT NATIONALITY) INTO v_nationality_count FROM ARCHITECT;\n    SELECT COUNT(DISTINCT GENDER) INTO v_gender_distribution FROM ARCHITECT;\n    \n    IF p_transformation_mode = 1 THEN\n        IF v_architect_exists > 0 THEN\n            UPDATE ARCHITECT SET NAME = p_name_modifier || ' ' || NAME WHERE NATIONALITY = p_nationality_filter;\n        ELSE\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('TRANS_1_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_modifier || ' Transformed', p_nationality_filter, 'male');\n        END IF;\n    ELSIF p_transformation_mode = 2 THEN\n        IF v_name_length_avg > 15 THEN\n            DELETE FROM ARCHITECT WHERE LENGTH(NAME) > v_name_length_avg AND NATIONALITY = p_nationality_filter;\n        ELSE\n            UPDATE ARCHITECT SET NATIONALITY = p_nationality_filter || '_Extended' WHERE LENGTH(NAME) < v_name_length_avg;\n        END IF;\n    ELSIF p_transformation_mode = 3 THEN\n        IF v_nationality_count > 3 THEN\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('TRANS_3_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_modifier || ' Diverse', 'Multinational', 'female');\n        ELSE\n            DELETE FROM ARCHITECT WHERE NATIONALITY NOT IN (SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2);\n        END IF;\n    ELSIF p_transformation_mode = 4 THEN\n        IF v_gender_distribution = 2 THEN\n            UPDATE ARCHITECT SET NAME = INITCAP(NAME) WHERE NATIONALITY = p_nationality_filter;\n        ELSE\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('TRANS_4_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_modifier || ' Gender Balanced', p_nationality_filter, 'female');\n        END IF;\n    ELSE\n        DELETE FROM ARCHITECT WHERE ID NOT IN (SELECT ID FROM ARCHITECT WHERE ROWNUM <= 3);\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT"
    ],
    "call_sqls": [
      "BEGIN\n  transform_architect_data(1, 'American', 'Arch.');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(2, 'Canadian', 'TestName');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(3, 'Iraqi, British', 'Diverse');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(4, 'French', 'Balanced');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(5, 'German', 'Cleanup');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named transform_architect_data with parameters for transformation mode (p_transformation_mode), nationality filter (p_nationality_filter), and name modifier (p_name_modifier). It calculates initial statistics: count of architects by nationality, average name length, count of distinct nationalities, and count of distinct genders. Based on the mode: Mode 1: If architects with the filtered nationality exist, prepend the name modifier to their names; otherwise, insert a new 'Transformed' male architect. Mode 2: If average name length > 15, delete architects with long names matching the nationality; otherwise, append '_Extended' to the nationality for architects with short names. Mode 3: If distinct nationalities > 3, insert a new 'Diverse' female 'Multinational' architect; otherwise, delete architects whose nationality is not among the top two. Mode 4: If distinct genders = 2, apply INITCAP to names of architects matching the nationality; otherwise, insert a new 'Gender Balanced' female architect. For any other mode, delete all architects except the first three.",
    "natural_language": "Create procedure transform_architect_data with params p_transformation_mode, p_nationality_filter, p_name_modifier. Compute stats: architect count by nationality, average name length, distinct nationality count, distinct gender count. Mode 1: If filtered nationality exists, prepend modifier to names; else insert new 'Transformed' male architect. Mode 2: If avg name length > 15, delete long-name architects of that nationality; else append '_Extended' to nationality for short-name architects. Mode 3: If distinct nationalities > 3, insert new 'Diverse' female 'Multinational' architect; else delete architects not in top two nationalities. Mode 4: If distinct genders = 2, apply INITCAP to names of matching nationality; else insert new 'Gender Balanced' female architect. Any other mode: delete all except first three architects.",
    "id": 247
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named adjust_manufacturer_revenue that does not take any parameters and is designed to update the revenue of manufacturers based on the total sales of their products. The procedure begins by declaring a cursor named cur_products, which retrieves data from the products table. Specifically, it selects the manufacturer column and calculates the total sales for each manufacturer by summing the price column, grouping the results by the manufacturer column. The procedure then enters a loop that iterates over each record fetched by the cursor. For each record, it performs an update operation on the manufacturers table, setting the revenue column to the value of total_sales from the current record of the cursor. The update operation is conditioned on matching the code column in the manufacturers table with the manufacturer value from the current cursor record. The loop continues until all records from the cursor have been processed, ensuring that each manufacturer's revenue is adjusted according to the total sales of their products.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_manufacturer_revenue\nIS\n   CURSOR cur_products IS\n      SELECT manufacturer, SUM(price) total_sales\n      FROM products\n      GROUP BY manufacturer;\nBEGIN\n   FOR rec IN cur_products LOOP\n      -- Instead of deleting, update the manufacturer's revenue based on total sales\n      UPDATE manufacturers\n      SET revenue = rec.total_sales\n      WHERE code = rec.manufacturer;\n   END LOOP;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_manufacturer_revenue;\n  commit;\nEND;"
    ],
    "summary": "Create a parameterless stored procedure named adjust_manufacturer_revenue. It uses a cursor to calculate total sales per manufacturer from the products table. For each manufacturer, it updates the revenue column in the manufacturers table to match its calculated total sales.",
    "natural_language": "Create a parameterless stored procedure, which should be named adjust_manufacturer_revenue. This procedure must utilize a cursor to meticulously calculate the comprehensive total sales for each individual manufacturer by querying the products table. Subsequently, for every single manufacturer identified, it will carefully update the corresponding revenue column within the manufacturers table, ensuring it precisely reflects the newly calculated total sales amount.",
    "id": 248
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_manufacturer_data that does not take any parameters and is designed to manage data in the manufacturers and products tables. The procedure begins by declaring two local variables, v_total_revenue and v_avg_revenue, both of type NUMBER, to store the total and average revenue of all manufacturers, respectively. It also declares a cursor named cur_manufacturers, which selects the code and revenue columns from the manufacturers table. The procedure first calculates the total revenue by executing a SELECT statement that sums the revenue column from the manufacturers table and stores the result in v_total_revenue. It then calculates the average revenue by executing another SELECT statement that averages the revenue column from the manufacturers table and stores the result in v_avg_revenue. The procedure then enters a loop that iterates over each record in the cur_manufacturers cursor. For each manufacturer record, it checks if the revenue is greater than, less than, or equal to the average revenue stored in v_avg_revenue. If the revenue is greater than the average, it deletes all rows from the products table where the manufacturer column matches the current manufacturer's code, and then deletes the current manufacturer from the manufacturers table where the code matches and the revenue is greater than the average revenue. If the revenue is less than the average, it performs the same deletions but with the condition that the revenue is less than the average. If the revenue is equal to the average, it deletes the rows from both tables where the revenue equals the average. The procedure does not return any values or perform any other operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_manufacturer_data\nIS\n   v_total_revenue NUMBER;\n   v_avg_revenue NUMBER;\n   CURSOR cur_manufacturers IS\n      SELECT code, revenue FROM manufacturers;\nBEGIN\n   SELECT SUM(revenue) INTO v_total_revenue FROM manufacturers;\n   SELECT AVG(revenue) INTO v_avg_revenue FROM manufacturers;\n   \n   FOR rec IN cur_manufacturers LOOP\n      IF rec.revenue > v_avg_revenue THEN\n         DELETE FROM products WHERE manufacturer = rec.code;\n         DELETE FROM manufacturers WHERE code = rec.code AND revenue > v_avg_revenue;\n      ELSIF rec.revenue < v_avg_revenue THEN\n         DELETE FROM products WHERE manufacturer = rec.code;\n         DELETE FROM manufacturers WHERE code = rec.code AND revenue < v_avg_revenue;\n      ELSE\n         DELETE FROM products WHERE manufacturer = rec.code;\n         DELETE FROM manufacturers WHERE code = rec.code AND revenue = v_avg_revenue;\n      END IF;\n   END LOOP;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  manage_manufacturer_data;\n  commit;\nEND;"
    ],
    "summary": "Create a parameterless stored procedure named manage_manufacturer_data. It calculates the total and average revenue from the manufacturers table. It then loops through each manufacturer. If a manufacturer's revenue is greater than, less than, or equal to the average, it deletes all related products and then deletes the manufacturer record itself from the manufacturers table.",
    "natural_language": "How can I create a stored procedure called manage_manufacturer_data that calculates the total and average revenue from the manufacturers table, loops through each manufacturer, and then, based on whether a manufacturer's revenue is greater than, less than, or equal to the average, deletes all related products before removing the manufacturer record itself?",
    "id": 249
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp1 that accepts four input parameters: a numeric parameter para_SONGID, a numeric parameter para_BANDMATE, a string parameter para_TYPE, and a string parameter para_TITLE. The procedure first declares a local numeric variable v_count. It begins execution by querying the SONGS table to count the number of rows where the SONGID column equals the input parameter para_SONGID, storing the result in v_count. If the count is zero, indicating no song with that ID exists, the procedure inserts a new row into the SONGS table, populating the SONGID column with para_SONGID and the TITLE column with para_TITLE. If the count is not zero, meaning a song with that ID already exists, the procedure deletes any existing row from the VOCALS table where the SONGID column equals para_SONGID and the BANDMATE column equals para_BANDMATE. Following this conditional logic, the procedure unconditionally inserts a new row into the VOCALS table, setting the SONGID column to para_SONGID, the BANDMATE column to para_BANDMATE, and the TYPE column to para_TYPE.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp1(para_SONGID NUMBER, para_BANDMATE NUMBER, para_TYPE VARCHAR2, para_TITLE VARCHAR2) IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM SONGS WHERE SONGID = para_SONGID;\n  IF v_count = 0 THEN\n    INSERT INTO SONGS (SONGID, TITLE) VALUES (para_SONGID, para_TITLE);\n  ELSE\n    DELETE FROM VOCALS WHERE SONGID = para_SONGID AND BANDMATE = para_BANDMATE;\n  END IF;\n  INSERT INTO VOCALS (SONGID, BANDMATE, TYPE) VALUES (para_SONGID, para_BANDMATE, para_TYPE);\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "BEGIN\n  sp1(1, 101, 'Lead', 'Song A');\n  commit;\nEND;",
      "BEGIN\n  sp1(2, 102, 'Backup', 'Song B');\n  commit;\nEND;",
      "BEGIN\n  sp1(3, 103, 'Harmony', 'Song C');\n  commit;\nEND;",
      "BEGIN\n  sp1(4, 104, 'Lead', 'Song D');\n  commit;\nEND;",
      "BEGIN\n  sp1(5, 105, 'Backup', 'Song E');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp1 with parameters for song ID (para_SONGID), bandmate (para_BANDMATE), type (para_TYPE), and title (para_TITLE). It checks if a song with the given ID exists. If not, it inserts a new song. If it exists, it first deletes any matching vocal entry for that song and bandmate. Finally, it always inserts a new row into the VOCALS table with the provided parameters.",
    "natural_language": "Make a stored procedure called sp1 that takes in a song ID, a bandmate, a type, and a title. It should see if a song with that ID is around. If it's not there, just add the new song. If it is there, first get rid of any vocal entry for that song and bandmate that seems to match. Then, no matter what, put a new record into the VOCALS table with the details you have.",
    "id": 250
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp4` that accepts five input parameters: `para_SONGID` of type `NUMBER`, `para_BANDMATE` of type `NUMBER`, `para_INSTRUMENT` of type `VARCHAR2`, `para_STAGEPOSITION` of type `VARCHAR2`, and `para_TITLE` of type `VARCHAR2` with a default value of 'Untitled Song'. The procedure begins by declaring two local variables: `v_instrument_count` of type `NUMBER` and `v_song_exists` of type `NUMBER`. The first operation is to check for the existence of a song record in the `SONGS` table. This is achieved by executing a `SELECT COUNT(*)` statement to count the number of rows in the `SONGS` table where the `SONGID` column matches the value provided in `para_SONGID`. The result of this count is stored in the `v_song_exists` variable. Following this, a conditional block is executed: if `v_song_exists` is equal to `0`, indicating that no song with the given `para_SONGID` exists in the `SONGS` table, then an `INSERT` statement is performed. This `INSERT` statement adds a new row into the `SONGS` table, populating the `SONGID` column with the value from `para_SONGID` and the `TITLE` column with the value from `para_TITLE`. After this potential insertion, the procedure proceeds to count the number of instruments associated with the given song. This is done by executing another `SELECT COUNT(*)` statement to count the rows in the `INSTRUMENTS` table where the `SONGID` column matches `para_SONGID`. The result of this count is stored in the `v_instrument_count` variable. Subsequently, another conditional block is executed based on the parity of `v_instrument_count`. If the remainder of `v_instrument_count` divided by `2` is `0` (i.e., `v_instrument_count` is an even number), then an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `INSTRUMENTS` table, populating the `SONGID` column with `para_SONGID`, the `BANDMATEID` column with `para_BANDMATE`, and the `INSTRUMENT` column with `para_INSTRUMENT`. If `v_instrument_count` is an odd number, the `ELSE` branch of the conditional block is executed. In this branch, a `DELETE` statement is first performed on the `PERFORMANCE` table. This `DELETE` statement removes any rows from the `PERFORMANCE` table where the `SONGID` column matches `para_SONGID` AND the `BANDMATE` column matches `para_BANDMATE`. Immediately after the `DELETE` operation, an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `PERFORMANCE` table, populating the `SONGID` column with `para_SONGID`, the `BANDMATE` column with `para_BANDMATE`, and the `STAGEPOSITION` column with `para_STAGEPOSITION`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp4(para_SONGID NUMBER, para_BANDMATE NUMBER, para_INSTRUMENT VARCHAR2, para_STAGEPOSITION VARCHAR2, para_TITLE VARCHAR2 DEFAULT 'Untitled Song') IS\n  v_instrument_count NUMBER;\n  v_song_exists NUMBER;\nBEGIN\n  -- Check if SONGID exists in parent table SONGS\n  SELECT COUNT(*) INTO v_song_exists FROM SONGS WHERE SONGID = para_SONGID;\n  \n  IF v_song_exists = 0 THEN\n    -- If SONGID does not exist, insert it into SONGS table\n    INSERT INTO SONGS (SONGID, TITLE) VALUES (para_SONGID, para_TITLE);\n  END IF;\n  \n  SELECT COUNT(*) INTO v_instrument_count FROM INSTRUMENTS WHERE SONGID = para_SONGID;\n  \n  IF MOD(v_instrument_count, 2) = 0 THEN\n    INSERT INTO INSTRUMENTS (SONGID, BANDMATEID, INSTRUMENT) \n    VALUES (para_SONGID, para_BANDMATE, para_INSTRUMENT);\n  ELSE\n    -- Check if a record exists in PERFORMANCE before attempting to delete\n    -- This prevents a potential NO_DATA_FOUND if DELETE was based on a non-existent row\n    -- However, DELETE on non-existent row just affects 0 rows, so it's not strictly necessary to check.\n    -- The primary key constraint on PERFORMANCE (SONGID, BANDMATE) will handle duplicates on INSERT.\n    DELETE FROM PERFORMANCE \n    WHERE SONGID = para_SONGID AND BANDMATE = para_BANDMATE;\n    \n    INSERT INTO PERFORMANCE (SONGID, BANDMATE, STAGEPOSITION) \n    VALUES (para_SONGID, para_BANDMATE, para_STAGEPOSITION);\n  END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "BEGIN\n  sp4(100, 1, 'Guitar', 'Front Left');\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(100, 2, 'Drums', 'Back Center', 'Rock Anthem');\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(101, 1, 'Bass', 'Front Right', 'Jazz Groove');\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(101, 2, 'Keyboard', 'Back Left');\n  COMMIT;\nEND;",
      "BEGIN\n  sp4(102, 3, 'Vocals', 'Center Stage', 'Ballad');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp4` with parameters `para_SONGID` (NUMBER), `para_BANDMATE` (NUMBER), `para_INSTRUMENT` (VARCHAR2), `para_STAGEPOSITION` (VARCHAR2), and `para_TITLE` (VARCHAR2) defaulting to 'Untitled Song'. Check if the song exists in the SONGS table using the SONGID. If not, insert it. Then, count the instruments for this song. If the count is even, insert a record into the INSTRUMENTS table. If the count is odd, delete matching records from the PERFORMANCE table and then insert a new record into it.",
    "natural_language": "Create a stored procedure called `sp4` that takes a few parameters: a song ID number, a band member number, an instrument name, a stage position, and a song title which can be left out to just use a default. First, see if that song is already in the songs list. If it's not there, go ahead and add it. Then, look at how many instruments are linked to this song. If that number seems about rightlike if it's an even amountthen put a new entry into the instruments log. If the number seems off, like if it's odd, then clean out any old performance records for it and put in a fresh one.",
    "id": 251
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp5` that accepts four input parameters: `para_SONGID` of type `NUMBER`, `para_BANDMATE` of type `NUMBER`, `para_TYPE` of type `VARCHAR2`, and `para_TITLE` of type `VARCHAR2`. The purpose of this procedure is to manage song and vocal records based on the existence of vocal entries for a given song.\n\nThe procedure begins by declaring two local variables: `v_vocal_count` of type `NUMBER` to store the count of vocal records, and `v_new_title` of type `VARCHAR2(255)` to store a newly generated song title.\n\nFirst, the procedure executes a `SELECT` statement to count the number of records in the `VOCALS` table where the `SONGID` column matches the input parameter `para_SONGID`. The result of this count is stored in the `v_vocal_count` variable.\n\nNext, it constructs a new song title by concatenating the current date formatted as 'YYYYMMDD' (e.g., '20231027') with an underscore character `_` and the input parameter `para_TITLE`. This new title is assigned to the `v_new_title` variable using the `TO_CHAR` function with `CURRENT_DATE`.\n\nFollowing this, the procedure enters a conditional block (`IF v_vocal_count > 0 THEN`).\n\nIf `v_vocal_count` is greater than 0, indicating that vocal records already exist for the `para_SONGID` in the `VOCALS` table, the procedure executes an `UPDATE` statement on the `SONGS` table. This `UPDATE` statement sets the `TITLE` column to the value stored in `v_new_title` for the row where the `SONGID` column matches the input parameter `para_SONGID`.\n\nIf `v_vocal_count` is not greater than 0 (i.e., it is 0), indicating that no vocal records exist for the `para_SONGID` in the `VOCALS` table, the procedure executes a `MERGE INTO` statement on the `SONGS` table. This `MERGE` statement uses a `DUAL` table subquery to provide the `para_SONGID` as `SONGID` and `para_TITLE` as `TITLE` for comparison. The `MERGE` operation attempts to match records in the `SONGS` table (`s`) with the provided `SONGID` from the `DUAL` source (`d`) using the condition `s.SONGID = d.SONGID`. If a match is `NOT MATCHED` (meaning no song with `para_SONGID` exists in the `SONGS` table), an `INSERT` operation is performed into the `SONGS` table, inserting the `SONGID` from `d.SONGID` (which is `para_SONGID`) and the `TITLE` from `d.TITLE` (which is `para_TITLE`). This ensures that a parent record for the song exists in the `SONGS` table before attempting to insert a vocal record.\n\nAfter the `MERGE` statement (which guarantees the existence of the song in the `SONGS` table), the procedure then executes an `INSERT` statement into the `VOCALS` table. This `INSERT` statement adds a new vocal record with the `SONGID` set to `para_SONGID`, the `BANDMATE` set to `para_BANDMATE`, and the `TYPE` set to `para_TYPE`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp5(para_SONGID NUMBER, para_BANDMATE NUMBER, para_TYPE VARCHAR2, para_TITLE VARCHAR2) IS\n  v_vocal_count NUMBER;\n  v_new_title VARCHAR2(255);\nBEGIN\n  SELECT COUNT(*) INTO v_vocal_count FROM VOCALS WHERE SONGID = para_SONGID;\n  v_new_title := TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '_' || para_TITLE;\n\n  IF v_vocal_count > 0 THEN\n    -- If vocals exist for the song, update the song's title.\n    -- Deleting and re-inserting SONGS would violate foreign key constraints\n    -- with INSTRUMENTS, PERFORMANCE, and VOCALS if child records exist.\n    UPDATE SONGS\n    SET TITLE = v_new_title\n    WHERE SONGID = para_SONGID;\n  ELSE\n    -- If no vocals exist, first ensure the song exists in SONGS,\n    -- then insert the new vocal record.\n    -- Check if the song already exists to avoid primary key violation on SONGS.\n    MERGE INTO SONGS s\n    USING (SELECT para_SONGID AS SONGID, para_TITLE AS TITLE FROM DUAL) d\n    ON (s.SONGID = d.SONGID)\n    WHEN NOT MATCHED THEN\n      INSERT (SONGID, TITLE) VALUES (d.SONGID, d.TITLE);\n\n    -- Now insert into VOCALS, as the parent record in SONGS is guaranteed to exist.\n    INSERT INTO VOCALS (SONGID, BANDMATE, TYPE) VALUES (para_SONGID, para_BANDMATE, para_TYPE);\n  END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "BEGIN\n  sp5(para_SONGID => 101, para_BANDMATE => 1, para_TYPE => 'Lead', para_TITLE => 'New Song Title One');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 102, para_BANDMATE => 2, para_TYPE => 'Backing', para_TITLE => 'Another Song');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 101, para_BANDMATE => 3, para_TYPE => 'Harmony', para_TITLE => 'Updated Song Title');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 103, para_BANDMATE => 4, para_TYPE => 'Lead', para_TITLE => 'Brand New Track');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 104, para_BANDMATE => 5, para_TYPE => 'Backing', para_TITLE => 'Fifth Song');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp5` with parameters `para_SONGID` (NUMBER), `para_BANDMATE` (NUMBER), `para_TYPE` (VARCHAR2), and `para_TITLE` (VARCHAR2). Count the vocal records for the song. If vocals exist, update the song's title to a new title formatted as 'YYYYMMDD_TITLE'. If no vocals exist, ensure the song exists in the SONGS table using a MERGE operation (insert if not present), then insert a new record into the VOCALS table.",
    "natural_language": "How can I create a stored procedure named `sp5` that takes parameters `para_SONGID` (NUMBER), `para_BANDMATE` (NUMBER), `para_TYPE` (VARCHAR2), and `para_TITLE` (VARCHAR2), counts the vocal records for the specified song, and then updates the song's title to a 'YYYYMMDD_TITLE' format if vocals exist, or uses a MERGE to ensure the song exists and inserts a new vocal record if no vocals are found?",
    "id": 252
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_analyze_artist_portfolio that takes a single parameter p_artist_id of type NUMBER, representing the unique identifier of an artist. The procedure begins by declaring several local variables: v_painting_count and v_sculpture_count to store the count of paintings and sculptures associated with the artist, v_avg_painting_year and v_avg_sculpture_year to store the average year of creation for paintings and sculptures, v_total_artworks to store the total number of artworks, v_artist_fname and v_artist_lname to store the artist's first and last names, v_birth_year and v_death_year to store the artist's birth and death years, and v_career_span to store the span of the artist's career. The procedure first retrieves the count of paintings from the PAINTINGS table where the PAINTERID matches p_artist_id and stores it in v_painting_count. Similarly, it retrieves the count of sculptures from the SCULPTURES table where the SCULPTORID matches p_artist_id and stores it in v_sculpture_count. If the artist has paintings, it calculates the average year of the paintings using the REGR_AVGX function on the PAINTINGS table and stores the result in v_avg_painting_year; otherwise, it sets v_avg_painting_year to 0. Similarly, if the artist has sculptures, it calculates the average year of the sculptures using the REGR_AVGX function on the SCULPTURES table and stores the result in v_avg_sculpture_year; otherwise, it sets v_avg_sculpture_year to 0. The procedure then calculates the total number of artworks by summing v_painting_count and v_sculpture_count and stores the result in v_total_artworks. It retrieves the artist's first name, last name, birth year, and death year from the ARTISTS table where ARTISTID matches p_artist_id and stores them in v_artist_fname, v_artist_lname, v_birth_year, and v_death_year, respectively. The career span is calculated by subtracting v_birth_year from v_death_year and stored in v_career_span. The procedure then evaluates several conditions: if v_total_artworks is 0, it deletes the artist from the ARTISTS table; if both v_painting_count and v_sculpture_count are greater than 5, it inserts a new record into the ARTISTS table with a modified ARTISTID and appends '_MASTER' to the artist's first name; if v_painting_count is greater than v_sculpture_count and v_avg_painting_year is greater than 1900, it inserts a new record with '_MODERN' appended to the first name; if v_sculpture_count is greater than v_painting_count and v_avg_sculpture_year is less than 1900, it inserts a new record with '_CLASSIC' appended to the first name; if v_career_span is greater than 50 and v_total_artworks is greater than 3, it inserts a new record with '_PROLIFIC' appended to the first name; if both v_avg_painting_year and v_avg_sculpture_year are greater than 0, it inserts a new record with '_VERSATILE' appended to the first name. If none of these conditions are met, it deletes all paintings associated with the artist from the PAINTINGS table.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_analyze_artist_portfolio(p_artist_id NUMBER) IS\n  v_painting_count NUMBER;\n  v_sculpture_count NUMBER;\n  v_avg_painting_year NUMBER;\n  v_avg_sculpture_year NUMBER;\n  v_total_artworks NUMBER;\n  v_artist_fname VARCHAR2(255);\n  v_artist_lname VARCHAR2(255);\n  v_birth_year NUMBER;\n  v_death_year NUMBER;\n  v_career_span NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_painting_count FROM PAINTINGS WHERE PAINTERID = p_artist_id;\n  SELECT COUNT(*) INTO v_sculpture_count FROM SCULPTURES WHERE SCULPTORID = p_artist_id;\n  \n  IF v_painting_count > 0 THEN\n    SELECT REGR_AVGX(PAINTINGID, YEAR) INTO v_avg_painting_year FROM PAINTINGS WHERE PAINTERID = p_artist_id;\n  ELSE\n    v_avg_painting_year := 0;\n  END IF;\n  \n  IF v_sculpture_count > 0 THEN\n    SELECT REGR_AVGX(SCULPTUREID, YEAR) INTO v_avg_sculpture_year FROM SCULPTURES WHERE SCULPTORID = p_artist_id;\n  ELSE\n    v_avg_sculpture_year := 0;\n  END IF;\n  \n  v_total_artworks := v_painting_count + v_sculpture_count;\n  \n  SELECT FNAME, LNAME, BIRTHYEAR, DEATHYEAR INTO v_artist_fname, v_artist_lname, v_birth_year, v_death_year\n  FROM ARTISTS WHERE ARTISTID = p_artist_id;\n  \n  v_career_span := v_death_year - v_birth_year;\n  \n  IF v_total_artworks = 0 THEN\n    DELETE FROM ARTISTS WHERE ARTISTID = p_artist_id;\n  ELSIF v_painting_count > 5 AND v_sculpture_count > 5 THEN\n    INSERT INTO ARTISTS (ARTISTID, FNAME, LNAME, BIRTHYEAR, DEATHYEAR) \n    VALUES (p_artist_id + 10000, v_artist_fname || '_MASTER', v_artist_lname, v_birth_year, v_death_year);\n  ELSIF v_painting_count > v_sculpture_count AND v_avg_painting_year > 1900 THEN\n    INSERT INTO ARTISTS (ARTISTID, FNAME, LNAME, BIRTHYEAR, DEATHYEAR) \n    VALUES (p_artist_id + 20000, v_artist_fname || '_MODERN', v_artist_lname, v_birth_year, v_death_year);\n  ELSIF v_sculpture_count > v_painting_count AND v_avg_sculpture_year < 1900 THEN\n    INSERT INTO ARTISTS (ARTISTID, FNAME, LNAME, BIRTHYEAR, DEATHYEAR) \n    VALUES (p_artist_id + 30000, v_artist_fname || '_CLASSIC', v_artist_lname, v_birth_year, v_death_year);\n  ELSIF v_career_span > 50 AND v_total_artworks > 3 THEN\n    INSERT INTO ARTISTS (ARTISTID, FNAME, LNAME, BIRTHYEAR, DEATHYEAR) \n    VALUES (p_artist_id + 40000, v_artist_fname || '_PROLIFIC', v_artist_lname, v_birth_year, v_death_year);\n  ELSIF v_avg_painting_year > 0 AND v_avg_sculpture_year > 0 THEN\n    INSERT INTO ARTISTS (ARTISTID, FNAME, LNAME, BIRTHYEAR, DEATHYEAR) \n    VALUES (p_artist_id + 50000, v_artist_fname || '_VERSATILE', v_artist_lname, v_birth_year, v_death_year);\n  ELSE\n    DELETE FROM PAINTINGS WHERE PAINTERID = p_artist_id;\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_analyze_artist_portfolio(111);\n  commit;\nEND;",
      "BEGIN\n  sp_analyze_artist_portfolio(222);\n  commit;\nEND;",
      "BEGIN\n  sp_analyze_artist_portfolio(333);\n  commit;\nEND;",
      "BEGIN\n  sp_analyze_artist_portfolio(444);\n  commit;\nEND;",
      "BEGIN\n  sp_analyze_artist_portfolio(555);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_analyze_artist_portfolio` with a parameter `p_artist_id` (NUMBER). Retrieve the artist's details and counts/averages of their paintings and sculptures. Based on these values, perform conditional operations: delete the artist if they have no artworks; insert a modified artist record if they meet specific criteria (e.g., high counts, modern/classic era, long career, versatile); otherwise, delete all their paintings.",
    "natural_language": "Construct a stored procedure designated as `sp_analyze_artist_portfolio` that accepts a single input parameter, `p_artist_id`, of the NUMBER data type. The procedure shall retrieve the specified artist's details along with aggregate counts and averages pertaining to their paintings and sculptures. Subsequently, based upon the retrieved values, execute conditional logic as follows: if the artist possesses no artworks, delete the artist record; if the artist satisfies specific criteriasuch as a high volume of works, classification within a modern or classic era, an extensive career duration, or demonstrated versatilityinsert a modified record for the artist; in all other cases, delete all paintings associated with the artist.",
    "id": 253
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ManagePetRecords` that does not accept any input parameters. This procedure declares several local variables: `v_pet_count` of type `NUMBER`, `v_stuid` of type `NUMBER` initialized to `1001`, `v_petid` of type `NUMBER` initialized to `2001`, `v_new_petid` of type `NUMBER` initialized to `2003`, and `v_exists` of type `NUMBER`. The procedure begins by executing a `SELECT` statement to count the number of records in the `HAS_PET` table where the `STUID` column matches the value of `v_stuid` (which is `1001`). The result of this count is stored in the `v_pet_count` variable. Following this, a conditional `IF-ELSIF-ELSE` block is executed based on the value of `v_pet_count`.\n\nIf `v_pet_count` is greater than `2`, the procedure executes a `DELETE` statement on the `HAS_PET` table. This `DELETE` operation removes all rows where the `STUID` column matches `v_stuid` (which is `1001`) AND the `PETID` column matches `v_petid` (which is `2001`).\n\nIf `v_pet_count` is not greater than `2` but is equal to `2`, the procedure executes an `UPDATE` statement on the `HAS_PET` table. This `UPDATE` operation sets the `PETID` column to the value of `v_new_petid` (which is `2003`) for all rows where the `STUID` column matches `v_stuid` (which is `1001`) AND the `PETID` column matches `v_petid` (which is `2001`).\n\nIf `v_pet_count` is neither greater than `2` nor equal to `2` (implying it is less than `2`), the procedure enters the `ELSE` block. Within this `ELSE` block, another `SELECT` statement is executed to count the number of records in the `HAS_PET` table where the `STUID` column matches `v_stuid` (which is `1001`) AND the `PETID` column matches `v_new_petid` (which is `2003`). The result of this count is stored in the `v_exists` variable. Subsequently, an inner `IF` statement checks if `v_exists` is equal to `0`. If `v_exists` is `0`, indicating that a pet with `STUID` `1001` and `PETID` `2003` does not already exist, an `INSERT` statement is executed. This `INSERT` operation adds a new row into the `HAS_PET` table, setting the `STUID` column to the value of `v_stuid` (which is `1001`) and the `PETID` column to the value of `v_new_petid` (which is `2003`).",
    "plsql": "CREATE OR REPLACE PROCEDURE ManagePetRecords IS\n  v_pet_count NUMBER;\n  v_stuid NUMBER := 1001;\n  v_petid NUMBER := 2001;\n  v_new_petid NUMBER := 2003;\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_pet_count FROM HAS_PET WHERE STUID = v_stuid;\n\n  IF v_pet_count > 2 THEN\n    DELETE FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSIF v_pet_count = 2 THEN\n    UPDATE HAS_PET SET PETID = v_new_petid WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSE\n    SELECT COUNT(*) INTO v_exists FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_new_petid;\n    IF v_exists = 0 THEN\n      INSERT INTO HAS_PET (STUID, PETID) VALUES (v_stuid, v_new_petid);\n    END IF;\n  END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET"
    ],
    "call_sqls": [
      "BEGIN\n  ManagePetRecords;\nEND;"
    ],
    "summary": "Create a stored procedure named `ManagePetRecords` with no parameters. Use local variables for student ID (1001) and pet IDs (2001, 2003). Count the pets for the student. If the count is >2, delete the record for pet 2001. If the count equals 2, update the pet ID from 2001 to 2003. If the count is <2, check if the record for pet 2003 exists; if not, insert it.",
    "natural_language": "Create procedure ManagePetRecords. Use local vars for student ID 1001 and pet IDs 2001, 2003. Count student's pets. If >2, delete pet 2001. If =2, update pet 2001 to 2003. If <2, insert pet 2003 if missing.",
    "id": 254
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AnalyzePetData that performs several operations on the HAS_PET table. First, it calculates the total number of pets by executing a SELECT COUNT(*) query and stores the result in the variable v_total_pets of type NUMBER. Next, it determines the number of unique students who have pets by executing a SELECT COUNT(DISTINCT STUID) query and stores the result in the variable v_unique_students of type NUMBER. The procedure then calculates the average number of pets per student by dividing v_total_pets by v_unique_students, storing the result in v_avg_pets_per_student of type NUMBER, with a conditional check to ensure division by zero is avoided by setting v_avg_pets_per_student to 0 if v_unique_students is zero. The procedure uses two predefined NUMBER variables, v_stuid set to 1002 and v_petid set to 2003, for subsequent operations. It then evaluates the value of v_avg_pets_per_student using conditional logic: if the average is greater than 1, it deletes a record from HAS_PET where the STUID column matches v_stuid and the PETID column matches v_petid; if the average equals 1, it updates the HAS_PET table by incrementing the PETID column by 1 for the record where STUID matches v_stuid and PETID matches v_petid; if the average is less than 1, it inserts a new record into HAS_PET with STUID set to v_stuid and PETID set to v_petid.",
    "plsql": "CREATE OR REPLACE PROCEDURE AnalyzePetData IS\n  v_total_pets NUMBER;\n  v_unique_students NUMBER;\n  v_avg_pets_per_student NUMBER;\n  v_stuid NUMBER := 1002;\n  v_petid NUMBER := 2003;\nBEGIN\n  SELECT COUNT(*) INTO v_total_pets FROM HAS_PET;\n\n  SELECT COUNT(DISTINCT STUID) INTO v_unique_students FROM HAS_PET;\n\n  IF v_unique_students > 0 THEN\n    v_avg_pets_per_student := v_total_pets / v_unique_students;\n  ELSE\n    v_avg_pets_per_student := 0;\n  END IF;\n\n  IF v_avg_pets_per_student > 1 THEN\n    DELETE FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSIF v_avg_pets_per_student = 1 THEN\n    UPDATE HAS_PET SET PETID = v_petid + 1 WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSE\n    INSERT INTO HAS_PET (STUID, PETID) VALUES (v_stuid, v_petid);\n  END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET"
    ],
    "call_sqls": [
      "BEGIN\n  AnalyzePetData;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `AnalyzePetData`. Calculate the total number of pets and unique students from the HAS_PET table. Compute the average pets per student. Based on this average: if >1, delete a specific record (STUID=1002, PETID=2003); if =1, update that record by incrementing PETID by 1; if <1, insert that record.",
    "natural_language": "Develop a stored procedure called `AnalyzePetData` that performs a comprehensive analysis of pet ownership. First, it must determine the overall count of pets and the distinct number of students recorded within the HAS_PET table. Subsequently, it calculates the detailed average of pets owned per student. Based on the result of this computed average, the procedure will execute a conditional action: if the average is determined to be greater than one, it will meticulously delete the specific record where the student ID is 1002 and the pet ID is 2003; if the average is found to be exactly equal to one, it will carefully update that very same record by incrementing the pet ID value by one; finally, if the average is discovered to be less than one, it will proceed to insert that exact record into the table.",
    "id": 255
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdatePetRecords` that does not accept any explicit input parameters. This procedure declares and initializes several local variables: `v_stuid` of type `NUMBER` to `1001`, `v_petid` of type `NUMBER` to `2002`, `v_new_petid` of type `NUMBER` to `2003`, `v_exists` of type `NUMBER`, and `v_total_pets` of type `NUMBER`. The procedure begins by executing a `SELECT` statement to count the total number of records in the `HAS_PET` table where the `STUID` column matches the value stored in `v_stuid` (which is `1001`). The result of this count is then stored into the `v_total_pets` variable. Following this, a conditional `IF` statement evaluates whether the value of `v_total_pets` is greater than `3`.\n\nIf `v_total_pets` is indeed greater than `3`, the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `HAS_PET` table where both the `STUID` column matches the value of `v_stuid` (which is `1001`) AND the `PETID` column matches the value of `v_petid` (which is `2002`).\n\nIf `v_total_pets` is NOT greater than `3` (i.e., it is less than or equal to `3`), the procedure proceeds to the `ELSE` block. Within this `ELSE` block, another `SELECT` statement is executed. This `SELECT` statement counts the number of records in the `HAS_PET` table where both the `STUID` column matches the value of `v_stuid` (which is `1001`) AND the `PETID` column matches the value of `v_new_petid` (which is `2003`). The result of this count is stored into the `v_exists` variable. Subsequently, a nested conditional `IF` statement evaluates whether the value of `v_exists` is equal to `0`.\n\nIf `v_exists` is equal to `0`, it indicates that a record with the specified `STUID` and `v_new_petid` does not exist. In this case, an `INSERT` statement is executed. This `INSERT` statement adds a new record into the `HAS_PET` table, setting the `STUID` column to the value of `v_stuid` (which is `1001`) and the `PETID` column to the value of `v_new_petid` (which is `2003`).\n\nIf `v_exists` is NOT equal to `0` (i.e., it is greater than `0`), it indicates that a record with the specified `STUID` and `v_new_petid` already exists. In this alternative scenario, an `UPDATE` statement is executed. This `UPDATE` statement modifies records in the `HAS_PET` table by setting the `PETID` column to the value of `v_new_petid` (which is `2003`). This update is applied to records where both the `STUID` column matches the value of `v_stuid` (which is `1001`) AND the `PETID` column matches the value of `v_petid` (which is `2002`).",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdatePetRecords IS\n  v_stuid NUMBER := 1001;\n  v_petid NUMBER := 2002;\n  v_new_petid NUMBER := 2003; -- Changed to an existing PETID to satisfy FK constraint\n  v_exists NUMBER;\n  v_total_pets NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_total_pets FROM HAS_PET WHERE STUID = v_stuid;\n\n  IF v_total_pets > 3 THEN\n    DELETE FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSE\n    SELECT COUNT(*) INTO v_exists FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_new_petid;\n    IF v_exists = 0 THEN\n      INSERT INTO HAS_PET (STUID, PETID) VALUES (v_stuid, v_new_petid);\n    ELSE\n      UPDATE HAS_PET SET PETID = v_new_petid WHERE STUID = v_stuid AND PETID = v_petid;\n    END IF;\n  END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET"
    ],
    "call_sqls": [
      "BEGIN\n  UpdatePetRecords;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdatePetRecords with no parameters. Declare and initialize variables: v_stuid=1001, v_petid=2002, v_new_petid=2003, v_exists, v_total_pets. Count records in HAS_PET where STUID = v_stuid into v_total_pets. If v_total_pets > 3, delete from HAS_PET where STUID = v_stuid and PETID = v_petid. Else, count records where STUID = v_stuid and PETID = v_new_petid into v_exists. If v_exists = 0, insert into HAS_PET (STUID, PETID) values (v_stuid, v_new_petid). Else, update HAS_PET set PETID = v_new_petid where STUID = v_stuid and PETID = v_petid.",
    "natural_language": "Please construct a stored procedure designated as UpdatePetRecords, which shall accept no parameters. Within the procedure, declare and initialize the following variables: v_stuid to 1001, v_petid to 2002, v_new_petid to 2003, v_exists, and v_total_pets. Subsequently, ascertain the total number of records in the HAS_PET table where the STUID matches the value of v_stuid, storing this count in the variable v_total_pets. Should the value of v_total_pets exceed three, execute a deletion from the HAS_PET table for the record where STUID equals v_stuid and PETID equals v_petid. Otherwise, determine the count of records where STUID equals v_stuid and PETID equals v_new_petid, storing this result in v_exists. If v_exists is found to be zero, insert a new record into the HAS_PET table with the specified STUID and v_new_petid as the PETID. Conversely, if v_exists is not zero, perform an update on the HAS_PET table, setting the PETID to v_new_petid for the record where STUID equals v_stuid and PETID equals v_petid.",
    "id": 256
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named PetStatistics that declares and initializes four numeric variables: v_stuid to 1002, v_petid to 2003, v_new_petid to 2006, and two uninitialized numeric variables v_pet_count and v_exists. The procedure first queries the HAS_PET table to count the number of rows where the STUID column equals the value of v_stuid (1002) and stores this count in v_pet_count. If v_pet_count is greater than 1, it deletes from the HAS_PET table the single row where STUID equals v_stuid (1002) and PETID equals v_petid (2003). If v_pet_count is exactly equal to 1, it updates the HAS_PET table, setting the PETID column to the value of v_new_petid (2006) for the row where STUID equals v_stuid (1002) and PETID equals v_petid (2003). If v_pet_count is not greater than 1 and not equal to 1 (meaning it is 0), it then queries the HAS_PET table to count the number of rows where STUID equals v_stuid (1002) and PETID equals v_new_petid (2006), storing this count in v_exists. If v_exists is 0, it inserts a new row into the HAS_PET table with STUID set to v_stuid (1002) and PETID set to v_new_petid (2006).",
    "plsql": "CREATE OR REPLACE PROCEDURE PetStatistics IS\n  v_stuid NUMBER := 1002;\n  v_petid NUMBER := 2003;\n  v_new_petid NUMBER := 2006;\n  v_pet_count NUMBER;\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_pet_count FROM HAS_PET WHERE STUID = v_stuid;\n\n  IF v_pet_count > 1 THEN\n    DELETE FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSIF v_pet_count = 1 THEN\n    UPDATE HAS_PET SET PETID = v_new_petid WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSE\n    SELECT COUNT(*) INTO v_exists FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_new_petid;\n    IF v_exists = 0 THEN\n      INSERT INTO HAS_PET (STUID, PETID) VALUES (v_stuid, v_new_petid);\n    END IF;\n  END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET"
    ],
    "call_sqls": [
      "BEGIN\n  PetStatistics;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named PetStatistics. Declare and initialize variables: v_stuid=1002, v_petid=2003, v_new_petid=2006, v_pet_count, v_exists. Count records in HAS_PET where STUID = v_stuid into v_pet_count. If v_pet_count > 1, delete from HAS_PET where STUID = v_stuid and PETID = v_petid. If v_pet_count = 1, update HAS_PET set PETID = v_new_petid where STUID = v_stuid and PETID = v_petid. If v_pet_count = 0, count records where STUID = v_stuid and PETID = v_new_petid into v_exists. If v_exists = 0, insert into HAS_PET (STUID, PETID) values (v_stuid, v_new_petid).",
    "natural_language": "Alright, so we need a stored procedure called PetStatistics. First off, let's set up some variables: v_stuid gets 1002, v_petid is 2003, v_new_petid becomes 2006, and we'll have v_pet_count and v_exists ready to go. Start by counting how many pet records this student (v_stuid) has already got and toss that number into v_pet_count. If they've got more than one pet, just go ahead and delete the specific pet (v_petid) for that student. If they only have one pet on record, then swap that old pet ID (v_petid) out for the new one (v_new_petid). Now, if it turns out they don't have any pets at all, check if this new pet (v_new_petid) is already linked to them and put the result in v_exists. If that check comes back zero, meaning the pet isn't there, then add a new record for the student with the new pet.",
    "id": 257
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ManageStudentPets that operates on the HAS_PET table, which contains columns STUID and PETID. The procedure initializes three local variables: v_stuid of type NUMBER set to 1001, v_petid of type NUMBER set to 2001, and v_new_petid of type NUMBER set to 2002. It also declares two additional NUMBER variables, v_pet_count and v_exists, for storing intermediate results. The procedure begins by executing a SELECT statement to count the number of rows in the HAS_PET table where the STUID column matches the value of v_stuid, storing the result in v_pet_count. It then evaluates whether v_pet_count is greater than 2. If this condition is true, it performs a DELETE operation on the HAS_PET table, removing the row where STUID equals v_stuid and PETID equals v_petid. If the condition is false, the procedure executes another SELECT statement to count the number of rows in the HAS_PET table where both STUID equals v_stuid and PETID equals v_new_petid, storing the result in v_exists. It then checks if v_exists equals 0. If true, it performs an INSERT operation, adding a new row to the HAS_PET table with STUID set to v_stuid and PETID set to v_new_petid. If v_exists is not 0, it performs an UPDATE operation on the HAS_PET table, changing the PETID to v_new_petid for the row where STUID equals v_stuid and PETID equals v_petid.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageStudentPets IS\n  v_stuid NUMBER := 1001;\n  v_petid NUMBER := 2001;\n  -- Changed v_new_petid to an existing PETID from the HAS_PET examples to satisfy FK constraint\n  v_new_petid NUMBER := 2002; \n  v_pet_count NUMBER;\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_pet_count FROM HAS_PET WHERE STUID = v_stuid;\n\n  IF v_pet_count > 2 THEN\n    DELETE FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_petid;\n  ELSE\n    SELECT COUNT(*) INTO v_exists FROM HAS_PET WHERE STUID = v_stuid AND PETID = v_new_petid;\n    IF v_exists = 0 THEN\n      INSERT INTO HAS_PET (STUID, PETID) VALUES (v_stuid, v_new_petid);\n    ELSE\n      UPDATE HAS_PET SET PETID = v_new_petid WHERE STUID = v_stuid AND PETID = v_petid;\n    END IF;\n  END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET"
    ],
    "call_sqls": [
      "BEGIN\n  ManageStudentPets;\nEND;"
    ],
    "summary": "Create a stored procedure named ManageStudentPets. Declare and initialize variables: v_stuid=1001, v_petid=2001, v_new_petid=2002, v_pet_count, v_exists. Count records in HAS_PET where STUID = v_stuid into v_pet_count. If v_pet_count > 2, delete from HAS_PET where STUID = v_stuid and PETID = v_petid. Else, count records where STUID = v_stuid and PETID = v_new_petid into v_exists. If v_exists = 0, insert into HAS_PET (STUID, PETID) values (v_stuid, v_new_petid). Else, update HAS_PET set PETID = v_new_petid where STUID = v_stuid and PETID = v_petid.",
    "natural_language": "Alright, so we need a stored procedure called ManageStudentPets. First off, let's set up some variables: v_stuid gets 1001, v_petid is 2001, v_new_petid becomes 2002, and we'll have v_pet_count and v_exists ready to go. Start by checking how many pets this student already has in HAS_PET. If they've got more than two pets, we gotta remove the one with PETID = v_petid. If they have two or fewer, then we check if the new pet (v_new_petid) is already linked to them. If it's not there at all, just add the new pet. But if it is already listed, then we'll just update the old pet's ID to the new one instead.",
    "id": 258
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc1 that accepts a single parameter, para_artist_id, of type NUMBER, which represents the unique identifier of an artist. The procedure performs two main operations. First, it deletes a record from the ARTIST table where the ARTIST_ID column matches the value of para_artist_id and the AGE column is less than 25. This operation removes young artists with the specified ID from the database. Second, the procedure inserts a new record into the MUSIC_FESTIVAL table. The ID column of the new record is assigned a value that is one greater than the current maximum ID value found in the MUSIC_FESTIVAL table, using the NVL function to handle cases where the table might be empty by defaulting to 0. The MUSIC_FESTIVAL column is set to the string 'New Festival', indicating the name of the festival. The VOLUME column is populated with the count of records from the VOLUME table where the ARTIST_ID column matches the value of para_artist_id, effectively recording the number of volumes associated with the specified artist.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc1(para_artist_id NUMBER) IS\nBEGIN\n  DELETE FROM ARTIST WHERE ARTIST_ID = para_artist_id AND AGE < 25;\n  INSERT INTO MUSIC_FESTIVAL (ID, MUSIC_FESTIVAL, VOLUME) \n  VALUES ((SELECT NVL(MAX(ID),0)+1 FROM MUSIC_FESTIVAL), 'New Festival', (SELECT COUNT(*) FROM VOLUME WHERE ARTIST_ID = para_artist_id));\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc1(1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(10);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(15);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc1 with one input parameter para_artist_id (NUMBER). First, delete from ARTIST where ARTIST_ID = para_artist_id and AGE < 25. Then, insert into MUSIC_FESTIVAL (ID, MUSIC_FESTIVAL, VOLUME) values (NVL((SELECT MAX(ID) FROM MUSIC_FESTIVAL), 0) + 1, 'New Festival', (SELECT COUNT(*) FROM VOLUME WHERE ARTIST_ID = para_artist_id)).",
    "natural_language": "Hey, can you whip up a stored procedure called sp_proc1? It needs one number input called para_artist_id. First off, get rid of any artists from the ARTIST table where their ARTIST_ID matches that input and they're under 25. After that, pop a new entry into the MUSIC_FESTIVAL table. For the ID, take the biggest current ID from MUSIC_FESTIVAL (or start at 0 if it's empty) and just add 1 to it. Set the MUSIC_FESTIVAL name to 'New Festival'. For the VOLUME, grab the count of all records in the VOLUME table that are linked to that same artist ID.",
    "id": 259
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_proc2` that accepts a single input parameter, `para_volume_id`, which is of data type `NUMBER`. The procedure first performs an `UPDATE` operation on the `VOLUME` table. In this update, it increments the value of the `WEEKS_ON_TOP` column by 1 for all rows where the `VOLUME_ID` column matches the value provided in the `para_volume_id` input parameter. Following this update, the procedure executes an `INSERT` operation into the `ARTIST` table. For this insert, it populates three columns: `ARTIST_ID`, `ARTIST`, and `AGE`. The `ARTIST_ID` column is populated by first executing a subquery that selects the maximum value from the `ARTIST_ID` column in the `ARTIST` table, uses the `NVL` function to treat a `NULL` result from `MAX` as 0, and then adds 1 to this result to generate a new, unique `ARTIST_ID`. The `ARTIST` column is populated with the string literal 'New Artist'. The `AGE` column is populated with the numeric literal 30.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc2(para_volume_id NUMBER) IS\nBEGIN\n  UPDATE VOLUME SET WEEKS_ON_TOP = WEEKS_ON_TOP + 1 WHERE VOLUME_ID = para_volume_id;\n  INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE) \n  VALUES ((SELECT NVL(MAX(ARTIST_ID),0)+1 FROM ARTIST), 'New Artist', 30);\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc2(1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc2(2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc2(3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc2(4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc2(5);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc2 with one input parameter para_volume_id (NUMBER). First, update VOLUME set WEEKS_ON_TOP = WEEKS_ON_TOP + 1 where VOLUME_ID = para_volume_id. Then, insert into ARTIST (ARTIST_ID, ARTIST, AGE) values (NVL((SELECT MAX(ARTIST_ID) FROM ARTIST), 0) + 1, 'New Artist', 30).",
    "natural_language": "Please construct a stored procedure designated as sp_proc2, which accepts a single input parameter named para_volume_id of the NUMBER data type. The procedure's operations must be executed in the following sequence: first, increment the WEEKS_ON_TOP value by one in the VOLUME table for the record where the VOLUME_ID matches the provided parameter. Subsequently, insert a new record into the ARTIST table. The values for this insertion shall be derived as follows: the ARTIST_ID shall be calculated as one greater than the current maximum ARTIST_ID found in the ARTIST table, or zero if the table is empty; the ARTIST name shall be 'New Artist'; and the AGE shall be 30.",
    "id": 260
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc3 that accepts a single input parameter named para_festival_id of the NUMBER data type, and within its execution block, first performs a DELETE operation on the MUSIC_FESTIVAL table, specifically removing any row where the ID column exactly matches the provided para_festival_id value, and then immediately performs an INSERT operation into the VOLUME table, populating the columns VOLUME_ID, VOLUME_ISSUE, WEEKS_ON_TOP, and ARTIST_ID with values determined as follows: for VOLUME_ID, it executes a subquery on the VOLUME table to find the current maximum value in the VOLUME_ID column, applies the NVL function to that result to convert a possible NULL value to 0, and then adds 1 to that result; for VOLUME_ISSUE, it uses the literal string 'New Issue'; for WEEKS_ON_TOP, it uses the literal number 0; and for ARTIST_ID, it executes a subquery on the ARTIST table to retrieve the minimum value found in the ARTIST_ID column.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc3(para_festival_id NUMBER) IS\nBEGIN\n  DELETE FROM MUSIC_FESTIVAL WHERE ID = para_festival_id;\n  INSERT INTO VOLUME (VOLUME_ID, VOLUME_ISSUE, WEEKS_ON_TOP, ARTIST_ID) \n  VALUES ((SELECT NVL(MAX(VOLUME_ID),0)+1 FROM VOLUME), 'New Issue', 0, (SELECT MIN(ARTIST_ID) FROM ARTIST));\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc3(1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc3(2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc3(3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc3(10);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc3(25);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc3 that accepts a NUMBER parameter para_festival_id. It deletes rows from MUSIC_FESTIVAL where ID equals the parameter, then inserts a new row into VOLUME. The new row's VOLUME_ID is the maximum existing VOLUME_ID plus 1 (defaulting to 0 if null), VOLUME_ISSUE is 'New Issue', WEEKS_ON_TOP is 0, and ARTIST_ID is the minimum ARTIST_ID from the ARTIST table.",
    "natural_language": "How can I create a stored procedure called sp_proc3 that takes a NUMBER parameter named para_festival_id, deletes records from the MUSIC_FESTIVAL table where the ID matches the parameter, and then inserts a new row into the VOLUME table with a VOLUME_ID set to one more than the current maximum (or 0 if none exist), a VOLUME_ISSUE of 'New Issue', a WEEKS_ON_TOP of 0, and an ARTIST_ID equal to the smallest ARTIST_ID from the ARTIST table?",
    "id": 261
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_proc4` that accepts one input parameter, `para_artist_name`, which is of type `VARCHAR2` and represents the name of an artist to be inserted. The procedure first performs an `INSERT` operation into the `ARTIST` table. For this `INSERT`, it populates the `ARTIST_ID` column by executing a subquery that calculates the maximum existing `ARTIST_ID` from the `ARTIST` table using the `MAX` aggregate function, handles cases where no `ARTIST_ID` exists by defaulting to `0` using the `NVL` function, and then increments this value by `1` to generate a new unique identifier. The `ARTIST` column is populated with the value provided by the `para_artist_name` input parameter. The `AGE` column is populated with the static integer value `28`. Following this `INSERT` operation, the procedure performs a `DELETE` operation on the `VOLUME` table. This `DELETE` operation removes all rows from the `VOLUME` table where the value in the `WEEKS_ON_TOP` column is strictly less than `2`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc4(para_artist_name VARCHAR2) IS\nBEGIN\n  INSERT INTO ARTIST (ARTIST_ID, ARTIST, AGE) \n  VALUES ((SELECT NVL(MAX(ARTIST_ID),0)+1 FROM ARTIST), para_artist_name, 28);\n  DELETE FROM VOLUME WHERE WEEKS_ON_TOP < 2;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc4('Metallica');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc4('Taylor Swift');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc4('The Beatles');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc4('Beyonc');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc4('Ed Sheeran');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc4 that accepts a VARCHAR2 parameter para_artist_name. It inserts a new artist into the ARTIST table with an ARTIST_ID set to the maximum existing ID plus 1 (defaulting to 0 if null), the ARTIST name from the parameter, and AGE set to 28. It then deletes all rows from the VOLUME table where WEEKS_ON_TOP is less than 2.",
    "natural_language": "Create a stored procedure, which should be named sp_proc4, that accepts a single input parameter of type VARCHAR2 called para_artist_name. This procedure will first perform an insertion into the ARTIST table, carefully constructing a new record where the ARTIST_ID is dynamically calculated by taking the maximum existing ID value from the table and incrementing it by one, gracefully defaulting to 0 if the current maximum is null. The ARTIST name for this new entry is taken directly from the provided parameter, while the AGE is explicitly set to a fixed value of 28. Subsequently, the procedure will execute a deletion operation, removing all rows from the VOLUME table where the WEEKS_ON_TOP column contains a value that is strictly less than 2.",
    "id": 262
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc5 that accepts a single input parameter named para_category of data type VARCHAR2, which is intended to represent a new category value, and performs two distinct data manipulation operations in sequence: first, it executes an UPDATE statement targeting the MUSIC_FESTIVAL table, specifically modifying the CATEGORY column for all rows where the VOLUME column value is equal to the maximum VOLUME_ID value retrieved from a scalar subquery that selects the MAX(VOLUME_ID) from the VOLUME table; second, it executes a DELETE statement that removes all rows from the ARTIST table where the value in the AGE column is strictly greater than 40.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc5(para_category VARCHAR2) IS\nBEGIN\n  UPDATE MUSIC_FESTIVAL SET CATEGORY = para_category WHERE VOLUME = (SELECT MAX(VOLUME_ID) FROM VOLUME);\n  DELETE FROM ARTIST WHERE AGE > 40;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc5('Rock');\n  commit;\nEND;",
      "BEGIN\n  sp_proc5('Jazz');\n  commit;\nEND;",
      "BEGIN\n  sp_proc5('Pop');\n  commit;\nEND;",
      "BEGIN\n  sp_proc5('Classical');\n  commit;\nEND;",
      "BEGIN\n  sp_proc5('Electronic');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc5 that accepts a VARCHAR2 parameter para_category. It updates the MUSIC_FESTIVAL table, setting the CATEGORY to the parameter value for all rows where the VOLUME column equals the maximum VOLUME_ID from the VOLUME table. It then deletes all rows from the ARTIST table where AGE is greater than 40.",
    "natural_language": "Please construct a stored procedure designated as sp_proc5, which shall accept a single input parameter of type VARCHAR2 named para_category. The procedure is to execute an update operation on the MUSIC_FESTIVAL table, assigning the CATEGORY column the value of the provided parameter for every record where the VOLUME column matches the maximum VOLUME_ID value ascertained from the VOLUME table. Subsequently, the procedure must perform a deletion of all entries within the ARTIST table where the AGE column exceeds 40.",
    "id": 263
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_church_and_people that accepts six parameters: p_church_id of type NUMBER representing the unique identifier for a church, p_people_id of type NUMBER representing the unique identifier for a person, p_name of type VARCHAR2 representing the name of the person, p_country of type VARCHAR2 representing the country of the person, p_is_male of type VARCHAR2 indicating the gender of the person, and p_age of type NUMBER representing the age of the person. The procedure begins by declaring two local variables, v_church_exists and v_person_exists, both of type NUMBER, initialized to 0, to track the existence of records in the CHURCH and PEOPLE tables, respectively. It also declares v_church_open_date of type NUMBER to store the open date of a church. The procedure first checks the existence of a church record by selecting the count of records from the CHURCH table where CHURCH_ID matches p_church_id and stores the result in v_church_exists. If no church exists (v_church_exists equals 0), it inserts a new record into the CHURCH table with CHURCH_ID set to p_church_id, NAME set to 'New Church', ORGANIZED_BY set to 'System', OPEN_DATE set to 2023, and CONTINUATION_OF set to 'Independent'. If a church record exists, it retrieves the OPEN_DATE for the church with CHURCH_ID equal to p_church_id into v_church_open_date and checks if this date is earlier than 2000. If so, it updates the NAME column of the existing church record by appending ' (Historic)' to the current name. Next, the procedure checks the existence of a person record by selecting the count of records from the PEOPLE table where PEOPLE_ID matches p_people_id and stores the result in v_person_exists. If no person exists (v_person_exists equals 0), it inserts a new record into the PEOPLE table with PEOPLE_ID set to p_people_id, NAME set to p_name, COUNTRY set to p_country, IS_MALE set to p_is_male, and AGE set to p_age. If a person record exists, it checks if p_age is greater than 65; if true, it updates the AGE column of the existing person record to 65, otherwise, it updates the AGE column to p_age.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_church_and_people(\n    p_church_id NUMBER,\n    p_people_id NUMBER,\n    p_name VARCHAR2,\n    p_country VARCHAR2,\n    p_is_male VARCHAR2,\n    p_age NUMBER\n) IS\n    v_church_exists NUMBER := 0;\n    v_person_exists NUMBER := 0;\n    v_church_open_date NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_church_exists FROM CHURCH WHERE CHURCH_ID = p_church_id;\n    SELECT COUNT(*) INTO v_person_exists FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\n\n    IF v_church_exists = 0 THEN\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n        VALUES (p_church_id, 'New Church', 'System', 2023, 'Independent');\n    ELSE\n        SELECT OPEN_DATE INTO v_church_open_date FROM CHURCH WHERE CHURCH_ID = p_church_id;\n        IF v_church_open_date < 2000 THEN\n            UPDATE CHURCH SET NAME = NAME || ' (Historic)' WHERE CHURCH_ID = p_church_id;\n        END IF;\n    END IF;\n\n    IF v_person_exists = 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_people_id, p_name, p_country, p_is_male, p_age);\n    ELSE\n        IF p_age > 65 THEN\n            UPDATE PEOPLE SET AGE = 65 WHERE PEOPLE_ID = p_people_id;\n        ELSE\n            UPDATE PEOPLE SET AGE = p_age WHERE PEOPLE_ID = p_people_id;\n        END IF;\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  manage_church_and_people(100, 200, 'John Smith', 'United States', 'T', 40);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_church_and_people(1, 300, 'Jane Doe', 'Canada', 'F', 28);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_church_and_people(500, 2, 'Robert Brown', 'United Kingdom', 'T', 70);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_church_and_people(2, 400, 'Maria Garcia', 'Spain', 'F', 25);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_church_and_people(600, 600, 'New Person', 'Germany', 'T', 45);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named manage_church_and_people that accepts parameters for church ID, person ID, name, country, gender (IS_MALE), and age. It checks if a church with the given ID exists. If not, it inserts a new church with default values. If it exists and its OPEN_DATE is before 2000, it appends ' (Historic)' to the church name. It then checks if a person with the given ID exists. If not, it inserts a new person using the provided parameters. If the person exists, it updates their AGE to the provided value, capping it at 65 if the provided age is greater than 65.",
    "natural_language": "Create a stored procedure called manage_church_and_people that takes in some details like church ID, person ID, a name, a country, gender, and an age. It should see if a church with that ID is already there. If it's not, it puts in a new church with standard default info. If the church does exist and was opened quite a while back, before the year 2000, it adds a note like ' (Historic)' to the church's name. Then, it looks for a person with the given ID. If that person isn't found, it adds a new person record with the provided details. If the person already exists, it adjusts their age to the new value, but if the given age seems too high, it should just set it to a reasonable maximum like 65.",
    "id": 264
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_wedding that takes four input parameters: p_church_id of type NUMBER to identify a church, p_male_id of type NUMBER to identify a male person, p_female_id of type NUMBER to identify a female person, and p_year of type NUMBER to specify the wedding year. The procedure first declares four local NUMBER variables: v_wedding_exists, v_male_exists, v_female_exists, and v_church_exists, each initialized to zero. It then performs a series of existence checks by querying the CHURCH, PEOPLE, and WEDDING tables. Specifically, it executes a SELECT COUNT(*) query on the CHURCH table where the CHURCH_ID column equals the p_church_id parameter, storing the result in v_church_exists. It executes a SELECT COUNT(*) query on the PEOPLE table where the PEOPLE_ID column equals the p_male_id parameter, storing the result in v_male_exists. It executes another SELECT COUNT(*) query on the PEOPLE table where the PEOPLE_ID column equals the p_female_id parameter, storing the result in v_female_exists. It also executes a SELECT COUNT(*) query on the WEDDING table where the CHURCH_ID column equals p_church_id, the MALE_ID column equals p_male_id, and the FEMALE_ID column equals p_female_id, storing the result in v_wedding_exists. Following these checks, the procedure uses conditional logic: if v_church_exists is zero, it inserts a new row into the CHURCH table with CHURCH_ID set to p_church_id, NAME set to 'New Church', ORGANIZED_BY set to 'System', OPEN_DATE set to 2023, and CONTINUATION_OF set to 'Independent'. If v_male_exists is zero, it inserts a new row into the PEOPLE table with PEOPLE_ID set to p_male_id, NAME set to 'Unknown Male', COUNTRY set to 'Unknown', IS_MALE set to 'T', and AGE set to 30. If v_female_exists is zero, it inserts a new row into the PEOPLE table with PEOPLE_ID set to p_female_id, NAME set to 'Unknown Female', COUNTRY set to 'Unknown', IS_MALE set to 'F', and AGE set to 28. Finally, based on the WEDDING table check, if v_wedding_exists is zero, it inserts a new row into the WEDDING table with CHURCH_ID set to p_church_id, MALE_ID set to p_male_id, FEMALE_ID set to p_female_id, and YEAR set to p_year; otherwise, if a wedding record already exists (v_wedding_exists is not zero), it deletes the existing row from the WEDDING table where CHURCH_ID equals p_church_id, MALE_ID equals p_male_id, and FEMALE_ID equals p_female_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_wedding(\n    p_church_id NUMBER,\n    p_male_id NUMBER,\n    p_female_id NUMBER,\n    p_year NUMBER\n) IS\n    v_wedding_exists NUMBER := 0;\n    v_male_exists NUMBER := 0;\n    v_female_exists NUMBER := 0;\n    v_church_exists NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_church_exists FROM CHURCH WHERE CHURCH_ID = p_church_id;\n    SELECT COUNT(*) INTO v_male_exists FROM PEOPLE WHERE PEOPLE_ID = p_male_id;\n    SELECT COUNT(*) INTO v_female_exists FROM PEOPLE WHERE PEOPLE_ID = p_female_id;\n    SELECT COUNT(*) INTO v_wedding_exists FROM WEDDING WHERE CHURCH_ID = p_church_id AND MALE_ID = p_male_id AND FEMALE_ID = p_female_id;\n\n    IF v_church_exists = 0 THEN\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n        VALUES (p_church_id, 'New Church', 'System', 2023, 'Independent');\n    END IF;\n\n    IF v_male_exists = 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_male_id, 'Unknown Male', 'Unknown', 'T', 30);\n    END IF;\n\n    IF v_female_exists = 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_female_id, 'Unknown Female', 'Unknown', 'F', 28);\n    END IF;\n\n    IF v_wedding_exists = 0 THEN\n        INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n        VALUES (p_church_id, p_male_id, p_female_id, p_year);\n    ELSE\n        DELETE FROM WEDDING WHERE CHURCH_ID = p_church_id AND MALE_ID = p_male_id AND FEMALE_ID = p_female_id;\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  manage_wedding(1, 1, 2, 2023);\nEND;",
      "BEGIN\n  manage_wedding(2, 3, 4, 2024);\nEND;",
      "BEGIN\n  manage_wedding(3, 5, 6, 2025);\nEND;",
      "BEGIN\n  manage_wedding(1, 1, 2, 2023); -- This will delete the previously inserted wedding\nEND;",
      "BEGIN\n  manage_wedding(4, 7, 8, 2026);\nEND;"
    ],
    "summary": "Create a stored procedure named manage_wedding that accepts parameters for church ID, male person ID, female person ID, and wedding year. It checks for the existence of the church, the male person, the female person, and a wedding record linking them all. If any of the church, male, or female records do not exist, they are inserted with default values. If no wedding record exists, one is inserted with the given year. If a wedding record already exists, it is deleted.",
    "natural_language": "Alright, so we need a stored procedure called manage_wedding. It's gonna take in a church ID, a guy's ID, a gal's ID, and the year they got hitched. Here's the deal: first, it checks if that church, the dude, and the lady are already in the system. If any of 'em aren't there, we just add 'em with some basic info. Then, it looks to see if there's already a wedding record for this whole crew. If there isn't one, we pop in a new record with the wedding year. But if there's already a record for them, then we just wipe that entry out.",
    "id": 265
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_church_and_people that accepts four input parameters: a numeric parameter p_church_id, a numeric parameter p_people_id, a string parameter p_new_name, and a string parameter p_new_country. The procedure first declares three local numeric variables: v_church_exists, v_person_exists, and v_church_open_date. It then checks for the existence of a church by selecting the count of rows from the CHURCH table where the CHURCH_ID column equals the input parameter p_church_id, storing the result in v_church_exists. It also checks for the existence of a person by selecting the count of rows from the PEOPLE table where the PEOPLE_ID column equals the input parameter p_people_id, storing the result in v_person_exists. If the v_church_exists count is greater than zero, indicating the church exists, it proceeds to select the OPEN_DATE column value from the CHURCH table for that specific CHURCH_ID into the variable v_church_open_date. It then evaluates a condition on this date: if v_church_open_date is less than 2000, it updates the NAME column in the CHURCH table for that row, setting it to the concatenation of the input parameter p_new_name with the appended string ' (Historic)'; otherwise, if the date is 2000 or later, it updates the NAME column to just p_new_name. Following the church logic, the procedure then checks if the v_person_exists count is greater than zero. If a person exists, it updates the COUNTRY column in the PEOPLE table for the row with the matching PEOPLE_ID to the value of the input parameter p_new_country. If the person does not exist (v_person_exists is zero), it performs an insert into the PEOPLE table, specifying values for the columns PEOPLE_ID (using p_people_id), NAME (using the literal string 'New Person'), COUNTRY (using p_new_country), IS_MALE (using the literal string 'T'), and AGE (using the literal number 30).",
    "plsql": "CREATE OR REPLACE PROCEDURE update_church_and_people(\n    p_church_id NUMBER,\n    p_people_id NUMBER,\n    p_new_name VARCHAR2,\n    p_new_country VARCHAR2\n) IS\n    v_church_exists NUMBER := 0;\n    v_person_exists NUMBER := 0;\n    v_church_open_date NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_church_exists FROM CHURCH WHERE CHURCH_ID = p_church_id;\n    SELECT COUNT(*) INTO v_person_exists FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\n\n    IF v_church_exists > 0 THEN\n        SELECT OPEN_DATE INTO v_church_open_date FROM CHURCH WHERE CHURCH_ID = p_church_id;\n        IF v_church_open_date < 2000 THEN\n            UPDATE CHURCH SET NAME = p_new_name || ' (Historic)' WHERE CHURCH_ID = p_church_id;\n        ELSE\n            UPDATE CHURCH SET NAME = p_new_name WHERE CHURCH_ID = p_church_id;\n        END IF;\n    END IF;\n\n    IF v_person_exists > 0 THEN\n        UPDATE PEOPLE SET COUNTRY = p_new_country WHERE PEOPLE_ID = p_people_id;\n    ELSE\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_people_id, 'New Person', p_new_country, 'T', 30);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  update_church_and_people(p_church_id => 1, p_people_id => 1, p_new_name => 'New Pure Church', p_new_country => 'Canada');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 2, p_people_id => 2, p_new_name => 'Modern Independent Church', p_new_country => 'Sweden');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 3, p_people_id => 3, p_new_name => 'Reformed Church of Christ', p_new_country => 'United States');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 1, p_people_id => 10, p_new_name => 'Historic Pure Church', p_new_country => 'Germany');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 99, p_people_id => 11, p_new_name => 'Non-existent Church', p_new_country => 'France');\nEND;"
    ],
    "summary": "Create a stored procedure named update_church_and_people that accepts church_id, people_id, new_name, and new_country as parameters. Check if the specified church exists. If it exists, update its name: append ' (Historic)' if its open date is before 2000, otherwise use the new name as-is. Then, check if the specified person exists. If the person exists, update their country. If the person does not exist, insert a new person record with the provided ID, a default name of 'New Person', the provided country, a default gender of 'T', and a default age of 30.",
    "natural_language": "Alright, so we need a stored procedure called update_church_and_people. It's gonna take church_id, people_id, new_name, and new_country as its inputs. First off, you gotta see if that church ID actually points to a real church. If it does, then update its name: but here's the catchif the church opened before the year 2000, tack on ' (Historic)' to the new name; otherwise, just slap the new name on there as given. Next, check if the person with that people_id exists. If they're in the system, just update their country to the new one. If they're not there at all, go ahead and add a new person record. For that new entry, use the provided ID, set the name to 'New Person' by default, use the given country, and just throw in 'T' for gender and 30 for age as the defaults.",
    "id": 266
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `manage_people_and_wedding` that accepts three input parameters: `p_people_id` of type `NUMBER`, representing a person's unique identifier; `p_church_id` of type `NUMBER`, representing a church's unique identifier; and `p_year` of type `NUMBER`, representing a specific year. The procedure begins by declaring three local variables: `v_person_exists` of type `NUMBER`, initialized to 0, to store the count of existing people; `v_wedding_count` of type `NUMBER`, initialized to 0, to store the count of weddings associated with the given person; and `v_church_exists` of type `NUMBER`, initialized to 0, to store the count of existing churches.\n\nThe procedure first executes a `SELECT COUNT(*)` statement to determine if a person with `PEOPLE_ID` equal to the value of `p_people_id` exists in the `PEOPLE` table, storing the result in `v_person_exists`. Next, it executes another `SELECT COUNT(*)` statement to determine if a church with `CHURCH_ID` equal to the value of `p_church_id` exists in the `CHURCH` table, storing the result in `v_church_exists`. Subsequently, it executes a third `SELECT COUNT(*)` statement to determine the number of weddings where either `MALE_ID` or `FEMALE_ID` is equal to the value of `p_people_id` in the `WEDDING` table, storing this count in `v_wedding_count`.\n\nFollowing these initial checks, the procedure enters a conditional block. If `v_person_exists` is equal to 0 (meaning the person does not exist), it executes an `INSERT` statement to add a new record into the `PEOPLE` table. This new record will have `PEOPLE_ID` set to `p_people_id`, `NAME` set to the literal string 'New Person', `COUNTRY` set to the literal string 'Unknown', `IS_MALE` set to the literal string 'T', and `AGE` set to the literal number 30.\n\nIf `v_person_exists` is not equal to 0 (meaning the person already exists), the procedure enters a nested conditional block. Inside this block, if `v_wedding_count` is equal to 0 (meaning the existing person is not associated with any wedding), it executes a `DELETE` statement to remove the record from the `PEOPLE` table where `PEOPLE_ID` is equal to `p_people_id`. Otherwise (if `v_wedding_count` is not equal to 0, meaning the existing person is associated with at least one wedding), it executes an `UPDATE` statement on the `PEOPLE` table, incrementing the `AGE` column by 1 for the record where `PEOPLE_ID` is equal to `p_people_id`.\n\nAfter handling the person-related logic, the procedure proceeds to another independent conditional block. If `v_church_exists` is equal to 0 (meaning the church does not exist), it executes an `INSERT` statement to add a new record into the `CHURCH` table. This new record will have `CHURCH_ID` set to `p_church_id`, `NAME` set to the literal string 'New Church', `ORGANIZED_BY` set to the literal string 'System', `OPEN_DATE` set to the literal number 2023, and `CONTINUATION_OF` set to the literal string 'Independent'.\n\nFinally, the procedure enters a third independent conditional block. If `v_wedding_count` is equal to 0 (meaning the person is not associated with any wedding), it executes an `INSERT` statement to add a new record into the `WEDDING` table. This new record will have `CHURCH_ID` set to `p_church_id`, `MALE_ID` set to `p_people_id`, `FEMALE_ID` set to `p_people_id + 1`, and `YEAR` set to `p_year`.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_people_and_wedding(\n    p_people_id NUMBER,\n    p_church_id NUMBER,\n    p_year NUMBER\n) IS\n    v_person_exists NUMBER := 0;\n    v_wedding_count NUMBER := 0;\n    v_church_exists NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_person_exists FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\n    SELECT COUNT(*) INTO v_church_exists FROM CHURCH WHERE CHURCH_ID = p_church_id;\n    SELECT COUNT(*) INTO v_wedding_count FROM WEDDING WHERE MALE_ID = p_people_id OR FEMALE_ID = p_people_id;\n\n    IF v_person_exists = 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_people_id, 'New Person', 'Unknown', 'T', 30);\n    ELSE\n        IF v_wedding_count = 0 THEN\n            DELETE FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\n        ELSE\n            UPDATE PEOPLE SET AGE = AGE + 1 WHERE PEOPLE_ID = p_people_id;\n        END IF;\n    END IF;\n\n    IF v_church_exists = 0 THEN\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n        VALUES (p_church_id, 'New Church', 'System', 2023, 'Independent');\n    END IF;\n\n    IF v_wedding_count = 0 THEN\n        INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n        VALUES (p_church_id, p_people_id, p_people_id + 1, p_year);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  manage_people_and_wedding(1, 1, 2023);\n  commit;\nEND;",
      "BEGIN\n  manage_people_and_wedding(2, 2, 2023);\n  commit;\nEND;",
      "BEGIN\n  manage_people_and_wedding(3, 3, 2023);\n  commit;\nEND;",
      "BEGIN\n  manage_people_and_wedding(4, 4, 2023);\n  commit;\nEND;",
      "BEGIN\n  manage_people_and_wedding(5, 5, 2023);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named manage_people_and_wedding that accepts people_id, church_id, and a year as parameters. First, check for the existence of the person, church, and any weddings associated with the person. If the person does not exist, insert a new default person record. If the person exists but has no associated weddings, delete that person. If the person exists and has associated weddings, increment their age by 1. If the church does not exist, insert a new default church record. Finally, if the person has no associated weddings, insert a new wedding record linking the person and church with the provided year.",
    "natural_language": "Create a stored procedure called manage_people_and_wedding that takes a few IDs and a year as inputs. First, look into whether the person, the church, and any related wedding records are around. If the person isn't found, add a basic person entry. If the person exists but doesn't seem to have any weddings linked to them, remove that person's record. If the person is there and has some weddings, bump their age up a bit. If the church isn't in the system, put in a simple church record. Lastly, if the person doesn't have any wedding ties, add a new wedding record to connect them with the church for the given year.",
    "id": 267
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_wedding_and_people that accepts four parameters: p_church_id of type NUMBER representing the church's unique identifier, p_male_id of type NUMBER representing the unique identifier of the male person, p_female_id of type NUMBER representing the unique identifier of the female person, and p_year of type NUMBER representing the year of the wedding. The procedure begins by declaring three local variables: v_wedding_exists, v_male_exists, and v_female_exists, all of type NUMBER, initialized to 0, to track the existence of records in the database. It first checks if a male person with the given p_male_id exists in the PEOPLE table by selecting the count of records where PEOPLE_ID equals p_male_id and storing the result in v_male_exists. Similarly, it checks for the existence of a female person with the given p_female_id in the PEOPLE table, storing the count in v_female_exists. It then checks if a wedding record exists in the WEDDING table with the specified p_church_id, p_male_id, and p_female_id, storing the count in v_wedding_exists. If v_male_exists is 0, indicating the male person does not exist, it inserts a new record into the PEOPLE table with PEOPLE_ID set to p_male_id, NAME set to 'Unknown Male', COUNTRY set to 'Unknown', IS_MALE set to 'T', and AGE set to 30. If v_female_exists is 0, indicating the female person does not exist, it inserts a new record into the PEOPLE table with PEOPLE_ID set to p_female_id, NAME set to 'Unknown Female', COUNTRY set to 'Unknown', IS_MALE set to 'F', and AGE set to 28. If v_wedding_exists is 0, indicating the wedding record does not exist, it inserts a new record into the WEDDING table with CHURCH_ID set to p_church_id, MALE_ID set to p_male_id, FEMALE_ID set to p_female_id, and YEAR set to p_year. If v_wedding_exists is not 0, indicating the wedding record already exists, it updates the existing record in the WEDDING table by setting the YEAR column to p_year for the row where CHURCH_ID equals p_church_id, MALE_ID equals p_male_id, and FEMALE_ID equals p_female_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_wedding_and_people(\n    p_church_id NUMBER,\n    p_male_id NUMBER,\n    p_female_id NUMBER,\n    p_year NUMBER\n) IS\n    v_wedding_exists NUMBER := 0;\n    v_male_exists NUMBER := 0;\n    v_female_exists NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_male_exists FROM PEOPLE WHERE PEOPLE_ID = p_male_id;\n    SELECT COUNT(*) INTO v_female_exists FROM PEOPLE WHERE PEOPLE_ID = p_female_id;\n    SELECT COUNT(*) INTO v_wedding_exists FROM WEDDING WHERE CHURCH_ID = p_church_id AND MALE_ID = p_male_id AND FEMALE_ID = p_female_id;\n\n    IF v_male_exists = 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_male_id, 'Unknown Male', 'Unknown', 'T', 30);\n    END IF;\n\n    IF v_female_exists = 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_female_id, 'Unknown Female', 'Unknown', 'F', 28);\n    END IF;\n\n    IF v_wedding_exists = 0 THEN\n        INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n        VALUES (p_church_id, p_male_id, p_female_id, p_year);\n    ELSE\n        UPDATE WEDDING SET YEAR = p_year WHERE CHURCH_ID = p_church_id AND MALE_ID = p_male_id AND FEMALE_ID = p_female_id;\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  update_wedding_and_people(1, 100, 101, 2023);\n  COMMIT;\nEND;",
      "BEGIN\n  update_wedding_and_people(2, 102, 103, 2022);\n  COMMIT;\nEND;",
      "BEGIN\n  update_wedding_and_people(3, 104, 105, 2024);\n  COMMIT;\nEND;",
      "BEGIN\n  update_wedding_and_people(1, 1, 2, 2015);\n  COMMIT;\nEND;",
      "BEGIN\n  update_wedding_and_people(5, 3, 4, 2016);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_wedding_and_people that accepts church_id, male_id, female_id, and a year as parameters. Check for the existence of the male person, female person, and the specified wedding. If the male person does not exist, insert a default male record. If the female person does not exist, insert a default female record. If the wedding does not exist, insert a new wedding record with the provided details. If the wedding already exists, update its year to the provided value.",
    "natural_language": "Alright, so we need a stored procedure called update_wedding_and_people. It's gonna take a church ID, a guy's ID, a gal's ID, and a year. First off, we gotta check if the guy, the gal, and their wedding are actually in the system. If the dude's not there, just pop in a default male entry. Same deal for the ladyif she's missing, add a default female record. Now, for the wedding itself: if it doesn't exist yet, create a new one with all the details we've got. But if it's already there, just update the year to the new one we're passing in.",
    "id": 268
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named categorize_mountain_photos that takes no parameters and begins by declaring local variables v_lens_count, v_photo_count, v_height_avg, v_prominence_sign, and v_category. It first queries the CAMERA_LENS table to count all rows and stores the result in v_lens_count. It then calculates the average value of the height column from the MOUNTAIN table and stores it in v_height_avg. The procedure then enters a loop that iterates over a result set from a query that performs a LEFT JOIN between the MOUNTAIN table (aliased as m) and the PHOTOS table (aliased as p) on the condition that m.id equals p.mountain_id; this query groups the results by m.id, m.height, and m.prominence, and for each group, it selects the mountain's id, height, prominence, and a count of associated photo rows (using COUNT(p.id)) which is aliased as photo_cnt. For each record (rec) in this loop, it calculates v_prominence_sign by using the SIGN function on the expression (rec.prominence - 1000), which returns 1 if prominence is greater than 1000, 0 if equal to 1000, or -1 if less than 1000. It then uses a series of IF and ELSIF conditional statements to assign a value to v_category based on comparing rec.height to the pre-calculated v_height_avg and the value of v_prominence_sign: if height is greater than the average and the sign is 1, v_category is set to 'HIGH_DOMINANT'; if height is greater than average and sign is 0, it is 'HIGH_EQUAL'; if height is greater than average and sign is -1, it is 'HIGH_SUBDOMINANT'; if height is less than or equal to the average and sign is 1, it is 'LOW_DOMINANT'; if height is less than or equal to the average and sign is 0, it is 'LOW_EQUAL'; if height is less than or equal to the average and sign is -1, it is 'LOW_SUBDOMINANT'. Following this categorization, another conditional block checks the value of rec.photo_cnt: if it equals 0, the procedure performs an INSERT into the PHOTOS table, specifying columns id, camera_lens_id, mountain_id, color, and name; the id value is determined by a subquery that selects the maximum existing id from the PHOTOS table (or 0 if the maximum is null using the NVL function) and adds 1; the camera_lens_id is calculated as MOD(rec.id, v_lens_count) + 1; the mountain_id is rec.id; the color is set to 'RGB'; and the name is set to the concatenation of v_category and the string '_AUTO'. If rec.photo_cnt equals 1, the procedure executes an UPDATE on the PHOTOS table, setting the color column to 'BGR' for the first row (using the condition ROWNUM = 1) where the mountain_id equals rec.id. If rec.photo_cnt is any other value (i.e., greater than 1), the procedure executes a DELETE from the PHOTOS table where the mountain_id equals rec.id and the id is in the result of a subquery that selects the single highest id (by ordering by id in descending order and using FETCH FIRST 1 ROWS ONLY) from PHOTOS for that specific mountain_id. The loop continues until all grouped mountain records from the initial query are processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE categorize_mountain_photos\nIS\n   v_lens_count NUMBER;\n   v_photo_count NUMBER;\n   v_height_avg NUMBER;\n   v_prominence_sign NUMBER;\n   v_category VARCHAR2(50);\nBEGIN\n   SELECT COUNT(*) INTO v_lens_count FROM CAMERA_LENS;\n   SELECT AVG(height) INTO v_height_avg FROM MOUNTAIN;\n   FOR rec IN (SELECT m.id, m.height, m.prominence, COUNT(p.id) as photo_cnt FROM MOUNTAIN m LEFT JOIN PHOTOS p ON m.id = p.mountain_id GROUP BY m.id, m.height, m.prominence) LOOP\n      v_prominence_sign := SIGN(rec.prominence - 1000);\n      IF rec.height > v_height_avg AND v_prominence_sign = 1 THEN\n         v_category := 'HIGH_DOMINANT';\n      ELSIF rec.height > v_height_avg AND v_prominence_sign = 0 THEN\n         v_category := 'HIGH_EQUAL';\n      ELSIF rec.height > v_height_avg AND v_prominence_sign = -1 THEN\n         v_category := 'HIGH_SUBDOMINANT';\n      ELSIF rec.height <= v_height_avg AND v_prominence_sign = 1 THEN\n         v_category := 'LOW_DOMINANT';\n      ELSIF rec.height <= v_height_avg AND v_prominence_sign = 0 THEN\n         v_category := 'LOW_EQUAL';\n      ELSIF rec.height <= v_height_avg AND v_prominence_sign = -1 THEN\n         v_category := 'LOW_SUBDOMINANT';\n      END IF;\n      IF rec.photo_cnt = 0 THEN\n         INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), MOD(rec.id, v_lens_count) + 1, rec.id, 'RGB', v_category || '_AUTO');\n      ELSIF rec.photo_cnt = 1 THEN\n         UPDATE PHOTOS SET color = 'BGR' WHERE mountain_id = rec.id AND ROWNUM = 1;\n      ELSE\n         DELETE FROM PHOTOS WHERE mountain_id = rec.id AND id IN (SELECT id FROM PHOTOS WHERE mountain_id = rec.id ORDER BY id DESC FETCH FIRST 1 ROWS ONLY);\n      END IF;\n   END LOOP;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  categorize_mountain_photos;\nEND;"
    ],
    "summary": "Create a stored procedure named categorize_mountain_photos with no parameters. Count the total camera lenses and calculate the average mountain height. For each mountain (including its photo count from a left join), determine a category based on its height relative to the average and its prominence relative to 1000. If the mountain has no photos, insert a new photo with an auto-generated name based on the category. If it has exactly one photo, update that photo's color to 'BGR'. If it has more than one photo, delete the photo with the highest ID for that mountain.",
    "natural_language": "Create procedure categorize_mountain_photos. Count lenses, get average height. For each mountain: if no photos, insert one with category-based name. If one photo, set its color to 'BGR'. If multiple, delete the highest ID photo. Categorize by height vs average and prominence vs 1000.",
    "id": 269
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_lens_mountain_combinations that does not take any parameters and is designed to process combinations of camera lenses and mountains. The procedure begins by declaring several local variables: v_focal_length of type NUMBER to store the focal length of a camera lens, v_height_sign of type NUMBER to store the sign of the mountain height relative to 3500 meters, v_range_match of type BOOLEAN to determine if the mountain's range contains the word 'Mountains', v_brand_prefix of type VARCHAR2(10) to store a prefix based on the lens and mountain characteristics, and v_counter of type NUMBER initialized to 0 to count the number of processed combinations. The procedure uses a nested loop structure to iterate over records from two tables: CAMERA_LENS and MOUNTAIN. The outer loop retrieves records from CAMERA_LENS where the focal_length_mm column is not NULL, selecting the id, brand, and focal_length_mm columns. The inner loop retrieves records from MOUNTAIN where the height column is not NULL, selecting the id, height, prominence, and range columns. Within the inner loop, the procedure calculates v_height_sign using the SIGN function to determine if the mountain's height is above, equal to, or below 3500 meters. It assigns the focal length of the current lens record to v_focal_length. Based on the values of v_height_sign and v_focal_length, the procedure sets v_brand_prefix to one of six possible values: 'WIDE_HIGH', 'TELE_HIGH', 'WIDE_MID', 'TELE_MID', 'WIDE_LOW', or 'TELE_LOW'. The procedure then evaluates v_range_match by checking if the mountain's range contains the substring 'Mountains' using the LIKE operator. Depending on the value of v_range_match, the procedure inserts a new record into the PHOTOS table with the columns id, camera_lens_id, mountain_id, color, and name. The id is determined by selecting the maximum id from PHOTOS and adding 1, or using 1 if no records exist. The camera_lens_id and mountain_id are set to the current lens and mountain record ids, respectively. The color is set to 'GRB' if v_range_match is TRUE, otherwise 'RBG'. The name is constructed by concatenating v_brand_prefix with either '_MOUNTAIN' or '_OTHER' based on v_range_match. After each insertion, v_counter is incremented by 1, and if v_counter reaches 10, the procedure exits both loops. After processing the combinations, the procedure deletes records from the PHOTOS table where the mountain_id corresponds to a mountain with prominence less than 1000, using a subquery to select such mountain ids from the MOUNTAIN table.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_lens_mountain_combinations\nIS\n   v_focal_length NUMBER;\n   v_height_sign NUMBER;\n   v_range_match BOOLEAN;\n   v_brand_prefix VARCHAR2(10);\n   v_counter NUMBER := 0;\nBEGIN\n   FOR lens_rec IN (SELECT id, brand, focal_length_mm FROM CAMERA_LENS WHERE focal_length_mm IS NOT NULL) LOOP\n      FOR mountain_rec IN (SELECT id, height, prominence, range FROM MOUNTAIN WHERE height IS NOT NULL) LOOP\n         v_height_sign := SIGN(mountain_rec.height - 3500);\n         v_focal_length := lens_rec.focal_length_mm;\n         IF v_height_sign = 1 AND v_focal_length < 20 THEN\n            v_brand_prefix := 'WIDE_HIGH';\n         ELSIF v_height_sign = 1 AND v_focal_length >= 20 THEN\n            v_brand_prefix := 'TELE_HIGH';\n         ELSIF v_height_sign = 0 AND v_focal_length < 20 THEN\n            v_brand_prefix := 'WIDE_MID';\n         ELSIF v_height_sign = 0 AND v_focal_length >= 20 THEN\n            v_brand_prefix := 'TELE_MID';\n         ELSIF v_height_sign = -1 AND v_focal_length < 20 THEN\n            v_brand_prefix := 'WIDE_LOW';\n         ELSIF v_height_sign = -1 AND v_focal_length >= 20 THEN\n            v_brand_prefix := 'TELE_LOW';\n         END IF;\n         v_range_match := mountain_rec.range LIKE '%Mountains%';\n         IF v_range_match THEN\n            INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), lens_rec.id, mountain_rec.id, 'GRB', v_brand_prefix || '_MOUNTAIN');\n         ELSE\n            INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), lens_rec.id, mountain_rec.id, 'RBG', v_brand_prefix || '_OTHER');\n         END IF;\n         v_counter := v_counter + 1;\n         IF v_counter >= 10 THEN\n            EXIT;\n         END IF;\n      END LOOP;\n      IF v_counter >= 10 THEN\n         EXIT;\n      END IF;\n   END LOOP;\n   DELETE FROM PHOTOS WHERE mountain_id IN (SELECT id FROM MOUNTAIN WHERE prominence < 1000);\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  process_lens_mountain_combinations;\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named process_lens_mountain_combinations with no parameters. For each camera lens with a focal length and each mountain with a height, generate a brand prefix based on the focal length and whether the height is above, at, or below 3500 meters. Check if the mountain's range contains 'Mountains'. Insert a new photo record using the lens and mountain IDs, with a color and name determined by the range check and the brand prefix. Stop processing after inserting 10 photos. Finally, delete all photos associated with mountains that have a prominence less than 1000.",
    "natural_language": "Make a procedure 'process_lens_mountain_combinations'. For each lens and mountain, set a brand prefix from focal length and if height is above, at, or below 3500m. If mountain range has 'Mountains', insert a photo using lens and mountain IDs, with color and name from range check and prefix. Stop after 10 inserts. Then delete photos for mountains with prominence under 1000.",
    "id": 270
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named analyze_equipment_performance that does not take any parameters and performs several operations involving the MOUNTAIN and CAMERA_LENS tables. The procedure begins by declaring several local variables: v_max_height, v_min_prominence, v_height_diff_sign, v_performance_score, and v_action_flag, all of which are of type NUMBER. It then retrieves the maximum value of the height column from the MOUNTAIN table and stores it in the v_max_height variable. Similarly, it retrieves the minimum value of the prominence column from the MOUNTAIN table and stores it in the v_min_prominence variable. The procedure then enters a nested loop structure. The outer loop iterates over each record in the CAMERA_LENS table, selecting the id, brand, focal_length_mm, and max_aperture columns. For each lens record, the inner loop iterates over each record in the MOUNTAIN table where the country column contains the letter 'a', selecting the id, height, and prominence columns. Within the inner loop, the procedure calculates the v_height_diff_sign as the sign of the difference between the current mountain's height and half of v_max_height. It also calculates the v_performance_score as the product of the mountain's height divided by 1000 and the lens's focal_length_mm divided by 10. Based on the values of v_height_diff_sign and v_performance_score, the procedure sets the v_action_flag to a value between 1 and 6 using a series of conditional statements. Depending on the value of v_action_flag, the procedure performs different actions using a CASE statement: if v_action_flag is 1, it inserts a new row into the PHOTOS table with a color of 'PERF_HIGH' and a name of 'OPTIMAL'; if v_action_flag is 2, it inserts a new row with a color of 'PERF_MID' and a name of 'AVERAGE'; if v_action_flag is 3, it updates the name column in the PHOTOS table to 'UPDATED_' concatenated with the mountain's id for rows matching the current mountain and lens ids; if v_action_flag is 4, it deletes rows from the PHOTOS table matching the current mountain and lens ids; if v_action_flag is 5, it inserts a new row with a color of 'PERF_LOW' and a name of 'MINIMAL'; if v_action_flag is 6, it updates the color column in the PHOTOS table to 'ADJUSTED' for rows matching the current mountain id. After completing the nested loops, the procedure deletes rows from the PHOTOS table where the mountain_id corresponds to mountains with a prominence less than twice the value of v_min_prominence.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_equipment_performance\nIS\n   v_max_height NUMBER;\n   v_min_prominence NUMBER;\n   v_height_diff_sign NUMBER;\n   v_performance_score NUMBER;\n   v_action_flag NUMBER;\nBEGIN\n   SELECT MAX(height) INTO v_max_height FROM MOUNTAIN;\n   SELECT MIN(prominence) INTO v_min_prominence FROM MOUNTAIN;\n   FOR lens_rec IN (SELECT id, brand, focal_length_mm, max_aperture FROM CAMERA_LENS) LOOP\n      FOR mountain_rec IN (SELECT id, height, prominence FROM MOUNTAIN WHERE country LIKE '%a%') LOOP\n         v_height_diff_sign := SIGN(mountain_rec.height - (v_max_height / 2));\n         v_performance_score := (mountain_rec.height / 1000) * (lens_rec.focal_length_mm / 10);\n         IF v_height_diff_sign = 1 AND v_performance_score > 20 THEN\n            v_action_flag := 1;\n         ELSIF v_height_diff_sign = 1 AND v_performance_score <= 20 THEN\n            v_action_flag := 2;\n         ELSIF v_height_diff_sign = 0 AND v_performance_score > 20 THEN\n            v_action_flag := 3;\n         ELSIF v_height_diff_sign = 0 AND v_performance_score <= 20 THEN\n            v_action_flag := 4;\n         ELSIF v_height_diff_sign = -1 AND v_performance_score > 20 THEN\n            v_action_flag := 5;\n         ELSIF v_height_diff_sign = -1 AND v_performance_score <= 20 THEN\n            v_action_flag := 6;\n         END IF;\n         CASE v_action_flag\n            WHEN 1 THEN INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), lens_rec.id, mountain_rec.id, 'PERF_HIGH', 'OPTIMAL');\n            WHEN 2 THEN INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), lens_rec.id, mountain_rec.id, 'PERF_MID', 'AVERAGE');\n            WHEN 3 THEN UPDATE PHOTOS SET name = 'UPDATED_' || mountain_rec.id WHERE mountain_id = mountain_rec.id AND camera_lens_id = lens_rec.id;\n            WHEN 4 THEN DELETE FROM PHOTOS WHERE mountain_id = mountain_rec.id AND camera_lens_id = lens_rec.id;\n            WHEN 5 THEN INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), lens_rec.id, mountain_rec.id, 'PERF_LOW', 'MINIMAL');\n            WHEN 6 THEN UPDATE PHOTOS SET color = 'ADJUSTED' WHERE mountain_id = mountain_rec.id;\n         END CASE;\n      END LOOP;\n   END LOOP;\n   DELETE FROM PHOTOS WHERE mountain_id IN (SELECT id FROM MOUNTAIN WHERE prominence < v_min_prominence * 2);\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  analyze_equipment_performance;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named analyze_equipment_performance with no parameters. Declare numeric variables for max height, min prominence, height difference sign, performance score, and action flag. Find the maximum height and minimum prominence from the MOUNTAIN table. Loop through all CAMERA_LENS records. For each lens, loop through MOUNTAIN records where the country contains 'a'. Calculate a height difference sign and a performance score. Based on these values, set an action flag (1-6). Use a CASE statement to perform different PHOTOS table operations (INSERT, UPDATE, DELETE) depending on the flag value. After the loops, delete from PHOTOS where the associated mountain's prominence is less than twice the minimum prominence.",
    "natural_language": "Create procedure analyze_equipment_performance. Declare numeric vars: max_height, min_prominence, diff_sign, score, flag. Get max height and min prominence from MOUNTAIN. For each CAMERA_LENS, loop mountains where country has 'a'. Calculate diff_sign and score. Set flag (1-6) via CASE. Based on flag, INSERT, UPDATE, or DELETE in PHOTOS. Finally, delete PHOTOS where mountain prominence < 2 * min_prominence.",
    "id": 271
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_photo_inventory that initializes several local variables: v_lens_total, v_mountain_total, v_height_status, v_focal_status, and v_decision_point, all of type NUMBER. The procedure begins by selecting the total count of rows from the CAMERA_LENS table into v_lens_total and the total count of rows from the MOUNTAIN table into v_mountain_total. It then enters a loop that iterates from 1 to the lesser of v_lens_total and v_mountain_total. Within each iteration, it attempts to select the SIGN of the difference between the height column value and 4000 from the MOUNTAIN table where the id matches the current loop index i, storing the result in v_height_status; if no data is found, v_height_status is set to 0. Similarly, it attempts to select the SIGN of the difference between the focal_length_mm column value and 25 from the CAMERA_LENS table where the id matches i, storing the result in v_focal_status; if no data is found, v_focal_status is set to 0. The procedure calculates v_decision_point as the sum of three times v_height_status, v_focal_status, and 4. Based on the value of v_decision_point, it performs different operations on the PHOTOS table: inserting new rows with specific values, updating existing rows to change the color or name, or deleting rows based on conditions involving camera_lens_id and mountain_id. After the loop, the procedure iterates over a query result that groups PHOTOS by mountain_id and counts the number of photos per mountain_id, deleting the earliest photo for any mountain_id with more than three photos.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_photo_inventory\nIS\n   v_lens_total NUMBER;\n   v_mountain_total NUMBER;\n   v_height_status NUMBER;\n   v_focal_status NUMBER;\n   v_decision_point NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_lens_total FROM CAMERA_LENS;\n   SELECT COUNT(*) INTO v_mountain_total FROM MOUNTAIN;\n   FOR i IN 1..LEAST(v_lens_total, v_mountain_total) LOOP\n      BEGIN\n         SELECT SIGN(height - 4000) INTO v_height_status FROM MOUNTAIN WHERE id = i;\n      EXCEPTION\n         WHEN NO_DATA_FOUND THEN\n            v_height_status := 0;\n      END;\n      \n      BEGIN\n         SELECT SIGN(focal_length_mm - 25) INTO v_focal_status FROM CAMERA_LENS WHERE id = i;\n      EXCEPTION\n         WHEN NO_DATA_FOUND THEN\n            v_focal_status := 0;\n      END;\n      \n      v_decision_point := v_height_status * 3 + v_focal_status + 4;\n      IF v_decision_point = 1 THEN\n         INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), i, i, 'COMBO_1', 'PAIR_' || i);\n      ELSIF v_decision_point = 2 THEN\n         UPDATE PHOTOS SET color = 'UPDATED_1' WHERE camera_lens_id = i OR mountain_id = i;\n      ELSIF v_decision_point = 3 THEN\n         DELETE FROM PHOTOS WHERE camera_lens_id = i AND mountain_id = i;\n      ELSIF v_decision_point = 4 THEN\n         INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), i, i, 'COMBO_2', 'DUAL_' || i);\n      ELSIF v_decision_point = 5 THEN\n         UPDATE PHOTOS SET name = 'MODIFIED_' || i WHERE camera_lens_id = i;\n      ELSIF v_decision_point = 6 THEN\n         DELETE FROM PHOTOS WHERE mountain_id = i;\n      ELSIF v_decision_point = 7 THEN\n         INSERT INTO PHOTOS (id, camera_lens_id, mountain_id, color, name) VALUES ((SELECT NVL(MAX(id), 0) + 1 FROM PHOTOS), i, i, 'COMBO_3', 'TRIPLE_' || i);\n      ELSIF v_decision_point = 8 THEN\n         UPDATE PHOTOS SET color = 'FINAL', name = 'COMPLETED' WHERE camera_lens_id = i AND mountain_id = i;\n      ELSE\n         DELETE FROM PHOTOS WHERE id IN (SELECT id FROM PHOTOS WHERE camera_lens_id = i OR mountain_id = i ORDER BY id FETCH FIRST 1 ROWS ONLY);\n      END IF;\n   END LOOP;\n   FOR rec IN (SELECT mountain_id, COUNT(*) as photo_count FROM PHOTOS GROUP BY mountain_id HAVING COUNT(*) > 3) LOOP\n      DELETE FROM PHOTOS WHERE mountain_id = rec.mountain_id AND id IN (SELECT id FROM PHOTOS WHERE mountain_id = rec.mountain_id ORDER BY id FETCH FIRST 1 ROWS ONLY);\n   END LOOP;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  manage_photo_inventory;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named manage_photo_inventory with no parameters. Declare numeric variables for lens count, mountain count, height status, focal status, and decision point. Get the total counts from CAMERA_LENS and MOUNTAIN tables. Loop from 1 to the smaller of the two counts. For each index, get the SIGN of (mountain height - 4000) and the SIGN of (lens focal length - 25), defaulting to 0 if no row is found. Calculate a decision point as (3 * height status + focal status + 4). Based on the decision point, perform INSERT, UPDATE, or DELETE operations on the PHOTOS table. After the loop, for any mountain with more than three photos in the PHOTOS table, delete the earliest photo for that mountain.",
    "natural_language": "Create a stored procedure to handle photo inventory. Start by setting up some numeric variables for things like how many lenses and mountains we have, along with a couple of status indicators and a decision score. First, find out roughly how many items are in the lens and mountain tables. Then, go through a loop for a bunch of times, maybe around the smaller of those two counts. For each step, check if a mountain is pretty tall or if a lens has a certain focal length, and assign simple status codes, using zero if nothing matches. Combine these statuses into a single decision score using a basic formula. Depending on what that score turns out to be, do something to the photos tablelike adding a new entry, changing an existing one, or removing one. Finally, look for any mountains that have a lot of photos associated with them and get rid of the oldest one for those mountains.",
    "id": 272
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named p_delete_old_missions that accepts three input parameters: a string parameter p_fate_pattern, a string parameter p_location_filter, and a numeric parameter p_archive_year, and performs a delete operation on the MISSION table, specifically removing all rows where the FATE column contains the substring specified by p_fate_pattern anywhere within its value, and the LOCATION column exactly matches the value of p_location_filter, and the LAUNCHED_YEAR column holds a value that is strictly less than the value provided in p_archive_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_delete_old_missions (\n    p_fate_pattern IN VARCHAR2,\n    p_location_filter IN VARCHAR2,\n    p_archive_year IN NUMBER\n)\nIS\nBEGIN\n    DELETE FROM MISSION\n    WHERE FATE LIKE '%' || p_fate_pattern || '%'\n    AND LOCATION = p_location_filter\n    AND LAUNCHED_YEAR < p_archive_year;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "BEGIN\n  p_delete_old_missions('Decommissioned', 'Germany', 1940);\n  COMMIT;\nEND;",
      "BEGIN\n  p_delete_old_missions('Retired', 'Norway', 1930);\n  COMMIT;\nEND;",
      "BEGIN\n  p_delete_old_missions('Lost', 'United Kingdom', 1920);\n  COMMIT;\nEND;",
      "BEGIN\n  p_delete_old_missions('Scrapped', 'France', 1955);\n  COMMIT;\nEND;",
      "BEGIN\n  p_delete_old_missions('Sold', 'Japan', 1910);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named p_delete_old_missions with three parameters: a fate pattern string, a location filter string, and an archive year number. Delete rows from the MISSION table where the FATE column contains the fate pattern, the LOCATION column exactly matches the location filter, and the LAUNCHED_YEAR is less than the archive year.",
    "natural_language": "Create a stored procedure called p_delete_old_missions that takes a fate pattern, a location string, and an archive year. It should remove some older mission records where the fate kind of matches the given pattern, the location is basically the specified one, and the launch year is from a while back, before the archive cutoff.",
    "id": 273
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `p_insert_new_ship` that accepts three input parameters: `p_name` of type `VARCHAR2`, representing the name of the new ship; `p_type` of type `VARCHAR2`, representing the type or category of the new ship; and `p_nationality` of type `VARCHAR2`, representing the nationality of the new ship. The procedure begins by declaring a local variable `v_new_ship_id` of type `NUMBER` to temporarily store the generated unique identifier for the new ship. It then executes a `SELECT` statement to determine the next available `SHIP_ID` for the `SHIP` table. This `SELECT` statement calculates the maximum value of the `SHIP_ID` column from the `SHIP` table. The `NVL` function is used to handle cases where the `SHIP` table might be empty, in which case `MAX(SHIP_ID)` would return `NULL`, and `NVL` would convert this `NULL` to `0`. The result of `NVL(MAX(SHIP_ID), 0)` is then incremented by `1` to ensure a unique, sequential `SHIP_ID`. This calculated value is stored in the `v_new_ship_id` variable. Following this, the procedure performs an `INSERT` operation into the `SHIP` table. It inserts a new row with the following column values: `SHIP_ID` is set to the value stored in `v_new_ship_id`; `NAME` is set to the value provided by the `p_name` input parameter; `TYPE` is set to the value provided by the `p_type` input parameter; `NATIONALITY` is set to the value provided by the `p_nationality` input parameter; and `TONNAGE` is explicitly set to `0`.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_insert_new_ship (\n    p_name IN VARCHAR2,\n    p_type IN VARCHAR2,\n    p_nationality IN VARCHAR2\n)\nIS\n    v_new_ship_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(SHIP_ID), 0) + 1 INTO v_new_ship_id FROM SHIP;\n    INSERT INTO SHIP (SHIP_ID, NAME, TYPE, NATIONALITY, TONNAGE)\n    VALUES (v_new_ship_id, p_name, p_type, p_nationality, 0);\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "BEGIN\n  p_insert_new_ship('Titanic', 'Passenger Liner', 'United Kingdom');\nEND;",
      "BEGIN\n  p_insert_new_ship('Bismarck', 'Battleship', 'Germany');\nEND;",
      "BEGIN\n  p_insert_new_ship('USS Enterprise', 'Aircraft Carrier', 'United States');\nEND;",
      "BEGIN\n  p_insert_new_ship('Yamato', 'Battleship', 'Japan');\nEND;",
      "BEGIN\n  p_insert_new_ship('Queen Mary 2', 'Ocean Liner', 'United Kingdom');\nEND;"
    ],
    "summary": "Create a stored procedure named p_insert_new_ship with three VARCHAR2 parameters: ship name, type, and nationality. Declare a local number variable for the new ID. Generate a new SHIP_ID by taking the maximum existing ID (or 0 if null) and adding 1. Insert a new row into the SHIP table with the generated ID, the provided name, type, and nationality, and set TONNAGE to 0.",
    "natural_language": "How can I create a stored procedure named p_insert_new_ship that accepts three VARCHAR2 parameters for ship name, type, and nationality, declares a local number variable for a new ID, generates that ID by incrementing the maximum existing SHIP_ID (or starting from 0 if none exist), and inserts a new row into the SHIP table with this new ID, the provided parameters, and a default TONNAGE of 0?",
    "id": 274
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that updates the LOCATION column in the MISSION table to a specified new location for a mission identified by a given mission ID, but only if the mission's launch year is earlier than a specified cutoff year. The procedure, named p_update_mission_location, accepts three parameters: p_mission_id, which is a NUMBER representing the unique identifier of the mission to be updated; p_new_location, which is a VARCHAR2 specifying the new location to be set; and p_year_cutoff, which is a NUMBER indicating the year before which the mission must have been launched for the update to occur. The procedure performs an UPDATE operation on the MISSION table, setting the LOCATION column to the value of p_new_location for the row where the MISSION_ID column matches the value of p_mission_id and the LAUNCHED_YEAR column is less than the value of p_year_cutoff.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_update_mission_location (\n    p_mission_id IN NUMBER,\n    p_new_location IN VARCHAR2,\n    p_year_cutoff IN NUMBER\n)\nIS\nBEGIN\n    UPDATE MISSION\n    SET LOCATION = p_new_location\n    WHERE MISSION_ID = p_mission_id\n    AND LAUNCHED_YEAR < p_year_cutoff;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "BEGIN\n  p_update_mission_location(1, 'United Kingdom', 1920);\n  COMMIT;\nEND;",
      "BEGIN\n  p_update_mission_location(2, 'France', 1918);\n  COMMIT;\nEND;",
      "BEGIN\n  p_update_mission_location(4, 'Netherlands', 1935);\n  COMMIT;\nEND;",
      "BEGIN\n  p_update_mission_location(1, 'Archived - Germany', 1945);\n  COMMIT;\nEND;",
      "BEGIN\n  p_update_mission_location(2, 'Museum - Norway', 1950);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named p_update_mission_location with three parameters: a mission ID number, a new location string, and a year cutoff number. Update the MISSION table, setting the LOCATION to the new location for the row where the MISSION_ID matches the given ID and the LAUNCHED_YEAR is less than the year cutoff.",
    "natural_language": "Develop a stored procedure, which should be named p_update_mission_location, that accepts three distinct input parameters: a numeric identifier for the mission, a new textual description for its location, and a specific cutoff year. This procedure must perform an update on the MISSION table, meticulously changing the LOCATION field to the newly provided string, but only for that precise record where the MISSION_ID corresponds exactly to the supplied identifier and, importantly, where the LAUNCHED_YEAR is definitively earlier than the specified cutoff year.",
    "id": 275
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named p_archive_missions_by_speed that accepts three parameters: an input parameter p_speed_threshold of type NUMBER, an input parameter p_archive_year of type NUMBER, and an output parameter p_result of type NUMBER. The procedure first executes a DELETE operation on the MISSION table, removing all rows where the SPEED_KNOTS column value is greater than the provided p_speed_threshold and the LAUNCHED_YEAR column value is less than the provided p_archive_year. Following the deletion, the procedure performs a SELECT COUNT(*) query on the same MISSION table, using the identical condition where SPEED_KNOTS is greater than p_speed_threshold and LAUNCHED_YEAR is less than p_archive_year, and stores the resulting count into the output parameter p_result.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_archive_missions_by_speed (\n    p_speed_threshold IN NUMBER,\n    p_archive_year IN NUMBER,\n    p_result OUT NUMBER\n)\nIS\nBEGIN\n    DELETE FROM MISSION\n    WHERE SPEED_KNOTS > p_speed_threshold\n    AND LAUNCHED_YEAR < p_archive_year;\n    \n    SELECT COUNT(*)\n    INTO p_result\n    FROM MISSION\n    WHERE SPEED_KNOTS > p_speed_threshold\n    AND LAUNCHED_YEAR < p_archive_year;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  p_archive_missions_by_speed(p_speed_threshold => 20, p_archive_year => 1920, p_result => v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  p_archive_missions_by_speed(p_speed_threshold => 15, p_archive_year => 1930, p_result => v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  p_archive_missions_by_speed(p_speed_threshold => 25, p_archive_year => 1910, p_result => v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  p_archive_missions_by_speed(p_speed_threshold => 10, p_archive_year => 1940, p_result => v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  p_archive_missions_by_speed(p_speed_threshold => 30, p_archive_year => 1900, p_result => v_result);\nEND;"
    ],
    "summary": "Create a stored procedure named p_archive_missions_by_speed that deletes rows from the MISSION table where SPEED_KNOTS exceeds a provided threshold and LAUNCHED_YEAR is less than a provided year. It then returns the count of rows still meeting those conditions via an output parameter.",
    "natural_language": "Create a stored procedure called p_archive_missions_by_speed that removes a bunch of rows from the MISSION table where the speed is kind of high, above a certain threshold, and the launch year is pretty old, before a given year. Then, have it give back a rough count of how many rows are still like that using an output parameter.",
    "id": 276
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `Delete_Expensive_Products` that is designed to remove records from a database table. This procedure accepts one input parameter and provides one output parameter. The input parameter, `p_price_threshold`, is of data type `NUMBER` and serves the purpose of defining the minimum price value for products to be considered \"expensive\" and thus eligible for deletion. The output parameter, `p_deleted_count`, is also of data type `NUMBER` and is used to return the total number of rows that were successfully deleted by the procedure. Upon execution, the procedure performs a `DELETE` operation on the `PRODUCTS` table. This `DELETE` operation is conditional, targeting only those rows where the value in the `PRICE` column is strictly greater than the value provided in the `p_price_threshold` input parameter. After the `DELETE` statement completes its execution, the procedure then assigns the number of rows affected by the preceding `DELETE` statement to the `p_deleted_count` output parameter. This count is obtained using the `SQL%ROWCOUNT` SQL attribute, which specifically returns the number of rows processed by the most recently executed SQL statement in the current session.",
    "plsql": "CREATE OR REPLACE PROCEDURE Delete_Expensive_Products(\n    p_price_threshold IN NUMBER,\n    p_deleted_count OUT NUMBER\n)\nAS\nBEGIN\n    DELETE FROM PRODUCTS\n    WHERE PRICE > p_price_threshold;\n    \n    p_deleted_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "PRODUCTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(200, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(150, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(100, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(250, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(300, v_deleted_count);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named Delete_Expensive_Products that deletes rows from the PRODUCTS table where PRICE exceeds a provided threshold. It returns the number of deleted rows via an output parameter using SQL%ROWCOUNT.",
    "natural_language": "Hey, can you whip up a stored procedure called Delete_Expensive_Products? It should clean out stuff from the PRODUCTS table where the PRICE is just too highlike, over a number we give it. Oh, and we wanna know how many got the axe, so have it spit back that count using SQL%ROWCOUNT.",
    "id": 277
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named calculate_customer_complaint_stats that accepts two input parameters: a numeric parameter p_customer_id representing a specific customer identifier and a numeric parameter p_min_price representing a minimum price threshold. The procedure first declares three local numeric variables: v_complaint_count, v_avg_product_price, and v_total_price_sum. It then performs a query on the COMPLAINTS table to count the total number of complaint records where the CUSTOMER_ID column matches the provided p_customer_id, storing the result in v_complaint_count. Next, it executes a query that joins the PRODUCTS table (aliased as p) with the COMPLAINTS table (aliased as c) on the condition that p.PRODUCT_ID equals c.PRODUCT_ID; this query calculates the average value of the PRODUCT_PRICE column from the PRODUCTS table and the sum of the PRODUCT_PRICE column, but only for rows where the CUSTOMER_ID in the COMPLAINTS table equals p_customer_id and the PRODUCT_PRICE in the PRODUCTS table is greater than the input parameter p_min_price; these calculated average and sum values are stored into v_avg_product_price and v_total_price_sum respectively. Following the data retrieval, the procedure uses a conditional IF-ELSIF-ELSE block: if the value of v_complaint_count is greater than 5, it performs an INSERT operation into the COMPLAINTS table, generating a new COMPLAINT_ID by selecting the maximum existing COMPLAINT_ID from the COMPLAINTS table and adding 1, using the input p_customer_id for the CUSTOMER_ID column, selecting a PRODUCT_ID by finding the product with the maximum PRODUCT_PRICE from the PRODUCTS table, setting the COMPLAINT_STATUS_CODE to the literal string 'High Volume', and setting the DATE_COMPLAINT_RAISED column to the current date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function on CURRENT_TIMESTAMP. Otherwise, if the first condition is not met and the value of v_avg_product_price is greater than 50, it performs a different INSERT into the COMPLAINTS table, again generating a new COMPLAINT_ID by selecting the maximum existing COMPLAINT_ID plus 1, using p_customer_id for CUSTOMER_ID, selecting a PRODUCT_ID by finding the product with the minimum PRODUCT_PRICE from the PRODUCTS table, setting the COMPLAINT_STATUS_CODE to 'Premium Products', and setting DATE_COMPLAINT_RAISED to the formatted current timestamp. If neither of the previous conditions is true, the procedure executes a DELETE operation on the COMPLAINTS table, removing all rows where the CUSTOMER_ID equals p_customer_id, the COMPLAINT_STATUS_CODE column equals the string 'Closed', and the DATE_COMPLAINT_CLOSED column is not null.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_customer_complaint_stats(p_customer_id NUMBER, p_min_price NUMBER)\nIS\n    v_complaint_count NUMBER;\n    v_avg_product_price NUMBER;\n    v_total_price_sum NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_complaint_count\n    FROM COMPLAINTS\n    WHERE CUSTOMER_ID = p_customer_id;\n    \n    SELECT AVG(p.PRODUCT_PRICE), SUM(p.PRODUCT_PRICE) \n    INTO v_avg_product_price, v_total_price_sum\n    FROM PRODUCTS p\n    JOIN COMPLAINTS c ON p.PRODUCT_ID = c.PRODUCT_ID\n    WHERE c.CUSTOMER_ID = p_customer_id\n    AND p.PRODUCT_PRICE > p_min_price;\n    \n    IF v_complaint_count > 5 THEN\n        INSERT INTO COMPLAINTS (COMPLAINT_ID, CUSTOMER_ID, PRODUCT_ID, COMPLAINT_STATUS_CODE, DATE_COMPLAINT_RAISED)\n        VALUES ((SELECT MAX(COMPLAINT_ID) + 1 FROM COMPLAINTS), p_customer_id, \n                (SELECT PRODUCT_ID FROM PRODUCTS WHERE PRODUCT_PRICE = (SELECT MAX(PRODUCT_PRICE) FROM PRODUCTS)),\n                'High Volume', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSIF v_avg_product_price > 50 THEN\n        INSERT INTO COMPLAINTS (COMPLAINT_ID, CUSTOMER_ID, PRODUCT_ID, COMPLAINT_STATUS_CODE, DATE_COMPLAINT_RAISED)\n        VALUES ((SELECT MAX(COMPLAINT_ID) + 1 FROM COMPLAINTS), p_customer_id,\n                (SELECT PRODUCT_ID FROM PRODUCTS WHERE PRODUCT_PRICE = (SELECT MIN(PRODUCT_PRICE) FROM PRODUCTS)),\n                'Premium Products', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSE\n        DELETE FROM COMPLAINTS \n        WHERE CUSTOMER_ID = p_customer_id \n        AND COMPLAINT_STATUS_CODE = 'Closed'\n        AND DATE_COMPLAINT_CLOSED IS NOT NULL;\n    END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_customer_complaint_stats(113, 10);\nEND;",
      "BEGIN\n  calculate_customer_complaint_stats(114, 25);\nEND;",
      "BEGIN\n  calculate_customer_complaint_stats(115, 50);\nEND;",
      "BEGIN\n  calculate_customer_complaint_stats(120, 100);\nEND;",
      "BEGIN\n  calculate_customer_complaint_stats(113, 0);\nEND;"
    ],
    "summary": "Create a stored procedure named calculate_customer_complaint_stats that, for a given customer and minimum price, calculates complaint count, average price, and total price sum. Based on these values: if complaint count > 5, insert a new complaint for the highest-priced product with status 'High Volume'; else if average price > 50, insert a complaint for the lowest-priced product with status 'Premium Products'; otherwise, delete all 'Closed' complaints for that customer where a close date exists.",
    "natural_language": "Hey, can you whip up a stored procedure called calculate_customer_complaint_stats? Here's what it needs to do: for a specific customer and a minimum price we set, it should figure out how many complaints they have, the average price of their stuff, and the total price of everything. Then, based on that: if the complaint count is more than 5, slap in a new complaint for their most expensive product and mark it as 'High Volume'. If that's not the case but the average price is over 50, then add a complaint for their cheapest product and tag it 'Premium Products'. If neither of those things are true, just go ahead and delete all the 'Closed' complaints for that customer, but only the ones that actually have a close date recorded.",
    "id": 278
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `analyze_staff_geographic_coverage` that accepts two input parameters: `p_staff_id` of type `NUMBER`, representing the unique identifier of a staff member, and `p_state_filter` of type `VARCHAR2`, representing a specific state to be filtered.\n\nThe procedure begins by declaring three local variables: `v_state_count` of type `NUMBER` to store the count of distinct states, `v_total_complaints` of type `NUMBER` to store the total number of complaints, and `v_avg_product_price` of type `NUMBER` to store the average product price.\n\nIt then defines a cursor named `state_cursor` which selects distinct values from the `STATE` column of the `CUSTOMERS` table. This selection is performed by joining the `CUSTOMERS` table (aliased as `c`) with the `COMPLAINTS` table (aliased as `comp`) on the condition `c.CUSTOMER_ID = comp.CUSTOMER_ID`. The results are filtered to include only those complaints where the `STAFF_ID` in the `COMPLAINTS` table matches the input parameter `p_staff_id`.\n\nFollowing the cursor definition, the procedure executes a `SELECT` statement to count the number of distinct states associated with the staff member identified by `p_staff_id`. This count is derived by joining the `CUSTOMERS` table (aliased as `c`) with the `COMPLAINTS` table (aliased as `comp`) on `c.CUSTOMER_ID = comp.CUSTOMER_ID`, and filtering where `comp.STAFF_ID` equals `p_staff_id`. The result of this count is stored in the `v_state_count` variable.\n\nNext, another `SELECT` statement is executed to count the total number of complaints for the staff member specified by `p_staff_id`. This count is obtained from the `COMPLAINTS` table where the `STAFF_ID` column matches `p_staff_id`. The result is stored in the `v_total_complaints` variable.\n\nSubsequently, a third `SELECT` statement calculates the average product price for products involved in complaints handled by the staff member `p_staff_id`. This is achieved by joining the `PRODUCTS` table (aliased as `p`) with the `COMPLAINTS` table (aliased as `c`) on `p.PRODUCT_ID = c.PRODUCT_ID`, and filtering where `c.STAFF_ID` equals `p_staff_id`. The average of the `PRODUCT_PRICE` column from the `PRODUCTS` table is then stored in the `v_avg_product_price` variable.\n\nAfter these initial calculations, the procedure enters a `FOR` loop that iterates through each record returned by the `state_cursor`. For each `state_rec` (representing a distinct state) fetched by the cursor, an `IF` condition checks if the `STATE` value of the current `state_rec` is equal to the input parameter `p_state_filter`.\n\nIf this condition is true, an `INSERT` statement is executed to add a new record into the `COMPLAINTS` table. The values inserted are:\n- `COMPLAINT_ID`: Determined by selecting the maximum `COMPLAINT_ID` from the `COMPLAINTS` table and adding 1 to it.\n- `PRODUCT_ID`: Determined by selecting the `PRODUCT_ID` from the `PRODUCTS` table where the `PRODUCT_PRICE` is equal to the maximum `PRODUCT_PRICE` found in the `PRODUCTS` table.\n- `CUSTOMER_ID`: Determined by selecting the `CUSTOMER_ID` from the `CUSTOMERS` table where the `STATE` matches the `state_rec.STATE` and `ROWNUM` is 1 (effectively picking one customer from that state).\n- `STAFF_ID`: Set to the input parameter `p_staff_id`.\n- `COMPLAINT_STATUS_CODE`: Set to the literal string 'Target State'.\n- `DATE_COMPLAINT_RAISED`: Set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS')`.\n\nFollowing the loop, another `IF` condition checks if the `v_state_count` variable (which holds the count of distinct states associated with the staff member) is greater than 4.\n\nIf this condition is true, a `DELETE` statement is executed to remove up to 5 records from the `COMPLAINTS` table. The records targeted for deletion are those where the `STAFF_ID` matches `p_staff_id`, the `COMPLAINT_STATUS_CODE` is 'Closed', and the `DATE_COMPLAINT_CLOSED` column is not null. The `ROWNUM <= 5` clause limits the deletion to the first 5 rows that satisfy the preceding conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_staff_geographic_coverage(p_staff_id NUMBER, p_state_filter VARCHAR2)\nIS\n    v_state_count NUMBER;\n    v_total_complaints NUMBER;\n    v_avg_product_price NUMBER;\n    CURSOR state_cursor IS\n        SELECT DISTINCT c.STATE\n        FROM CUSTOMERS c\n        JOIN COMPLAINTS comp ON c.CUSTOMER_ID = comp.CUSTOMER_ID\n        WHERE comp.STAFF_ID = p_staff_id;\nBEGIN\n    SELECT COUNT(DISTINCT c.STATE) INTO v_state_count\n    FROM CUSTOMERS c\n    JOIN COMPLAINTS comp ON c.CUSTOMER_ID = comp.CUSTOMER_ID\n    WHERE comp.STAFF_ID = p_staff_id;\n    \n    SELECT COUNT(*) INTO v_total_complaints\n    FROM COMPLAINTS\n    WHERE STAFF_ID = p_staff_id;\n    \n    SELECT AVG(p.PRODUCT_PRICE) INTO v_avg_product_price\n    FROM PRODUCTS p\n    JOIN COMPLAINTS c ON p.PRODUCT_ID = c.PRODUCT_ID\n    WHERE c.STAFF_ID = p_staff_id;\n    \n    FOR state_rec IN state_cursor LOOP\n        IF state_rec.STATE = p_state_filter THEN\n            INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, STAFF_ID, COMPLAINT_STATUS_CODE, DATE_COMPLAINT_RAISED)\n            VALUES ((SELECT MAX(COMPLAINT_ID) + 1 FROM COMPLAINTS),\n                   (SELECT PRODUCT_ID FROM PRODUCTS WHERE PRODUCT_PRICE = (SELECT MAX(PRODUCT_PRICE) FROM PRODUCTS)),\n                   (SELECT CUSTOMER_ID FROM CUSTOMERS WHERE STATE = state_rec.STATE AND ROWNUM = 1),\n                   p_staff_id, 'Target State', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n        END IF;\n    END LOOP;\n    \n    IF v_state_count > 4 THEN\n        DELETE FROM COMPLAINTS \n        WHERE STAFF_ID = p_staff_id \n        AND COMPLAINT_STATUS_CODE = 'Closed'\n        AND DATE_COMPLAINT_CLOSED IS NOT NULL\n        AND ROWNUM <= 5;\n    END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  analyze_staff_geographic_coverage(114, 'Kansas');\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_staff_geographic_coverage(115, 'Hawaii');\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_staff_geographic_coverage(120, 'Tennessee');\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_staff_geographic_coverage(116, 'California');\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_staff_geographic_coverage(117, 'Texas');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named analyze_staff_geographic_coverage that, for a given staff member and state filter, calculates distinct state count, total complaints, and average product price. For each distinct state associated with the staff member, if it matches the state filter, insert a new 'Target State' complaint using a top-priced product and a customer from that state. Finally, if the distinct state count exceeds 4, delete up to 5 'Closed' complaints for that staff member where a close date exists.",
    "natural_language": "Alright, so we need a stored procedure called 'analyze_staff_geographic_coverage'. Here's the deal: you give it a specific staff member and a state to look for. It's gotta figure out how many different states that staffer works in, count up all their complaints, and find the average price of the products involved. Now, for every state the staffer's connected to, if it's the one we're filtering for, we gotta add a new complaint labeled 'Target State'. For that new complaint, use the priciest product and a customer from that same state. Oh, and one more thingif the staffer covers more than 4 states, go ahead and delete up to 5 of their 'Closed' complaints, but only the ones that actually have a close date.",
    "id": 279
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateProductRevenue that accepts five input parameters: a numeric parameter p_product_code representing a product identifier, a numeric parameter p_new_price representing a proposed new price, a numeric parameter p_revenue_threshold representing a revenue limit, a numeric parameter p_manufacturer_code representing a manufacturer identifier, and a numeric parameter p_default_price representing a baseline price. The procedure executes a conditional block where, if the p_new_price value is strictly greater than the p_default_price value, it performs an update on the PRODUCTS table, setting the PRICE column to the p_new_price value for the specific row where the CODE column equals p_product_code and the MANUFACTURER column equals p_manufacturer_code. If the p_new_price value is less than or equal to the p_default_price value, the procedure executes a delete operation on the PRODUCTS table, removing rows where the CODE column equals p_product_code and the MANUFACTURER column value is found in a subquery result; this subquery selects the CODE column from the MANUFACTURERS table for all rows where the REVENUE column value is less than the p_revenue_threshold parameter. If neither of the previous conditions is true, which logically cannot occur as the conditions are exhaustive, the procedure executes an insert operation into the PRODUCTS table, specifying values for the columns CODE, NAME, PRICE, and MANUFACTURER; the value for the CODE column is derived from a scalar subquery that calculates the next available integer by selecting the maximum value from the CODE column in the PRODUCTS table, using the NVL function to substitute a zero if the maximum is null, and then adding one to that result, the NAME column is set to the literal string 'New Product', the PRICE column is set to the p_default_price parameter value, and the MANUFACTURER column is set to the p_manufacturer_code parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateProductRevenue(\n  p_product_code IN NUMBER,\n  p_new_price IN NUMBER,\n  p_revenue_threshold IN NUMBER,\n  p_manufacturer_code IN NUMBER,\n  p_default_price IN NUMBER\n) AS\nBEGIN\n  IF p_new_price > p_default_price THEN\n    UPDATE PRODUCTS\n    SET PRICE = p_new_price\n    WHERE CODE = p_product_code AND MANUFACTURER = p_manufacturer_code;\n  ELSIF p_new_price <= p_default_price THEN\n    DELETE FROM PRODUCTS\n    WHERE CODE = p_product_code AND MANUFACTURER IN (\n      SELECT CODE FROM MANUFACTURERS WHERE REVENUE < p_revenue_threshold\n    );\n  ELSE\n    INSERT INTO PRODUCTS (CODE, NAME, PRICE, MANUFACTURER)\n    VALUES (\n      (SELECT NVL(MAX(CODE), 0) + 1 FROM PRODUCTS),\n      'New Product',\n      p_default_price,\n      p_manufacturer_code\n    );\n  END IF;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateProductRevenue(1, 300, 80, 1, 250);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(2, 100, 60, 2, 120);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(3, 200, 70, 3, 150);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(4, 90, 50, 1, 100);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(5, 400, 90, 2, 350);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateProductRevenue that, for given product and manufacturer codes, a new price, a revenue threshold, and a default price: if the new price exceeds the default, update the product's price. If the new price is less than or equal to the default, delete the product if its manufacturer's revenue is below the threshold. Otherwise, insert a new product with an auto-generated code, name 'New Product', the default price, and the given manufacturer code.",
    "natural_language": "Create a stored procedure called UpdateProductRevenue that, for a specific product and its maker, a proposed price, a certain revenue level, and a standard price: if the proposed price is higher than the standard, adjust the product's price. If the proposed price isn't higher, remove the product provided its maker's earnings are kind of low compared to that level. If not, add a new product entry with an auto-made code, a name like 'New Product', the standard price, and that maker's code.",
    "id": 280
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateManufacturerRevenue that accepts five input parameters: a numeric parameter p_code representing a manufacturer identifier, a numeric parameter p_new_revenue representing a new revenue value to be assigned, a numeric parameter p_product_code which is not used within the procedure's logic, a numeric parameter p_price_threshold used to filter products by price, and a numeric parameter p_manufacturer_code which is also not used within the procedure's logic. The procedure performs a single UPDATE operation on the MANUFACTURERS table, specifically targeting the REVENUE column. It sets the REVENUE column to the value provided in the p_new_revenue parameter for rows in the MANUFACTURERS table that satisfy a compound condition. The condition requires that the manufacturer's CODE column equals the input parameter p_code and, simultaneously, that the same CODE value exists within the result set of a subquery. The subquery selects from the PRODUCTS table, retrieving the MANUFACTURER column for all rows where the PRICE column value is strictly greater than the input parameter p_price_threshold.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateManufacturerRevenue(\n  p_code IN NUMBER,\n  p_new_revenue IN NUMBER,\n  p_product_code IN NUMBER,\n  p_price_threshold IN NUMBER,\n  p_manufacturer_code IN NUMBER\n) AS\nBEGIN\n  UPDATE MANUFACTURERS\n  SET REVENUE = p_new_revenue\n  WHERE CODE = p_code AND CODE IN (\n    SELECT MANUFACTURER FROM PRODUCTS WHERE PRICE > p_price_threshold\n  );\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateManufacturerRevenue(1, 150, 1, 100, 1);\nEND;",
      "BEGIN\n  UpdateManufacturerRevenue(2, 110, 2, 130, 2);\nEND;",
      "BEGIN\n  UpdateManufacturerRevenue(3, 60, 3, 200, 3);\nEND;",
      "BEGIN\n  UpdateManufacturerRevenue(1, 130, 1, 250, 1);\nEND;",
      "BEGIN\n  UpdateManufacturerRevenue(2, 90, 2, 50, 2);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateManufacturerRevenue that updates the REVENUE column in the MANUFACTURERS table. It sets the revenue to a provided new value for a specific manufacturer, but only if that manufacturer has products with a price greater than a given threshold.",
    "natural_language": "Please construct a stored procedure designated as UpdateManufacturerRevenue. This procedure shall modify the REVENUE column within the MANUFACTURERS table, assigning it a specified new value for a particular manufacturer. The update is to be executed conditionally, proceeding only if the manufacturer in question has associated products whose price exceeds a supplied threshold.",
    "id": 281
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes five input parameters: p_product_code (a NUMBER representing the unique identifier of a product), p_name (a VARCHAR2 representing the name of the product), p_price (a NUMBER representing the price of the product), p_manufacturer_code (a NUMBER representing the unique identifier of the manufacturer associated with the product), and p_revenue_threshold (a NUMBER representing a revenue threshold value used for filtering manufacturers). The procedure first checks if a product with the given p_product_code exists in the PRODUCTS table by performing a SELECT COUNT(*) query on the CODE column of the PRODUCTS table and storing the result in a local variable v_count. If no product exists (v_count equals 0), the procedure inserts a new row into the PRODUCTS table with the values provided in the parameters p_product_code, p_name, p_price, and p_manufacturer_code, mapping them to the CODE, NAME, PRICE, and MANUFACTURER columns respectively. If a product with the given p_product_code already exists (v_count is greater than 0), the procedure updates the PRICE column of the PRODUCTS table for the row where CODE matches p_product_code, but only if the MANUFACTURER column in the PRODUCTS table corresponds to a manufacturer whose CODE exists in the MANUFACTURERS table and whose REVENUE column value exceeds the p_revenue_threshold parameter. This filtering of manufacturers is achieved using a subquery on the MANUFACTURERS table that selects the CODE values of manufacturers with REVENUE greater than p_revenue_threshold. The procedure uses an IF-ELSE conditional structure to determine whether to perform the INSERT or UPDATE operation based on the existence of the product in the PRODUCTS table.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertOrUpdateProduct(\n  p_product_code IN NUMBER,\n  p_name IN VARCHAR2,\n  p_price IN NUMBER,\n  p_manufacturer_code IN NUMBER,\n  p_revenue_threshold IN NUMBER\n) AS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO v_count\n  FROM PRODUCTS\n  WHERE CODE = p_product_code;\n\n  IF v_count = 0 THEN\n    INSERT INTO PRODUCTS (CODE, NAME, PRICE, MANUFACTURER)\n    VALUES (\n      p_product_code,\n      p_name,\n      p_price,\n      p_manufacturer_code\n    );\n  ELSE\n    UPDATE PRODUCTS\n    SET PRICE = p_price\n    WHERE CODE = p_product_code AND MANUFACTURER IN (\n      SELECT CODE FROM MANUFACTURERS WHERE REVENUE > p_revenue_threshold\n    );\n  END IF;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  InsertOrUpdateProduct(10, 'New Product A', 500, 1, 100);\nEND;",
      "BEGIN\n  InsertOrUpdateProduct(11, 'New Product B', 750, 2, 150);\nEND;",
      "BEGIN\n  InsertOrUpdateProduct(1, 'Updated Hard drive', 250, 5, 100);\nEND;",
      "BEGIN\n  InsertOrUpdateProduct(2, 'Updated Memory', 130, 6, 1000);\nEND;",
      "BEGIN\n  InsertOrUpdateProduct(12, 'New Product C', 300, 3, 50);\nEND;"
    ],
    "summary": "Create a stored procedure that inserts a new product or updates its price. It first checks if a product with the given code exists. If not, it inserts a new product. If it exists, it updates the product's price, but only if the product's manufacturer has revenue above a specified threshold.",
    "natural_language": "Please construct a stored procedure to insert a new product record or update an existing product's price. The procedure must initially verify the existence of a product with the provided product code. Should the product not exist, a new product record is to be inserted. If the product does exist, the procedure shall update its price, but only under the condition that the associated manufacturer's revenue exceeds a designated threshold.",
    "id": 282
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_customer_records that accepts three parameters: an input number parameter p_old_id, an input number parameter p_new_id, and an output number parameter p_result. The procedure first checks if p_old_id and p_new_id are equal and, if they are, sets p_result to -1 and stops execution. If the IDs are different, it then checks for the existence of p_new_id in the CMI_CROSS_REFERENCES table by selecting the value 1 into a local variable v_dummy from the row where the CMI_CROSS_REF_ID column equals p_new_id; if no row is found, it sets p_result to -2 and stops, and if more than one row is found, it sets p_result to -4 and stops. Next, it performs an identical existence check for p_old_id in the CMI_CROSS_REFERENCES table, setting p_result to -3 if the old ID is not found, or to -4 if multiple rows for the old ID are found, and stopping execution in either case. If both IDs exist uniquely, the procedure proceeds to update the BENEFITS_OVERPAYMENTS table, changing the CMI_CROSS_REF_ID column value from p_old_id to p_new_id for all rows where CMI_CROSS_REF_ID equals p_old_id, and stores the number of rows updated from this operation into p_result. It then updates the RENT_ARREARS table, similarly changing the CMI_CROSS_REF_ID column value from p_old_id to p_new_id for all rows where CMI_CROSS_REF_ID equals p_old_id, and adds the number of rows updated from this second operation to the existing value of p_result.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_customer_records(\n    p_old_id  IN  NUMBER,\n    p_new_id  IN  NUMBER,\n    p_result  OUT NUMBER\n) IS\n    v_dummy NUMBER;\nBEGIN\n    -- Check if old ID and new ID are the same\n    IF p_old_id = p_new_id THEN\n        p_result := -1;\n        RETURN;\n    END IF;\n\n    -- Check if the new ID exists in CMI_CROSS_REFERENCES\n    BEGIN\n        SELECT 1 INTO v_dummy FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = p_new_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            p_result := -2;\n            RETURN;\n        WHEN TOO_MANY_ROWS THEN\n            p_result := -4; -- Unexpected case: multiple rows for the same ID\n            RETURN;\n    END;\n\n    -- Check if the old ID exists in CMI_CROSS_REFERENCES\n    BEGIN\n        SELECT 1 INTO v_dummy FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = p_old_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            p_result := -3;\n            RETURN;\n        WHEN TOO_MANY_ROWS THEN\n            p_result := -4; -- Unexpected case: multiple rows for the same ID\n            RETURN;\n    END;\n\n    -- Update BENEFITS_OVERPAYMENTS\n    UPDATE BENEFITS_OVERPAYMENTS\n       SET CMI_CROSS_REF_ID = p_new_id\n     WHERE CMI_CROSS_REF_ID = p_old_id;\n    p_result := SQL%ROWCOUNT;\n\n    -- Update RENT_ARREARS\n    UPDATE RENT_ARREARS\n       SET CMI_CROSS_REF_ID = p_new_id\n     WHERE CMI_CROSS_REF_ID = p_old_id;\n    p_result := p_result + SQL%ROWCOUNT;\n\n    COMMIT;\nEXCEPTION\n    WHEN OTHERS THEN\n        ROLLBACK;\n        RAISE;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(2, 4, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(8, 2, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(4, 8, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(65, 41, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(83, 65, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;"
    ],
    "summary": "Create a stored procedure named consolidate_customer_records that merges records from an old customer ID to a new one. It validates that both IDs exist uniquely in a reference table. If validation passes, it updates all references to the old ID in the BENEFITS_OVERPAYMENTS and RENT_ARREARS tables to the new ID and returns the total number of rows updated.",
    "natural_language": "Create procedure consolidate_customer_records to merge an old customer ID into a new one. Validate both IDs exist uniquely, then update BENEFITS_OVERPAYMENTS and RENT_ARREARS. Return total rows updated.",
    "id": 283
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_gymnast_total_points` that accepts two input parameters: `p_gymnast_id` of data type `NUMBER`, representing the unique identifier of a gymnast whose total points are to be updated, and `p_round_precision` of data type `NUMBER`, specifying the number of decimal places to which the calculated total points should be rounded. The procedure begins by declaring a local variable `v_total_points` of data type `NUMBER` to temporarily store the calculated total points. It then executes a `SELECT` statement to retrieve and calculate the sum of various individual event scores for a specific gymnast. This calculation involves summing the values from the `FLOOR_EXERCISE_POINTS`, `POMMEL_HORSE_POINTS`, `RINGS_POINTS`, `VAULT_POINTS`, `PARALLEL_BARS_POINTS`, and `HORIZONTAL_BAR_POINTS` columns from the `GYMNAST` table. The result of this summation is then rounded to the number of decimal places specified by the `p_round_precision` parameter using the `ROUND` function. The calculated and rounded total points are then stored into the `v_total_points` local variable. This `SELECT` operation is filtered by a `WHERE` clause, ensuring that the calculation is performed only for the row in the `GYMNAST` table where the `GYMNAST_ID` column matches the value provided in the `p_gymnast_id` input parameter. Following this, the procedure executes an `UPDATE` statement on the `GYMNAST` table. This `UPDATE` statement sets the value of the `TOTAL_POINTS` column to the value stored in the `v_total_points` local variable. This `UPDATE` operation is also filtered by a `WHERE` clause, ensuring that only the row in the `GYMNAST` table where the `GYMNAST_ID` column matches the value provided in the `p_gymnast_id` input parameter is modified.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_gymnast_total_points(p_gymnast_id IN NUMBER, p_round_precision IN NUMBER)\nIS\n    v_total_points NUMBER;\nBEGIN\n    SELECT ROUND(FLOOR_EXERCISE_POINTS + POMMEL_HORSE_POINTS + RINGS_POINTS + VAULT_POINTS + PARALLEL_BARS_POINTS + HORIZONTAL_BAR_POINTS, p_round_precision)\n    INTO v_total_points\n    FROM GYMNAST\n    WHERE GYMNAST_ID = p_gymnast_id;\n\n    UPDATE GYMNAST\n    SET TOTAL_POINTS = v_total_points\n    WHERE GYMNAST_ID = p_gymnast_id;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  update_gymnast_total_points(1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_total_points(2, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_total_points(4, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_total_points(1, 0);\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_total_points(2, 1);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_gymnast_total_points that calculates a gymnast's total points by summing their scores from six events, rounds the result to a specified decimal precision, and updates the TOTAL_POINTS column in the GYMNAST table for that gymnast.",
    "natural_language": "Create a stored procedure, which should be named update_gymnast_total_points, that meticulously calculates a gymnast's comprehensive total points by carefully summing up all of their individual scores from each of the six distinct competitive events, then precisely rounds the resulting sum to a user-specified decimal precision, and finally updates the TOTAL_POINTS column within the GYMNAST table specifically for that particular gymnast's record.",
    "id": 284
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_gymnast that accepts two input parameters: p_name of type VARCHAR2, which represents the name of the new gymnast, and p_age of type NUMBER, which represents the age of the new gymnast. The procedure first declares a local variable v_people_id of type NUMBER. It then executes a SELECT statement on the PEOPLE table to calculate a new unique identifier by finding the current maximum value in the PEOPLE_ID column, using the NVL function to return 0 if the column is null, and adding 1 to that result; this calculated value is stored into the local variable v_people_id. Following this, the procedure performs an INSERT operation into the PEOPLE table, creating a new row with the PEOPLE_ID column set to the value of v_people_id, the NAME column set to the input parameter p_name, and the AGE column set to the input parameter p_age. Subsequently, the procedure performs a second INSERT operation into the GYMNAST table, creating a new row where the GYMNAST_ID column is set to the same v_people_id value, and initializing the score columns FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, and TOTAL_POINTS all to the value 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_gymnast(p_name IN VARCHAR2, p_age IN NUMBER)\nIS\n    v_people_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(PEOPLE_ID), 0) + 1 INTO v_people_id FROM PEOPLE;\n\n    INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE)\n    VALUES (v_people_id, p_name, p_age);\n\n    INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS)\n    VALUES (v_people_id, 0, 0, 0, 0, 0, 0, 0);\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_gymnast('John Doe', 22);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Jane Smith', 19);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Michael Johnson', 25);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Emily Davis', 20);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Chris Brown', 23);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_new_gymnast that adds a new gymnast. It generates a new unique ID for the PEOPLE table, inserts the person's name and age, and then inserts a corresponding record into the GYMNAST table with all scores initialized to zero.",
    "natural_language": "Please construct a stored procedure designated as 'insert_new_gymnast' to facilitate the addition of a new gymnast. The procedure must generate a novel, unique identifier for insertion into the PEOPLE table, subsequently inserting the individual's name and age. Following this, it shall insert a corresponding entry into the GYMNAST table, initializing all performance scores to a value of zero.",
    "id": 285
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_gymnast` that accepts two input parameters: `p_gymnast_id` of data type `NUMBER` and `p_people_id` of data type `NUMBER`. The purpose of this procedure is to remove specific records from two distinct tables. The procedure first executes a `DELETE` operation on the `GYMNAST` table. This deletion targets rows where the value in the `GYMNAST_ID` column precisely matches the value provided in the `p_gymnast_id` input parameter. Following this, the procedure performs a second `DELETE` operation, this time on the `PEOPLE` table. This subsequent deletion targets rows within the `PEOPLE` table where the value in the `PEOPLE_ID` column exactly corresponds to the value supplied in the `p_people_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_gymnast(p_gymnast_id IN NUMBER, p_people_id IN NUMBER)\nIS\nBEGIN\n    DELETE FROM GYMNAST WHERE GYMNAST_ID = p_gymnast_id;\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  delete_gymnast(1, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(2, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(4, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(5, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(10, 10);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `delete_gymnast` that deletes a record from the GYMNAST table where GYMNAST_ID matches the input parameter `p_gymnast_id`, and then deletes a record from the PEOPLE table where PEOPLE_ID matches the input parameter `p_people_id`.",
    "natural_language": "Please construct a stored procedure designated as `delete_gymnast`. This procedure shall perform the deletion of a record from the GYMNAST table, specifically where the GYMNAST_ID column corresponds to the provided input parameter `p_gymnast_id`. Subsequently, it shall delete a record from the PEOPLE table where the PEOPLE_ID column matches the supplied input parameter `p_people_id`.",
    "id": 286
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `calculate_average_points` that accepts two input parameters: `p_gymnast_id` of type NUMBER, which specifies the unique identifier for a gymnast, and `p_round_precision` of type NUMBER, which determines the number of decimal places for rounding. The procedure begins by declaring a local variable `v_average_points` of type NUMBER. It then executes a SELECT statement that queries the `GYMNAST` table for the row where the `GYMNAST_ID` column matches the input parameter `p_gymnast_id`. For that specific row, it calculates the sum of six specific column values: `FLOOR_EXERCISE_POINTS`, `POMMEL_HORSE_POINTS`, `RINGS_POINTS`, `VAULT_POINTS`, `PARALLEL_BARS_POINTS`, and `HORIZONTAL_BAR_POINTS`. This sum is divided by 6 to compute an average. The `ROUND` function is applied to this average, using the input parameter `p_round_precision` as the second argument to control the rounding precision, and the resulting value is stored into the local variable `v_average_points`. Following this calculation, the procedure performs an UPDATE operation on the `GYMNAST` table, setting the `TOTAL_POINTS` column to the value stored in `v_average_points` for the row where the `GYMNAST_ID` column equals the input parameter `p_gymnast_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_points(p_gymnast_id IN NUMBER, p_round_precision IN NUMBER)\nIS\n    v_average_points NUMBER;\nBEGIN\n    SELECT ROUND((FLOOR_EXERCISE_POINTS + POMMEL_HORSE_POINTS + RINGS_POINTS + VAULT_POINTS + PARALLEL_BARS_POINTS + HORIZONTAL_BAR_POINTS) / 6, p_round_precision)\n    INTO v_average_points\n    FROM GYMNAST\n    WHERE GYMNAST_ID = p_gymnast_id;\n\n    UPDATE GYMNAST\n    SET TOTAL_POINTS = v_average_points\n    WHERE GYMNAST_ID = p_gymnast_id;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_average_points(1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  calculate_average_points(2, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  calculate_average_points(4, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  calculate_average_points(1, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  calculate_average_points(2, 0);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `calculate_average_points` that calculates the average of six points columns (FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) for a specific gymnast, rounds the result to a specified decimal precision, and updates the TOTAL_POINTS column in the GYMNAST table for that gymnast.",
    "natural_language": "Develop a stored procedure called `calculate_average_points` that meticulously computes the average score from six distinct points columnsspecifically FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTSfor a particular gymnast, carefully rounds the computed average to a user-defined decimal precision, and subsequently updates the TOTAL_POINTS column within the GYMNAST table for that specific athlete.",
    "id": 287
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_gymnast_hometown` that accepts two input parameters: `p_gymnast_id`, which is of data type `NUMBER` and represents the unique identifier for a specific gymnast, and `p_hometown`, which is of data type `VARCHAR2` and represents the new hometown value to be assigned to the specified gymnast. The procedure's sole operation is to perform an `UPDATE` statement on the `PEOPLE` table. This `UPDATE` statement modifies the `HOMETOWN` column of one or more rows in the `PEOPLE` table. The new value for the `HOMETOWN` column will be set to the value provided by the `p_hometown` input parameter. The specific row(s) to be updated are determined by a `WHERE` clause, which specifies that only rows where the `PEOPLE_ID` column matches the value provided by the `p_gymnast_id` input parameter will be affected by this update operation.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_gymnast_hometown(p_gymnast_id IN NUMBER, p_hometown IN VARCHAR2)\nIS\nBEGIN\n    UPDATE PEOPLE\n    SET HOMETOWN = p_hometown\n    WHERE PEOPLE_ID = p_gymnast_id;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  update_gymnast_hometown(1, 'Los Angeles');\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_hometown(2, 'Chicago');\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_hometown(4, 'New York');\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_hometown(3, 'Houston');\n  COMMIT;\nEND;",
      "BEGIN\n  update_gymnast_hometown(1, 'San Francisco');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `update_gymnast_hometown` that updates the HOMETOWN column in the PEOPLE table for the record where PEOPLE_ID matches the input parameter `p_gymnast_id`, setting it to the new value provided in the `p_hometown` parameter.",
    "natural_language": "Create procedure `update_gymnast_hometown` to set HOMETOWN in PEOPLE for a given PEOPLE_ID.",
    "id": 288
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_register_customer_order` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_order_date` of type `VARCHAR2`, and `p_order_status` of type `VARCHAR2`. The purpose of this procedure is to register a new customer order into the `CUSTOMER_ORDERS` table, but only if the specified customer exists in the `CUSTOMERS` table.\n\nUpon execution, the procedure first declares two local variables: `v_order_id` of type `NUMBER` to store the generated order identifier, and `v_customer_exists` of type `NUMBER` to store a count indicating the presence of the customer.\n\nThe procedure then performs a `SELECT` operation to count the number of records in the `CUSTOMERS` table where the `CUSTOMER_ID` column matches the value provided in the `p_customer_id` input parameter. The result of this count is stored in the `v_customer_exists` variable.\n\nFollowing this, a conditional check is performed: `IF v_customer_exists > 0 THEN`. This condition evaluates whether the customer identified by `p_customer_id` actually exists in the `CUSTOMERS` table.\n\nIf the customer exists (i.e., `v_customer_exists` is greater than 0), the procedure proceeds to generate a new `ORDER_ID`. It does this by performing another `SELECT` operation to find the maximum value of the `ORDER_ID` column from the `CUSTOMER_ORDERS` table and then adding 1 to it. This calculated value is stored in the `v_order_id` variable.\n\nImmediately after attempting to generate `v_order_id`, another conditional check is performed: `IF v_order_id IS NULL THEN`. This condition handles the scenario where the `CUSTOMER_ORDERS` table might be empty, resulting in `MAX(ORDER_ID)` returning `NULL`. If `v_order_id` is `NULL`, it is then explicitly set to `1`, ensuring the first order receives an `ORDER_ID` of 1.\n\nFinally, if the customer exists, an `INSERT` operation is executed to add a new record into the `CUSTOMER_ORDERS` table. The values inserted are: `v_order_id` into the `ORDER_ID` column, `p_customer_id` into the `CUSTOMER_ID` column, `p_order_date` into the `ORDER_DATE` column, and `p_order_status` into the `ORDER_STATUS_CODE` column.\n\nIf the initial `IF v_customer_exists > 0 THEN` condition evaluates to false (meaning the customer does not exist), no further operations are performed, and the procedure concludes without inserting an order.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_register_customer_order(p_customer_id IN NUMBER, p_order_date IN VARCHAR2, p_order_status IN VARCHAR2)\nIS\n    v_order_id NUMBER;\n    v_customer_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_customer_exists FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    IF v_customer_exists > 0 THEN\n        SELECT MAX(ORDER_ID) + 1 INTO v_order_id FROM CUSTOMER_ORDERS;\n        IF v_order_id IS NULL THEN\n            v_order_id := 1;\n        END IF;\n        INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n        VALUES (v_order_id, p_customer_id, p_order_date, p_order_status);\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_register_customer_order(1, '2024-01-15 10:30:00', 'New');\n  commit;\nEND;",
      "BEGIN\n  proc_register_customer_order(4, '2024-01-16 14:45:00', 'Processing');\n  commit;\nEND;",
      "BEGIN\n  proc_register_customer_order(5, '2024-01-17 09:15:00', 'Pending');\n  commit;\nEND;",
      "BEGIN\n  proc_register_customer_order(12, '2024-01-18 16:20:00', 'Shipped');\n  commit;\nEND;",
      "BEGIN\n  proc_register_customer_order(3, '2024-01-19 11:00:00', 'Completed');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_register_customer_order` that inserts a new order into the CUSTOMER_ORDERS table only if the customer exists in the CUSTOMERS table. It generates a new ORDER_ID by finding the maximum existing ID and adding 1, handling the case where the table is empty. The procedure inserts the generated ORDER_ID, customer ID, order date, and order status.",
    "natural_language": "Make a stored procedure called `proc_register_customer_order` that puts a new order into the CUSTOMER_ORDERS table, but only if that customer is already in the CUSTOMERS table somewhere. It should figure out a new ORDER_ID by looking at the current highest one and bumping it up a bit, making sure it works even if there's nothing in the table yet. The procedure needs to add this new ID, the customer's identifier, when the order happened, and what state it's in.",
    "id": 289
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_add_order_item` that accepts three input parameters: `p_order_id` of data type `NUMBER`, representing the unique identifier of an order; `p_product_id` of data type `NUMBER`, representing the unique identifier of a product; and `p_order_quantity` of data type `VARCHAR2`, representing the quantity of the product to be ordered. The procedure declares three local variables: `v_order_item_id` of data type `NUMBER`, intended to store the generated unique identifier for the new order item; `v_order_exists` of data type `NUMBER`, intended to store a count indicating whether the provided order ID exists; and `v_product_exists` of data type `NUMBER`, intended to store a count indicating whether the provided product ID exists. The procedure first executes a `SELECT COUNT(*)` statement to count the number of rows in the `CUSTOMER_ORDERS` table where the `ORDER_ID` column matches the value provided in the `p_order_id` input parameter, storing this count into the `v_order_exists` variable. Subsequently, it executes another `SELECT COUNT(*)` statement to count the number of rows in the `PRODUCTS` table where the `PRODUCT_ID` column matches the value provided in the `p_product_id` input parameter, storing this count into the `v_product_exists` variable. Following these checks, the procedure enters a conditional block (`IF`) that evaluates whether both `v_order_exists` is greater than 0 AND `v_product_exists` is greater than 0. This condition ensures that both the specified order and product exist in their respective tables before proceeding. If this condition is true, the procedure then executes a `SELECT MAX(ORDER_ITEM_ID) + 1` statement from the `ORDER_ITEMS` table to determine the next available `ORDER_ITEM_ID`, storing this calculated value into the `v_order_item_id` variable. Immediately after, it checks if `v_order_item_id` is `NULL` using an `IF v_order_item_id IS NULL THEN` statement. If `v_order_item_id` is indeed `NULL` (which would occur if the `ORDER_ITEMS` table is empty), it assigns the value `1` to `v_order_item_id`. Finally, within the same conditional block, if both the order and product exist, the procedure executes an `INSERT INTO` statement to add a new row into the `ORDER_ITEMS` table. This new row includes the `v_order_item_id` for the `ORDER_ITEM_ID` column, the `p_order_id` input parameter for the `ORDER_ID` column, the `p_product_id` input parameter for the `PRODUCT_ID` column, and the `p_order_quantity` input parameter for the `ORDER_QUANTITY` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_add_order_item(p_order_id IN NUMBER, p_product_id IN NUMBER, p_order_quantity IN VARCHAR2)\nIS\n    v_order_item_id NUMBER;\n    v_order_exists NUMBER;\n    v_product_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_order_exists FROM CUSTOMER_ORDERS WHERE ORDER_ID = p_order_id;\n    SELECT COUNT(*) INTO v_product_exists FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n    IF v_order_exists > 0 AND v_product_exists > 0 THEN\n        SELECT MAX(ORDER_ITEM_ID) + 1 INTO v_order_item_id FROM ORDER_ITEMS;\n        IF v_order_item_id IS NULL THEN\n            v_order_item_id := 1;\n        END IF;\n        INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n        VALUES (v_order_item_id, p_order_id, p_product_id, p_order_quantity);\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_add_order_item(1, 1, '3');\n  commit;\nEND;",
      "BEGIN\n  proc_add_order_item(2, 2, '1');\n  commit;\nEND;",
      "BEGIN\n  proc_add_order_item(3, 3, '5');\n  commit;\nEND;",
      "BEGIN\n  proc_add_order_item(1, 2, '2');\n  commit;\nEND;",
      "BEGIN\n  proc_add_order_item(2, 1, '4');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_add_order_item` that inserts a new item into the ORDER_ITEMS table only if both the specified order exists in CUSTOMER_ORDERS and the product exists in PRODUCTS. It generates a new ORDER_ITEM_ID by finding the maximum existing ID and adding 1, handling the case where the table is empty. The procedure inserts the generated ID, order ID, product ID, and quantity.",
    "natural_language": "Write a stored procedure called `proc_add_order_item` to insert a new item into the ORDER_ITEMS table. Ensure the specified order exists in CUSTOMER_ORDERS and the product exists in PRODUCTS before inserting. Generate a new ORDER_ITEM_ID by taking the maximum existing ID and adding 1, and handle the scenario where the table is empty. Insert the generated ID along with the order ID, product ID, and quantity.",
    "id": 290
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_create_customer_address` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_customer_name` of type `VARCHAR2`, and `p_address_details` of type `VARCHAR2`. The procedure declares three local variables: `v_address_id` of type `NUMBER`, `v_customer_exists` of type `NUMBER`, and `v_truncated_address` of type `VARCHAR2(255)`. The execution begins by assigning a truncated version of the `p_address_details` parameter to the `v_truncated_address` variable. This truncation is performed using the `SUBSTRB` function, which extracts a substring of bytes from `p_address_details`, starting from the first byte and extending for a maximum of 255 bytes. Next, the procedure queries the `CUSTOMERS` table to determine if a customer with the provided `p_customer_id` already exists. It does this by performing a `SELECT COUNT(*)` operation, storing the count of matching rows into the `v_customer_exists` variable, where the `CUSTOMER_ID` column equals the `p_customer_id` parameter. Following this, a conditional block is executed: `IF v_customer_exists = 0 THEN`. This means the subsequent operations will only proceed if no customer with the given `p_customer_id` was found in the `CUSTOMERS` table. Inside this conditional block, the procedure first attempts to determine a new `ADDRESS_ID`. It does this by performing a `SELECT MAX(ADDRESS_ID) + 1` operation from the `ADDRESSES` table, storing the result into `v_address_id`. If the `v_address_id` obtained from this query is `NULL` (which would happen if the `ADDRESSES` table is empty), then `v_address_id` is explicitly set to `1`. After determining the `v_address_id`, the procedure performs an `INSERT` operation into the `ADDRESSES` table. It inserts a new row with the `ADDRESS_ID` column set to the value of `v_address_id` and the `ADDRESS_DETAILS` column set to the value of `v_truncated_address`. Immediately after this, another `INSERT` operation is performed, this time into the `CUSTOMERS` table. A new customer record is inserted with the `CUSTOMER_ID` column set to `p_customer_id`, the `ADDRESS_ID` column set to `v_address_id`, the `CUSTOMER_NAME` column set to `p_customer_name`, and the `CUSTOMER_ADDRESS` column set to `v_truncated_address`. The `CUSTOMER_PHONE`, `CUSTOMER_EMAIL`, `PAYMENT_METHOD_CODE`, and `CUSTOMER_NUMBER` columns are all explicitly set to `NULL` during this insertion. The conditional block then concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_create_customer_address(p_customer_id IN NUMBER, p_customer_name IN VARCHAR2, p_address_details IN VARCHAR2)\nIS\n    v_address_id NUMBER;\n    v_customer_exists NUMBER;\n    v_truncated_address VARCHAR2(255);\nBEGIN\n    v_truncated_address := SUBSTRB(p_address_details, 1, 255);\n    SELECT COUNT(*) INTO v_customer_exists FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    IF v_customer_exists = 0 THEN\n        SELECT MAX(ADDRESS_ID) + 1 INTO v_address_id FROM ADDRESSES;\n        IF v_address_id IS NULL THEN\n            v_address_id := 1;\n        END IF;\n        INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS)\n        VALUES (v_address_id, v_truncated_address);\n        INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER)\n        VALUES (p_customer_id, v_address_id, p_customer_name, v_truncated_address, NULL, NULL, NULL, NULL);\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_create_customer_address(6, 'Alice', '123 Elm Street Apt. 4B');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(7, 'Bob', '456 Oak Avenue Suite 12');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(8, 'Charlie', '789 Pine Road');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(9, 'Diana', '101 Maple Lane');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(10, 'Eve', '202 Birch Boulevard');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_create_customer_address` that accepts a customer ID, name, and address details. It checks if the customer ID already exists. If not, it generates a new address ID, inserts a truncated address (255 bytes) into the ADDRESSES table, and then inserts a new customer record with the provided ID, name, and address, setting other columns to NULL.",
    "natural_language": "Please construct a stored procedure designated as `proc_create_customer_address`. This procedure is to accept parameters for a customer identifier, a customer name, and address details. Its function is to verify the non-existence of the provided customer ID. Should the ID be absent, the procedure shall generate a new address identifier, insert a version of the address truncated to 255 bytes into the ADDRESSES table, and subsequently insert a new customer record utilizing the supplied identifier, name, and the generated address ID. All other columns within this new customer record are to be initialized with NULL values.",
    "id": 291
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_process_customer_data` that accepts three input parameters: a numeric `p_customer_id`, a string `p_new_name`, and a string `p_new_phone`. The procedure first declares local variables `v_current_name`, `v_current_phone`, and `v_truncated_phone`, each capable of holding up to 255 characters. It begins execution by using the `SUBSTRB` function to assign the first 255 bytes of the input parameter `p_new_phone` to the variable `v_truncated_phone`. It then performs a `SELECT` statement on the `CUSTOMERS` table to retrieve the existing `CUSTOMER_NAME` and `CUSTOMER_PHONE` columns for the row where the `CUSTOMER_ID` column matches the input parameter `p_customer_id`, storing these values into the local variables `v_current_name` and `v_current_phone`. The procedure uses a complex conditional `IF` statement to determine which, if any, columns to update. The condition checks for inequality between the current and new values while also handling `NULL` comparisons: it evaluates whether both the name and the truncated phone number are different from their current values (accounting for `NULL` states). If this compound condition is true, it executes an `UPDATE` statement on the `CUSTOMERS` table for the matching `CUSTOMER_ID`, setting both the `CUSTOMER_NAME` column to `p_new_name` and the `CUSTOMER_PHONE` column to `v_truncated_phone`. If only the name condition is met (the current name differs from `p_new_name` or one is `NULL` while the other is not), it executes an `UPDATE` statement that sets only the `CUSTOMER_NAME` column to `p_new_name` for the target customer. If only the phone condition is met (the current phone differs from `v_truncated_phone` or one is `NULL` while the other is not), it executes an `UPDATE` statement that sets only the `CUSTOMER_PHONE` column to `v_truncated_phone` for the target customer. The procedure includes an `EXCEPTION` handler that catches the `NO_DATA_FOUND` exception, which occurs if the initial `SELECT` statement finds no matching customer, and in that case, it uses `DBMS_OUTPUT.PUT_LINE` to display a message stating the customer ID was not found; for any other exceptions, it uses the `RAISE` statement to re-raise the error to the calling program.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_process_customer_data(p_customer_id IN NUMBER, p_new_name IN VARCHAR2, p_new_phone IN VARCHAR2)\nIS\n    v_current_name VARCHAR2(255);\n    v_current_phone VARCHAR2(255);\n    v_truncated_phone VARCHAR2(255);\nBEGIN\n    v_truncated_phone := SUBSTRB(p_new_phone, 1, 255);\n    \n    SELECT CUSTOMER_NAME, CUSTOMER_PHONE INTO v_current_name, v_current_phone\n    FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    \n    IF (v_current_name != p_new_name OR (v_current_name IS NULL AND p_new_name IS NOT NULL) OR (v_current_name IS NOT NULL AND p_new_name IS NULL))\n       AND (v_current_phone != v_truncated_phone OR (v_current_phone IS NULL AND v_truncated_phone IS NOT NULL) OR (v_current_phone IS NOT NULL AND v_truncated_phone IS NULL)) THEN\n        UPDATE CUSTOMERS\n        SET CUSTOMER_NAME = p_new_name,\n            CUSTOMER_PHONE = v_truncated_phone\n        WHERE CUSTOMER_ID = p_customer_id;\n    ELSIF v_current_name != p_new_name OR (v_current_name IS NULL AND p_new_name IS NOT NULL) OR (v_current_name IS NOT NULL AND p_new_name IS NULL) THEN\n        UPDATE CUSTOMERS\n        SET CUSTOMER_NAME = p_new_name\n        WHERE CUSTOMER_ID = p_customer_id;\n    ELSIF v_current_phone != v_truncated_phone OR (v_current_phone IS NULL AND v_truncated_phone IS NOT NULL) OR (v_current_phone IS NOT NULL AND v_truncated_phone IS NULL) THEN\n        UPDATE CUSTOMERS\n        SET CUSTOMER_PHONE = v_truncated_phone\n        WHERE CUSTOMER_ID = p_customer_id;\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        DBMS_OUTPUT.PUT_LINE('Customer ID ' || p_customer_id || ' not found.');\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n    proc_process_customer_data(1, 'Jeromy Updated', '1-968-453-3485');\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(4, 'Madelynn', '1-909-419-5704');\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(5, 'Nya Newname', NULL);\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(1, NULL, '555-123-4567');\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(999, 'NonExistent', '000-000-0000');\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_process_customer_data` that accepts a customer ID, a new name, and a new phone number. It retrieves the customer's current name and phone. It then conditionally updates the CUSTOMERS table: updating both fields if both differ, or only the name or phone if only one differs. It handles NULL comparisons and outputs a message if the customer is not found.",
    "natural_language": "Make a stored procedure called `proc_process_customer_data` that takes a customer ID, a name, and a phone number. It should get the customer's current details. Then, if the new info is somewhat different from the old, update the CUSTOMERS table accordinglymaybe update both, or just one if only that part changed. Handle cases where things might be NULL. Also, if the customer isn't really found, show a message about it.",
    "id": 292
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named SP that accepts four input parameters: a numeric parameter P_COMPANY_ID, a numeric parameter P_RANK, a numeric parameter P_SALES_BILLION, and a numeric parameter P_PROFITS_BILLION; the procedure first declares a local numeric variable V_MEDIAN_MARKET_VALUE, then calculates the median market value from the COMPANY table by using the PERCENTILE_DISC(0.5) WITHIN GROUP analytic function on the MARKET_VALUE column ordered ascending and stores the result into the local variable, then performs a deletion from the STATION_COMPANY table for all rows where the COMPANY_ID column equals the input parameter P_COMPANY_ID and the RANK_OF_THE_YEAR column is greater than the input parameter P_RANK, and finally performs an insertion into the COMPANY table, populating the columns COMPANY_ID with the value of P_COMPANY_ID plus 100, RANK with the value of P_RANK, SALES_BILLION with the value of P_SALES_BILLION, PROFITS_BILLION with the value of P_PROFITS_BILLION, and MARKET_VALUE with the calculated median value stored in V_MEDIAN_MARKET_VALUE.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_company_id NUMBER, p_rank NUMBER, p_sales_billion NUMBER, p_profits_billion NUMBER) IS\n  v_median_market_value NUMBER;\nBEGIN\n  SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY MARKET_VALUE) INTO v_median_market_value FROM COMPANY;\n  DELETE FROM STATION_COMPANY WHERE COMPANY_ID = p_company_id AND RANK_OF_THE_YEAR > p_rank;\n  INSERT INTO COMPANY (COMPANY_ID, RANK, SALES_BILLION, PROFITS_BILLION, MARKET_VALUE) VALUES (p_company_id + 100, p_rank, p_sales_billion, p_profits_billion, v_median_market_value);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1, 2, 500.0, 50.0);\n  commit;\nEND;",
      "BEGIN\n  sp(2, 3, 600.0, 60.0);\n  commit;\nEND;",
      "BEGIN\n  sp(3, 1, 700.0, 70.0);\n  commit;\nEND;",
      "BEGIN\n  sp(4, 4, 800.0, 80.0);\n  commit;\nEND;",
      "BEGIN\n  sp(5, 5, 900.0, 90.0);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a company ID, rank, sales, and profits. It calculates the median market value from the COMPANY table. It then deletes records from the STATION_COMPANY table where the COMPANY_ID matches and the RANK_OF_THE_YEAR is greater than the provided rank. Finally, it inserts a new company record with an ID offset by 100, using the provided parameters and the calculated median market value.",
    "natural_language": "Write a stored procedure that takes a company ID, rank, sales, and profits as input. First, compute the median market value from the COMPANY table. Then, remove all records from the STATION_COMPANY table where the COMPANY_ID matches the given one and the RANK_OF_THE_YEAR exceeds the provided rank. Finally, add a new record to the company table with an ID increased by 100, using the given inputs and the calculated median market value.",
    "id": 293
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts four input parameters: `p_main_industry` of type `VARCHAR2`, `p_market_value_threshold` of type `NUMBER`, `p_rank_threshold` of type `NUMBER`, and `p_sales_billion` of type `NUMBER`. The procedure begins by declaring two local variables: `v_total_profits` of type `NUMBER` and `v_new_company_id` of type `NUMBER`. The first operation performed is a `SELECT` statement that calculates the sum of the `PROFITS_BILLION` column from the `COMPANY` table. This sum is stored in the `v_total_profits` variable. The rows considered for this summation are filtered by two conditions: the `MAIN_INDUSTRY` column must be equal to the value provided in the `p_main_industry` input parameter, and the `MARKET_VALUE` column must be greater than the value provided in the `p_market_value_threshold` input parameter. Following this, a `DELETE` statement is executed on the `STATION_COMPANY` table. This statement removes all rows where the `RANK_OF_THE_YEAR` column has a value less than the value provided in the `p_rank_threshold` input parameter. Next, the procedure determines a new, unique `COMPANY_ID`. This is achieved by executing a `SELECT` statement that retrieves the maximum value from the `COMPANY_ID` column in the `COMPANY` table. The `NVL` function is used to handle cases where no `COMPANY_ID` exists (i.e., the table is empty), in which case it defaults to 0. One is then added to this maximum value (or 0) to generate the `v_new_company_id`, ensuring uniqueness. Finally, an `INSERT` statement is executed to add a new row into the `COMPANY` table. The `COMPANY_ID` column of this new row is populated with the value from `v_new_company_id`. The `RANK` column is populated with the value from the `p_rank_threshold` input parameter. The `SALES_BILLION` column is populated with the value from the `p_sales_billion` input parameter. The `PROFITS_BILLION` column is populated with the value calculated and stored in the `v_total_profits` variable. The `MARKET_VALUE` column is populated with the value from the `p_market_value_threshold` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_main_industry VARCHAR2, p_market_value_threshold NUMBER, p_rank_threshold NUMBER, p_sales_billion NUMBER) IS\n  v_total_profits NUMBER;\n  v_new_company_id NUMBER;\nBEGIN\n  SELECT SUM(PROFITS_BILLION) INTO v_total_profits FROM COMPANY WHERE MAIN_INDUSTRY = p_main_industry AND MARKET_VALUE > p_market_value_threshold;\n\n  DELETE FROM STATION_COMPANY WHERE RANK_OF_THE_YEAR < p_rank_threshold;\n\n  -- Generate a new, unique COMPANY_ID\n  SELECT NVL(MAX(COMPANY_ID), 0) + 1 INTO v_new_company_id FROM COMPANY;\n\n  INSERT INTO COMPANY (COMPANY_ID, RANK, SALES_BILLION, PROFITS_BILLION, MARKET_VALUE)\n  VALUES (v_new_company_id, p_rank_threshold, p_sales_billion, v_total_profits, p_market_value_threshold);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp('Oil and gas', 200, 5, 100);\nEND;",
      "BEGIN\n  sp('Conglomerate', 150, 10, 50);\nEND;",
      "BEGIN\n  sp('Technology', 300, 2, 200);\nEND;",
      "BEGIN\n  sp('Automotive', 100, 15, 75);\nEND;",
      "BEGIN\n  sp('Finance', 500, 1, 300);\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a main industry, market value threshold, rank threshold, and sales figure. It calculates the total profits from the COMPANY table for the given industry where market value exceeds the threshold. It then deletes records from the STATION_COMPANY table where the rank is below the threshold. Finally, it generates a new company ID and inserts a new company record using the calculated total profits and the provided parameters.",
    "natural_language": "Create a procedure that takes an industry, market value limit, rank limit, and sales figure. It sums profits for companies in that industry with market value above the limit. It then removes STATION_COMPANY records where rank is below the limit. Finally, it generates a new ID and inserts a company using the total profits and given inputs.",
    "id": 294
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes five input parameters: p_company_id (a NUMBER representing the ID of a company), p_assets_threshold (a NUMBER specifying a threshold for the assets of companies in billions), p_rank (a NUMBER indicating the rank of the company for the year), p_market_value (a NUMBER representing the market value threshold for companies), and p_station_id (a NUMBER identifying a station). The procedure performs the following operations: First, it calculates the maximum value of the SALES_BILLION column from the COMPANY table for rows where the ASSETS_BILLION column exceeds the value of p_assets_threshold and stores this maximum value in a local variable v_max_sales. Next, it deletes rows from the COMPANY table where the COMPANY_ID column matches the value of p_company_id and the MARKET_VALUE column is less than p_market_value. Then, it performs a MERGE operation on the STATION_COMPANY table using a source dataset created with the SELECT statement from the dual table, which includes the values of p_station_id as station_id, p_company_id as company_id, and p_rank as rank_of_the_year. The MERGE operation checks if a match exists between the STATION_ID and COMPANY_ID columns in the STATION_COMPANY table and the corresponding values in the source dataset. If a match is found, it updates the RANK_OF_THE_YEAR column in the STATION_COMPANY table to the value of rank_of_the_year from the source dataset. If no match is found, it inserts a new row into the STATION_COMPANY table with the values of station_id, company_id, and rank_of_the_year from the source dataset.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_company_id NUMBER, p_assets_threshold NUMBER, p_rank NUMBER, p_market_value NUMBER, p_station_id NUMBER) IS\n  v_max_sales NUMBER;\nBEGIN\n  SELECT MAX(SALES_BILLION) INTO v_max_sales FROM COMPANY WHERE ASSETS_BILLION > p_assets_threshold;\n  DELETE FROM COMPANY WHERE COMPANY_ID = p_company_id AND MARKET_VALUE < p_market_value;\n  \n  MERGE INTO STATION_COMPANY sc\n  USING (SELECT p_station_id AS station_id, p_company_id AS company_id, p_rank AS rank_of_the_year FROM dual) src\n  ON (sc.STATION_ID = src.station_id AND sc.COMPANY_ID = src.company_id)\n  WHEN MATCHED THEN\n    UPDATE SET sc.RANK_OF_THE_YEAR = src.rank_of_the_year\n  WHEN NOT MATCHED THEN\n    INSERT (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR)\n    VALUES (src.station_id, src.company_id, src.rank_of_the_year);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1, 300.0, 5, 400.0, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2, 500.0, 3, 200.0, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(3, 200.0, 8, 250.0, 6);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(4, 100.0, 12, 150.0, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(5, 600.0, 1, 500.0, 1);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a company ID, assets threshold, rank, market value threshold, and station ID. It calculates the maximum sales from the COMPANY table where assets exceed the threshold. It then deletes company records where the ID matches and the market value is below the threshold. Finally, it merges data into the STATION_COMPANY table, updating the rank if a matching station-company pair exists, or inserting a new record otherwise.",
    "natural_language": "Can you create a stored procedure that takes a company ID, an assets threshold, a rank, a market value threshold, and a station ID? It should first determine the maximum sales from the COMPANY table for entries where assets are above the given threshold. Then, it must delete any company records where the company ID matches the input and the market value is below the specified threshold. Finally, can it merge data into the STATION_COMPANY table so that it updates the rank for an existing station-company pair or inserts a new record if no match is found?",
    "id": 295
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts four input parameters: a string parameter 'p_headquarters', a numeric parameter 'p_sales_threshold', a numeric parameter 'p_rank', and a numeric parameter 'p_profits_billion'. The procedure first declares two local numeric variables, 'v_min_market_value' and 'v_new_company_id'. It then queries the COMPANY table to find the minimum MARKET_VALUE from all rows where the HEADQUARTERS column exactly matches the provided 'p_headquarters' parameter and the SALES_BILLION column is greater than the provided 'p_sales_threshold' parameter, storing this result into the variable 'v_min_market_value'. Next, it queries the COMPANY table again to calculate a new COMPANY_ID by taking the maximum existing value from the COMPANY_ID column, using the NVL function to substitute a value of 0 if the maximum is null, and then adding 1 to this result, storing the final value into the variable 'v_new_company_id'. Following this, the procedure deletes all rows from the STATION_COMPANY table where the value in the RANK_OF_THE_YEAR column is greater than the provided 'p_rank' parameter. Finally, the procedure inserts a new row into the COMPANY table, populating the columns COMPANY_ID with the value from 'v_new_company_id', RANK with the value from 'p_rank', SALES_BILLION with the value from 'p_sales_threshold', PROFITS_BILLION with the value from 'p_profits_billion', and MARKET_VALUE with the value from 'v_min_market_value'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_headquarters VARCHAR2, p_sales_threshold NUMBER, p_rank NUMBER, p_profits_billion NUMBER) IS\n  v_min_market_value NUMBER;\n  v_new_company_id NUMBER;\nBEGIN\n  SELECT MIN(MARKET_VALUE) INTO v_min_market_value FROM COMPANY WHERE HEADQUARTERS = p_headquarters AND SALES_BILLION > p_sales_threshold;\n  SELECT NVL(MAX(COMPANY_ID), 0) + 1 INTO v_new_company_id FROM COMPANY;\n  DELETE FROM STATION_COMPANY WHERE RANK_OF_THE_YEAR > p_rank;\n  INSERT INTO COMPANY (COMPANY_ID, RANK, SALES_BILLION, PROFITS_BILLION, MARKET_VALUE) VALUES (v_new_company_id, p_rank, p_sales_threshold, p_profits_billion, v_min_market_value);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp('USA', 400, 1, 50);\n  commit;\nEND;",
      "BEGIN\n  sp('Netherlands', 200, 3, 25);\n  commit;\nEND;",
      "BEGIN\n  sp('USA', 450, 2, 60);\n  commit;\nEND;",
      "BEGIN\n  sp('Netherlands', 300, 4, 30);\n  commit;\nEND;",
      "BEGIN\n  sp('USA', 500, 5, 70);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp' that accepts a headquarters string, a sales threshold number, a rank number, and a profits billion number. It finds the minimum market value for companies matching the headquarters and exceeding the sales threshold. It generates a new company ID by incrementing the maximum existing ID. It deletes records from STATION_COMPANY where the rank exceeds the provided rank. Finally, it inserts a new company record using the generated ID, provided parameters, and the calculated minimum market value.",
    "natural_language": "Create a comprehensive stored procedure, which we shall name 'sp', that is designed to accept four distinct input parameters: a detailed headquarters location expressed as a string, a specific numerical sales threshold, a precise rank number, and a profits figure denominated in billions. This procedure will meticulously identify the absolute minimum market value from among all companies that are based in the specified headquarters and, importantly, whose sales figures surpass the provided threshold. Subsequently, it will cleverly generate a brand new, unique company identifier by systematically incrementing the maximum company ID currently present in the system. Following this, it will perform a targeted deletion, removing all records from the STATION_COMPANY table where the existing rank is strictly greater than the supplied rank parameter. To conclude its operation, the procedure will gracefully insert a fresh company record, meticulously populating it with the newly generated ID, all the originally provided parameter values, and the carefully calculated minimum market value.",
    "id": 296
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named delete_low_scoring_countries that accepts a single input parameter p_min_score of type NUMBER, which serves as the minimum acceptable overall score threshold, and performs a two-step deletion process: first, it deletes rows from the official_languages table for any country whose country_id matches the id of any country in the countries table where the overall_score column value is less than the provided p_min_score parameter, and second, it deletes rows directly from the countries table where the overall_score column value is also less than the provided p_min_score parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_low_scoring_countries(p_min_score IN NUMBER)\nIS\nBEGIN\n    DELETE FROM official_languages\n    WHERE country_id IN (\n        SELECT id\n        FROM countries\n        WHERE overall_score < p_min_score\n    );\n    \n    DELETE FROM countries\n    WHERE overall_score < p_min_score;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "BEGIN\n  delete_low_scoring_countries(90);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_low_scoring_countries(85.5);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_low_scoring_countries(95);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_low_scoring_countries(80);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_low_scoring_countries(70);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named 'delete_low_scoring_countries' that accepts a minimum score number. It deletes records from the official_languages table for countries with an overall score below the threshold, then deletes those countries from the countries table.",
    "natural_language": "Make a stored procedure 'delete_low_scoring_countries' that takes a minimum score. It removes low-scoring countries from official_languages, then from countries.",
    "id": 297
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_new_language` that accepts a single input parameter. This input parameter is named `p_language_name` and is of data type `VARCHAR2`. The purpose of this parameter is to provide the name of the new language to be inserted into the database. The procedure performs a single `INSERT` operation into the `languages` table. The `INSERT` statement populates two columns in the `languages` table: `id` and `name`. The value for the `id` column is determined by a subquery. This subquery selects the maximum value from the `id` column of the `languages` table and then adds `1` to this maximum value. This effectively generates a new, unique identifier for the new language, assuming `id` is a numeric primary key and new IDs are sequentially assigned. The value for the `name` column is directly taken from the input parameter `p_language_name`. There are no conditional statements or loops within this procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_language(p_language_name IN VARCHAR2)\nIS\nBEGIN\n    INSERT INTO languages (id, name)\n    SELECT MAX(id) + 1, p_language_name\n    FROM languages;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_language('Spanish');\nEND;",
      "BEGIN\n  insert_new_language('French');\nEND;",
      "BEGIN\n  insert_new_language('German');\nEND;",
      "BEGIN\n  insert_new_language('Mandarin');\nEND;",
      "BEGIN\n  insert_new_language('Arabic');\nEND;"
    ],
    "summary": "Create a stored procedure named 'insert_new_language' that accepts a language name string. It inserts a new record into the languages table, generating a new ID by adding 1 to the maximum existing ID and using the provided name.",
    "natural_language": "How can I create a stored procedure called 'insert_new_language' that takes a language name as input, inserts it into the languages table, and automatically generates a new ID by incrementing the current maximum ID by 1?",
    "id": 298
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes three parameters: p_manufacturer_code of type NUMBER, p_new_revenue of type NUMBER, and p_old_revenue of type OUT NUMBER. The procedure first retrieves the current value of the REVENUE column from the MANUFACTURERS table for the row where the CODE column matches the value of the input parameter p_manufacturer_code, and assigns this retrieved value to the output parameter p_old_revenue. Then, it updates the REVENUE column in the MANUFACTURERS table to the value of the input parameter p_new_revenue for the row where the CODE column matches the value of the input parameter p_manufacturer_code.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_manufacturer_revenue(p_manufacturer_code NUMBER, p_new_revenue NUMBER, p_old_revenue OUT NUMBER) IS\nBEGIN\n    SELECT REVENUE INTO p_old_revenue FROM MANUFACTURERS WHERE CODE = p_manufacturer_code;\n    UPDATE MANUFACTURERS SET REVENUE = p_new_revenue WHERE CODE = p_manufacturer_code;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_revenue NUMBER;\nBEGIN\n  update_manufacturer_revenue(1, 150, v_old_revenue);\nEND;",
      "DECLARE\n  v_old_revenue NUMBER;\nBEGIN\n  update_manufacturer_revenue(2, 110, v_old_revenue);\nEND;",
      "DECLARE\n  v_old_revenue NUMBER;\nBEGIN\n  update_manufacturer_revenue(3, 60, v_old_revenue);\nEND;",
      "DECLARE\n  v_old_revenue NUMBER;\nBEGIN\n  update_manufacturer_revenue(1, 130, v_old_revenue);\nEND;",
      "DECLARE\n  v_old_revenue NUMBER;\nBEGIN\n  update_manufacturer_revenue(2, 90, v_old_revenue);\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a manufacturer code number and a new revenue number, and returns an old revenue number. It retrieves the current revenue for the specified manufacturer into the output parameter, then updates the revenue to the new value for that manufacturer.",
    "natural_language": "Create a procedure that takes a manufacturer code and new revenue, returns the old revenue, and updates it.",
    "id": 299
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `AnalyzeShopPerformance` that declares several local variables: `v_old_shops` of type `NUMBER` to store a count of shops, `v_new_shops` of type `NUMBER` to store another count of shops, `v_avg_quantity` of type `NUMBER` to store an average quantity, `v_xml_output` of type `XMLTYPE` to store XML data, and `v_carrier_name` of type `VARCHAR2(255)` to store a carrier name. The procedure begins by selecting the count of all rows from the `SHOP` table where the `OPEN_YEAR` column is less than 2010, and stores this count into the `v_old_shops` variable.\n\nNext, it evaluates a series of conditional statements based on the value of `v_old_shops`.\n\nIf `v_old_shops` is greater than 5, the procedure performs two operations:\n1. It selects the count of all rows from the `SHOP` table where the `OPEN_YEAR` column is greater than or equal to 2010, and stores this count into the `v_new_shops` variable.\n2. It deletes all rows from the `STOCK` table where the `QUANTITY` column is equal to 0.\n\nElse if `v_old_shops` is greater than 2 (and not greater than 5), the procedure performs two operations:\n1. It calculates the average of all values in the `QUANTITY` column from the `STOCK` table, and stores this average into the `v_avg_quantity` variable.\n2. It inserts a new row into the `STOCK` table with `SHOP_ID` set to 100, `DEVICE_ID` set to 100, and `QUANTITY` set to the value of `v_avg_quantity`.\n\nElse if `v_old_shops` is greater than 0 (and not greater than 2), the procedure performs three operations:\n1. It constructs an XMLTYPE object containing an `<analysis>` root element with an `<old>` child element whose content is the value of `v_old_shops`, and assigns this XMLTYPE object to the `v_xml_output` variable.\n2. It selects the value of the `CARRIER` column from the `DEVICE` table where the `DEVICE_ID` column is equal to 1, and stores this value into the `v_carrier_name` variable.\n3. It updates the `CARRIER` column to 'Analyzed' in the `DEVICE` table for the row where the `DEVICE_ID` column is equal to 2.\n\nElse (if `v_old_shops` is 0 or less), the procedure iterates through a loop. For each `SHOP_ID` from the `SHOP` table, up to a maximum of 3 rows (due to `ROWNUM < 4`), it inserts a new row into the `STOCK` table with `SHOP_ID` set to the current `rec.SHOP_ID`, `DEVICE_ID` set to 5, and `QUANTITY` set to 15.\n\nFollowing these conditional statements, the procedure checks another condition:\nIf `v_avg_quantity` is greater than 100, it deletes all rows from the `STOCK` table where the `DEVICE_ID` column is equal to 99. Note that `v_avg_quantity` would only have a value if the `ELSIF v_old_shops > 2` branch was executed.\n\nFinally, the procedure executes a `CASE` statement based on the value of `v_old_shops`:\n1. When `v_old_shops` is equal to 1, it inserts a new row into the `STOCK` table with `SHOP_ID` set to 88, `DEVICE_ID` set to 88, and `QUANTITY` set to 88.\n2. When `v_old_shops` is equal to 2, it updates the `LOCATION` column to 'Updated' in the `SHOP` table for the row where the `SHOP_ID` column is equal to 1.\n3. For any other value of `v_old_shops`, no operation is performed (represented by `NULL`).",
    "plsql": "CREATE OR REPLACE PROCEDURE AnalyzeShopPerformance\nIS\n    v_old_shops NUMBER;\n    v_new_shops NUMBER;\n    v_avg_quantity NUMBER;\n    v_xml_output XMLTYPE;\n    v_carrier_name VARCHAR2(255);\nBEGIN\n    SELECT COUNT(*) INTO v_old_shops FROM SHOP WHERE OPEN_YEAR < 2010;\n    \n    IF v_old_shops > 5 THEN\n        SELECT COUNT(*) INTO v_new_shops FROM SHOP WHERE OPEN_YEAR >= 2010;\n        DELETE FROM STOCK WHERE QUANTITY = 0;\n    ELSIF v_old_shops > 2 THEN\n        SELECT AVG(QUANTITY) INTO v_avg_quantity FROM STOCK;\n        INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (100, 100, v_avg_quantity);\n    ELSIF v_old_shops > 0 THEN\n        v_xml_output := XMLTYPE('<analysis><old>' || v_old_shops || '</old></analysis>');\n        SELECT CARRIER INTO v_carrier_name FROM DEVICE WHERE DEVICE_ID = 1;\n        UPDATE DEVICE SET CARRIER = 'Analyzed' WHERE DEVICE_ID = 2;\n    ELSE\n        FOR rec IN (SELECT SHOP_ID FROM SHOP WHERE ROWNUM < 4) LOOP\n            INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (rec.SHOP_ID, 5, 15);\n        END LOOP;\n    END IF;\n    \n    IF v_avg_quantity > 100 THEN\n        DELETE FROM STOCK WHERE DEVICE_ID = 99;\n    END IF;\n    \n    CASE v_old_shops\n        WHEN 1 THEN\n            INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (88, 88, 88);\n        WHEN 2 THEN\n            UPDATE SHOP SET LOCATION = 'Updated' WHERE SHOP_ID = 1;\n        ELSE\n            NULL;\n    END CASE;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "BEGIN\n  AnalyzeShopPerformance;\nEND;"
    ],
    "summary": "Create a stored procedure named 'AnalyzeShopPerformance' that counts shops opened before 2010. Based on this count, it performs different operations: if >5, count new shops and delete zero-quantity stock; if >2, calculate average stock quantity and insert a stock record; if >0, generate XML, fetch a carrier name, and update a device carrier. If count is 0 or less, insert stock records for up to three shops. If the average quantity (from the >2 branch) exceeds 100, delete stock for device 99. Finally, a case statement performs specific inserts or updates if the old shop count is exactly 1 or 2.",
    "natural_language": "How can I create a stored procedure called 'AnalyzeShopPerformance' that counts shops opened before 2010 and then, based on that count, performs different actions? Specifically, if the count is greater than 5, how does it count new shops and delete stock with zero quantity? If the count is greater than 2, how does it calculate the average stock quantity and insert a stock record? If the count is greater than 0, how does it generate XML, fetch a carrier name, and update a device carrier? What happens if the count is 0 or less, and it inserts stock records for up to three shops? Furthermore, if the average quantity calculated in the greater-than-2 branch exceeds 100, how does it delete stock for device 99? Finally, how does a case statement perform specific inserts or updates if the old shop count is exactly 1 or 2?",
    "id": 300
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named TransformCarrierData that begins by declaring local variables: v_carrier_devices as a NUMBER to hold a count, v_total_stock as a NUMBER for a sum, v_shop_year as a NUMBER for a year value, v_xml_transform as an XMLTYPE for XML data, and v_device_name as a VARCHAR2(255) for a text value. The procedure first queries the DEVICE table to count the number of rows where the CARRIER column contains the substring 'Wireless' and stores this count in v_carrier_devices. If this count is greater than 10, it calculates the total sum of the QUANTITY column from the STOCK table into v_total_stock and then deletes from the STOCK table any rows where the DEVICE_ID is not found in the DEVICE_ID column of the DEVICE table. If the count is not greater than 10 but is greater than 5, it selects the OPEN_YEAR value from the SHOP table where SHOP_ID equals 1 into v_shop_year and then inserts a new row into the STOCK table with SHOP_ID 400, DEVICE_ID 400, and a QUANTITY calculated as the v_carrier_devices count multiplied by 10. If the count is not greater than 5 but is greater than 0, it constructs an XML document with a root element 'carrier' containing a child element 'devices' whose text is the v_carrier_devices count, assigning this XML to v_xml_transform, then selects the DEVICE column value from the DEVICE table where DEVICE_ID equals 2 into v_device_name, and finally updates the DEVICE table, setting the PACKAGE_VERSION column to the string 'Transformed' for the row where DEVICE_ID equals 1. If the count is 0 or less (the ELSE case), it executes a reverse FOR loop from 1 to 3, where for each iteration value i, it inserts a row into the STOCK table with SHOP_ID set to i + 500, DEVICE_ID set to i + 500, and QUANTITY set to i multiplied by 20. After this main conditional block, if the v_total_stock variable (which may only be populated in the first IF branch) is less than 1000, it deletes from the STOCK table any rows where the QUANTITY column is greater than 200. Finally, the procedure uses a CASE statement on the v_carrier_devices count: when the count is exactly 0, it updates the SHOP table, setting the SHOP_NAME column to 'No Wireless' for the row where SHOP_ID equals 3; when the count is exactly 1, it inserts a new row into the STOCK table with SHOP_ID 66, DEVICE_ID 66, and QUANTITY 66; for any other count value, it performs no action (NULL).",
    "plsql": "CREATE OR REPLACE PROCEDURE TransformCarrierData\nIS\n    v_carrier_devices NUMBER;\n    v_total_stock NUMBER;\n    v_shop_year NUMBER;\n    v_xml_transform XMLTYPE;\n    v_device_name VARCHAR2(255);\nBEGIN\n    SELECT COUNT(*) INTO v_carrier_devices FROM DEVICE WHERE CARRIER LIKE '%Wireless%';\n    \n    IF v_carrier_devices > 10 THEN\n        SELECT SUM(QUANTITY) INTO v_total_stock FROM STOCK;\n        DELETE FROM STOCK WHERE DEVICE_ID NOT IN (SELECT DEVICE_ID FROM DEVICE);\n    ELSIF v_carrier_devices > 5 THEN\n        SELECT OPEN_YEAR INTO v_shop_year FROM SHOP WHERE SHOP_ID = 1;\n        INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (400, 400, v_carrier_devices * 10);\n    ELSIF v_carrier_devices > 0 THEN\n        v_xml_transform := XMLTYPE('<carrier><devices>' || v_carrier_devices || '</devices></carrier>');\n        SELECT DEVICE INTO v_device_name FROM DEVICE WHERE DEVICE_ID = 2;\n        UPDATE DEVICE SET PACKAGE_VERSION = 'Transformed' WHERE DEVICE_ID = 1;\n    ELSE\n        FOR i IN REVERSE 1..3 LOOP\n            INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (i + 500, i + 500, i * 20);\n        END LOOP;\n    END IF;\n    \n    IF v_total_stock < 1000 THEN\n        DELETE FROM STOCK WHERE QUANTITY > 200;\n    END IF;\n    \n    CASE v_carrier_devices\n        WHEN 0 THEN\n            UPDATE SHOP SET SHOP_NAME = 'No Wireless' WHERE SHOP_ID = 3;\n        WHEN 1 THEN\n            INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (66, 66, 66);\n        ELSE\n            NULL;\n    END CASE;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "BEGIN\n  TransformCarrierData;\nEND;"
    ],
    "summary": "Create a stored procedure named TransformCarrierData. Declare variables: v_carrier_devices NUMBER, v_total_stock NUMBER, v_shop_year NUMBER, v_xml_transform XMLTYPE, v_device_name VARCHAR2(255). Count rows from DEVICE where CARRIER contains 'Wireless' into v_carrier_devices. If count > 10, sum QUANTITY from STOCK into v_total_stock and delete from STOCK where DEVICE_ID not in DEVICE.DEVICE_ID. Else if count > 5, select OPEN_YEAR from SHOP where SHOP_ID=1 into v_shop_year, then insert into STOCK values (400, 400, v_carrier_devices * 10). Else if count > 0, create XML '<carrier><devices>' || v_carrier_devices || '</devices></carrier>' into v_xml_transform, select DEVICE from DEVICE where DEVICE_ID=2 into v_device_name, update DEVICE set PACKAGE_VERSION='Transformed' where DEVICE_ID=1. Else (count <=0), loop i from 1 to 3 in reverse, insert into STOCK values (i+500, i+500, i*20). After main block, if v_total_stock < 1000, delete from STOCK where QUANTITY > 200. Finally, case v_carrier_devices: when 0 update SHOP set SHOP_NAME='No Wireless' where SHOP_ID=3; when 1 insert into STOCK values (66,66,66); else null.",
    "natural_language": "Create a stored procedure called TransformCarrierData. Within this procedure, carefully declare the following variables: a numeric variable v_carrier_devices to hold a count, another numeric variable v_total_stock for a sum total, a numeric variable v_shop_year for a specific year, an XMLTYPE variable v_xml_transform for structured data, and a string variable v_device_name with a length of up to 255 characters. First, determine the number of rows in the DEVICE table where the CARRIER field interestingly contains the substring 'Wireless', storing this count into v_carrier_devices. If this count is discovered to be greater than 10, then proceed to calculate the sum of the QUANTITY column from the entire STOCK table, placing the result into v_total_stock, and subsequently delete any records from the STOCK table where the DEVICE_ID does not correspond to an ID found in the DEVICE table. Alternatively, if the count is found to be greater than 5 but not more than 10, then retrieve the OPEN_YEAR from the SHOP table specifically for the shop with SHOP_ID equal to 1, storing it into v_shop_year, and then insert a new record into the STOCK table with the values (400, 400, and the product of v_carrier_devices multiplied by 10). In the next scenario, if the count is merely greater than 0, then dynamically construct an XML string formatted as '<carrier><devices>' concatenated with the v_carrier_devices value and '</devices></carrier>', assigning it to v_xml_transform, then fetch the DEVICE name from the DEVICE table for the device where DEVICE_ID equals 2, storing it into v_device_name, and finally update the DEVICE table by setting the PACKAGE_VERSION to 'Transformed' for the device where DEVICE_ID is 1. Should the count be less than or equal to 0, then meticulously execute a loop that iterates in reverse order from 1 to 3, and for each iteration i, insert a new row into the STOCK table with the calculated values (i+500, i+500, and i multiplied by 20). After completing this main conditional block, if the variable v_total_stock is found to be less than 1000, then perform a deletion from the STOCK table for all rows where the QUANTITY exceeds 200. Finally, evaluate v_carrier_devices using a case statement: when it is precisely 0, update the SHOP table to set the SHOP_NAME to 'No Wireless' for the shop where SHOP_ID is 3; when it is exactly 1, insert a single new record into STOCK with the values (66, 66, 66); for any other value, simply do nothing.",
    "id": 301
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ConsolidateShopStock` that declares several local variables: `v_location_count` of type `NUMBER` to store the count of distinct locations, `v_device_avg` of type `NUMBER` to store the average of device IDs, `v_shop_id_val` of type `NUMBER` to store a shop ID, `v_xml_consolidate` of type `XMLTYPE` to store an XML document, and `v_platform_type` of type `VARCHAR2(255)` to store a software platform type. The procedure begins by querying the `SHOP` table to count the number of distinct `LOCATION` values and stores this count in `v_location_count`.\n\nFollowing this initial query, the procedure executes a series of conditional statements based on the value of `v_location_count`.\n\nIf `v_location_count` is greater than 4:\n  The procedure calculates the average of all `DEVICE_ID` values from the `DEVICE` table and stores this average in `v_device_avg`.\n  Subsequently, it deletes all rows from the `STOCK` table where the `SHOP_ID` is greater than 1000.\n\nElse if `v_location_count` is greater than 2 (but not greater than 4):\n  The procedure selects the `SHOP_ID` from the `SHOP` table for the first row encountered (due to `ROWNUM = 1`) and stores this value in `v_shop_id_val`.\n  Then, it inserts a new row into the `STOCK` table with `SHOP_ID` set to 600, `DEVICE_ID` set to 600, and `QUANTITY` calculated as `v_location_count` multiplied by 15.\n\nElse if `v_location_count` is greater than 0 (but not greater than 2):\n  The procedure constructs an XML document as a string `<locations><count>` followed by the value of `v_location_count` and then `</count></locations>`, and converts this string into an `XMLTYPE` object, storing it in `v_xml_consolidate`.\n  It then selects the `SOFTWARE_PLATFORM` from the `DEVICE` table for the first row encountered (due to `ROWNUM = 1`) and stores this value in `v_platform_type`.\n  Finally, it updates the `OPEN_YEAR` column to 2024 in the `SHOP` table for the row where `SHOP_ID` is equal to 1.\n\nElse (if `v_location_count` is 0 or less):\n  An anonymous PL/SQL block is executed.\n  Within this block, a local variable `v_idx` of type `NUMBER` is declared and initialized to 1.\n  A `LOOP` statement is initiated.\n  Inside the loop, a new row is inserted into the `STOCK` table with `SHOP_ID` set to `v_idx + 700`, `DEVICE_ID` set to `v_idx + 700`, and `QUANTITY` set to 30.\n  The `v_idx` variable is then incremented by 1.\n  The loop continues until `v_idx` becomes greater than 3, at which point the loop is exited.\n\nAfter the initial conditional block, the procedure checks a second condition:\nIf `v_device_avg` is not `NULL` AND `v_device_avg` is less than 10:\n  It deletes all rows from the `STOCK` table where the `DEVICE_ID` is less than 5.\n\nFinally, the procedure executes a `CASE` statement based on the value of `v_location_count`:\nWhen `v_location_count` is greater than or equal to 3:\n  A new row is inserted into the `STOCK` table with `SHOP_ID` set to 55, `DEVICE_ID` set to 55, and `QUANTITY` set to 55.\nWhen `v_location_count` is less than or equal to 1:\n  The `CARRIER` column in the `DEVICE` table is updated to 'Consolidated' for the row where `DEVICE_ID` is equal to 3.\nFor any other case (i.e., `v_location_count` is 2):\n  No operation is performed (`NULL` statement).",
    "plsql": "CREATE OR REPLACE PROCEDURE ConsolidateShopStock\nIS\n    v_location_count NUMBER;\n    v_device_avg NUMBER;\n    v_shop_id_val NUMBER;\n    v_xml_consolidate XMLTYPE;\n    v_platform_type VARCHAR2(255);\nBEGIN\n    SELECT COUNT(DISTINCT LOCATION) INTO v_location_count FROM SHOP;\n    \n    IF v_location_count > 4 THEN\n        SELECT AVG(DEVICE_ID) INTO v_device_avg FROM DEVICE;\n        DELETE FROM STOCK WHERE SHOP_ID > 1000;\n    ELSIF v_location_count > 2 THEN\n        SELECT SHOP_ID INTO v_shop_id_val FROM SHOP WHERE ROWNUM = 1;\n        INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (600, 600, v_location_count * 15);\n    ELSIF v_location_count > 0 THEN\n        v_xml_consolidate := XMLTYPE('<locations><count>' || v_location_count || '</count></locations>');\n        SELECT SOFTWARE_PLATFORM INTO v_platform_type FROM DEVICE WHERE ROWNUM = 1;\n        UPDATE SHOP SET OPEN_YEAR = 2024 WHERE SHOP_ID = 1;\n    ELSE\n        DECLARE\n            v_idx NUMBER := 1;\n        BEGIN\n            LOOP\n                INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (v_idx + 700, v_idx + 700, 30);\n                v_idx := v_idx + 1;\n                EXIT WHEN v_idx > 3;\n            END LOOP;\n        END;\n    END IF;\n    \n    IF v_device_avg IS NOT NULL AND v_device_avg < 10 THEN\n        DELETE FROM STOCK WHERE DEVICE_ID < 5;\n    END IF;\n    \n    CASE \n        WHEN v_location_count >= 3 THEN\n            INSERT INTO STOCK (SHOP_ID, DEVICE_ID, QUANTITY) VALUES (55, 55, 55);\n        WHEN v_location_count <= 1 THEN\n            UPDATE DEVICE SET CARRIER = 'Consolidated' WHERE DEVICE_ID = 3;\n        ELSE\n            NULL;\n    END CASE;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "BEGIN\n    ConsolidateShopStock;\nEND;"
    ],
    "summary": "Create a stored procedure named ConsolidateShopStock. Declare variables: v_location_count NUMBER, v_device_avg NUMBER, v_shop_id_val NUMBER, v_xml_consolidate XMLTYPE, v_platform_type VARCHAR2(255). Count distinct LOCATION from SHOP into v_location_count. If count > 4, calculate average DEVICE_ID from DEVICE into v_device_avg and delete from STOCK where SHOP_ID > 1000. Else if count > 2, select SHOP_ID from SHOP where ROWNUM=1 into v_shop_id_val, insert into STOCK values (600, 600, v_location_count * 15). Else if count > 0, create XML '<locations><count>' || v_location_count || '</count></locations>' into v_xml_consolidate, select SOFTWARE_PLATFORM from DEVICE where ROWNUM=1 into v_platform_type, update SHOP set OPEN_YEAR=2024 where SHOP_ID=1. Else (count <=0), loop v_idx from 1 to 3, insert into STOCK values (v_idx+700, v_idx+700, 30). After main block, if v_device_avg is not null and v_device_avg < 10, delete from STOCK where DEVICE_ID < 5. Finally, case v_location_count: when >=3 insert into STOCK values (55,55,55); when <=1 update DEVICE set CARRIER='Consolidated' where DEVICE_ID=3; else null.",
    "natural_language": "Create procedure ConsolidateShopStock. Variables: v_location_count NUMBER, v_device_avg NUMBER, v_shop_id_val NUMBER, v_xml_consolidate XMLTYPE, v_platform_type VARCHAR2(255). Count distinct LOCATION from SHOP into v_location_count. If count > 4: average DEVICE_ID from DEVICE into v_device_avg, delete from STOCK where SHOP_ID > 1000. Else if count > 2: get first SHOP_ID into v_shop_id_val, insert into STOCK (600, 600, v_location_count * 15). Else if count > 0: create XML '<locations><count>' || v_location_count || '</count></locations>' into v_xml_consolidate, get first SOFTWARE_PLATFORM into v_platform_type, update SHOP set OPEN_YEAR=2024 where SHOP_ID=1. Else: loop v_idx 1 to 3, insert into STOCK (v_idx+700, v_idx+700, 30). After main block: if v_device_avg not null and < 10, delete from STOCK where DEVICE_ID < 5. Finally, case v_location_count: if >=3 insert into STOCK (55,55,55); if <=1 update DEVICE set CARRIER='Consolidated' where DEVICE_ID=3.",
    "id": 302
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_process_structure_data` that performs a series of data manipulation and analysis operations on the `BRIDGE`, `MILL`, and `ARCHITECT` tables. The procedure declares several local variables: `v_bridge_total` of type `NUMBER` to store the total count of records in the `BRIDGE` table, `v_mill_total` of type `NUMBER` to store the total count of records in the `MILL` table, `v_architect_exists` of type `NUMBER` to check for the existence of an architect, `v_correlation` of type `NUMBER` to store the population covariance between `BUILT_YEAR` and `ARCHITECT_ID` in the `MILL` table, `v_year_threshold` of type `NUMBER` to store an average built year, `v_length_threshold` of type `NUMBER` to store an average length in meters, and `v_counter` of type `NUMBER` to serve as a loop counter.\n\nThe procedure begins by querying the `BRIDGE` table to count all its records and stores this count in `v_bridge_total`. Subsequently, it queries the `MILL` table to count all its records and stores this count in `v_mill_total`. Following this, it calculates the population covariance (`COVAR_POP`) between the `BUILT_YEAR` and `ARCHITECT_ID` columns from the `MILL` table and stores the result in `v_correlation`.\n\nNext, the procedure initializes `v_counter` to 1 and enters a `WHILE` loop that continues as long as `v_counter` is less than or equal to 3. Inside this loop, it first checks for the existence of an architect in the `ARCHITECT` table by counting records where the `ID` column matches the `v_counter` value converted to a character string using `TO_CHAR(v_counter)`. The result is stored in `v_architect_exists`.\n\nIf `v_architect_exists` is greater than 0 (meaning an architect with the current `v_counter` ID exists), the procedure proceeds with nested conditional logic. It calculates the average `BUILT_YEAR` from the `MILL` table for records where `ARCHITECT_ID` equals `v_counter` and stores it in `v_year_threshold`. Concurrently, it calculates the average `LENGTH_METERS` from the `BRIDGE` table for records where `ARCHITECT_ID` equals `v_counter` and stores it in `v_length_threshold`.\n\nWithin this nested `IF` block:\n1. If `v_year_threshold` is greater than 1850 AND `v_length_threshold` is greater than 30, a new record is inserted into the `MILL` table with `ID` as `3000 + v_counter`, `ARCHITECT_ID` as `v_counter`, `NAME` as 'Combined Structure ' concatenated with `v_counter`, `LOCATION` as 'Hybrid Location', `TYPE` as 'MIXED', `BUILT_YEAR` as 1880, and `NOTES` as 'Dual threshold met'.\n2. Else if `v_year_threshold` IS NULL AND `v_length_threshold` IS NOT NULL, records are deleted from the `BRIDGE` table where `ARCHITECT_ID` equals `v_counter` AND `LENGTH_METERS` is less than 20.\n3. Else if `v_year_threshold` IS NOT NULL AND `v_length_threshold` IS NULL, records are deleted from the `MILL` table where `ARCHITECT_ID` equals `v_counter` AND `BUILT_YEAR` is less than 1700.\n4. Else (if none of the above conditions are met), a new record is inserted into the `ARCHITECT` table with `ID` as `500 + v_counter` converted to a character string using `TO_CHAR`, `NAME` as 'Generated Architect ' concatenated with `v_counter`, `NATIONALITY` as 'Synthetic', and `GENDER` as 'unknown'.\n\nAfter the inner conditional logic, `v_counter` is incremented by 1, and the `WHILE` loop continues.\n\nFollowing the completion of the `WHILE` loop, the procedure enters another conditional block based on the initial counts of `BRIDGE` and `MILL` records.\n1. If `v_bridge_total` is greater than `v_mill_total`, the procedure iterates through a cursor that selects distinct `ARCHITECT_ID` values from the `BRIDGE` table where `ARCHITECT_ID` is not NULL. For each `ARCHITECT_ID` found, a new record is inserted into the `MILL` table with `ID` as `4000 + rec.ARCHITECT_ID`, `ARCHITECT_ID` as `rec.ARCHITECT_ID`, `NAME` as 'Balance Mill for Bridge', `LOCATION` as 'Compensation Site', `TYPE` as 'BALANCE', `BUILT_YEAR` as 2024, and `NOTES` as 'Added for ratio'.\n2. Else if `v_mill_total` is greater than `v_bridge_total`, the procedure iterates through a cursor that selects distinct `ARCHITECT_ID` values from the `MILL` table where `ARCHITECT_ID` is not NULL. For each `ARCHITECT_ID` found, a new record is inserted into the `BRIDGE` table with `ID` as `5000 + rec.ARCHITECT_ID`, `ARCHITECT_ID` as `rec.ARCHITECT_ID`, `NAME` as 'Balance Bridge for Mill', `LOCATION` as 'Equilibrium Point', `LENGTH_METERS` as 50, and `LENGTH_FEET` as 164.\n\nFinally, the procedure evaluates the `v_correlation` value.\n1. If `v_correlation` is greater than 50, records are deleted from the `MILL` table where `BUILT_YEAR` is greater than 2000, and records are deleted from the `BRIDGE` table where `LENGTH_METERS` is greater than 100.\n2. Else if `v_correlation` is less than -50, a new record is inserted into the `BRIDGE` table with `ID` as 6000, `ARCHITECT_ID` as 1, `NAME` as 'Inverse Correlation Bridge', `LOCATION` as 'Statistical Anomaly', `LENGTH_METERS` as 75, and `LENGTH_FEET` as 246. Concurrently, a new record is inserted into the `MILL` table with `ID` as 6000, `ARCHITECT_ID` as 1, `NAME` as 'Inverse Correlation Mill', `LOCATION` as 'Math Anomaly', `TYPE` as 'DATA', `BUILT_YEAR` as 1800, and `NOTES` as 'Negative covariance'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_process_structure_data\nIS\n    v_bridge_total NUMBER;\n    v_mill_total NUMBER;\n    v_architect_exists NUMBER;\n    v_correlation NUMBER;\n    v_year_threshold NUMBER;\n    v_length_threshold NUMBER;\n    v_counter NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_bridge_total FROM BRIDGE;\n    SELECT COUNT(*) INTO v_mill_total FROM MILL;\n    SELECT COVAR_POP(BUILT_YEAR, ARCHITECT_ID) INTO v_correlation FROM MILL;\n\n    v_counter := 1;\n    WHILE v_counter <= 3 LOOP\n        SELECT COUNT(*) INTO v_architect_exists FROM ARCHITECT WHERE ID = TO_CHAR(v_counter);\n        IF v_architect_exists > 0 THEN\n            SELECT AVG(BUILT_YEAR) INTO v_year_threshold FROM MILL WHERE ARCHITECT_ID = v_counter;\n            SELECT AVG(LENGTH_METERS) INTO v_length_threshold FROM BRIDGE WHERE ARCHITECT_ID = v_counter;\n            IF v_year_threshold > 1850 AND v_length_threshold > 30 THEN\n                INSERT INTO MILL (ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, NOTES) VALUES (3000 + v_counter, v_counter, 'Combined Structure ' || v_counter, 'Hybrid Location', 'MIXED', 1880, 'Dual threshold met');\n            ELSIF v_year_threshold IS NULL AND v_length_threshold IS NOT NULL THEN\n                DELETE FROM BRIDGE WHERE ARCHITECT_ID = v_counter AND LENGTH_METERS < 20;\n            ELSIF v_year_threshold IS NOT NULL AND v_length_threshold IS NULL THEN\n                DELETE FROM MILL WHERE ARCHITECT_ID = v_counter AND BUILT_YEAR < 1700;\n            ELSE\n                INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) VALUES (TO_CHAR(500 + v_counter), 'Generated Architect ' || v_counter, 'Synthetic', 'unknown');\n            END IF;\n        END IF;\n        v_counter := v_counter + 1;\n    END LOOP;\n\n    IF v_bridge_total > v_mill_total THEN\n        FOR rec IN (SELECT DISTINCT ARCHITECT_ID FROM BRIDGE WHERE ARCHITECT_ID IS NOT NULL) LOOP\n            INSERT INTO MILL (ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, NOTES) VALUES (4000 + rec.ARCHITECT_ID, rec.ARCHITECT_ID, 'Balance Mill for Bridge', 'Compensation Site', 'BALANCE', 2024, 'Added for ratio');\n        END LOOP;\n    ELSIF v_mill_total > v_bridge_total THEN\n        FOR rec IN (SELECT DISTINCT ARCHITECT_ID FROM MILL WHERE ARCHITECT_ID IS NOT NULL) LOOP\n            INSERT INTO BRIDGE (ID, ARCHITECT_ID, NAME, LOCATION, LENGTH_METERS, LENGTH_FEET) VALUES (5000 + rec.ARCHITECT_ID, rec.ARCHITECT_ID, 'Balance Bridge for Mill', 'Equilibrium Point', 50, 164);\n        END LOOP;\n    END IF;\n\n    IF v_correlation > 50 THEN\n        DELETE FROM MILL WHERE BUILT_YEAR > 2000;\n        DELETE FROM BRIDGE WHERE LENGTH_METERS > 100;\n    ELSIF v_correlation < -50 THEN\n        INSERT INTO BRIDGE (ID, ARCHITECT_ID, NAME, LOCATION, LENGTH_METERS, LENGTH_FEET) VALUES (6000, 1, 'Inverse Correlation Bridge', 'Statistical Anomaly', 75, 246);\n        INSERT INTO MILL (ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, NOTES) VALUES (6000, 1, 'Inverse Correlation Mill', 'Math Anomaly', 'DATA', 1800, 'Negative covariance');\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  proc_process_structure_data;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_process_structure_data. Declare variables: v_bridge_total NUMBER, v_mill_total NUMBER, v_architect_exists NUMBER, v_correlation NUMBER, v_year_threshold NUMBER, v_length_threshold NUMBER, v_counter NUMBER. Count rows in BRIDGE into v_bridge_total. Count rows in MILL into v_mill_total. Calculate COVAR_POP(BUILT_YEAR, ARCHITECT_ID) from MILL into v_correlation. Set v_counter=1. While v_counter <=3 loop: count rows in ARCHITECT where ID = TO_CHAR(v_counter) into v_architect_exists. If v_architect_exists > 0 then: calculate avg(BUILT_YEAR) from MILL where ARCHITECT_ID=v_counter into v_year_threshold; calculate avg(LENGTH_METERS) from BRIDGE where ARCHITECT_ID=v_counter into v_length_threshold. If v_year_threshold > 1850 and v_length_threshold > 30 then insert into MILL values (3000+v_counter, v_counter, 'Combined Structure '||v_counter, 'Hybrid Location', 'MIXED', 1880, 'Dual threshold met'). Elsif v_year_threshold is null and v_length_threshold is not null then delete from BRIDGE where ARCHITECT_ID=v_counter and LENGTH_METERS < 20. Elsif v_year_threshold is not null and v_length_threshold is null then delete from MILL where ARCHITECT_ID=v_counter and BUILT_YEAR < 1700. Else insert into ARCHITECT values (TO_CHAR(500+v_counter), 'Generated Architect '||v_counter, 'Synthetic', 'unknown'). End if. v_counter := v_counter + 1. End loop. If v_bridge_total > v_mill_total then for each distinct ARCHITECT_ID from BRIDGE where ARCHITECT_ID is not null, insert into MILL values (4000+ARCHITECT_ID, ARCHITECT_ID, 'Balance Mill for Bridge', 'Compensation Site', 'BALANCE', 2024, 'Added for ratio'). Elsif v_mill_total > v_bridge_total then for each distinct ARCHITECT_ID from MILL where ARCHITECT_ID is not null, insert into BRIDGE values (5000+ARCHITECT_ID, ARCHITECT_ID, 'Balance Bridge for Mill', 'Equilibrium Point', 50, 164). End if. If v_correlation > 50 then delete from MILL where BUILT_YEAR > 2000; delete from BRIDGE where LENGTH_METERS > 100. Elsif v_correlation < -50 then insert into BRIDGE values (6000, 1, 'Inverse Correlation Bridge', 'Statistical Anomaly', 75, 246); insert into MILL values (6000, 1, 'Inverse Correlation Mill', 'Math Anomaly', 'DATA', 1800, 'Negative covariance'). End if.",
    "natural_language": "What steps should be taken to create a stored procedure named 'proc_process_structure_data' that performs the following operations? First, declare variables for totals, existence checks, correlation, thresholds, and a counter. Then, count the total rows in the BRIDGE and MILL tables. Calculate the population covariance between BUILT_YEAR and ARCHITECT_ID in the MILL table. Next, initialize a counter and loop from 1 to 3. For each counter value, check if an architect with that ID exists. If they do, calculate the average BUILT_YEAR for their mills and the average LENGTH_METERS for their bridges. If both averages exceed their respective thresholds (1850 and 30), insert a new mixed mill. If only the year average is missing, delete short bridges for that architect. If only the length average is missing, delete old mills for that architect. Otherwise, insert a new synthetic architect. After the loop, if there are more bridges than mills, insert balance mills for each distinct bridge architect. Conversely, if there are more mills, insert balance bridges for each distinct mill architect. Finally, if the calculated covariance is high, delete modern mills and long bridges, but if it is very low, insert records indicating an inverse correlation.",
    "id": 303
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_transform_architect_records` that performs a series of data transformations and manipulations across the `BRIDGE`, `MILL`, and `ARCHITECT` tables based on various conditions derived from existing data.\n\nThe procedure begins by declaring several local variables:\n- `v_max_bridge_length` of type `NUMBER`, intended to store the maximum length of bridges.\n- `v_min_mill_year` of type `NUMBER`, intended to store the minimum built year of mills.\n- `v_avg_covar` of type `NUMBER`, intended to store the population covariance between bridge lengths in meters and feet.\n- `v_nationality_count` of type `NUMBER`, intended to store the count of architects matching specific criteria.\n- `v_gender_distinct` of type `NUMBER`, intended to store the length of a gender string.\n- `v_temp_id` of type `NUMBER`, intended to serve as a temporary counter or identifier.\n\nThe procedure then proceeds with the following steps:\n\n1.  **Initial Data Retrieval:**\n    *   It selects the maximum value from the `LENGTH_METERS` column of the `BRIDGE` table and stores it into the `v_max_bridge_length` variable.\n    *   It selects the minimum value from the `BUILT_YEAR` column of the `MILL` table and stores it into the `v_min_mill_year` variable.\n    *   It calculates the population covariance (`COVAR_POP`) between the `LENGTH_METERS` and `LENGTH_FEET` columns of the `BRIDGE` table and stores the result into the `v_avg_covar` variable. This function returns a single aggregate value for the entire set of rows in the `BRIDGE` table.\n\n2.  **Conditional Block 1 (based on `v_max_bridge_length`):**\n    *   An `IF` statement checks if the `v_max_bridge_length` is greater than 80.\n    *   If the condition is true:\n        *   The `v_temp_id` variable is initialized to 1.\n        *   A `LOOP` structure is initiated, which continues as long as `v_temp_id` is not greater than 5.\n        *   Inside the loop:\n            *   It counts the number of records in the `ARCHITECT` table where the `NATIONALITY` column contains the substring '%American%' and the `ID` column (which is `VARCHAR2`) is equal to the character representation of `v_temp_id` (obtained using `TO_CHAR(v_temp_id)`). This count is stored in `v_nationality_count`.\n            *   Another nested `IF` statement checks if `v_nationality_count` is greater than 0.\n            *   If this nested condition is true, a new record is inserted into the `BRIDGE` table with the following values:\n                *   `ID`: `7000 + v_temp_id`\n                *   `ARCHITECT_ID`: `v_temp_id` (which is a `NUMBER` and is inserted into a `NUMBER` column)\n                *   `NAME`: 'National Bridge ' concatenated with `v_temp_id`\n                *   `LOCATION`: 'Heritage Site'\n                *   `LENGTH_METERS`: 60\n                *   `LENGTH_FEET`: 197\n            *   The `v_temp_id` variable is incremented by 1.\n\n3.  **Conditional Block 2 (based on `v_min_mill_year`):**\n    *   An `IF` statement checks if the `v_min_mill_year` is less than 1800.\n    *   If the condition is true:\n        *   A `FOR` loop iterates through a cursor that selects the `ID` and `GENDER` columns from the `ARCHITECT` table for all records where `GENDER` is not `NULL`. Each row is represented by `rec`.\n        *   Inside the loop:\n            *   The length of the `GENDER` column from the current `rec` is calculated using `LENGTH(rec.GENDER)` and stored in `v_gender_distinct`.\n            *   Another nested `IF` statement checks if `v_gender_distinct` is greater than 4.\n            *   If this nested condition is true, a new record is inserted into the `MILL` table with the following values:\n                *   `ID`: `8000 + TO_NUMBER(rec.ID)` (converting `rec.ID` from `VARCHAR2` to `NUMBER`)\n                *   `ARCHITECT_ID`: `TO_NUMBER(rec.ID)` (converting `rec.ID` from `VARCHAR2` to `NUMBER` for insertion into a `NUMBER` column)\n                *   `NAME`: 'Gender Mill ' concatenated with `rec.GENDER`\n                *   `LOCATION`: 'Diversity Location'\n                *   `TYPE`: 'CULTURAL'\n                *   `BUILT_YEAR`: 1820\n                *   `NOTES`: `rec.GENDER`\n            *   An `ELSIF` clause checks if `v_gender_distinct` is less than or equal to 4.\n            *   If this `ELSIF` condition is true, records are deleted from the `MILL` table where the `ARCHITECT_ID` column is equal to the numeric representation of `rec.ID` (obtained using `TO_NUMBER(rec.ID)`) and the `TYPE` column is 'OBSOLETE'.\n\n4.  **Conditional Block 3 (based on `v_avg_covar`):**\n    *   An `IF` statement checks if `v_avg_covar` is `BETWEEN` 0 and 1000 (inclusive).\n    *   If this condition is true:\n        *   A `DECLARE` block introduces a local variable `v_architect_name` of type `VARCHAR2(255)`.\n        *   Inside this block:\n            *   It selects the `NAME` column from the `ARCHITECT` table where the `ID` column is '1' and stores it into `v_architect_name`.\n            *   A new record is inserted into the `ARCHITECT` table with the following values:\n                *   `ID`: 'COVAR'\n                *   `NAME`: 'Covariance Analyst ' concatenated with `v_architect_name`\n                *   `NATIONALITY`: 'Statistical'\n                *   `GENDER`: 'data'\n            *   A new record is inserted into the `BRIDGE` table with the following values:\n                *   `ID`: 9000\n                *   `ARCHITECT_ID`: 1 (implicitly converted or explicitly `TO_NUMBER('1')` if `ARCHITECT.ID` was `VARCHAR2` and `BRIDGE.ARCHITECT_ID` is `NUMBER`)\n                *   `NAME`: 'Covariance Analysis Bridge'\n                *   `LOCATION`: 'Math Park'\n                *   `LENGTH_METERS`: 45\n                *   `LENGTH_FEET`: 148\n            *   A new record is inserted into the `MILL` table with the following values:\n                *   `ID`: 9000\n                *   `ARCHITECT_ID`: 1 (implicitly converted or explicitly `TO_NUMBER('1')` if `ARCHITECT.ID` was `VARCHAR2` and `MILL.ARCHITECT_ID` is `NUMBER`)\n                *   `NAME`: 'Covariance Analysis Mill'\n                *   `LOCATION`: 'Statistics Valley'\n                *   `TYPE`: 'RESEARCH'\n                *   `BUILT_YEAR`: 2024\n                *   `NOTES`: 'For covariance study'\n    *   An `ELSIF` clause checks if `v_avg_covar` is greater than 1000.\n    *   If this `ELSIF` condition is true:\n        *   Records are deleted from the `BRIDGE` table where `LENGTH_METERS` is greater than 90.\n        *   Records are deleted from the `MILL` table where `BUILT_YEAR` is less than 1500.\n    *   An `ELSE` clause handles all other cases for `v_avg_covar`.\n    *   If the `ELSE` condition is met, a new record is inserted into the `ARCHITECT` table with the following values:\n        *   `ID`: 'NEGATIVE'\n        *   `NAME`: 'Negative Covariance'\n        *   `NATIONALITY`: 'Mathematical'\n        *   `GENDER`: 'unknown'\n\n5.  **Conditional Block 4 (based on `v_max_bridge_length` and `v_min_mill_year`):**\n    *   An `IF` statement checks if `v_max_bridge_length` is less than 50 AND `v_min_mill_year` is greater than 1900.\n    *   If this condition is true:\n        *   The `NATIONALITY` column in the `ARCHITECT` table is updated by appending '_MODERN' to its current value. This update applies to architects whose `ID` (which is `VARCHAR2`) is found in the subquery result. The subquery selects the character representation of `ARCHITECT_ID` (obtained using `TO_CHAR(ARCHITECT_ID)`) from the `BRIDGE` table where `LENGTH_METERS` is less than 40.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_transform_architect_records\nIS\n    v_max_bridge_length NUMBER;\n    v_min_mill_year NUMBER;\n    v_avg_covar NUMBER;\n    v_nationality_count NUMBER;\n    v_gender_distinct NUMBER;\n    v_temp_id NUMBER;\nBEGIN\n    SELECT MAX(LENGTH_METERS) INTO v_max_bridge_length FROM BRIDGE;\n    SELECT MIN(BUILT_YEAR) INTO v_min_mill_year FROM MILL;\n    -- Corrected: Removed AVG as COVAR_POP already returns a single aggregate value for the entire set\n    SELECT COVAR_POP(LENGTH_METERS, LENGTH_FEET) INTO v_avg_covar FROM BRIDGE;\n\n    IF v_max_bridge_length > 80 THEN\n        v_temp_id := 1;\n        LOOP\n            EXIT WHEN v_temp_id > 5;\n            -- Ensure ARCHITECT.ID (VARCHAR2) is compared with TO_CHAR(v_temp_id)\n            SELECT COUNT(*) INTO v_nationality_count FROM ARCHITECT WHERE NATIONALITY LIKE '%American%' AND ID = TO_CHAR(v_temp_id);\n            IF v_nationality_count > 0 THEN\n                -- Ensure ARCHITECT_ID (NUMBER) is inserted as NUMBER\n                INSERT INTO BRIDGE (ID, ARCHITECT_ID, NAME, LOCATION, LENGTH_METERS, LENGTH_FEET) VALUES (7000 + v_temp_id, v_temp_id, 'National Bridge ' || v_temp_id, 'Heritage Site', 60, 197);\n            END IF;\n            v_temp_id := v_temp_id + 1;\n        END LOOP;\n    END IF;\n\n    IF v_min_mill_year < 1800 THEN\n        FOR rec IN (SELECT ID, GENDER FROM ARCHITECT WHERE GENDER IS NOT NULL) LOOP\n            v_gender_distinct := LENGTH(rec.GENDER);\n            IF v_gender_distinct > 4 THEN\n                -- Ensure ARCHITECT_ID (NUMBER) is inserted as NUMBER\n                INSERT INTO MILL (ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, NOTES) VALUES (8000 + TO_NUMBER(rec.ID), TO_NUMBER(rec.ID), 'Gender Mill ' || rec.GENDER, 'Diversity Location', 'CULTURAL', 1820, rec.GENDER);\n            ELSIF v_gender_distinct <= 4 THEN\n                -- Ensure ARCHITECT_ID (NUMBER) is compared with TO_NUMBER(rec.ID)\n                DELETE FROM MILL WHERE ARCHITECT_ID = TO_NUMBER(rec.ID) AND TYPE = 'OBSOLETE';\n            END IF;\n        END LOOP;\n    END IF;\n\n    IF v_avg_covar BETWEEN 0 AND 1000 THEN\n        DECLARE\n            v_architect_name VARCHAR2(255);\n        BEGIN\n            SELECT NAME INTO v_architect_name FROM ARCHITECT WHERE ID = '1';\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) VALUES ('COVAR', 'Covariance Analyst ' || v_architect_name, 'Statistical', 'data');\n            -- ARCHITECT_ID is NUMBER in BRIDGE, so '1' is implicitly converted or explicitly TO_NUMBER('1')\n            INSERT INTO BRIDGE (ID, ARCHITECT_ID, NAME, LOCATION, LENGTH_METERS, LENGTH_FEET) VALUES (9000, 1, 'Covariance Analysis Bridge', 'Math Park', 45, 148);\n            -- ARCHITECT_ID is NUMBER in MILL, so '1' is implicitly converted or explicitly TO_NUMBER('1')\n            INSERT INTO MILL (ID, ARCHITECT_ID, NAME, LOCATION, TYPE, BUILT_YEAR, NOTES) VALUES (9000, 1, 'Covariance Analysis Mill', 'Statistics Valley', 'RESEARCH', 2024, 'For covariance study');\n        END;\n    ELSIF v_avg_covar > 1000 THEN\n        DELETE FROM BRIDGE WHERE LENGTH_METERS > 90;\n        DELETE FROM MILL WHERE BUILT_YEAR < 1500;\n    ELSE\n        INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) VALUES ('NEGATIVE', 'Negative Covariance', 'Mathematical', 'unknown');\n    END IF;\n\n    IF v_max_bridge_length < 50 AND v_min_mill_year > 1900 THEN\n        -- Ensure ARCHITECT.ID (VARCHAR2) is compared with TO_CHAR(ARCHITECT_ID) from BRIDGE (NUMBER)\n        UPDATE ARCHITECT SET NATIONALITY = NATIONALITY || '_MODERN' WHERE ID IN (SELECT TO_CHAR(ARCHITECT_ID) FROM BRIDGE WHERE LENGTH_METERS < 40);\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "BEGIN\n  proc_transform_architect_records;\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_transform_architect_records. Declare variables: v_max_bridge_length NUMBER, v_min_mill_year NUMBER, v_avg_covar NUMBER, v_nationality_count NUMBER, v_gender_distinct NUMBER, v_temp_id NUMBER. Select max(LENGTH_METERS) from BRIDGE into v_max_bridge_length. Select min(BUILT_YEAR) from MILL into v_min_mill_year. Calculate COVAR_POP(LENGTH_METERS, LENGTH_FEET) from BRIDGE into v_avg_covar. If v_max_bridge_length > 80 then v_temp_id := 1; loop exit when v_temp_id > 5; count rows in ARCHITECT where NATIONALITY like '%American%' and ID = TO_CHAR(v_temp_id) into v_nationality_count; if v_nationality_count > 0 then insert into BRIDGE values (7000+v_temp_id, v_temp_id, 'National Bridge '||v_temp_id, 'Heritage Site', 60, 197); end if; v_temp_id := v_temp_id + 1; end loop; end if. If v_min_mill_year < 1800 then for each rec in (select ID, GENDER from ARCHITECT where GENDER is not null) loop: v_gender_distinct := LENGTH(rec.GENDER); if v_gender_distinct > 4 then insert into MILL values (8000+TO_NUMBER(rec.ID), TO_NUMBER(rec.ID), 'Gender Mill '||rec.GENDER, 'Diversity Location', 'CULTURAL', 1820, rec.GENDER); elsif v_gender_distinct <= 4 then delete from MILL where ARCHITECT_ID = TO_NUMBER(rec.ID) and TYPE = 'OBSOLETE'; end if; end loop; end if. If v_avg_covar between 0 and 1000 then declare v_architect_name VARCHAR2(255); select NAME from ARCHITECT where ID='1' into v_architect_name; insert into ARCHITECT values ('COVAR', 'Covariance Analyst '||v_architect_name, 'Statistical', 'data'); insert into BRIDGE values (9000, 1, 'Covariance Analysis Bridge', 'Math Park', 45, 148); insert into MILL values (9000, 1, 'Covariance Analysis Mill', 'Statistics Valley', 'RESEARCH', 2024, 'For covariance study'); elsif v_avg_covar > 1000 then delete from BRIDGE where LENGTH_METERS > 90; delete from MILL where BUILT_YEAR < 1500; else insert into ARCHITECT values ('NEGATIVE', 'Negative Covariance', 'Mathematical', 'unknown'); end if. If v_max_bridge_length < 50 and v_min_mill_year > 1900 then update ARCHITECT set NATIONALITY = NATIONALITY || '_MODERN' where ID in (select TO_CHAR(ARCHITECT_ID) from BRIDGE where LENGTH_METERS < 40); end if.",
    "natural_language": "Create proc_transform_architect_records. Declare v_max_bridge_length, v_min_mill_year, v_avg_covar, v_nationality_count, v_gender_distinct, v_temp_id. Get max bridge length into v_max_bridge_length. Get min mill year into v_min_mill_year. Calculate covariance into v_avg_covar. If max length > 80, loop 1 to 5: count American architects by ID; if count > 0, insert bridge. If min year < 1800, for each architect: if gender length > 4, insert mill; else if length <=4, delete obsolete mills. If covariance between 0 and 1000, insert analyst, bridge, and mill. If covariance > 1000, delete long bridges and old mills. Else insert negative covariance architect. If max length < 50 and min year > 1900, update architect nationalities.",
    "id": 304
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes two input parameters, p_club_id of type NUMBER and p_threshold of type NUMBER, and performs the following operations: First, it calculates the average age and the total count of members associated with a specific club by joining the MEMBER table and the CLUB_LEADER table on the MEMBER_ID column, filtering rows where the CLUB_ID column in the CLUB_LEADER table matches the value of p_club_id. The calculated average age is stored in the variable v_avg_age, and the count of members is stored in the variable v_count_members. Next, the procedure evaluates two conditional statements: if the count of members (v_count_members) is greater than zero and the average age (v_avg_age) exceeds the value of p_threshold, it inserts a new row into the CLUB table with the CLUB_ID column set to p_club_id plus 1000, the CLUB_NAME column set to the string 'Senior_' concatenated with the value of p_club_id, the TEAM_LEADER column set to the string 'Auto_Leader', and the OVERALL_RANKING column set to 99. Alternatively, if the count of members (v_count_members) is greater than zero and the average age (v_avg_age) is less than or equal to the value of p_threshold, it inserts a new row into the CLUB table with the CLUB_ID column set to p_club_id plus 2000, the CLUB_NAME column set to the string 'Junior_' concatenated with the value of p_club_id, the TEAM_LEADER column set to the string 'Auto_Leader', and the OVERALL_RANKING column set to 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_age(p_club_id NUMBER, p_threshold NUMBER)\nIS\n   v_avg_age NUMBER;\n   v_count_members NUMBER;\nBEGIN\n   SELECT AVG(m.AGE), COUNT(m.MEMBER_ID)\n   INTO v_avg_age, v_count_members\n   FROM MEMBER m\n   JOIN CLUB_LEADER cl ON m.MEMBER_ID = cl.MEMBER_ID\n   WHERE cl.CLUB_ID = p_club_id;\n\n   IF v_count_members > 0 AND v_avg_age > p_threshold THEN\n      INSERT INTO CLUB (CLUB_ID, CLUB_NAME, TEAM_LEADER, OVERALL_RANKING)\n      VALUES (p_club_id + 1000, 'Senior_' || p_club_id, 'Auto_Leader', 99);\n   ELSIF v_count_members > 0 AND v_avg_age <= p_threshold THEN\n      INSERT INTO CLUB (CLUB_ID, CLUB_NAME, TEAM_LEADER, OVERALL_RANKING)\n      VALUES (p_club_id + 2000, 'Junior_' || p_club_id, 'Auto_Leader', 1);\n   END IF;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_average_age(1, 20);\n  commit;\nEND;",
      "BEGIN\n  calculate_average_age(3, 25);\n  commit;\nEND;",
      "BEGIN\n  calculate_average_age(4, 18);\n  commit;\nEND;",
      "BEGIN\n  calculate_average_age(8, 22);\n  commit;\nEND;",
      "BEGIN\n  calculate_average_age(6, 30);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure with input parameters p_club_id NUMBER and p_threshold NUMBER. Declare variables v_avg_age NUMBER and v_count_members NUMBER. Calculate average age and count members by joining MEMBER and CLUB_LEADER on MEMBER_ID where CLUB_LEADER.CLUB_ID = p_club_id, store results into v_avg_age and v_count_members. If v_count_members > 0 and v_avg_age > p_threshold then insert into CLUB values (p_club_id+1000, 'Senior_'||p_club_id, 'Auto_Leader', 99). Elsif v_count_members > 0 and v_avg_age <= p_threshold then insert into CLUB values (p_club_id+2000, 'Junior_'||p_club_id, 'Auto_Leader', 1). End if.",
    "natural_language": "Create a procedure with inputs p_club_id and p_threshold. Compute average member age and member count for the given club. If members exist and average age exceeds threshold, insert a 'Senior' club record. If members exist and average age is at or below threshold, insert a 'Junior' club record.",
    "id": 305
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_member_nationality` that accepts two input parameters: `p_member_id` of type `NUMBER`, representing the unique identifier of a member, and `p_new_nationality` of type `VARCHAR2`, representing the new nationality to be assigned to the member. The procedure begins by declaring two local variables: `v_current_age` of type `NUMBER` to store the member's age, and `v_name_length` of type `NUMBER` to store the length of the member's name. It then executes a `SELECT` statement to retrieve the `AGE` and the `LENGTH` of the `NAME` column from the `MEMBER` table. These retrieved values are stored into the `v_current_age` and `v_name_length` variables, respectively. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `MEMBER_ID` column matches the input parameter `p_member_id` is considered. Following this data retrieval, the procedure enters a conditional block. The first condition checks if `v_current_age` is less than 20 AND `v_name_length` is greater than 10. If this condition is true, an `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the uppercase version of the `p_new_nationality` input parameter, achieved by using the `UPPER()` function. This update is applied only to the row where the `MEMBER_ID` column matches `p_member_id`. If the first condition is false, the procedure proceeds to an `ELSIF` condition. This condition checks if `v_current_age` is greater than or equal to 20 AND `v_current_age` is less than or equal to 30. If this `ELSIF` condition is true, another `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the lowercase version of the `p_new_nationality` input parameter, achieved by using the `LOWER()` function. This update is also applied only to the row where the `MEMBER_ID` column matches `p_member_id`. If both the initial `IF` and the `ELSIF` conditions are false, the procedure executes the `ELSE` block. Within this `ELSE` block, a final `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the title-cased version of the `p_new_nationality` input parameter, where the first letter of each word is capitalized and the rest are lowercase, achieved by using the `INITCAP()` function. This update is applied only to the row where the `MEMBER_ID` column matches `p_member_id`. After the conditional updates to the `MEMBER` table, the procedure executes a `DELETE` statement. This `DELETE` statement removes rows from the `CLUB_LEADER` table where the `MEMBER_ID` column matches the input parameter `p_member_id` AND the `YEAR_JOIN` column is less than the string literal '2016'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_member_nationality(p_member_id NUMBER, p_new_nationality VARCHAR2)\nIS\n   v_current_age NUMBER;\n   v_name_length NUMBER;\nBEGIN\n   SELECT AGE, LENGTH(NAME)\n   INTO v_current_age, v_name_length\n   FROM MEMBER\n   WHERE MEMBER_ID = p_member_id;\n   \n   IF v_current_age < 20 AND v_name_length > 10 THEN\n      UPDATE MEMBER \n      SET NATIONALITY = UPPER(p_new_nationality)\n      WHERE MEMBER_ID = p_member_id;\n   ELSIF v_current_age >= 20 AND v_current_age <= 30 THEN\n      UPDATE MEMBER \n      SET NATIONALITY = LOWER(p_new_nationality)\n      WHERE MEMBER_ID = p_member_id;\n   ELSE\n      UPDATE MEMBER \n      SET NATIONALITY = INITCAP(p_new_nationality)\n      WHERE MEMBER_ID = p_member_id;\n   END IF;\n   \n   DELETE FROM CLUB_LEADER \n   WHERE MEMBER_ID = p_member_id \n   AND YEAR_JOIN < '2016';\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "BEGIN\n  update_member_nationality(1984, 'American');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1985, 'Canadian');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1986, 'British');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1988, 'Australian');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1989, 'Indian');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `update_member_nationality` that updates a member's nationality based on their age and name length. It takes a member ID and a new nationality as input. First, retrieve the member's age and name length. If the member is under 20 and their name length is greater than 10, update their nationality to the uppercase version of the input. If the member is between 20 and 30 (inclusive), update their nationality to the lowercase version. Otherwise, update it to the title-cased version. Finally, delete any records for this member from the `CLUB_LEADER` table where they joined before '2016'.",
    "natural_language": "Write a stored procedure called `update_member_nationality` to update a member's nationality using their age and name length. The procedure should accept a member ID and a new nationality. Fetch the member's age and name length. For members under 20 with a name longer than 10 characters, set the nationality to the uppercase input. For those aged 20 to 30, set it to the lowercase input. For all others, use the title-cased input. Then, remove any entries for this member from the `CLUB_LEADER` table where the join date is earlier than '2016'.",
    "id": 306
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named merge_club_data that accepts two numeric input parameters, p_source_id and p_target_id, and performs a series of operations to merge data from a source club into a target club. The procedure begins by executing a SELECT statement that joins the CLUB_LEADER table (aliased as cl) with the CLUB table (aliased as c) on the CLUB_ID column to retrieve data for clubs matching either the p_source_id or p_target_id. This query calculates two aggregate values: the count of distinct MEMBER_ID entries from the CLUB_LEADER table and the average of the OVERALL_RANKING column from the CLUB table. These results are stored into local variables v_leader_count and v_avg_ranking, respectively. Next, the procedure performs a MERGE operation targeting the CLUB table (aliased as t). The source data for the merge is a single-row derived query from DUAL that constructs values using the input parameters and the calculated v_avg_ranking: it sets the CLUB_ID to p_target_id, creates a CLUB_NAME by concatenating the string 'Merged_' with the p_source_id value, sets TEAM_LEADER to the literal string 'Consolidated', and sets OVERALL_RANKING to the value of v_avg_ranking, using the NVL function to substitute a default of 50 if v_avg_ranking is null. The merge condition matches rows where the target table's CLUB_ID equals the source's constructed CLUB_ID (p_target_id). When a match is found (i.e., a club with the target ID already exists), the operation updates the target row's CLUB_NAME, TEAM_LEADER, and OVERALL_RANKING columns with the corresponding values from the source data. When no match is found, the operation inserts a new row into the CLUB table using the source data's CLUB_ID, CLUB_NAME, TEAM_LEADER, and OVERALL_RANKING values. Finally, the procedure includes a conditional IF statement that checks if the previously calculated v_leader_count is greater than zero; if this condition is true, it executes a DELETE statement to remove the row from the CLUB table where the CLUB_ID equals the p_source_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE merge_club_data(p_source_id NUMBER, p_target_id NUMBER)\nIS\n   v_leader_count NUMBER;\n   v_avg_ranking NUMBER;\nBEGIN\n   SELECT COUNT(DISTINCT MEMBER_ID), AVG(OVERALL_RANKING)\n   INTO v_leader_count, v_avg_ranking\n   FROM CLUB_LEADER cl\n   JOIN CLUB c ON cl.CLUB_ID = c.CLUB_ID\n   WHERE cl.CLUB_ID IN (p_source_id, p_target_id);\n   \n   MERGE INTO CLUB t\n   USING (SELECT p_target_id AS CLUB_ID, \n                 'Merged_' || p_source_id AS CLUB_NAME,\n                 'Consolidated' AS TEAM_LEADER,\n                 NVL(v_avg_ranking, 50) AS OVERALL_RANKING\n          FROM DUAL) s\n   ON (t.CLUB_ID = s.CLUB_ID)\n   WHEN MATCHED THEN\n        UPDATE SET t.CLUB_NAME = s.CLUB_NAME,\n                   t.TEAM_LEADER = s.TEAM_LEADER,\n                   t.OVERALL_RANKING = s.OVERALL_RANKING\n   WHEN NOT MATCHED THEN\n        INSERT (CLUB_ID, CLUB_NAME, TEAM_LEADER, OVERALL_RANKING)\n        VALUES (s.CLUB_ID, s.CLUB_NAME, s.TEAM_LEADER, s.OVERALL_RANKING);\n   \n   IF v_leader_count > 0 THEN\n      DELETE FROM CLUB WHERE CLUB_ID = p_source_id;\n   END IF;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "BEGIN\n  merge_club_data(1, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  merge_club_data(4, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  merge_club_data(3, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  merge_club_data(6, 8);\n  COMMIT;\nEND;",
      "BEGIN\n  merge_club_data(8, 6);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `merge_club_data` that merges data from a source club into a target club. It accepts source and target club IDs as input. First, calculate the count of distinct leaders and the average ranking for these clubs. Then, merge this data into the `CLUB` table for the target ID: update the existing club's name, leader, and ranking, or insert a new club if it doesn't exist. The club name is set to 'Merged_' followed by the source ID, and the leader is set to 'Consolidated'. If the leader count is greater than zero, delete the source club record.",
    "natural_language": "Please construct a stored procedure designated as `merge_club_data` to facilitate the merging of data from a source club into a target club. The procedure shall accept the source and target club identifiers as input parameters. Initially, compute the count of distinct leaders and the average ranking pertaining to the specified clubs. Subsequently, merge the derived data into the `CLUB` table for the target identifier, executing an update on the existing club's name, leader, and ranking, or performing an insertion of a new club record should it not already exist. The club name shall be assigned as the concatenation of the string 'Merged_' and the source identifier, while the leader shall be set to 'Consolidated'. Finally, provided the leader count exceeds zero, delete the record associated with the source club.",
    "id": 307
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named INSERT_COURSE_ARRANGEMENT that accepts three input parameters: a numeric parameter P_COURSE_ID representing a course identifier, a numeric parameter P_TEACHER_ID representing a teacher identifier, and a numeric parameter P_GRADE representing a grade level. The procedure performs a conditional insert operation into the COURSE_ARRANGE table, specifically into its COURSE_ID, TEACHER_ID, and GRADE columns. The logic uses a SELECT statement from the DUAL system table to provide the source values for the insert, which are the three input parameters. This insert is executed only when a WHERE NOT EXISTS condition is satisfied. The condition checks for the absence of an existing record in the COURSE_ARRANGE table by performing a subquery that selects the constant value 1 from the same table where the COURSE_ID column equals the input P_COURSE_ID, the TEACHER_ID column equals the input P_TEACHER_ID, and the GRADE column equals the input P_GRADE. Therefore, the procedure inserts a new row with the specified course, teacher, and grade combination only if an identical combination does not already exist in the table, thereby preventing duplicate entries based on these three fields.",
    "plsql": "CREATE OR REPLACE PROCEDURE INSERT_COURSE_ARRANGEMENT(\n  P_COURSE_ID IN NUMBER,\n  P_TEACHER_ID IN NUMBER,\n  P_GRADE IN NUMBER\n) AS\nBEGIN\n  INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE)\n  SELECT P_COURSE_ID, P_TEACHER_ID, P_GRADE\n  FROM DUAL\n  WHERE NOT EXISTS (\n    SELECT 1\n    FROM COURSE_ARRANGE\n    WHERE COURSE_ID = P_COURSE_ID\n    AND TEACHER_ID = P_TEACHER_ID\n    AND GRADE = P_GRADE\n  );\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 1, P_TEACHER_ID => 1, P_GRADE => 1);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 2, P_TEACHER_ID => 3, P_GRADE => 3);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 3, P_TEACHER_ID => 5, P_GRADE => 1);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 1, P_TEACHER_ID => 2, P_GRADE => 5);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 2, P_TEACHER_ID => 1, P_GRADE => 3);\nEND;"
    ],
    "summary": "Create a stored procedure named `INSERT_COURSE_ARRANGEMENT` that inserts a new course arrangement only if it does not already exist. It accepts a course ID, a teacher ID, and a grade as input. The procedure checks the `COURSE_ARRANGE` table for an existing record with the same course, teacher, and grade combination. If no such record is found, it inserts a new row with these values.",
    "natural_language": "Create procedure INSERT_COURSE_ARRANGEMENT to add a new course arrangement if missing. Inputs: course ID, teacher ID, grade. Check COURSE_ARRANGE for duplicate. Insert if none exists.",
    "id": 308
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DELETE_TEACHER_COURSES that accepts three parameters: an input parameter P_TEACHER_ID of type NUMBER to identify a specific teacher, an input parameter P_AGE_LIMIT of type VARCHAR2 representing a textual age threshold, and an output parameter P_DELETED_COUNT of type NUMBER to return the number of rows affected. The procedure performs a DELETE operation on the COURSE_ARRANGE table, using the alias CA. It deletes rows from COURSE_ARRANGE where the TEACHER_ID column matches the provided P_TEACHER_ID value, but only if a correlated subquery condition is also satisfied. The subquery checks the TEACHER table, aliased as T, for the existence of a teacher record where the TEACHER_ID matches the TEACHER_ID from the outer COURSE_ARRANGE row. For that matching teacher record, it converts the AGE column from the TEACHER table and the P_AGE_LIMIT input parameter from VARCHAR2 to NUMBER using the TO_NUMBER function, and then verifies that the teacher's numerical age is less than the numerical value of the provided P_AGE_LIMIT. After the DELETE operation completes, the procedure assigns the number of rows deleted, obtained from the SQL%ROWCOUNT attribute, to the output parameter P_DELETED_COUNT.",
    "plsql": "CREATE OR REPLACE PROCEDURE DELETE_TEACHER_COURSES(\n  P_TEACHER_ID IN NUMBER,\n  P_AGE_LIMIT IN VARCHAR2,\n  P_DELETED_COUNT OUT NUMBER\n) AS\nBEGIN\n  DELETE FROM COURSE_ARRANGE CA\n  WHERE CA.TEACHER_ID = P_TEACHER_ID\n  AND EXISTS (\n    SELECT 1\n    FROM TEACHER T\n    WHERE T.TEACHER_ID = CA.TEACHER_ID\n    AND TO_NUMBER(T.AGE) < TO_NUMBER(P_AGE_LIMIT)\n  );\n  P_DELETED_COUNT := SQL%ROWCOUNT;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(1, '30', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(2, '28', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(3, '35', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(5, '25', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(2, '40', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;"
    ],
    "summary": "Create a stored procedure named `DELETE_TEACHER_COURSES` that deletes course arrangements for a specific teacher whose age is below a given limit. It accepts a teacher ID and an age limit (as text) as input, and returns the count of deleted rows as an output parameter. The procedure deletes rows from `COURSE_ARRANGE` for the specified teacher, but only if the teacher's age (converted to a number) is less than the provided age limit (also converted to a number).",
    "natural_language": "Please construct a stored procedure designated as `DELETE_TEACHER_COURSES`. This procedure is to remove course arrangements for a specified educator, contingent upon the educator's age being beneath a stipulated threshold. It shall accept two input parameters: a teacher identifier and an age limit, the latter provided as textual data. The procedure must return the quantity of deleted records via an output parameter. The deletion operation is to be performed on the `COURSE_ARRANGE` table, targeting entries associated with the provided teacher ID. This action is to be executed only if the numerical representation of the teacher's age is determined to be less than the numerical value derived from the supplied age limit parameter.",
    "id": 309
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UPDATE_COURSE_DATES that accepts three parameters: an input parameter P_OLD_DATE_PATTERN of type VARCHAR2 used to specify a text pattern to search for within date strings, a second input parameter P_NEW_DATE of type VARCHAR2 used to provide the new date value for replacement, and an output parameter P_UPDATED_COUNT of type NUMBER used to return the count of rows affected by the procedure's operation. The procedure performs a single update operation on the COURSE table, specifically modifying the STARING_DATE column for every row where the existing STARING_DATE value contains the substring specified by P_OLD_DATE_PATTERN; this condition is implemented using the LIKE operator with wildcard characters, forming the pattern '%' concatenated with P_OLD_DATE_PATTERN concatenated with '%' to match the pattern anywhere within the column's value. For all rows satisfying this WHERE clause condition, the STARING_DATE column is set to the value provided in the P_NEW_DATE parameter. After the update completes, the procedure assigns the number of rows updated, obtained from the implicit cursor attribute SQL%ROWCOUNT, to the output parameter P_UPDATED_COUNT.",
    "plsql": "CREATE OR REPLACE PROCEDURE UPDATE_COURSE_DATES(\n  P_OLD_DATE_PATTERN IN VARCHAR2,\n  P_NEW_DATE IN VARCHAR2,\n  P_UPDATED_COUNT OUT NUMBER\n) AS\nBEGIN\n  UPDATE COURSE\n  SET STARING_DATE = P_NEW_DATE\n  WHERE STARING_DATE LIKE '%' || P_OLD_DATE_PATTERN || '%';\n  P_UPDATED_COUNT := SQL%ROWCOUNT;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "DECLARE\n  v_updated_count NUMBER;\nBEGIN\n  UPDATE_COURSE_DATES('May', '10 June', v_updated_count);\n  DBMS_OUTPUT.PUT_LINE('Updated Count: ' || v_updated_count);\nEND;",
      "DECLARE\n  v_updated_count NUMBER;\nBEGIN\n  UPDATE_COURSE_DATES('June', '15 July', v_updated_count);\n  DBMS_OUTPUT.PUT_LINE('Updated Count: ' || v_updated_count);\nEND;",
      "DECLARE\n  v_updated_count NUMBER;\nBEGIN\n  UPDATE_COURSE_DATES('July', '20 August', v_updated_count);\n  DBMS_OUTPUT.PUT_LINE('Updated Count: ' || v_updated_count);\nEND;",
      "DECLARE\n  v_updated_count NUMBER;\nBEGIN\n  UPDATE_COURSE_DATES('August', '25 September', v_updated_count);\n  DBMS_OUTPUT.PUT_LINE('Updated Count: ' || v_updated_count);\nEND;",
      "DECLARE\n  v_updated_count NUMBER;\nBEGIN\n  UPDATE_COURSE_DATES('September', '30 October', v_updated_count);\n  DBMS_OUTPUT.PUT_LINE('Updated Count: ' || v_updated_count);\nEND;"
    ],
    "summary": "Create a stored procedure named `UPDATE_COURSE_DATES` that updates course start dates containing a specific text pattern. It accepts an old date pattern and a new date as input, and returns the count of updated rows as an output parameter. The procedure updates the `STARING_DATE` column in the `COURSE` table to the new date for all rows where the existing date contains the old pattern anywhere within it.",
    "natural_language": "Create procedure UPDATE_COURSE_DATES to set STARING_DATE to a new date where it contains an old pattern. Return the number of rows updated.",
    "id": 310
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_calculate_total_forms that accepts a single input parameter para_party_id of the NUMBER data type, which is used to identify a specific party. The procedure begins by declaring a local variable total_forms of type NUMBER. It then executes a SELECT statement to query the PARTY_FORMS table, calculating the sum of all FORM_ID values for rows where the PARTY_ID column matches the input parameter para_party_id, and stores this aggregated result into the total_forms variable. Following this calculation, the procedure uses an IF-THEN-ELSE conditional block to evaluate the value of total_forms. If total_forms is greater than 50, the procedure performs an INSERT operation into the PARTY_FORMS table, creating a new row with the following column values: the PARTY_ID is set to the input para_party_id, the FORM_ID is set to the calculated total_forms value incremented by one, the DATE_COMPLETION_STARTED column is populated with the current system date and time formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format using the TO_CHAR and SYSDATE functions, the FORM_STATUS_CODE is set to the literal string 'Completed', and the DATE_FULLY_COMPLETED column is explicitly set to NULL. Conversely, if the condition total_forms > 50 evaluates to FALSE (i.e., total_forms is less than or equal to 50), the procedure executes a DELETE operation on the PARTY_FORMS table, removing all rows where the PARTY_ID equals the input para_party_id and the FORM_STATUS_CODE column exactly matches the string 'Partially Completed'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_calculate_total_forms(para_party_id NUMBER) IS\n  total_forms NUMBER;\nBEGIN\n  SELECT SUM(FORM_ID) INTO total_forms FROM PARTY_FORMS WHERE PARTY_ID = para_party_id;\n  IF total_forms > 50 THEN\n    INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED)\n    VALUES (para_party_id, total_forms + 1, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'Completed', NULL);\n  ELSE\n    DELETE FROM PARTY_FORMS WHERE PARTY_ID = para_party_id AND FORM_STATUS_CODE = 'Partially Completed';\n  END IF;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_calculate_total_forms(1);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(2);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(3);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(15);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(8);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_calculate_total_forms that accepts a party ID number. Calculate the total number of forms for that party. If the total is greater than 50, insert a new 'Completed' form record for the party with an incremented ID and the current timestamp. Otherwise, delete all 'Partially Completed' forms for that party.",
    "natural_language": "How can I create a stored procedure called sp_calculate_total_forms that takes a party ID, calculates the total number of forms for that party, and then, if the total exceeds 50, inserts a new 'Completed' form record with an incremented ID and the current timestamp, otherwise deletes all 'Partially Completed' forms for that party?",
    "id": 311
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes a single input parameter para_payment_method of type VARCHAR2, representing a payment method code, and performs conditional operations on the PARTIES table based on the number of rows in the table that match the given payment method code. The procedure begins by executing a SELECT statement to count the number of rows in the PARTIES table where the PAYMENT_METHOD_CODE column matches the value of para_payment_method, storing the result in a local variable named party_count of type NUMBER. If the value of party_count is greater than 5, the procedure inserts a new row into the PARTIES table with the following values: the PARTY_ID column is set to the value of party_count plus 100, the PAYMENT_METHOD_CODE column is set to the value of para_payment_method, the PARTY_PHONE column is set to the string '555-0000', and the PARTY_EMAIL column is set to the string 'new@example.com'. If the value of party_count is not greater than 5, the procedure deletes all rows from the PARTIES table where the PAYMENT_METHOD_CODE column matches the value of para_payment_method.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_process_party_data(para_payment_method VARCHAR2) IS\n  party_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO party_count FROM PARTIES WHERE PAYMENT_METHOD_CODE = para_payment_method;\n  IF party_count > 5 THEN\n    INSERT INTO PARTIES (PARTY_ID, PAYMENT_METHOD_CODE, PARTY_PHONE, PARTY_EMAIL)\n    VALUES (party_count + 100, para_payment_method, '555-0000', 'new@example.com');\n  ELSE\n    DELETE FROM PARTIES WHERE PAYMENT_METHOD_CODE = para_payment_method;\n  END IF;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_process_party_data('Cheque');\n  commit;\nEND;",
      "BEGIN\n  sp_process_party_data('Credit Card');\n  commit;\nEND;",
      "BEGIN\n  sp_process_party_data('Cash');\n  commit;\nEND;",
      "BEGIN\n  sp_process_party_data('Bank Transfer');\n  commit;\nEND;",
      "BEGIN\n  sp_process_party_data('PayPal');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a payment method code. Count how many parties use that payment method. If the count is greater than 5, insert a new party record with that payment method and default contact details. Otherwise, delete all parties using that payment method.",
    "natural_language": "How can I create a stored procedure that takes a payment method code, counts the parties using it, and then inserts a new party with default details if the count exceeds 5, or deletes all those parties if the count is 5 or less?",
    "id": 312
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes a single input parameter, para_party_id of type NUMBER, and performs the following operations: First, it queries the PARTIES table to count the number of rows where the PARTY_ID column matches the value of para_party_id and stores the result in a local variable named party_exists. Then, it checks if the value of party_exists is greater than 0, indicating that a row with the specified PARTY_ID exists in the PARTIES table. If this condition is true, it deletes all rows from the PARTY_FORMS table where the PARTY_ID column matches the value of para_party_id. After that, it deletes the row from the PARTIES table where the PARTY_ID column matches the value of para_party_id. If the condition is not met (i.e., no matching row exists in the PARTIES table), no further action is taken.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_cleanup_parties(para_party_id NUMBER) IS\n  party_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO party_exists FROM PARTIES WHERE PARTY_ID = para_party_id;\n  IF party_exists > 0 THEN\n    DELETE FROM PARTY_FORMS WHERE PARTY_ID = para_party_id;\n    DELETE FROM PARTIES WHERE PARTY_ID = para_party_id;\n  END IF;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_cleanup_parties(1);\nEND;",
      "BEGIN\n  sp_cleanup_parties(2);\nEND;",
      "BEGIN\n  sp_cleanup_parties(3);\nEND;",
      "BEGIN\n  sp_cleanup_parties(15);\nEND;",
      "BEGIN\n  sp_cleanup_parties(8);\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a party ID number. Check if the party exists. If it exists, first delete all forms associated with that party, then delete the party record itself.",
    "natural_language": "Delete a party and its forms by ID if the party exists.",
    "id": 313
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_archive_completed_forms that accepts a single input parameter named para_party_id of the NUMBER data type, which is used to identify a specific party. The procedure first executes a SELECT statement to query the PARTY_FORMS table, counting all rows where the PARTY_ID column matches the provided para_party_id value and the FORM_STATUS_CODE column has the exact string value 'Completed', storing the resulting count into a local variable named completed_forms. The procedure then executes a DELETE statement on the PARTY_FORMS table, removing all rows that satisfy the same conditions: where the PARTY_ID column equals the input para_party_id and the FORM_STATUS_CODE column is exactly 'Completed'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_archive_completed_forms(para_party_id NUMBER) IS\n  completed_forms NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO completed_forms FROM PARTY_FORMS WHERE PARTY_ID = para_party_id AND FORM_STATUS_CODE = 'Completed';\n  DELETE FROM PARTY_FORMS WHERE PARTY_ID = para_party_id AND FORM_STATUS_CODE = 'Completed';\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_archive_completed_forms(1);\nEND;",
      "BEGIN\n  sp_archive_completed_forms(2);\nEND;",
      "BEGIN\n  sp_archive_completed_forms(3);\nEND;",
      "BEGIN\n  sp_archive_completed_forms(15);\nEND;",
      "BEGIN\n  sp_archive_completed_forms(8);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_archive_completed_forms that accepts a party ID number. Count and then delete all 'Completed' forms associated with that party.",
    "natural_language": "Count and delete all 'Completed' forms for a given party ID using a stored procedure named sp_archive_completed_forms.",
    "id": 314
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_university_ranking that accepts four input parameters: p_university_id of type NUMBER to identify the university, p_reputation_point of type NUMBER for the university's reputation score, p_research_point of type NUMBER for the research score, and p_citation_point of type NUMBER for the citation score. The procedure first calculates a variable v_total by summing the three input point parameters. It then queries the OVERALL_RANKING table to count, into variable v_count, the number of existing records where the UNIVERSITY_ID column matches the input p_university_id. Next, it calculates a ranking variable v_rank by querying the OVERALL_RANKING table to count all records where the existing TOTAL column value is greater than the newly calculated v_total, then adding 1 to this count, thereby assigning a rank where a higher total score results in a lower (better) rank number. If the v_count is greater than 0, indicating the university already exists in the OVERALL_RANKING table, the procedure performs an UPDATE on the OVERALL_RANKING table for the row where UNIVERSITY_ID equals p_university_id, setting the RANK column to v_rank, the REPUTATION_POINT column to p_reputation_point, the RESEARCH_POINT column to p_research_point, the CITATION_POINT column to p_citation_point, and the TOTAL column to v_total. If v_count is 0, indicating the university does not exist, the procedure performs an INSERT into the OVERALL_RANKING table, providing values for the columns RANK, UNIVERSITY_ID, REPUTATION_POINT, RESEARCH_POINT, CITATION_POINT, and TOTAL using the calculated v_rank, the input p_university_id, the input p_reputation_point, the input p_research_point, the input p_citation_point, and the calculated v_total, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_university_ranking(\n    p_university_id IN NUMBER,\n    p_reputation_point IN NUMBER,\n    p_research_point IN NUMBER,\n    p_citation_point IN NUMBER\n)\nIS\n    v_total NUMBER;\n    v_rank NUMBER;\n    v_count NUMBER;\nBEGIN\n    v_total := p_reputation_point + p_research_point + p_citation_point;\n    \n    -- Check if the university already exists\n    SELECT COUNT(*)\n    INTO v_count\n    FROM OVERALL_RANKING\n    WHERE UNIVERSITY_ID = p_university_id;\n\n    -- Calculate rank based on the new total\n    -- This rank calculation is a simple one, assuming higher total means lower rank number\n    SELECT COUNT(*) + 1 INTO v_rank\n    FROM OVERALL_RANKING\n    WHERE TOTAL > v_total;\n    \n    IF v_count > 0 THEN\n        -- University exists, update the record\n        UPDATE OVERALL_RANKING\n        SET\n            RANK = v_rank,\n            REPUTATION_POINT = p_reputation_point,\n            RESEARCH_POINT = p_research_point,\n            CITATION_POINT = p_citation_point,\n            TOTAL = v_total\n        WHERE UNIVERSITY_ID = p_university_id;\n    ELSE\n        -- University does not exist, insert a new record\n        INSERT INTO OVERALL_RANKING (RANK, UNIVERSITY_ID, REPUTATION_POINT, RESEARCH_POINT, CITATION_POINT, TOTAL)\n        VALUES (v_rank, p_university_id, p_reputation_point, p_research_point, p_citation_point, v_total);\n    END IF;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n    insert_university_ranking(1, 5, 2, 0);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_university_ranking(2, 4, 1, 1);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_university_ranking(3, 6, 3, 2);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_university_ranking(4, 3, 2, 1);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_university_ranking(1, 7, 3, 1);\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_university_ranking that accepts a university ID and three score parameters. Calculate the total score and determine a ranking based on existing totals. If the university already has a ranking record, update it with the new scores and rank. Otherwise, insert a new ranking record.",
    "natural_language": "Create procedure insert_university_ranking to add or update a university's ranking using its ID and three scores.",
    "id": 315
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_major_rankings` that is designed to remove specific records from the `MAJOR_RANKING` table. This procedure accepts four input parameters: `p_major_id` of data type `NUMBER`, which represents the unique identifier for a major; `p_university_id` of data type `NUMBER`, which represents the unique identifier for a university; `p_min_rank` of data type `NUMBER`, which specifies the lower bound of a rank range; and `p_max_rank` of data type `NUMBER`, which specifies the upper bound of the same rank range. The core operation performed by this procedure is a `DELETE` statement targeting the `MAJOR_RANKING` table. This `DELETE` operation is conditional, meaning it only removes rows that satisfy a set of criteria defined in its `WHERE` clause. Specifically, a row will be deleted if its `MAJOR_ID` column value exactly matches the value provided in the `p_major_id` input parameter, AND its `UNIVERSITY_ID` column value exactly matches the value provided in the `p_university_id` input parameter, AND its `RANK` column value falls inclusively within the range defined by `p_min_rank` and `p_max_rank`. This means that the `RANK` column value must be greater than or equal to `p_min_rank` AND less than or equal to `p_max_rank`. The procedure does not perform any other operations such as inserts, updates, or selections, nor does it involve any function calls or complex logical flows beyond the single conditional delete statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_major_rankings(\n    p_major_id IN NUMBER,\n    p_university_id IN NUMBER,\n    p_min_rank IN NUMBER,\n    p_max_rank IN NUMBER\n)\nIS\nBEGIN\n    DELETE FROM MAJOR_RANKING\n    WHERE MAJOR_ID = p_major_id\n    AND UNIVERSITY_ID = p_university_id\n    AND RANK BETWEEN p_min_rank AND p_max_rank;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  delete_major_rankings(p_major_id => 1, p_university_id => 1, p_min_rank => 1, p_max_rank => 10);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 2, p_university_id => 3, p_min_rank => 5, p_max_rank => 15);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 3, p_university_id => 2, p_min_rank => 1, p_max_rank => 5);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 1, p_university_id => 3, p_min_rank => 1, p_max_rank => 1);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 2, p_university_id => 1, p_min_rank => 10, p_max_rank => 20);\nEND;"
    ],
    "summary": "Create a stored procedure named delete_major_rankings that deletes records from the MAJOR_RANKING table where MAJOR_ID equals input p_major_id, UNIVERSITY_ID equals input p_university_id, and RANK is between input p_min_rank and p_max_rank inclusive.",
    "natural_language": "Delete MAJOR_RANKING records for given major and university where rank is within a specified range.",
    "id": 316
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_major_record` that accepts four input parameters: a numeric `p_major_id`, a string `p_major_name`, a numeric `p_major_code`, and a numeric `p_name_length`. The procedure first queries the `MAJOR` table to count the number of existing rows where the `MAJOR_ID` column matches the input `p_major_id`, storing the result in a local variable `v_exists`. If `v_exists` is greater than zero, indicating a record with that ID already exists, the procedure performs an update on the `MAJOR` table for the row where `MAJOR_ID` equals `p_major_id`. Within this update branch, if the character length of the input `p_major_name` is greater than or equal to the input `p_name_length`, it sets the `MAJOR_NAME` column to the uppercase version of `p_major_name` using the `UPPER` function and sets the `MAJOR_CODE` column directly to the input `p_major_code`. If the length condition is not met, it sets the `MAJOR_NAME` column to the unchanged `p_major_name` and sets the `MAJOR_CODE` column to the result of the calculation `CEIL(p_major_code * 1.1)`, which multiplies the input code by 1.1 and rounds up to the nearest integer using the `CEIL` function. If `v_exists` is zero, indicating no existing record with the provided ID, the procedure performs an insert into the `MAJOR` table, specifying the columns `MAJOR_ID`, `MAJOR_NAME`, and `MAJOR_CODE`. Within this insert branch, if the length of `p_major_name` is greater than or equal to `p_name_length`, it inserts the values `p_major_id`, the uppercase version of `p_major_name`, and the original `p_major_code`. If the length condition is not met, it inserts the values `p_major_id`, the unchanged `p_major_name`, and the calculated value `CEIL(p_major_code * 1.1)`.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_major_record(\n    p_major_id IN NUMBER,\n    p_major_name IN VARCHAR2,\n    p_major_code IN NUMBER,\n    p_name_length IN NUMBER\n)\nIS\n    v_exists NUMBER;\nBEGIN\n    -- Check if the MAJOR_ID already exists\n    SELECT COUNT(*)\n    INTO v_exists\n    FROM MAJOR\n    WHERE MAJOR_ID = p_major_id;\n\n    IF v_exists > 0 THEN\n        -- Update the existing record\n        IF LENGTH(p_major_name) >= p_name_length THEN\n            UPDATE MAJOR \n            SET MAJOR_NAME = UPPER(p_major_name), \n                MAJOR_CODE = p_major_code\n            WHERE MAJOR_ID = p_major_id;\n        ELSE\n            UPDATE MAJOR \n            SET MAJOR_NAME = p_major_name, \n                MAJOR_CODE = CEIL(p_major_code * 1.1)\n            WHERE MAJOR_ID = p_major_id;\n        END IF;\n    ELSE\n        -- Insert the record based on the length of the major name\n        IF LENGTH(p_major_name) >= p_name_length THEN\n            INSERT INTO MAJOR (MAJOR_ID, MAJOR_NAME, MAJOR_CODE)\n            VALUES (p_major_id, UPPER(p_major_name), p_major_code);\n        ELSE\n            INSERT INTO MAJOR (MAJOR_ID, MAJOR_NAME, MAJOR_CODE)\n            VALUES (p_major_id, p_major_name, CEIL(p_major_code * 1.1));\n        END IF;\n    END IF;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n    insert_major_record(101, 'Computer Science', 1001, 5);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_major_record(2, 'Advertising', 1053, 10);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_major_record(105, 'Math', 900, 4);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_major_record(3, 'Healthcare Management', 1154, 15);\n    COMMIT;\nEND;",
      "BEGIN\n    insert_major_record(200, 'Electrical Engineering', 1200, 8);\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_major_record that inserts or updates the MAJOR table. If a record with the input p_major_id exists, update it: set MAJOR_NAME to uppercase(p_major_name) and MAJOR_CODE to p_major_code if the name length >= p_name_length; otherwise, set MAJOR_NAME to p_major_name and MAJOR_CODE to CEIL(p_major_code * 1.1). If the record does not exist, insert a new record with the same conditional logic for MAJOR_NAME and MAJOR_CODE.",
    "natural_language": "Write a stored procedure called insert_major_record to insert or update the MAJOR table. If a record with the given p_major_id exists, update it: set MAJOR_NAME to uppercase(p_major_name) and MAJOR_CODE to p_major_code when the name length is greater than or equal to p_name_length; otherwise, set MAJOR_NAME to p_major_name and MAJOR_CODE to CEIL(p_major_code * 1.1). If the record does not exist, insert a new record using the same conditional logic for MAJOR_NAME and MAJOR_CODE.",
    "id": 317
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_conference_from_pattern` that accepts three input parameters: `p_name_pattern` of data type `VARCHAR2`, intended to provide a base string for the new conference's name; `p_year_value` of data type `NUMBER`, intended to specify the year of the new conference; and `p_location_value` of data type `VARCHAR2`, intended to specify the location of the new conference. The procedure declares a local variable `v_new_id` of data type `NUMBER` to temporarily store the generated `conference_id`. The procedure's execution block begins by performing a `SELECT` operation on the `conference` table. This `SELECT` statement retrieves the maximum value from the `conference_id` column across all existing records in the `conference` table. It then adds `1` to this maximum value to generate a new, unique identifier for the upcoming conference record. The result of this calculation is stored into the local variable `v_new_id`. Following this, the procedure executes an `INSERT` operation to add a new record into the `conference` table. The `INSERT` statement populates four columns: `conference_id`, `conference_name`, `year`, and `location`. The `conference_id` column is populated with the value stored in the `v_new_id` variable. The `conference_name` column is populated by concatenating the value of the `p_name_pattern` input parameter, a single space character, and the value of the `p_year_value` input parameter. The `year` column is populated directly with the value of the `p_year_value` input parameter. Finally, the `location` column is populated with the value of the `p_location_value` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_conference_from_pattern(\n    p_name_pattern VARCHAR2,\n    p_year_value NUMBER,\n    p_location_value VARCHAR2\n) IS\n    v_new_id NUMBER;\nBEGIN\n    SELECT MAX(conference_id) + 1 INTO v_new_id FROM conference;\n    \n    INSERT INTO conference (conference_id, conference_name, year, location)\n    VALUES (v_new_id, p_name_pattern || ' ' || p_year_value, p_year_value, p_location_value);\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE"
    ],
    "call_sqls": [
      "BEGIN\n  insert_conference_from_pattern('ACL', 2024, 'Thailand');\n  commit;\nEND;",
      "BEGIN\n  insert_conference_from_pattern('Naccl', 2025, 'South Korea');\n  commit;\nEND;",
      "BEGIN\n  insert_conference_from_pattern('EMNLP', 2024, 'Mexico');\n  commit;\nEND;",
      "BEGIN\n  insert_conference_from_pattern('COLING', 2025, 'Germany');\n  commit;\nEND;",
      "BEGIN\n  insert_conference_from_pattern('LREC', 2026, 'Italy');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_conference_from_pattern that inserts a new record into the conference table. Generate a new conference_id as the maximum existing conference_id plus 1. Set conference_name to p_name_pattern concatenated with a space and p_year_value. Set year to p_year_value and location to p_location_value.",
    "natural_language": "How can I create a stored procedure called 'insert_conference_from_pattern' that adds a new record to the conference table by generating a new conference_id as the maximum existing id plus 1, setting the conference_name to the p_name_pattern concatenated with a space and p_year_value, and setting the year to p_year_value and the location to p_location_value?",
    "id": 318
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes three input parameters: p_year_cutoff of type NUMBER, p_location_exclude of type VARCHAR2, and p_min_id of type NUMBER, and performs a delete operation on the conference table. The procedure removes rows from the conference table where the value in the year column is less than the value of p_year_cutoff, the value in the location column is not equal to the value of p_location_exclude, and the value in the conference_id column is greater than the value of p_min_id. The delete operation is executed based on these three conditions combined using logical AND operators, ensuring that only rows meeting all specified criteria are deleted.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_conferences(\n    p_year_cutoff NUMBER,\n    p_location_exclude VARCHAR2,\n    p_min_id NUMBER\n) IS\nBEGIN\n    DELETE FROM conference\n    WHERE year < p_year_cutoff\n    AND location != p_location_exclude\n    AND conference_id > p_min_id;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE"
    ],
    "call_sqls": [
      "BEGIN\n  delete_old_conferences(2005, 'Japan', 1);\n  commit;\nEND;",
      "BEGIN\n  delete_old_conferences(2004, 'Philippines', 2);\n  commit;\nEND;",
      "BEGIN\n  delete_old_conferences(2003, 'Japan', 3);\n  commit;\nEND;",
      "BEGIN\n  delete_old_conferences(2006, 'Philippines', 1);\n  commit;\nEND;",
      "BEGIN\n  delete_old_conferences(2007, 'Japan', 2);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure that deletes records from the conference table where year is less than input p_year_cutoff, location is not equal to input p_location_exclude, and conference_id is greater than input p_min_id.",
    "natural_language": "Hey, can you whip up a stored procedure that gets rid of old conference records? It should trash any where the year is before the cutoff year we give it, the location isn't the one we want to skip, and the conference ID is bigger than our minimum ID number.",
    "id": 319
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `merge_conference_data` that accepts three input parameters: `p_source_location` of type `VARCHAR2`, representing the location to be used as the source for data merging; `p_dest_location` of type `VARCHAR2`, representing the target location where data will be merged; and `p_year_offset` of type `NUMBER`, representing an integer value to be added to the 'year' column during the merge operation. The procedure declares three local variables: `v_count_source` of type `NUMBER`, `v_count_dest` of type `NUMBER`, and `v_max_id` of type `NUMBER`. The procedure begins by executing a `SELECT` statement to count the total number of rows in the `conference` table where the `location` column matches the value provided in the `p_source_location` parameter, storing this count into the `v_count_source` variable. Subsequently, another `SELECT` statement is executed to count the total number of rows in the `conference` table where the `location` column matches the value provided in the `p_dest_location` parameter, storing this count into the `v_count_dest` variable. Following these counts, a conditional `IF` statement evaluates whether the value of `v_count_source` is strictly greater than the value of `v_count_dest`. If this condition is true, the procedure proceeds to execute a `SELECT` statement to determine the maximum value of the `conference_id` column from the `conference` table. If no rows exist or `conference_id` is `NULL` for all rows, the `NVL` function ensures that `0` is returned instead of `NULL`, and this result is stored in the `v_max_id` variable. After determining `v_max_id`, an `INSERT` statement is executed to add new rows into the `conference` table. The `INSERT` statement populates the `conference_id`, `conference_name`, `year`, and `location` columns. The values for these columns are derived from a `SELECT` subquery that retrieves data from the `conference` table where the `location` column matches `p_source_location`. For each row selected by the subquery, the `conference_id` is generated by adding the `ROWNUM` (which provides a sequential number for each row returned by the subquery, starting from 1) to the `v_max_id` value. The `conference_name` is directly taken from the `conference_name` column of the source rows. The `year` is calculated by adding the `p_year_offset` value to the `year` column of the source rows. The `location` for the new rows is set to the value provided in the `p_dest_location` parameter. This `INSERT` operation is performed only if the initial `IF` condition (v_count_source > v_count_dest) was met. The procedure concludes after the `IF` statement, whether the `INSERT` was executed or not.",
    "plsql": "CREATE OR REPLACE PROCEDURE merge_conference_data(\n    p_source_location VARCHAR2,\n    p_dest_location VARCHAR2,\n    p_year_offset NUMBER\n) IS\n    v_count_source NUMBER;\n    v_count_dest NUMBER;\n    v_max_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count_source\n    FROM conference\n    WHERE location = p_source_location;\n    \n    SELECT COUNT(*) INTO v_count_dest\n    FROM conference\n    WHERE location = p_dest_location;\n    \n    IF v_count_source > v_count_dest THEN\n        SELECT NVL(MAX(conference_id), 0) INTO v_max_id\n        FROM conference;\n        \n        INSERT INTO conference (conference_id, conference_name, year, location)\n        SELECT v_max_id + ROWNUM, conference_name, year + p_year_offset, p_dest_location\n        FROM conference\n        WHERE location = p_source_location;\n    END IF;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE"
    ],
    "call_sqls": [
      "BEGIN\n  merge_conference_data('Philippines', 'Japan', 1);\n  commit;\nEND;",
      "BEGIN\n  merge_conference_data('Japan', 'Philippines', 2);\n  commit;\nEND;",
      "BEGIN\n  merge_conference_data('Philippines', 'Japan', 3);\n  commit;\nEND;",
      "BEGIN\n  merge_conference_data('Japan', 'Philippines', 4);\n  commit;\nEND;",
      "BEGIN\n  merge_conference_data('Philippines', 'Japan', 5);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named merge_conference_data that merges data from a source location to a destination location. If the count of records at the source location (p_source_location) is greater than the count at the destination location (p_dest_location), insert new records into the conference table. For each source record, generate a new conference_id by adding ROWNUM to the maximum existing conference_id, copy the conference_name, set year to source year plus p_year_offset, and set location to p_dest_location.",
    "natural_language": "How can I create a stored procedure named merge_conference_data that merges data from a source to a destination location, inserting new records into the conference table only if the source has more records, and for each new record, generates a conference_id by adding ROWNUM to the maximum existing ID, copies the conference_name, sets the year to the source year plus an offset, and sets the location to the destination?",
    "id": 320
  }
]