[
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_country_name` that is designed to retrieve the name of a country based on its unique identifier. This function accepts a single input parameter named `country_id_param`, which is of the `bigint` data type. The purpose of `country_id_param` is to provide the specific identifier of the country whose name is to be retrieved. The function is declared to return a value of the `text` data type, which will represent the name of the country. The core operation performed by this function is a `SELECT` statement. This `SELECT` statement queries the `countries` table. Specifically, it selects the value from the `name` column of the `countries` table. The selection is filtered by a `WHERE` clause, which specifies a condition: the value in the `id` column of the `countries` table must be equal to the value passed in the `country_id_param` input parameter. The result of this `SELECT` statement, which is the `name` of the country corresponding to the provided `country_id_param`, is then immediately returned as the output of the `get_country_name` function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_name(country_id_param bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN (SELECT name FROM countries WHERE id = country_id_param);\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT get_country_name(1);",
      "SELECT get_country_name(2);",
      "SELECT get_country_name(3);"
    ],
    "summary": "Create a function named `get_country_name` that returns the `name` (as text) of a country from the `countries` table for a given `country_id_param` (bigint).",
    "natural_language": "Write function `get_country_name` to return `name` from `countries` for a given `country_id_param`.",
    "id": 1
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_average_score` that accepts a single input parameter. This parameter, named `country_id_param`, is of the `bigint` data type and is intended to represent the unique identifier for a specific country record. The function is designed to return a single value of the `real` data type, which will represent the calculated average score for the country identified by `country_id_param`. The core operation of this function involves executing a `SELECT` statement against the `countries` table. This `SELECT` statement retrieves data from the `countries` table where the `id` column matches the value provided by the `country_id_param` input parameter. For the matching row, it calculates an average score by summing the values from five specific columns: `justice_score`, `health_score`, `education_score`, `economics_score`, and `politics_score`. The sum of these five scores is then divided by `5.0` (a floating-point literal to ensure floating-point division) to compute the average. The result of this calculation, which is a single `real` value representing the average score, is then returned as the output of the `calculate_average_score` function.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_score(country_id_param bigint)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN (SELECT (justice_score + health_score + education_score + economics_score + politics_score) / 5.0 FROM countries WHERE id = country_id_param);\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT calculate_average_score(1);",
      "SELECT calculate_average_score(2);",
      "SELECT calculate_average_score(3);"
    ],
    "summary": "Create a function named `calculate_average_score` that returns a real value. It calculates the average of the `justice_score`, `health_score`, `education_score`, `economics_score`, and `politics_score` columns from the `countries` table for a record matching the provided `country_id_param` (bigint).",
    "natural_language": "Make a function `calculate_average_score` returning real. Average `justice_score`, `health_score`, `education_score`, `economics_score`, and `politics_score` for the given `country_id_param` from `countries`.",
    "id": 2
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `process_customer_email_domains` that takes no input parameters and returns a single `text` value. The function initializes a local variable `v_result` of type `text` to an empty string. It also declares a record variable `v_customer_record` to hold rows fetched from a query and a `v_domain_part` variable of type `text`. The function then iterates through each row retrieved from the `Customers` table. The selection criteria for these rows are that the `email_address` column must not be `NULL`. For each selected customer record, the function extracts the `customer_id`, `email_address`, and `first_name` columns. Inside the loop, for each `v_customer_record`, it extracts the domain part of the `email_address` by splitting the `email_address` string at the '@' character and taking the second part, storing this in `v_domain_part`. It then evaluates the `v_domain_part` against a series of conditional statements. If `v_domain_part` ends with '.com' (case-insensitive due to `LIKE` operator's default behavior), it appends the `first_name` from the current `v_customer_record` followed by ':COM,' to the `v_result` string. If `v_domain_part` does not end with '.com' but ends with '.org', it appends the `first_name` followed by ':ORG,' to `v_result`. If `v_domain_part` does not end with '.com' or '.org' but ends with '.net', it appends the `first_name` followed by ':NET,' to `v_result`. For all other cases where `v_domain_part` does not match any of the preceding conditions, it appends the `first_name` followed by ':OTHER,' to `v_result`. After iterating through all relevant customer records, the function removes any trailing comma from the `v_result` string using the `trim` function with the `trailing` option and returns the final modified `v_result` string.",
    "plsql": "CREATE OR REPLACE FUNCTION process_customer_email_domains()\nRETURNS text AS $$\nDECLARE\n    v_result text := '';\n    v_customer_record record;\n    v_domain_part text;\nBEGIN\n    FOR v_customer_record IN \n        SELECT \"customer_id\", \"email_address\", \"first_name\" \n        FROM \"Customers\" \n        WHERE \"email_address\" IS NOT NULL\n    LOOP\n        v_domain_part := split_part(v_customer_record.email_address, '@', 2);\n        \n        IF v_domain_part LIKE '%.com' THEN\n            v_result := v_result || v_customer_record.first_name || ':COM,';\n        ELSIF v_domain_part LIKE '%.org' THEN\n            v_result := v_result || v_customer_record.first_name || ':ORG,';\n        ELSIF v_domain_part LIKE '%.net' THEN\n            v_result := v_result || v_customer_record.first_name || ':NET,';\n        ELSE\n            v_result := v_result || v_customer_record.first_name || ':OTHER,';\n        END IF;\n    END LOOP;\n    RETURN trim(trailing ',' from v_result);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Lessons",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT process_customer_email_domains();",
      "SELECT * FROM process_customer_email_domains();",
      "SELECT process_customer_email_domains() AS email_domain_summary;",
      "DO $$\nDECLARE\n    result_text text;\nBEGIN\n    result_text := process_customer_email_domains();\n    RAISE NOTICE 'Email domain results: %', result_text;\nEND $$;",
      "WITH domain_summary AS (\n    SELECT process_customer_email_domains() AS summary\n)\nSELECT summary FROM domain_summary;"
    ],
    "summary": "Create a PL/pgSQL function named `process_customer_email_domains` with no parameters that returns a text. For each customer with a non-null email, extract the domain from the email address. Append the customer's first name followed by a suffix (':COM,', ':ORG,', ':NET,', or ':OTHER,') based on whether the domain ends with '.com', '.org', '.net', or another suffix, respectively. Return the final concatenated string after removing any trailing comma.",
    "natural_language": "Hey, write me a PL/pgSQL function called `process_customer_email_domains` that doesn't take any parameters and spits out a text string. For every customer who's got an email on file, pull out just the domain part. Then, tack on the customer's first name and a tag like ':COM,', ':ORG,', ':NET,', or ':OTHER,' depending on if the domain ends with '.com', '.org', '.net', or something else. Smush all those bits together into one big string and make sure to chop off the last comma if there is one.",
    "id": 3
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named generate_customer_location_report that takes no parameters and returns a single text value, which constructs a comma-separated report string by iterating over a result set obtained from an inner join between the Customers table and the Addresses table, where the join condition matches the customer_address_id column from the Customers table with the address_id column from the Addresses table, selecting for each row the customer_id, first_name, and state_province_county columns, then for each fetched record into variable v_customer_record, extracts the first word from the state_province_county field using the split_part function with a space delimiter and index position 1, storing the result in variable v_state_code, and conditionally appends to the accumulating report string v_report based on the value of v_state_code: if it equals the literal string 'Georgia', it appends the customer's first_name followed by the string ':GA,', if it equals 'Kentucky', it appends first_name followed by ':KY,', if it equals 'California', it appends first_name followed by ':CA,', and for any other value, it appends first_name followed by ':OTHER,', and after the loop completes, the function returns the final report string after removing any trailing comma character using the trim function with the 'trailing' specifier and ',' as the character to remove.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_customer_location_report()\nRETURNS text AS $$\nDECLARE\n    v_report text := '';\n    v_customer_record record;\n    v_state_code text;\nBEGIN\n    FOR v_customer_record IN \n        SELECT c.\"customer_id\", c.\"first_name\", a.\"state_province_county\"\n        FROM \"Customers\" c\n        JOIN \"Addresses\" a ON c.\"customer_address_id\" = a.\"address_id\"\n    LOOP\n        v_state_code := split_part(v_customer_record.state_province_county, ' ', 1);\n        \n        IF v_state_code = 'Georgia' THEN\n            v_report := v_report || v_customer_record.first_name || ':GA,';\n        ELSIF v_state_code = 'Kentucky' THEN\n            v_report := v_report || v_customer_record.first_name || ':KY,';\n        ELSIF v_state_code = 'California' THEN\n            v_report := v_report || v_customer_record.first_name || ':CA,';\n        ELSE\n            v_report := v_report || v_customer_record.first_name || ':OTHER,';\n        END IF;\n    END LOOP;\n    RETURN trim(trailing ',' from v_report);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Lessons",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT generate_customer_location_report();",
      "SELECT * FROM generate_customer_location_report() AS report;",
      "SELECT generate_customer_location_report() AS customer_location_report;",
      "DO $$\nDECLARE\n    report_text text;\nBEGIN\n    report_text := generate_customer_location_report();\n    RAISE NOTICE 'Report: %', report_text;\nEND $$;",
      "WITH report AS (SELECT generate_customer_location_report() AS report_data)\nSELECT report_data FROM report;"
    ],
    "summary": "Create a PL/pgSQL function named `generate_customer_location_report` with no parameters that returns a text. Join the `Customers` and `Addresses` tables. For each customer, extract the first word from the `state_province_county` field. Append the customer's first name followed by a suffix (':GA,', ':KY,', ':CA,', or ':OTHER,') based on whether the extracted code is 'Georgia', 'Kentucky', 'California', or another value. Return the final concatenated string after removing any trailing comma.",
    "natural_language": "Please construct a PL/pgSQL function, designated as `generate_customer_location_report`, which accepts no parameters and yields a text output. The function must perform an inner join between the `Customers` and `Addresses` tables. For every customer record, the initial word from the `state_province_county` column is to be isolated. Subsequently, concatenate the customer's first name with a specific suffix—either ':GA,', ':KY,', ':CA,', or ':OTHER,'—determined by whether the extracted word corresponds to 'Georgia', 'Kentucky', 'California', or any other value, respectively. The function should return the aggregated string, ensuring any terminal comma is removed.",
    "id": 4
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named count_parties_by_payment_method that accepts a single input parameter p_payment_method of type text, which represents the specific payment method code to be used as a filter, and returns a single integer value; the function declares a local integer variable v_count to store the result of a count operation, then executes a SELECT statement that queries the \"Parties\" table to count all rows where the value in the column named \"payment_method_code\" exactly matches the value provided in the input parameter p_payment_method, storing the resulting count into the variable v_count, and finally returns the value stored in v_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_parties_by_payment_method(p_payment_method text)\nRETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM \"Parties\"\n    WHERE \"payment_method_code\" = p_payment_method;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Individuals",
      "Organizations",
      "Addresses",
      "Party_Addresses"
    ],
    "call_sqls": [
      "SELECT count_parties_by_payment_method('Cheque');",
      "SELECT count_parties_by_payment_method('Credit Card');",
      "SELECT count_parties_by_payment_method('Cash');",
      "SELECT count_parties_by_payment_method('Bank Transfer');",
      "SELECT count_parties_by_payment_method('PayPal');"
    ],
    "summary": "Create a PL/pgSQL function named `count_parties_by_payment_method` that takes a text parameter `p_payment_method` and returns an integer. Count and return the number of rows in the `Parties` table where the `payment_method_code` matches the provided parameter.",
    "natural_language": "How many rows in the `Parties` table have a `payment_method_code` that matches a given text parameter, and how can this be returned as an integer from a PL/pgSQL function named `count_parties_by_payment_method`?",
    "id": 5
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_organization_name that accepts a single input parameter p_organization_id of type bigint, which represents the unique identifier for an organization, and returns a value of type text. The function declares a local variable v_name of type text to temporarily store the result. The function's logic executes a SELECT query that retrieves the value from the organization_name column within the Organizations table, specifically from the row where the organization_id column exactly matches the provided input parameter p_organization_id, and assigns this retrieved value into the local variable v_name. The function then concludes by returning the value stored in v_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_organization_name(p_organization_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_name text;\nBEGIN\n    SELECT \"organization_name\" INTO v_name\n    FROM \"Organizations\"\n    WHERE \"organization_id\" = p_organization_id;\n    RETURN v_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Individuals",
      "Organizations",
      "Addresses",
      "Party_Addresses"
    ],
    "call_sqls": [
      "SELECT get_organization_name(1);",
      "SELECT get_organization_name(2);",
      "SELECT get_organization_name(3);",
      "SELECT get_organization_name(4);",
      "SELECT get_organization_name(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_organization_name` that takes a bigint parameter `p_organization_id` and returns text. Select and return the `organization_name` from the `Organizations` table where the `organization_id` matches the provided parameter.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_organization_name`. This function shall accept a single parameter of type bigint, named `p_organization_id`, and is defined to return a text value. Its operational logic must involve querying the `Organizations` table to retrieve and subsequently return the `organization_name` for the record whose `organization_id` corresponds precisely to the supplied input parameter.",
    "id": 6
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_party_address` that accepts a single input parameter, `p_party_id`, which is of type `bigint` and represents the unique identifier for a party. This function is designed to retrieve and return a specific address line associated with the provided party identifier. The function declares a local variable named `v_address` of type `text` to temporarily store the retrieved address line. The core operation involves executing a `SELECT` statement to fetch data. Specifically, it selects the value from the column named `\"line_1_number_building\"` from the table aliased as `a`. This `SELECT` statement performs an `INNER JOIN` operation between two tables: `\"Addresses\"`, aliased as `a`, and `\"Party_Addresses\"`, aliased as `pa`. The join condition specifies that rows from `\"Addresses\"` and `\"Party_Addresses\"` are matched when the value in the `\"address_id\"` column of the `\"Addresses\"` table (`a.\"address_id\"`) is equal to the value in the `\"address_id\"` column of the `\"Party_Addresses\"` table (`pa.\"address_id\"`). After the join, a `WHERE` clause is applied to filter the results, ensuring that only rows where the value in the `\"party_id\"` column of the `\"Party_Addresses\"` table (`pa.\"party_id\"`) matches the value of the input parameter `p_party_id` are considered. The value retrieved from the `\"line_1_number_building\"` column for the matching row is then assigned to the local variable `v_address`. Finally, the function returns the value stored in the `v_address` variable as its output, which is of type `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_party_address(p_party_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_address text;\nBEGIN\n    SELECT \"line_1_number_building\" INTO v_address\n    FROM \"Addresses\" a\n    JOIN \"Party_Addresses\" pa ON a.\"address_id\" = pa.\"address_id\"\n    WHERE pa.\"party_id\" = p_party_id;\n    RETURN v_address;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Individuals",
      "Organizations",
      "Addresses",
      "Party_Addresses"
    ],
    "call_sqls": [
      "SELECT get_party_address(1);",
      "SELECT get_party_address(2);",
      "SELECT get_party_address(10);",
      "SELECT get_party_address(15);",
      "SELECT get_party_address(4);"
    ],
    "summary": "Create a PL/pgSQL function named `get_party_address` that accepts a `p_party_id` (bigint) and returns the `line_1_number_building` (text) for that party by joining the `Addresses` and `Party_Addresses` tables.",
    "natural_language": "Create a comprehensive PL/pgSQL function, which we shall name `get_party_address`, that is designed to accept a single input parameter: a `p_party_id` of the bigint data type. This function's primary purpose is to meticulously retrieve and return the specific `line_1_number_building` detail, stored as text, for the provided party identifier. It accomplishes this by performing a careful join operation between the `Addresses` table and the `Party_Addresses` table, ensuring the correct association is made to locate the precise address information.",
    "id": 7
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the full name of an individual from the Individuals table based on a provided individual_id parameter. The function, named get_individual_full_name, accepts a single parameter p_individual_id of type bigint, which represents the unique identifier of the individual whose full name is to be retrieved. Within the function, a local variable v_full_name of type text is declared to store the concatenated result of the individual's first and last names. The function executes a SELECT statement that concatenates the values from the individual_first_name and individual_last_name columns, separated by a space, for the row where the individual_id column matches the value of the p_individual_id parameter. The concatenated full name is stored in the v_full_name variable. Finally, the function returns the value of v_full_name, which contains the full name of the individual.",
    "plsql": "CREATE OR REPLACE FUNCTION get_individual_full_name(p_individual_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_full_name text;\nBEGIN\n    SELECT CONCAT(\"individual_first_name\", ' ', \"individual_last_name\") INTO v_full_name\n    FROM \"Individuals\"\n    WHERE \"individual_id\" = p_individual_id;\n    RETURN v_full_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Individuals",
      "Organizations",
      "Addresses",
      "Party_Addresses"
    ],
    "call_sqls": [
      "SELECT get_individual_full_name(1);",
      "SELECT get_individual_full_name(2);",
      "SELECT get_individual_full_name(3);",
      "SELECT get_individual_full_name(100);",
      "SELECT get_individual_full_name(p_individual_id := 50);"
    ],
    "summary": "Create a PL/pgSQL function named `get_individual_full_name` that accepts a `p_individual_id` (bigint) and returns a text value containing the concatenated first and last name (separated by a space) from the `Individuals` table.",
    "natural_language": "Write a function called `get_individual_full_name` that takes a person's ID number and gives back their full name from the Individuals table, putting together the first and last parts with a space in between.",
    "id": 8
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_actor_musical_name` that accepts a single input parameter named `actor_id` of data type `integer`. This function is designed to return a value of data type `text`. Internally, the function declares a local variable named `musical_name` of data type `text` to temporarily store the retrieved musical name. The core operation of the function involves a `SELECT` statement that retrieves a single value into the `musical_name` variable. This `SELECT` statement targets the `Name` column from the table named `\"musical\"`. The selection is conditioned by a `WHERE` clause that matches the `Musical_ID` column in the `\"musical\"` table with a `Musical_ID` value obtained from a subquery. The subquery performs a `SELECT` operation on the `Musical_ID` column from the table named `\"actor\"`, where the selection is further conditioned by matching the `Actor_ID` column in the `\"actor\"` table with the value provided by the `actor_id` input parameter. After successfully executing this `SELECT` statement and populating the `musical_name` variable, the function then returns the value stored in the `musical_name` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_musical_name(actor_id integer)\nRETURNS text AS $$\nDECLARE\n    musical_name text;\nBEGIN\n    SELECT \"Name\" INTO musical_name FROM \"musical\"\n    WHERE \"Musical_ID\" = (SELECT \"Musical_ID\" FROM \"actor\" WHERE \"Actor_ID\" = actor_id);\n    RETURN musical_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_musical_name(1);",
      "SELECT get_actor_musical_name(2);",
      "SELECT get_actor_musical_name(3);"
    ],
    "summary": "Create a PLpgSQL function named get_actor_musical_name that returns text. It accepts an actor_id. The function should return the Name from the musical table for the musical associated with the given actor_id, based on matching the Musical_ID from the actor table.",
    "natural_language": "Write a PLpgSQL function called get_actor_musical_name that returns text. It should take an actor_id as input. The function must fetch and return the Name from the musical table for the musical linked to the provided actor_id, using the Musical_ID from the actor table to find the match.",
    "id": 9
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the name of an actor from the actor table, identified by the Actor_ID column matching the provided actor_id parameter of type integer, and transforms this name into capitalized form using the initcap function, which converts the first letter of each word to uppercase and the rest to lowercase, storing the result in a variable named actor_name of type text, and then returns this capitalized name as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION capitalize_actor_name(actor_id integer)\nRETURNS text AS $$\nDECLARE\n    actor_name text;\nBEGIN\n    SELECT initcap(\"Name\") INTO actor_name FROM \"actor\" WHERE \"Actor_ID\" = actor_id;\n    RETURN actor_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT capitalize_actor_name(1);",
      "SELECT capitalize_actor_name(2);",
      "SELECT capitalize_actor_name(3);",
      "SELECT capitalize_actor_name(4);",
      "SELECT capitalize_actor_name(5);"
    ],
    "summary": "Create a PLpgSQL function that returns text. It accepts an actor_id. The function should retrieve the actor's name from the actor table where Actor_ID matches the input, transform the name to capitalized form (first letter of each word uppercase), and return the result.",
    "natural_language": "Develop a PLpgSQL function that yields a text output. This function must take a single actor identifier as its parameter. Within the function, query the actor table to fetch the full name of the actor whose unique Actor_ID corresponds precisely to the provided input value. Subsequently, apply a transformation to convert the retrieved name into a properly capitalized format, where the initial letter of every individual word is changed to uppercase, while all other letters are set to lowercase. Finally, the function should elegantly return this meticulously formatted name as its result.",
    "id": 10
  },
  {
    "ir": "Write a PLpgSQL function named get_musical_award that accepts a single input parameter named musical_id of integer data type, which is used to identify a specific musical record, and returns a value of text data type; within the function, a local variable named award of text data type is declared, then a SELECT query is executed against the table named \"musical\" to retrieve the value from the column named \"Award\" for the row where the column \"Musical_ID\" exactly matches the provided musical_id input parameter, and this retrieved value is stored into the local award variable using the INTO clause, after which the function concludes by returning the value contained in the award variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_musical_award(musical_id integer)\nRETURNS text AS $$\nDECLARE\n    award text;\nBEGIN\n    SELECT \"Award\" INTO award FROM \"musical\" WHERE \"Musical_ID\" = musical_id;\n    RETURN award;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_musical_award(1);",
      "SELECT get_musical_award(2);",
      "SELECT get_musical_award(3);"
    ],
    "summary": "Create a PLpgSQL function named get_musical_award that returns text. It accepts a musical_id. The function should retrieve and return the value from the Award column in the musical table for the row where Musical_ID matches the provided musical_id.",
    "natural_language": "What is the award for the musical with the specified musical_id?",
    "id": 11
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_actor_character that accepts a single mandatory input parameter named actor_id of integer data type, and returns a value of text data type; within the function, declare a local variable named character_name of text data type, then execute a SELECT query that retrieves a single column value from the \"Character\" column of the \"actor\" table, assigning that retrieved value into the character_name variable, where the selection is conditioned upon the \"Actor_ID\" column in the \"actor\" table being exactly equal to the provided actor_id input parameter value, and finally, the function returns the value stored in the character_name variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_character(actor_id integer)\nRETURNS text AS $$\nDECLARE\n    character_name text;\nBEGIN\n    SELECT \"Character\" INTO character_name FROM \"actor\" WHERE \"Actor_ID\" = actor_id;\n    RETURN character_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_character(1);",
      "SELECT get_actor_character(2);",
      "SELECT get_actor_character(3);",
      "SELECT get_actor_character(4);",
      "SELECT get_actor_character(5);"
    ],
    "summary": "Create a function named get_actor_character that takes an integer actor_id and returns text. It selects the Character column from the actor table where Actor_ID matches the input, stores it in a variable, and returns that value.",
    "natural_language": "Write function get_actor_character(actor_id int) returning text. Fetch Character from actor where Actor_ID matches, store it, and return.",
    "id": 12
  },
  {
    "ir": "Write a PL/pgSQL function named `get_album_year_or_default` that accepts a single input parameter named `album_id` of type `bigint`. This function is designed to return a `bigint` value. Inside the function, a local variable named `result` of type `bigint` is declared. The function then executes a `SELECT` statement to retrieve the value from the column named `\"Year\"` from the table named `\"Albums\"`. This selection is performed for the row where the value in the column named `\"AId\"` is equal to the value provided by the input parameter `album_id`. The retrieved value is then assigned to the local variable `result`. Following this, a conditional check is performed: if the value stored in the `result` variable is `NULL`, the function immediately returns the `bigint` literal value `2000`. If the `result` variable is not `NULL`, the function proceeds to return the value currently stored in the `result` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_album_year_or_default(album_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    result bigint;\nBEGIN\n    SELECT \"Year\" INTO result FROM \"Albums\" WHERE \"AId\" = album_id;\n    IF result IS NULL THEN\n        RETURN 2000;\n    END IF;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Songs",
      "Tracklists",
      "Instruments",
      "Vocals"
    ],
    "call_sqls": [
      "SELECT get_album_year_or_default(1);",
      "SELECT get_album_year_or_default(2);",
      "SELECT get_album_year_or_default(3);",
      "SELECT get_album_year_or_default(4);",
      "SELECT get_album_year_or_default(5);"
    ],
    "summary": "Create a function named get_album_year_or_default that takes a bigint album_id and returns a bigint. It selects the Year from the Albums table where AId matches the input. If the result is NULL, return 2000; otherwise, return the result.",
    "natural_language": "Create a function, which should be named get_album_year_or_default, that is designed to accept a single bigint parameter representing an album_id. This function must return a bigint value. Its core operation involves querying the Albums table to carefully select the Year column specifically for the entry whose AId column precisely matches the provided input identifier. In the detailed scenario where this query yields a NULL result, indicating the year is absent, the function should thoughtfully return a default value of 2000. Conversely, if a valid year is successfully retrieved, it should simply and directly return that actual result.",
    "id": 13
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter album_id of type bigint and returns a bigint. The function first checks if the provided album_id is not NULL. If album_id is not NULL, it executes a SELECT statement to count the number of rows in the \"Tracklists\" table where the \"AlbumId\" column matches the provided album_id. The result of this COUNT operation, which represents the number of tracks associated with the specified album, is then returned by the function. If the album_id is NULL, the function returns 0, indicating that no tracks are associated with a NULL album identifier.",
    "plsql": "CREATE OR REPLACE FUNCTION count_album_tracks(album_id bigint)\nRETURNS bigint AS $$\nBEGIN\n    IF album_id IS NOT NULL THEN\n        RETURN (SELECT COUNT(*) FROM \"Tracklists\" WHERE \"AlbumId\" = album_id);\n    END IF;\n    RETURN 0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Songs",
      "Tracklists",
      "Instruments",
      "Vocals"
    ],
    "call_sqls": [
      "SELECT count_album_tracks(1);",
      "SELECT count_album_tracks(2);",
      "SELECT count_album_tracks(3);",
      "SELECT count_album_tracks(4);",
      "SELECT count_album_tracks(5);"
    ],
    "summary": "Create a PLpgSQL function that takes a bigint album_id and returns a bigint. If album_id is not null, return the count of tracks in the \"Tracklists\" table for that album. If album_id is null, return 0.",
    "natural_language": "Write a PLpgSQL function that accepts a bigint for an album and gives back a bigint. When the provided album identifier has a value, fetch the approximate number of entries for it from the \"Tracklists\" table. If no specific album is given or the identifier is missing, just return zero.",
    "id": 14
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_state of type text and returns a numeric value representing the average enrollment from the university table. The function performs a SELECT operation to calculate the average of the \"Enrollment\" column for rows where the \"State\" column matches the value of the p_state parameter. The function uses the AVG() aggregate function to compute the average enrollment, and the result is returned directly from the SELECT statement. The function is defined using the plpgsql language and does not include any conditional statements or additional logic beyond the selection and aggregation of data based on the specified state condition.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_enrollment_by_state(p_state text)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT AVG(\"Enrollment\") FROM university WHERE \"State\" = p_state);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT get_average_enrollment_by_state('Illinois');",
      "SELECT get_average_enrollment_by_state('Wisconsin');",
      "SELECT get_average_enrollment_by_state('California');",
      "SELECT get_average_enrollment_by_state('New York');",
      "SELECT get_average_enrollment_by_state('Texas');"
    ],
    "summary": "Create a PLpgSQL function that takes a text p_state and returns a numeric average enrollment from the university table for rows matching the given state.",
    "natural_language": "Write a PLpgSQL function that, for a provided state text, gives back a rough average of the enrollment numbers from the university data where the state is about right.",
    "id": 15
  },
  {
    "ir": "Write a PLpgSQL function that takes an integer parameter p_university_id and returns an integer representing the count of rows in the major_ranking table where the University_ID column matches the provided p_university_id. The function performs a SELECT COUNT(*) operation on the major_ranking table, filtering the results based on the condition that the University_ID column is equal to the input parameter p_university_id. The function is defined using the plpgsql language and is designed to encapsulate the logic for counting the number of majors associated with a specific university, identified by the university's unique identifier passed as the parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION count_majors_for_university(p_university_id integer)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM major_ranking WHERE \"University_ID\" = p_university_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT count_majors_for_university(1);",
      "SELECT count_majors_for_university(2);",
      "SELECT count_majors_for_university(3);",
      "SELECT count_majors_for_university(10);",
      "SELECT count_majors_for_university(NULL);"
    ],
    "summary": "Create a PLpgSQL function that takes an integer p_university_id and returns an integer count of majors in the major_ranking table for that university.",
    "natural_language": "How many majors are listed in the major_ranking table for a given university, identified by its ID?",
    "id": 16
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns the name of the top-ranked university from the university table. This function, named get_top_ranked_university_name, does not take any parameters and returns a text value. It performs a SELECT operation to obtain the \"University_Name\" from the university table, aliased as 'u'. The function joins the university table with the overall_ranking table, aliased as 'o', on the condition that the \"University_ID\" column in both tables matches. It filters the results to include only the row where the \"Rank\" column in the overall_ranking table is equal to 1, indicating the top rank. The results are ordered by the \"University_ID\" column in ascending order, and the LIMIT clause ensures that only the first result is returned. The function is defined using the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_top_ranked_university_name()\nRETURNS text AS $$\nBEGIN\n    RETURN (\n        SELECT u.\"University_Name\" \n        FROM university u \n        JOIN overall_ranking o ON u.\"University_ID\" = o.\"University_ID\" \n        WHERE o.\"Rank\" = 1\n        ORDER BY u.\"University_ID\"\n        LIMIT 1\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT get_top_ranked_university_name();"
    ],
    "summary": "Create a PLpgSQL function named get_top_ranked_university_name with no parameters that returns text. It returns the name of the university with a rank of 1 from the university table joined with the overall_ranking table.",
    "natural_language": "List the name of the top-ranked university by returning the university name with a rank of 1 from the university and overall_ranking tables.",
    "id": 17
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_research_percentage that accepts a single integer input parameter named p_university_id, which is used to identify a specific university, and returns a numeric value; the function's body executes a single SQL query that selects from the overall_ranking table, specifically targeting the row where the University_ID column matches the provided p_university_id parameter; within that selected row, the query retrieves the values of two columns, Research_point and Total, and uses a CASE conditional expression to evaluate if the value in the Total column is greater than zero; if the Total is greater than zero, the function calculates the percentage by multiplying the Research_point value by 100.0, dividing the result by the Total value, and returning this computed numeric percentage; if the Total is not greater than zero (i.e., it is zero or null, though null would make the condition false), the CASE expression returns the numeric value zero; the result of this CASE expression is then directly returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_research_percentage(p_university_id integer)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT CASE WHEN \"Total\" > 0 THEN (\"Research_point\" * 100.0 / \"Total\") ELSE 0 END FROM overall_ranking WHERE \"University_ID\" = p_university_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT calculate_research_percentage(1);",
      "SELECT calculate_research_percentage(2);",
      "SELECT calculate_research_percentage(3);"
    ],
    "summary": "Create a PLpgSQL function named calculate_research_percentage that takes an integer p_university_id and returns a numeric value. It calculates (Research_point * 100.0 / Total) from the overall_ranking table for the given university. If Total is not greater than zero, return 0.",
    "natural_language": "Write a PLpgSQL function called calculate_research_percentage that accepts an integer parameter p_university_id and outputs a numeric. The function should compute (Research_point * 100.0 / Total) from the overall_ranking table for the specified university. Return 0 if Total is not greater than zero.",
    "id": 18
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_church_wedding_count` that is designed to retrieve the total number of wedding records associated with a specific church. This function accepts a single input parameter, `p_church_id`, which is of data type `integer` and represents the unique identifier of the church for which the wedding count is to be determined. The function is declared to return a single value of data type `integer`, which will be the calculated count of weddings. Internally, the function declares a local variable named `v_wedding_count`, also of data type `integer`, to temporarily store the result of the database query. The core operation involves executing a `SELECT` statement to count all rows in the `wedding` table. The `COUNT(*)` aggregate function is used to count all rows that satisfy a specific condition. This condition is `WHERE \"Church_ID\" = p_church_id`, which filters the `wedding` table to include only those records where the value in the column named `\"Church_ID\"` (which is case-sensitive due to the double quotes) exactly matches the value provided in the input parameter `p_church_id`. The result of this `COUNT(*)` operation is then assigned to the local variable `v_wedding_count` using the `INTO` clause. Finally, the function returns the value stored in `v_wedding_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_church_wedding_count(p_church_id integer)\nRETURNS integer AS $$\nDECLARE\n    v_wedding_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_wedding_count\n    FROM wedding\n    WHERE \"Church_ID\" = p_church_id;\n    \n    RETURN v_wedding_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_church_wedding_count(1);",
      "SELECT get_church_wedding_count(2);",
      "SELECT get_church_wedding_count(3);",
      "SELECT get_church_wedding_count(4);",
      "SELECT get_church_wedding_count(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_church_wedding_count` that takes a church ID as an integer input and returns the integer count of wedding records for that church from the wedding table.",
    "natural_language": "Yo, I need a PL/pgSQL function called `get_church_wedding_count`. It should take a church's ID (as an integer) and spit back how many weddings they've had, you know, the count from the wedding table. Just give me the number.",
    "id": 19
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_oldest_person_in_church` that accepts a single input parameter, `p_church_id`, which is of type `integer` and represents the unique identifier of a church. This function is designed to return a value of type `text`, which will be the name of the oldest person associated with the specified church.\n\nUpon execution, the function declares a local variable named `v_oldest_person` of type `text` to temporarily store the name of the identified oldest person. The core operation involves a `SELECT` statement that retrieves data from the `people` table, aliased as `p`. This `SELECT` statement is joined with the `wedding` table, aliased as `w`, using an `ON` clause. The join condition specifies that a record from the `people` table is linked to a record from the `wedding` table if the `People_ID` column from the `people` table (`p.\"People_ID\"`) matches either the `Male_ID` column (`w.\"Male_ID\"`) or the `Female_ID` column (`w.\"Female_ID\"`) in the `wedding` table. This effectively links individuals to their wedding records.\n\nFollowing the join, a `WHERE` clause filters the results to include only those records where the `Church_ID` column from the `wedding` table (`w.\"Church_ID\"`) is equal to the input parameter `p_church_id`. This ensures that only people associated with the specified church are considered.\n\nThe filtered results are then ordered in descending order based on the `Age` column from the `people` table (`p.\"Age\"`), meaning the oldest individuals will appear first. Finally, the `LIMIT 1` clause restricts the output to only the single top record after sorting, which corresponds to the oldest person.\n\nThe `Name` column from this single oldest person's record (`p.\"Name\"`) is then assigned to the `v_oldest_person` variable. After this assignment, the function returns the value stored in `v_oldest_person`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_person_in_church(p_church_id integer)\nRETURNS text AS $$\nDECLARE\n    v_oldest_person text;\nBEGIN\n    SELECT p.\"Name\" INTO v_oldest_person\n    FROM people p\n    JOIN wedding w ON p.\"People_ID\" IN (w.\"Male_ID\", w.\"Female_ID\")\n    WHERE w.\"Church_ID\" = p_church_id\n    ORDER BY p.\"Age\" DESC\n    LIMIT 1;\n    \n    RETURN v_oldest_person;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_oldest_person_in_church(1);",
      "SELECT get_oldest_person_in_church(3);",
      "SELECT get_oldest_person_in_church(5);",
      "SELECT get_oldest_person_in_church(2);",
      "SELECT get_oldest_person_in_church(4);"
    ],
    "summary": "Create a PL/pgSQL function named `get_oldest_person_in_church` that takes a church ID as an integer input and returns the name (as text) of the oldest person associated with that church by joining the people and wedding tables.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_oldest_person_in_church`. This function should accept a church identifier as an integer parameter. Its purpose is to retrieve and return, as a text value, the name of the most senior individual affiliated with the specified church. This determination is to be made by performing a join operation between the `people` and `wedding` tables.",
    "id": 20
  },
  {
    "ir": "Write a PLpgSQL function named get_church_open_date that accepts a single parameter p_church_id of type integer, which represents the unique identifier of a church. The function is designed to retrieve the open date of a church from the church table. It declares a local variable v_open_date of type integer to store the result of the query. The function performs a SELECT operation on the church table, specifically targeting the Open_Date column, and assigns the retrieved value to the v_open_date variable. The selection is based on the condition that the Church_ID column in the church table matches the value of the input parameter p_church_id. After successfully retrieving the open date, the function returns the value stored in v_open_date. The function is written in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_church_open_date(p_church_id integer)\nRETURNS integer AS $$\nDECLARE\n    v_open_date integer;\nBEGIN\n    SELECT c.\"Open_Date\" INTO v_open_date\n    FROM church c\n    WHERE c.\"Church_ID\" = p_church_id;\n    \n    RETURN v_open_date;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_church_open_date(1);",
      "SELECT get_church_open_date(2);",
      "SELECT get_church_open_date(3);",
      "SELECT get_church_open_date(4);",
      "SELECT get_church_open_date(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_church_open_date` that takes a church ID as an integer input and returns the integer open date for that church from the church table.",
    "natural_language": "Write a function called `get_church_open_date` that, when given a church's ID number, fetches and gives back roughly when that church first opened from the main list, as a simple number.",
    "id": 21
  },
  {
    "ir": "Write a PLpgSQL function that calculates the average age of wedding participants associated with a specific church. The function, named get_average_age_of_wedding_participants, accepts a single parameter p_church_id of type integer, which represents the unique identifier of a church. Within the function, declare a variable v_avg_age of type numeric to store the computed average age. Execute a SELECT statement that calculates the average age of people involved in weddings by joining the people table, aliased as p, with the wedding table, aliased as w, on the condition that the People_ID column in the people table matches either the Male_ID or Female_ID columns in the wedding table. Further filter the results to include only those weddings where the Church_ID column in the wedding table equals the input parameter p_church_id. Store the result of the average age calculation into the variable v_avg_age. Use the COALESCE function to ensure that the function returns 0 if the computed average age is null, and then return the value of v_avg_age.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_age_of_wedding_participants(p_church_id integer)\nRETURNS numeric AS $$\nDECLARE\n    v_avg_age numeric;\nBEGIN\n    SELECT AVG(p.\"Age\") INTO v_avg_age\n    FROM people p\n    JOIN wedding w ON p.\"People_ID\" IN (w.\"Male_ID\", w.\"Female_ID\")\n    WHERE w.\"Church_ID\" = p_church_id;\n    \n    RETURN COALESCE(v_avg_age, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_average_age_of_wedding_participants(1);",
      "SELECT get_average_age_of_wedding_participants(2);",
      "SELECT get_average_age_of_wedding_participants(3);",
      "SELECT get_average_age_of_wedding_participants(5);",
      "SELECT get_average_age_of_wedding_participants(10);"
    ],
    "summary": "Create a PL/pgSQL function named `get_average_age_of_wedding_participants` that takes a church ID as an integer input and returns the numeric average age of people involved in weddings at that church, returning 0 if the result is null.",
    "natural_language": "Write a PL/pgSQL function called `get_average_age_of_wedding_participants` that accepts a church ID as an integer and gives back the numeric average age of people taking part in weddings at that church. Ensure it returns 0 if the average is null.",
    "id": 22
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_wedding_years_in_church` that accepts a single input parameter, `p_church_id`, which is of data type `integer`. This function is designed to return a set of `integer` values. The core operation of this function involves querying the `wedding` table. Specifically, it selects the distinct values from the `\"Year\"` column of the `wedding` table. This selection is filtered by a condition: the value in the `\"Church_ID\"` column of the `wedding` table must be equal to the value provided in the `p_church_id` input parameter. The `DISTINCT` keyword ensures that only unique year values are returned, eliminating any duplicate years for weddings held in the specified church. The `RETURN QUERY` statement is used to return the result set of this `SELECT` statement directly as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_wedding_years_in_church(p_church_id integer)\nRETURNS SETOF integer AS $$\nBEGIN\n    RETURN QUERY\n    SELECT DISTINCT w.\"Year\"\n    FROM wedding w\n    WHERE w.\"Church_ID\" = p_church_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT * FROM get_wedding_years_in_church(1);",
      "SELECT * FROM get_wedding_years_in_church(2);",
      "SELECT * FROM get_wedding_years_in_church(3);",
      "SELECT * FROM get_wedding_years_in_church(4);",
      "SELECT * FROM get_wedding_years_in_church(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_wedding_years_in_church` that takes a church ID as an integer input and returns a set of distinct integer years when weddings occurred at that church from the wedding table.",
    "natural_language": "What are the distinct years in which weddings took place at a specific church, given its ID?",
    "id": 23
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_book_rating_ratio` that accepts two input parameters: `p_book_id`, an integer representing the unique identifier of a book, and `p_multiplier`, a real number used as a scaling factor. This function is designed to return a single real number as its result. Upon execution, the function declares a local variable named `v_ratio` of type real. The core operation involves executing a `SELECT` statement to retrieve data from the `review` table. Specifically, it calculates a value by dividing the numerical content of the column named `\"Rating\"` by the numerical content of the column named `\"Readers_in_Million\"`, and then multiplies this intermediate result by the value provided in the `p_multiplier` input parameter. The outcome of this calculation is then assigned to the local variable `v_ratio`. This selection is conditional, applying only to rows in the `review` table where the value in the column named `\"Book_ID\"` precisely matches the integer value provided in the `p_book_id` input parameter. Finally, the function returns the calculated value stored in the `v_ratio` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_book_rating_ratio(p_book_id integer, p_multiplier real)\nRETURNS real AS $$\nDECLARE\n    v_ratio real;\nBEGIN\n    SELECT (\"Rating\" / \"Readers_in_Million\") * p_multiplier INTO v_ratio FROM review WHERE \"Book_ID\" = p_book_id;\n    RETURN v_ratio;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT calculate_book_rating_ratio(1, 1.5);",
      "SELECT calculate_book_rating_ratio(2, 2.0);",
      "SELECT calculate_book_rating_ratio(3, 0.8);",
      "SELECT calculate_book_rating_ratio(4, 1.2);",
      "SELECT calculate_book_rating_ratio(1, 1.0);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_book_rating_ratio` that takes a book ID (`integer`) and a multiplier (`real`), and returns a `real`. For the given book ID in the `review` table, calculate the ratio by dividing the `\"Rating\"` by `\"Readers_in_Million\"` and then multiplying by the provided multiplier. Return this calculated ratio.",
    "natural_language": "Write a function called `calculate_book_rating_ratio` that gives back a real number. It needs a book ID and a multiplier. For that book, look at its reviews and figure out a value. Basically, take the rating, divide it by how many readers it has, and then adjust that result using the multiplier. Return whatever that final number comes out to be.",
    "id": 24
  },
  {
    "ir": "Write a PLpgSQL function named get_book_release_year that accepts two parameters: p_book_id of type integer, which specifies the unique identifier of a book, and p_format_type of type text, which determines the format of the release date to be returned. The function declares a local variable v_result of type text to store the result. It begins by checking if the value of p_format_type is equal to 'YEAR'. If this condition is true, the function executes a SELECT statement that retrieves the year part of the \"Release\" date from the book table, where the \"Book_ID\" column matches the provided p_book_id. The \"Release\" column is expected to be in the format 'Month YYYY', and the EXTRACT function is used to extract the year after converting the \"Release\" string to a date using the TO_DATE function. The extracted year is then cast to text and stored in v_result. If the condition is false, the function executes an alternative SELECT statement that retrieves the entire \"Release\" value from the book table for the specified \"Book_ID\" and stores it in v_result. Finally, the function returns the value of v_result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_release_year(p_book_id integer, p_format_type text)\nRETURNS text AS $$\nDECLARE\n    v_result text;\nBEGIN\n    IF p_format_type = 'YEAR' THEN\n        SELECT EXTRACT(YEAR FROM TO_DATE(\"Release\", 'Month YYYY'))::text INTO v_result FROM book WHERE \"Book_ID\" = p_book_id;\n    ELSE\n        SELECT \"Release\" INTO v_result FROM book WHERE \"Book_ID\" = p_book_id;\n    END IF;\n    RETURN v_result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT get_book_release_year(1, 'YEAR');",
      "SELECT get_book_release_year(2, 'YEAR');",
      "SELECT get_book_release_year(3, 'YEAR');",
      "SELECT get_book_release_year(1, 'FULL');",
      "SELECT get_book_release_year(2, 'FULL');"
    ],
    "summary": "Create a PL/pgSQL function named get_book_release_year that returns the release date for a given Book_ID. If the format parameter is 'YEAR', return only the year part; otherwise, return the full date string.",
    "natural_language": "What is the PL/pgSQL function definition for get_book_release_year that returns the release date for a specified Book_ID, and how does it handle returning only the year when the format is 'YEAR' versus the full date string otherwise?",
    "id": 25
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: staff_name of type TEXT and conference_name of type TEXT. The function returns a BOOLEAN value. It begins by declaring a local variable is_participating of type BOOLEAN, initialized to FALSE. The function first checks if there exists a record in the staff table where the name column matches the provided staff_name. If such a record exists, it proceeds to execute a nested SELECT query. This query checks for the existence of a record in the conference_participation table, aliased as cp, where the staff_ID column matches the staff_ID of the staff member with the given staff_name. This is determined by a subquery that selects the staff_ID from the staff table where the name matches staff_name. Additionally, the query joins the conference table, aliased as c, on the condition that the Conference_ID column in conference_participation matches the Conference_ID in conference. The WHERE clause of this query further filters the results to ensure that the Conference_Name in the conference table matches the provided conference_name. The result of this EXISTS query is assigned to the is_participating variable. Finally, the function returns the value of is_participating, indicating whether the specified staff member is participating in the specified conference.",
    "plsql": "CREATE OR REPLACE FUNCTION check_staff_participation(staff_name TEXT, conference_name TEXT)\nRETURNS BOOLEAN AS $$\nDECLARE\n    is_participating BOOLEAN := FALSE;\nBEGIN\n    IF EXISTS(SELECT 1 FROM staff WHERE name = staff_name) THEN\n        SELECT EXISTS(\n            SELECT 1 FROM conference_participation cp\n            JOIN conference c ON cp.\"Conference_ID\" = c.\"Conference_ID\"\n            WHERE c.\"Conference_Name\" = conference_name AND cp.\"staff_ID\" = (SELECT \"staff_ID\" FROM staff WHERE name = staff_name)\n        ) INTO is_participating;\n    END IF;\n    RETURN is_participating;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "SELECT check_staff_participation('Bobby Jackson', 'ACL');",
      "SELECT check_staff_participation('Casey Jacobsen', 'Naccl');",
      "SELECT check_staff_participation('Alexander Johnson', 'ACL');",
      "SELECT check_staff_participation('Bobby Jackson', 'Naccl');",
      "SELECT check_staff_participation('Casey Jacobsen', 'ACL');"
    ],
    "summary": "Create a PL/pgSQL function that returns a BOOLEAN indicating if a staff member with a given name is participating in a conference with a given name.",
    "natural_language": "Write a function that checks, maybe, if a staff person whose name is roughly like a certain one is involved in a conference that has a name kind of similar to another given one, and returns a true or false result.",
    "id": 26
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `count_conferences_by_location` that accepts a single input parameter named `location` of type `TEXT`. This function is designed to return an `INTEGER` value representing the count of conferences. Upon execution, the function initializes a local variable named `conference_count` to `0`, which is also of type `INTEGER`. The core logic of the function then proceeds with a conditional check: it evaluates whether the `strpos` function, which searches for the first occurrence of a substring within a string, returns `0` when searching for a space character (`' '`) within the `location` parameter. If `strpos` returns `0`, it indicates that the `location` parameter does not contain any space characters. In this specific scenario, the function executes a `SELECT` statement to count the total number of rows in the `conference` table. This count is specifically filtered by a `WHERE` clause, which ensures that only rows where the value in the column named `\"Location\"` (case-sensitive due to double quotes) exactly matches the value provided in the `location` input parameter are included in the count. The result of this `COUNT(*)` operation is then assigned to the `conference_count` variable. If the initial conditional check (i.e., `strpos(location, ' ') = 0`) evaluates to false, meaning the `location` parameter contains one or more space characters, the `SELECT` statement is entirely skipped, and the `conference_count` variable retains its initial value of `0`. Finally, the function returns the current value stored in the `conference_count` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION count_conferences_by_location(location TEXT)\nRETURNS INTEGER AS $$\nDECLARE\n    conference_count INTEGER := 0;\nBEGIN\n    IF strpos(location, ' ') = 0 THEN\n        SELECT COUNT(*) INTO conference_count FROM conference WHERE \"Location\" = location;\n    END IF;\n    RETURN conference_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "SELECT count_conferences_by_location('Philippines');",
      "SELECT count_conferences_by_location('Japan');",
      "SELECT count_conferences_by_location('USA');",
      "SELECT count_conferences_by_location('Germany');",
      "SELECT count_conferences_by_location('France');"
    ],
    "summary": "Create a function named count_conferences_by_location that takes a text location parameter and returns an integer. If the location contains no spaces, count and return the number of rows in the conference table where the \"Location\" column exactly matches the input parameter. Otherwise, return 0.",
    "natural_language": "Write a function called count_conferences_by_location that accepts a location as text and gives back a number. If the location is a single word without any spaces, find roughly how many conference records are for that specific place. Otherwise, just return zero.",
    "id": 27
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_conference_year that accepts a single input parameter named conference_name of type TEXT, which represents the name of a conference to look up, and returns an integer value; within the function, declare a local integer variable called conference_year; then check for the existence of a record in the table named conference where the value in the column \"Conference_Name\" exactly matches the input parameter conference_name; if such a record exists, perform a SELECT query on the conference table to retrieve the value from the column \"Year\" for the row where \"Conference_Name\" equals conference_name and store that value into the local variable conference_year; after the conditional block, return the value of the conference_year variable, which will be NULL if no matching conference record was found.",
    "plsql": "CREATE OR REPLACE FUNCTION get_conference_year(conference_name TEXT)\nRETURNS INTEGER AS $$\nDECLARE\n    conference_year INTEGER;\nBEGIN\n    IF EXISTS(SELECT 1 FROM conference WHERE \"Conference_Name\" = conference_name) THEN\n        SELECT \"Year\" INTO conference_year FROM conference WHERE \"Conference_Name\" = conference_name;\n    END IF;\n    RETURN conference_year;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_conference_year('ACL');",
      "SELECT get_conference_year('Naccl');",
      "SELECT get_conference_year('NonExistentConference');",
      "SELECT get_conference_year('AnotherConference');"
    ],
    "summary": "Create a function named get_conference_year that takes a text conference_name and returns an integer. If a matching record exists in the conference table where \"Conference_Name\" equals the input, return its \"Year\" value. Otherwise, return NULL.",
    "natural_language": "Define a function called get_conference_year that accepts a conference_name text parameter and outputs an integer. For a matching conference name in the conference table, output the corresponding Year. If no match is found, output NULL.",
    "id": 28
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_total_order_value` that accepts a single input parameter, `p_order_id`, which is of type `bigint`. This function is designed to calculate and return the total monetary value of a specific order identified by `p_order_id`. The function's return type is `double precision`, indicating that it will output a floating-point number with double-precision accuracy.\n\nUpon execution, the function declares a local variable named `v_total_value` of type `double precision` to temporarily store the calculated total order value. The core operation involves a `SELECT` statement that calculates the sum of the product of `order_quantity` and `product_price` for all items belonging to the order specified by `p_order_id`.\n\nSpecifically, the `SELECT` statement performs the following steps:\n1. It queries the `\"Order_Items\"` table, aliased as `oi`, which presumably stores individual items within orders.\n2. It joins `\"Order_Items\"` (`oi`) with the `\"Products\"` table, aliased as `p`, which presumably contains product details including prices. The join condition is `oi.product_id = p.product_id`, ensuring that each order item is linked to its corresponding product.\n3. For each joined row, it accesses the `order_quantity` column from the `\"Order_Items\"` table. This `order_quantity` is explicitly cast to an `integer` type using `::int`.\n4. It accesses the `product_price` column from the `\"Products\"` table.\n5. It multiplies the cast `order_quantity` by the `product_price` to get the total value for that specific order item.\n6. It then calculates the `SUM` of these individual item values.\n7. The `WHERE` clause filters these calculations to include only those order items where the `order_id` column in the `\"Order_Items\"` table matches the input parameter `p_order_id`.\n8. The calculated `SUM` is then assigned to the local variable `v_total_value` using the `INTO` clause.\n\nFinally, the function returns the value stored in `v_total_value` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_order_value(p_order_id bigint)\nRETURNS double precision\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_value double precision;\nBEGIN\n    SELECT SUM(oi.order_quantity::int * p.product_price) INTO v_total_value\n    FROM \"Order_Items\" oi\n    JOIN \"Products\" p ON oi.product_id = p.product_id\n    WHERE oi.order_id = p_order_id;\n\n    RETURN v_total_value;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_total_order_value(1);",
      "SELECT get_total_order_value(2);",
      "SELECT get_total_order_value(8);",
      "SELECT get_total_order_value(13);",
      "SELECT get_total_order_value(100);"
    ],
    "summary": "Create a function named get_total_order_value that takes a bigint p_order_id and returns a double precision value. Calculate and return the sum of (order_quantity::int * product_price) from the \"Order_Items\" table joined with the \"Products\" table where order_id equals p_order_id.",
    "natural_language": "Function get_total_order_value(p_order_id bigint) returns double precision. Sum order_quantity::int * product_price for that order_id from Order_Items join Products.",
    "id": 29
  },
  {
    "ir": "Write a PLpgSQL function named get_customer_last_order_date that accepts a single input parameter p_customer_id of type bigint, which represents the unique identifier for a customer, and returns a value of type timestamp with time zone. The function declares a local variable v_last_order_date of type timestamp with time zone. The function's logic executes a SELECT statement that queries the \"Customer_Orders\" table, applying a WHERE clause to filter rows where the customer_id column exactly matches the provided input parameter p_customer_id. Within this filtered result set, the function uses the aggregate function MAX on the order_date column to calculate the most recent (maximum) timestamp value, and this result is assigned into the local variable v_last_order_date using the INTO clause. Finally, the function returns the value stored in the v_last_order_date variable, which will be the latest order date for the specified customer or NULL if no orders exist for that customer_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_last_order_date(p_customer_id bigint)\nRETURNS timestamp with time zone\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_last_order_date timestamp with time zone;\nBEGIN\n    SELECT MAX(order_date) INTO v_last_order_date\n    FROM \"Customer_Orders\"\n    WHERE customer_id = p_customer_id;\n\n    RETURN v_last_order_date;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_customer_last_order_date(12);",
      "SELECT get_customer_last_order_date(3);",
      "SELECT get_customer_last_order_date(1);",
      "SELECT get_customer_last_order_date(2);",
      "SELECT get_customer_last_order_date(999);"
    ],
    "summary": "Create a function named get_customer_last_order_date that takes a customer_id (bigint) and returns the most recent order_date (timestamptz) for that customer from the Customer_Orders table.",
    "natural_language": "What is the most recent order date for a given customer ID from the Customer_Orders table?",
    "id": 30
  },
  {
    "ir": "Write a PLpgSQL function that calculates the total sales count for a specific product by summing the order quantities from the \"Order_Items\" table where the product_id matches the provided parameter p_product_id, which is of type bigint. The function begins by declaring a variable v_sales_count of type bigint to store the result of the summation. It then performs a SELECT operation to sum the order_quantity column, casting each value to an integer, from the \"Order_Items\" table, filtering the rows where the product_id column equals the input parameter p_product_id. The result of this summation is stored into the v_sales_count variable. The function concludes by returning the value of v_sales_count, using the COALESCE function to ensure that if v_sales_count is null, a default value of 0 is returned instead.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_sales_count(p_product_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_sales_count bigint;\nBEGIN\n    SELECT SUM(oi.order_quantity::int) INTO v_sales_count\n    FROM \"Order_Items\" oi\n    WHERE oi.product_id = p_product_id;\n    \n    RETURN COALESCE(v_sales_count, 0);\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_product_sales_count(1);",
      "SELECT get_product_sales_count(2);",
      "SELECT get_product_sales_count(3);",
      "SELECT get_product_sales_count(10);",
      "SELECT get_product_sales_count(13);"
    ],
    "summary": "Create a function that takes a product_id (bigint) and returns the total sales count (bigint) by summing the order_quantity from the Order_Items table for that product, returning 0 if no sales are found.",
    "natural_language": "Calculate the total sales count for a given product ID by summing the order quantities from the Order_Items table. Return 0 if there are no sales for that product.",
    "id": 31
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_customer_address_details that accepts a single input parameter p_customer_id of type bigint, which is used to identify a specific customer, and returns a single text value; within the function, a local variable v_address_details of type text is declared to hold the result; the function's logic executes a SELECT query that retrieves data by performing an inner join between the Customers table (aliased as c) and the Addresses table (aliased as a) using the condition that the address_id column from the Customers table matches the address_id column from the Addresses table; from this joined result set, the query specifically extracts the value from the address_details column of the Addresses table and assigns it into the local variable v_address_details, but only for the row where the customer_id column from the Customers table is exactly equal to the provided input parameter p_customer_id; finally, the function returns the content of the v_address_details variable, which will be the address details text for the specified customer or null if no matching customer or address is found.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_address_details(p_customer_id bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_address_details text;\nBEGIN\n    SELECT a.address_details INTO v_address_details\n    FROM \"Customers\" c\n    JOIN \"Addresses\" a ON c.address_id = a.address_id\n    WHERE c.customer_id = p_customer_id;\n    \n    RETURN v_address_details;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_customer_address_details(1);",
      "SELECT get_customer_address_details(2);",
      "SELECT get_customer_address_details(3);",
      "SELECT get_customer_address_details(12);",
      "SELECT get_customer_address_details(9);"
    ],
    "summary": "Create a function named get_customer_address_details that takes a customer_id (bigint) and returns the address_details (text) for that customer by joining the Customers and Addresses tables.",
    "natural_language": "Please construct a function designated as 'get_customer_address_details'. This function shall accept a parameter of type bigint representing a customer identifier and shall return a text value containing the associated address details. The implementation must perform a join operation between the Customers and Addresses tables to retrieve the requisite information.",
    "id": 32
  },
  {
    "ir": "Write a PLpgSQL function named generate_customer_complaint_summary that returns a table with three columns: customer_id of type bigint, total_complaints of type bigint, and latest_complaint_date of type timestamp with time zone. The function performs a query operation that retrieves data from two tables, Customers and Complaints. It begins by selecting the customer_id from the Customers table and performs a LEFT JOIN operation with the Complaints table on the condition that the customer_id in the Customers table matches the customer_id in the Complaints table. For each customer_id, it calculates the total number of complaints by counting the complaint_id from the Complaints table and casting the result to bigint, and it determines the latest date a complaint was raised by finding the maximum value of the date_complaint_raised column from the Complaints table. The results are grouped by customer_id from the Customers table to ensure that each row in the output corresponds to a unique customer. Finally, the output is ordered in descending order based on the total_complaints column, so that customers with the highest number of complaints appear first in the result set.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_customer_complaint_summary()\nRETURNS TABLE(customer_id bigint, total_complaints bigint, latest_complaint_date timestamp with time zone)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT c.\"customer_id\", \n           COUNT(co.\"complaint_id\")::bigint as total_complaints,\n           MAX(co.\"date_complaint_raised\") as latest_complaint_date\n    FROM \"Customers\" c\n    LEFT JOIN \"Complaints\" co ON c.\"customer_id\" = co.\"customer_id\"\n    GROUP BY c.\"customer_id\"\n    ORDER BY total_complaints DESC;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "SELECT * FROM generate_customer_complaint_summary();",
      "SELECT customer_id, total_complaints FROM generate_customer_complaint_summary() WHERE total_complaints > 0;",
      "SELECT * FROM generate_customer_complaint_summary() ORDER BY latest_complaint_date DESC NULLS LAST;",
      "SELECT customer_id, total_complaints, latest_complaint_date FROM generate_customer_complaint_summary() WHERE total_complaints >= 5;",
      "SELECT * FROM generate_customer_complaint_summary() WHERE customer_id IN (113, 114, 115);"
    ],
    "summary": "Create a PL/pgSQL function named generate_customer_complaint_summary that returns a table. The table columns are customer_id (bigint), total_complaints (bigint), and latest_complaint_date (timestamptz). For each customer, perform a LEFT JOIN between Customers and Complaints, count total complaints, and find the latest complaint date. Group by customer_id and order the results by total_complaints in descending order.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called generate_customer_complaint_summary that spits out a table? We need columns for customer_id (as a bigint), total_complaints (also bigint), and the latest_complaint_date (timestamptz). For every customer, do a LEFT JOIN linking the Customers and Complaints tables, tally up all their complaints, and grab the date of their most recent gripe. Then, bunch everything by customer_id and sort it so the folks with the most complaints show up first.",
    "id": 33
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_college_leader_by_location` that accepts a single input parameter named `location` of data type `text`. This function is designed to retrieve the name of the leader associated with a college located at the specified `location`. Inside the function, a local variable named `leader_name` of data type `text` is declared to temporarily store the retrieved leader's name. The core operation involves executing a `SELECT` statement. This `SELECT` statement queries the table named `\"college\"`. It specifically selects the value from the column named `\"Leader_Name\"` and attempts to store this value into the `leader_name` variable. The selection is constrained by a `WHERE` clause, which filters the rows in the `\"college\"` table. The condition for filtering is that the value in the column named `\"College_Location\"` must be exactly equal to the value provided in the input parameter `location`. After successfully executing the `SELECT` statement and populating the `leader_name` variable, the function then returns the value stored in the `leader_name` variable as its output. The return type of the function is `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_college_leader_by_location(location text)\nRETURNS text\nLANGUAGE plpgsql AS $$\nDECLARE\n  leader_name text;\nBEGIN\n  SELECT \"Leader_Name\" INTO leader_name FROM \"college\" WHERE \"College_Location\" = location;\n  RETURN leader_name;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "SELECT get_college_leader_by_location('Ottawa');",
      "SELECT get_college_leader_by_location('Minnesota');",
      "SELECT get_college_leader_by_location('St. Francis Xavier');",
      "SELECT get_college_leader_by_location('Toronto');",
      "SELECT get_college_leader_by_location(NULL);"
    ],
    "summary": "Create a PL/pgSQL function named get_college_leader_by_location that takes a text parameter 'location' and returns text. Select the \"Leader_Name\" from the \"college\" table where \"College_Location\" matches the input parameter and return the value.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_college_leader_by_location`. This function should accept a single text parameter for the location and yield a text result. Its operation must involve querying the \"college\" table to retrieve the \"Leader_Name\" value where the \"College_Location\" column corresponds precisely to the provided input parameter, subsequently returning that value.",
    "id": 34
  },
  {
    "ir": "Write a PLpgSQL function named get_member_college_name that accepts a single integer input parameter named member_id, which is used to identify a specific member, and returns a text value; within the function, a local text variable named college_name is declared, then a SELECT query is executed to retrieve the value from the \"Name\" column of the \"college\" table, aliased as c, by performing a subquery that first selects the \"College_ID\" from the \"member\" table, aliased as m, where the \"Member_ID\" column in the \"member\" table equals the provided member_id input parameter, and then uses that resulting \"College_ID\" value to find the matching row in the \"college\" table where the \"College_ID\" column equals the subquery result, storing the retrieved \"Name\" value into the college_name variable, which is subsequently returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_college_name(member_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  college_name text;\nBEGIN\n  SELECT c.\"Name\" INTO college_name\n  FROM \"college\" c\n  WHERE c.\"College_ID\" = (SELECT m.\"College_ID\" FROM \"member\" m WHERE m.\"Member_ID\" = member_id);\n  \n  RETURN college_name;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "SELECT get_member_college_name(1);",
      "SELECT get_member_college_name(2);",
      "SELECT get_member_college_name(3);",
      "SELECT get_member_college_name(4);",
      "SELECT get_member_college_name(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_member_college_name that takes an integer parameter 'member_id' and returns text. Using a subquery, find the member's \"College_ID\" from the \"member\" table, then select the corresponding \"Name\" from the \"college\" table and return it.",
    "natural_language": "Write a PL/pgSQL function called get_member_college_name that accepts a member_id integer parameter and returns text. Use a subquery to first get the member's College_ID from the member table, then retrieve the matching Name from the college table and return it.",
    "id": 35
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_round_theme_by_member` that accepts a single input parameter. This parameter, named `member_id`, is of the `integer` data type and represents the unique identifier for a member. The function is designed to return a single value of the `text` data type, which will represent the decoration theme associated with a specific round.\n\nUpon execution, the function declares a local variable named `theme` of the `text` data type. This variable is used to temporarily store the retrieved decoration theme. The core operation of the function is a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"Decoration_Theme\"` from the table named `\"round\"`. The retrieval is conditional, meaning only rows that satisfy a specific criterion are considered. The condition for selection is that the value in the column named `\"Member_ID\"` within the `\"round\"` table must be equal to the value provided by the input parameter `member_id`. The single value retrieved from the `\"Decoration_Theme\"` column of the matching row is then assigned to the local variable `theme`. Finally, the function returns the value currently stored in the `theme` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_round_theme_by_member(member_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  theme text;\nBEGIN\n  SELECT \"Decoration_Theme\" INTO theme FROM \"round\" WHERE \"Member_ID\" = member_id;\n  RETURN theme;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "SELECT get_round_theme_by_member(1);",
      "SELECT get_round_theme_by_member(2);",
      "SELECT get_round_theme_by_member(10);",
      "SELECT get_round_theme_by_member(3);",
      "SELECT get_round_theme_by_member(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_round_theme_by_member that takes an integer parameter 'member_id' and returns text. Select the \"Decoration_Theme\" from the \"round\" table where \"Member_ID\" equals the input parameter and return the value.",
    "natural_language": "Function get_round_theme_by_member(member_id integer) returns text. Fetch Decoration_Theme from round where Member_ID matches given member_id.",
    "id": 36
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the name of a college leader based on a specified country. The function, named get_college_leader_by_member_country, accepts a single parameter, country, of type text, which represents the country of interest. It returns a text value, which is the name of the leader. Within the function, a local variable leader_name of type text is declared to store the leader's name. The function performs a SELECT operation to retrieve the Leader_Name column from the college table, aliased as c, by joining it with the member table, aliased as m, on the College_ID column common to both tables. The WHERE clause filters the results to include only those rows where the Country column in the member table matches the provided country parameter. The LIMIT 1 clause ensures that only one leader name is selected, even if multiple records match the criteria. The INTO STRICT clause is used to assign the result of the SELECT query to the leader_name variable, ensuring that an exception is raised if no data is found. If the SELECT operation does not find any matching records, the NO_DATA_FOUND exception is caught, and the function returns NULL.",
    "plsql": "CREATE OR REPLACE FUNCTION get_college_leader_by_member_country(country text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  leader_name text;\nBEGIN\n  SELECT c.\"Leader_Name\" INTO STRICT leader_name\n  FROM \"college\" c\n  INNER JOIN \"member\" m ON c.\"College_ID\" = m.\"College_ID\"\n  WHERE m.\"Country\" = country\n  LIMIT 1;\n  \n  RETURN leader_name;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "SELECT get_college_leader_by_member_country('United States');",
      "SELECT get_college_leader_by_member_country('Canada');",
      "SELECT get_college_leader_by_member_country('Mexico');",
      "SELECT get_college_leader_by_member_country('United Kingdom');",
      "SELECT get_college_leader_by_member_country('Australia');"
    ],
    "summary": "Create a PL/pgSQL function named get_college_leader_by_member_country that takes a country (text) parameter and returns the leader's name (text). It should join the college and member tables on College_ID, select the Leader_Name where the member's Country matches the input, and return a single result. If no data is found, return NULL.",
    "natural_language": "What is the name of the college leader for members from a specified country, based on joining the college and member tables?",
    "id": 37
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_shop_device_total` that accepts a single input parameter, `p_shop_id`, which is of data type `integer`. This function is designed to return an `integer` value. The function's execution flow begins by evaluating a conditional statement: it checks if the value of `p_shop_id` is strictly greater than `0`. If this condition `p_shop_id > 0` evaluates to true, the function proceeds to execute a `SELECT` statement. This `SELECT` statement calculates the sum of values from the `Quantity` column within the `stock` table. During this summation, the `COALESCE` function is applied to the result of the `SUM` operation, ensuring that if the `SUM` returns a `NULL` value (which would happen if no rows match the `WHERE` clause), it is replaced with `0`. The `WHERE` clause of this `SELECT` statement filters the rows in the `stock` table, including only those where the value in the `Shop_ID` column is equal to the value provided in the `p_shop_id` input parameter. The result of this `SELECT` statement (the calculated sum, or `0` if `NULL`) is then returned by the function. If, however, the initial condition `p_shop_id > 0` evaluates to false (meaning `p_shop_id` is `0` or a negative integer), the function immediately returns the integer value `0` without performing any database queries.",
    "plsql": "CREATE OR REPLACE FUNCTION get_shop_device_total(p_shop_id integer)\nRETURNS integer AS $$\nBEGIN\n    IF p_shop_id > 0 THEN\n        RETURN (SELECT COALESCE(SUM(\"Quantity\"), 0) FROM \"stock\" WHERE \"Shop_ID\" = p_shop_id);\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT get_shop_device_total(1);",
      "SELECT get_shop_device_total(2);",
      "SELECT get_shop_device_total(3);",
      "SELECT get_shop_device_total(10);",
      "SELECT get_shop_device_total(0);"
    ],
    "summary": "Create a PL/pgSQL function named get_shop_device_total that takes a shop_id (integer) parameter and returns an integer. If the shop_id is greater than 0, return the sum of the Quantity column from the stock table for that shop (or 0 if no rows). If the shop_id is 0 or negative, return 0.",
    "natural_language": "Write a function called get_shop_device_total that accepts a shop_id number. It should give back a total count. For a shop_id that seems valid and positive, add up all the Quantity entries linked to that shop from the stock records, or just give back nothing if there's no data. For any shop_id that is zero or seems off or negative, the result should simply be zero.",
    "id": 38
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named check_shop_exists that accepts a single input parameter p_shop_name of type text, which represents the name of a shop to be verified for existence, and returns a boolean value indicating the result of this verification; the function's logic begins by evaluating a conditional IF statement that checks for the existence of at least one record in the table named \"shop\" where the value in the column \"Shop_Name\" exactly matches, using a case-sensitive equality comparison, the provided input parameter p_shop_name; if such a record exists, the function execution proceeds to the THEN branch and returns the boolean value true; if no such record is found, the function execution proceeds to the ELSE branch and returns the boolean value false.",
    "plsql": "CREATE OR REPLACE FUNCTION check_shop_exists(p_shop_name text)\nRETURNS boolean AS $$\nBEGIN\n    IF EXISTS(SELECT 1 FROM \"shop\" WHERE \"Shop_Name\" = p_shop_name) THEN\n        RETURN true;\n    ELSE\n        RETURN false;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT check_shop_exists('Dinas Device');",
      "SELECT check_shop_exists('Best Buy');",
      "SELECT check_shop_exists('Ferndale');",
      "SELECT check_shop_exists('Non-Existent Shop');",
      "SELECT check_shop_exists('Walmart');"
    ],
    "summary": "Create a PL/pgSQL function named check_shop_exists that takes a shop_name (text) parameter and returns a boolean. Return TRUE if a record with that exact Shop_Name exists in the shop table, otherwise return FALSE.",
    "natural_language": "Write a PL/pgSQL function called check_shop_exists that accepts a shop_name text parameter and returns a boolean. Have it return TRUE if a record with that exact Shop_Name is found in the shop table, and FALSE otherwise.",
    "id": 39
  },
  {
    "ir": "Write a PLpgSQL function that accepts an integer parameter p_device_id and returns a text value. The function checks if the provided p_device_id is not null, and if so, it performs a SELECT operation on the device table to retrieve the Software_Platform column value for the row where the Device_ID column matches the p_device_id. If the p_device_id is null, the function returns the text 'Unknown'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_platform(p_device_id integer)\nRETURNS text AS $$\nBEGIN\n    IF p_device_id IS NOT NULL THEN\n        RETURN (SELECT \"Software_Platform\" FROM \"device\" WHERE \"Device_ID\" = p_device_id);\n    ELSE\n        RETURN 'Unknown';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT get_device_platform(1);",
      "SELECT get_device_platform(2);",
      "SELECT get_device_platform(3);",
      "SELECT get_device_platform(NULL);",
      "SELECT get_device_platform(999);"
    ],
    "summary": "Create a function that takes a device ID and returns its software platform from the device table. If the ID is null, return 'Unknown'.",
    "natural_language": "Hey, can you whip up a function that, when you give it a device ID, fetches the software platform for that gadget from the device table? If the ID's null or not found, just have it spit out 'Unknown'.",
    "id": 40
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_total_parties that takes no input parameters and returns a single bigint value, which is the total count of all rows in the table named \"Parties\" by executing a SELECT COUNT(*) query against that table, where the COUNT(*) aggregate function calculates the number of rows without any filtering conditions, and the function returns this computed integer result directly.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_parties()\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM \"Parties\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_government",
    "tables": [
      "Addresses",
      "Forms",
      "Individuals",
      "Organizations",
      "Parties",
      "Party_Addresses",
      "Party_Forms",
      "Services"
    ],
    "call_sqls": [
      "SELECT get_total_parties();"
    ],
    "summary": "Create a function named get_total_parties that returns the total count of all rows in the Parties table.",
    "natural_language": "Please construct a function designated as 'get_total_parties' that will provide the total number of records present within the Parties table.",
    "id": 41
  },
  {
    "ir": "Write a PLpgSQL function named calculate_course_completion_rate that accepts a single parameter p_course_id of type bigint, which represents the unique identifier of a course. The function calculates the completion rate of the specified course and returns it as a numeric value. It begins by declaring three local variables: v_total_students and v_completed_students of type integer, and v_completion_rate of type numeric. The function first executes a SELECT COUNT(*) query on the \"Student_Course_Enrolment\" table to determine the total number of students enrolled in the course identified by p_course_id, storing the result in v_total_students. It then evaluates a conditional statement: if v_total_students equals 0, it assigns 0 to v_completion_rate, indicating no students are enrolled, hence no completion rate. If v_total_students is greater than 0, it performs another SELECT COUNT(*) query on the same table to count the number of students who have completed the course, identified by a non-null date_of_completion, storing this count in v_completed_students. The function then calculates the completion rate by dividing v_completed_students by v_total_students, multiplying by 100.0 to convert it to a percentage, and rounding the result to two decimal places using the ROUND function, assigning this value to v_completion_rate. If neither condition is met, it assigns NULL to v_completion_rate. Finally, the function returns the calculated v_completion_rate.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_course_completion_rate(p_course_id bigint)\nRETURNS numeric AS $$\nDECLARE\n    v_total_students integer;\n    v_completed_students integer;\n    v_completion_rate numeric;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_total_students\n    FROM \"Student_Course_Enrolment\"\n    WHERE course_id = p_course_id;\n\n    IF v_total_students = 0 THEN\n        v_completion_rate := 0;\n    ELSIF v_total_students > 0 THEN\n        SELECT COUNT(*)\n        INTO v_completed_students\n        FROM \"Student_Course_Enrolment\"\n        WHERE course_id = p_course_id AND date_of_completion IS NOT NULL;\n\n        v_completion_rate := ROUND((v_completed_students * 100.0) / v_total_students, 2);\n    ELSE\n        v_completion_rate := NULL;\n    END IF;\n\n    RETURN v_completion_rate;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT calculate_course_completion_rate(1);",
      "SELECT calculate_course_completion_rate(2);",
      "SELECT calculate_course_completion_rate(3);",
      "SELECT calculate_course_completion_rate(4);",
      "SELECT calculate_course_completion_rate(8);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_course_completion_rate that accepts a course_id (bigint) and returns a numeric completion rate. It counts total enrolled students and those with a non-null completion date from the Student_Course_Enrolment table. If no students are enrolled, return 0. Otherwise, calculate the percentage (completed/total * 100) and round to two decimal places.",
    "natural_language": "What is the completion rate for a specific course, calculated as the percentage of enrolled students who have a non-null completion date, rounded to two decimal places, and returning 0 if no students are enrolled?",
    "id": 42
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_student_test_performance` that accepts one input parameter, `p_student_id`, which is of type `bigint`. This function is designed to return a set of records, specifically a table with two columns: `test_date` of type `timestamp with time zone` and `result` of type `text`. The function's logic proceeds conditionally based on the value of `p_student_id`.\n\nFirst, it evaluates if `p_student_id` is `NULL`. If `p_student_id` is indeed `NULL`, the function immediately returns an empty set of records. This is achieved by constructing a `SELECT` statement that projects two `NULL` values, explicitly cast to `timestamp with time zone` and `text` respectively, and then applying a `LIMIT 0` clause to ensure no rows are actually returned.\n\nSecond, if `p_student_id` is not `NULL`, the function then checks if `p_student_id` is greater than `0`. If this condition is true, the function executes a query to retrieve student test performance data. This query selects the `date_test_taken` column and the `test_result` column from the table named `\"Student_Tests_Taken\"`, aliased as `stt`. It then performs an `INNER JOIN` operation with the table named `\"Student_Course_Enrolment\"`, aliased as `sce`. The join condition links `stt.registration_id` with `sce.registration_id`. A `WHERE` clause is applied to filter the joined results, ensuring that only records where `sce.student_id` matches the input parameter `p_student_id` are included in the final output. The results of this `SELECT` statement are then returned as the function's output table.\n\nFinally, if `p_student_id` is neither `NULL` nor greater than `0` (implying it is `0` or a negative value), the function again returns an empty set of records. Similar to the `NULL` case, this is accomplished by a `SELECT` statement projecting two `NULL` values, cast to `timestamp with time zone` and `text`, followed by a `LIMIT 0` clause.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_test_performance(p_student_id bigint)\nRETURNS TABLE(test_date timestamp with time zone, result text) AS $$\nBEGIN\n    IF p_student_id IS NULL THEN\n        RETURN QUERY\n        SELECT NULL::timestamp with time zone, NULL::text\n        LIMIT 0;\n    ELSIF p_student_id > 0 THEN\n        RETURN QUERY\n        SELECT stt.date_test_taken, stt.test_result\n        FROM \"Student_Tests_Taken\" stt\n        JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n        WHERE sce.student_id = p_student_id;\n    ELSE\n        RETURN QUERY\n        SELECT NULL::timestamp with time zone, NULL::text\n        LIMIT 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT * FROM get_student_test_performance(11);",
      "SELECT * FROM get_student_test_performance(15);",
      "SELECT * FROM get_student_test_performance(10);",
      "SELECT * FROM get_student_test_performance(1);",
      "SELECT * FROM get_student_test_performance(2);"
    ],
    "summary": "Create a PL/pgSQL function named get_student_test_performance that returns a table of test_date (timestamptz) and result (text). It accepts a student_id (bigint). If the ID is NULL or not greater than 0, return an empty set. Otherwise, return test data by joining Student_Tests_Taken and Student_Course_Enrolment tables where the student_id matches.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called get_student_test_performance? It should spit out a table with test_date (as timestamptz) and result (as text). It takes a student_id (bigint). If the ID's null or not a positive number, just give back nothing. Otherwise, go fetch the test info by linking up the Student_Tests_Taken and Student_Course_Enrolment tables where the student_id lines up.",
    "id": 43
  },
  {
    "ir": "Write a PLpgSQL function named get_author_course_count that accepts a single parameter, p_author_id, of type bigint, which represents the unique identifier of an author. The function returns an integer value. The function begins by declaring a local variable v_course_count of type integer to store the count of courses associated with the given author. The function then checks if the input parameter p_author_id is NULL; if it is, the function assigns a value of 0 to v_course_count, indicating that no courses are associated with a NULL author ID. If p_author_id is greater than 0, the function executes a SELECT statement to count the number of rows in the \"Courses\" table where the author_id column matches the provided p_author_id. The result of this count is stored in the v_course_count variable. If p_author_id is not greater than 0, the function assigns a NULL value to v_course_count, indicating an invalid author ID. Finally, the function returns the value of v_course_count, which represents the number of courses associated with the specified author ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_author_course_count(p_author_id bigint)\nRETURNS integer AS $$\nDECLARE\n    v_course_count integer;\nBEGIN\n    IF p_author_id IS NULL THEN\n        v_course_count := 0;\n    ELSIF p_author_id > 0 THEN\n        SELECT COUNT(*)\n        INTO v_course_count\n        FROM \"Courses\"\n        WHERE author_id = p_author_id;\n    ELSE\n        v_course_count := NULL;\n    END IF;\n\n    RETURN v_course_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_author_course_count(1);",
      "SELECT get_author_course_count(8);",
      "SELECT get_author_course_count(NULL);",
      "SELECT get_author_course_count(15);",
      "SELECT get_author_course_count(0);"
    ],
    "summary": "Create a PL/pgSQL function named get_author_course_count that accepts an author_id (bigint) and returns an integer count. If the ID is NULL, return 0. If the ID is greater than 0, count courses from the Courses table where author_id matches. For any other ID value, return NULL.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be distinctly named get_author_course_count, designed to accept a single input parameter of type bigint representing an author's identifier. This function must meticulously return an integer value representing a precise count. In the specific scenario where the provided author_id is explicitly NULL, the function should thoughtfully return a value of 0. However, if the supplied author_id is determined to be a positive number greater than zero, the function must carefully and accurately count all relevant entries from the Courses table where the author_id column matches the given input parameter. For any other conceivable value of the author_id that does not meet the previous conditions, the function must deliberately and clearly return NULL.",
    "id": 44
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_subject_popularity that accepts a single input parameter p_subject_id of type bigint, which represents the unique identifier for a subject, and returns a numeric value. The function begins by declaring three local variables: v_total_courses as integer, v_enrolled_students as integer, and v_popularity_rate as numeric. It first executes a SELECT statement to count all rows from the \"Courses\" table where the subject_id column matches the provided p_subject_id, storing the result into v_total_courses. It then evaluates a conditional IF statement: if v_total_courses equals zero, it directly assigns zero to v_popularity_rate; if v_total_courses is greater than zero, it executes a second SELECT statement to count all rows from the \"Student_Course_Enrolment\" table (aliased as sce) by performing an inner join with the \"Courses\" table (aliased as c) on the condition that sce.course_id equals c.course_id, where the joined c.subject_id matches p_subject_id, storing this count of enrolled students into v_enrolled_students, and then calculates v_popularity_rate by multiplying v_enrolled_students by 100.0, dividing the product by v_total_courses, and rounding the final result to two decimal places using the ROUND function; for any other case (an ELSE condition), it assigns NULL to v_popularity_rate. The function concludes by returning the computed v_popularity_rate value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_subject_popularity(p_subject_id bigint)\nRETURNS numeric AS $$\nDECLARE\n    v_total_courses integer;\n    v_enrolled_students integer;\n    v_popularity_rate numeric;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_total_courses\n    FROM \"Courses\"\n    WHERE subject_id = p_subject_id;\n\n    IF v_total_courses = 0 THEN\n        v_popularity_rate := 0;\n    ELSIF v_total_courses > 0 THEN\n        SELECT COUNT(*)\n        INTO v_enrolled_students\n        FROM \"Student_Course_Enrolment\" sce\n        JOIN \"Courses\" c ON sce.course_id = c.course_id\n        WHERE c.subject_id = p_subject_id;\n\n        v_popularity_rate := ROUND((v_enrolled_students * 100.0) / v_total_courses, 2);\n    ELSE\n        v_popularity_rate := NULL;\n    END IF;\n\n    RETURN v_popularity_rate;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT calculate_subject_popularity(1);",
      "SELECT calculate_subject_popularity(2);",
      "SELECT calculate_subject_popularity(3);",
      "SELECT calculate_subject_popularity(4);",
      "SELECT calculate_subject_popularity(5);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_subject_popularity that accepts a subject_id (bigint) and returns a numeric popularity rate. Count total courses for the subject. If zero, return 0. If greater than zero, count enrolled students by joining Courses and Student_Course_Enrolment, then calculate the percentage (enrolled_students/total_courses * 100) and round to two decimals. For other cases, return NULL.",
    "natural_language": "Write a PL/pgSQL function called calculate_subject_popularity that takes a subject_id (bigint) and gives back a numeric popularity rate. Count all courses for that subject. If the count is zero, output 0. If it's more than zero, count the enrolled students by linking the Courses and Student_Course_Enrolment tables, then compute the percentage (enrolled_students divided by total_courses, multiplied by 100) and round the result to two decimal places. For any other situation, return NULL.",
    "id": 45
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_student_enrolment_status that accepts a single input parameter p_student_id of type bigint and returns a table with two text columns, course_name and enrolment_status; the function's logic is divided into three conditional branches based on the value of p_student_id: if p_student_id is NULL, the function returns a query that selects the course_name column from the \"Courses\" table and a literal string 'Not Enrolled' as enrolment_status by performing a left join between the \"Courses\" table and the \"Student_Course_Enrolment\" table on the course_id column, and then filtering the result to include only those rows where the student_id from the \"Student_Course_Enrolment\" table is NULL, thereby listing all courses that have no student enrolments; if p_student_id is greater than 0, the function returns a query that selects the course_name column from the \"Courses\" table and uses a CASE expression to determine the enrolment_status, which evaluates to 'Completed' if the date_of_completion column in the \"Student_Course_Enrolment\" table is not NULL, otherwise it evaluates to 'Enrolled', by performing an inner join between the \"Courses\" table and the \"Student_Course_Enrolment\" table on the course_id column, and then filtering the result to include only rows where the student_id in the \"Student_Course_Enrolment\" table equals the provided p_student_id parameter, thereby listing all courses for that specific student along with their enrolment progress; for any other value of p_student_id (specifically when it is less than or equal to 0), the function returns an empty result set by selecting two empty text literals and applying a LIMIT 0 clause.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_enrolment_status(p_student_id bigint)\nRETURNS TABLE(course_name text, enrolment_status text) AS $$\nBEGIN\n    IF p_student_id IS NULL THEN\n        RETURN QUERY\n        SELECT c.course_name, 'Not Enrolled'::text\n        FROM \"Courses\" c\n        LEFT JOIN \"Student_Course_Enrolment\" sce ON c.course_id = sce.course_id\n        WHERE sce.student_id IS NULL;\n    ELSIF p_student_id > 0 THEN\n        RETURN QUERY\n        SELECT c.course_name, \n               CASE WHEN sce.date_of_completion IS NOT NULL THEN 'Completed' ELSE 'Enrolled' END\n        FROM \"Courses\" c\n        JOIN \"Student_Course_Enrolment\" sce ON c.course_id = sce.course_id\n        WHERE sce.student_id = p_student_id;\n    ELSE\n        RETURN QUERY\n        SELECT ''::text, ''::text\n        LIMIT 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT * FROM get_student_enrolment_status(11);",
      "SELECT * FROM get_student_enrolment_status(15);",
      "SELECT * FROM get_student_enrolment_status(10);",
      "SELECT * FROM get_student_enrolment_status(NULL);",
      "SELECT * FROM get_student_enrolment_status(-1);"
    ],
    "summary": "Create a PL/pgSQL function named get_student_enrolment_status that returns a table of course_name (text) and enrolment_status (text). It accepts a student_id (bigint). If ID is NULL, return all courses with no enrolments (status 'Not Enrolled'). If ID is greater than 0, return that student's courses with status 'Completed' (if completion date exists) or 'Enrolled'. For any other ID, return an empty set.",
    "natural_language": "Write a PL/pgSQL function called get_student_enrolment_status that outputs a table with columns for course_name and enrolment_status. The function must take a student_id as a bigint argument. For a NULL student_id, list all courses with the status 'Not Enrolled'. For a student_id greater than 0, show that student's courses, marking them as 'Completed' if a completion date is present or 'Enrolled' if not. For any other input, return an empty result set.",
    "id": 46
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named count_residents_in_property that accepts a single input parameter p_property_id of type BIGINT, which represents the unique identifier of a property, and returns an integer value; the function declares a local integer variable resident_count, then executes a SELECT statement to query the Residents table, specifically counting all rows where the property_id column matches the provided input parameter p_property_id, storing the resulting count into the resident_count variable, and finally returns the value of resident_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_residents_in_property(\n    p_property_id BIGINT\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    resident_count INTEGER;\nBEGIN\n    SELECT COUNT(*)\n    INTO resident_count\n    FROM \"Residents\"\n    WHERE property_id = p_property_id;\n    \n    RETURN resident_count;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Residents",
      "Properties"
    ],
    "call_sqls": [
      "SELECT count_residents_in_property(24);",
      "SELECT count_residents_in_property(107);",
      "SELECT count_residents_in_property(108);",
      "SELECT count_residents_in_property(605);",
      "SELECT count_residents_in_property(879);"
    ],
    "summary": "Create a PL/pgSQL function named count_residents_in_property that takes a property_id (BIGINT) and returns the count of residents in the Residents table for that property.",
    "natural_language": "How many residents are recorded in the Residents table for a given property_id?",
    "id": 47
  },
  {
    "ir": "Write a PLpgSQL function named determine_overpayment_category that accepts a single parameter p_council_tax_id of type bigint, which represents the council tax identifier. The function aims to categorize overpayments based on the source system code associated with the given council tax ID. It begins by declaring two local variables: v_source_code and v_category, both of type text. The function performs a SELECT operation to retrieve the source_system_code from the Benefits_Overpayments table, aliased as bo, by joining it with the CMI_Cross_References table, aliased as cr, using the cmi_cross_ref_id column as the join condition. The WHERE clause filters the results to match the council_tax_id column in the Benefits_Overpayments table with the input parameter p_council_tax_id. The retrieved source_system_code is stored in the v_source_code variable. The function then uses a series of conditional statements to determine the overpayment category based on the value of v_source_code. If v_source_code equals 'Rent', the v_category variable is set to 'RENTAL_OVERPAY'. If v_source_code equals 'Parking', v_category is set to 'PARKING_OVERPAY'. If v_source_code equals 'Benefits', v_category is set to 'BENEFIT_OVERPAY'. If v_source_code equals 'Council', v_category is set to 'COUNCIL_OVERPAY'. If none of these conditions are met, v_category defaults to 'OTHER_OVERPAY'. The function concludes by returning the value of v_category. Additionally, the function includes an exception handler for the NO_DATA_FOUND exception, which returns 'UNKNOWN_OVERPAY' if no matching data is found during the SELECT operation.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_overpayment_category(p_council_tax_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_source_code text;\n    v_category text;\nBEGIN\n    SELECT source_system_code INTO v_source_code\n    FROM \"Benefits_Overpayments\" bo\n    JOIN \"CMI_Cross_References\" cr ON bo.cmi_cross_ref_id = cr.cmi_cross_ref_id\n    WHERE bo.council_tax_id = p_council_tax_id;\n\n    IF v_source_code = 'Rent' THEN\n        v_category := 'RENTAL_OVERPAY';\n    ELSIF v_source_code = 'Parking' THEN\n        v_category := 'PARKING_OVERPAY';\n    ELSIF v_source_code = 'Benefits' THEN\n        v_category := 'BENEFIT_OVERPAY';\n    ELSIF v_source_code = 'Council' THEN\n        v_category := 'COUNCIL_OVERPAY';\n    ELSE\n        v_category := 'OTHER_OVERPAY';\n    END IF;\n\n    RETURN v_category;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 'UNKNOWN_OVERPAY';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT determine_overpayment_category(3);",
      "SELECT determine_overpayment_category(6);",
      "SELECT determine_overpayment_category(7);",
      "SELECT determine_overpayment_category(1);",
      "SELECT determine_overpayment_category(999);"
    ],
    "summary": "Create a PL/pgSQL function named determine_overpayment_category that takes a council_tax_id (bigint) and returns a text category. It retrieves the source_system_code from a join of Benefits_Overpayments and CMI_Cross_References tables. The category is set based on the source code: 'RENTAL_OVERPAY' for 'Rent', 'PARKING_OVERPAY' for 'Parking', 'BENEFIT_OVERPAY' for 'Benefits', 'COUNCIL_OVERPAY' for 'Council', else 'OTHER_OVERPAY'. Handle NO_DATA_FOUND by returning 'UNKNOWN_OVERPAY'.",
    "natural_language": "Write a PL/pgSQL function called determine_overpayment_category that accepts a council_tax_id (bigint) and outputs a text category. Fetch the source_system_code by joining the Benefits_Overpayments and CMI_Cross_References tables. Assign the category as follows: 'RENTAL_OVERPAY' for 'Rent', 'PARKING_OVERPAY' for 'Parking', 'BENEFIT_OVERPAY' for 'Benefits', 'COUNCIL_OVERPAY' for 'Council', and 'OTHER_OVERPAY' for any other source. If no data is found, return 'UNKNOWN_OVERPAY'.",
    "id": 48
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named categorize_council_tax that accepts a single input parameter p_council_tax_id of type bigint and returns a value of type text. The function begins by declaring two local variables: v_cross_ref_id of type bigint and v_category of type text. The function's logic executes a SELECT query on the table named \"Council_Tax\", retrieving the value from the column \"cmi_cross_ref_id\" for the specific row where the column \"council_tax_id\" matches the provided input parameter p_council_tax_id, and stores this retrieved value into the local variable v_cross_ref_id. Following this retrieval, the function evaluates a series of conditional IF-ELSIF-ELSE statements on the value of v_cross_ref_id. If v_cross_ref_id is found to be NULL, the function assigns the text literal 'NO_REFERENCE' to the output variable v_category. If v_cross_ref_id is not NULL and is less than 100, the function assigns 'LOW_REFERENCE' to v_category. If v_cross_ref_id is not NULL, is 100 or greater, but is less than 200, the function assigns 'MEDIUM_REFERENCE' to v_category. If v_cross_ref_id is not NULL, is 200 or greater, but is less than 300, the function assigns 'HIGH_REFERENCE' to v_category. For any other case where v_cross_ref_id is not NULL and is 300 or greater, the function assigns 'VERY_HIGH_REFERENCE' to v_category. Finally, the function concludes by returning the value stored in the v_category variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_council_tax(p_council_tax_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_cross_ref_id bigint;\n    v_category text;\nBEGIN\n    SELECT \"cmi_cross_ref_id\" INTO v_cross_ref_id FROM \"Council_Tax\" WHERE \"council_tax_id\" = p_council_tax_id;\n\n    IF v_cross_ref_id IS NULL THEN\n        v_category := 'NO_REFERENCE';\n    ELSIF v_cross_ref_id < 100 THEN\n        v_category := 'LOW_REFERENCE';\n    ELSIF v_cross_ref_id < 200 THEN\n        v_category := 'MEDIUM_REFERENCE';\n    ELSIF v_cross_ref_id < 300 THEN\n        v_category := 'HIGH_REFERENCE';\n    ELSE\n        v_category := 'VERY_HIGH_REFERENCE';\n    END IF;\n\n    RETURN v_category;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT categorize_council_tax(1);",
      "SELECT categorize_council_tax(2);",
      "SELECT categorize_council_tax(3);",
      "SELECT categorize_council_tax(4);",
      "SELECT categorize_council_tax(5);"
    ],
    "summary": "Create a PL/pgSQL function named categorize_council_tax that takes a council_tax_id (bigint) and returns a text category. It retrieves the cmi_cross_ref_id from the Council_Tax table. The category is assigned based on the ID's value: 'NO_REFERENCE' if NULL, 'LOW_REFERENCE' if <100, 'MEDIUM_REFERENCE' if >=100 and <200, 'HIGH_REFERENCE' if >=200 and <300, else 'VERY_HIGH_REFERENCE'.",
    "natural_language": "Write a PL/pgSQL function called categorize_council_tax that accepts a council_tax_id of type bigint and outputs a text category. Fetch the cmi_cross_ref_id from the Council_Tax table. Assign the category as follows: return 'NO_REFERENCE' for a NULL ID, 'LOW_REFERENCE' if the ID is less than 100, 'MEDIUM_REFERENCE' if it is 100 or more but less than 200, 'HIGH_REFERENCE' if it is 200 or more but less than 300, and 'VERY_HIGH_REFERENCE' for all other cases.",
    "id": 49
  },
  {
    "ir": "Write a PLpgSQL function named process_customer_status that accepts a single parameter p_master_id of type bigint, which represents the master customer ID. The function retrieves the cmi_details column from the Customer_Master_Index table where the master_customer_id matches the provided p_master_id. The retrieved value is stored in a local variable v_details of type text. The function then evaluates the length of v_details using conditional statements to determine the appropriate status. If v_details is null, the function assigns the text 'NO_DETAILS' to the local variable v_status. If the length of v_details exceeds 100 characters, v_status is set to 'LONG_DETAILS'. If the length is greater than 50 but less than or equal to 100, v_status is set to 'MEDIUM_DETAILS'. If the length is greater than 20 but less than or equal to 50, v_status is set to 'SHORT_DETAILS'. If the length is 20 or fewer characters, v_status is set to 'VERY_SHORT_DETAILS'. Finally, the function returns the value of v_status as the result.",
    "plsql": "CREATE OR REPLACE FUNCTION process_customer_status(p_master_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_details text;\n    v_status text;\nBEGIN\n    SELECT cmi_details INTO v_details FROM \"Customer_Master_Index\" WHERE master_customer_id = p_master_id;\n\n    IF v_details IS NULL THEN\n        v_status := 'NO_DETAILS';\n    ELSIF LENGTH(v_details) > 100 THEN\n        v_status := 'LONG_DETAILS';\n    ELSIF LENGTH(v_details) > 50 THEN\n        v_status := 'MEDIUM_DETAILS';\n    ELSIF LENGTH(v_details) > 20 THEN\n        v_status := 'SHORT_DETAILS';\n    ELSE\n        v_status := 'VERY_SHORT_DETAILS';\n    END IF;\n\n    RETURN v_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT process_customer_status(1);",
      "SELECT process_customer_status(2);",
      "SELECT process_customer_status(3);",
      "SELECT process_customer_status(4);",
      "SELECT process_customer_status(5);"
    ],
    "summary": "Create a PL/pgSQL function named process_customer_status that takes a master_id (bigint) and returns a text status. It retrieves the cmi_details from the Customer_Master_Index table. The status is determined by the length of the details: 'NO_DETAILS' if null, 'LONG_DETAILS' if >100, 'MEDIUM_DETAILS' if >50 and <=100, 'SHORT_DETAILS' if >20 and <=50, else 'VERY_SHORT_DETAILS'.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be named process_customer_status, that is designed to accept a single input parameter of type bigint representing a master_id and subsequently returns a text value indicating a status. This function must first retrieve the cmi_details field from the Customer_Master_Index table corresponding to the provided identifier. The status is then meticulously determined by evaluating the length of the retrieved details string: it should return 'NO_DETAILS' if the details are null, 'LONG_DETAILS' if the character count exceeds 100, 'MEDIUM_DETAILS' if the length is greater than 50 but does not exceed 100, 'SHORT_DETAILS' for lengths greater than 20 and up to 50 characters, and finally 'VERY_SHORT_DETAILS' for any remaining cases where the length is 20 characters or less.",
    "id": 50
  },
  {
    "ir": "Write a PLpgSQL function named evaluate_cross_reference that accepts a single parameter p_cmi_cross_ref_id of type bigint, which represents the identifier for a cross-reference entry in the CMI_Cross_References table. The function begins by declaring two local variables: v_source_code and v_evaluation, both of type text. The function performs a SELECT operation to retrieve the value from the source_system_code column of the CMI_Cross_References table where the cmi_cross_ref_id column matches the provided p_cmi_cross_ref_id parameter, storing this value into the v_source_code variable. The function then evaluates the value of v_source_code using a series of conditional statements. If v_source_code equals 'Rent', the function assigns the text 'RENT_SOURCE' to the v_evaluation variable. If v_source_code equals 'Parking', it assigns 'PARKING_SOURCE' to v_evaluation. If v_source_code equals 'Benefits', it assigns 'BENEFITS_SOURCE' to v_evaluation. If v_source_code equals 'Council', it assigns 'COUNCIL_SOURCE' to v_evaluation. For any other value of v_source_code, the function assigns 'OTHER_SOURCE' to v_evaluation. Finally, the function returns the value stored in v_evaluation.",
    "plsql": "CREATE OR REPLACE FUNCTION evaluate_cross_reference(p_cmi_cross_ref_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_source_code text;\n    v_evaluation text;\nBEGIN\n    SELECT source_system_code INTO v_source_code FROM \"CMI_Cross_References\" WHERE cmi_cross_ref_id = p_cmi_cross_ref_id;\n\n    IF v_source_code = 'Rent' THEN\n        v_evaluation := 'RENT_SOURCE';\n    ELSIF v_source_code = 'Parking' THEN\n        v_evaluation := 'PARKING_SOURCE';\n    ELSIF v_source_code = 'Benefits' THEN\n        v_evaluation := 'BENEFITS_SOURCE';\n    ELSIF v_source_code = 'Council' THEN\n        v_evaluation := 'COUNCIL_SOURCE';\n    ELSE\n        v_evaluation := 'OTHER_SOURCE';\n    END IF;\n\n    RETURN v_evaluation;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT evaluate_cross_reference(2);",
      "SELECT evaluate_cross_reference(4);",
      "SELECT evaluate_cross_reference(8);",
      "SELECT evaluate_cross_reference(65);",
      "SELECT evaluate_cross_reference(41);"
    ],
    "summary": "Create a PLpgSQL function named evaluate_cross_reference that takes a bigint parameter p_cmi_cross_ref_id. It retrieves the source_system_code from CMI_Cross_References for the given ID, maps it to a descriptive text value ('RENT_SOURCE' for 'Rent', 'PARKING_SOURCE' for 'Parking', 'BENEFITS_SOURCE' for 'Benefits', 'COUNCIL_SOURCE' for 'Council', else 'OTHER_SOURCE'), and returns that text.",
    "natural_language": "Write a PLpgSQL function called evaluate_cross_reference that uses a bigint parameter for the cross-reference ID. It should fetch the source system code from the CMI_Cross_References table for that ID and then figure out what descriptive label to return. Basically, if the code is something like 'Rent', map it to 'RENT_SOURCE', if it's 'Parking', use 'PARKING_SOURCE', and do similar for a couple of other known types like 'Benefits' and 'Council'. For any other codes that pop up, just return a generic 'OTHER_SOURCE' label.",
    "id": 51
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_reviewer_rating_count` that accepts a single input parameter, `rev_name`, of type `TEXT`. This function is designed to return an `INTEGER` value representing the total number of ratings associated with a specific reviewer. Upon execution, the function first declares a local variable named `rating_count` of type `INTEGER` to store the computed count. The core logic begins with a conditional check: it determines if a reviewer with a name matching the provided `rev_name` exists in the `\"Reviewer\"` table. This check is performed by executing a `SELECT 1` query, which is an efficient way to check for existence, from the `\"Reviewer\"` table, applying a `LOWER()` function to both the `\"name\"` column of the `\"Reviewer\"` table and the input `rev_name` parameter to ensure a case-insensitive comparison. If a reviewer with the matching name is found (i.e., the `EXISTS` condition evaluates to true), the function proceeds to calculate the number of ratings. This calculation involves a `SELECT COUNT(*)` operation, which counts all rows, into the `rating_count` variable. The `COUNT(*)` is performed on a `JOIN` between the `\"Rating\"` table (aliased as `r`) and the `\"Reviewer\"` table (aliased as `rev`). The join condition `r.\"rID\" = rev.\"rID\"` links ratings to their respective reviewers using the `\"rID\"` column, which presumably represents the reviewer's identifier. A `WHERE` clause is then applied to filter these joined records, specifically looking for ratings where the reviewer's name, after being converted to lowercase using `LOWER(rev.\"name\")`, matches the lowercase version of the input `rev_name` parameter, also converted using `LOWER(rev_name)`. If, however, the initial `EXISTS` check determines that no reviewer with the specified name exists in the `\"Reviewer\"` table, the `ELSE` block is executed, and the `rating_count` variable is explicitly assigned a value of `0`. Finally, regardless of whether a reviewer was found or not, the function returns the final value stored in the `rating_count` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_reviewer_rating_count(rev_name TEXT) RETURNS INTEGER AS $$\nDECLARE\n    rating_count INTEGER;\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Reviewer\" WHERE LOWER(\"name\") = LOWER(rev_name)) THEN\n        SELECT COUNT(*) INTO rating_count FROM \"Rating\" r JOIN \"Reviewer\" rev ON r.\"rID\" = rev.\"rID\" WHERE LOWER(rev.\"name\") = LOWER(rev_name);\n    ELSE\n        rating_count := 0;\n    END IF;\n    RETURN rating_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT get_reviewer_rating_count('Sarah Martinez');",
      "SELECT get_reviewer_rating_count('Daniel Lewis');",
      "SELECT get_reviewer_rating_count('Brittany Harris');",
      "SELECT get_reviewer_rating_count('John Doe');",
      "SELECT get_reviewer_rating_count('Jane Smith');"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_reviewer_rating_count that takes a TEXT parameter rev_name. It returns an INTEGER count of ratings for that reviewer (using a case-insensitive name match). If the reviewer does not exist, it returns 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_reviewer_rating_count that accepts a TEXT parameter rev_name and returns an INTEGER. The function should count the ratings for the specified reviewer, matching the name case-insensitively. Return 0 if the reviewer is not found.",
    "id": 52
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_artist_festival_count` that accepts a single input parameter, `p_artist_id`, which is of type `integer`. The purpose of this function is to calculate and return the total number of music festivals associated with a specific artist. The function's execution flow begins with a conditional check: it evaluates whether the value of the `p_artist_id` parameter is strictly greater than `0`. If this condition is true, the function proceeds to execute a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows in the table named `\"music_festival\"`. The counting operation is filtered by a `WHERE` clause, which specifies that only rows where the value in the column named `\"Volume\"` is equal to the value of the `p_artist_id` parameter should be included in the count. The result of this count is then returned as the output of the function. If the initial conditional check determines that `p_artist_id` is not strictly greater than `0` (i.e., it is `0` or a negative integer), the function immediately returns the integer value `0` without performing any database queries. The function is designed to return a single value of type `integer`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_festival_count(p_artist_id integer)\nRETURNS integer AS $$\nBEGIN\n    IF p_artist_id > 0 THEN\n        RETURN (SELECT COUNT(*) FROM \"music_festival\" WHERE \"Volume\" = p_artist_id);\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT get_artist_festival_count(1);",
      "SELECT get_artist_festival_count(2);",
      "SELECT get_artist_festival_count(3);"
    ],
    "summary": "Create a PL/pgSQL function named get_artist_festival_count that accepts an artist ID integer parameter. If the ID is greater than 0, return the count of music festivals where the Volume column matches the artist ID. Otherwise, return 0.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_artist_festival_count'. This function shall accept a single integer parameter representing an artist ID. The function's logic must be implemented as follows: if the provided artist ID is a positive integer, the function should return the total number of music festival records where the value in the 'Volume' column corresponds to that artist ID. Conversely, if the provided artist ID is less than or equal to zero, the function must return the integer zero.",
    "id": 53
  },
  {
    "ir": "Write a PLpgSQL function named calculate_weeks_bonus that accepts a single parameter p_volume_id of type integer. This function is designed to calculate and return a bonus value based on the number of weeks a particular volume has been on top. It operates on a table named volume, which contains at least two columns: Volume_ID, an identifier for each volume, and Weeks_on_Top, a numeric value representing the number of weeks the volume has been on top. The function begins by checking if the Weeks_on_Top value for the row in the volume table where the Volume_ID matches the input parameter p_volume_id is greater than 2.0. If this condition is true, the function returns the product of Weeks_on_Top and 1.5 for that specific row. If the condition is false, it simply returns the Weeks_on_Top value for the same row. The function uses SELECT statements to retrieve the Weeks_on_Top value from the volume table based on the provided Volume_ID, and it employs a conditional IF statement to determine which value to return.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_weeks_bonus(p_volume_id integer)\nRETURNS real AS $$\nBEGIN\n    IF (SELECT \"Weeks_on_Top\" FROM \"volume\" WHERE \"Volume_ID\" = p_volume_id) > 2.0 THEN\n        RETURN (SELECT \"Weeks_on_Top\" * 1.5 FROM \"volume\" WHERE \"Volume_ID\" = p_volume_id);\n    ELSE\n        RETURN (SELECT \"Weeks_on_Top\" FROM \"volume\" WHERE \"Volume_ID\" = p_volume_id);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT calculate_weeks_bonus(1);",
      "SELECT calculate_weeks_bonus(2);",
      "SELECT calculate_weeks_bonus(3);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_weeks_bonus that accepts a volume ID integer parameter. For the matching volume, if its Weeks_on_Top is greater than 2.0, return Weeks_on_Top multiplied by 1.5. Otherwise, return the Weeks_on_Top value.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called calculate_weeks_bonus? It should take a volume ID (as an integer). For that specific volume, if its \"Weeks_on_Top\" is more than 2.0, give me that number times 1.5. If not, just spit out the \"Weeks_on_Top\" value as is.",
    "id": 54
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `count_pets_by_age` that accepts two input parameters: `p_age_threshold`, which is of type `bigint` and represents a numeric age value used as a lower bound for filtering, and `p_pet_type`, which is of type `text` and represents a specific type of pet to filter by. This function is designed to return a single integer value. Upon execution, the function declares a local variable named `v_count` of type `integer` to temporarily store the result of a database query. The core operation involves performing a `SELECT` statement to count the total number of rows in the table named `\"Pets\"`. This count is then stored into the `v_count` variable. The `SELECT` statement includes a `WHERE` clause that applies two conditions for filtering the rows: first, it selects only those rows where the value in the `\"pet_age\"` column is strictly greater than the value provided in the `p_age_threshold` parameter; second, it further filters these results to include only rows where the value in the `\"PetType\"` column is exactly equal to the value provided in the `p_pet_type` parameter. After successfully executing the `SELECT` statement and populating `v_count` with the calculated count, the function concludes by returning the final integer value stored in the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_pets_by_age(p_age_threshold bigint, p_pet_type text)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM \"Pets\"\n    WHERE \"pet_age\" > p_age_threshold\n    AND \"PetType\" = p_pet_type;\n    \n    RETURN v_count;\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT count_pets_by_age(2, 'cat');",
      "SELECT count_pets_by_age(1, 'dog');",
      "SELECT count_pets_by_age(3, 'cat');",
      "SELECT count_pets_by_age(0, 'dog');",
      "SELECT count_pets_by_age(1, 'cat');"
    ],
    "summary": "Create a function named `count_pets_by_age` that takes a bigint `p_age_threshold` and a text `p_pet_type`. Count and return the number of rows in the `Pets` table where the `pet_age` is greater than the threshold and the `PetType` matches the input type.",
    "natural_language": "Develop a function called `count_pets_by_age` which accepts a bigint parameter named `p_age_threshold` and a text parameter named `p_pet_type`. This function should meticulously calculate and then return the total count of entries found within the `Pets` table, specifically targeting those records where the `pet_age` column exceeds the provided threshold value and, simultaneously, where the `PetType` column precisely corresponds to the supplied pet type.",
    "id": 55
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_pet_weight` that accepts two input parameters: `p_pet_id` of type `bigint` and `p_weight_threshold` of type `real`. This function is designed to return a single value of type `real`. Inside the function, a local variable named `v_weight` of type `real` is declared to temporarily store the retrieved weight. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"weight\"` from the table named `\"Pets\"`. The retrieved value is then assigned to the local variable `v_weight`. The selection of rows from the `\"Pets\"` table is subject to two conditions connected by an `AND` operator: first, the value in the column named `\"PetID\"` must be equal to the value provided in the input parameter `p_pet_id`; and second, the value in the column named `\"weight\"` must be strictly greater than the value provided in the input parameter `p_weight_threshold`. After the `SELECT` statement has been executed and `v_weight` has been populated with the result, the function returns the value currently stored in the `v_weight` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_pet_weight(p_pet_id bigint, p_weight_threshold real)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_weight real;\nBEGIN\n    SELECT \"weight\"\n    INTO v_weight\n    FROM \"Pets\"\n    WHERE \"PetID\" = p_pet_id\n    AND \"weight\" > p_weight_threshold;\n    \n    RETURN v_weight;\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_pet_weight(2001, 10.0);",
      "SELECT get_pet_weight(2002, 13.0);",
      "SELECT get_pet_weight(2003, 5.0);",
      "SELECT get_pet_weight(2001, 15.0);",
      "SELECT get_pet_weight(2002, 11.0);"
    ],
    "summary": "Create a function named `get_pet_weight` that returns a `real` value. It takes a `bigint` pet ID and a `real` weight threshold as input. The function selects the `weight` from the `\"Pets\"` table where the `\"PetID\"` matches the input ID and the `\"weight\"` is greater than the input threshold, then returns that weight.",
    "natural_language": "Make a function `get_pet_weight` returning real. It takes a bigint pet ID and a real weight threshold. Return the weight from \"Pets\" where \"PetID\" matches and \"weight\" exceeds the threshold.",
    "id": 56
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns a table containing the Institution_ID, Name, and Number_of_Championships for a specific institution. The function, named get_institution_championships, accepts a single parameter p_institution_id of type INTEGER, which represents the unique identifier of the institution whose championship data is to be fetched. The function returns a table with three columns: Institution_ID of type INTEGER, Name of type TEXT, and Number_of_Championships of type REAL. Within the function, a SQL SELECT query is executed to fetch data from two tables: \"institution\" and \"Championship\". The \"institution\" table is aliased as i, and the \"Championship\" table is aliased as c. The query performs an inner join between these tables based on the condition that the Institution_ID column in the \"institution\" table matches the Institution_ID column in the \"Championship\" table. The WHERE clause filters the results to include only the rows where the Institution_ID in the \"institution\" table equals the value of the input parameter p_institution_id. The selected columns, i.\"Institution_ID\", i.\"Name\", and c.\"Number_of_Championships\", are returned as the result of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_institution_championships(p_institution_id INTEGER)\nRETURNS TABLE (\n    Institution_ID INTEGER,\n    Name TEXT,\n    Number_of_Championships REAL\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT i.\"Institution_ID\", i.\"Name\", c.\"Number_of_Championships\"\n    FROM \"institution\" AS i\n    JOIN \"Championship\" AS c ON i.\"Institution_ID\" = c.\"Institution_ID\"\n    WHERE i.\"Institution_ID\" = p_institution_id;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "SELECT * FROM get_institution_championships(1);",
      "SELECT * FROM get_institution_championships(2);",
      "SELECT * FROM get_institution_championships(3);",
      "SELECT * FROM get_institution_championships(4);",
      "SELECT * FROM get_institution_championships(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_institution_championships` that takes an `INTEGER` parameter `p_institution_id` and returns a table with columns `Institution_ID` (INTEGER), `Name` (TEXT), and `Number_of_Championships` (REAL). The function should perform an inner join between the `\"institution\"` table (aliased `i`) and the `\"Championship\"` table (aliased `c`) on `i.\"Institution_ID\"` = `c.\"Institution_ID\"`, and return the specified columns where `i.\"Institution_ID\"` equals the input parameter.",
    "natural_language": "Alright, so we need a PL/pgSQL function called `get_institution_championships`. It's gonna take one number input, `p_institution_id`. What it does is it grabs the institution's ID, its name, and how many championships it's won (as a real number). To get that, it'll link up the \"institution\" table (let's call it `i`) with the \"Championship\" table (call it `c`) by matching their Institution_ID fields. Finally, it just returns the info for the specific institution ID we passed in.",
    "id": 57
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named count_institutions_by_province that accepts a single input parameter called province_name of type TEXT, which represents the name of a province to be used as a filter condition, and returns a single integer value representing the count of institutions; within the function, it declares a local integer variable named institution_count to hold the result, then executes a SELECT statement that queries the institution table to count all rows where the value in the column named \"Province\" exactly matches the provided province_name parameter, storing the resulting count into the institution_count variable, and finally returns the value stored in institution_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_institutions_by_province(province_name TEXT)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    institution_count INTEGER;\nBEGIN\n    SELECT COUNT(*)\n    INTO institution_count\n    FROM institution\n    WHERE \"Province\" = province_name;\n    \n    RETURN institution_count;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "SELECT count_institutions_by_province('BC');",
      "SELECT count_institutions_by_province('AB');",
      "SELECT count_institutions_by_province('ON');",
      "SELECT count_institutions_by_province('QC');",
      "SELECT count_institutions_by_province('SK');"
    ],
    "summary": "Create a PL/pgSQL function named `count_institutions_by_province` that takes a `TEXT` parameter `province_name` and returns an `INTEGER`. Declare an integer variable `institution_count`. Count all rows from the `institution` table where the `\"Province\"` column matches the input parameter, store the result in `institution_count`, and return it.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called `count_institutions_by_province`? It should take a `TEXT` parameter for the `province_name`. We need it to spit back an `INTEGER`. So, inside the function, set up an integer variable, let's call it `institution_count`. Then, just count up all the rows in the `institution` table where the `\"Province\"` column is the same as the input name, stash that number in `institution_count`, and finally, return that count.",
    "id": 58
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_document_owner that accepts a single input parameter p_document_object_id of type bigint and returns a text value. The function's purpose is to retrieve the owner name associated with a specific document object identifier. It declares a local variable owner_name of type text. The function begins a nested block that attempts to execute a SELECT query. This query selects the value from the column named \"Owner\" in the table named \"Document_Objects\" where the column \"Document_Object_ID\" exactly matches the provided input parameter p_document_object_id, using the STRICT keyword to enforce that exactly one row must be returned, and assigns the result to the owner_name variable, which is then returned. If the SELECT query finds no matching rows, the NO_DATA_FOUND exception is caught and the function returns the literal string 'Document object not found'. If the SELECT query finds more than one matching row, the TOO_MANY_ROWS exception is caught and the function returns the literal string 'Multiple document objects found'. If the SELECT query fails because the referenced table does not exist, specifically the undefined_table exception, the function enters another nested exception handling block. Within this inner block, it attempts a second SELECT query that is identical to the first except it references the table using the unquoted identifier Document_Objects, which PostgreSQL treats as case-insensitive, again selecting the \"Owner\" column where \"Document_Object_ID\" equals p_document_object_id with the STRICT keyword and returning the retrieved owner_name. If this second query also raises an undefined_table exception, the function returns the literal string 'Table Document_Objects does not exist'. If this second query raises any other exception, it is re-raised using the RAISE statement without parameters. For the outer exception block, if any exception other than NO_DATA_FOUND, TOO_MANY_ROWS, or undefined_table occurs during the initial SELECT query, it is also re-raised using the RAISE statement.",
    "plsql": "CREATE OR REPLACE FUNCTION get_document_owner(p_document_object_id bigint)\nRETURNS text AS $$\nDECLARE\n    owner_name text;\nBEGIN\n    BEGIN\n        SELECT \"Owner\" INTO STRICT owner_name\n        FROM \"Document_Objects\"\n        WHERE \"Document_Object_ID\" = p_document_object_id;\n        \n        RETURN owner_name;\n        \n    EXCEPTION \n        WHEN NO_DATA_FOUND THEN\n            RETURN 'Document object not found';\n        WHEN TOO_MANY_ROWS THEN\n            RETURN 'Multiple document objects found';\n        WHEN undefined_table THEN\n            -- Try alternative table name without quotes (case-insensitive)\n            BEGIN\n                SELECT \"Owner\" INTO STRICT owner_name\n                FROM Document_Objects\n                WHERE \"Document_Object_ID\" = p_document_object_id;\n                RETURN owner_name;\n            EXCEPTION \n                WHEN undefined_table THEN\n                    RETURN 'Table Document_Objects does not exist';\n                WHEN OTHERS THEN\n                    RAISE;\n            END;\n        WHEN OTHERS THEN\n            RAISE;\n    END;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collections",
      "Collection_Subsets",
      "Collection_Subset_Members",
      "Document_Objects",
      "Documents_in_Collections"
    ],
    "call_sqls": [
      "SELECT get_document_owner(5);",
      "SELECT get_document_owner(8);",
      "SELECT get_document_owner(9);",
      "SELECT get_document_owner(10);",
      "SELECT get_document_owner(11);"
    ],
    "summary": "Create a PL/pgSQL function named `get_document_owner` that takes a `bigint` parameter `p_document_object_id` and returns `TEXT`. Declare a `text` variable `owner_name`. Attempt to select the `\"Owner\"` column from the `\"Document_Objects\"` table where `\"Document_Object_ID\"` equals the input parameter (using `STRICT`) into `owner_name` and return it. Handle exceptions: if `NO_DATA_FOUND`, return 'Document object not found'; if `TOO_MANY_ROWS`, return 'Multiple document objects found'; if `undefined_table`, try the same select from the unquoted `Document_Objects` table and return the result; if that also raises `undefined_table`, return 'Table Document_Objects does not exist'; for any other exception in the second attempt, re-raise it. For any other exception in the first attempt, re-raise it.",
    "natural_language": "Alright, so I need you to write a PL/pgSQL function called `get_document_owner`. It's gonna take one input, a bigint called `p_document_object_id`, and it'll spit back some TEXT. Here's the plan: set up a text variable for the owner's name. First, try to grab the \"Owner\" column from that \"Document_Objects\" table (yeah, with the quotes) where the \"Document_Object_ID\" matches the input. Use STRICT to put it straight into that variable. If that works, just return the name.\n\nNow, if it doesn't find anything (that's a NO_DATA_FOUND), just say 'Document object not found'. If it finds too many rows, return 'Multiple document objects found'.\n\nHere's the tricky bit: if the first try blows up because the table itself doesn't exist (that's the undefined_table error), don't panic. Give it another shot, but this time, try selecting from the table without the quotes, just plain Document_Objects. If that works, return what you get.\n\nIf that second try also says the table's not there, then just return 'Table Document_Objects does not exist'. If some other weird error pops up during the second attempt, let it crash—just re-raise that exception. Same goes for any other unexpected error in the first attempt, just let it bubble up.\n\nGot it? Cool.",
    "id": 59
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_orders` that accepts a single input parameter, `customer_id_param`, which is of type `bigint` and represents the unique identifier for a customer. This function is designed to return a set of records, specifically a table, where each record contains three columns: `actual_order_id` of type `bigint`, `order_status_code` of type `text`, and `actual_order_date` of type `timestamp with time zone`. The core operation of this function is to execute a `SELECT` query that retrieves specific order details. The query selects the `actual_order_id`, `order_status_code`, and `actual_order_date` columns from the `Actual_Orders` table, aliased as `ao`. This selection is performed by joining the `Actual_Orders` table (`ao`) with the `Customer_Addresses` table, aliased as `ca`. The join condition specifies that the `customer_id` column from the `Customer_Addresses` table (`ca.customer_id`) must be equal to the input parameter `customer_id_param`. Furthermore, the `SELECT` statement includes a `WHERE` clause that filters the results based on the `actual_order_id` column from the `Actual_Orders` table (`ao.actual_order_id`). This `actual_order_id` must be present `IN` the result set of a subquery. The subquery itself selects the `actual_order_id` from the `Actual_Order_Products` table, aliased as `aop`. This subquery performs an inner join between the `Actual_Order_Products` table (`aop`) and the `Products` table, aliased as `p`, where the join condition requires that the `product_id` column from `Actual_Order_Products` (`aop.product_id`) matches the `product_id` column from the `Products` table (`p.product_id`). The overall effect is to return all orders from the `Actual_Orders` table that are associated with the provided `customer_id_param` through the `Customer_Addresses` table, and where the order itself contains at least one product listed in the `Products` table, as linked via the `Actual_Order_Products` table. The function then returns the result set of this `SELECT` query.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_orders(\"customer_id_param\" bigint)\nRETURNS TABLE(\"actual_order_id\" bigint, \"order_status_code\" text, \"actual_order_date\" timestamp with time zone) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"ao\".\"actual_order_id\", \"ao\".\"order_status_code\", \"ao\".\"actual_order_date\"\n    FROM \"Actual_Orders\" \"ao\"\n    JOIN \"Customer_Addresses\" \"ca\" ON \"ca\".\"customer_id\" = \"customer_id_param\"\n    WHERE \"ao\".\"actual_order_id\" IN (\n        SELECT \"aop\".\"actual_order_id\"\n        FROM \"Actual_Order_Products\" \"aop\"\n        JOIN \"Products\" \"p\" ON \"aop\".\"product_id\" = \"p\".\"product_id\"\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Addresses",
      "Actual_Orders",
      "Actual_Order_Products",
      "Products",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT * FROM get_customer_orders(5);",
      "SELECT * FROM get_customer_orders(14);",
      "SELECT * FROM get_customer_orders(2);",
      "SELECT * FROM get_customer_orders(1);",
      "SELECT * FROM get_customer_orders(3);"
    ],
    "summary": "Create a PL/pgSQL function named `get_customer_orders` that takes a `bigint` parameter `customer_id_param` and returns a table with columns `actual_order_id` (bigint), `order_status_code` (text), and `actual_order_date` (timestamp with time zone). Select the specified columns from the `Actual_Orders` table (aliased `ao`), joining with the `Customer_Addresses` table (aliased `ca`) on `ca.customer_id` = `customer_id_param`. Filter the results where `ao.actual_order_id` is in a subquery result: the subquery selects `aop.actual_order_id` from the `Actual_Order_Products` table (aliased `aop`) joined with the `Products` table (aliased `p`) on `aop.product_id` = `p.product_id`. Return the result set.",
    "natural_language": "List the actual order ID, order status code, and order date for a specified customer. Only include orders that contain products. Join the customer addresses to filter by the given customer ID, and join the order products with products to identify relevant orders.",
    "id": 60
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns the product_price from the Products table for a specific product identified by the product_id_param parameter, which is of type bigint. The function performs a SELECT operation to extract the product_price column from the Products table where the product_id column matches the provided product_id_param value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price(\"product_id_param\" bigint)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (\n        SELECT \"product_price\"\n        FROM \"Products\"\n        WHERE \"product_id\" = \"product_id_param\"\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Addresses",
      "Actual_Orders",
      "Actual_Order_Products",
      "Products",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT get_product_price(1);",
      "SELECT get_product_price(2);",
      "SELECT get_product_price(3);",
      "SELECT get_product_price(5);",
      "SELECT get_product_price(6);"
    ],
    "summary": "Create a function that returns the product_price from the Products table for a given product_id.",
    "natural_language": "Get product price by product ID.",
    "id": 61
  },
  {
    "ir": "Write a PLpgSQL function named get_truck_details that accepts a single mandatory input parameter named truck_id_param of type bigint, which is used to identify a specific truck record, and returns a result set with a defined structure consisting of two text columns named truck_licence_number and truck_details; the function's body executes a single SQL query that selects the truck_licence_number column and the truck_details column from the table named Trucks, specifically from the row or rows where the value in the truck_id column of the Trucks table is exactly equal to the value provided in the truck_id_param input parameter, and then immediately returns the result set of that query as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_truck_details(\"truck_id_param\" bigint)\nRETURNS TABLE(\"truck_licence_number\" text, \"truck_details\" text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Trucks\".\"truck_licence_number\", \"Trucks\".\"truck_details\"\n    FROM \"Trucks\"\n    WHERE \"Trucks\".\"truck_id\" = \"truck_id_param\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Addresses",
      "Actual_Orders",
      "Actual_Order_Products",
      "Products",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT * FROM get_truck_details(1);",
      "SELECT * FROM get_truck_details(2);",
      "SELECT * FROM get_truck_details(3);",
      "SELECT * FROM get_truck_details(10);",
      "SELECT * FROM get_truck_details(11);"
    ],
    "summary": "Create a function named get_truck_details that takes a truck_id and returns a result set with columns truck_licence_number and truck_details from the Trucks table.",
    "natural_language": "Hey, can you whip up a function called get_truck_details? It should take a truck_id and spit back the truck_licence_number and truck_details for that rig from the Trucks table.",
    "id": 62
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_address_details that accepts a single input parameter named address_id_param of type bigint, which represents the unique identifier of an address record to be retrieved, and returns a result set with a defined table structure consisting of five text columns named address_details, city, zip_postcode, state_province_county, and country; the function's logic executes a single SELECT query that retrieves the columns address_details, city, zip_postcode, state_province_county, and country from the table named Addresses, using the alias A for the table, where the value in the address_id column of the Addresses table is strictly equal to the value supplied in the address_id_param input parameter, and then returns the result of this query directly as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_address_details(\"address_id_param\" bigint)\nRETURNS TABLE(\"address_details\" text, \"city\" text, \"zip_postcode\" text, \"state_province_county\" text, \"country\" text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT\n        A.\"address_details\",\n        A.\"city\",\n        A.\"zip_postcode\",\n        A.\"state_province_county\",\n        A.\"country\"\n    FROM \"Addresses\" AS A\n    WHERE A.\"address_id\" = \"address_id_param\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Addresses",
      "Actual_Orders",
      "Actual_Order_Products",
      "Products",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT * FROM get_address_details(1);",
      "SELECT * FROM get_address_details(2);",
      "SELECT * FROM get_address_details(3);",
      "SELECT * FROM get_address_details(5);",
      "SELECT * FROM get_address_details(6);"
    ],
    "summary": "Create a function named get_address_details that takes an address_id and returns a result set with columns address_details, city, zip_postcode, state_province_county, and country from the Addresses table.",
    "natural_language": "Please construct a function designated as 'get_address_details'. This function should accept an address_id as its input parameter and yield a result set comprising the columns address_details, city, zip_postcode, state_province_county, and country, which are to be retrieved from the Addresses table.",
    "id": 63
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the classroom number associated with a teacher by taking two text parameters, teacher_lastname and teacher_firstname, which represent the last name and first name of the teacher, respectively. The function queries the teachers table, specifically selecting the Classroom column, where the LastName column matches the provided teacher_lastname and the FirstName column matches the provided teacher_firstname. The result of this query is stored in a variable named classroom, which is of type bigint. The function then returns the value of the classroom variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_classroom(teacher_lastname text, teacher_firstname text) RETURNS bigint AS $$\nDECLARE\n    classroom bigint;\nBEGIN\n    SELECT \"Classroom\" INTO classroom FROM teachers WHERE \"LastName\" = teacher_lastname AND \"FirstName\" = teacher_firstname;\n    RETURN classroom;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT get_teacher_classroom('MACROSTIE', ' MIN');",
      "SELECT get_teacher_classroom('COVIN', ' JEROME');",
      "SELECT get_teacher_classroom('MOYER', ' OTHA');",
      "SELECT get_teacher_classroom('MACROSTIE', ' JEROME');",
      "SELECT get_teacher_classroom('COVIN', ' MIN');"
    ],
    "summary": "Create a function that takes a teacher's first and last name, queries the teachers table for their classroom number, and returns it.",
    "natural_language": "Construct a function that, when provided with the specific first name and last name of a teacher, will perform a detailed lookup within the comprehensive teachers table to meticulously retrieve and subsequently return the precise classroom number associated with that particular educator.",
    "id": 64
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns the grade of a student from the list table by taking two parameters: student_lastname and student_firstname, both of which are of type text. The function declares a local variable named grade of type bigint to store the result. It performs a SELECT operation to fetch the value from the \"Grade\" column of the list table where the \"LastName\" column matches the provided student_lastname and the \"FirstName\" column matches the provided student_firstname. The retrieved grade is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_grade(student_lastname text, student_firstname text) RETURNS bigint AS $$\nDECLARE\n    grade bigint;\nBEGIN\n    SELECT \"Grade\" INTO grade FROM list WHERE \"LastName\" = student_lastname AND \"FirstName\" = student_firstname;\n    RETURN grade;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT get_student_grade('CAR', ' MAUDE');",
      "SELECT get_student_grade('KRISTENSEN', ' STORMY');",
      "SELECT get_student_grade('VANDERWOUDE', ' SHERWOOD');"
    ],
    "summary": "Create a function that takes a student's first and last name, queries the list table for their grade, and returns it.",
    "natural_language": "Get grade from list table for given student first and last name.",
    "id": 65
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns a table consisting of the LastName and FirstName columns from the teachers table for rows where the Classroom column matches the provided parameter classroom_number, which is of type bigint. The function is defined to return a table with two columns: LastName of type text and FirstName of type text. It uses the RETURN QUERY statement to execute a SELECT operation that filters the teachers table based on the condition that the Classroom column is equal to the input parameter classroom_number, thereby extracting the relevant teacher names associated with the specified classroom number. The function is implemented using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_by_classroom(classroom_number bigint) RETURNS TABLE(LastName text, FirstName text) AS $$\nBEGIN\n    RETURN QUERY SELECT \"LastName\", \"FirstName\" FROM teachers WHERE \"Classroom\" = classroom_number;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT * FROM get_teacher_by_classroom(101);",
      "SELECT * FROM get_teacher_by_classroom(102);",
      "SELECT * FROM get_teacher_by_classroom(103);",
      "SELECT * FROM get_teacher_by_classroom(112);",
      "SELECT * FROM get_teacher_by_classroom(107);"
    ],
    "summary": "Create a function that returns a table of teacher last names and first names from the \"teachers\" table for a specified classroom number.",
    "natural_language": "Make a function that gives back a list of teacher names from the teachers table, but only for a classroom number that's kind of around a certain area or section.",
    "id": 66
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_students_by_grade that accepts a single input parameter named grade_level of type bigint, which represents the specific academic grade level to filter student records, and returns a result set with a defined table structure consisting of two text columns named LastName and FirstName in that order; the function body begins by executing a RETURN QUERY statement, which directly returns the result of a SELECT query that retrieves data from the database table named list, specifically extracting the values from the columns named LastName and FirstName (note that these column names are case-sensitive and enclosed in double quotes), and applying a filter condition where the value in the column named Grade (also case-sensitive and double-quoted) must be exactly equal to the value supplied in the grade_level input parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_by_grade(grade_level bigint) RETURNS TABLE(LastName text, FirstName text) AS $$\nBEGIN\n    RETURN QUERY SELECT \"LastName\", \"FirstName\" FROM list WHERE \"Grade\" = grade_level;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_by_grade(2);",
      "SELECT * FROM get_students_by_grade(6);",
      "SELECT * FROM get_students_by_grade(3);",
      "SELECT * FROM get_students_by_grade(1);",
      "SELECT * FROM get_students_by_grade(5);"
    ],
    "summary": "Create a function named get_students_by_grade that returns a table of student last names and first names from the \"list\" table for a specified grade level.",
    "natural_language": "Make function get_students_by_grade return last and first names from list table for a given grade.",
    "id": 67
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named check_friendship_and_like that accepts two integer input parameters, student_id and target_id, and returns a boolean value. The function first declares two local boolean variables, are_friends and has_liked. It then executes a SELECT statement to query the \"Friend\" table, using the EXISTS operator to determine if there is at least one row where the \"student_id\" column equals the input student_id parameter and the \"friend_id\" column equals the input target_id parameter; the result of this existence check is stored in the are_friends variable. Next, it executes another SELECT statement to query the \"Likes\" table, using the EXISTS operator to determine if there is at least one row where the \"student_id\" column equals the input student_id parameter and the \"liked_id\" column equals the input target_id parameter; the result is stored in the has_liked variable. Finally, the function returns the logical AND of the two boolean variables, meaning it returns true only if both conditions are satisfied: a friendship link exists from the specified student to the specified target in the \"Friend\" table and a like link exists from the same student to the same target in the \"Likes\" table.",
    "plsql": "CREATE OR REPLACE FUNCTION check_friendship_and_like(student_id integer, target_id integer) RETURNS boolean AS $$\nDECLARE\n    are_friends boolean;\n    has_liked boolean;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM \"Friend\" f WHERE f.\"student_id\" = check_friendship_and_like.student_id AND f.\"friend_id\" = check_friendship_and_like.target_id) INTO are_friends;\n    SELECT EXISTS(SELECT 1 FROM \"Likes\" l WHERE l.\"student_id\" = check_friendship_and_like.student_id AND l.\"liked_id\" = check_friendship_and_like.target_id) INTO has_liked;\n    RETURN are_friends AND has_liked;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT check_friendship_and_like(1510, 1381);",
      "SELECT check_friendship_and_like(1689, 1709);",
      "SELECT check_friendship_and_like(1510, 1689);",
      "SELECT check_friendship_and_like(1689, 1689);",
      "SELECT check_friendship_and_like(1709, 1689);"
    ],
    "summary": "Create a function named check_friendship_and_like that returns true if a given student is both friends with and has liked a specified target student, based on the \"Friend\" and \"Likes\" tables.",
    "natural_language": "Does the function 'check_friendship_and_like' return true for a given student if that student is both friends with and has liked a specified target student, according to the 'Friend' and 'Likes' tables?",
    "id": 68
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named classify_gymnast_by_height that accepts a single integer input parameter named g_id, which represents a People_ID, and returns a text value; the function begins by declaring a local real variable named gymnast_height to store a height value and a local text variable named category to store the classification result; it then executes a SELECT query on the people table, specifically retrieving the value from the Height column for the row where the People_ID column exactly matches the provided g_id parameter, and assigns the retrieved value into the gymnast_height variable; following this retrieval, the function checks if the gymnast_height variable is not NULL; if it is not NULL, it proceeds with a conditional block: if the gymnast_height value is less than 1.70, the category variable is assigned the text 'SHORT'; otherwise, if the gymnast_height value is less than or equal to 1.80, the category variable is assigned the text 'MEDIUM'; if neither of the previous conditions is true (meaning the height is greater than 1.80), the category variable is assigned the text 'TALL'; if the initial check finds that the gymnast_height variable is NULL, the category variable is directly assigned the text 'UNKNOWN'; finally, the function returns the value stored in the category variable.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_gymnast_by_height(g_id INTEGER)\nRETURNS TEXT AS $$\nDECLARE\n    gymnast_height REAL;\n    category TEXT;\nBEGIN\n    SELECT p.\"Height\" INTO gymnast_height\n    FROM people p\n    WHERE p.\"People_ID\" = g_id;\n    \n    IF gymnast_height IS NOT NULL THEN\n        IF gymnast_height < 1.70 THEN\n            category := 'SHORT';\n        ELSIF gymnast_height <= 1.80 THEN\n            category := 'MEDIUM';\n        ELSE\n            category := 'TALL';\n        END IF;\n    ELSE\n        category := 'UNKNOWN';\n    END IF;\n    \n    RETURN category;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT classify_gymnast_by_height(1);",
      "SELECT classify_gymnast_by_height(2);",
      "SELECT classify_gymnast_by_height(3);",
      "SELECT classify_gymnast_by_height(4);",
      "SELECT classify_gymnast_by_height(100);"
    ],
    "summary": "Create a PostgreSQL function named classify_gymnast_by_height that takes an integer parameter g_id (representing People_ID) and returns text. Retrieve the Height from the people table for the given ID. Classify as 'SHORT' if height < 1.70, 'MEDIUM' if height <= 1.80, 'TALL' if height > 1.80, and 'UNKNOWN' if height is NULL. Return the classification.",
    "natural_language": "Write a PostgreSQL function classify_gymnast_by_height(g_id int) returning text. Fetch Height from people for that ID. Return 'SHORT' if height < 1.70, 'MEDIUM' if <= 1.80, 'TALL' if > 1.80, else 'UNKNOWN' for NULL.",
    "id": 69
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_average_age_by_hometown` that does not accept any input parameters. This function is designed to return a set of records, where each record consists of two columns: `hometown` of type `TEXT` and `avg_age` of type `REAL`. The function's core operation involves querying the `people` table, aliased as `p`. It selects the value from the `Hometown` column of the `people` table, explicitly casting it to `TEXT`, and calculates the average of the values from the `Age` column of the `people` table, explicitly casting the result to `REAL`, aliasing this calculated average as `avg_age`. These aggregations are performed by grouping the rows based on the distinct values found in the `Hometown` column of the `people` table. Furthermore, a filtering condition is applied to these grouped results using a `HAVING` clause, ensuring that only groups (hometowns) where the count of individuals is greater than or equal to 1 are included in the final output. The function then returns this set of `hometown` and `avg_age` records as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_age_by_hometown()\nRETURNS TABLE(hometown TEXT, avg_age REAL) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT p.\"Hometown\"::TEXT, AVG(p.\"Age\")::REAL as avg_age\n    FROM people p\n    GROUP BY p.\"Hometown\"\n    HAVING COUNT(*) >= 1;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_average_age_by_hometown();"
    ],
    "summary": "Create a PostgreSQL function named calculate_average_age_by_hometown with no parameters that returns a table of hometown (TEXT) and avg_age (REAL). Query the people table, group by Hometown, calculate the average Age for each group, and return only groups with at least one member.",
    "natural_language": "Please construct a PostgreSQL function designated as 'calculate_average_age_by_hometown'. This function shall accept no parameters and shall return a table comprising two columns: 'hometown' of type TEXT and 'avg_age' of type REAL. The implementation must query the 'people' table, group the records by the 'Hometown' field, compute the average of the 'Age' column for each resultant group, and subsequently return only those groups for which the count of members is one or greater.",
    "id": 70
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `find_youngest_gymnast_hometown` that takes no parameters and returns a `TEXT` value representing the hometown of the youngest gymnast. The function begins by declaring a local variable named `youngest_hometown` of type `TEXT` to store the result. It then proceeds with a conditional check: it verifies if any records exist in the `gymnast` table that can be joined with the `people` table using the condition `g.\"Gymnast_ID\" = p.\"People_ID\"`. This check is performed by attempting to select the constant `1` from the `gymnast` table, aliased as `g`, joined with the `people` table, aliased as `p`, on the specified join condition. If this `EXISTS` condition evaluates to true, indicating that there is at least one gymnast associated with a person record, the function then executes a `SELECT` statement. This `SELECT` statement retrieves the value from the `Hometown` column of the `people` table, aliased as `p`, and stores it into the `youngest_hometown` variable. The data is sourced from the `people` table, aliased as `p`, joined with the `gymnast` table, aliased as `g`, on the join condition `p.\"People_ID\" = g.\"Gymnast_ID\"`. The results of this join are ordered in ascending order based on the values in the `Age` column of the `people` table, aliased as `p`. The `LIMIT 1` clause ensures that only the first row after sorting, which corresponds to the youngest person, is selected. If the initial `EXISTS` condition evaluates to false, meaning no gymnast records are associated with person records, the `youngest_hometown` variable is assigned the string literal `'NO_DATA'`. Finally, the function returns the current value stored in the `youngest_hometown` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION find_youngest_gymnast_hometown()\nRETURNS TEXT AS $$\nDECLARE\n    youngest_hometown TEXT;\nBEGIN\n    IF EXISTS (SELECT 1 FROM gymnast g JOIN people p ON g.\"Gymnast_ID\" = p.\"People_ID\") THEN\n        SELECT p.\"Hometown\" INTO youngest_hometown\n        FROM people p\n        JOIN gymnast g ON p.\"People_ID\" = g.\"Gymnast_ID\"\n        ORDER BY p.\"Age\" ASC\n        LIMIT 1;\n    ELSE\n        youngest_hometown := 'NO_DATA';\n    END IF;\n    \n    RETURN youngest_hometown;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT find_youngest_gymnast_hometown();"
    ],
    "summary": "Create a PostgreSQL function named find_youngest_gymnast_hometown with no parameters that returns TEXT. If gymnast records linked to people exist, find the Hometown of the person with the smallest Age from the joined tables and return it. If no records exist, return 'NO_DATA'.",
    "natural_language": "Write a PostgreSQL function called find_youngest_gymnast_hometown that takes no parameters and gives back TEXT. If there are any gymnast entries connected to people, figure out the Hometown for the person who seems to be the youngest from the combined data and send that back. If nothing is found, just return 'NO_DATA'.",
    "id": 71
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_popular_students` that returns a table with two columns: `student_name` of type `text` and `like_count` of type `bigint`. This function does not accept any input parameters. The function's core operation involves executing a `SELECT` query to retrieve data. The query selects the `name` column from the `\"Highschooler\"` table, aliased as `h`, and counts the occurrences of `liked_id` from the `\"Likes\"` table, aliased as `l`, assigning this count to a new column named `like_count`. The `\"Highschooler\"` table is joined with the `\"Likes\"` table using a `LEFT JOIN` operation. The join condition specifies that `h.\"ID\"` from the `\"Highschooler\"` table must be equal to `l.\"liked_id\"` from the `\"Likes\"` table. After the join, the results are grouped by `h.\"ID\"` and `h.\"name\"`. Finally, the grouped results are ordered in descending order based on the calculated `like_count`. The entire result set of this `SELECT` query is then returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_popular_students()\nRETURNS TABLE(student_name text, like_count bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT h.\"name\", COUNT(l.\"liked_id\") as like_count\n    FROM \"Highschooler\" h\n    LEFT JOIN \"Likes\" l ON h.\"ID\" = l.\"liked_id\"\n    GROUP BY h.\"ID\", h.\"name\"\n    ORDER BY like_count DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT * FROM get_popular_students();",
      "SELECT student_name FROM get_popular_students() WHERE like_count > 2;",
      "SELECT * FROM get_popular_students() ORDER BY student_name;",
      "SELECT student_name, like_count FROM get_popular_students() WHERE like_count = 0;",
      "SELECT student_name, like_count FROM get_popular_students() LIMIT 5;"
    ],
    "summary": "Create a function named get_popular_students that returns a table of student names and their like counts. It joins the Highschooler and Likes tables, groups by student, and orders by the count of likes in descending order.",
    "natural_language": "List the names of students and their total like counts by joining the Highschooler and Likes tables, grouping the results by student, and ordering them from the highest number of likes to the lowest.",
    "id": 72
  },
  {
    "ir": "Write a PLpgSQL function that returns a table consisting of student_id, student_name, and grade by querying the Highschooler table. The function takes a single parameter, name_pattern, of type text, which is used to filter the results. The function performs a SELECT operation on the Highschooler table, specifically retrieving the ID, name, and grade columns. It applies a WHERE clause to filter the rows based on the name column, using a case-insensitive pattern match. This is achieved by converting both the name column and the name_pattern parameter to lowercase using the LOWER() function and then applying the LIKE operator to perform the pattern matching. The function returns the result set directly as a table.",
    "plsql": "CREATE OR REPLACE FUNCTION find_students_by_name_pattern(name_pattern text)\nRETURNS TABLE(student_id integer, student_name text, grade integer) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT h.\"ID\", h.\"name\", h.\"grade\"\n    FROM \"Highschooler\" h\n    WHERE lower(h.\"name\") LIKE lower(name_pattern);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT * FROM find_students_by_name_pattern('Jord%');",
      "SELECT * FROM find_students_by_name_pattern('%an%');",
      "SELECT * FROM find_students_by_name_pattern('gabriel');",
      "SELECT * FROM find_students_by_name_pattern('Tiff%');",
      "SELECT * FROM find_students_by_name_pattern('%y');"
    ],
    "summary": "Create a function that returns a table of student IDs, names, and grades from the Highschooler table, filtered by a case-insensitive name pattern provided as a parameter.",
    "natural_language": "Please construct a function that yields a tabular result set comprising student identification numbers, full names, and academic grades from the Highschooler table. The function should accept a name pattern as an input parameter and apply a filter such that the name matching is performed without regard to letter case.",
    "id": 73
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_mutual_friends_count` that accepts two integer parameters: `student1_id` and `student2_id`. This function is designed to calculate and return the total number of mutual friends shared between the two students identified by these input IDs. The core operation involves a single `SELECT` statement that queries the `\"Friend\"` table. This `SELECT` statement performs an inner join of the `\"Friend\"` table with itself, aliasing the first instance as `f1` and the second as `f2`. The join condition `f1.\"friend_id\" = f2.\"friend_id\"` links rows where the `friend_id` column values are identical across both aliased instances of the table. This effectively identifies common friends. A `WHERE` clause is applied to filter the joined results: `f1.\"student_id\" = student1_id` ensures that the first instance of the friend relationship (`f1`) belongs to the student identified by the `student1_id` parameter, and `f2.\"student_id\" = student2_id` ensures that the second instance of the friend relationship (`f2`) belongs to the student identified by the `student2_id` parameter. The `COUNT(*)` aggregate function is then applied to the filtered and joined rows to determine the total number of such relationships, which represents the count of mutual friends. The result of `COUNT(*)` is explicitly cast to an `integer` type using `::integer` before being returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mutual_friends_count(student1_id integer, student2_id integer)\nRETURNS integer AS $$\nBEGIN\n    RETURN (\n        SELECT COUNT(*)::integer\n        FROM \"Friend\" f1\n        JOIN \"Friend\" f2 ON f1.\"friend_id\" = f2.\"friend_id\"\n        WHERE f1.\"student_id\" = student1_id AND f2.\"student_id\" = student2_id\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT get_mutual_friends_count(1510, 1689);",
      "SELECT get_mutual_friends_count(1689, 1510);",
      "SELECT get_mutual_friends_count(1381, 1709);",
      "SELECT get_mutual_friends_count(1510, 1381);",
      "SELECT get_mutual_friends_count(1709, 1689);"
    ],
    "summary": "Create a function named get_mutual_friends_count that takes two student IDs and returns an integer count of their mutual friends by joining the Friend table on itself.",
    "natural_language": "Function get_mutual_friends_count: takes two student IDs, returns integer count of their mutual friends via Friend table self-join.",
    "id": 74
  },
  {
    "ir": "Write a PLpgSQL function named calculate_gymnast_cosine that accepts a single parameter gymnast_id of type integer, which represents the unique identifier of a gymnast. The function retrieves the Total_Points value from the gymnast table for the row where the Gymnast_ID column matches the provided gymnast_id. If a matching row is found and the Total_Points value is not null, the function calculates the cosine of the Total_Points value using the cos() function and returns this result as a real number. If no matching row is found or if the Total_Points value is null, the function returns null.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_gymnast_cosine(gymnast_id integer) RETURNS real AS $$\nDECLARE\n    total_points real;\nBEGIN\n    SELECT \"Total_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    IF total_points IS NOT NULL THEN\n        RETURN cos(total_points);\n    ELSE\n        RETURN NULL;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT calculate_gymnast_cosine(1);",
      "SELECT calculate_gymnast_cosine(2);",
      "SELECT calculate_gymnast_cosine(4);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_gymnast_cosine that takes a gymnast_id integer and returns a real. It should return the cosine of the gymnast's Total_Points if found and not null; otherwise, return null.",
    "natural_language": "Function calculate_gymnast_cosine(gymnast_id integer) returns real. Return cosine(Total_Points) if found and not null, else null.",
    "id": 75
  },
  {
    "ir": "Write a PLpgSQL function named calculate_cosine_height that accepts a single parameter, people_id, of type integer, which represents the unique identifier for a person in the people table. The function is designed to return a real number. Within the function, declare a local variable named person_height of type real to store the height of the person. The function begins by executing a SELECT statement to retrieve the Height column from the people table where the People_ID column matches the provided people_id parameter. The retrieved height value is stored in the person_height variable. The function then checks if the person_height variable is not NULL using an IF conditional statement. If person_height contains a valid height value, the function calculates the cosine of this height using the cos() function and returns the result. If person_height is NULL, indicating that no height was found for the given People_ID, the function returns NULL. The function is defined using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_cosine_height(people_id integer) RETURNS real AS $$\nDECLARE\n    person_height real;\nBEGIN\n    SELECT \"Height\" INTO person_height FROM \"people\" WHERE \"People_ID\" = people_id;\n    IF person_height IS NOT NULL THEN\n        RETURN cos(person_height);\n    ELSE\n        RETURN NULL;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT calculate_cosine_height(1);",
      "SELECT calculate_cosine_height(2);",
      "SELECT calculate_cosine_height(3);",
      "SELECT calculate_cosine_height(4);",
      "SELECT calculate_cosine_height(5);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_cosine_height that takes a people_id integer and returns a real. It should return the cosine of the person's Height if found and not null; otherwise, return null.",
    "natural_language": "What PL/pgSQL function, named calculate_cosine_height, takes a people_id integer and returns a real, and how does it return the cosine of the person's Height if found and not null, otherwise returning null?",
    "id": 76
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter named chain_id of type bigint and returns an integer. This function calculates the number of department stores associated with a specific department store chain. It declares a local variable store_count of type integer to store the result of the calculation. The function performs a SELECT operation to count the number of rows in the \"Department_Stores\" table where the dept_store_chain_id column matches the provided chain_id parameter. The COUNT function is used to determine the total number of department stores that belong to the specified chain. The result of this count is stored in the store_count variable. Finally, the function returns the value of store_count, which represents the total number of department stores associated with the given chain_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_store_count_by_chain(chain_id bigint) RETURNS integer AS $$\nDECLARE\n    store_count integer;\nBEGIN\n    SELECT COUNT(dept_store_id) INTO store_count\n    FROM \"Department_Stores\"\n    WHERE dept_store_chain_id = chain_id;\n    RETURN store_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_store_count_by_chain(1);",
      "SELECT get_store_count_by_chain(2);",
      "SELECT get_store_count_by_chain(3);",
      "SELECT get_store_count_by_chain(4);",
      "SELECT get_store_count_by_chain(5);"
    ],
    "summary": "Create a PL/pgSQL function that takes a chain_id (bigint) and returns the count of department stores for that chain.",
    "natural_language": "Hey, can you whip up a function in PL/pgSQL that, given a chain's ID (as a bigint), spits back how many department stores that chain has?",
    "id": 77
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_staff_count_by_store` that accepts a single input parameter, `store_id`, of type `bigint`. This function is designed to return an integer value representing the count of distinct staff members associated with a specific store identified by the provided `store_id`. Upon execution, the function declares a local variable named `staff_count` of type `integer` to temporarily store the computed count. The core operation involves a `SELECT` statement that calculates the count of distinct `staff_id` values. This `SELECT` statement queries the `\"Staff\"` table, aliased as `s`, and performs two `JOIN` operations. The first `JOIN` connects `\"Staff\"` (s) with the `\"Staff_Department_Assignments\"` table, aliased as `sda`, using the join condition `s.staff_id = sda.staff_id`. The second `JOIN` connects the result of the first join with the `\"Departments\"` table, aliased as `d`, using the join condition `sda.department_id = d.department_id`. The `WHERE` clause filters the joined records, retaining only those where the `dept_store_id` column from the `\"Departments\"` table (d) is equal to the input parameter `store_id`. The `COUNT(DISTINCT s.staff_id)` aggregate function then counts the unique `staff_id` values from the filtered set of records. The result of this count is then assigned to the `staff_count` local variable. Finally, the function returns the value stored in the `staff_count` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_count_by_store(store_id bigint) RETURNS integer AS $$\nDECLARE\n    staff_count integer;\nBEGIN\n    SELECT COUNT(DISTINCT s.staff_id) INTO staff_count\n    FROM \"Staff\" s\n    JOIN \"Staff_Department_Assignments\" sda ON s.staff_id = sda.staff_id\n    JOIN \"Departments\" d ON sda.department_id = d.department_id\n    WHERE d.dept_store_id = store_id;\n    RETURN staff_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_staff_count_by_store(1);",
      "SELECT get_staff_count_by_store(2);",
      "SELECT get_staff_count_by_store(3);",
      "SELECT get_staff_count_by_store(5);",
      "SELECT get_staff_count_by_store(11);"
    ],
    "summary": "Create a PL/pgSQL function named get_staff_count_by_store that takes a store_id (bigint) and returns the count of distinct staff assigned to that store.",
    "natural_language": "Construct a PL/pgSQL function, which we shall name get_staff_count_by_store, that is designed to accept a single input parameter—specifically a store identifier of the bigint data type—and then meticulously calculates and returns the precise count of unique, individual staff members who are formally assigned to operate within that particular retail location.",
    "id": 78
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_department_count_by_store that accepts a single input parameter named store_id of type bigint, which represents the unique identifier of a store, and returns a single integer value; within the function, declare a local integer variable named department_count; then execute a SELECT query on the table named \"Departments\" to count the number of distinct department_id values for all rows where the column dept_store_id is equal to the provided store_id parameter, storing the resulting count into the department_count variable; finally, return the value stored in the department_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_count_by_store(store_id bigint) RETURNS integer AS $$\nDECLARE\n    department_count integer;\nBEGIN\n    SELECT COUNT(department_id) INTO department_count\n    FROM \"Departments\"\n    WHERE dept_store_id = store_id;\n    RETURN department_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_department_count_by_store(5);",
      "SELECT get_department_count_by_store(11);",
      "SELECT get_department_count_by_store(4);",
      "SELECT get_department_count_by_store(1);",
      "SELECT get_department_count_by_store(2);"
    ],
    "summary": "Create a PL/pgSQL function named get_department_count_by_store that takes a store_id (bigint) and returns the count of distinct departments in that store.",
    "natural_language": "Write a PL/pgSQL function called get_department_count_by_store that accepts a store_id (bigint) and gives back the number of distinct departments for that store.",
    "id": 79
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_staff_count_by_chain` that accepts a single input parameter, `chain_id`, of type `bigint`. This function is designed to return an integer representing the total count of distinct staff members associated with a specific department store chain identified by the provided `chain_id`. The function begins by declaring a local variable named `staff_count` of type `integer` to store the computed count. Subsequently, it executes a `SELECT` statement to calculate this count. The `SELECT` statement performs several `JOIN` operations: it joins the `\"Staff\"` table (aliased as `s`) with the `\"Staff_Department_Assignments\"` table (aliased as `sda`) on the condition that `s.staff_id` matches `sda.staff_id`. This result is then joined with the `\"Departments\"` table (aliased as `d`) on the condition that `sda.department_id` matches `d.department_id`. Finally, this result is joined with the `\"Department_Stores\"` table (aliased as `ds`) on the condition that `d.dept_store_id` matches `ds.dept_store_id`. The `WHERE` clause filters these joined records, retaining only those where the `dept_store_chain_id` column from the `\"Department_Stores\"` table (`ds.dept_store_chain_id`) is equal to the input parameter `chain_id`. The `COUNT(DISTINCT s.staff_id)` aggregate function is applied to the filtered set of records to count the unique `staff_id` values from the `\"Staff\"` table. The result of this count is then assigned to the `staff_count` variable. After the `SELECT` statement completes, the function returns the final value stored in the `staff_count` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_count_by_chain(chain_id bigint) RETURNS integer AS $$\nDECLARE\n    staff_count integer;\nBEGIN\n    SELECT COUNT(DISTINCT s.staff_id) INTO staff_count\n    FROM \"Staff\" s\n    JOIN \"Staff_Department_Assignments\" sda ON s.staff_id = sda.staff_id\n    JOIN \"Departments\" d ON sda.department_id = d.department_id\n    JOIN \"Department_Stores\" ds ON d.dept_store_id = ds.dept_store_id\n    WHERE ds.dept_store_chain_id = chain_id;\n    RETURN staff_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_staff_count_by_chain(1);",
      "SELECT get_staff_count_by_chain(2);",
      "SELECT get_staff_count_by_chain(3);",
      "SELECT get_staff_count_by_chain(4);",
      "SELECT get_staff_count_by_chain(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_staff_count_by_chain that takes a chain_id (bigint) and returns the count of distinct staff across all stores in that chain.",
    "natural_language": "How many distinct staff members are there across all stores for a given chain?",
    "id": 80
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns the email address of a store from the \"Department_Stores\" table, given a specific department store chain identifier as input. The function, named get_store_email_by_chain, accepts a single parameter named chain_id of type bigint, which represents the unique identifier for the department store chain. Within the function, a variable named store_email of type text is declared to hold the email address of the store. The function executes a SELECT statement to fetch the store_email column from the \"Department_Stores\" table, where the dept_store_chain_id column matches the provided chain_id parameter. The query is limited to retrieving only one record, using the LIMIT 1 clause. The result of the query is stored in the store_email variable. Finally, the function returns the value of store_email, which is the email address of the store associated with the specified department store chain identifier.",
    "plsql": "CREATE OR REPLACE FUNCTION get_store_email_by_chain(chain_id bigint) RETURNS text AS $$\nDECLARE\n    store_email text;\nBEGIN\n    SELECT ds.store_email INTO store_email\n    FROM \"Department_Stores\" ds\n    WHERE ds.dept_store_chain_id = chain_id\n    LIMIT 1;\n    RETURN store_email;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_store_email_by_chain(1);",
      "SELECT get_store_email_by_chain(2);",
      "SELECT get_store_email_by_chain(3);",
      "SELECT get_store_email_by_chain(4);",
      "SELECT get_store_email_by_chain(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_store_email_by_chain that takes a chain_id (bigint) and returns the email address for a store in that chain.",
    "natural_language": "Write function get_store_email_by_chain(chain_id bigint) returning store email.",
    "id": 81
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter named product_id_input of type bigint and returns a bigint. The function calculates the total number of records in the \"Problems\" table where the product_id column matches the provided product_id_input. It does this by executing a SELECT COUNT(*) query on the \"Problems\" table, filtering the results with a WHERE clause that checks for equality between the product_id column and the product_id_input parameter. The result of this count operation is stored in a local variable named problem_count, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_problem_count(product_id_input bigint) RETURNS bigint AS $$\nDECLARE\n    problem_count bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO problem_count\n    FROM \"Problems\"\n    WHERE product_id = product_id_input;\n    RETURN problem_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "SELECT get_product_problem_count(1);",
      "SELECT get_product_problem_count(2);",
      "SELECT get_product_problem_count(3);",
      "SELECT get_product_problem_count(4);",
      "SELECT get_product_problem_count(8);"
    ],
    "summary": "Create a function that accepts a product_id_input (bigint) and returns a bigint. The function should count and return the number of records in the \"Problems\" table where the product_id matches the input parameter.",
    "natural_language": "Design a function that takes a single bigint parameter, specifically a product_id_input, and yields a bigint result. This function should meticulously calculate and then provide the total count of entries found within the \"Problems\" table, exclusively for those records where the product_id column corresponds precisely to the supplied input argument.",
    "id": 82
  },
  {
    "ir": "Write a PLpgSQL function named get_staff_problem_summary that accepts a single parameter, staff_id_input, of type bigint, and returns a table with two columns: reported_count and assigned_count, both of type bigint. The function begins by executing a RETURN QUERY statement, which performs two subqueries. The first subquery counts the number of rows in the Problems table where the reported_by_staff_id column matches the value of staff_id_input, effectively calculating how many problems have been reported by the specified staff member. The second subquery counts the number of rows in the Problem_Log table where the assigned_to_staff_id column equals the staff_id_input, determining how many problems have been assigned to the specified staff member. The results of these two subqueries are returned as a single row with two columns, reported_count and assigned_count, representing the total number of problems reported by and assigned to the staff member identified by staff_id_input, respectively.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_problem_summary(staff_id_input bigint) RETURNS TABLE(reported_count bigint, assigned_count bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        (SELECT COUNT(*) FROM \"Problems\" WHERE reported_by_staff_id = staff_id_input),\n        (SELECT COUNT(*) FROM \"Problem_Log\" WHERE assigned_to_staff_id = staff_id_input);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "SELECT * FROM get_staff_problem_summary(1);",
      "SELECT * FROM get_staff_problem_summary(2);",
      "SELECT * FROM get_staff_problem_summary(10);",
      "SELECT * FROM get_staff_problem_summary(11);",
      "SELECT * FROM get_staff_problem_summary(12);"
    ],
    "summary": "Create a function named get_staff_problem_summary that accepts a staff_id_input (bigint) and returns a table with columns reported_count and assigned_count (both bigint). The function should return a single row containing: the count of problems reported by the staff member from the \"Problems\" table, and the count of problems assigned to the staff member from the \"Problem_Log\" table.",
    "natural_language": "Construct a function called get_staff_problem_summary which is designed to take a single input parameter, specifically a staff_id_input of type bigint. This function must return a results table featuring precisely two columns: reported_count and assigned_count, both defined as bigint. The function's purpose is to meticulously calculate and deliver, within a single row of output, the following detailed counts: firstly, the total number of problems that were originally reported by the specified staff member, diligently extracted from the \"Problems\" table; and secondly, the comprehensive count of all problems that have been officially assigned to that staff member, carefully gathered from the records within the \"Problem_Log\" table.",
    "id": 83
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named generate_problem_hash that accepts a single input parameter called problem_id_input of type bigint, which is used to identify a specific record in the \"Problems\" table, and returns a value of type text; the function begins by declaring a local text variable named hash_result, then executes a SELECT query that retrieves a single row from the \"Problems\" table where the problem_id column exactly matches the provided problem_id_input parameter, and for that row, it calculates an MD5 cryptographic hash by concatenating the value from the problem_description column with the value from the other_problem_details column and passing the concatenated string to the built-in md5() function, storing the resulting hash string into the hash_result variable, and finally the function returns the value stored in hash_result.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_problem_hash(problem_id_input bigint) RETURNS text AS $$\nDECLARE\n    hash_result text;\nBEGIN\n    SELECT md5(problem_description || other_problem_details)\n    INTO hash_result\n    FROM \"Problems\"\n    WHERE problem_id = problem_id_input;\n    RETURN hash_result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "SELECT generate_problem_hash(1);",
      "SELECT generate_problem_hash(2);",
      "SELECT generate_problem_hash(3);",
      "SELECT generate_problem_hash(11);",
      "SELECT generate_problem_hash(8);"
    ],
    "summary": "Create a function named generate_problem_hash that accepts a problem_id_input (bigint) and returns a text value. The function should retrieve the row from the \"Problems\" table matching the input ID, calculate an MD5 hash by concatenating the problem_description and other_problem_details columns, and return the hash string.",
    "natural_language": "Please construct a function designated as 'generate_problem_hash'. This function shall accept a single parameter of type bigint, named 'problem_id_input', and shall return a value of type text. The function's operation must involve querying the \"Problems\" table to locate the record corresponding to the provided identifier. Subsequently, it must compute an MD5 hash by concatenating the contents of the 'problem_description' and 'other_problem_details' columns from that record. The resultant hash string is to be returned as the function's output.",
    "id": 84
  },
  {
    "ir": "Write a PLpgSQL function named get_problem_category_stats that returns a table with columns category_code of type text, total_problems of type bigint, and avg_log_entries of type numeric. The function begins by executing a query that defines a Common Table Expression (CTE) named ProblemLogCounts. This CTE selects the problem_id and problem_category_code from the Problem_Log table, counting the number of problem_log_id entries for each unique combination of problem_id and problem_category_code, and groups the results by these two columns. The main query then selects from the Problem_Category_Codes table, retrieving the problem_category_code column. It performs a LEFT JOIN operation with the ProblemLogCounts CTE on the problem_category_code column to associate each category code with its corresponding log entry counts. The query calculates the total number of distinct problems for each category code using COUNT(DISTINCT plc.problem_id) and casts the result to bigint. It also computes the average number of log entries per problem for each category code using AVG(plc.log_entry_count), applying the COALESCE function to ensure that the average is zero if there are no log entries, and casts the result to numeric. The results are grouped by the problem_category_code column to produce the final output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_problem_category_stats() RETURNS TABLE(category_code text, total_problems bigint, avg_log_entries numeric) AS $$\nBEGIN\n    RETURN QUERY\n    WITH ProblemLogCounts AS (\n        SELECT\n            pl.problem_id,\n            pl.problem_category_code,\n            COUNT(pl.problem_log_id) AS log_entry_count\n        FROM \"Problem_Log\" pl\n        GROUP BY pl.problem_id, pl.problem_category_code\n    )\n    SELECT\n        pc.problem_category_code,\n        COUNT(DISTINCT plc.problem_id)::bigint AS total_problems,\n        COALESCE(AVG(plc.log_entry_count), 0)::numeric AS avg_log_entries\n    FROM \"Problem_Category_Codes\" pc\n    LEFT JOIN ProblemLogCounts plc ON pc.problem_category_code = plc.problem_category_code\n    GROUP BY pc.problem_category_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "SELECT * FROM get_problem_category_stats();"
    ],
    "summary": "Create a function named get_problem_category_stats that returns a table with columns category_code (text), total_problems (bigint), and avg_log_entries (numeric). The function should use a CTE to count log entries per problem and category. The main query must join the category codes with the CTE, calculate the total distinct problems and the average log entries per problem for each category, and return the results grouped by category.",
    "natural_language": "Create function get_problem_category_stats returning table(category_code text, total_problems bigint, avg_log_entries numeric). Use CTE for log counts per problem and category. Join categories with CTE, compute total distinct problems and average log entries per problem by category, group by category.",
    "id": 85
  },
  {
    "ir": "Write a PLpgSQL function named justify_collection_days that accepts two parameters: \"Collection_ID\" of type bigint and days_interval of type interval. The function aims to process the days_interval parameter using the PostgreSQL built-in function justify_days, which adjusts the interval to normalize the number of days, months, and years. The function begins by declaring a local variable justified_interval of type interval to store the result of the justify_days operation. Within the function body, it assigns the result of justify_days applied to days_interval to justified_interval. A conditional statement then checks if justified_interval is not null, and if this condition is true, the function returns justified_interval. If the condition is false, meaning justified_interval is null, the function returns an interval of '0 days'. The function does not interact with any tables, perform any updates, inserts, deletes, or selects, nor does it utilize any other functions or special operations beyond justify_days. The logic flow is straightforward, with a single conditional statement determining the return value based on the presence or absence of a non-null justified interval.",
    "plsql": "CREATE OR REPLACE FUNCTION justify_collection_days(\"Collection_ID\" bigint, days_interval interval)\nRETURNS interval\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    justified_interval interval;\nBEGIN\n    justified_interval := justify_days(days_interval);\n    IF justified_interval IS NOT NULL THEN\n        RETURN justified_interval;\n    END IF;\n    RETURN interval '0 days';\nEND;\n$$;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collections",
      "Documents_in_Collections"
    ],
    "call_sqls": [
      "SELECT justify_collection_days(6, INTERVAL '5 days');",
      "SELECT justify_collection_days(7, INTERVAL '10 days');",
      "SELECT justify_collection_days(6, INTERVAL '1 day');",
      "SELECT justify_collection_days(7, INTERVAL '0 days');",
      "SELECT justify_collection_days(6, INTERVAL '20 days');"
    ],
    "summary": "Create a PL/pgSQL function named justify_collection_days that accepts a bigint Collection_ID and an interval days_interval. It uses justify_days on the interval, stores the result, and returns that result if not null, otherwise returns an interval of '0 days'.",
    "natural_language": "Alright, so we need a PL/pgSQL function called justify_collection_days. It's gotta take in a bigint for the Collection_ID and an interval called days_interval. The function should run justify_days on that interval, stash the result, and then spit it back out if it's not null. If it is null, just hand back an interval of '0 days'.",
    "id": 86
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_student_major_count` that accepts a single input parameter named `city_code_input` of data type `TEXT`. This function is designed to return a single value of data type `BIGINT`. The primary purpose of this function is to calculate and return the count of distinct major values associated with students residing in a specific city, as identified by the provided `city_code_input`.\n\nUpon execution, the function declares a local variable named `major_count` of data type `BIGINT`. The core operation involves a `SELECT` statement that queries the table named `\"Student\"`. Within this `SELECT` statement, the `COUNT` aggregate function is applied to the `DISTINCT` values found in the column named `\"Major\"`. This `COUNT(DISTINCT \"Major\")` operation effectively tallies the number of unique major designations. The selection of rows for this count is constrained by a `WHERE` clause, which specifies that only those rows where the value in the column named `\"city_code\"` is exactly equal to the value provided in the `city_code_input` parameter should be considered. The result of this `COUNT(DISTINCT \"Major\")` operation is then assigned to the previously declared local variable `major_count`. Finally, the function concludes by returning the value stored in the `major_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_major_count(city_code_input TEXT) RETURNS BIGINT AS $$\nDECLARE\n    major_count BIGINT;\nBEGIN\n    SELECT COUNT(DISTINCT \"Major\") INTO major_count FROM \"Student\" WHERE \"city_code\" = city_code_input;\n    RETURN major_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_student_major_count('BAL');",
      "SELECT get_student_major_count('PIT');",
      "SELECT get_student_major_count('PHL');",
      "SELECT get_student_major_count('HKG');",
      "SELECT get_student_major_count('WAS');"
    ],
    "summary": "Create a PL/pgSQL function named get_student_major_count that takes a TEXT city_code_input and returns a BIGINT. It counts the distinct \"Major\" values from the \"Student\" table where the \"city_code\" matches the input parameter.",
    "natural_language": "How many distinct majors are there for students in a given city code?",
    "id": 87
  },
  {
    "ir": "Write a PLpgSQL function named get_city_average_latitude that accepts a single parameter, country_input, of type TEXT, which represents the name of a country. The function calculates the average latitude of all cities within the specified country by performing a SELECT operation on the \"City\" table. It retrieves the latitude values from the latitude column for rows where the country column matches the provided country_input parameter. The function uses the AVG() aggregate function to compute the average of these latitude values and stores the result in a local variable named avg_latitude of type DOUBLE PRECISION. Finally, the function returns the computed average latitude value as a DOUBLE PRECISION result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_city_average_latitude(country_input TEXT) RETURNS DOUBLE PRECISION AS $$\nDECLARE\n    avg_latitude DOUBLE PRECISION;\nBEGIN\n    SELECT AVG(latitude) INTO avg_latitude FROM \"City\" WHERE country = country_input;\n    RETURN avg_latitude;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_city_average_latitude('USA');",
      "SELECT get_city_average_latitude('Canada');",
      "SELECT get_city_average_latitude('Mexico');",
      "SELECT get_city_average_latitude('Brazil');",
      "SELECT get_city_average_latitude('UK');"
    ],
    "summary": "Create a PL/pgSQL function named get_city_average_latitude that takes a TEXT country_input and returns a DOUBLE PRECISION. It calculates the average of the latitude column from the \"City\" table where the country column matches the input.",
    "natural_language": "Write a function get_city_average_latitude(country_input TEXT) returning DOUBLE PRECISION to compute average latitude from City for the given country.",
    "id": 88
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_total_distance` that accepts a single input parameter, `city_code_input`, which is of data type `TEXT`. This function is designed to calculate and return the sum of distances associated with a given city code. Upon execution, the function declares a local variable named `total_distance` of data type `BIGINT` to store the computed sum. The core operation involves executing a `SELECT` statement to retrieve data from the table named `\"Direct_distance\"`. Specifically, it calculates the `SUM` of values from the `distance` column. This summation is performed under a `WHERE` clause condition: it includes rows where the value in the `city1_code` column is equal to the value provided in the `city_code_input` parameter, OR where the value in the `city2_code` column is equal to the value provided in the `city_code_input` parameter. The result of this `SUM` aggregation is then assigned to the `total_distance` local variable. Finally, the function returns the value stored in the `total_distance` variable, which represents the aggregated sum of distances, as a `BIGINT`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_distance(city_code_input TEXT) RETURNS BIGINT AS $$\nDECLARE\n    total_distance BIGINT;\nBEGIN\n    SELECT SUM(distance) INTO total_distance FROM \"Direct_distance\" WHERE city1_code = city_code_input OR city2_code = city_code_input;\n    RETURN total_distance;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_total_distance('BAL');",
      "SELECT get_total_distance('PIT');",
      "SELECT get_total_distance('PHL');",
      "SELECT get_total_distance('ATL');",
      "SELECT get_total_distance('BKK');"
    ],
    "summary": "Create a PL/pgSQL function named get_total_distance that takes a TEXT city_code_input and returns a BIGINT. It calculates the sum of the distance column from the \"Direct_distance\" table where the city1_code or city2_code matches the input parameter.",
    "natural_language": "Write a PL/pgSQL function called get_total_distance that accepts a TEXT parameter for a city code and gives back a BIGINT. It should figure out the total from the distance column in the \"Direct_distance\" table for entries where the provided code is kind of similar to either the city1_code or the city2_code.",
    "id": 89
  },
  {
    "ir": "Write a PLpgSQL function that takes a parameter city_code_input of type TEXT and returns a BIGINT value representing the count of students residing in a specific city. The function begins by declaring a variable student_count of type BIGINT to store the result of the count operation. It then executes a SELECT statement that counts all rows in the \"Student\" table where the city_code column matches the provided city_code_input parameter. The result of this count operation is stored in the student_count variable. Finally, the function returns the value of student_count, which represents the total number of students associated with the specified city code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_count_by_city(city_code_input TEXT) RETURNS BIGINT AS $$\nDECLARE\n    student_count BIGINT;\nBEGIN\n    SELECT COUNT(*) INTO student_count FROM \"Student\" WHERE city_code = city_code_input;\n    RETURN student_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_student_count_by_city('BAL');",
      "SELECT get_student_count_by_city('PIT');",
      "SELECT get_student_count_by_city('PHL');",
      "SELECT get_student_count_by_city('HKG');",
      "SELECT get_student_count_by_city('WAS');"
    ],
    "summary": "Create a PL/pgSQL function that takes a TEXT city_code_input and returns a BIGINT. It counts all rows in the \"Student\" table where the city_code column matches the input parameter.",
    "natural_language": "Construct a PL/pgSQL function that accepts a single TEXT parameter, specifically a city_code_input, and meticulously returns a BIGINT value. This function should perform a comprehensive count of every single row within the \"Student\" table, but only for those records where the city_code column precisely and exactly matches the provided input parameter.",
    "id": 90
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_max_distance_between_cities` that accepts a single input parameter, `city_code_input`, which is of type `TEXT`. This function is designed to return a single value of type `BIGINT`. Upon execution, the function declares a local variable named `max_distance` of type `BIGINT`. The core operation of the function involves performing a `SELECT` statement to retrieve data from the table named `\"Direct_distance\"`. Specifically, it calculates the maximum value from the `distance` column within this table. The rows considered for this maximum calculation are filtered by a `WHERE` clause. This `WHERE` clause specifies that a row is included if the value in its `city1_code` column is equal to the `city_code_input` parameter, OR if the value in its `city2_code` column is equal to the `city_code_input` parameter. The result of this `MAX` aggregation is then assigned to the `max_distance` local variable. Finally, the function returns the value stored in the `max_distance` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_distance_between_cities(city_code_input TEXT) RETURNS BIGINT AS $$\nDECLARE\n    max_distance BIGINT;\nBEGIN\n    SELECT MAX(distance) INTO max_distance FROM \"Direct_distance\" WHERE city1_code = city_code_input OR city2_code = city_code_input;\n    RETURN max_distance;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_max_distance_between_cities('BAL');",
      "SELECT get_max_distance_between_cities('PIT');",
      "SELECT get_max_distance_between_cities('PHL');",
      "SELECT get_max_distance_between_cities('ATL');",
      "SELECT get_max_distance_between_cities('BKK');"
    ],
    "summary": "Create a function named `get_max_distance_between_cities` that takes a text `city_code_input` and returns a bigint. It calculates and returns the maximum distance from the `Direct_distance` table where the input code matches either the `city1_code` or `city2_code`.",
    "natural_language": "Create a function called `get_max_distance_between_cities` that takes some city code text and gives back a bigint. It should figure out and return the biggest distance from the `Direct_distance` table for cases where the given code kind of matches either the starting city code or the ending city code.",
    "id": 91
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_total_treatment_cost that takes no input parameters and returns a single numeric value, which is the result of executing a SELECT query that calculates the sum of all values contained in the cost_of_treatment column from every row in the table named \"Treatments\".",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_treatment_cost()\nRETURNS NUMERIC AS $$\nBEGIN\n    RETURN (SELECT SUM(cost_of_treatment) FROM \"Treatments\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "SELECT get_total_treatment_cost();"
    ],
    "summary": "Create a function named `get_total_treatment_cost` with no parameters that returns a numeric value. It calculates and returns the sum of the `cost_of_treatment` column from the `Treatments` table.",
    "natural_language": "Write a function called `get_total_treatment_cost` that doesn't take any inputs and gives back a number. It should figure out the total by adding up all the amounts in the `cost_of_treatment` field from the `Treatments` table.",
    "id": 92
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named count_large_dogs that takes no input parameters and returns a single value of type BIGINT, where the function body executes a SELECT statement that queries the table named \"Dogs\" to compute the total number of rows by using the COUNT(*) aggregate function, applying a filter condition on the size_code column such that only rows where the size_code column holds the exact string value 'LGE' are included in the count, and then returns this computed count as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION count_large_dogs()\nRETURNS BIGINT AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM \"Dogs\" WHERE size_code = 'LGE');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "SELECT count_large_dogs();"
    ],
    "summary": "Create a function named count_large_dogs that returns a BIGINT. It counts rows in the \"Dogs\" table where the size_code column equals 'LGE'.",
    "natural_language": "Please construct a function designated as 'count_large_dogs' that yields a value of type BIGINT. The function's purpose is to enumerate the records within the \"Dogs\" table for which the value in the 'size_code' column is equivalent to the string 'LGE'.",
    "id": 93
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named \"calculate_delivery_metrics\" that accepts two input parameters: `p_start_date` of type `TIMESTAMP` representing the inclusive beginning of a date range, and `p_end_date` of type `TIMESTAMP` representing the inclusive end of the date range. This function is designed to return a set of rows, effectively acting as a table, with three columns: `location` of type `TEXT`, `total_orders` of type `BIGINT`, and `avg_driver_id` of type `NUMERIC`. The function's core operation involves executing a `SELECT` query. This query retrieves data by joining two tables: `\"Actual_Orders\"` (aliased as `ao`) and `\"Order_Deliveries\"` (aliased as `od`). The join condition specifies that rows from `\"Actual_Orders\"` and `\"Order_Deliveries\"` are matched when the value in the `actual_order_id` column of `\"Actual_Orders\"` is equal to the value in the `actual_order_id` column of `\"Order_Deliveries\"`. A filtering condition is applied to the joined data, retaining only those rows where the `actual_order_date` column from the `\"Actual_Orders\"` table falls inclusively between the `p_start_date` and `p_end_date` input parameters. After filtering, the remaining rows are grouped by the `location_code` column from the `\"Order_Deliveries\"` table. For each distinct `location_code` group, the query calculates three aggregate values: first, it counts the number of unique `actual_order_id` values from the `\"Actual_Orders\"` table, representing the `total_orders`; second, it computes the average of the `driver_employee_id` column from the `\"Order_Deliveries\"` table, explicitly casting `driver_employee_id` to a `NUMERIC` type before averaging, representing the `avg_driver_id`; and third, it selects the `location_code` itself from the `\"Order_Deliveries\"` table, which becomes the `location` column in the result set. The function then returns this aggregated and grouped result set.",
    "plsql": "CREATE OR REPLACE FUNCTION \"calculate_delivery_metrics\"(p_start_date TIMESTAMP, p_end_date TIMESTAMP) RETURNS TABLE(location TEXT, total_orders BIGINT, avg_driver_id NUMERIC) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT od.\"location_code\", COUNT(DISTINCT ao.\"actual_order_id\"), AVG(od.\"driver_employee_id\"::NUMERIC)\n    FROM \"Actual_Orders\" ao\n    JOIN \"Order_Deliveries\" od ON ao.\"actual_order_id\" = od.\"actual_order_id\"\n    WHERE ao.\"actual_order_date\" BETWEEN p_start_date AND p_end_date\n    GROUP BY od.\"location_code\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Order_Deliveries"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_delivery_metrics('2018-02-25 00:00:00+08:00', '2018-03-02 23:59:59+08:00');",
      "SELECT * FROM calculate_delivery_metrics('2018-03-01 00:00:00+08:00', '2018-03-02 23:59:59+08:00');",
      "SELECT * FROM calculate_delivery_metrics('2018-02-26 00:00:00+08:00', '2018-03-01 23:59:59+08:00');",
      "SELECT * FROM calculate_delivery_metrics('2018-02-25 00:00:00+08:00', '2018-02-28 23:59:59+08:00');",
      "SELECT * FROM calculate_delivery_metrics('2018-03-02 00:00:00+08:00', '2018-03-02 23:59:59+08:00');"
    ],
    "summary": "Create a PostgreSQL function named \"calculate_delivery_metrics\" that returns a table with columns location (TEXT), total_orders (BIGINT), and avg_driver_id (NUMERIC). The function accepts start and end TIMESTAMP parameters. It joins the \"Actual_Orders\" and \"Order_Deliveries\" tables on actual_order_id, filters for orders within the date range, groups by location_code, and for each group returns the location, count of distinct orders, and the average of driver_employee_id cast to NUMERIC.",
    "natural_language": "Write a PostgreSQL function \"calculate_delivery_metrics\" returning a table (location TEXT, total_orders BIGINT, avg_driver_id NUMERIC). It takes start and end TIMESTAMPs, joins Actual_Orders and Order_Deliveries on actual_order_id, filters by date range, groups by location_code, and returns location, distinct order count, and average driver_employee_id as NUMERIC.",
    "id": 94
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named \"consolidate_order_data\" that accepts one input parameter, `p_driver_threshold`, which is of type `BIGINT`. This function is designed to return a table with four columns: `order_id` of type `BIGINT`, `status` of type `TEXT`, `delivery_location` of type `TEXT`, and `driver_experience` of type `TEXT`. The function's core operation is to execute a `SELECT` query to retrieve and consolidate order-related data.\n\nThe `SELECT` statement performs a `LEFT JOIN` between two tables: `\"Actual_Orders\"` (aliased as `ao`) and `\"Order_Deliveries\"` (aliased as `od`). The join condition links rows from `\"Actual_Orders\"` to `\"Order_Deliveries\"` where the `actual_order_id` column in `\"Actual_Orders\"` matches the `actual_order_id` column in `\"Order_Deliveries\"`. This `LEFT JOIN` ensures that all orders from `\"Actual_Orders\"` are included in the result set, even if there is no corresponding entry in `\"Order_Deliveries\"`.\n\nThe `WHERE` clause filters the results to include only orders from `\"Actual_Orders\"` where the `actual_order_date` is more recent than 30 days prior to the current timestamp. This is achieved by comparing `ao.\"actual_order_date\"` with the result of `CURRENT_TIMESTAMP - INTERVAL '30 days'`.\n\nThe `SELECT` list specifies the columns to be returned:\n1.  `ao.\"actual_order_id\"`: This directly selects the `actual_order_id` from the `\"Actual_Orders\"` table and renames it to `order_id` in the output table.\n2.  `ao.\"order_status_code\"`: This directly selects the `order_status_code` from the `\"Actual_Orders\"` table and renames it to `status` in the output table.\n3.  `COALESCE(od.\"location_code\", 'Unknown')`: This expression selects the `location_code` from the `\"Order_Deliveries\"` table. If `od.\"location_code\"` is `NULL` (which can happen due to the `LEFT JOIN` if an order has no delivery record, or if the `location_code` itself is `NULL` in `\"Order_Deliveries\"`), it defaults to the string literal `'Unknown'`. This result is renamed to `delivery_location` in the output table.\n4.  A `CASE` statement determines the `driver_experience` based on the `driver_employee_id` from the `\"Order_Deliveries\"` table:\n    *   `WHEN od.\"driver_employee_id\" IS NULL THEN 'No Driver'`: If the `driver_employee_id` in `\"Order_Deliveries\"` is `NULL` (again, possibly due to the `LEFT JOIN` or an actual `NULL` value), the `driver_experience` is set to the string literal `'No Driver'`.\n    *   `WHEN od.\"driver_employee_id\" < p_driver_threshold THEN 'Junior Driver'`: If the `driver_employee_id` is not `NULL` and its value is less than the input parameter `p_driver_threshold`, the `driver_experience` is set to the string literal `'Junior Driver'`.\n    *   `WHEN od.\"driver_employee_id\" = p_driver_threshold THEN 'Mid Driver'`: If the `driver_employee_id` is not `NULL` and its value is equal to the input parameter `p_driver_threshold`, the `driver_experience` is set to the string literal `'Mid Driver'`.\n    *   `ELSE 'Senior Driver'`: For all other cases (i.e., if `driver_employee_id` is not `NULL` and is greater than `p_driver_threshold`), the `driver_experience` is set to the string literal `'Senior Driver'`.\n    This result is renamed to `driver_experience` in the output table.\n\nThe `RETURN QUERY` statement then returns the entire result set generated by this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION \"consolidate_order_data\"(p_driver_threshold BIGINT) RETURNS TABLE(order_id BIGINT, status TEXT, delivery_location TEXT, driver_experience TEXT) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT ao.\"actual_order_id\", \n           ao.\"order_status_code\",\n           COALESCE(od.\"location_code\", 'Unknown'),\n           CASE \n               WHEN od.\"driver_employee_id\" IS NULL THEN 'No Driver'\n               WHEN od.\"driver_employee_id\" < p_driver_threshold THEN 'Junior Driver'\n               WHEN od.\"driver_employee_id\" = p_driver_threshold THEN 'Mid Driver'\n               ELSE 'Senior Driver'\n           END\n    FROM \"Actual_Orders\" ao\n    LEFT JOIN \"Order_Deliveries\" od ON ao.\"actual_order_id\" = od.\"actual_order_id\"\n    WHERE ao.\"actual_order_date\" > CURRENT_TIMESTAMP - INTERVAL '30 days';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Order_Deliveries"
    ],
    "call_sqls": [
      "SELECT * FROM consolidate_order_data(5);",
      "SELECT * FROM consolidate_order_data(10);",
      "SELECT * FROM consolidate_order_data(15);",
      "SELECT * FROM consolidate_order_data(20);",
      "SELECT * FROM consolidate_order_data(25);"
    ],
    "summary": "Create a PostgreSQL function named \"consolidate_order_data\" that returns a table with columns order_id (BIGINT), status (TEXT), delivery_location (TEXT), and driver_experience (TEXT). It accepts a BIGINT parameter p_driver_threshold. The function performs a LEFT JOIN between \"Actual_Orders\" and \"Order_Deliveries\" on actual_order_id, filters for orders from the last 30 days, and selects: the order ID, status code, location (defaulting to 'Unknown' if NULL), and a driver experience category ('No Driver', 'Junior', 'Mid', or 'Senior') based on comparing driver_employee_id to the threshold.",
    "natural_language": "How can I create a PostgreSQL function called \"consolidate_order_data\" that returns a table with order_id, status, delivery_location, and driver_experience columns? The function should take a BIGINT parameter p_driver_threshold, perform a LEFT JOIN between \"Actual_Orders\" and \"Order_Deliveries\" on actual_order_id, filter for orders from the last 30 days, and then select the order ID, status code, a location (defaulting to 'Unknown' if NULL), and a driver experience category ('No Driver', 'Junior', 'Mid', or 'Senior') based on comparing driver_employee_id to the provided threshold.",
    "id": 95
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_university_total_score that accepts a single integer input parameter named para_University_ID, which is intended to identify a specific university, and returns an integer value; the function's logic consists of a single SQL SELECT query executed within a RETURN statement that retrieves the value from the column named \"Total\" in the table named \"overall_ranking\", specifically from the row where the value in the column named \"University_ID\" is exactly equal to the provided input parameter para_University_ID, and this retrieved integer value is then directly returned as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_university_total_score(para_University_ID integer)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT \"Total\" FROM \"overall_ranking\" WHERE \"University_ID\" = para_University_ID);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT get_university_total_score(1);",
      "SELECT get_university_total_score(2);",
      "SELECT get_university_total_score(3);"
    ],
    "summary": "Create a PostgreSQL function named \"get_university_total_score\" that returns an INTEGER. It accepts an integer parameter para_University_ID. The function returns the value from the \"Total\" column in the \"overall_ranking\" table where the \"University_ID\" column matches the provided parameter.",
    "natural_language": "Hey, can you whip up a PostgreSQL function called \"get_university_total_score\" that gives back an INTEGER? It should take one integer input, para_University_ID. Basically, the function needs to fetch and return the number from the \"Total\" column in the \"overall_ranking\" table for the uni whose \"University_ID\" matches the ID you throw at it.",
    "id": 96
  },
  {
    "ir": "Write a PLpgSQL function that calculates the average enrollment of universities located in a specified state. The function, named calculate_avg_enrollment_by_state, accepts a single parameter \"State\" of type text, which represents the name of the state for which the average enrollment is to be calculated. The function returns a numeric value representing the average enrollment rounded to two decimal places. Within the function, a SELECT statement is executed to compute the average of the \"Enrollment\" column from the \"university\" table, where the \"State\" column in the \"university\" table matches the provided \"State\" parameter. The AVG function is used to calculate the average enrollment, and the ROUND function is applied to round the result to two decimal places. The function is defined using the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_enrollment_by_state(\"State\" text)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT ROUND(AVG(\"Enrollment\"), 2) FROM \"university\" WHERE \"university\".\"State\" = $1);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT calculate_avg_enrollment_by_state('Illinois');",
      "SELECT calculate_avg_enrollment_by_state('Wisconsin');",
      "SELECT calculate_avg_enrollment_by_state('California');",
      "SELECT calculate_avg_enrollment_by_state('New York');",
      "SELECT calculate_avg_enrollment_by_state('Texas');"
    ],
    "summary": "Create a PostgreSQL function named \"calculate_avg_enrollment_by_state\" that returns a NUMERIC value rounded to two decimal places. It accepts a TEXT parameter \"State\". The function calculates the average of the \"Enrollment\" column from the \"university\" table where the \"State\" column matches the provided parameter.",
    "natural_language": "Develop a PostgreSQL function called \"calculate_avg_enrollment_by_state\" which is designed to return a NUMERIC value that is carefully rounded to precisely two decimal places. This specialized function should accept a single TEXT parameter named \"State\". Its primary purpose is to meticulously compute the average value from the \"Enrollment\" column within the extensive \"university\" table, specifically filtering for those records where the \"State\" column exactly corresponds to the parameter that is supplied.",
    "id": 97
  },
  {
    "ir": "Write a PL/pgSQL function named `get_major_name_by_code` that accepts a single input parameter. This parameter is named `\"Major_Code\"`, has a data type of `integer`, and its purpose is to provide the unique identifier for a major whose name is to be retrieved. The function is designed to return a single value of type `text`. Upon execution, the function performs a `SELECT` operation. Specifically, it queries the table named `\"major\"`. From this table, it selects the value from the column named `\"Major_Name\"`. The selection is filtered by a `WHERE` clause, which specifies a condition: the value in the `\"Major_Code\"` column of the `\"major\"` table must be equal to the value passed into the function's `\"Major_Code\"` parameter. The result of this `SELECT` query, which is expected to be a single `text` value representing the major's name, is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_major_name_by_code(\"Major_Code\" integer)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT \"Major_Name\" FROM \"major\" WHERE \"major\".\"Major_Code\" = get_major_name_by_code.\"Major_Code\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT get_major_name_by_code(1054);",
      "SELECT get_major_name_by_code(1053);",
      "SELECT get_major_name_by_code(1154);",
      "SELECT get_major_name_by_code(9999);",
      "SELECT get_major_name_by_code(1000);"
    ],
    "summary": "Create a PL/pgSQL function named `get_major_name_by_code` that takes an integer parameter `Major_Code` and returns the `Major_Name` (as text) from the `major` table where the `Major_Code` column matches the input parameter.",
    "natural_language": "Hey, can you whip up a function called `get_major_name_by_code`? It should take a number for the major code and spit back the name of the major from the `major` table, but only for the one where the code matches what you gave it.",
    "id": 98
  },
  {
    "ir": "Write a PLpgSQL function named count_universities_in_conference that accepts a single input parameter named \"Home_Conference\" of type text, which represents the conference name to be matched, and returns an integer value; the function's logic consists of executing a single SQL query that performs a SELECT operation on the \"university\" table, specifically using the COUNT(*) aggregate function to calculate the total number of rows, where the condition for inclusion in the count is that the value in the \"Home_Conference\" column of the \"university\" table must be exactly equal to the value provided in the input parameter \"Home_Conference\".",
    "plsql": "CREATE OR REPLACE FUNCTION count_universities_in_conference(\"Home_Conference\" text)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM \"university\" WHERE \"university\".\"Home_Conference\" = $1);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT count_universities_in_conference('CCIW');",
      "SELECT count_universities_in_conference('Northern');",
      "SELECT count_universities_in_conference('Midwest');",
      "SELECT count_universities_in_conference('Big Ten');",
      "SELECT count_universities_in_conference('SEC');"
    ],
    "summary": "Create a PL/pgSQL function named `count_universities_in_conference` that takes a text parameter `Home_Conference` and returns an integer count of rows from the `university` table where the `Home_Conference` column equals the input parameter.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called `count_universities_in_conference`? It should take a `Home_Conference` (as text) and just spit back a number—specifically, how many universities in the `university` table are in that same home conference.",
    "id": 99
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_max_reputation_point that takes no input parameters and returns a single integer value; within its body, it executes a SQL query that performs a SELECT operation on the \"overall_ranking\" table to retrieve the maximum value found in the column named \"Reputation_point\" using the aggregate function MAX, and this computed maximum integer value is then directly returned as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_reputation_point()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT MAX(\"Reputation_point\") FROM \"overall_ranking\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT get_max_reputation_point();"
    ],
    "summary": "Create a PL/pgSQL function named `get_max_reputation_point` with no parameters that returns an integer. The function should return the maximum value from the `Reputation_point` column in the `overall_ranking` table.",
    "natural_language": "Please construct a PL/pgSQL function, designated as `get_max_reputation_point`, which accepts no parameters and yields an integer as its return value. The function's logic must retrieve and return the highest numerical value present in the `Reputation_point` column of the `overall_ranking` table.",
    "id": 100
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_ship_type_by_speed` that accepts a single input parameter named `\"Speed_knots\"`, which is of the `integer` data type. This function is designed to determine and return a textual description of a ship's type based on its speed. The function's logic involves a conditional evaluation: it first checks if the value provided for the `\"Speed_knots\"` parameter is strictly greater than the integer literal `24`. If this condition evaluates to `TRUE`, the function immediately returns the string literal `'Fast Ship'` as its output, which is of the `text` data type. If the initial condition (`\"Speed_knots\" > 24`) evaluates to `FALSE` (meaning `\"Speed_knots\"` is less than or equal to `24`), the function then proceeds to the `ELSE` block and returns the string literal `'Standard Ship'` as its output, also of the `text` data type. The function does not interact with any database tables, perform any data manipulation operations (inserts, updates, deletes), or call any other functions.",
    "plsql": "CREATE OR REPLACE FUNCTION get_ship_type_by_speed(\"Speed_knots\" integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF \"Speed_knots\" > 24 THEN\n        RETURN 'Fast Ship';\n    ELSE\n        RETURN 'Standard Ship';\n    END IF;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_ship_type_by_speed(25);",
      "SELECT get_ship_type_by_speed(23);",
      "SELECT get_ship_type_by_speed(24);",
      "SELECT get_ship_type_by_speed(30);",
      "SELECT get_ship_type_by_speed(20);"
    ],
    "summary": "Create a PL/pgSQL function named `get_ship_type_by_speed` that takes an integer parameter `Speed_knots` and returns a text value. Return 'Fast Ship' if the speed is greater than 24, otherwise return 'Standard Ship'.",
    "natural_language": "What PL/pgSQL function, named `get_ship_type_by_speed`, should be created to take an integer parameter `Speed_knots` and return a text value of 'Fast Ship' if the speed is greater than 24, otherwise returning 'Standard Ship'?",
    "id": 101
  },
  {
    "ir": "Write a PLpgSQL function named get_mission_location_by_code that accepts a single parameter, \"Code\", of type text, which represents a mission code. The function returns a text value. Within the function, a conditional statement checks if the provided \"Code\" is equal to the string 'VMV-1'. If this condition is true, the function executes a SELECT query to retrieve the \"Location\" column from the \"mission\" table where the \"Code\" column in the \"mission\" table matches the input parameter \"Code\". The result of this query is returned as the function's output. If the condition is false, meaning the \"Code\" does not equal 'VMV-1', the function returns the string 'Unknown Location'. The function uses PLpgSQL as its language and is designed to handle only the specific mission code 'VMV-1', providing a location from the database for this code or a default message for any other code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mission_location_by_code(\"Code\" text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF \"Code\" = 'VMV-1' THEN\n        RETURN (SELECT \"Location\" FROM \"mission\" WHERE \"mission\".\"Code\" = $1);\n    ELSE\n        RETURN 'Unknown Location';\n    END IF;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_mission_location_by_code('VMV-1');",
      "SELECT get_mission_location_by_code('VMV-2');",
      "SELECT get_mission_location_by_code('VMV-3');",
      "SELECT get_mission_location_by_code('UNKNOWN');"
    ],
    "summary": "Create a function named get_mission_location_by_code that takes a mission code. If the code is 'VMV-1', return the corresponding location from the mission table. For any other code, return 'Unknown Location'.",
    "natural_language": "Create a function called get_mission_location_by_code which is designed to accept a specific mission code as its input parameter. In the detailed scenario where the provided mission code precisely matches the value 'VMV-1', the function should then retrieve and return the exact associated location from the mission database table. However, for any other mission code that is supplied, the function must comprehensively handle this by returning the descriptive string 'Unknown Location'.",
    "id": 102
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_customer_total_payments that accepts a single input parameter p_customer_id of type bigint, which is used to identify a specific customer, and returns a value of type double precision; the function's body executes a single SQL query that selects from the table named \"Customer_Payments\", applying a filter condition where the column customer_id must exactly equal the provided input parameter p_customer_id, and within that filtered result set, it calculates the sum of all values in the amount_payment column; the COALESCE function is then applied to this sum result to handle cases where the query returns a NULL value—such as when no matching rows are found for the given customer_id—by converting that NULL to the numeric value 0; this final computed result, which represents the total sum of payment amounts for the specified customer or zero if no payments exist, is immediately returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_total_payments(p_customer_id bigint)\nRETURNS double precision AS $$\nBEGIN\n    RETURN (SELECT COALESCE(SUM(amount_payment), 0) FROM \"Customer_Payments\" WHERE customer_id = p_customer_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Addresses",
      "Customer_Payments",
      "Customers",
      "Lessons",
      "Staff",
      "Vehicles"
    ],
    "call_sqls": [
      "SELECT get_customer_total_payments(11);",
      "SELECT get_customer_total_payments(2);",
      "SELECT get_customer_total_payments(14);",
      "SELECT get_customer_total_payments(1);",
      "SELECT get_customer_total_payments(3);"
    ],
    "summary": "Create a function named get_customer_total_payments that takes a customer ID. Return the sum of all payment amounts for that customer from the Customer_Payments table, or 0 if no payments are found.",
    "natural_language": "Define a function designated as 'get_customer_total_payments' that accepts a customer ID as its input parameter. The function shall compute and return the aggregate sum of all payment amounts associated with the specified customer, as recorded in the Customer_Payments table. In the event that no corresponding payments are located, the function must return a value of zero.",
    "id": 103
  },
  {
    "ir": "Write a PLpgSQL function named calculate_lesson_revenue that accepts a single parameter p_staff_id of type bigint, which represents the identifier of a staff member. The function returns a value of type double precision, which is the calculated revenue from lessons associated with the specified staff member. Within the function, a SELECT statement is executed to retrieve the sum of the price column from the Lessons table, where the staff_id column matches the provided p_staff_id parameter and the lesson_status_code column does not equal 'Cancelled'. The COALESCE function is used to ensure that if the sum of prices is NULL, a default value of 0 is returned instead. The result of this SELECT statement is returned as the output of the function. The function is defined using the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_lesson_revenue(p_staff_id bigint)\nRETURNS double precision AS $$\nBEGIN\n    RETURN (SELECT COALESCE(SUM(price), 0) FROM \"Lessons\" WHERE staff_id = p_staff_id AND lesson_status_code != 'Cancelled');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Addresses",
      "Customer_Payments",
      "Customers",
      "Lessons",
      "Staff",
      "Vehicles"
    ],
    "call_sqls": [
      "SELECT calculate_lesson_revenue(1);",
      "SELECT calculate_lesson_revenue(8);",
      "SELECT calculate_lesson_revenue(14);",
      "SELECT calculate_lesson_revenue(11);",
      "SELECT calculate_lesson_revenue(2);"
    ],
    "summary": "Create a function named calculate_lesson_revenue that takes a staff ID. Return the sum of prices for all lessons assigned to that staff member where the status is not 'Cancelled', or 0 if none exist.",
    "natural_language": "Construct a function called calculate_lesson_revenue which accepts a specific staff identifier as its input. This function should meticulously compute and deliver the total sum of prices from every single lesson that has been assigned to the designated staff member, but only for those lessons whose current status is explicitly not marked as 'Cancelled'. In the event that no such qualifying lessons are found for the provided staff ID, the function must gracefully return a value of zero.",
    "id": 104
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_full_name` that accepts a single input parameter, `p_customer_id`, which is of data type `bigint`. This function is designed to return a single value of data type `text`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves data from the table named `\"Customers\"`. Within this `SELECT` statement, the function concatenates two column values: `first_name` and `last_name`. A single space character (`' '`) is inserted between the `first_name` and `last_name` values during this concatenation. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `\"Customers\"` table. This `WHERE` clause specifies that only rows where the value in the `customer_id` column is equal to the value provided by the input parameter `p_customer_id` should be considered. The concatenated full name resulting from this `SELECT` query is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_full_name(p_customer_id bigint)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT CONCAT(first_name, ' ', last_name) FROM \"Customers\" WHERE customer_id = p_customer_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Addresses",
      "Customer_Payments",
      "Customers",
      "Lessons",
      "Staff",
      "Vehicles"
    ],
    "call_sqls": [
      "SELECT get_customer_full_name(1);",
      "SELECT get_customer_full_name(2);",
      "SELECT get_customer_full_name(3);",
      "SELECT get_customer_full_name(11);",
      "SELECT get_customer_full_name(14);"
    ],
    "summary": "Create a function named get_customer_full_name that takes a customer_id (bigint) and returns the customer's full name (text) by concatenating first_name and last_name with a space from the Customers table.",
    "natural_language": "Function get_customer_full_name: takes customer_id (bigint), returns concatenated first_name and last_name from Customers.",
    "id": 105
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_school_enrollment` that accepts two input parameters: `school_id_input` of type `INTEGER` and `denomination_input` of type `TEXT`. This function is designed to return a single value of type `REAL`. Upon execution, the function declares a local variable named `school_enrollment` of type `REAL`. The core operation involves executing a `SELECT` statement to retrieve the value from the `\"Enrollment\"` column. This selection is performed on the `school` table. The `WHERE` clause of the `SELECT` statement applies two conditions: first, it filters rows where the value in the `\"School_ID\"` column is equal to the value provided by the `school_id_input` parameter; second, it further filters these rows where the value in the `\"Denomination\"` column is equal to the value provided by the `denomination_input` parameter. The single value retrieved by this `SELECT` statement is then assigned to the `school_enrollment` local variable. Finally, the function returns the value stored in the `school_enrollment` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_enrollment(school_id_input INTEGER, denomination_input TEXT)\nRETURNS REAL\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    school_enrollment REAL;\nBEGIN\n    SELECT \"Enrollment\"\n    INTO school_enrollment\n    FROM school\n    WHERE \"School_ID\" = school_id_input AND \"Denomination\" = denomination_input;\n    \n    RETURN school_enrollment;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "school",
      "school_details"
    ],
    "call_sqls": [
      "SELECT get_school_enrollment(1, 'Catholic');",
      "SELECT get_school_enrollment(2, 'Anglican');",
      "SELECT get_school_enrollment(3, 'Anglican');",
      "SELECT get_school_enrollment(1, 'Anglican');",
      "SELECT get_school_enrollment(2, 'Catholic');"
    ],
    "summary": "Create a function named get_school_enrollment that takes a school_id (integer) and a denomination (text) and returns the enrollment value (real) from the school table for the matching record.",
    "natural_language": "Please construct a function designated as 'get_school_enrollment'. This function shall accept two parameters: a school identifier of integer type and a denomination of text type. Its purpose is to retrieve and return the enrollment figure, represented as a real number, from the school table corresponding to the specified criteria.",
    "id": 106
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named process_complaint_by_priority that accepts a single input parameter p_complaint_id of type bigint, which represents the unique identifier of a complaint record, and returns a text value. The function begins by declaring three local variables: v_days_open as integer, v_complaint_type as text, and v_result as text. It then executes a SELECT query on the \"Complaints\" table to retrieve two specific column values for the row where the complaint_id column matches the provided p_complaint_id parameter. The query uses the EXTRACT function with the 'days' argument to calculate the number of days between the current timestamp (obtained via the now() function) and the date_complaint_raised column, storing this calculated integer into v_days_open. It also retrieves the complaint_type_code column value, storing it into v_complaint_type. Following this data retrieval, the function employs a series of conditional IF-ELSIF-ELSE statements to assign a priority label to the v_result variable based on the values of v_complaint_type and v_days_open. If v_complaint_type equals the exact string 'Product Failure' and v_days_open is greater than 30, then v_result is set to 'Critical'. Otherwise, if v_complaint_type equals the exact string 'Product Unusable' and v_days_open is greater than 15, then v_result is set to 'High'. If neither of the previous type-specific conditions are met, the function checks if v_days_open is greater than 7, and if so, sets v_result to 'Medium'. If none of the preceding conditions are true, v_result is set to 'Low'. Finally, the function returns the value stored in the v_result variable.",
    "plsql": "CREATE OR REPLACE FUNCTION process_complaint_by_priority(p_complaint_id bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_days_open integer;\n    v_complaint_type text;\n    v_result text;\nBEGIN\n    SELECT EXTRACT(days FROM now() - date_complaint_raised), complaint_type_code\n    INTO v_days_open, v_complaint_type\n    FROM \"Complaints\"\n    WHERE complaint_id = p_complaint_id;\n    \n    IF v_complaint_type = 'Product Failure' AND v_days_open > 30 THEN\n        v_result := 'Critical';\n    ELSIF v_complaint_type = 'Product Unusable' AND v_days_open > 15 THEN\n        v_result := 'High';\n    ELSIF v_days_open > 7 THEN\n        v_result := 'Medium';\n    ELSE\n        v_result := 'Low';\n    END IF;\n    \n    RETURN v_result;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "SELECT process_complaint_by_priority(1);",
      "SELECT process_complaint_by_priority(2);",
      "SELECT process_complaint_by_priority(3);",
      "SELECT process_complaint_by_priority(100);",
      "SELECT process_complaint_by_priority(complaint_id) FROM \"Complaints\" WHERE complaint_status_code = 'New' LIMIT 1;"
    ],
    "summary": "Create a function named process_complaint_by_priority that takes a complaint_id (bigint) and returns a priority label (text). It calculates the days the complaint has been open and checks its type. Priority is 'Critical' for 'Product Failure' open >30 days, 'High' for 'Product Unusable' open >15 days, 'Medium' if open >7 days, otherwise 'Low'.",
    "natural_language": "Make a function process_complaint_by_priority that returns a text label for a given complaint_id. Assign 'Critical' for 'Product Failure' over 30 days old, 'High' for 'Product Unusable' over 15 days, 'Medium' if over 7 days, else 'Low'.",
    "id": 107
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_staff_performance_rank that accepts a single input parameter p_staff_id of type bigint, representing the unique identifier of a staff member, and returns a bigint value representing a performance rank. The function begins by declaring three local variables: v_closed_count as integer, v_avg_resolution_days as numeric, and v_rank as bigint. It then executes a SELECT statement on the \"Complaints\" table to compute two metrics for the specified staff member. The SELECT statement filters rows where the staff_id column equals the input parameter p_staff_id. For the filtered rows, it calculates the count of complaints where the complaint_status_code column is exactly 'Closed' using a CASE expression that yields 1 for 'Closed' status and NULL otherwise, storing this count into v_closed_count. Simultaneously, it calculates the average resolution time for closed complaints by using another CASE expression that, only when complaint_status_code is 'Closed', computes the difference in days between the date_complaint_closed column and the date_complaint_raised column using the EXTRACT(days FROM ...) function, storing this average into v_avg_resolution_days. Following the data retrieval, the function uses a conditional IF-ELSIF-ELSE block to assign a performance rank based on the computed metrics. If v_closed_count is greater than 20 and v_avg_resolution_days is less than 5, the v_rank is set to 1. Otherwise, if v_closed_count is greater than 10 and v_avg_resolution_days is less than 10, v_rank is set to 2. Otherwise, if v_closed_count is greater than 5 and v_avg_resolution_days is less than 15, v_rank is set to 3. If none of these conditions are met, v_rank is set to 4. Finally, the function returns the value of v_rank.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_performance_rank(p_staff_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_closed_count integer;\n    v_avg_resolution_days numeric;\n    v_rank bigint;\nBEGIN\n    SELECT COUNT(CASE WHEN complaint_status_code = 'Closed' THEN 1 END),\n           AVG(CASE WHEN complaint_status_code = 'Closed' THEN EXTRACT(days FROM date_complaint_closed - date_complaint_raised) END)\n    INTO v_closed_count, v_avg_resolution_days\n    FROM \"Complaints\"\n    WHERE staff_id = p_staff_id;\n    \n    IF v_closed_count > 20 AND v_avg_resolution_days < 5 THEN\n        v_rank := 1;\n    ELSIF v_closed_count > 10 AND v_avg_resolution_days < 10 THEN\n        v_rank := 2;\n    ELSIF v_closed_count > 5 AND v_avg_resolution_days < 15 THEN\n        v_rank := 3;\n    ELSE\n        v_rank := 4;\n    END IF;\n    \n    RETURN v_rank;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "SELECT get_staff_performance_rank(114);",
      "SELECT get_staff_performance_rank(120);",
      "SELECT get_staff_performance_rank(115);",
      "SELECT get_staff_performance_rank(116);",
      "SELECT get_staff_performance_rank(117);"
    ],
    "summary": "Create a function named get_staff_performance_rank that takes a staff_id (bigint) and returns a performance rank (bigint). It calculates the number of closed complaints and the average resolution days for the staff member. Rank is 1 if >20 closed and avg <5 days, 2 if >10 closed and avg <10 days, 3 if >5 closed and avg <15 days, otherwise 4.",
    "natural_language": "What is the performance rank for a staff member with a given ID, based on the number of complaints they have closed and their average resolution time?",
    "id": 108
  },
  {
    "ir": "Write a PLpgSQL function named calculate_product_complaint_score that accepts a single parameter p_product_id of type bigint, which represents the unique identifier of a product. The function calculates a numeric score based on the complaints associated with the specified product. It begins by declaring three local variables: v_total_complaints and v_failure_complaints of type integer, and v_score of type numeric. The function executes a SELECT statement on the Complaints table to count the total number of complaints and the number of complaints with a complaint_type_code of 'Product Failure' for the given product_id, storing these counts in v_total_complaints and v_failure_complaints respectively. The function then evaluates several conditional statements to determine the value of v_score. If there are no complaints (v_total_complaints equals 0), v_score is set to 100.0. If the number of failure complaints exceeds 50% of total complaints and there are more than 10 total complaints, v_score is set to 25.0. If the number of failure complaints exceeds 30% of total complaints and there are more than 5 total complaints, v_score is set to 50.0. Otherwise, v_score is set to 75.0. Finally, the function returns the calculated v_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_product_complaint_score(p_product_id bigint)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_complaints integer;\n    v_failure_complaints integer;\n    v_score numeric;\nBEGIN\n    SELECT COUNT(*), COUNT(CASE WHEN \"complaint_type_code\" = 'Product Failure' THEN 1 END)\n    INTO v_total_complaints, v_failure_complaints\n    FROM \"Complaints\"\n    WHERE \"product_id\" = p_product_id;\n    \n    IF v_total_complaints = 0 THEN\n        v_score := 100.0;\n    ELSIF v_failure_complaints > v_total_complaints * 0.5 AND v_total_complaints > 10 THEN\n        v_score := 25.0;\n    ELSIF v_failure_complaints > v_total_complaints * 0.3 AND v_total_complaints > 5 THEN\n        v_score := 50.0;\n    ELSE\n        v_score := 75.0;\n    END IF;\n    \n    RETURN v_score;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "SELECT calculate_product_complaint_score(117);",
      "SELECT calculate_product_complaint_score(118);",
      "SELECT calculate_product_complaint_score(119);",
      "SELECT calculate_product_complaint_score(1);",
      "SELECT calculate_product_complaint_score(2);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_product_complaint_score` that takes a product ID (`bigint`) and returns a numeric score. The function should: 1) Count the total complaints and the 'Product Failure' complaints for the product. 2) Calculate a score: 100.0 if there are no complaints; 25.0 if failure complaints > 50% and total > 10; 50.0 if failure complaints > 30% and total > 5; otherwise 75.0. 3) Return the calculated score.",
    "natural_language": "Write a function called `calculate_product_complaint_score` that gives back a number for a product. It should look at how many complaints there are in total and how many seem to be about the product not working right. The score should be high if there aren't many complaints, but lower if there are quite a few complaints and a good portion of them are about failures. For instance, if there are no complaints at all, give the best score. If there are a bunch of complaints and more than half are about failures, give a much lower score. If there's a fair number of complaints and over a certain part are failures, give a middling score. Otherwise, just give a decent score. The function needs the product's ID to work.",
    "id": 109
  },
  {
    "ir": "Write a PLpgSQL function that takes a parameter p_master_id of type bigint and returns an integer representing the count of distinct source_system_code values from the CMI_Cross_References table where the master_customer_id column matches the provided p_master_id. The function begins by declaring a local variable v_count of type integer to store the result of the query. It then executes a SELECT statement that counts the number of unique source_system_code entries in the CMI_Cross_References table, filtering the rows based on the condition that the master_customer_id column is equal to the input parameter p_master_id. The result of this count is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the number of distinct source systems associated with the specified master customer ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_system_count(p_master_id bigint)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(DISTINCT source_system_code) INTO v_count\n    FROM \"CMI_Cross_References\"\n    WHERE master_customer_id = p_master_id;\n    RETURN v_count;\nEND;\n$$;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "SELECT get_customer_system_count(1);",
      "SELECT get_customer_system_count(2);",
      "SELECT get_customer_system_count(3);",
      "SELECT get_customer_system_count(4);",
      "SELECT get_customer_system_count(5);"
    ],
    "summary": "Create a PL/pgSQL function that takes a master customer ID (`bigint`) and returns an integer count. The function should count and return the number of distinct `source_system_code` values from the `CMI_Cross_References` table where the `master_customer_id` matches the input parameter.",
    "natural_language": "Develop a comprehensive PL/pgSQL function which accepts a single input parameter, specifically a master customer ID of the type bigint, and meticulously calculates an integer count as its return value. This function's essential purpose is to thoroughly examine the `CMI_Cross_References` table, carefully identifying and tallying every unique entry within the `source_system_code` column, but only for those precise records where the `master_customer_id` field exactly corresponds to the provided input argument.",
    "id": 110
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_total_debt_accounts` that accepts a single input parameter, `p_master_id`, which is of type `bigint` and represents a master customer identifier. This function is designed to return an `integer` value representing the total count of debt accounts associated with the specified master customer.\n\nUpon execution, the function declares a local variable named `v_total` of type `integer` to store the calculated sum of debt accounts. The core operation involves a single `SELECT` statement that calculates the sum of counts from four distinct categories of debt accounts. Each category's count is determined by performing a `COUNT(*)` operation on a specific debt-related table, joined with the `CMI_Cross_References` table.\n\nSpecifically, the function performs the following four sub-queries and sums their results:\n1. It counts the number of records in the `\"Benefits_Overpayments\"` table. This count is filtered by joining `\"Benefits_Overpayments\"` (aliased as `bo`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `bo.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n2. It counts the number of records in the `\"Business_Rates\"` table. This count is filtered by joining `\"Business_Rates\"` (aliased as `br`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `br.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n3. It counts the number of records in the `\"Council_Tax\"` table. This count is filtered by joining `\"Council_Tax\"` (aliased as `ct`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `ct.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n4. It counts the number of records in the `\"Rent_Arrears\"` table. This count is filtered by joining `\"Rent_Arrears\"` (aliased as `ra`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `ra.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n\nThe sum of these four individual counts is then assigned to the `v_total` variable. Finally, the function returns the value stored in `v_total` as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_debt_accounts(p_master_id bigint)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total integer;\nBEGIN\n    SELECT (SELECT COUNT(*) FROM \"Benefits_Overpayments\" bo JOIN \"CMI_Cross_References\" cr ON bo.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id) +\n           (SELECT COUNT(*) FROM \"Business_Rates\" br JOIN \"CMI_Cross_References\" cr ON br.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id) +\n           (SELECT COUNT(*) FROM \"Council_Tax\" ct JOIN \"CMI_Cross_References\" cr ON ct.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id) +\n           (SELECT COUNT(*) FROM \"Rent_Arrears\" ra JOIN \"CMI_Cross_References\" cr ON ra.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id)\n    INTO v_total;\n    RETURN v_total;\nEND;\n$$;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "SELECT calculate_total_debt_accounts(1);",
      "SELECT calculate_total_debt_accounts(2);",
      "SELECT calculate_total_debt_accounts(3);",
      "SELECT calculate_total_debt_accounts(4);",
      "SELECT calculate_total_debt_accounts(5);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_total_debt_accounts` that takes a master customer ID (`bigint`) and returns an integer total. The function should sum the counts of records from four debt tables (`Benefits_Overpayments`, `Business_Rates`, `Council_Tax`, `Rent_Arrears`) where each record is linked to the provided master ID via the `CMI_Cross_References` table, and return this total.",
    "natural_language": "Write a function that gives us a rough total number of debt-related entries for a certain customer. It should look through a few different debt tables—like for overpayments, business charges, local taxes, and rent—and add up how many records seem to be connected to that person via a reference table. Just return that overall count.",
    "id": 111
  },
  {
    "ir": "Write a PLpgSQL function that takes a parameter p_system_code of type text and returns a text value. The function is designed to retrieve customer details from a database. It declares a local variable v_customer_details of type text to store the result of a query. The function performs a SELECT operation to fetch the cmi_details column from the Customer_Master_Index table, which is aliased as cmi. This table is joined with the CMI_Cross_References table, aliased as cr, on the condition that the master_customer_id column in both tables matches. The WHERE clause filters the results to include only those rows where the source_system_code column in the CMI_Cross_References table equals the input parameter p_system_code. The query is limited to return only the first matching row using the LIMIT 1 clause. The result of the query is stored in the v_customer_details variable. The function then returns the value of v_customer_details, using the COALESCE function to return the string 'No customer found' if v_customer_details is null, indicating that no matching customer was found for the given system code.",
    "plsql": "CREATE OR REPLACE FUNCTION find_customer_by_system(p_system_code text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_customer_details text;\nBEGIN\n    SELECT cmi.\"cmi_details\" INTO v_customer_details\n    FROM \"Customer_Master_Index\" cmi\n    JOIN \"CMI_Cross_References\" cr ON cmi.\"master_customer_id\" = cr.\"master_customer_id\"\n    WHERE cr.\"source_system_code\" = p_system_code\n    LIMIT 1;\n    RETURN COALESCE(v_customer_details, 'No customer found');\nEND;\n$$;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "SELECT find_customer_by_system('Rent');",
      "SELECT find_customer_by_system('Parking');"
    ],
    "summary": "Create a function that accepts a text p_system_code and returns text. Retrieve the cmi_details from the Customer_Master_Index table by joining it with the CMI_Cross_References table where the master_customer_id matches and the source_system_code equals p_system_code. Limit the result to one row. Return the customer details or 'No customer found' if none exist.",
    "natural_language": "Write a function that takes a system code as input and gives back some text. It should look up customer information by connecting the main customer table with the references table where the customer IDs align and the source system roughly matches the provided code. Just fetch one record, whatever seems like the most relevant match. If it finds something, return those customer details; otherwise, just say no customer was found.",
    "id": 112
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_books_by_type_and_min_pages that returns a result set with three columns labeled \"Title\" (TEXT), \"Pages\" (INTEGER), and \"Chapters\" (INTEGER), and accepts three input parameters: a TEXT parameter named book_type, an INTEGER parameter named min_pages, and an INTEGER parameter named max_chapters; the function's logic begins by executing a RETURN QUERY statement to return the results of a SELECT query that retrieves the \"Title\", \"Pages\", and \"Chapters\" columns from the table named \"book\" (aliased as b) where three conditions are simultaneously met: the value in the column \"Type\" from the \"book\" table must be exactly equal to the input parameter book_type, the value in the column \"Pages\" from the \"book\" table must be greater than or equal to the input parameter min_pages, and the value in the column \"Chapters\" from the \"book\" table must be less than or equal to the input parameter max_chapters.",
    "plsql": "CREATE OR REPLACE FUNCTION get_books_by_type_and_min_pages(book_type TEXT, min_pages INTEGER, max_chapters INTEGER)\nRETURNS TABLE (\"Title\" TEXT, \"Pages\" INTEGER, \"Chapters\" INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT b.\"Title\", b.\"Pages\", b.\"Chapters\"\n    FROM \"book\" AS b\n    WHERE b.\"Type\" = book_type AND b.\"Pages\" >= min_pages AND b.\"Chapters\" <= max_chapters;\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT * FROM get_books_by_type_and_min_pages('Novel', 500, 80);",
      "SELECT * FROM get_books_by_type_and_min_pages('Novel', 700, 75);",
      "SELECT * FROM get_books_by_type_and_min_pages('Fiction', 300, 100);",
      "SELECT * FROM get_books_by_type_and_min_pages('Novel', 1000, 90);",
      "SELECT * FROM get_books_by_type_and_min_pages('Science', 200, 50);"
    ],
    "summary": "Create a function named get_books_by_type_and_min_pages that returns a table with Title (TEXT), Pages (INTEGER), and Chapters (INTEGER). It accepts a text book_type, an integer min_pages, and an integer max_chapters. Return all books where the Type equals book_type, Pages is greater than or equal to min_pages, and Chapters is less than or equal to max_chapters.",
    "natural_language": "Please construct a function designated as 'get_books_by_type_and_min_pages'. This function shall yield a result set comprising the columns Title (of TEXT data type), Pages (INTEGER), and Chapters (INTEGER). It is required to accept the following parameters: a text value for 'book_type', an integer for 'min_pages', and an integer for 'max_chapters'. The function must return all book records for which the 'Type' attribute matches the provided 'book_type', the 'Pages' value is greater than or equal to the specified 'min_pages', and the 'Chapters' value is less than or equal to the supplied 'max_chapters'.",
    "id": 113
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `categorize_protein_by_divergence` that returns a table with two columns: `protein_name` of type `text` and `divergence_category` of type `text`. This function does not accept any input parameters. The function's core operation is to execute a `SELECT` query that retrieves data from the database. Specifically, it selects the `protein_name` column from the `protein` table, aliased as `p`. It also calculates a `divergence_category` based on the value of the `divergence_from_human_lineage` column from the `protein` table. This categorization is performed using a `CASE` statement: if `divergence_from_human_lineage` is less than 400, the category is 'Recent'; if `divergence_from_human_lineage` is between 400 (inclusive) and 600 (inclusive), the category is 'Moderate'; if `divergence_from_human_lineage` is between 600 (inclusive) and 800 (inclusive), the category is 'Ancient'; for all other cases (i.e., `divergence_from_human_lineage` is greater than 800), the category is 'Very Ancient'. The `SELECT` query joins the `protein` table (aliased as `p`) with the `Institution` table (aliased as `i`) using an inner join condition where the `Institution_id` column from the `protein` table matches the `Institution_id` column from the `Institution` table. The results are filtered by a `WHERE` clause, which includes only those rows where the `Type` column in the `Institution` table is equal to the string literal 'Private'. The function then returns the results of this `SELECT` query as its output table.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_protein_by_divergence()\nRETURNS TABLE(protein_name text, divergence_category text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT p.\"protein_name\",\n           CASE\n               WHEN p.\"divergence_from_human_lineage\" < 400 THEN 'Recent'\n               WHEN p.\"divergence_from_human_lineage\" BETWEEN 400 AND 600 THEN 'Moderate'\n               WHEN p.\"divergence_from_human_lineage\" BETWEEN 600 AND 800 THEN 'Ancient'\n               ELSE 'Very Ancient'\n           END\n    FROM \"protein\" p\n    JOIN \"Institution\" i ON p.\"Institution_id\" = i.\"Institution_id\"\n    WHERE i.\"Type\" = 'Private';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "SELECT * FROM categorize_protein_by_divergence();",
      "SELECT protein_name, divergence_category FROM categorize_protein_by_divergence();",
      "SELECT * FROM categorize_protein_by_divergence() WHERE divergence_category = 'Recent';",
      "SELECT protein_name FROM categorize_protein_by_divergence() WHERE divergence_category = 'Ancient';",
      "SELECT count(*) FROM categorize_protein_by_divergence() WHERE divergence_category = 'Moderate';"
    ],
    "summary": "Create a function named categorize_protein_by_divergence that returns a table with protein_name (text) and divergence_category (text). It takes no parameters. Select protein_name and categorize divergence_from_human_lineage as 'Recent' (<400), 'Moderate' (400-600), 'Ancient' (600-800), or 'Very Ancient' (>800). Join the protein table with the Institution table where Institution_id matches and Institution.Type is 'Private'.",
    "natural_language": "List all proteins by categorizing their divergence from the human lineage. Show the protein name and a category of 'Recent' for divergence less than 400, 'Moderate' for 400 to 600, 'Ancient' for 600 to 800, and 'Very Ancient' for greater than 800. Only include proteins from private institutions by joining the protein and institution tables where their IDs match.",
    "id": 114
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_institution_protein_stats that returns a table with three columns: institution_name of type text, avg_divergence of type numeric, and max_length of type real. The function begins execution by returning the result set of a query. This query performs a SELECT operation on the Institution table, aliased as i, and left joins it with the protein table, aliased as p, using the condition that the Institution_id column from the Institution table matches the Institution_id column from the protein table. The SELECT clause retrieves three computed values: the Institution column from the Institution table, the average of the divergence_from_human_lineage column from the protein table cast to the numeric data type, and the maximum value of the sequence_length column from the protein table. The results are grouped by the combination of the Institution_id column and the Institution column from the Institution table. A HAVING clause filters the grouped results to include only those groups where the count of the accession_number column from the protein table is greater than zero, ensuring that only institutions with at least one associated protein record are included in the final result set.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_institution_protein_stats()\nRETURNS TABLE(institution_name text, avg_divergence numeric, max_length real) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT i.\"Institution\",\n           AVG(p.\"divergence_from_human_lineage\")::numeric,\n           MAX(p.\"sequence_length\")\n    FROM \"Institution\" i\n    LEFT JOIN \"protein\" p ON i.\"Institution_id\" = p.\"Institution_id\"\n    GROUP BY i.\"Institution_id\", i.\"Institution\"\n    HAVING COUNT(p.\"accession_number\") > 0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_institution_protein_stats();",
      "SELECT institution_name, avg_divergence FROM calculate_institution_protein_stats() WHERE avg_divergence > 500;",
      "SELECT * FROM calculate_institution_protein_stats() ORDER BY max_length DESC;",
      "SELECT institution_name, max_length FROM calculate_institution_protein_stats() WHERE institution_name LIKE '%University%';",
      "SELECT institution_name, avg_divergence::real, max_length FROM calculate_institution_protein_stats() WHERE max_length > 2000;"
    ],
    "summary": "Create a PostgreSQL function named calculate_institution_protein_stats that returns a table with columns institution_name (text), avg_divergence (numeric), and max_length (real). The function should return a query that left joins the Institution and protein tables on institution_id. Select the institution name, the average of divergence_from_human_lineage (cast to numeric), and the maximum sequence_length. Group by institution_id and name, and only include groups where the count of protein accession numbers is greater than zero.",
    "natural_language": "What are the institution name, average divergence (cast to numeric), and maximum sequence length for each institution, including only those with at least one protein accession, by left joining the Institution and protein tables on institution_id?",
    "id": 115
  },
  {
    "ir": "Write a PLpgSQL function that returns a table with columns building_name of type text, institution_count of type bigint, and status of type text, which analyzes the relationship between buildings and institutions. The function performs a SELECT operation on the building table, aliased as b, and the Institution table, aliased as i, using a LEFT JOIN condition where the building_id column in the building table matches the building_id column in the Institution table. It groups the results by the building_id and Name columns from the building table. For each building, it calculates the count of Institution_id from the Institution table, casting the result to bigint, and determines the status based on the count: 'Unused' if the count is 0, 'Single User' if the count is 1, 'Shared' if the count is 2, and 'Highly Shared' for counts greater than 2. The results are ordered in descending order based on the count of Institution_id.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_building_institution_relationship()\nRETURNS TABLE(building_name text, institution_count bigint, status text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT b.\"Name\",\n           COUNT(i.\"Institution_id\")::bigint,\n           CASE\n               WHEN COUNT(i.\"Institution_id\") = 0 THEN 'Unused'\n               WHEN COUNT(i.\"Institution_id\") = 1 THEN 'Single User'\n               WHEN COUNT(i.\"Institution_id\") = 2 THEN 'Shared'\n               ELSE 'Highly Shared'\n           END\n    FROM \"building\" b\n    LEFT JOIN \"Institution\" i ON b.\"building_id\" = i.\"building_id\"\n    GROUP BY b.\"building_id\", b.\"Name\"\n    ORDER BY COUNT(i.\"Institution_id\") DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_building_institution_relationship();",
      "SELECT building_name, institution_count FROM analyze_building_institution_relationship() WHERE status = 'Highly Shared';",
      "SELECT building_name, status FROM analyze_building_institution_relationship() ORDER BY building_name;",
      "SELECT * FROM analyze_building_institution_relationship() WHERE institution_count > 2;",
      "SELECT status, COUNT(*) as building_count FROM analyze_building_institution_relationship() GROUP BY status;"
    ],
    "summary": "Create a PostgreSQL function that returns a table with columns building_name (text), institution_count (bigint), and status (text). The function should query the building table, left joined with the Institution table on building_id. Group by building_id and building name. For each building, count the associated institutions. Determine the status: 'Unused' for count 0, 'Single User' for 1, 'Shared' for 2, and 'Highly Shared' for counts greater than 2. Order the results by the institution count in descending order.",
    "natural_language": "What are the building names, their associated institution counts, and statuses, determined by grouping buildings and left joining with institutions, where status is 'Unused' for zero institutions, 'Single User' for one, 'Shared' for two, and 'Highly Shared' for more than two, ordered by institution count descending?",
    "id": 116
  },
  {
    "ir": "Write a PLpgSQL function named get_delivery_summary that accepts two input parameters: p_route_id of type BIGINT, which specifies the unique identifier for a delivery route, and p_status_code of type TEXT, which indicates the status code of deliveries to be considered. The function returns two output parameters: v_total_deliveries of type INTEGER, representing the total number of deliveries matching the criteria, and v_route_name of type TEXT, which provides the name of the delivery route. The function performs a SELECT operation to retrieve the count of deliveries and the route name from the \"Order_Deliveries\" table, which contains delivery records, by joining it with the \"Delivery_Route_Locations\" table on the location_code column to associate deliveries with specific route locations. It further joins with the \"Delivery_Routes\" table on the route_id column to obtain the route name. The WHERE clause filters the results to include only those records where the route_id matches the input parameter p_route_id and the delivery_status_code matches the input parameter p_status_code. The results are grouped by the route_name to ensure accurate counting of deliveries per route, and the retrieved values are assigned to the output parameters v_total_deliveries and v_route_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_delivery_summary(p_route_id BIGINT, p_status_code TEXT, OUT v_total_deliveries INTEGER, OUT v_route_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COUNT(*), dr.route_name\n    INTO v_total_deliveries, v_route_name\n    FROM \"Order_Deliveries\" od\n    JOIN \"Delivery_Route_Locations\" drl ON od.location_code = drl.location_code\n    JOIN \"Delivery_Routes\" dr ON drl.route_id = dr.route_id\n    WHERE dr.route_id = p_route_id AND od.delivery_status_code = p_status_code\n    GROUP BY dr.route_name;\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Order_Products",
      "Actual_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Employees",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT * FROM get_delivery_summary(1, 'Ready');",
      "SELECT * FROM get_delivery_summary(2, 'On Road');",
      "SELECT * FROM get_delivery_summary(3, 'Delivered');",
      "SELECT * FROM get_delivery_summary(11, 'Ready');",
      "SELECT * FROM get_delivery_summary(7, 'On Road');"
    ],
    "summary": "Create a PostgreSQL function named get_delivery_summary that takes a route_id (BIGINT) and a status_code (TEXT) as input. It should return two output parameters: total_deliveries (INTEGER) and route_name (TEXT). The function should query the Order_Deliveries table, joined with Delivery_Route_Locations on location_code and Delivery_Routes on route_id. Filter by the input route_id and delivery_status_code. Group by route_name to get the count of deliveries and the route name, and assign these values to the output parameters.",
    "natural_language": "Write a PostgreSQL function called get_delivery_summary that needs a route_id and a status_code. It should give back a couple of outputs: total_deliveries and route_name. The function has to look at the Order_Deliveries table, connect it with some other tables on location_code and route_id. It should filter based on the provided route_id and a status that's kind of like the delivery_status_code. Group everything by the route name to figure out roughly how many deliveries there are and what the route is called, then put those results into the output parameters.",
    "id": 117
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_employee_workload that returns a table with two columns, delivery_count of type BIGINT and employee_name of type TEXT, and accepts two input parameters: p_employee_id of type BIGINT to specify a driver employee identifier and p_truck_id of type BIGINT to specify a truck identifier; the function executes a SELECT query that performs an INNER JOIN between the Order_Deliveries table (aliased as od) and the Employees table (aliased as e) by matching the driver_employee_id column from Order_Deliveries with the employee_id column from Employees, then filters the joined result set to include only rows where the driver_employee_id column equals the input parameter p_employee_id and the truck_id column equals the input parameter p_truck_id, groups the filtered rows by the employee_name column from the Employees table, and for each group calculates the count of actual_order_id values from the Order_Deliveries table, finally returning the resulting aggregated count and the corresponding employee name for the specified employee and truck combination.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_employee_workload(p_employee_id BIGINT, p_truck_id BIGINT)\nRETURNS TABLE (delivery_count BIGINT, employee_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT COUNT(od.actual_order_id), e.employee_name\n    FROM \"Order_Deliveries\" od\n    JOIN \"Employees\" e ON od.driver_employee_id = e.employee_id\n    WHERE od.driver_employee_id = p_employee_id AND od.truck_id = p_truck_id\n    GROUP BY e.employee_name;\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Order_Products",
      "Actual_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Employees",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_employee_workload(1, 2);",
      "SELECT * FROM calculate_employee_workload(4, 10);",
      "SELECT * FROM calculate_employee_workload(6, 11);",
      "SELECT * FROM calculate_employee_workload(3, 3);",
      "SELECT * FROM calculate_employee_workload(2, 1);"
    ],
    "summary": "Create a PostgreSQL function named calculate_employee_workload that returns a table with columns delivery_count (BIGINT) and employee_name (TEXT). The function accepts an employee_id and a truck_id as BIGINT parameters. It should perform an inner join between the Order_Deliveries and Employees tables on driver_employee_id and employee_id. Filter the results where the driver_employee_id matches the input employee_id and the truck_id matches the input truck_id. Group by employee_name and count the actual_order_id values for that group.",
    "natural_language": "Write a PostgreSQL function called calculate_employee_workload that gives back a table. It should have a count of deliveries and the employee's name. The function needs an employee ID and a truck ID. Join the order deliveries and employees data where the driver matches the employee. Only look at records for that specific person and that particular truck. Then, bunch the results by the employee's name and figure out how many orders they handled.",
    "id": 118
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_age that accepts a single input parameter named musical_name of type text, which represents the name of a musical, and returns a value of type numeric; the function declares a local numeric variable named avg_age, then executes a SELECT statement that calculates the average age by applying the AVG aggregate function to the age column from the actor table, which is aliased as a; this calculation is performed on rows obtained by performing an inner join between the actor table and the musical table, aliased as m, using the condition that the Musical_ID column from the actor table matches the Musical_ID column from the musical table; the join is further filtered by a WHERE clause that requires the Name column from the musical table to be exactly equal to the provided musical_name parameter; the result of the AVG calculation is stored into the local variable avg_age using the INTO clause, and finally, the function returns the value stored in the avg_age variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_age(musical_name text)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_age numeric;\nBEGIN\n    SELECT AVG(a.age) INTO avg_age\n    FROM actor a\n    JOIN musical m ON a.\"Musical_ID\" = m.\"Musical_ID\"\n    WHERE m.\"Name\" = musical_name;\n\n    RETURN avg_age;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT calculate_average_age('The Phantom of the Opera');",
      "SELECT calculate_average_age('Les Misérables');",
      "SELECT calculate_average_age('Wicked');",
      "SELECT calculate_average_age('Cats');",
      "SELECT calculate_average_age('Hamilton');"
    ],
    "summary": "Create a function named calculate_average_age that takes a musical name as text input and returns a numeric value. It calculates the average age of actors from the actor table who are associated with that specific musical by joining the actor and musical tables on Musical_ID.",
    "natural_language": "Develop a function called calculate_average_age which accepts a single text parameter representing the name of a musical. This function should meticulously compute and return a precise numeric value, specifically the average age of all actors listed in the actor table who have performed in that particular musical. This calculation is achieved by performing a detailed join between the actor and musical tables using the common Musical_ID field to correctly associate each actor with their respective production.",
    "id": 119
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `find_longest_duration_actor` that accepts a single input parameter, `musical_id_param`, of type `integer`. This function is designed to return a `text` value representing the name of an actor. The function begins by declaring two local variables: `max_years` of type `integer` and `actor_name` of type `text`. The first operation performed is a `SELECT` statement that calculates the maximum duration among actors associated with a specific musical. This `SELECT` statement queries the `actor` table. Within this query, the `SUBSTRING` function is used on the `\"Duration\"` column to extract a substring that matches the regular expression `'^[0-9]+'`, effectively isolating the numeric part at the beginning of the \"Duration\" string. The result of this `SUBSTRING` operation is then explicitly `CAST` to an `integer` data type. The `MAX` aggregate function is applied to these cast integer durations to find the highest value. This maximum duration value is then stored into the `max_years` variable. The `WHERE` clause of this `SELECT` statement filters the `actor` table records, considering only those where the `\"Musical_ID\"` column matches the value provided by the `musical_id_param` input parameter. Following this, a second `SELECT` statement is executed to retrieve the name of an actor. This `SELECT` statement queries the `actor` table and selects the value from the `\"Name\"` column. The retrieved name is then stored into the `actor_name` variable. The `WHERE` clause for this second `SELECT` statement has two conditions: first, it ensures that the `\"Musical_ID\"` column matches the `musical_id_param` input parameter, similar to the previous query. Second, it filters records where the duration, extracted and cast to an integer using `CAST(SUBSTRING(\"Duration\" FROM '^[0-9]+') AS integer)`, is exactly equal to the `max_years` value previously determined. The `LIMIT 1` clause is applied to this `SELECT` statement, ensuring that only one actor's name is returned in case multiple actors share the same maximum duration. Finally, the function concludes by returning the value stored in the `actor_name` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION find_longest_duration_actor(musical_id_param integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    max_years integer;\n    actor_name text;\nBEGIN\n    SELECT MAX(CAST(SUBSTRING(\"Duration\" FROM '^[0-9]+') AS integer)) INTO max_years\n    FROM actor\n    WHERE \"Musical_ID\" = musical_id_param;\n    \n    SELECT \"Name\" INTO actor_name\n    FROM actor\n    WHERE \"Musical_ID\" = musical_id_param \n    AND CAST(SUBSTRING(\"Duration\" FROM '^[0-9]+') AS integer) = max_years\n    LIMIT 1;\n    \n    RETURN actor_name;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT find_longest_duration_actor(1);",
      "SELECT find_longest_duration_actor(2);",
      "SELECT find_longest_duration_actor(3);",
      "SELECT find_longest_duration_actor(4);",
      "SELECT find_longest_duration_actor(5);"
    ],
    "summary": "Create a function named find_longest_duration_actor that takes a musical ID as integer input and returns the actor's name as text. It finds the maximum numeric duration from the actor table for the given musical ID, then returns the name of the first actor who has that exact duration.",
    "natural_language": "Create a function called find_longest_duration_actor that takes a musical ID number and gives back the actor's name as text. It should figure out the biggest duration value in the actor table for that specific musical, then return the name of one of the actors who has that top duration.",
    "id": 120
  },
  {
    "ir": "Write a PLpgSQL function named check_award_nomination that accepts a single integer input parameter called actor_id_param, which represents the unique identifier of an actor, and returns a boolean value; the function declares a local boolean variable named has_nomination, then executes a SELECT statement that uses the EXISTS operator to query the database: the query performs an inner join between the actor table (aliased as 'a') and the musical table (aliased as 'm') by matching the Musical_ID column from the actor table to the Musical_ID column in the musical table, and it filters the joined result set to only include rows where the Actor_ID column from the actor table equals the provided actor_id_param input and where the Result column from the musical table contains the exact string value 'Nominated'; the EXISTS operator evaluates to TRUE if at least one row satisfies these conditions, and this boolean result is assigned into the has_nomination variable via the INTO clause; finally, the function returns the value stored in the has_nomination variable.",
    "plsql": "CREATE OR REPLACE FUNCTION check_award_nomination(actor_id_param integer)\nRETURNS boolean\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    has_nomination boolean;\nBEGIN\n    SELECT EXISTS (\n        SELECT 1\n        FROM actor a\n        JOIN musical m ON a.\"Musical_ID\" = m.\"Musical_ID\"\n        WHERE a.\"Actor_ID\" = actor_id_param\n        AND m.\"Result\" = 'Nominated'\n    ) INTO has_nomination;\n    RETURN has_nomination;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT check_award_nomination(1);",
      "SELECT check_award_nomination(2);",
      "SELECT check_award_nomination(3);"
    ],
    "summary": "Create a function named check_award_nomination that takes an actor ID as integer input and returns a boolean. It checks if the specified actor is associated with any musical where the result is 'Nominated' by joining the actor and musical tables on Musical_ID.",
    "natural_language": "Does the actor with the given ID have any musical nominations? Create a function called 'check_award_nomination' that takes an actor ID and returns true or false by checking if that actor is linked to any musical with a result of 'Nominated' in the database.",
    "id": 121
  },
  {
    "ir": "Write a PLpgSQL function named get_owner_dog_count that accepts two parameters: p_owner_id of type bigint and p_size_filter of type text. The function is designed to return a bigint value representing the count of rows in the \"Dogs\" table that meet specific criteria. The function begins by declaring a local variable v_count of type bigint to store the result of the count operation. It then performs a SELECT statement to count the number of rows in the \"Dogs\" table where the owner_id column matches the value of the p_owner_id parameter and the size_code column matches the value of the p_size_filter parameter. The result of this count operation is stored in the v_count variable using the INTO clause. Finally, the function returns the value of v_count, which represents the number of dogs owned by the specified owner and matching the specified size filter. The function is written in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_owner_dog_count(p_owner_id bigint, p_size_filter text)\nRETURNS bigint AS $$\nDECLARE\n    v_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM \"Dogs\"\n    WHERE owner_id = p_owner_id\n      AND size_code = p_size_filter;\n    \n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Treatments",
      "Professionals"
    ],
    "call_sqls": [
      "SELECT get_owner_dog_count(3, 'LGE');",
      "SELECT get_owner_dog_count(11, 'MED');",
      "SELECT get_owner_dog_count(1, 'SML');",
      "SELECT get_owner_dog_count(5, 'LGE');",
      "SELECT get_owner_dog_count(10, 'MED');"
    ],
    "summary": "Create a function named get_owner_dog_count that takes an owner ID (bigint) and a size filter (text) as input, and returns a bigint count. It counts the number of dogs in the Dogs table that belong to the specified owner and match the given size code.",
    "natural_language": "Hey, can you whip up a function called get_owner_dog_count? It should take an owner's ID (as a bigint) and a dog size filter (as text). What it does is it gives back a bigint count of how many dogs in the Dogs table are owned by that specific person and are the right size.",
    "id": 122
  },
  {
    "ir": "Write a PLpgSQL function named calculate_professional_revenue that accepts two input parameters: a bigint parameter named p_prof_id representing a professional identifier and a text parameter named p_treatment_type representing a treatment type code, and returns a numeric value; within the function, a local numeric variable v_total_revenue is declared; the function executes a SELECT statement that queries the \"Treatments\" table, using the TRUNC function to round the sum of values from the cost_of_treatment column to two decimal places, and stores the result into the v_total_revenue variable; the SELECT statement includes a WHERE clause with two conditions joined by AND: the first condition filters rows where the professional_id column equals the input parameter p_prof_id, and the second condition filters rows where the treatment_type_code column equals the input parameter p_treatment_type; the function concludes by using the COALESCE function to return the value of v_total_revenue if it is not null, otherwise returning 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_professional_revenue(p_prof_id bigint, p_treatment_type text)\nRETURNS numeric AS $$\nDECLARE\n    v_total_revenue numeric;\nBEGIN\n    SELECT trunc(SUM(cost_of_treatment), 2) INTO v_total_revenue\n    FROM \"Treatments\"\n    WHERE professional_id = p_prof_id\n      AND treatment_type_code = p_treatment_type;\n    \n    RETURN COALESCE(v_total_revenue, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Treatments",
      "Professionals"
    ],
    "call_sqls": [
      "SELECT calculate_professional_revenue(9, 'WALK');",
      "SELECT calculate_professional_revenue(10, 'VAC');",
      "SELECT calculate_professional_revenue(4, 'EXAM');",
      "SELECT calculate_professional_revenue(1, 'GROOM');",
      "SELECT calculate_professional_revenue(2, 'BOARD');"
    ],
    "summary": "Create a PL/pgSQL function named calculate_professional_revenue that takes a professional ID (bigint) and a treatment type code (text) and returns a numeric. It calculates the total revenue by summing the cost_of_treatment for matching records in the Treatments table, rounds the result to two decimal places, and returns it. If no revenue is found, return 0.",
    "natural_language": "Write a function called calculate_professional_revenue that, for a given professional and a kind of treatment, figures out the total money brought in. It should add up the treatment costs from the relevant entries, give back the amount rounded to the nearest cent, and just return zero if there's nothing to sum up.",
    "id": 123
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_dogs_by_breed_and_state that accepts two input parameters, p_breed_code of type text and p_state_code of type text, and returns a table consisting of three text columns: dog_name, owner_name, and dog_age; the function's logic executes a single SQL query that selects data from the \"Dogs\" table, aliased as d, performing an inner join with the \"Owners\" table, aliased as o, using the condition that the owner_id column from the \"Dogs\" table matches the owner_id column from the \"Owners\" table; the query applies a filter in its WHERE clause requiring that the breed_code column from the \"Dogs\" table equals the input parameter p_breed_code and that the state column from the \"Owners\" table equals the input parameter p_state_code; for each row satisfying these join and filter conditions, the query's SELECT clause retrieves the value from the name column of the \"Dogs\" table, concatenates the first_name and last_name columns from the \"Owners\" table with a single space separator using the || operator, and retrieves the value from the age column of the \"Dogs\" table; the function then returns the complete result set of this query directly as its output table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_dogs_by_breed_and_state(p_breed_code text, p_state_code text)\nRETURNS TABLE(dog_name text, owner_name text, dog_age text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT d.name, o.first_name || ' ' || o.last_name, d.age\n    FROM \"Dogs\" d\n    INNER JOIN \"Owners\" o ON d.owner_id = o.owner_id\n    WHERE d.breed_code = p_breed_code\n      AND o.state = p_state_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Treatments",
      "Professionals"
    ],
    "call_sqls": [
      "SELECT * FROM get_dogs_by_breed_and_state('ESK', 'Wisconsin');",
      "SELECT * FROM get_dogs_by_breed_and_state('BUL', 'Virginia');",
      "SELECT * FROM get_dogs_by_breed_and_state('ESK', 'Vermont');",
      "SELECT * FROM get_dogs_by_breed_and_state('BUL', 'Wisconsin');",
      "SELECT * FROM get_dogs_by_breed_and_state('ESK', 'Virginia');"
    ],
    "summary": "Create a PL/pgSQL function named get_dogs_by_breed_and_state that takes a breed code (text) and a state code (text) and returns a table with columns dog_name, owner_name, and dog_age (all text). It returns the dog's name, the owner's full name (first and last concatenated), and the dog's age for dogs of the specified breed whose owners live in the specified state.",
    "natural_language": "List the dog's name, the owner's full name, and the dog's age for all dogs of a specified breed whose owners live in a specified state.",
    "id": 124
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_station_manager_length` that accepts a single input parameter, `p_station_id`, which is of type `integer`. This function is designed to return an `integer` value representing the length of the manager's name associated with a specific gas station. The function begins by declaring a local variable named `v_length` of type `integer` to temporarily store the calculated length. The core operation involves executing a `SELECT` statement against the `gas_station` table. This `SELECT` statement calculates the `LENGTH` of the `Manager_Name` column. The result of this `LENGTH` function call is then stored into the `v_length` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `gas_station` table, specifically targeting the row where the `Station_ID` column matches the value provided by the `p_station_id` input parameter. Following the data retrieval, the function proceeds with a conditional `IF` statement. This `IF` statement checks if the `v_length` variable is `NULL`. If `v_length` is indeed `NULL`, indicating that no manager name was found or the `Manager_Name` column itself was `NULL` for the specified station, the function immediately returns the integer value `0`. Otherwise, if `v_length` is not `NULL`, the function returns the actual integer value stored in `v_length`, which represents the length of the manager's name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_station_manager_length(p_station_id integer)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_length integer;\nBEGIN\n    SELECT LENGTH(\"Manager_Name\") INTO v_length\n    FROM gas_station\n    WHERE \"Station_ID\" = p_station_id;\n    \n    IF v_length IS NULL THEN\n        RETURN 0;\n    ELSE\n        RETURN v_length;\n    END IF;\nEND;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "SELECT get_station_manager_length(1);",
      "SELECT get_station_manager_length(2);",
      "SELECT get_station_manager_length(3);",
      "SELECT get_station_manager_length(100);",
      "SELECT get_station_manager_length(0);"
    ],
    "summary": "Create a PL/pgSQL function named get_station_manager_length that takes a station ID (integer) and returns an integer. It calculates and returns the length of the Manager_Name for the specified station from the gas_station table. If no name is found (result is NULL), return 0.",
    "natural_language": "Write function get_station_manager_length(station_id integer) returning integer. Return Manager_Name length for that station from gas_station, or 0 if null.",
    "id": 125
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_company_avg_profit that accepts a single integer input parameter named p_company_id, which is used to identify a specific company, and returns a real number value. The function declares a local real variable named v_avg_profit to hold a calculated average. The function's logic executes a SELECT query on the table named company, specifically calculating the average value of the column \"Profits_billion\" for all rows in that table where the value in the column \"Company_ID\" exactly matches the provided input parameter p_company_id, and stores this computed average into the local variable v_avg_profit. Following this query, the function uses an IF-THEN-ELSE conditional statement to evaluate the value stored in v_avg_profit: if v_avg_profit is greater than 0, the function returns the value of v_avg_profit directly; otherwise, if v_avg_profit is less than or equal to 0 or is NULL, the function returns the real number value 0.0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_company_avg_profit(p_company_id integer)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_profit real;\nBEGIN\n    SELECT AVG(\"Profits_billion\") INTO v_avg_profit\n    FROM company\n    WHERE \"Company_ID\" = p_company_id;\n    \n    IF v_avg_profit > 0 THEN\n        RETURN v_avg_profit;\n    ELSE\n        RETURN 0.0;\n    END IF;\nEND;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "SELECT calculate_company_avg_profit(1);",
      "SELECT calculate_company_avg_profit(2);",
      "SELECT calculate_company_avg_profit(3);",
      "SELECT calculate_company_avg_profit(4);",
      "SELECT calculate_company_avg_profit(5);"
    ],
    "summary": "Create a function named calculate_company_avg_profit that takes a company_id integer and returns a real. Calculate the average Profits_billion for that company from the company table. If the average is greater than 0, return it; otherwise, return 0.0.",
    "natural_language": "What is the average profit in billions for a given company, and can you return it as a real number, defaulting to 0.0 if the average is not greater than zero?",
    "id": 126
  },
  {
    "ir": "Write a PLpgSQL function that calculates the experience of an actor by taking two input parameters: actor_id of type integer, which identifies the actor, and base_year of type integer, which represents the reference year for the calculation. The function outputs two values: experience_years of type integer, which is the difference between the base_year and the actor's birth_year, and experience_score of type numeric, which is computed as the exponential of the experience_years divided by 10.0. The function performs a SELECT operation on the actor table, retrieving the birth_year of the actor whose aid matches the provided actor_id. The difference between base_year and birth_year is calculated to determine experience_years, and the experience_score is calculated using the exponential function exp() applied to the quotient of experience_years and 10.0. The results are stored in the output parameters experience_years and experience_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_actor_experience(IN actor_id integer, IN base_year integer, OUT experience_years integer, OUT experience_score numeric) LANGUAGE plpgsql AS $$\nBEGIN\n    SELECT \n        base_year - \"birth_year\",\n        exp((base_year - \"birth_year\") / 10.0)\n    INTO experience_years, experience_score\n    FROM \"actor\"\n    WHERE \"aid\" = actor_id;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "actor",
      "cast",
      "director",
      "directed_by",
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "SELECT calculate_actor_experience(1, 2023);",
      "SELECT calculate_actor_experience(2, 2020);",
      "SELECT calculate_actor_experience(3, 2024);",
      "SELECT calculate_actor_experience(4, 2019);",
      "SELECT calculate_actor_experience(5, 2022);"
    ],
    "summary": "Create a function that takes an actor_id integer and a base_year integer. It returns the actor's experience_years (base_year minus birth_year) and experience_score (exp(experience_years/10.0)) by looking up the actor in the actor table.",
    "natural_language": "For actor_id and base_year, return experience_years (base_year - birth_year) and experience_score (exp(experience_years/10.0)).",
    "id": 127
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_series_statistics` that accepts a single input parameter, `series_id`, which is of type `integer`. This function is designed to return a table containing specific statistical information about a television series. The returned table will have four columns: `total_episodes` of type `integer`, `seasons_count` of type `integer`, `release_year` of type `integer`, and `budget_value` of type `text`. The function's core operation involves executing a `SELECT` query against the `tv_series` table. This query retrieves the values from the `num_of_episodes` column, the `num_of_seasons` column, the `release_year` column, and the `budget` column. The selection of rows from the `tv_series` table is filtered by a `WHERE` clause, which ensures that only the row where the `sid` column's value exactly matches the `series_id` input parameter is included in the result set. The `RETURN QUERY` statement then outputs the results of this `SELECT` query directly as the function's return table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_series_statistics(series_id integer)\nRETURNS TABLE(total_episodes integer, seasons_count integer, release_year integer, budget_value text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        tv_series.\"num_of_episodes\",\n        tv_series.\"num_of_seasons\", \n        tv_series.\"release_year\",\n        tv_series.\"budget\"\n    FROM \"tv_series\"\n    WHERE tv_series.\"sid\" = series_id;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "actor",
      "cast",
      "director",
      "directed_by",
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "SELECT * FROM get_series_statistics(1);",
      "SELECT * FROM get_series_statistics(5);",
      "SELECT * FROM get_series_statistics(10);",
      "SELECT * FROM get_series_statistics(15);",
      "SELECT * FROM get_series_statistics(20);"
    ],
    "summary": "Create a function named get_series_statistics that takes a series_id integer and returns a table with columns total_episodes, seasons_count, release_year, and budget_value. The data is selected from the tv_series table for the row matching the given series_id.",
    "natural_language": "Get the total episodes, seasons count, release year, and budget value for the series with the specified ID from the tv_series table.",
    "id": 128
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: writer_id of type integer and multiplier of type numeric, and returns a table with two columns: episode_count of type integer and productivity_score of type numeric. The function performs a SELECT operation on the writer table, specifically retrieving the num_of_episodes column for the row where the wid column matches the provided writer_id parameter. It then calculates the productivity_score by applying the exponential function exp() to the product of num_of_episodes and the multiplier parameter. The function returns the num_of_episodes value as episode_count and the calculated productivity_score for the specified writer_id.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_writer_productivity(writer_id integer, multiplier numeric)\nRETURNS TABLE(episode_count integer, productivity_score numeric) LANGUAGE plpgsql AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        \"num_of_episodes\",\n        exp(\"num_of_episodes\" * multiplier)\n    FROM \"writer\"\n    WHERE \"wid\" = writer_id;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "actor",
      "cast",
      "director",
      "directed_by",
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_writer_productivity(1, 0.1);",
      "SELECT * FROM analyze_writer_productivity(5, 0.05);",
      "SELECT * FROM analyze_writer_productivity(10, 0.2);",
      "SELECT * FROM analyze_writer_productivity(15, 0.01);",
      "SELECT * FROM analyze_writer_productivity(20, 0.15);"
    ],
    "summary": "Create a PLpgSQL function that returns a table with episode_count and productivity_score for a given writer_id. It calculates productivity_score as exp(num_of_episodes * multiplier).",
    "natural_language": "Please construct a PL/pgSQL function that yields a table containing the columns 'episode_count' and 'productivity_score' for a specified writer identifier. The function must compute the productivity score by applying the exponential function to the product of the number of episodes and a predetermined multiplier.",
    "id": 129
  },
  {
    "ir": "Write a PostgreSQL SQL function that retrieves the top company by sales from the company table. This function, named get_top_company_by_sales, returns a table with three columns: Company_ID of type integer, Company of type text, and Sales_billion of type real. The function performs a SELECT operation on the company table, extracting the Company_ID, Company, and Sales_billion columns. It orders the results by the Sales_billion column in descending order to ensure the company with the highest sales is prioritized. The function limits the result set to a single row using the LIMIT 1 clause, effectively selecting the company with the highest sales figure. There are no conditional statements or special operations like function calls within this function. The logic flow is straightforward, focusing solely on retrieving and ordering data based on sales figures.",
    "plsql": "CREATE OR REPLACE FUNCTION get_top_company_by_sales()\nRETURNS TABLE(\"Company_ID\" integer, \"Company\" text, \"Sales_billion\" real)\nLANGUAGE sql AS $$\nSELECT \"Company_ID\", \"Company\", \"Sales_billion\" FROM \"company\" ORDER BY \"Sales_billion\" DESC LIMIT 1;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "station_company"
    ],
    "call_sqls": [
      "SELECT * FROM get_top_company_by_sales();",
      "SELECT \"Company\", \"Sales_billion\" FROM get_top_company_by_sales();",
      "SELECT \"Company_ID\" FROM get_top_company_by_sales();",
      "SELECT * FROM get_top_company_by_sales() AS top_company;",
      "SELECT \"Company_ID\", \"Company\" FROM get_top_company_by_sales();"
    ],
    "summary": "Create a PostgreSQL SQL function named get_top_company_by_sales that returns a single row table with Company_ID, Company, and Sales_billion for the company with the highest sales.",
    "natural_language": "What is the company ID, name, and sales in billions for the company with the highest sales?",
    "id": 130
  },
  {
    "ir": "Write a PostgreSQL SQL language function named calculate_company_performance_rank that returns a table with two columns: an integer column named \"Company_ID\" and a double precision column named \"Performance_Rank\". The function body executes a single SELECT query on the \"company\" table. The query selects the \"Company_ID\" column directly from the table and also computes a value using the percent_rank() window function. The percent_rank() function is applied over a window defined by the OVER clause, which orders all rows from the \"company\" table in ascending order based on the \"Profits_billion\" column. For each row, this calculation determines the relative rank of the company's profit by computing the percentile rank, which is a value between 0 and 1 derived from the formula (rank - 1) / (total number of rows - 1), where rank is the row's rank within the ordered set. The function returns the resulting set of company identifiers paired with their corresponding calculated performance percentile rank.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_company_performance_rank()\nRETURNS TABLE(\"Company_ID\" integer, \"Performance_Rank\" double precision)\nLANGUAGE sql AS $$\nSELECT \"Company_ID\", percent_rank() OVER (ORDER BY \"Profits_billion\") FROM \"company\";\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "station_company"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_company_performance_rank();",
      "SELECT \"Company_ID\", \"Performance_Rank\" FROM calculate_company_performance_rank();",
      "SELECT * FROM calculate_company_performance_rank() WHERE \"Performance_Rank\" > 0.5;",
      "SELECT \"Company_ID\" FROM calculate_company_performance_rank() ORDER BY \"Performance_Rank\" DESC LIMIT 1;",
      "SELECT COUNT(*) FROM calculate_company_performance_rank();"
    ],
    "summary": "Create a PostgreSQL SQL function named calculate_company_performance_rank that returns a table with Company_ID and Performance_Rank. Performance_Rank is the percent_rank() of each company based on ascending Profits_billion.",
    "natural_language": "How can I create a PostgreSQL SQL function called calculate_company_performance_rank that returns a table containing Company_ID and a Performance_Rank, where the rank is the percent_rank() based on ascending Profits_billion?",
    "id": 131
  },
  {
    "ir": "Write a PostgreSQL SQL function that returns a table with two columns: \"Company_ID\" of type integer and \"Market_Percentile\" of type double precision. This function, named get_market_value_percentile, does not take any input parameters. It performs a SELECT operation on the \"company\" table, retrieving the \"Company_ID\" column and calculating the percentile rank of each company's market value using the percent_rank() window function. The percent_rank() function is applied over an ordered set of rows determined by the \"Market_Value\" column in ascending order. The result is a table where each row contains a company's ID and its corresponding market value percentile rank, indicating the relative standing of each company's market value compared to others in the dataset.",
    "plsql": "CREATE OR REPLACE FUNCTION get_market_value_percentile()\nRETURNS TABLE(\"Company_ID\" integer, \"Market_Percentile\" double precision)\nLANGUAGE sql AS $$\nSELECT \"Company_ID\", percent_rank() OVER (ORDER BY \"Market_Value\") FROM \"company\";\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "station_company"
    ],
    "call_sqls": [
      "SELECT * FROM get_market_value_percentile();",
      "SELECT \"Company_ID\", \"Market_Percentile\" FROM get_market_value_percentile();",
      "SELECT * FROM get_market_value_percentile() LIMIT 1;",
      "SELECT \"Company_ID\" FROM get_market_value_percentile() ORDER BY \"Market_Percentile\" DESC;",
      "SELECT \"Market_Percentile\" FROM get_market_value_percentile() WHERE \"Company_ID\" = 1;"
    ],
    "summary": "Create a PostgreSQL function named get_market_value_percentile with no parameters that returns a table of integer Company_ID and double precision Market_Percentile. Select Company_ID and the percent_rank() of Market_Value ordered ascending from the company table.",
    "natural_language": "Please construct a PostgreSQL function designated as 'get_market_value_percentile'. This function shall accept no parameters and shall return a table comprising two columns: an integer column labeled 'Company_ID' and a double precision column labeled 'Market_Percentile'. The function logic must select the 'Company_ID' from the company table and compute the percentile rank, via the percent_rank() window function, for each company's 'Market_Value' when ordered in ascending sequence.",
    "id": 132
  },
  {
    "ir": "Write a PLpgSQL function named get_actor_count_by_gender that accepts a single parameter p_gender of type text, which specifies the gender for which the count of actors is to be retrieved. The function returns an integer representing the number of actors of the specified gender. Within the function, a conditional statement checks the value of p_gender. If p_gender is equal to 'male', the function executes a SELECT COUNT(*) query on the actor table, filtering rows where the gender column is equal to 'male', and returns the count of such rows. If p_gender is not 'male', the function assumes the gender is 'female' and performs a similar SELECT COUNT(*) query on the actor table, filtering rows where the gender column is equal to 'female', and returns the count of these rows. The function uses the plpgsql language for its implementation.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_count_by_gender(p_gender text)\nRETURNS integer AS $$\nBEGIN\n    IF p_gender = 'male' THEN\n        RETURN (SELECT COUNT(*) FROM actor WHERE gender = 'male');\n    ELSE\n        RETURN (SELECT COUNT(*) FROM actor WHERE gender = 'female');\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "made_by",
      "producer"
    ],
    "call_sqls": [
      "SELECT get_actor_count_by_gender('male');",
      "SELECT get_actor_count_by_gender('female');",
      "SELECT get_actor_count_by_gender('male') AS male_count, get_actor_count_by_gender('female') AS female_count;",
      "SELECT gender, get_actor_count_by_gender(gender) FROM (SELECT DISTINCT gender FROM actor) AS genders;",
      "SELECT get_actor_count_by_gender('male') FROM actor LIMIT 1;"
    ],
    "summary": "Create a PLpgSQL function named get_actor_count_by_gender that accepts a text parameter p_gender and returns an integer. If p_gender is 'male', return the count of rows from the actor table where gender is 'male'. Otherwise, return the count where gender is 'female'.",
    "natural_language": "Function get_actor_count_by_gender(p_gender text) returns integer. Count male actors if p_gender is 'male', else count female actors.",
    "id": 133
  },
  {
    "ir": "Write a PLpgSQL function named calculate_age_difference that accepts two integer parameters: p_actor_id and p_producer_id. The purpose of this function is to compute the absolute difference in birth years between an actor and a producer. The function first checks if there exists a record in the actor table with the aid column matching the value of p_actor_id. If such a record exists, the function proceeds to calculate the age difference by selecting the birth_year from the actor table where aid equals p_actor_id and the birth_year from the producer table where pid equals p_producer_id. It then computes the absolute difference between these two birth_year values using the ABS() function and returns this result. If no record exists in the actor table with the specified p_actor_id, the function returns -1.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_age_difference(p_actor_id integer, p_producer_id integer)\nRETURNS integer AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM actor WHERE aid = p_actor_id) THEN\n        RETURN ABS((SELECT birth_year FROM actor WHERE aid = p_actor_id) - (SELECT birth_year FROM producer WHERE pid = p_producer_id));\n    ELSE\n        RETURN -1;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "made_by",
      "producer"
    ],
    "call_sqls": [
      "SELECT calculate_age_difference(1, 100);",
      "SELECT calculate_age_difference(5, 150);",
      "SELECT calculate_age_difference(10, 200);",
      "SELECT calculate_age_difference(15, 250);",
      "SELECT calculate_age_difference(20, 300);"
    ],
    "summary": "Create a function named calculate_age_difference that takes an actor ID and a producer ID. Return the absolute difference in their birth years. If the actor ID does not exist, return -1.",
    "natural_language": "Hey, can you whip up a function called calculate_age_difference? It needs to take an actor's ID and a producer's ID. Just give me the absolute gap between their birth years. But if that actor ID isn't in the system, just spit out -1.",
    "id": 134
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_album_song_count` that accepts three input parameters: `p_album_id` of type `bigint`, `p_year_threshold` of type `bigint`, and `p_min_position` of type `bigint`. The purpose of this function is to calculate and return a single `bigint` value representing the total count of songs associated with a specific album, subject to certain filtering criteria. The function achieves this by executing a `SELECT` statement that performs a `COUNT(*)` operation. This `SELECT` statement involves an `INNER JOIN` between two tables: `\"Tracklists\"` and `\"Albums\"`. The join condition specifies that records from `\"Tracklists\"` are linked to records from `\"Albums\"` where the value in the `\"AlbumId\"` column of the `\"Tracklists\"` table is equal to the value in the `\"AId\"` column of the `\"Albums\"` table. After the join, the result set is filtered using a `WHERE` clause with three conditions combined by `AND` operators. The first condition requires that the value in the `\"AlbumId\"` column of the `\"Tracklists\"` table must be equal to the input parameter `p_album_id`. The second condition specifies that the value in the `\"Year\"` column of the `\"Albums\"` table must be greater than or equal to the input parameter `p_year_threshold`. The third condition dictates that the value in the `\"Position\"` column of the `\"Tracklists\"` table must be greater than or equal to the input parameter `p_min_position`. The `COUNT(*)` aggregate function then counts all rows that satisfy these join and filtering conditions, and this final count is returned as the result of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_album_song_count(p_album_id bigint, p_year_threshold bigint, p_min_position bigint)\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM \"Tracklists\" t JOIN \"Albums\" a ON t.\"AlbumId\" = a.\"AId\" WHERE t.\"AlbumId\" = p_album_id AND a.\"Year\" >= p_year_threshold AND t.\"Position\" >= p_min_position);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "SELECT get_album_song_count(1, 2000, 5);",
      "SELECT get_album_song_count(5, 1995, 1);",
      "SELECT get_album_song_count(10, 2010, 3);",
      "SELECT get_album_song_count(15, 1980, 10);",
      "SELECT get_album_song_count(20, 2005, 2);"
    ],
    "summary": "Create a function named get_album_song_count that takes an album ID, a minimum year, and a minimum track position. Return the count of songs for that album where the album's year meets the threshold and the track's position meets the minimum.",
    "natural_language": "Alright, so I need a function called get_album_song_count. You gotta feed it an album ID, a cutoff year, and a minimum track number. It should spit back how many songs are on that specific album, but only if the album came out on or after that year and the song's track position is at least that minimum number.",
    "id": 135
  },
  {
    "ir": "Write a PLpgSQL function named get_instrument_diversity that returns a text value, which accepts three input parameters: a bigint parameter named p_song_id to identify a specific song, a bigint parameter named p_min_bandmate_id to set a minimum bandmate identifier, and a text parameter named p_instrument_filter to specify an instrument to exclude; the function's logic executes a single SQL SELECT query on the \"Instruments\" table, where the query selects the \"Instrument\" column, applies a DISTINCT modifier to eliminate duplicate instrument names, and filters rows using a WHERE clause with three conditions that must all be true: the \"SongId\" column must exactly equal the input parameter p_song_id, the \"BandmateId\" column must be greater than or equal to the input parameter p_min_bandmate_id, and the \"Instrument\" column must not be equal to the input parameter p_instrument_filter; the resulting set of distinct instrument names is then aggregated into a single text string using the STRING_AGG function, which concatenates the instrument names separated by commas, and this aggregated string is returned as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_instrument_diversity(p_song_id bigint, p_min_bandmate_id bigint, p_instrument_filter text)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT STRING_AGG(DISTINCT \"Instrument\", ',') FROM \"Instruments\" WHERE \"SongId\" = p_song_id AND \"BandmateId\" >= p_min_bandmate_id AND \"Instrument\" != p_instrument_filter);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "SELECT get_instrument_diversity(1, 1, 'Guitar');",
      "SELECT get_instrument_diversity(2, 3, 'Drums');",
      "SELECT get_instrument_diversity(5, 2, 'Bass');",
      "SELECT get_instrument_diversity(10, 1, 'Piano');",
      "SELECT get_instrument_diversity(7, 4, 'Vocals');"
    ],
    "summary": "Create a PLpgSQL function named get_instrument_diversity that returns a text value. It accepts three parameters: p_song_id (bigint), p_min_bandmate_id (bigint), and p_instrument_filter (text). The function returns a comma-separated string of distinct instrument names from the \"Instruments\" table where SongId equals p_song_id, BandmateId is greater than or equal to p_min_bandmate_id, and Instrument is not equal to p_instrument_filter.",
    "natural_language": "Write a PLpgSQL function called get_instrument_diversity that gives back a text result. It should take three inputs: a song ID, a minimum bandmate ID, and a text to filter instruments by. The function needs to produce a list, separated by commas, of the different kinds of instruments found in the \"Instruments\" table for a certain song, but only for bandmates with IDs at or above a certain number, and leaving out any instruments that match the given filter text.",
    "id": 136
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns a table consisting of the Title and Sales columns from the song table for songs performed by a specified singer and having sales greater than a specified minimum value. The function, named get_singer_sales, accepts two input parameters: singer_name of type TEXT, which represents the name of the singer, and min_sales of type REAL, which represents the minimum sales threshold. The function operates by executing a SQL SELECT query that joins the song table, aliased as s, with the singer table, aliased as si, using the Singer_ID column from both tables to establish the relationship between songs and singers. The WHERE clause of the query filters the results to include only those rows where the Name column in the singer table matches the provided singer_name parameter and the Sales column in the song table exceeds the min_sales parameter. The function returns the result set as a table with columns Title and Sales, corresponding to the Title and Sales columns from the song table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_singer_sales(IN singer_name TEXT, IN min_sales REAL)\nRETURNS TABLE (Title TEXT, Sales REAL)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT s.\"Title\", s.\"Sales\"\n    FROM song s\n    JOIN singer si ON s.\"Singer_ID\" = si.\"Singer_ID\"\n    WHERE si.\"Name\" = singer_name AND s.\"Sales\" > min_sales;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "SELECT * FROM get_singer_sales('Liliane Bettencourt', 1000000.0);",
      "SELECT * FROM get_singer_sales('Christy Walton', 500000.0);",
      "SELECT * FROM get_singer_sales('Alice Walton', 300000.0);",
      "SELECT * FROM get_singer_sales('Liliane Bettencourt', 2000000.0);",
      "SELECT * FROM get_singer_sales('Christy Walton', 100000.0);"
    ],
    "summary": "Create a PLpgSQL function named get_singer_sales that returns a table with columns Title and Sales. It accepts two parameters: singer_name (TEXT) and min_sales (REAL). The function returns songs from the song table (aliased 's') joined with the singer table (aliased 'si') on Singer_ID, where the singer's Name matches singer_name and the song's Sales exceed min_sales.",
    "natural_language": "Construct a PLpgSQL function called get_singer_sales, which is designed to produce a result table containing the specific columns Title and Sales. This function requires two input parameters: a singer_name of type TEXT and a min_sales threshold of type REAL. The function's logic involves querying the song table, referenced with the alias 's', and performing an inner join with the singer table, referenced as 'si', using the common Singer_ID field. It meticulously filters the results to include only those records where the singer's full Name precisely corresponds to the provided singer_name parameter and, importantly, where the song's total Sales are definitively greater than the specified min_sales value.",
    "id": 137
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: singer_id of type INTEGER and min_position of type REAL. The function queries the song table to find the title of a song where the Singer_ID column matches the provided singer_id and the Highest_Position column is less than or equal to the specified min_position. It orders the results by the Highest_Position column in ascending order and selects the first result using a LIMIT of 1. The function then returns the title of this song as a TEXT value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_position_song(singer_id INTEGER, min_position REAL)\nRETURNS TEXT\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    result_title TEXT;\nBEGIN\n    SELECT \"Title\"\n    INTO result_title\n    FROM song\n    WHERE \"Singer_ID\" = singer_id AND \"Highest_Position\" <= min_position\n    ORDER BY \"Highest_Position\" ASC\n    LIMIT 1;\n    \n    RETURN result_title;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "SELECT get_highest_position_song(1, 5.0);",
      "SELECT get_highest_position_song(2, 10.0);",
      "SELECT get_highest_position_song(3, 1.0);",
      "SELECT get_highest_position_song(1, 100.0);",
      "SELECT get_highest_position_song(2, 50.0);"
    ],
    "summary": "Create a PLpgSQL function that returns a TEXT value. It accepts two parameters: singer_id (INTEGER) and min_position (REAL). The function returns the title of the first song from the song table where Singer_ID matches singer_id and Highest_Position is less than or equal to min_position, ordered by Highest_Position ascending.",
    "natural_language": "Write a PLpgSQL function that gives back a TEXT. It should take a singer's ID number and a minimum chart position as inputs. The function needs to find and return the title of a song for that singer where its peak ranking is at or below the given minimum, picking one of the earlier, better-charting ones.",
    "id": 138
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_revenue_category` that accepts a single input parameter, `manufacturer_code`, of type `bigint`. This function is designed to determine and return a revenue category, either 'High' or 'Low', for a specific manufacturer based on their `Revenue` value stored in the `\"Manufacturers\"` table. The logic for categorizing revenue is conditional, depending on the value of the `manufacturer_code`.\n\nFirst, a local variable named `revenue_category` of type `text` is declared to store the calculated revenue category.\n\nThe function then proceeds with a series of conditional checks using an `IF-ELSIF-ELSE` block based on the `manufacturer_code` parameter:\n\n1.  **If `manufacturer_code` is equal to `1`**:\n    The function executes a `SELECT` statement to retrieve data from the `\"Manufacturers\"` table. It specifically looks for the row where the `\"Code\"` column matches the input `manufacturer_code`. From this row, it evaluates the `\"Revenue\"` column. If the value in `\"Revenue\"` is greater than `100`, the `revenue_category` variable is set to 'High'; otherwise, it is set to 'Low'.\n\n2.  **Else if `manufacturer_code` is equal to `2`**:\n    The function executes a `SELECT` statement to retrieve data from the `\"Manufacturers\"` table. It specifically looks for the row where the `\"Code\"` column matches the input `manufacturer_code`. From this row, it evaluates the `\"Revenue\"` column. If the value in `\"Revenue\"` is greater than `200`, the `revenue_category` variable is set to 'High'; otherwise, it is set to 'Low'.\n\n3.  **Else if `manufacturer_code` is equal to `3`**:\n    The function executes a `SELECT` statement to retrieve data from the `\"Manufacturers\"` table. It specifically looks for the row where the `\"Code\"` column matches the input `manufacturer_code`. From this row, it evaluates the `\"Revenue\"` column. If the value in `\"Revenue\"` is greater than `300`, the `revenue_category` variable is set to 'High'; otherwise, it is set to 'Low'.\n\n4.  **Else if `manufacturer_code` is equal to `4`**:\n    The function executes a `SELECT` statement to retrieve data from the `\"Manufacturers\"` table. It specifically looks for the row where the `\"Code\"` column matches the input `manufacturer_code`. From this row, it evaluates the `\"Revenue\"` column. If the value in `\"Revenue\"` is greater than `400`, the `revenue_category` variable is set to 'High'; otherwise, it is set to 'Low'.\n\n5.  **Else (for any `manufacturer_code` not equal to `1`, `2`, `3`, or `4`)**:\n    The function executes a `SELECT` statement to retrieve data from the `\"Manufacturers\"` table. It specifically looks for the row where the `\"Code\"` column matches the input `manufacturer_code`. From this row, it evaluates the `\"Revenue\"` column. If the value in `\"Revenue\"` is greater than `500`, the `revenue_category` variable is set to 'High'; otherwise, it is set to 'Low'.\n\nFinally, after the appropriate `revenue_category` has been determined and assigned based on the conditional logic, the function returns the value stored in the `revenue_category` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_revenue_category(manufacturer_code bigint) RETURNS text AS $$\nDECLARE\n    revenue_category text;\nBEGIN\n    IF manufacturer_code = 1 THEN\n        SELECT CASE WHEN \"Revenue\" > 100 THEN 'High' ELSE 'Low' END INTO revenue_category FROM \"Manufacturers\" WHERE \"Code\" = manufacturer_code;\n    ELSIF manufacturer_code = 2 THEN\n        SELECT CASE WHEN \"Revenue\" > 200 THEN 'High' ELSE 'Low' END INTO revenue_category FROM \"Manufacturers\" WHERE \"Code\" = manufacturer_code;\n    ELSIF manufacturer_code = 3 THEN\n        SELECT CASE WHEN \"Revenue\" > 300 THEN 'High' ELSE 'Low' END INTO revenue_category FROM \"Manufacturers\" WHERE \"Code\" = manufacturer_code;\n    ELSIF manufacturer_code = 4 THEN\n        SELECT CASE WHEN \"Revenue\" > 400 THEN 'High' ELSE 'Low' END INTO revenue_category FROM \"Manufacturers\" WHERE \"Code\" = manufacturer_code;\n    ELSE\n        SELECT CASE WHEN \"Revenue\" > 500 THEN 'High' ELSE 'Low' END INTO revenue_category FROM \"Manufacturers\" WHERE \"Code\" = manufacturer_code;\n    END IF;\n    RETURN revenue_category;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_revenue_category(1);",
      "SELECT get_revenue_category(2);",
      "SELECT get_revenue_category(3);",
      "SELECT get_revenue_category(4);",
      "SELECT get_revenue_category(5);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_revenue_category that returns a text value. It accepts one parameter: manufacturer_code (bigint). The function returns 'High' or 'Low' based on the Revenue value from the \"Manufacturers\" table for the given code. The threshold for 'High' is 100 for code 1, 200 for code 2, 300 for code 3, 400 for code 4, and 500 for all other codes.",
    "natural_language": "Hey, can you whip up a PostgreSQL function called get_revenue_category? It should spit out a text value. It takes one input: manufacturer_code (as a bigint). Basically, it needs to check the Revenue from the \"Manufacturers\" table for that code and tell us if it's 'High' or 'Low'. Here's the deal: if the code is 1, 'High' means Revenue is at least 100. For code 2, the bar is 200. For 3, it's 300. For 4, it's 400. And for any other code, it's gotta be 500 or more to be 'High'.",
    "id": 139
  },
  {
    "ir": "Write a PLpgSQL function named categorize_product_price that accepts a single parameter manufacturer_code of type bigint, which represents the code of a manufacturer. The function aims to categorize the price of products from the \"Products\" table based on the manufacturer code provided. It begins by declaring a local variable price_category of type text to store the result of the categorization. The function uses a series of conditional statements to determine the price threshold for categorizing a product as 'Expensive' or 'Affordable'. If the manufacturer_code is 1, it selects the price category from the \"Products\" table where the \"Manufacturer\" column matches the manufacturer_code, and categorizes the product as 'Expensive' if the \"Price\" column is greater than 200, otherwise as 'Affordable'. Similarly, for manufacturer_code 2, the threshold is set at 250; for manufacturer_code 3, the threshold is 300; for manufacturer_code 4, the threshold is 350. For any other manufacturer_code, the threshold is set at 400. The selection is limited to one product using LIMIT 1. If no product is found that matches the criteria, the price_category is set to 'No products found'. Finally, the function returns the price_category value.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_product_price(manufacturer_code bigint) RETURNS text AS $$\nDECLARE\n    price_category text;\nBEGIN\n    IF manufacturer_code = 1 THEN\n        SELECT CASE WHEN \"Price\" > 200 THEN 'Expensive' ELSE 'Affordable' END INTO price_category FROM \"Products\" WHERE \"Manufacturer\" = manufacturer_code LIMIT 1;\n    ELSIF manufacturer_code = 2 THEN\n        SELECT CASE WHEN \"Price\" > 250 THEN 'Expensive' ELSE 'Affordable' END INTO price_category FROM \"Products\" WHERE \"Manufacturer\" = manufacturer_code LIMIT 1;\n    ELSIF manufacturer_code = 3 THEN\n        SELECT CASE WHEN \"Price\" > 300 THEN 'Expensive' ELSE 'Affordable' END INTO price_category FROM \"Products\" WHERE \"Manufacturer\" = manufacturer_code LIMIT 1;\n    ELSIF manufacturer_code = 4 THEN\n        SELECT CASE WHEN \"Price\" > 350 THEN 'Expensive' ELSE 'Affordable' END INTO price_category FROM \"Products\" WHERE \"Manufacturer\" = manufacturer_code LIMIT 1;\n    ELSE\n        SELECT CASE WHEN \"Price\" > 400 THEN 'Expensive' ELSE 'Affordable' END INTO price_category FROM \"Products\" WHERE \"Manufacturer\" = manufacturer_code LIMIT 1;\n    END IF;\n    \n    IF price_category IS NULL THEN\n        price_category := 'No products found';\n    END IF;\n    \n    RETURN price_category;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "SELECT categorize_product_price(1);",
      "SELECT categorize_product_price(2);",
      "SELECT categorize_product_price(3);",
      "SELECT categorize_product_price(4);",
      "SELECT categorize_product_price(5);"
    ],
    "summary": "Create a PL/pgSQL function named categorize_product_price that takes a manufacturer_code (bigint) and returns a text. For the given manufacturer, retrieve one product's price from the Products table. Categorize it as 'Expensive' or 'Affordable' based on a price threshold: 200 for code 1, 250 for code 2, 300 for code 3, 350 for code 4, and 400 for any other code. If no product is found, return 'No products found'.",
    "natural_language": "Create function categorize_product_price(manufacturer_code bigint) returning text. For that manufacturer, get one product price. Return 'Expensive' if price exceeds threshold: 200 for code 1, 250 for 2, 300 for 3, 350 for 4, else 400. Return 'Affordable' if not expensive. Return 'No products found' if none exist.",
    "id": 140
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `determine_headquarter_location` that accepts a single input parameter, `manufacturer_code`, which is of type `bigint`. This function is designed to retrieve the headquarter location for a specific manufacturer. Inside the function's `BEGIN` block, a local variable named `location` of type `text` is declared to temporarily store the retrieved headquarter information. The core operation involves executing a `SELECT` statement against the `\"Manufacturers\"` table. This `SELECT` statement specifically targets the `\"Headquarter\"` column. The value retrieved from the `\"Headquarter\"` column is then immediately assigned to the `location` variable. The selection of the row from the `\"Manufacturers\"` table is conditional, based on a `WHERE` clause that matches the value in the `\"Code\"` column with the `manufacturer_code` parameter provided to the function. Finally, the function returns the value stored in the `location` variable, which represents the headquarter location of the manufacturer identified by the input `manufacturer_code`.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_headquarter_location(manufacturer_code bigint) RETURNS text AS $$\nDECLARE\n    location text;\nBEGIN\n    SELECT \"Headquarter\" INTO location FROM \"Manufacturers\" WHERE \"Code\" = manufacturer_code;\n    RETURN location;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "SELECT determine_headquarter_location(1);",
      "SELECT determine_headquarter_location(2);",
      "SELECT determine_headquarter_location(3);"
    ],
    "summary": "Create a PL/pgSQL function named determine_headquarter_location that takes a manufacturer_code (bigint) and returns a text. Retrieve the headquarter location from the Manufacturers table where the Code matches the input parameter.",
    "natural_language": "What is the headquarter location for the manufacturer with the given manufacturer_code?",
    "id": 141
  },
  {
    "ir": "Write a PLpgSQL function named find_teacher_info that accepts three input parameters: a bigint parameter named p_classroom, a text parameter named p_firstname, and a text parameter named p_lastname, and returns a boolean value; the function's logic begins by declaring a local boolean variable called teacher_exists, then executes a SELECT statement that uses the EXISTS operator to query the teachers table, checking for the presence of at least one row where the value in the column named Classroom is exactly equal to the p_classroom parameter, and where the value in the column named FirstName, after being converted to uppercase using the UPPER function, matches the uppercase conversion of the p_firstname parameter, and where the value in the column named LastName, after being converted to uppercase using the UPPER function, matches the uppercase conversion of the p_lastname parameter; the boolean result of this EXISTS subquery is then assigned into the teacher_exists variable using a SELECT INTO statement, and finally, the function returns the value stored in the teacher_exists variable.",
    "plsql": "CREATE OR REPLACE FUNCTION find_teacher_info(p_classroom bigint, p_firstname text, p_lastname text)\nRETURNS boolean\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    teacher_exists boolean;\nBEGIN\n    SELECT EXISTS(\n        SELECT 1 FROM teachers \n        WHERE \"Classroom\" = p_classroom \n        AND UPPER(\"FirstName\") = UPPER(p_firstname) \n        AND UPPER(\"LastName\") = UPPER(p_lastname)\n    ) INTO teacher_exists;\n    \n    RETURN teacher_exists;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT find_teacher_info(101, 'MIN', 'MACROSTIE');",
      "SELECT find_teacher_info(112, 'STORMY', 'KRISTENSEN');",
      "SELECT find_teacher_info(103, 'OTHA', 'MOYER');",
      "SELECT find_teacher_info(102, 'JEROME', 'COVIN');",
      "SELECT find_teacher_info(107, 'SHERWOOD', 'VANDERWOUDE');"
    ],
    "summary": "Create a PL/pgSQL function named find_teacher_info that takes a classroom (bigint), a first name (text), and a last name (text) and returns a boolean. Check if a teacher exists in the teachers table where the Classroom matches and the uppercase FirstName and LastName match the uppercase input names.",
    "natural_language": "Does a teacher exist in the teachers table for the specified classroom where the uppercase first and last names match the provided inputs?",
    "id": 142
  },
  {
    "ir": "Write a PLpgSQL function named `get_artist_age` that accepts a single input parameter, `p_artist_id`, which is of type `INTEGER`. The purpose of this function is to retrieve the age of a specific artist from the `artist` table. The function's logic begins with a conditional check: it evaluates whether the value of `p_artist_id` is greater than `0`. If this condition is true, the function proceeds to execute a `SELECT` statement. This `SELECT` statement queries the `artist` table to retrieve the value from the `\"Age\"` column. The retrieval is filtered by a `WHERE` clause, which specifies that the `\"Artist_ID\"` column in the `artist` table must match the value provided by the `p_artist_id` input parameter. The result of this `SELECT` statement (the artist's age) is then returned by the function. If the initial conditional check (`p_artist_id > 0`) evaluates to false, meaning `p_artist_id` is `0` or a negative value, the `SELECT` statement is bypassed, and the function directly returns `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_age(p_artist_id INTEGER)\nRETURNS INTEGER AS $$\nBEGIN\n    IF p_artist_id > 0 THEN\n        RETURN (SELECT \"Age\" FROM artist WHERE \"Artist_ID\" = p_artist_id);\n    END IF;\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT get_artist_age(1);",
      "SELECT get_artist_age(2);",
      "SELECT get_artist_age(3);",
      "SELECT get_artist_age(10);",
      "SELECT get_artist_age(NULL);"
    ],
    "summary": "Create a PL/pgSQL function named get_artist_age that takes an artist_id (integer) and returns an integer. If the artist_id is greater than 0, retrieve and return the Age from the artist table where Artist_ID matches. Otherwise, return NULL.",
    "natural_language": "Write a function called get_artist_age that uses an artist_id number. If you give it a decent, positive-looking ID, it should fetch and give back the Age from the artist table for that particular artist. If the ID isn't really valid or seems off, just return nothing.",
    "id": 143
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `check_festival_award` that accepts a single input parameter, `p_festival_id`, of type `INTEGER`. This function is designed to determine if a specific music festival, identified by `p_festival_id`, has been awarded. The function returns a `BOOLEAN` value. Inside the function, a local variable named `award_status` of type `TEXT` is declared to temporarily store the award status retrieved from the database. The function's logic begins with a conditional check: `IF p_festival_id > 0 THEN`. If the value of `p_festival_id` is strictly greater than zero, the function proceeds to execute a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"Result\"` from the table named `music_festival`. The retrieved value is then assigned to the `award_status` variable. The `WHERE` clause of this `SELECT` statement specifies the condition `\"ID\" = p_festival_id`, meaning it fetches the `\"Result\"` for the row in `music_festival` where the value in the `\"ID\"` column matches the input `p_festival_id`. After the `SELECT` operation, the function evaluates the expression `award_status = 'Awarded'`. This comparison checks if the value stored in the `award_status` variable is exactly equal to the string literal 'Awarded'. The boolean result of this comparison is then returned by the function. If the initial conditional check `IF p_festival_id > 0` evaluates to `FALSE` (i.e., `p_festival_id` is less than or equal to zero), the `SELECT` statement and subsequent comparison are skipped, and the function immediately returns `FALSE`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_festival_award(p_festival_id INTEGER)\nRETURNS BOOLEAN AS $$\nDECLARE\n    award_status TEXT;\nBEGIN\n    IF p_festival_id > 0 THEN\n        SELECT \"Result\" INTO award_status FROM music_festival WHERE \"ID\" = p_festival_id;\n        RETURN award_status = 'Awarded';\n    END IF;\n    RETURN FALSE;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT check_festival_award(1);",
      "SELECT check_festival_award(2);",
      "SELECT check_festival_award(3);"
    ],
    "summary": "Create a PL/pgSQL function named check_festival_award that takes a festival_id (integer) and returns a boolean. If the festival_id is greater than 0, retrieve the Result from the music_festival table where ID matches. Return TRUE if the result is 'Awarded', otherwise FALSE. If the festival_id is not greater than 0, return FALSE.",
    "natural_language": "Write a PL/pgSQL function called check_festival_award that takes a festival ID number. It should check if the ID is a positive number. If it is, look up that festival in the music_festival table and see what its Result is. If the result looks like it was awarded something, then return true. Otherwise, or if the ID wasn't a valid positive number to begin with, just return false.",
    "id": 144
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_volume_weeks_on_top` that accepts a single input parameter, `p_volume_id`, which is of type `INTEGER`. The purpose of this function is to retrieve the value from the `\"Weeks_on_Top\"` column for a specific record in the `volume` table, identified by the provided `p_volume_id`. The function begins with a conditional check: if the value of `p_volume_id` is strictly greater than `0`, then it proceeds to execute a `SELECT` statement. This `SELECT` statement queries the `volume` table to fetch the value of the `\"Weeks_on_Top\"` column. The retrieval is filtered by a `WHERE` clause, ensuring that only the row where the `\"Volume_ID\"` column matches the input `p_volume_id` is considered. The value obtained from this `SELECT` query is then returned as the result of the function, which is of type `REAL`. If the initial conditional check evaluates to false (i.e., `p_volume_id` is not greater than `0`), the function bypasses the `SELECT` operation and directly returns `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_volume_weeks_on_top(p_volume_id INTEGER)\nRETURNS REAL AS $$\nBEGIN\n    IF p_volume_id > 0 THEN\n        RETURN (SELECT \"Weeks_on_Top\" FROM volume WHERE \"Volume_ID\" = p_volume_id);\n    END IF;\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT get_volume_weeks_on_top(1);",
      "SELECT get_volume_weeks_on_top(2);",
      "SELECT get_volume_weeks_on_top(3);",
      "SELECT get_volume_weeks_on_top(10);",
      "SELECT get_volume_weeks_on_top(NULL);"
    ],
    "summary": "Create a function named `get_volume_weeks_on_top` that takes an integer `p_volume_id` and returns a REAL. If `p_volume_id` is greater than 0, return the `\"Weeks_on_Top\"` value from the `volume` table where `\"Volume_ID\"` matches the input. Otherwise, return NULL.",
    "natural_language": "Define a function called `get_volume_weeks_on_top` that accepts an integer parameter `p_volume_id` and yields a REAL value. Should the provided `p_volume_id` exceed zero, the function shall retrieve and return the corresponding `\"Weeks_on_Top\"` figure from the `volume` table, contingent upon a match with the `\"Volume_ID\"` column. In the event that `p_volume_id` is zero or less, the function must return a NULL value.",
    "id": 145
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named is_artist_famous that accepts a single integer input parameter named p_artist_id, which is intended to identify a specific artist record, and returns a boolean value; the function's logic begins by checking if the provided p_artist_id is greater than zero, and if this condition is true, it executes a SELECT query on the artist table to retrieve the value of the column named \"Famous_Title\" for the row where the column \"Artist_ID\" exactly matches the input p_artist_id, and then evaluates whether the length of the retrieved \"Famous_Title\" string is greater than zero characters, returning the result of this boolean expression; if the initial condition that p_artist_id is greater than zero is not met, the function bypasses the query and immediately returns the boolean value FALSE.",
    "plsql": "CREATE OR REPLACE FUNCTION is_artist_famous(p_artist_id INTEGER)\nRETURNS BOOLEAN AS $$\nBEGIN\n    IF p_artist_id > 0 THEN\n        RETURN (SELECT LENGTH(\"Famous_Title\") > 0 FROM artist WHERE \"Artist_ID\" = p_artist_id);\n    END IF;\n    RETURN FALSE;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT is_artist_famous(1);",
      "SELECT is_artist_famous(2);",
      "SELECT is_artist_famous(3);"
    ],
    "summary": "Create a function named `is_artist_famous` that takes an integer `p_artist_id` and returns a BOOLEAN. If `p_artist_id` is greater than 0, return TRUE if the length of the `\"Famous_Title\"` column for the matching `\"Artist_ID\"` in the `artist` table is greater than 0. Otherwise, return FALSE.",
    "natural_language": "Alright, so I need you to whip up a function called `is_artist_famous`. It's gonna take an artist's ID number (`p_artist_id`) and spit back a simple yes/no (that's a BOOLEAN). Here's the deal: first, check if the ID is a positive number. If it's not, just say FALSE. If it is, go look up that artist in the `artist` table. If their `\"Famous_Title\"` has any text in it at all (like, the length is more than zero), then yeah, they're famous—return TRUE. Otherwise, it's a FALSE.",
    "id": 146
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_festival_category that accepts a single integer input parameter named p_festival_id, which is intended to identify a specific festival record, and returns a value of type TEXT. The function begins by evaluating a conditional IF statement to check if the provided p_festival_id is greater than zero. If this condition is true, the function executes a SELECT query on the music_festival table, specifically retrieving the value from the column named \"Category\" for the single row where the value in the column named \"ID\" exactly equals the input p_festival_id, and then immediately returns that retrieved \"Category\" value as the function's result. If the initial condition is false, meaning p_festival_id is zero, negative, or null, the function bypasses the SELECT query and proceeds to return a NULL value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_festival_category(p_festival_id INTEGER)\nRETURNS TEXT AS $$\nBEGIN\n    IF p_festival_id > 0 THEN\n        RETURN (SELECT \"Category\" FROM music_festival WHERE \"ID\" = p_festival_id);\n    END IF;\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT get_festival_category(1);",
      "SELECT get_festival_category(2);",
      "SELECT get_festival_category(3);",
      "SELECT get_festival_category(10);",
      "SELECT get_festival_category(NULL);"
    ],
    "summary": "Create a function named `get_festival_category` that takes an integer `p_festival_id` and returns TEXT. If `p_festival_id` is greater than 0, return the `\"Category\"` value from the `music_festival` table where `\"ID\"` matches the input. Otherwise, return NULL.",
    "natural_language": "Write a function called `get_festival_category` that accepts an integer parameter `p_festival_id` and returns TEXT. For a `p_festival_id` greater than 0, fetch and return the `\"Category\"` from the `music_festival` table where `\"ID\"` equals the provided ID. If the ID is not greater than 0, return NULL.",
    "id": 147
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named \"CountParticipantsInEvent\" that accepts two mandatory input parameters: a BIGINT parameter named \"eventId\" representing a specific event identifier and a BIGINT parameter named \"serviceId\" representing a specific service identifier, and returns an integer value; within the function, a local integer variable named participantCount is declared, then a SELECT statement is executed to calculate a count by querying the \"Participants_in_Events\" table aliased as pie and performing an inner join with the \"Events\" table aliased as e on the condition that the pie.\"Event_ID\" column value equals the e.\"Event_ID\" column value, and the result of the COUNT(*) aggregation is stored into the participantCount variable, where the join is filtered by a WHERE clause requiring that the e.\"Event_ID\" column matches the input \"eventId\" parameter and that the e.\"Service_ID\" column matches the input \"serviceId\" parameter; finally, the function returns the integer value stored in the participantCount variable.",
    "plsql": "CREATE OR REPLACE FUNCTION \"CountParticipantsInEvent\"(\"eventId\" BIGINT, \"serviceId\" BIGINT)\nRETURNS INT\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    participantCount INT;\nBEGIN\n    SELECT COUNT(*) INTO participantCount\n    FROM \"Participants_in_Events\" pie\n    JOIN \"Events\" e ON pie.\"Event_ID\" = e.\"Event_ID\"\n    WHERE e.\"Event_ID\" = \"eventId\" AND e.\"Service_ID\" = \"serviceId\";\n    \n    RETURN participantCount;\nEND;\n$$;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "SELECT \"CountParticipantsInEvent\"(3, 5);",
      "SELECT \"CountParticipantsInEvent\"(8, 8);",
      "SELECT \"CountParticipantsInEvent\"(13, 5);",
      "SELECT \"CountParticipantsInEvent\"(3, 8);",
      "SELECT \"CountParticipantsInEvent\"(8, 5);"
    ],
    "summary": "Create a function named `CountParticipantsInEvent` that takes two BIGINT parameters, `eventId` and `serviceId`, and returns an INTEGER. It should count the participants by querying the `\"Participants_in_Events\"` table (aliased `pie`) joined with the `\"Events\"` table (aliased `e`) on `pie.\"Event_ID\" = e.\"Event_ID\"`, where `e.\"Event_ID\"` equals `eventId` and `e.\"Service_ID\"` equals `serviceId`.",
    "natural_language": "Count the participants by creating a function called `CountParticipantsInEvent`. It must accept two BIGINT parameters, `eventId` and `serviceId`, and return an INTEGER. Perform the count by joining the `\"Participants_in_Events\"` table (as `pie`) with the `\"Events\"` table (as `e`) on `pie.\"Event_ID\" = e.\"Event_ID\"`, filtering where `e.\"Event_ID\"` matches `eventId` and `e.\"Service_ID\"` matches `serviceId`.",
    "id": 148
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named \"GetEventServiceDetails\" that accepts two input parameters: \"eventId\" of type BIGINT, representing the unique identifier for an event, and \"participantId\" of type BIGINT, representing the unique identifier for a participant. This function is designed to retrieve and return the service type code associated with a specific event and participant. Inside the function, a local variable named `serviceDetails` of type TEXT is declared to store the retrieved service type code. The core operation involves a SELECT statement that populates the `serviceDetails` variable. This SELECT statement queries the \"Services\" table, aliased as `s`, the \"Events\" table, aliased as `e`, and the \"Participants_in_Events\" table, aliased as `pie`. The tables are joined based on their relationships: the \"Services\" table (`s`) is joined with the \"Events\" table (`e`) where `s.\"Service_ID\"` matches `e.\"Service_ID\"`, and the \"Events\" table (`e`) is joined with the \"Participants_in_Events\" table (`pie`) where `e.\"Event_ID\"` matches `pie.\"Event_ID\"`. The selection is filtered by a WHERE clause that ensures `e.\"Event_ID\"` matches the input parameter `\"eventId\"` AND `pie.\"Participant_ID\"` matches the input parameter `\"participantId\"`. From the joined and filtered rows, the value of the `s.\"Service_Type_Code\"` column is selected and assigned to the `serviceDetails` variable. Finally, the function returns the value stored in the `serviceDetails` variable, which represents the service type code for the specified event and participant.",
    "plsql": "CREATE OR REPLACE FUNCTION \"GetEventServiceDetails\"(\"eventId\" BIGINT, \"participantId\" BIGINT)\nRETURNS TEXT\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    serviceDetails TEXT;\nBEGIN\n    SELECT s.\"Service_Type_Code\" INTO serviceDetails\n    FROM \"Services\" s\n    JOIN \"Events\" e ON s.\"Service_ID\" = e.\"Service_ID\"\n    JOIN \"Participants_in_Events\" pie ON e.\"Event_ID\" = pie.\"Event_ID\"\n    WHERE e.\"Event_ID\" = \"eventId\" AND pie.\"Participant_ID\" = \"participantId\";\n    \n    RETURN serviceDetails;\nEND;\n$$;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "SELECT \"GetEventServiceDetails\"(3, 26);",
      "SELECT \"GetEventServiceDetails\"(8, 26);",
      "SELECT \"GetEventServiceDetails\"(3, 66);",
      "SELECT \"GetEventServiceDetails\"(8, 66);",
      "SELECT \"GetEventServiceDetails\"(3, 86);"
    ],
    "summary": "Create a function named `GetEventServiceDetails` that takes two BIGINT parameters, `eventId` and `participantId`, and returns TEXT. It should retrieve the `\"Service_Type_Code\"` by joining the `\"Services\"` table (s), `\"Events\"` table (e), and `\"Participants_in_Events\"` table (pie) where `s.\"Service_ID\" = e.\"Service_ID\"` and `e.\"Event_ID\" = pie.\"Event_ID\"`, filtered by the matching `eventId` and `participantId`.",
    "natural_language": "Develop a comprehensive function called `GetEventServiceDetails` which is designed to accept two parameters of type BIGINT, specifically named `eventId` and `participantId`, and which will ultimately return a TEXT value. This function's purpose is to meticulously fetch the detailed `\"Service_Type_Code\"` by performing a join across three key tables: the `\"Services\"` table, which we can alias as 's', the `\"Events\"` table, aliased as 'e', and the `\"Participants_in_Events\"` table, referred to as 'pie'. The joins should be carefully constructed so that `s.\"Service_ID\"` is matched with `e.\"Service_ID\"` and, furthermore, `e.\"Event_ID\"` is matched with `pie.\"Event_ID\"`. The entire query must then be precisely filtered to only include records where the provided `eventId` parameter matches the relevant event identifier and the provided `participantId` parameter matches the corresponding participant identifier.",
    "id": 149
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_total_missions that takes no input parameters and returns a single integer value; the function's purpose is to calculate and return the total count of all rows currently present in the database table named mission by executing a SELECT statement that uses the COUNT(*) aggregate function on the entire mission table without any filtering conditions, joins, or grouping, and directly returns the resulting scalar count value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_missions()\nRETURNS INTEGER AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM mission);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_total_missions();",
      "SELECT * FROM get_total_missions();",
      "SELECT get_total_missions() AS total_missions;",
      "DO $$\nDECLARE\n    total INTEGER;\nBEGIN\n    total := get_total_missions();\n    RAISE NOTICE 'Total missions: %', total;\nEND $$;",
      "SELECT get_total_missions() INTO TEMP TABLE mission_count;"
    ],
    "summary": "Create a PL/pgSQL function named get_total_missions that returns the total row count from the mission table.",
    "natural_language": "Please construct a PL/pgSQL function, designated as `get_total_missions`, which shall return the aggregate number of rows present within the mission table.",
    "id": 150
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the average value of the \"Tonnage\" column from the \"ship\" table. This function, named get_average_tonnage, does not take any parameters and returns a numeric value representing the average tonnage. The function performs a single operation: it executes a SELECT statement to compute the average of all entries in the \"Tonnage\" column of the \"ship\" table using the AVG() aggregate function. The result of this calculation is returned as the output of the function. The function is defined using the PLpgSQL language, and it encapsulates the logic for retrieving the average tonnage from the specified table without any conditional statements or additional logic.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_tonnage()\nRETURNS NUMERIC AS $$\nBEGIN\n    RETURN (SELECT AVG(\"Tonnage\") FROM ship);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_average_tonnage();",
      "SELECT * FROM get_average_tonnage();",
      "SELECT get_average_tonnage() AS avg_tonnage;",
      "SELECT get_average_tonnage() FROM ship LIMIT 1;",
      "SELECT get_average_tonnage() INTO avg_result;"
    ],
    "summary": "Create a PL/pgSQL function named get_average_tonnage that returns the average value of the Tonnage column from the ship table.",
    "natural_language": "Develop a PL/pgSQL function, which should be named get_average_tonnage, that meticulously calculates and returns the precise average value, derived from all entries, for the Tonnage column found within the comprehensive ship table.",
    "id": 151
  },
  {
    "ir": "Write a PLpgSQL function that calculates the average price of lessons for a specific customer by taking a parameter p_customer_id of type bigint, which represents the unique identifier of the customer. The function declares a variable v_average_price of type double precision to store the result of the average calculation. It performs a SELECT operation to compute the average of the \"price\" column from the \"Lessons\" table, filtering the rows where the \"customer_id\" column matches the provided p_customer_id. The result of this average calculation is stored into the v_average_price variable. The function then checks if v_average_price is NULL, which would indicate that there are no lessons associated with the given customer_id. If v_average_price is NULL, the function returns 0.0; otherwise, it returns the calculated average price stored in v_average_price.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_lesson_price(p_customer_id bigint)\nRETURNS double precision AS $$\nDECLARE\n    v_average_price double precision;\nBEGIN\n    SELECT AVG(\"price\") INTO v_average_price FROM \"Lessons\" WHERE \"customer_id\" = p_customer_id;\n    \n    IF v_average_price IS NULL THEN\n        RETURN 0.0;\n    ELSE\n        RETURN v_average_price;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Lessons",
      "Staff",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT calculate_average_lesson_price(1);",
      "SELECT calculate_average_lesson_price(2);",
      "SELECT calculate_average_lesson_price(3);",
      "SELECT calculate_average_lesson_price(6);",
      "SELECT calculate_average_lesson_price(8);"
    ],
    "summary": "Create a PL/pgSQL function that takes a customer_id (bigint) and returns the average price of their lessons. If no lessons are found, return 0.0.",
    "natural_language": "Please construct a PL/pgSQL function that accepts a customer identifier of type bigint as its parameter. The function shall compute and return the average price of all lessons associated with the provided customer. In the event that no lessons are found for the specified customer, the function must return the value 0.0.",
    "id": 152
  },
  {
    "ir": "Write a PLpgSQL function named calculate_total_outstanding_for_customer that accepts a single parameter, p_customer_id, of type bigint, representing the unique identifier of a customer. The function aims to compute the total outstanding amount for the specified customer by performing a SELECT operation on the Customers table. It retrieves the sum of values in the amount_outstanding column for rows where the customer_id column matches the provided p_customer_id. The result of this aggregation is stored in a local variable, v_total_outstanding, of type double precision. The function then evaluates whether v_total_outstanding is NULL, indicating that no matching records were found or the sum resulted in a NULL value. If v_total_outstanding is NULL, the function returns 0.0, signifying no outstanding amount for the customer. Otherwise, it returns the computed sum stored in v_total_outstanding, representing the total outstanding amount for the customer. The function is defined using the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_outstanding_for_customer(p_customer_id bigint)\nRETURNS double precision AS $$\nDECLARE\n    v_total_outstanding double precision;\nBEGIN\n    SELECT SUM(\"amount_outstanding\") INTO v_total_outstanding FROM \"Customers\" WHERE \"customer_id\" = p_customer_id;\n    \n    IF v_total_outstanding IS NULL THEN\n        RETURN 0.0;\n    ELSE\n        RETURN v_total_outstanding;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Lessons",
      "Staff",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT calculate_total_outstanding_for_customer(1);",
      "SELECT calculate_total_outstanding_for_customer(2);",
      "SELECT calculate_total_outstanding_for_customer(3);",
      "SELECT calculate_total_outstanding_for_customer(11);",
      "SELECT calculate_total_outstanding_for_customer(14);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_total_outstanding_for_customer that takes a customer_id (bigint) and returns the sum of their outstanding amount. If no amount is found, return 0.0.",
    "natural_language": "Develop a PL/pgSQL function, which should be named calculate_total_outstanding_for_customer, that is designed to accept a single input parameter: a customer identifier of the bigint data type. This function's primary purpose is to compute and deliver the aggregate sum of all outstanding financial amounts specifically linked to the provided customer. In the event that no relevant records or outstanding amounts are located for that particular customer, the function must gracefully return a default value of 0.0.",
    "id": 153
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_staff_conference_roles` that accepts a single input parameter, `p_staff_id`, which is of type `integer`. This function is designed to return an array of text (`text[]`). Inside the function, a local variable named `roles` of type `text[]` is declared to store the results. The function's logic proceeds through a series of conditional checks.\n\nFirst, it checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id` AND whose `Age` is strictly greater than 30. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" > 30`. If this condition is true, the function then selects all `role` values from the `conference_participation` table where the `staff_ID` matches the input `p_staff_id`. These selected `role` values are collected into an array using `ARRAY(SELECT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id)` and assigned to the `roles` variable.\n\nIf the first condition is false, the function proceeds to an `ELSIF` block. This block checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id` AND whose `Age` is less than or equal to 30. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" <= 30`. If this second condition is true, the function then selects distinct `role` values from the `conference_participation` table where the `staff_ID` matches the input `p_staff_id`. These distinct `role` values are collected into an array using `ARRAY(SELECT DISTINCT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id)` and assigned to the `roles` variable.\n\nIf both the first and second conditions are false, the function proceeds to another `ELSIF` block. This block checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id`. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id`. If this third condition is true (meaning the staff member exists but did not meet the age criteria for the previous two branches), the `roles` variable is assigned a single-element array containing the text literal 'No participation' using `ARRAY['No participation']`.\n\nFinally, if none of the preceding conditions are met (meaning no staff member with the given `p_staff_id` was found in the `staff` table), the function executes the `ELSE` block. In this case, the `roles` variable is assigned a single-element array containing the text literal 'Staff not found' using `ARRAY['Staff not found']`.\n\nAfter evaluating all conditional statements and assigning a value to the `roles` variable, the function returns the final `roles` array.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_conference_roles(p_staff_id integer)\nRETURNS text[] AS $$\nDECLARE\n    roles text[];\nBEGIN\n    IF EXISTS (SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" > 30) THEN\n        SELECT ARRAY(SELECT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id) INTO roles;\n    ELSIF EXISTS (SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" <= 30) THEN\n        SELECT ARRAY(SELECT DISTINCT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id) INTO roles;\n    ELSIF EXISTS (SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id) THEN\n        roles := ARRAY['No participation'];\n    ELSE\n        roles := ARRAY['Staff not found'];\n    END IF;\n    RETURN roles;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_staff_conference_roles(1);",
      "SELECT get_staff_conference_roles(2);",
      "SELECT get_staff_conference_roles(3);",
      "SELECT get_staff_conference_roles(4);",
      "SELECT get_staff_conference_roles(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_staff_conference_roles` that accepts a staff_id parameter and returns a text array. Return all roles if staff age > 30, distinct roles if age ≤ 30, ['No participation'] if staff exists without age criteria, or ['Staff not found'] if staff doesn't exist.",
    "natural_language": "Write a PL/pgSQL function called `get_staff_conference_roles` that takes a staff_id. It should give back a list of text. For staff members who are a bit older, return all their roles. For the younger ones, just the different roles. If the person is on staff but we don't have their age info, say they haven't participated. And if we can't find the staff member at all, indicate they're not found.",
    "id": 154
  },
  {
    "ir": "Write a PLpgSQL function named get_architect_structures that accepts two input parameters: an integer parameter named arch_id representing the unique identifier of an architect, and a text parameter named structure_type specifying the category of structure to count. The function returns a single integer value. The function declares a local integer variable named structure_count to hold the result of the count operation. The function's logic begins with a conditional IF statement that checks if the provided structure_type parameter is exactly equal to the string literal 'bridge'. If this condition evaluates to true, the function executes a SELECT statement that performs a COUNT(*) aggregation on the bridge table, counting all rows where the architect_id column value matches the input arch_id parameter, and stores the resulting count into the structure_count variable. If the condition in the IF statement evaluates to false, meaning the structure_type is not 'bridge', the function executes an alternative SELECT statement that performs a COUNT(*) aggregation on the mill table, counting all rows where the architect_id column value matches the input arch_id parameter, and stores this count into the structure_count variable. After the conditional block, the function returns the value stored in the structure_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_architect_structures(arch_id INTEGER, structure_type TEXT)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    structure_count INTEGER;\nBEGIN\n    IF structure_type = 'bridge' THEN\n        SELECT COUNT(*) INTO structure_count FROM bridge WHERE architect_id = arch_id;\n    ELSE\n        SELECT COUNT(*) INTO structure_count FROM mill WHERE architect_id = arch_id;\n    END IF;\n    \n    RETURN structure_count;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "SELECT get_architect_structures(1, 'bridge');",
      "SELECT get_architect_structures(2, 'mill');",
      "SELECT get_architect_structures(3, 'bridge');",
      "SELECT get_architect_structures(1, 'mill');",
      "SELECT get_architect_structures(2, 'bridge');"
    ],
    "summary": "Create a PL/pgSQL function named get_architect_structures that takes an architect ID (integer) and a structure type (text). It returns an integer count. If the structure type is 'bridge', count the architect's bridges. Otherwise, count the architect's mills.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_architect_structures'. This function shall accept two parameters: an architect identifier of integer type and a structure type of text type. The function is to return an integer value representing a count. The logic is as follows: if the provided structure type is precisely 'bridge', the function must return the count of bridges associated with the specified architect. For any other structure type input, the function must return the count of mills associated with the architect.",
    "id": 155
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_total_length that accepts two input parameters: an integer parameter arch_id representing an architect identifier and a text parameter unit_type specifying the measurement unit, and returns a real number value; the function declares a local real variable total_length, then uses a conditional IF statement to check if the unit_type parameter equals the exact string 'meters'; if true, it executes a SELECT query on the bridge table that uses the COALESCE function to sum the length_meters column for all rows where the architect_id column matches the input arch_id parameter, converting any NULL sum result to 0, and stores the result into the total_length variable; if the condition is false (meaning unit_type is not 'meters'), it executes an alternative SELECT query that similarly uses COALESCE to sum the length_feet column from the same bridge table under the identical condition architect_id = arch_id, also defaulting to 0, and stores that sum into total_length; finally, the function returns the value of the total_length variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_length(arch_id INTEGER, unit_type TEXT)\nRETURNS REAL\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_length REAL;\nBEGIN\n    IF unit_type = 'meters' THEN\n        SELECT COALESCE(SUM(length_meters), 0) INTO total_length FROM bridge WHERE architect_id = arch_id;\n    ELSE\n        SELECT COALESCE(SUM(length_feet), 0) INTO total_length FROM bridge WHERE architect_id = arch_id;\n    END IF;\n    \n    RETURN total_length;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "SELECT calculate_total_length(1, 'meters');",
      "SELECT calculate_total_length(2, 'feet');",
      "SELECT calculate_total_length(3, 'meters');",
      "SELECT calculate_total_length(1, 'feet');",
      "SELECT calculate_total_length(4, 'meters');"
    ],
    "summary": "Create a PL/pgSQL function named calculate_total_length that takes an architect ID (integer) and a unit type (text). It returns a real number. If the unit type is 'meters', sum the length in meters for the architect's bridges. Otherwise, sum the length in feet. Return 0 if no bridges are found.",
    "natural_language": "What is the total length of bridges for a given architect ID, returned in either meters or feet based on the specified unit type?",
    "id": 156
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_account_summary` that accepts a single input parameter, `account_id_input`, which is of data type `BIGINT`. This function is designed to return a set of rows, effectively acting as a table-returning function. The output table will consist of two columns: `account_name` of data type `TEXT` and `date_account_opened` of data type `TIMESTAMPTZ`. The core operation performed by this function is a `SELECT` statement. Specifically, it selects the `account_name` column and the `date_account_opened` column from the table named `\"Accounts\"`, aliased as `a`. The selection of rows is filtered by a `WHERE` clause, which specifies that only those rows where the `account_id` column in the `\"Accounts\"` table (`a.account_id`) is equal to the value provided by the `account_id_input` parameter will be included in the result set. The `RETURN QUERY` statement is used to return the entire result set of this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_account_summary(account_id_input BIGINT)\nRETURNS TABLE(account_name TEXT, date_account_opened TIMESTAMPTZ)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT a.account_name, a.date_account_opened\n    FROM \"Accounts\" a\n    WHERE a.account_id = account_id_input;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Financial_Transactions"
    ],
    "call_sqls": [
      "SELECT * FROM get_account_summary(1);",
      "SELECT * FROM get_account_summary(2);",
      "SELECT * FROM get_account_summary(3);",
      "SELECT * FROM get_account_summary(8);",
      "SELECT * FROM get_account_summary(13);"
    ],
    "summary": "Create a PL/pgSQL function named get_account_summary that takes an account ID (bigint). It returns a table with columns account_name (text) and date_account_opened (timestamptz). The function selects and returns the account name and opening date for the specified account ID.",
    "natural_language": "What is the account name and opening date for a specified account ID? Create a PL/pgSQL function named get_account_summary that takes an account ID (bigint) and returns a table with these columns.",
    "id": 157
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_ship_details` that accepts one input parameter and produces four output parameters. The input parameter, `ship_id`, is of type `integer` and is used to identify a specific ship record. The output parameters are `ship_name` of type `text`, `ship_type` of type `text`, `ship_nationality` of type `text`, and `ship_tonnage` of type `integer`. The function is designed to return a `record` type, which encapsulates these output parameters. The core operation of this function involves a `SELECT` statement. This `SELECT` statement retrieves data from the table named `ship`. Specifically, it selects the values from the columns `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. These retrieved values are then assigned, in order, to the output parameters `ship_name`, `ship_type`, `ship_nationality`, and `ship_tonnage`, respectively. The selection of the row from the `ship` table is constrained by a `WHERE` clause, which specifies that the value in the column `\"Ship_ID\"` must be equal to the value provided by the input parameter `ship_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_ship_details(IN ship_id integer, OUT ship_name text, OUT ship_type text, OUT ship_nationality text, OUT ship_tonnage integer)\nRETURNS record\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT \"Name\", \"Type\", \"Nationality\", \"Tonnage\" INTO ship_name, ship_type, ship_nationality, ship_tonnage FROM ship WHERE \"Ship_ID\" = ship_id;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT * FROM get_ship_details(1);",
      "SELECT * FROM get_ship_details(2);",
      "SELECT * FROM get_ship_details(3);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_ship_details` that takes an integer `ship_id` as input and returns a record containing four output parameters: `ship_name` (text), `ship_type` (text), `ship_nationality` (text), and `ship_tonnage` (integer). The function selects the `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"` columns from the `ship` table where `\"Ship_ID\"` equals the input `ship_id` and assigns them to the respective output parameters.",
    "natural_language": "What PostgreSQL PL/pgSQL function, named `get_ship_details`, takes an integer `ship_id` as input and returns a record with the four output parameters `ship_name` (text), `ship_type` (text), `ship_nationality` (text), and `ship_tonnage` (integer)?",
    "id": 158
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_mission_summary that accepts a single integer input parameter named mission_id, which is used to identify a specific mission record, and returns a result set with a table structure consisting of four columns: mission_code of type text, mission_location of type text, mission_fate of type text, and mission_speed of type integer. The function's body executes a single SQL SELECT query that retrieves data from a table named mission, specifically selecting the values from the columns \"Code\", \"Location\", \"Fate\", and \"Speed_knots\" for every row where the value in the \"Mission_ID\" column is exactly equal to the provided mission_id parameter value, and then returns the complete result set of this query directly as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mission_summary(mission_id integer)\nRETURNS TABLE (\n    mission_code text,\n    mission_location text,\n    mission_fate text,\n    mission_speed integer\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Code\", \"Location\", \"Fate\", \"Speed_knots\"\n    FROM mission\n    WHERE \"Mission_ID\" = mission_id;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT * FROM get_mission_summary(1);",
      "SELECT * FROM get_mission_summary(2);",
      "SELECT * FROM get_mission_summary(3);",
      "SELECT * FROM get_mission_summary(99);",
      "SELECT * FROM get_mission_summary(0);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_mission_summary` that takes an integer `mission_id` as input and returns a table with columns: `mission_code` (text), `mission_location` (text), `mission_fate` (text), and `mission_speed` (integer). The function selects the `\"Code\"`, `\"Location\"`, `\"Fate\"`, and `\"Speed_knots\"` columns from the `mission` table where `\"Mission_ID\"` equals the input `mission_id` and returns the result set.",
    "natural_language": "Write a PostgreSQL function called `get_mission_summary` that fetches some details about a mission when given its ID number. It should give back a table with a mission code, where it happened, what its outcome was, and how fast it was going. Basically, pull the code, location, fate, and speed from the mission table for that specific mission.",
    "id": 159
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and calculates specific mission-related statistics for a given ship. The function, named get_ship_mission_count, accepts an input parameter ship_id of type integer, which identifies the ship for which the statistics are to be gathered. It outputs four values: mission_count, first_mission_year, last_mission_year, and avg_speed, all of which are integers. The function performs a SELECT operation on the mission table, specifically targeting rows where the \"Ship_ID\" column matches the provided ship_id. It calculates the total number of missions by counting the rows, determines the earliest mission year by finding the minimum value in the \"Launched_Year\" column, identifies the latest mission year by finding the maximum value in the \"Launched_Year\" column, and computes the average speed of the missions by averaging the values in the \"Speed_knots\" column. The results of these calculations are stored in the respective output parameters: mission_count, first_mission_year, last_mission_year, and avg_speed.",
    "plsql": "CREATE OR REPLACE FUNCTION get_ship_mission_count(IN ship_id integer, OUT mission_count integer, OUT first_mission_year integer, OUT last_mission_year integer, OUT avg_speed integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COUNT(*), MIN(\"Launched_Year\"), MAX(\"Launched_Year\"), AVG(\"Speed_knots\") INTO mission_count, first_mission_year, last_mission_year, avg_speed FROM mission WHERE \"Ship_ID\" = ship_id;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT * FROM get_ship_mission_count(1);",
      "SELECT * FROM get_ship_mission_count(2);",
      "SELECT * FROM get_ship_mission_count(3);",
      "SELECT * FROM get_ship_mission_count(4);",
      "SELECT * FROM get_ship_mission_count(5);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_ship_mission_count` that takes an integer `ship_id` as input and returns four integer output parameters: `mission_count`, `first_mission_year`, `last_mission_year`, and `avg_speed`. The function calculates these values from the `mission` table where `\"Ship_ID\"` equals `ship_id` by counting rows, finding the minimum and maximum of `\"Launched_Year\"`, and averaging `\"Speed_knots\"`.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `get_ship_mission_count`? It needs to take a ship's ID number as input. The function should spit back four numbers: how many missions the ship had, the year of its first mission, the year of its last mission, and the ship's average speed across all missions. Just grab the info from the `mission` table for that specific ship—count the rows, find the earliest and latest launch years, and work out the average speed in knots.",
    "id": 160
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `CreateArtistSummary` that accepts two input parameters: `p_artist_id`, which is of type `bigint` and represents the unique identifier for an artist, and `p_summary_type`, which is of type `text` and specifies the type of artistic work to summarize. This function is designed to return a table with two columns: `artwork_count` of type `bigint`, representing the total number of artworks, and `avg_year` of type `bigint`, representing the average year of creation for those artworks. The function's logic proceeds conditionally based on the value of the `p_summary_type` parameter. If `p_summary_type` is exactly equal to the string literal 'paintings', the function executes a `SELECT` query to retrieve data from the table named `\"Paintings\"`. This query calculates two aggregate values: first, it counts all rows in the `\"Paintings\"` table using `COUNT(*)`, casting the result to `bigint` to populate the `artwork_count` column; second, it computes the average of the `year` column using `AVG(year)`, then rounds this average to the nearest whole number using `ROUND()`, and finally uses `COALESCE()` to replace any `NULL` result from the `ROUND(AVG(year))` operation with `0`, casting the final result to `bigint` to populate the `avg_year` column. This selection is filtered by a `WHERE` clause, ensuring that only rows where the `\"painterID\"` column matches the input parameter `p_artist_id` are included in the aggregation. If `p_summary_type` is not equal to 'paintings' (implicitly handling any other value, as there's no further `ELSIF` or `ELSE IF` condition), the function executes a different `SELECT` query to retrieve data from the table named `\"Sculptures\"`. Similar to the previous branch, this query also calculates two aggregate values: first, it counts all rows in the `\"Sculptures\"` table using `COUNT(*)`, casting the result to `bigint` for the `artwork_count` column; second, it computes the average of the `year` column using `AVG(year)`, rounds this average using `ROUND()`, and uses `COALESCE()` to substitute `NULL` results with `0`, casting the final result to `bigint` for the `avg_year` column. This selection is filtered by a `WHERE` clause, ensuring that only rows where the `\"sculptorID\"` column matches the input parameter `p_artist_id` are included in this aggregation. In both conditional branches, the `RETURN QUERY` statement is used to return the result set of the executed `SELECT` query as the output table of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION CreateArtistSummary(\n    p_artist_id bigint,\n    p_summary_type text\n)\nRETURNS TABLE(artwork_count bigint, avg_year bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF p_summary_type = 'paintings' THEN\n        RETURN QUERY\n        SELECT COUNT(*)::bigint, COALESCE(ROUND(AVG(year)), 0)::bigint\n        FROM \"Paintings\"\n        WHERE \"painterID\" = p_artist_id;\n    ELSE\n        RETURN QUERY\n        SELECT COUNT(*)::bigint, COALESCE(ROUND(AVG(year)), 0)::bigint\n        FROM \"Sculptures\"\n        WHERE \"sculptorID\" = p_artist_id;\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "SELECT * FROM CreateArtistSummary(111, 'paintings');",
      "SELECT * FROM CreateArtistSummary(222, 'sculptures');",
      "SELECT * FROM CreateArtistSummary(333, 'paintings');",
      "SELECT * FROM CreateArtistSummary(111, 'sculptures');",
      "SELECT * FROM CreateArtistSummary(222, 'paintings');"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `CreateArtistSummary` that takes a `bigint` input `p_artist_id` and a `text` input `p_summary_type`. It returns a table with columns `artwork_count` (bigint) and `avg_year` (bigint). If `p_summary_type` is 'paintings', it queries the `\"Paintings\"` table where `\"painterID\"` equals `p_artist_id`, counting rows and calculating the rounded average of the `year` column (defaulting to 0 if NULL). Otherwise, it performs the same calculations on the `\"Sculptures\"` table where `\"sculptorID\"` equals `p_artist_id`.",
    "natural_language": "Write a function `CreateArtistSummary(p_artist_id bigint, p_summary_type text)` returning table(artwork_count bigint, avg_year bigint). If p_summary_type is 'paintings', count rows and average year from \"Paintings\" where \"painterID\" = p_artist_id. Else, do the same on \"Sculptures\" where \"sculptorID\" = p_artist_id. Round average, default to 0 if null.",
    "id": 161
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named GenerateArtworkReport that returns a table with two columns: painting_dimensions of type bigint and sculpture_count of type bigint, accepting two input text parameters p_location_filter and p_medium_filter, which first calculates the total area in square millimeters for all paintings by selecting from the \"Paintings\" table, summing the product of the \"height_mm\" and \"width_mm\" columns, but only for rows where the \"location\" column exactly matches the p_location_filter parameter and the \"medium\" column exactly matches the p_medium_filter parameter, using the COALESCE function to convert any null sum result to zero and storing this value into the output variable painting_dimensions, then separately counts the total number of sculptures by selecting from the \"Sculptures\" table, using COUNT(*) for rows where the \"location\" column exactly matches the p_location_filter parameter and the \"medium\" column exactly matches the p_medium_filter parameter, storing this count into the output variable sculpture_count, and finally returns a single row containing these two calculated values via the RETURN NEXT statement.",
    "plsql": "CREATE OR REPLACE FUNCTION GenerateArtworkReport(\n    p_location_filter text,\n    p_medium_filter text\n)\nRETURNS TABLE (\n    painting_dimensions bigint,\n    sculpture_count bigint\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COALESCE(SUM(\"height_mm\" * \"width_mm\"), 0) INTO painting_dimensions\n    FROM \"Paintings\"\n    WHERE \"location\" = p_location_filter AND \"medium\" = p_medium_filter;\n    \n    SELECT COUNT(*) INTO sculpture_count\n    FROM \"Sculptures\"\n    WHERE \"location\" = p_location_filter AND \"medium\" = p_medium_filter;\n    \n    RETURN NEXT;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "SELECT * FROM GenerateArtworkReport('Gallery 240', 'oil');",
      "SELECT * FROM GenerateArtworkReport('Gallery 226', 'bronze');",
      "SELECT * FROM GenerateArtworkReport('Gallery 240', 'conte crayon');",
      "SELECT * FROM GenerateArtworkReport('NonExistentLocation', 'oil');",
      "SELECT * FROM GenerateArtworkReport('Gallery 240', 'NonExistentMedium');"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named GenerateArtworkReport that returns a table with columns painting_dimensions (bigint) and sculpture_count (bigint). It accepts two text parameters: p_location_filter and p_medium_filter. The function calculates the total area (height_mm * width_mm) for paintings matching the filters, using COALESCE to return zero for null results. It also counts sculptures matching the same filters. Return a single row with these two values.",
    "natural_language": "Construct a PostgreSQL PL/pgSQL function called GenerateArtworkReport, which is designed to produce a result table containing precisely two columns: painting_dimensions, defined as a bigint type, and sculpture_count, also defined as a bigint type. This comprehensive function must accept two distinct text parameters, specifically named p_location_filter and p_medium_filter, which serve as filters for the data. Within its detailed logic, the function meticulously computes the aggregate total area—derived by multiplying height_mm and width_mm—for all painting records that correspond to the provided filter criteria, thoughtfully employing the COALESCE function to ensure a zero is returned in place of any null outcome. Concurrently, it carefully tallies the number of sculpture entries that similarly match the very same set of filters. Ultimately, the function returns a single, consolidated row that elegantly presents both of these calculated values.",
    "id": 162
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `CalculateArtistMetrics` that accepts two input parameters: `p_birth_year_threshold`, which is of type `bigint`, and `p_death_year_threshold`, also of type `bigint`. This function is designed to return a table with two columns: `p_living_artists` of type `bigint` and `p_total_artworks` of type `bigint`. The function's execution begins by performing a `SELECT` operation to count the number of artists. This count is stored into the `p_living_artists` output variable. The `SELECT` statement targets the `\"Artists\"` table. The filtering condition for this count requires that the `\"birthYear\"` column in the `\"Artists\"` table must be greater than or equal to the value provided in the `p_birth_year_threshold` input parameter. Additionally, for an artist to be included in this count, their `\"deathYear\"` column must either be `NULL` (indicating they are still alive or their death year is unknown) OR their `\"deathYear\"` must be greater than or equal to the value provided in the `p_death_year_threshold` input parameter. Following this, another `SELECT` operation is performed to calculate the total number of artworks. This calculation involves two subqueries. The first subquery performs a `COUNT(*)` operation on the `\"Paintings\"` table to get the total number of paintings. The second subquery performs a `COUNT(*)` operation on the `\"Sculptures\"` table to get the total number of sculptures. The results of these two subqueries are then summed together, and this combined total is stored into the `p_total_artworks` output variable. Finally, the function returns the current values of `p_living_artists` and `p_total_artworks` as a single row in the result table.",
    "plsql": "CREATE OR REPLACE FUNCTION CalculateArtistMetrics(\n    p_birth_year_threshold bigint,\n    p_death_year_threshold bigint\n)\nRETURNS TABLE(p_living_artists bigint, p_total_artworks bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COUNT(*) INTO p_living_artists\n    FROM \"Artists\"\n    WHERE \"birthYear\" >= p_birth_year_threshold \n    AND (\"deathYear\" IS NULL OR \"deathYear\" >= p_death_year_threshold);\n    \n    SELECT \n        (SELECT COUNT(*) FROM \"Paintings\") + \n        (SELECT COUNT(*) FROM \"Sculptures\")\n    INTO p_total_artworks;\n    \n    RETURN NEXT;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "SELECT * FROM CalculateArtistMetrics(1900, 1950);",
      "SELECT * FROM CalculateArtistMetrics(1850, 1900);",
      "SELECT * FROM CalculateArtistMetrics(1920, 1980);",
      "SELECT * FROM CalculateArtistMetrics(1800, 1850);",
      "SELECT * FROM CalculateArtistMetrics(1950, 2000);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named CalculateArtistMetrics that returns a table with columns p_living_artists (bigint) and p_total_artworks (bigint). It accepts two bigint parameters: p_birth_year_threshold and p_death_year_threshold. Count artists where birthYear >= p_birth_year_threshold and (deathYear IS NULL OR deathYear >= p_death_year_threshold). Calculate total artworks as the sum of counts from the Paintings and Sculptures tables. Return a single row with these counts.",
    "natural_language": "Construct a PostgreSQL PL/pgSQL function called CalculateArtistMetrics that yields a table containing two bigint columns: p_living_artists and p_total_artworks. This function must accept two bigint parameters, specifically p_birth_year_threshold and p_death_year_threshold. To determine the count of living artists, meticulously consider only those artists whose recorded birthYear is greater than or equal to the provided p_birth_year_threshold and, importantly, who either have a deathYear that is entirely unknown (NULL) or whose documented deathYear is greater than or equal to the supplied p_death_year_threshold. Subsequently, for the total artworks, you must comprehensively calculate the sum by aggregating the individual counts from both the Paintings table and the Sculptures table. Finally, the function should return a single, consolidated row that neatly presents both of these carefully computed counts.",
    "id": 163
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_conference_count_by_year that takes no input parameters and returns a single integer value, where the function's logic executes a SELECT query on the conference table to compute the total count of all rows where the value in the column named \"Year\" is exactly equal to 2003, and then returns this computed count as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_conference_count_by_year()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM conference WHERE \"Year\" = 2003);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_conference_count_by_year();",
      "SELECT * FROM get_conference_count_by_year();",
      "DO $$\nDECLARE\n    count_result INTEGER;\nBEGIN\n    count_result := get_conference_count_by_year();\n    RAISE NOTICE 'Conference count for year 2003: %', count_result;\nEND $$;",
      "SELECT get_conference_count_by_year() AS conference_count_2003;",
      "WITH result AS (\n    SELECT get_conference_count_by_year() AS count\n)\nSELECT count FROM result;"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_conference_count_by_year with no parameters that returns an integer. It counts rows from the conference table where the \"Year\" column equals 2003 and returns the count.",
    "natural_language": "Write a function called get_conference_count_by_year that gives back a number. It should figure out roughly how many conferences happened around the year 2003 or so, by looking through the conference records and checking the year.",
    "id": 164
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_staff_count_by_nationality that takes no input parameters and returns a single integer value, where the function's body executes a SELECT query on the staff table to count all rows using the COUNT(*) aggregate function, applying a filter condition that restricts the count to only those rows where the value in the column named \"Nationality\" is exactly equal to the string literal 'United States', and the function then directly returns the resulting scalar count value from this query.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_count_by_nationality()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM staff WHERE \"Nationality\" = 'United States');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_staff_count_by_nationality();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_staff_count_by_nationality with no parameters that returns an integer. It counts rows from the staff table where the \"Nationality\" column equals 'United States' and returns the count.",
    "natural_language": "Develop a PostgreSQL PL/pgSQL function, which should be named get_staff_count_by_nationality, that accepts no parameters and yields an integer as its return value. This function meticulously calculates and provides the total number of records within the staff table specifically where the \"Nationality\" column is precisely set to the value 'United States'.",
    "id": 165
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_institution_count_by_location` that is designed to return a single integer value. This function takes no input parameters. Upon execution, the function performs a `SELECT` operation to count the total number of rows in the table named `institution`. The counting operation is subject to a filtering condition: only rows where the value in the column named `\"Location\"` is exactly equal to the string literal `'Peoria, Illinois'` (case-sensitive comparison) are included in the count. The result of this `COUNT(*)` aggregation, representing the total number of institutions found matching the specified location, is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_institution_count_by_location()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM institution WHERE \"Location\" = 'Peoria, Illinois');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_institution_count_by_location();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_institution_count_by_location with no parameters that returns an integer. It counts rows from the institution table where the \"Location\" column equals 'Peoria, Illinois' and returns the count.",
    "natural_language": "Count the institutions located in 'Peoria, Illinois' and return the total number.",
    "id": 166
  },
  {
    "ir": "Write a PLpgSQL function named get_conference_participation_count_by_role that takes no input parameters and returns a single integer value, where the function body executes a SELECT statement that queries the conference_participation table, specifically performing a COUNT(*) aggregation on all rows in that table where the value in the role column is exactly equal to the string literal 'Speaker', and the function then returns the resulting scalar count value as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_conference_participation_count_by_role()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM conference_participation WHERE role = 'Speaker');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_conference_participation_count_by_role();"
    ],
    "summary": "Create a PL/pgSQL function named get_conference_participation_count_by_role with no parameters that returns an integer. The function should count all rows in the conference_participation table where the role column equals 'Speaker' and return that count.",
    "natural_language": "Please construct a PL/pgSQL function, designated as 'get_conference_participation_count_by_role', which accepts no parameters and yields an integer value. The function's purpose is to compute the total number of entries within the 'conference_participation' table for which the 'role' column is specified as 'Speaker', and subsequently return this computed count.",
    "id": 167
  },
  {
    "ir": "Write a PL/pgSQL function named `get_latest_conference_year` that is designed to retrieve the maximum year value from the `conference` table. This function does not accept any input parameters. It is declared to return a single integer value. The core logic of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `conference` table and applies the `MAX` aggregate function to the column named `\"Year\"`. The `MAX` function calculates the highest value present in the `\"Year\"` column across all rows in the `conference` table. The result of this `SELECT` statement, which is the single maximum year value, is then returned as the output of the `get_latest_conference_year` function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_conference_year()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT MAX(\"Year\") FROM conference);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_latest_conference_year();",
      "SELECT * FROM conference WHERE \"Year\" = get_latest_conference_year();",
      "INSERT INTO conference (\"Conference_Name\", \"Year\", \"Location\") VALUES ('NewConf', get_latest_conference_year() + 1, 'USA');",
      "SELECT get_latest_conference_year() AS latest_year;",
      "SELECT \"Conference_Name\", \"Year\" FROM conference WHERE \"Year\" = get_latest_conference_year();"
    ],
    "summary": "Create a PL/pgSQL function named get_latest_conference_year with no parameters that returns an integer. The function should return the maximum value from the \"Year\" column in the conference table.",
    "natural_language": "What is the maximum year in the conference table? Create a PL/pgSQL function named get_latest_conference_year with no parameters to return this integer value.",
    "id": 168
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_country_roller_coasters` that is designed to retrieve aggregated statistical information about roller coasters located in a specific country. This function accepts one input parameter and produces three output parameters. The input parameter, `country_id`, is of type `INTEGER` and serves to identify the specific country for which the roller coaster data should be aggregated. The first output parameter, `coaster_count`, is of type `INTEGER` and will store the total number of roller coasters found for the specified country. The second output parameter, `total_length`, is of type `REAL` and will store the sum of the lengths of all roller coasters in that country. The third output parameter, `average_height`, is of type `REAL` and will store the average height of all roller coasters in that country. The function's return type is `record`, which is a composite type used to return multiple values. The core logic of the function involves a single `SELECT` statement. This `SELECT` statement performs three aggregate calculations: `COUNT(*)`, `SUM(\"Length\")`, and `AVG(\"Height\")`. `COUNT(*)` calculates the total number of rows (roller coasters). `SUM(\"Length\")` calculates the sum of values from the `\"Length\"` column. `AVG(\"Height\")` calculates the average of values from the `\"Height\"` column. These calculated aggregate values are then assigned, in order, to the output parameters `coaster_count`, `total_length`, and `average_height` using the `INTO` clause. The data for these calculations is sourced from the table named `roller_coaster`. The selection of rows from the `roller_coaster` table is filtered by a `WHERE` clause. The condition in the `WHERE` clause is `\"Country_ID\" = country_id`, which ensures that only roller coaster records where the value in the `\"Country_ID\"` column matches the value provided by the input parameter `country_id` are included in the aggregation.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_roller_coasters(IN country_id INTEGER, OUT coaster_count INTEGER, OUT total_length REAL, OUT average_height REAL)\nRETURNS record\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COUNT(*), SUM(\"Length\"), AVG(\"Height\")\n    INTO coaster_count, total_length, average_height\n    FROM roller_coaster\n    WHERE \"Country_ID\" = country_id;\nEND;\n$$;",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "SELECT * FROM get_country_roller_coasters(1);",
      "SELECT * FROM get_country_roller_coasters(2);",
      "SELECT * FROM get_country_roller_coasters(3);",
      "SELECT * FROM get_country_roller_coasters(10);",
      "SELECT * FROM get_country_roller_coasters(99);"
    ],
    "summary": "Create a PL/pgSQL function named get_country_roller_coasters that takes an integer country_id parameter and returns a record with three output parameters: coaster_count (integer), total_length (real), and average_height (real). The function should calculate the count, sum of \"Length\", and average of \"Height\" from the roller_coaster table where \"Country_ID\" matches the input parameter.",
    "natural_language": "What are the count, total length, and average height of roller coasters for a given country ID?",
    "id": 169
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_country_details` that accepts a single input parameter named `country_id` of data type `INTEGER`. This function is designed to return a set of rows, effectively acting as a table, with each row containing three columns: `country_name` of data type `TEXT`, `population` of data type `INTEGER`, and `area` of data type `INTEGER`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves specific column values from a table named `country`. Specifically, it selects the column named `\"Name\"` and aliases it as `country_name` in the output, the column named `\"Population\"` and aliases it as `population` in the output, and the column named `\"Area\"` and aliases it as `area` in the output. The selection of rows from the `country` table is filtered by a `WHERE` clause. This `WHERE` clause specifies that only those rows where the value in the column named `\"Country_ID\"` is exactly equal to the value provided in the input parameter `country_id` should be included in the result set. The `RETURN QUERY` statement then outputs the entire result set generated by this `SELECT` statement as the function's return value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_details(country_id INTEGER)\nRETURNS TABLE(country_name TEXT, population INTEGER, area INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Name\", \"Population\", \"Area\"\n    FROM country\n    WHERE \"Country_ID\" = country_id;\nEND;\n$$;",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "SELECT * FROM get_country_details(1);",
      "SELECT * FROM get_country_details(2);",
      "SELECT * FROM get_country_details(3);"
    ],
    "summary": "Create a PL/pgSQL function named get_country_details that takes an integer country_id parameter and returns a table with columns country_name (text), population (integer), and area (integer). The function should query the country table, selecting the \"Name\", \"Population\", and \"Area\" columns where \"Country_ID\" equals the input parameter.",
    "natural_language": "Construct a PL/pgSQL function called get_country_details, which accepts a single integer parameter representing a country_id, and is designed to return a result set comprising the columns country_name (as text), population (as an integer), and area (also as an integer). This detailed function should perform a precise query on the country table, carefully selecting the specific \"Name\", \"Population\", and \"Area\" columns exclusively for the record where the \"Country_ID\" perfectly matches the provided input parameter.",
    "id": 170
  },
  {
    "ir": "Write a PLpgSQL function named get_average_rating that accepts two parameters: p_book_id of type integer, which specifies the identifier of a book, and p_min_rank of type integer, which sets the minimum rank threshold for reviews to be considered. The function calculates the average rating of reviews from the review table, where the Book_ID column matches the value of p_book_id and the Rank column is greater than or equal to p_min_rank. It performs a SELECT operation to compute the average of the Rating column for the filtered reviews and stores the result in a local variable named avg_rating of type real. If no reviews meet the criteria, the function uses the COALESCE function to return 0.0 instead of a NULL value. The function returns the computed average rating as a real number.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_rating(p_book_id integer, p_min_rank integer)\nRETURNS real AS $$\nDECLARE\n    avg_rating real;\nBEGIN\n    SELECT AVG(r.\"Rating\") INTO avg_rating\n    FROM \"review\" r\n    WHERE r.\"Book_ID\" = p_book_id AND r.\"Rank\" >= p_min_rank;\n    RETURN COALESCE(avg_rating, 0.0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT get_average_rating(1, 10);",
      "SELECT get_average_rating(2, 15);",
      "SELECT get_average_rating(3, 20);",
      "SELECT get_average_rating(1, 0);",
      "SELECT get_average_rating(4, 5);"
    ],
    "summary": "Create a function named get_average_rating that takes a book ID and a minimum rank as integers. It returns the average rating from the review table for that book where the rank meets the threshold, or 0.0 if no reviews are found.",
    "natural_language": "Define a function called get_average_rating that accepts a book ID and a minimum rank as integer inputs. Return the average rating from the review table for the specified book, but only for reviews with a rank at or above the given threshold. If no matching reviews exist, return 0.0.",
    "id": 171
  },
  {
    "ir": "Write a PLpgSQL function named get_total_readers that accepts two input parameters: an integer parameter p_book_id representing a specific book identifier and a real number parameter p_min_rating representing a minimum rating threshold, and returns a real number value; the function declares a local real variable named total_readers, then executes a SELECT query that calculates the sum of the \"Readers_in_Million\" column values from the \"review\" table, aliased as r, for all rows where the \"Book_ID\" column equals the input parameter p_book_id and the \"Rating\" column is greater than or equal to the input parameter p_min_rating, storing the result of this summation into the total_readers variable; the function concludes by returning the value stored in total_readers, but uses the COALESCE function to substitute a value of 0.0 if the total_readers variable is null, which occurs when the SELECT query finds no matching rows or the sum of \"Readers_in_Million\" is null.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_readers(p_book_id integer, p_min_rating real)\nRETURNS real AS $$\nDECLARE\n    total_readers real;\nBEGIN\n    SELECT SUM(r.\"Readers_in_Million\") INTO total_readers\n    FROM \"review\" r\n    WHERE r.\"Book_ID\" = p_book_id AND r.\"Rating\" >= p_min_rating;\n    RETURN COALESCE(total_readers, 0.0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT get_total_readers(1, 6.0);",
      "SELECT get_total_readers(2, 5.5);",
      "SELECT get_total_readers(3, 6.5);",
      "SELECT get_total_readers(1, 5.0);",
      "SELECT get_total_readers(3, 5.8);"
    ],
    "summary": "Create a function named get_total_readers that takes a book ID (integer) and a minimum rating (real). It returns the sum of readers (in millions) from the review table for that book with ratings meeting the threshold, or 0.0 if no matches are found.",
    "natural_language": "Create a function called get_total_readers, which accepts a specific book ID as an integer and a minimum acceptable rating as a real number. This function should meticulously calculate and return the cumulative sum, expressed in millions, of all readers documented in the review table specifically for the given book, but only for those reviews whose ratings are equal to or surpass the provided threshold. In the event that no such qualifying reviews are discovered, the function must gracefully return a default value of 0.0.",
    "id": 172
  },
  {
    "ir": "Write a PLpgSQL function named get_highest_ranked_review that accepts two input parameters: an integer parameter named p_book_id representing a specific book identifier and a real number parameter named p_min_readers representing a minimum reader count threshold in millions, and returns an integer value; the function declares a local integer variable named highest_rank, then executes a SELECT query on the table named \"review\" (aliased as r) to retrieve the minimum value from the column named \"Rank\" for all rows where the column \"Book_ID\" equals the input parameter p_book_id and the column \"Readers_in_Million\" is greater than or equal to the input parameter p_min_readers, storing the result into the highest_rank variable; the function concludes by returning the value of highest_rank using the COALESCE function, which substitutes a value of 0 if the highest_rank variable is null.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_ranked_review(p_book_id integer, p_min_readers real)\nRETURNS integer AS $$\nDECLARE\n    highest_rank integer;\nBEGIN\n    SELECT MIN(r.\"Rank\") INTO highest_rank\n    FROM \"review\" r\n    WHERE r.\"Book_ID\" = p_book_id AND r.\"Readers_in_Million\" >= p_min_readers;\n    RETURN COALESCE(highest_rank, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT get_highest_ranked_review(1, 2.0);",
      "SELECT get_highest_ranked_review(2, 1.5);",
      "SELECT get_highest_ranked_review(3, 3.0);",
      "SELECT get_highest_ranked_review(1, 0.5);",
      "SELECT get_highest_ranked_review(4, 2.5);"
    ],
    "summary": "Create a function named get_highest_ranked_review that takes a book ID (integer) and a minimum reader count in millions (real). It returns the best (lowest) rank from the review table for that book with reader counts meeting the threshold, or 0 if no matches are found.",
    "natural_language": "Create a function called get_highest_ranked_review that needs a book's ID number and a certain minimum number of readers, in the millions. It should give back the top rank from the reviews for that book, but only for reviews that have a decently high reader count. If nothing fits these somewhat loose criteria, just return 0.",
    "id": 173
  },
  {
    "ir": "Write a PLpgSQL function that returns a table with two columns: grade_level of type integer and friend_count of type bigint. The function performs a query operation that selects data from the \"Highschooler\" table and the \"Friend\" table. It uses a LEFT JOIN to combine these tables based on the condition that the \"ID\" column in the \"Highschooler\" table matches the student_id column in the \"Friend\" table. The query groups the results by the grade column from the \"Highschooler\" table and counts the number of friend_id entries from the \"Friend\" table for each grade level. The results are ordered by the grade column in ascending order. The function does not take any input parameters and is defined using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION count_friends_by_grade()\nRETURNS TABLE(grade_level integer, friend_count bigint) AS\n$$\nBEGIN\nRETURN QUERY SELECT h.grade, COUNT(f.friend_id) FROM \"Highschooler\" h LEFT JOIN \"Friend\" f ON h.\"ID\" = f.student_id GROUP BY h.grade ORDER BY h.grade;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Highschooler",
      "Friend"
    ],
    "call_sqls": [
      "SELECT * FROM count_friends_by_grade();"
    ],
    "summary": "Create a PL/pgSQL function that returns a table with columns grade_level (integer) and friend_count (bigint). The function should use a LEFT JOIN between the Highschooler and Friend tables on Highschooler.ID = Friend.student_id, group the results by the grade column from Highschooler, count the friend_id entries for each grade, and order the results by grade in ascending order. The function takes no parameters.",
    "natural_language": "Write a PL/pgSQL function that returns a table containing grade_level and friend_count. Use a LEFT JOIN to combine the Highschooler and Friend tables on the ID and student_id fields, group the data by student grade, count the friends for each grade, and sort the output by grade in ascending order. The function should have no input parameters.",
    "id": 174
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `find_students_without_friends` that is designed to return a set of records, where each record conforms to the structure of the `\"Highschooler\"` table. This function takes no input parameters. The core operation of this function is to execute a `SELECT` query. This `SELECT` query retrieves all columns (`*`) from the table named `\"Highschooler\"`, aliased as `h`. The selection of rows from `\"Highschooler\"` is filtered by a `WHERE` clause that employs a `NOT EXISTS` subquery. The `NOT EXISTS` condition evaluates to true for a given row in `\"Highschooler\"` if the subquery returns no rows. The subquery itself is a `SELECT 1` statement, which is a common optimization to check for the existence of rows, from the table named `\"Friend\"`, aliased as `f`. The subquery's `WHERE` clause establishes a correlation between the outer query and the inner query by checking if the `student_id` column in the `\"Friend\"` table (`f.student_id`) is equal to the `ID` column in the `\"Highschooler\"` table (`h.\"ID\"`). In essence, the function identifies and returns all records from the `\"Highschooler\"` table for which there is no corresponding entry in the `\"Friend\"` table where the `student_id` in `\"Friend\"` matches the `ID` of the high school student. The `RETURN QUERY` statement is used to return the result set of this `SELECT` query directly as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION find_students_without_friends()\nRETURNS SETOF \"Highschooler\" AS\n$$\nBEGIN\nRETURN QUERY SELECT * FROM \"Highschooler\" h WHERE NOT EXISTS (SELECT 1 FROM \"Friend\" f WHERE f.student_id = h.\"ID\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Highschooler",
      "Friend"
    ],
    "call_sqls": [
      "SELECT * FROM find_students_without_friends();",
      "SELECT name, grade FROM find_students_without_friends();",
      "SELECT COUNT(*) FROM find_students_without_friends();",
      "SELECT * FROM find_students_without_friends() WHERE grade = 9;",
      "SELECT * FROM find_students_without_friends() ORDER BY name;"
    ],
    "summary": "Create a PL/pgSQL function named find_students_without_friends that returns a set of records matching the Highschooler table structure. The function should select all columns from the Highschooler table where no corresponding record exists in the Friend table with Friend.student_id equal to Highschooler.ID. The function takes no parameters.",
    "natural_language": "Write a function called find_students_without_friends that gives back a bunch of records like the Highschooler table. It should basically pull all details for students where you can't really find any solid friend links for them in the Friend table. The function doesn't need any inputs.",
    "id": 175
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_friend_network_snapshot` that is designed to return a set of records, effectively acting as a table. This function does not accept any input parameters. The function's return type is a table with three columns: `student_name` of type `text`, `friend_count` of type `bigint`, and `snapshot_time` of type `timestamp`. The core operation of this function is to execute a `SELECT` query and return its results. The `SELECT` query retrieves data by joining two tables: `\"Highschooler\"` and `\"Friend\"`. The `\"Highschooler\"` table is aliased as `h`, and the `\"Friend\"` table is aliased as `f`. The join condition specifies that rows from `\"Highschooler\"` and `\"Friend\"` are matched when the `ID` column from the `\"Highschooler\"` table (`h.\"ID\"`) is equal to the `student_id` column from the `\"Friend\"` table (`f.\"student_id\"`). The `SELECT` statement then projects three columns: the `name` column from the `\"Highschooler\"` table (`h.name`), the count of `friend_id` values from the `\"Friend\"` table (`COUNT(f.friend_id)`), and the current transaction timestamp (`transaction_timestamp()`) cast explicitly to a `timestamp` data type. The results of this `SELECT` query are grouped by the `name` column from the `\"Highschooler\"` table (`h.name`). This grouping ensures that for each unique high school student name, a single row is returned, containing their name, the total number of friends associated with that student, and the timestamp at which this snapshot of the data was taken.",
    "plsql": "CREATE OR REPLACE FUNCTION get_friend_network_snapshot()\nRETURNS TABLE(student_name text, friend_count bigint, snapshot_time timestamp) AS\n$$\nBEGIN\nRETURN QUERY SELECT h.name, COUNT(f.friend_id), transaction_timestamp()::timestamp FROM \"Highschooler\" h JOIN \"Friend\" f ON h.\"ID\" = f.\"student_id\" GROUP BY h.name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Highschooler",
      "Friend"
    ],
    "call_sqls": [
      "SELECT * FROM get_friend_network_snapshot();",
      "SELECT student_name, friend_count FROM get_friend_network_snapshot() WHERE friend_count > 5;",
      "SELECT * FROM get_friend_network_snapshot() ORDER BY friend_count DESC;",
      "SELECT student_name, snapshot_time FROM get_friend_network_snapshot() WHERE student_name LIKE 'J%';",
      "SELECT AVG(friend_count) as average_friends FROM get_friend_network_snapshot();"
    ],
    "summary": "Create a PL/pgSQL function named get_friend_network_snapshot that returns a table with columns student_name (text), friend_count (bigint), and snapshot_time (timestamp). The function should join the Highschooler and Friend tables on Highschooler.ID = Friend.student_id, group by student name, count the number of friends for each student, and include the current timestamp. The function takes no parameters.",
    "natural_language": "How can I create a PL/pgSQL function named get_friend_network_snapshot that returns a table with student_name, friend_count, and snapshot_time, which joins the Highschooler and Friend tables on ID, groups by student name, counts each student's friends, and includes the current timestamp without taking any parameters?",
    "id": 176
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_actor_producer_stats that takes a single integer input parameter named p_birth_year and returns a table with three columns: total_actors of type BIGINT, total_producers of type BIGINT, and avg_birth_year of type NUMERIC. The function's logic is determined by conditional branching based on the value of p_birth_year. If p_birth_year is less than 1950, the function executes a query that selects from the actor table, counting all rows where the birth_year column is less than 1950 to populate total_actors, hardcoding total_producers as 0, and calculating the rounded average of the birth_year column for those rows to two decimal places for avg_birth_year. If p_birth_year is between 1950 and 1980 inclusive, the function executes a query that selects from the actor table, counting all rows where the birth_year column is between 1950 and 1980 inclusive to populate both total_actors and total_producers, and calculating the rounded average of the birth_year column for those rows to two decimal places for avg_birth_year. If p_birth_year is greater than 1980, the function executes a query that performs a FULL OUTER JOIN between the actor table (aliased as a) and the producer table (aliased as p) on the condition that a.nationality equals p.nationality, where the filter condition is that either a.birth_year is greater than 1980 or p.birth_year is greater than 1980; from this result set, it calculates total_actors as the distinct count of a.aid, total_producers as the distinct count of p.pid, and avg_birth_year as the rounded average to two decimal places of a COALESCE operation that takes a.birth_year if not null, otherwise p.birth_year. For any other input value of p_birth_year, which specifically handles the NULL case or exact values not caught by the previous branches, the function returns a single row with all three output columns hardcoded to zero.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_producer_stats(p_birth_year INTEGER)\nRETURNS TABLE(total_actors BIGINT, total_producers BIGINT, avg_birth_year NUMERIC) AS $$\nBEGIN\n    IF p_birth_year < 1950 THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, 0::BIGINT as total_producers, ROUND(AVG(birth_year), 2) as avg_birth_year FROM actor WHERE birth_year < 1950;\n    ELSIF p_birth_year BETWEEN 1950 AND 1980 THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, COUNT(*) as total_producers, ROUND(AVG(birth_year), 2) as avg_birth_year FROM actor WHERE birth_year BETWEEN 1950 AND 1980;\n    ELSIF p_birth_year > 1980 THEN\n        RETURN QUERY SELECT COUNT(DISTINCT a.aid) as total_actors, COUNT(DISTINCT p.pid) as total_producers, ROUND(AVG(COALESCE(a.birth_year, p.birth_year)), 2) as avg_birth_year FROM actor a FULL OUTER JOIN producer p ON a.nationality = p.nationality WHERE a.birth_year > 1980 OR p.birth_year > 1980;\n    ELSE\n        RETURN QUERY SELECT 0::BIGINT as total_actors, 0::BIGINT as total_producers, 0::NUMERIC as avg_birth_year;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "producer",
      "made_by",
      "company"
    ],
    "call_sqls": [
      "SELECT * FROM get_actor_producer_stats(1940);",
      "SELECT * FROM get_actor_producer_stats(1955);",
      "SELECT * FROM get_actor_producer_stats(1990);",
      "SELECT * FROM get_actor_producer_stats(NULL);",
      "SELECT total_actors, total_producers, avg_birth_year FROM get_actor_producer_stats(1975);"
    ],
    "summary": "Create a PL/pgSQL function named get_actor_producer_stats that takes an integer parameter p_birth_year and returns a table with columns total_actors (BIGINT), total_producers (BIGINT), and avg_birth_year (NUMERIC). If p_birth_year < 1950, count actors with birth_year < 1950, set producers to 0, and calculate the rounded average birth_year. If p_birth_year is between 1950 and 1980 inclusive, count actors and producers with birth_year in that range and calculate the rounded average. If p_birth_year > 1980, perform a FULL OUTER JOIN between actor and producer tables on nationality where either birth_year > 1980, then calculate distinct counts and the rounded average of birth years. For any other input (including NULL), return a row with all zeros.",
    "natural_language": "Write a function called get_actor_producer_stats that takes a birth year number. It should give back a table with the total number of actors, total number of producers, and an average birth year. The way it counts things depends on the input year in a kind of fuzzy way. If the given year is pretty old, like before 1950, then just count the older actors and ignore producers, also figure out the typical birth year from that group. If the year is sort of in the middle, say between 1950 and around 1980, then count both actors and producers from roughly that era and get their average year. For more recent years, after 1980, you need to loosely combine data from actors and producers based on where they're from, but only for the newer people, then count them and find an average. If the input is weird or missing, just return zeros for everything.",
    "id": 177
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_nationality_stats` that accepts a single input parameter, `p_nationality`, which is of type `TEXT`. This function is designed to return a table-like result set with two columns: `total_actors` of type `BIGINT` and `total_producers` of type `BIGINT`. The function's logic proceeds conditionally based on the value of the `p_nationality` parameter.\n\nIf the value of `p_nationality` is exactly equal to the string literal 'American', the function executes a `SELECT` query. This query counts the total number of rows in the `actor` table where the `nationality` column is equal to 'American'. The result of this count is aliased as `total_actors`. Simultaneously, it returns a constant value of `0` explicitly cast to `BIGINT` as `total_producers`. The results of this query are then returned by the function.\n\nAlternatively, if the value of `p_nationality` is exactly equal to the string literal 'British', the function executes a different `SELECT` query. This query counts the total number of rows in the `producer` table where the `nationality` column is equal to 'British'. The result of this count is aliased as `total_producers`. Concurrently, it returns a constant value of `0` explicitly cast to `BIGINT` as `total_actors`. The results of this query are then returned by the function.\n\nIn all other cases, meaning if `p_nationality` is neither 'American' nor 'British', the function executes a third `SELECT` query. This query performs a Cartesian product (or cross join) between the `actor` table and the `producer` table. From this combined set of rows, it then filters the results to include only those rows where the `nationality` column from the `actor` table is equal to the `nationality` column from the `producer` table. It then counts the total number of rows resulting from this filtered join operation, aliasing this count as `total_actors`. Simultaneously, it also counts the total number of rows from this same filtered join operation, aliasing this second count as `total_producers`. The results of this query are then returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_nationality_stats(p_nationality TEXT)\nRETURNS TABLE(total_actors BIGINT, total_producers BIGINT) AS $$\nBEGIN\n    IF p_nationality = 'American' THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, 0::BIGINT as total_producers FROM actor WHERE nationality = 'American';\n    ELSIF p_nationality = 'British' THEN\n        RETURN QUERY SELECT 0::BIGINT as total_actors, COUNT(*) as total_producers FROM producer WHERE nationality = 'British';\n    ELSE\n        RETURN QUERY SELECT COUNT(*) as total_actors, COUNT(*) as total_producers FROM actor, producer WHERE actor.nationality = producer.nationality;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "producer",
      "made_by",
      "company"
    ],
    "call_sqls": [
      "SELECT * FROM get_nationality_stats('American');",
      "SELECT * FROM get_nationality_stats('British');",
      "SELECT * FROM get_nationality_stats('French');",
      "SELECT * FROM get_nationality_stats('German');",
      "SELECT * FROM get_nationality_stats('Canadian');"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_nationality_stats` that takes a TEXT parameter `p_nationality` and returns a table with columns `total_actors` BIGINT and `total_producers` BIGINT. If `p_nationality` is 'American', count actors with that nationality and return 0 for producers. If it's 'British', count producers with that nationality and return 0 for actors. For any other value, perform a cross join between actor and producer tables, filter where nationalities match, and count rows from both tables.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `get_nationality_stats`? It needs a TEXT parameter, let's call it `p_nationality`. It should spit out a table with two columns: `total_actors` (as a BIGINT) and `total_producers` (also a BIGINT). Here's the deal: if `p_nationality` is 'American', just count up the actors with that nationality and set the producer count to zero. If it's 'British', do the opposite—count the producers and set the actor count to zero. For any other nationality you throw at it, it should do a cross join between the actor and producer tables, filter so the nationalities match, and then count up the rows from both tables.",
    "id": 178
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_birth_city_stats that accepts a single input parameter p_birth_city of type TEXT and returns a table with two columns: total_actors of type BIGINT and total_producers of type BIGINT. The function's logic is determined by the value of the p_birth_city parameter. If the parameter value is exactly equal to the string 'New York', the function executes a query that counts all rows in the actor table where the birth_city column equals 'New York', returns this count as total_actors, and returns a hardcoded zero as total_producers. If the parameter value is exactly equal to the string 'Los Angeles', the function executes a query that counts all rows in the producer table where the birth_city column equals 'Los Angeles', returns this count as total_producers, and returns a hardcoded zero as total_actors. For any other parameter value, the function executes a query that performs a Cartesian product between the actor and producer tables, then counts all rows from the actor table as total_actors and all rows from the producer table as total_producers, but only includes rows in these counts where the birth_city column from the actor table is equal to the birth_city column from the producer table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_birth_city_stats(p_birth_city TEXT)\nRETURNS TABLE(total_actors BIGINT, total_producers BIGINT) AS $$\nBEGIN\n    IF p_birth_city = 'New York' THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, 0::BIGINT as total_producers FROM actor WHERE birth_city = 'New York';\n    ELSIF p_birth_city = 'Los Angeles' THEN\n        RETURN QUERY SELECT 0::BIGINT as total_actors, COUNT(*) as total_producers FROM producer WHERE birth_city = 'Los Angeles';\n    ELSE\n        RETURN QUERY SELECT COUNT(*) as total_actors, COUNT(*) as total_producers FROM actor, producer WHERE actor.birth_city = producer.birth_city;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "producer",
      "made_by",
      "company"
    ],
    "call_sqls": [
      "SELECT * FROM get_birth_city_stats('New York');",
      "SELECT * FROM get_birth_city_stats('Los Angeles');",
      "SELECT * FROM get_birth_city_stats('Chicago');",
      "SELECT * FROM get_birth_city_stats('London');",
      "SELECT * FROM get_birth_city_stats(NULL);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_birth_city_stats` that takes a TEXT parameter `p_birth_city` and returns a table with columns `total_actors` BIGINT and `total_producers` BIGINT. If `p_birth_city` is 'New York', count actors born there and return 0 for producers. If it's 'Los Angeles', count producers born there and return 0 for actors. For other values, perform a cross join between actor and producer tables, filter where birth cities match, and count rows from both tables.",
    "natural_language": "Write a PostgreSQL function called `get_birth_city_stats` that accepts a TEXT input for a city. It should give back a table with two columns: one for the total number of actors and another for the total number of producers, both as BIGINT. If the provided city is roughly 'New York', figure out how many actors come from around there and just put zero for producers. If it's more or less 'Los Angeles', do the opposite—tally up the producers from that general area and set the actor count to nothing. For any other city name, somehow link the actor and producer tables together, find entries where their birth cities seem to match, and then come up with counts for both groups.",
    "id": 179
  },
  {
    "ir": "Write a PL/pgSQL function named `get_movie_rating_status` that accepts a single input parameter named `movie_id` of type `integer`. This function is designed to determine and return the rating status of a specific movie. Internally, it declares two local variables: `rating_count` of type `integer`, initialized to `0`, and `status_text` of type `text`, initialized to the string literal 'No Ratings'. The function then executes a `SELECT` statement to count the number of rows in the table named `\"Rating\"`. This count is performed under the condition that the value in the column named `\"mID\"` within the `\"Rating\"` table is equal to the value provided by the input parameter `movie_id`. The result of this count operation is stored into the local variable `rating_count`. Following this, the function updates the value of the local variable `status_text` based on a conditional `CASE` expression. If the value of `rating_count` is greater than `0`, `status_text` is assigned the string literal 'Has Ratings'; otherwise, if `rating_count` is not greater than `0` (meaning it is `0`), `status_text` retains or is assigned the string literal 'No Ratings'. Finally, the function returns the current value of the `status_text` variable as its output, which is of type `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_rating_status(\"movie_id\" integer)\nRETURNS text AS $$\nDECLARE\n    \"rating_count\" integer := 0;\n    \"status_text\" text := 'No Ratings';\nBEGIN\n    SELECT COUNT(*) INTO \"rating_count\" FROM \"Rating\" WHERE \"mID\" = \"movie_id\";\n    \"status_text\" := CASE WHEN \"rating_count\" > 0 THEN 'Has Ratings' ELSE 'No Ratings' END;\n    RETURN \"status_text\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT get_movie_rating_status(101);",
      "SELECT get_movie_rating_status(102);",
      "SELECT get_movie_rating_status(103);",
      "SELECT get_movie_rating_status(106);",
      "SELECT get_movie_rating_status(104);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_movie_rating_status` that takes an INTEGER parameter `movie_id` and returns TEXT. Count ratings for the given movie ID. If count > 0, return 'Has Ratings'; otherwise return 'No Ratings'.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `get_movie_rating_status`? It should take a movie's ID (as an integer) and spit back some text. Basically, check how many ratings that movie has. If it's got more than zero, just say 'Has Ratings'. If there aren't any, say 'No Ratings'.",
    "id": 180
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_reviewer_average` that accepts a single input parameter named `reviewer_id` of type `integer`. This function is designed to compute and return the average rating (represented as a numeric value) for a specific reviewer identified by the provided `reviewer_id`. The function initializes a local variable named `total_stars` of type `integer` to `0` and another local variable named `avg_rating` of type `numeric` to `0.0`. The first operation performed is a `SELECT` statement that queries the `Rating` table. This `SELECT` statement calculates the sum of all values in the `stars` column for rows where the `rID` column matches the input `reviewer_id`. The `COALESCE` function is applied to this sum, ensuring that if no matching rows are found (and thus `SUM` returns `NULL`), the `total_stars` variable is assigned `0` instead of `NULL`. The result of this sum (or `0`) is then stored into the `total_stars` local variable. Following this, the `avg_rating` local variable is assigned a calculated value. This calculation involves dividing the `total_stars` by the greater of two values: either the count of rows in the `Rating` table where the `rID` column matches the input `reviewer_id`, or `1`. The `GREATEST` function is used to ensure that the divisor is never zero, preventing a division-by-zero error. The `COUNT(*)` aggregate function is used to determine the number of ratings for the specified reviewer. The entire division result is then rounded to two decimal places using the `ROUND` function. Finally, the function returns the calculated `avg_rating` value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_reviewer_average(\"reviewer_id\" integer)\nRETURNS numeric AS $$\nDECLARE\n    \"total_stars\" integer := 0;\n    \"avg_rating\" numeric := 0.0;\nBEGIN\n    SELECT COALESCE(SUM(\"stars\"), 0) INTO \"total_stars\" FROM \"Rating\" WHERE \"rID\" = \"reviewer_id\";\n    \"avg_rating\" := ROUND(\"total_stars\" / GREATEST((SELECT COUNT(*) FROM \"Rating\" WHERE \"rID\" = \"reviewer_id\"), 1), 2);\n    RETURN \"avg_rating\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT calculate_reviewer_average(201);",
      "SELECT calculate_reviewer_average(202);",
      "SELECT calculate_reviewer_average(203);",
      "SELECT calculate_reviewer_average(204);",
      "SELECT calculate_reviewer_average(205);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `calculate_reviewer_average` that takes an INTEGER parameter `reviewer_id` and returns NUMERIC. Calculate the average stars for the reviewer, using COALESCE to handle NULL sums and GREATEST to prevent division by zero. Round the result to two decimal places.",
    "natural_language": "Please construct a PostgreSQL PL/pgSQL function designated `calculate_reviewer_average`. This function shall accept a single INTEGER parameter, `reviewer_id`, and yield a NUMERIC value. The function's logic must compute the average star rating associated with the specified reviewer. It is required to employ the COALESCE function to manage potential NULL values in the sum of stars and the GREATEST function to safeguard against division by zero. The final computed average must be rounded to two decimal places.",
    "id": 181
  },
  {
    "ir": "Write a PLpgSQL function named get_movie_decade that accepts a single parameter movie_id of type integer, which represents the unique identifier of a movie. The function is designed to return a text value indicating the decade in which the movie was released. Within the function, declare a local variable movie_year of type integer initialized to 0, which will store the year of the movie's release, and another local variable decade_label of type text initialized to 'Unknown', which will hold the resulting decade label. The function begins by executing a SELECT statement to retrieve the year column from the Movie table where the mID column matches the provided movie_id parameter. The COALESCE function is used to ensure that if the year column is NULL, the movie_year variable is set to 0. The retrieved year is stored in the movie_year variable. Next, the function calculates the decade by dividing movie_year by 10, flooring the result to remove any fractional part, and then multiplying by 10 to get the starting year of the decade. This calculated decade is concatenated with the letter 's' to form a string representing the decade, which is then assigned to the decade_label variable. Finally, the function returns the value of decade_label, which represents the decade in which the movie was released.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_decade(\"movie_id\" integer)\nRETURNS text AS $$\nDECLARE\n    \"movie_year\" integer := 0;\n    \"decade_label\" text := 'Unknown';\nBEGIN\n    SELECT COALESCE(\"year\", 0) INTO \"movie_year\" FROM \"Movie\" WHERE \"mID\" = \"movie_id\";\n    \"decade_label\" := CONCAT(FLOOR(\"movie_year\" / 10) * 10, 's');\n    RETURN \"decade_label\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT get_movie_decade(101);",
      "SELECT get_movie_decade(102);",
      "SELECT get_movie_decade(103);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_movie_decade` that takes an INTEGER parameter `movie_id` and returns TEXT. Retrieve the movie's release year, calculate the decade by flooring (year/10)*10, append 's' to create the decade label, and return it. Handle NULL years by defaulting to 0.",
    "natural_language": "Write a function `get_movie_decade` that returns a movie's decade as text from its ID. Use floor(year/10)*10, add 's'. Default year to 0 if null.",
    "id": 182
  },
  {
    "ir": "Write a PLpgSQL function named check_rating_exists that accepts two integer input parameters, the first named reviewer_id and the second named movie_id, and returns a boolean value; within the function, it declares a local integer variable named rating_exists initialized to zero and a local boolean variable named result_flag initialized to false; the function executes a SELECT statement that queries the Rating table, using the COUNT(*) aggregate function to count the number of rows where the rID column value equals the input reviewer_id parameter and the mID column value equals the input movie_id parameter, and stores the resulting count into the rating_exists variable; it then evaluates the condition rating_exists > 0, assigning the boolean result of this comparison to the result_flag variable; finally, the function returns the value of the result_flag variable.",
    "plsql": "CREATE OR REPLACE FUNCTION check_rating_exists(\"reviewer_id\" integer, \"movie_id\" integer)\nRETURNS boolean AS $$\nDECLARE\n    \"rating_exists\" integer := 0;\n    \"result_flag\" boolean := false;\nBEGIN\n    SELECT COUNT(*) INTO \"rating_exists\" FROM \"Rating\" WHERE \"rID\" = \"reviewer_id\" AND \"mID\" = \"movie_id\";\n    \"result_flag\" := \"rating_exists\" > 0;\n    RETURN \"result_flag\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT check_rating_exists(201, 101);",
      "SELECT check_rating_exists(202, 106);",
      "SELECT check_rating_exists(203, 101);",
      "SELECT check_rating_exists(201, 102);",
      "SELECT check_rating_exists(202, 103);"
    ],
    "summary": "Create a PLpgSQL function named check_rating_exists that takes reviewer_id and movie_id as integer parameters and returns a boolean. It should check if a rating exists in the Rating table for the given reviewer and movie ID, returning true if found and false otherwise.",
    "natural_language": "Write a PLpgSQL function called check_rating_exists that uses integer inputs for reviewer and movie. It should see if there's any kind of rating in the Rating table for those IDs, giving back true if there seems to be one and false if it looks like there isn't.",
    "id": 183
  },
  {
    "ir": "Write a PLpgSQL function named get_rating_quality that accepts a single parameter, stars_value, of type integer. This function initializes a numeric variable, quality_score, with a default value of 0.0, and a text variable, quality_description, with a default value of 'Poor'. The function calculates the quality_score by multiplying the stars_value by 2.0. It then uses a CASE statement to determine the value of quality_description based on the calculated quality_score: if quality_score is 8 or greater, quality_description is set to 'Excellent'; if quality_score is 6 or greater but less than 8, quality_description is set to 'Good'; otherwise, quality_description remains 'Poor'. Finally, the function returns the quality_description as the result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_rating_quality(\"stars_value\" integer)\nRETURNS text AS $$\nDECLARE\n    \"quality_score\" numeric := 0.0;\n    \"quality_description\" text := 'Poor';\nBEGIN\n    \"quality_score\" := \"stars_value\" * 2.0;\n    \"quality_description\" := CASE WHEN \"quality_score\" >= 8 THEN 'Excellent' WHEN \"quality_score\" >= 6 THEN 'Good' ELSE 'Poor' END;\n    RETURN \"quality_description\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT get_rating_quality(5);",
      "SELECT get_rating_quality(2);",
      "SELECT get_rating_quality(4);",
      "SELECT get_rating_quality(1);",
      "SELECT get_rating_quality(3);"
    ],
    "summary": "Create a PLpgSQL function named get_rating_quality that takes an integer stars_value parameter and returns a text description. It should calculate a quality score (stars_value * 2.0) and return 'Excellent' for score >= 8, 'Good' for score >= 6, and 'Poor' otherwise.",
    "natural_language": "Make a PLpgSQL function get_rating_quality. It takes integer stars_value and returns text. Compute score as stars_value * 2.0. Return 'Excellent' if score >= 8, 'Good' if score >= 6, else 'Poor'.",
    "id": 184
  },
  {
    "ir": "Write a PLpgSQL function named get_attraction_name that accepts a single input parameter named attraction_id of type bigint and returns a value of type text, which begins by declaring a local variable named attraction_name of type text, then enters a nested block that attempts to execute a SELECT query on the table named \"Tourist_Attractions\" to retrieve the value from the column named \"Name\" for the specific row where the column \"Tourist_Attraction_ID\" exactly equals the provided attraction_id parameter, storing the result into the attraction_name variable, and then returns the result of the COALESCE function applied to the attraction_name variable and the literal string 'No name available', which yields the attraction_name if it is not null or the fallback string if it is null, and this nested block includes an exception handler that catches the predefined exception named undefined_table, which executes if the SELECT statement fails because the \"Tourist_Attractions\" table does not exist, and in that case, the function immediately returns the literal string 'Table not available' instead of proceeding with the normal return logic.",
    "plsql": "CREATE OR REPLACE FUNCTION get_attraction_name(attraction_id bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    attraction_name text;\nBEGIN\n    BEGIN\n        SELECT \"Name\" INTO attraction_name\n        FROM \"Tourist_Attractions\"\n        WHERE \"Tourist_Attraction_ID\" = attraction_id;\n        \n        RETURN COALESCE(attraction_name, 'No name available');\n    EXCEPTION\n        WHEN undefined_table THEN\n            RETURN 'Table not available';\n    END;\nEND;\n$$;",
    "database_name": "cre_Theme_park",
    "tables": [
      "Features",
      "Tourist_Attractions",
      "Tourist_Attraction_Features",
      "Theme_Parks",
      "Staff"
    ],
    "call_sqls": [
      "SELECT get_attraction_name(2113);",
      "SELECT get_attraction_name(2701);",
      "SELECT get_attraction_name(5076);",
      "SELECT get_attraction_name(5265);",
      "SELECT get_attraction_name(9999);"
    ],
    "summary": "Create a PLpgSQL function named get_attraction_name that takes a bigint attraction_id parameter and returns text. It should fetch the attraction name from the Tourist_Attractions table. Return the name, 'No name available' if null, or 'Table not available' if the table doesn't exist.",
    "natural_language": "Write a PLpgSQL function called get_attraction_name that accepts a bigint parameter for attraction_id and returns text. Fetch the attraction name from the Tourist_Attractions table. Return the name, 'No name available' if it is null, or 'Table not available' if the table does not exist.",
    "id": 185
  },
  {
    "ir": "Write a PLpgSQL function named `get_related_document` that takes a single input parameter `doc_id` of type `bigint`, representing the identifier of a document, and returns a value of type `bigint`. The function begins by declaring a local variable `related_doc_id` of type `bigint` to store the result. It then checks if there exists at least one row in the table `Document_Subset_Members` within the `public` schema where the column `Document_Object_ID` matches the value of the input parameter `doc_id`. If such a row exists, the function retrieves the value of the column `Related_Document_Object_ID` from the first matching row in the `Document_Subset_Members` table and assigns it to the variable `related_doc_id`. This retrieval is performed using a `SELECT INTO` statement with a `LIMIT 1` clause to ensure only one row is fetched. If no matching row exists in the `Document_Subset_Members` table, the function assigns a `NULL` value to the variable `related_doc_id`. The function then returns the value of `related_doc_id`. Additionally, the function includes an exception handler for the `undefined_table` exception, which occurs if the `Document_Subset_Members` table does not exist, in which case the function returns `NULL`. The function is implemented using the `plpgsql` language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_related_document(doc_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    related_doc_id bigint;\nBEGIN\n    IF EXISTS (\n        SELECT 1\n        FROM public.\"Document_Subset_Members\"\n        WHERE \"Document_Object_ID\" = doc_id\n    ) THEN\n        SELECT \"Related_Document_Object_ID\"\n        INTO related_doc_id\n        FROM public.\"Document_Subset_Members\"\n        WHERE \"Document_Object_ID\" = doc_id\n        LIMIT 1;\n    ELSE\n        related_doc_id := NULL;\n    END IF;\n    RETURN related_doc_id;\nEXCEPTION\n    WHEN undefined_table THEN\n        RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Document_Subsets",
      "Document_Subset_Members"
    ],
    "call_sqls": [
      "SELECT get_related_document(5);",
      "SELECT get_related_document(10);",
      "SELECT get_related_document(100);",
      "SELECT get_related_document(8);",
      "SELECT get_related_document(NULL);"
    ],
    "summary": "Create a PLpgSQL function named get_related_document that takes a bigint doc_id parameter and returns a bigint. It should fetch the Related_Document_Object_ID from the public.Document_Subset_Members table where Document_Object_ID matches doc_id. Return the ID, NULL if not found, or NULL if the table doesn't exist.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_related_document`. This function shall accept a single parameter of type `bigint` named `doc_id` and shall return a value of type `bigint`. Its operational logic is to retrieve the `Related_Document_Object_ID` from the `public.Document_Subset_Members` table, specifically from the row where the `Document_Object_ID` column corresponds to the provided `doc_id` parameter. The function must return the retrieved identifier. In the event that no matching record is located, or if the specified table does not exist within the database, the function should return a NULL value.",
    "id": 186
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_actor_count that takes no input parameters, returns a single integer value, and executes a single operation which is to compute and return the total number of rows present in the actor table by performing a SELECT COUNT(*) query on that table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_count()\nRETURNS INTEGER AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM actor);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_count();",
      "SELECT * FROM get_actor_count();",
      "SELECT get_actor_count() AS total_actors;",
      "DO $$\nDECLARE\n    actor_count INTEGER;\nBEGIN\n    actor_count := get_actor_count();\n    RAISE NOTICE 'Total actors: %', actor_count;\nEND $$;",
      "SELECT get_actor_count() FROM actor LIMIT 1;"
    ],
    "summary": "Create a PLpgSQL function named get_actor_count with no parameters that returns an integer. It should return the total count of rows from the actor table.",
    "natural_language": "Develop a PLpgSQL function, which should be named get_actor_count, that accepts no input parameters and is designed to yield an integer as its return value. This function's purpose is to calculate and provide the comprehensive, total number of all existing rows contained within the actor table.",
    "id": 187
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_average_actor_age that takes no input parameters and returns a single numeric value, which is computed by executing a SELECT query on the actor table to calculate the arithmetic mean of all values contained in its age column, thereby providing the average age of all records stored in that table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_actor_age()\nRETURNS NUMERIC AS $$\nBEGIN\n    RETURN (SELECT AVG(age) FROM actor);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_average_actor_age();",
      "SELECT * FROM get_average_actor_age();",
      "SELECT get_average_actor_age() AS average_age;",
      "SELECT ROUND(get_average_actor_age(), 2) AS rounded_average_age;",
      "SELECT get_average_actor_age() FROM actor LIMIT 1;"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_average_actor_age with no parameters that returns a numeric value representing the average age from the actor table.",
    "natural_language": "Construct a PostgreSQL PL/pgSQL function, which should be named get_average_actor_age, that accepts no parameters and meticulously computes and then returns a single numeric value, which precisely represents the carefully calculated average age of all individuals listed within the actor table.",
    "id": 188
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_oldest_actor_age that takes no input parameters and returns a single integer value; within the function body, it executes a single SQL SELECT query that retrieves the maximum value from the column named age in the table named actor, and this computed maximum integer value is then directly returned as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_actor_age()\nRETURNS INTEGER AS $$\nBEGIN\n    RETURN (SELECT MAX(age) FROM actor);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_oldest_actor_age();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_oldest_actor_age with no parameters that returns an integer representing the maximum age from the actor table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_oldest_actor_age that takes no parameters and returns an integer for the maximum age in the actor table.",
    "id": 189
  },
  {
    "ir": "Write a PLpgSQL function that takes a single numeric parameter emp_id, representing the unique identifier of an employee, and retrieves the full name of the employee from the employees table. The function declares a local variable full_name of type text to store the result. It performs a SELECT query on the employees table, concatenating the values of the FIRST_NAME and LAST_NAME columns with a space in between using the CONCAT function, and assigns the result to the full_name variable. The query filters rows by matching the EMPLOYEE_ID column with the provided emp_id parameter. After the SELECT operation, the function returns the value stored in the full_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_full_name(emp_id numeric)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    full_name text;\nBEGIN\n    SELECT CONCAT(\"FIRST_NAME\", ' ', \"LAST_NAME\") INTO full_name\n    FROM employees\n    WHERE \"EMPLOYEE_ID\" = emp_id;\n    RETURN full_name;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_employee_full_name(100);",
      "SELECT get_employee_full_name(101);",
      "SELECT get_employee_full_name(102);",
      "SELECT get_employee_full_name(103);",
      "SELECT get_employee_full_name(104);"
    ],
    "summary": "Create a PL/pgSQL function that takes an employee ID and returns the employee's full name as text. The function should retrieve the concatenated first and last name from the employees table for the matching employee ID.",
    "natural_language": "How can I write a PL/pgSQL function that, given an employee ID, returns the full name of that employee by concatenating their first and last name from the employees table?",
    "id": 190
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter dept_id of type numeric, retrieves the city name associated with the department identified by the given dept_id, and returns this city name as a text value. The function begins by declaring a local variable location_name of type text to store the result of the query. It then performs a SELECT statement to fetch the value of the \"CITY\" column from the locations table, which is joined with the departments table using the condition that the \"LOCATION_ID\" column in the departments table matches the \"LOCATION_ID\" column in the locations table. The SELECT statement includes a WHERE clause that filters rows in the departments table to only those where the \"DEPARTMENT_ID\" column matches the input parameter dept_id. The result of this query is assigned to the location_name variable using the INTO clause. Finally, the function returns the value stored in location_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_location(dept_id numeric)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    location_name text;\nBEGIN\n    SELECT l.\"CITY\" INTO location_name\n    FROM departments d\n    JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n    WHERE d.\"DEPARTMENT_ID\" = dept_id;\n    RETURN location_name;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_department_location(10);",
      "SELECT get_department_location(20);",
      "SELECT get_department_location(30);",
      "SELECT get_department_location(40);",
      "SELECT get_department_location(50);"
    ],
    "summary": "Create a PL/pgSQL function that takes a department ID and returns the associated city name as text. The function should retrieve the city from the locations table by joining with the departments table on location ID, where the department ID matches the input.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function that, when I give it a department's ID, spits back the city name where that department is? It's gotta look up the city in the locations table by linking it with the departments table using the location ID, but only for the department ID I'm asking about.",
    "id": 191
  },
  {
    "ir": "Write a PL/pgSQL function named `get_region_name_by_country` that accepts a single input parameter named `country_id` of data type `text`. The purpose of this `country_id` parameter is to specify the unique identifier of a country for which the corresponding region name is to be retrieved. The function is designed to return a single value of data type `text`, which will represent the name of the region associated with the provided country identifier.\n\nUpon execution, the function declares a local variable named `region_name` of data type `text` to temporarily store the retrieved region name. The core operation of the function involves executing a `SELECT` statement to fetch data. This `SELECT` statement targets the `REGION_NAME` column from the `regions` table. The value retrieved from `r.\"REGION_NAME\"` is then assigned to the local variable `region_name`.\n\nThe `SELECT` statement performs a `JOIN` operation between two tables: `countries` (aliased as `c`) and `regions` (aliased as `r`). The join condition specifies that rows from `countries` and `regions` tables are matched when the value in the `REGION_ID` column of the `countries` table (`c.\"REGION_ID\"`) is equal to the value in the `REGION_ID` column of the `regions` table (`r.\"REGION_ID\"`).\n\nFurthermore, a `WHERE` clause is applied to filter the results of the join. This `WHERE` clause ensures that only rows where the value in the `COUNTRY_ID` column of the `countries` table (`c.\"COUNTRY_ID\"`) is equal to the value passed in the input parameter `country_id` are considered.\n\nAfter the `SELECT` statement successfully retrieves the `REGION_NAME` and assigns it to the `region_name` variable, the function concludes by returning the value stored in the `region_name` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_name_by_country(country_id text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    region_name text;\nBEGIN\n    SELECT r.\"REGION_NAME\" INTO region_name\n    FROM countries c\n    JOIN regions r ON c.\"REGION_ID\" = r.\"REGION_ID\"\n    WHERE c.\"COUNTRY_ID\" = country_id;\n    RETURN region_name;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_region_name_by_country('AR');",
      "SELECT get_region_name_by_country('AU');",
      "SELECT get_region_name_by_country('BE');",
      "SELECT get_region_name_by_country('IT');",
      "SELECT get_region_name_by_country('JP');"
    ],
    "summary": "Create a PL/pgSQL function named `get_region_name_by_country` that takes a `text` parameter `country_id` and returns the `text` region name. It should join the `countries` and `regions` tables on `REGION_ID` and select the `REGION_NAME` where the `COUNTRY_ID` matches the input parameter.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_region_name_by_country`. This function shall accept a single `text` parameter named `country_id` and is to return a `text` value representing the region name. The implementation must perform an inner join between the `countries` and `regions` tables utilizing the `REGION_ID` column as the join condition. Subsequently, it should select the `REGION_NAME` from the joined result set where the `COUNTRY_ID` column corresponds precisely to the provided input parameter.",
    "id": 192
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_job_id of type text, retrieves the minimum and maximum salary values from the jobs table for the row where the JOB_ID column matches the value of p_job_id, concatenates these values into a single text string in the format \"Min: [MIN_SALARY], Max: [MAX_SALARY]\", and returns this concatenated string. The function begins by declaring a local variable salary_range of type text to store the resulting string. It then performs a SELECT statement on the jobs table, extracting the values of the MIN_SALARY and MAX_SALARY columns for the row where the JOB_ID column equals the input parameter p_job_id. The SELECT statement uses the CONCAT function to combine the literal strings \"Min: \" and \", Max: \" with the values of the MIN_SALARY and MAX_SALARY columns, and assigns the resulting string to the salary_range variable. Finally, the function returns the value of salary_range.",
    "plsql": "CREATE OR REPLACE FUNCTION get_job_salary_range(p_job_id text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    salary_range text;\nBEGIN\n    SELECT CONCAT('Min: ', \"MIN_SALARY\", ', Max: ', \"MAX_SALARY\") INTO salary_range\n    FROM jobs\n    WHERE \"JOB_ID\" = p_job_id;\n    RETURN salary_range;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_job_salary_range('AD_PRES');",
      "SELECT get_job_salary_range('AD_VP');",
      "SELECT get_job_salary_range('AD_ASST');",
      "SELECT get_job_salary_range('IT_PROG');",
      "SELECT get_job_salary_range('SA_REP');"
    ],
    "summary": "Create a PL/pgSQL function that takes a `text` parameter `p_job_id` and returns a `text` string. It should query the `jobs` table for the row matching the `JOB_ID`, concatenate the `MIN_SALARY` and `MAX_SALARY` values into the format \"Min: [MIN_SALARY], Max: [MAX_SALARY]\", and return that string.",
    "natural_language": "Please construct a PL/pgSQL function that accepts a single text parameter designated as `p_job_id` and yields a text string as its output. The function shall execute a query on the `jobs` table to retrieve the record corresponding to the provided `JOB_ID`. Subsequently, it must concatenate the values from the `MIN_SALARY` and `MAX_SALARY` columns into a string formatted as \"Min: [MIN_SALARY], Max: [MAX_SALARY]\", which is to be returned.",
    "id": 193
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_array_dimensions` that takes no input parameters. This function is designed to return a single `text` value representing the dimensions of a specific array. Inside the function's execution block, a local variable named `dimensions` of type `text` is declared. The core operation involves a `SELECT` statement that calls the built-in PostgreSQL function `array_dims()`. The `array_dims()` function is invoked with a literal one-dimensional array `ARRAY[1,2,3,4]` as its argument. This `array_dims()` function calculates and returns a `text` representation of the dimensions of the input array. The result of this `array_dims()` function call is then assigned to the `dimensions` variable. Finally, the function returns the value currently stored in the `dimensions` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_array_dimensions()\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    dimensions text;\nBEGIN\n    SELECT array_dims(ARRAY[1,2,3,4]) INTO dimensions;\n    RETURN dimensions;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_array_dimensions();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_array_dimensions` with no parameters that returns a `text` value. It should assign the result of `array_dims(ARRAY[1,2,3,4])` to a variable and return it.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `get_array_dimensions` that takes no parameters and returns a text value. Assign the output of `array_dims(ARRAY[1,2,3,4])` to a variable and then return that variable.",
    "id": 194
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_student_test_status` that accepts a single input parameter, `student_id_input`, of type `BIGINT`. This function is designed to return a `TEXT` value indicating whether a specific student has taken any tests.\n\nUpon execution, the function declares a local variable named `test_status` of type `TEXT` to store the determined status.\n\nThe core operation of the function involves a `SELECT` statement that queries two tables: `\"Student_Course_Enrolment\"` (aliased as `e`) and `\"Student_Tests_Taken\"` (aliased as `t`). The `SELECT` statement performs a `LEFT JOIN` operation between these two tables. The join condition `e.registration_id = t.registration_id` links records from `\"Student_Course_Enrolment\"` to `\"Student_Tests_Taken\"` based on their common `registration_id` column. This `LEFT JOIN` ensures that all enrolment records for the specified student are considered, even if there are no corresponding test records.\n\nA `WHERE` clause filters the results of the join, specifically targeting records where the `student_id` column in the `\"Student_Course_Enrolment\"` table matches the value provided by the `student_id_input` parameter.\n\nWithin the `SELECT` statement, a `CASE` expression is used to determine the `test_status`. The `CASE` expression evaluates the `COUNT(t.test_result)` aggregate function. This counts the number of non-NULL values in the `test_result` column from the `\"Student_Tests_Taken\"` table for the joined records.\nIf `COUNT(t.test_result)` is greater than `0`, meaning at least one test result exists for the student's enrolments, the `CASE` expression evaluates to the string literal `'Tests Taken'`.\nOtherwise, if `COUNT(t.test_result)` is `0` (indicating no test results or no tests associated with the student's enrolments), the `CASE` expression evaluates to the string literal `'No Tests Taken'`.\n\nThe result of this `CASE` expression is then assigned to the `test_status` local variable using the `INTO` clause.\n\nFinally, the function returns the value stored in the `test_status` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_test_status(student_id_input BIGINT)\nRETURNS TEXT AS $$\nDECLARE\n  test_status TEXT;\nBEGIN\n  SELECT CASE \n           WHEN COUNT(t.test_result) > 0 THEN 'Tests Taken'\n           ELSE 'No Tests Taken'\n         END INTO test_status\n  FROM \"Student_Course_Enrolment\" e\n  LEFT JOIN \"Student_Tests_Taken\" t ON e.registration_id = t.registration_id\n  WHERE e.student_id = student_id_input;\n\n  RETURN test_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_student_test_status(11);",
      "SELECT get_student_test_status(15);",
      "SELECT get_student_test_status(10);",
      "SELECT get_student_test_status(1);",
      "SELECT get_student_test_status(100);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_student_test_status` that takes a `BIGINT` parameter `student_id_input` and returns a `TEXT` status. It should perform a left join between `\"Student_Course_Enrolment\"` and `\"Student_Tests_Taken\"` on `registration_id` for the given student. Use a CASE expression to return 'Tests Taken' if `COUNT(test_result) > 0`, otherwise return 'No Tests Taken'.",
    "natural_language": "Develop a comprehensive PostgreSQL PL/pgSQL function, which should be named `get_student_test_status`, designed to accept a single input parameter of type `BIGINT` called `student_id_input` and to ultimately yield a `TEXT` value representing a status. This function must meticulously execute a left join operation, specifically between the `\"Student_Course_Enrolment\"` table and the `\"Student_Tests_Taken\"` table, using the `registration_id` column as the joining condition, but only for the specific student identified by the provided input parameter. Furthermore, within its logic, it should employ a detailed CASE expression to carefully evaluate the data; if the count of `test_result` entries is determined to be greater than zero, it must thoughtfully return the status message 'Tests Taken', otherwise, it should conclusively return the alternative status message 'No Tests Taken'.",
    "id": 195
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_author_course_count that accepts a single input parameter author_id_input of type BIGINT, which represents the unique identifier of an author, and returns a value of type BIGINT; the function declares a local variable course_count of type BIGINT; it executes a SELECT statement that queries the \"Courses\" table, using the COUNT(*) aggregate function to calculate the total number of rows where the author_id column value is exactly equal to the provided author_id_input parameter, and stores this result into the course_count variable; it then evaluates a conditional IF statement: if the calculated course_count is greater than zero, the function returns the course_count value directly; otherwise, if the course_count is zero or less, the function explicitly returns the integer value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION get_author_course_count(author_id_input BIGINT)\nRETURNS BIGINT AS $$\nDECLARE\n  course_count BIGINT;\nBEGIN\n  SELECT COUNT(*) INTO course_count\n  FROM \"Courses\"\n  WHERE author_id = author_id_input;\n\n  IF course_count > 0 THEN\n    RETURN course_count;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_author_course_count(1);",
      "SELECT get_author_course_count(2);",
      "SELECT get_author_course_count(3);",
      "SELECT get_author_course_count(6);",
      "SELECT get_author_course_count(8);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_author_course_count` that takes a `BIGINT` parameter `author_id_input` and returns a `BIGINT`. It should count rows in the `\"Courses\"` table where `author_id` matches the input. If the count is greater than zero, return the count; otherwise, return 0.",
    "natural_language": "Hey, can you whip up a PostgreSQL function called `get_author_course_count`? It needs to take an `author_id_input` (which is a BIGINT) and spit back a BIGINT. Basically, it should count how many entries in the \"Courses\" table have an `author_id` that matches the one we give it. If it finds any, just give us that count. If it comes up empty, just return a zero.",
    "id": 196
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_student_enrolment_status that accepts a single input parameter called student_id_input of type BIGINT, which represents the unique identifier of a student, and returns a value of type TEXT; the function declares a local variable named enrolment_status of type TEXT to store the result; it performs a SELECT query on the table named \"Student_Course_Enrolment\" (aliased as e), specifically counting the number of registration_id values for rows where the student_id column matches the provided student_id_input parameter; the query uses a CASE expression to evaluate the result of the COUNT(e.registration_id) aggregation: if the count is greater than zero, the expression yields the string literal 'Enrolled', otherwise it yields the string literal 'Not Enrolled'; the result of this CASE expression is assigned into the enrolment_status variable via a SELECT INTO statement; finally, the function returns the value stored in the enrolment_status variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_enrolment_status(student_id_input BIGINT)\nRETURNS TEXT AS $$\nDECLARE\n  enrolment_status TEXT;\nBEGIN\n  SELECT CASE \n           WHEN COUNT(e.registration_id) > 0 THEN 'Enrolled'\n           ELSE 'Not Enrolled'\n         END INTO enrolment_status\n  FROM \"Student_Course_Enrolment\" e\n  WHERE e.student_id = student_id_input;\n\n  RETURN enrolment_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_student_enrolment_status(1);",
      "SELECT get_student_enrolment_status(11);",
      "SELECT get_student_enrolment_status(15);",
      "SELECT get_student_enrolment_status(100);",
      "SELECT get_student_enrolment_status(3);"
    ],
    "summary": "Create a function named get_student_enrolment_status that takes a student_id_input (BIGINT) and returns TEXT. It determines if the student is 'Enrolled' or 'Not Enrolled' by checking for any matching registration_id in the Student_Course_Enrolment table.",
    "natural_language": "Write a function called get_student_enrolment_status that accepts a student_id_input of type BIGINT and outputs TEXT. The function should check the Student_Course_Enrolment table for any matching registration_id and return 'Enrolled' if found, otherwise 'Not Enrolled'.",
    "id": 197
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter subject_id_input of type BIGINT, representing the unique identifier of a subject, and returns a BIGINT value indicating the total number of student registrations associated with courses under that subject. The function begins by declaring a local variable enrolment_count of type BIGINT to store the count of registrations. It then performs a SELECT query to count the number of rows in the \"Student_Course_Enrolment\" table, specifically the registration_id column, where the course_id in the \"Student_Course_Enrolment\" table matches the course_id in the \"Courses\" table, and the subject_id in the \"Courses\" table matches the input parameter subject_id_input. The result of this query is stored in the enrolment_count variable. After the query execution, the function evaluates whether enrolment_count is greater than 0 using an IF conditional statement. If enrolment_count is greater than 0, the function returns the value of enrolment_count; otherwise, it returns 0.",
    "plsql": "CREATE OR REPLACE FUNCTION get_subject_popularity(subject_id_input BIGINT)\nRETURNS BIGINT AS $$\nDECLARE\n  enrolment_count BIGINT;\nBEGIN\n  SELECT COUNT(e.registration_id) INTO enrolment_count\n  FROM \"Student_Course_Enrolment\" e\n  JOIN \"Courses\" c ON e.course_id = c.course_id\n  WHERE c.subject_id = subject_id_input;\n\n  IF enrolment_count > 0 THEN\n    RETURN enrolment_count;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_subject_popularity(1);",
      "SELECT get_subject_popularity(2);",
      "SELECT get_subject_popularity(3);",
      "SELECT get_subject_popularity(100);",
      "SELECT get_subject_popularity(5);"
    ],
    "summary": "Create a function that takes a subject_id_input (BIGINT) and returns a BIGINT count of student registrations for courses under that subject from the Student_Course_Enrolment and Courses tables. Return 0 if the count is zero.",
    "natural_language": "Please construct a function that accepts a subject identifier, of type BIGINT, as its input parameter. This function shall compute and return a BIGINT value representing the total number of student registrations for all courses associated with the specified subject, utilizing data from the Student_Course_Enrolment and Courses tables. In the event that no such registrations are found, the function must return a value of zero.",
    "id": 198
  },
  {
    "ir": "Write a PLpgSQL function named get_student_latest_logon that accepts a single input parameter called student_id_input of type BIGINT, which is used to identify a specific student, and returns a value of type TIMESTAMP. The function declares a local variable named latest_logon of type TIMESTAMP. The function executes a SELECT statement that queries the \"Students\" table, specifically retrieving the value from the column date_of_latest_logon for the row where the column student_id matches the provided student_id_input parameter, and assigns this retrieved value into the local variable latest_logon. Following this retrieval, the function uses an IF-THEN-ELSE conditional statement to evaluate the value of latest_logon. If the latest_logon variable is not NULL, the function returns the value stored in latest_logon. If the latest_logon variable is NULL, the function returns the result of the CURRENT_TIMESTAMP function call, which provides the current date and time from the system at the moment of execution.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_latest_logon(student_id_input BIGINT)\nRETURNS TIMESTAMP AS $$\nDECLARE\n  latest_logon TIMESTAMP;\nBEGIN\n  SELECT date_of_latest_logon INTO latest_logon\n  FROM \"Students\"\n  WHERE student_id = student_id_input;\n\n  IF latest_logon IS NOT NULL THEN\n    RETURN latest_logon;\n  ELSE\n    RETURN CURRENT_TIMESTAMP;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_student_latest_logon(1);",
      "SELECT get_student_latest_logon(2);",
      "SELECT get_student_latest_logon(3);",
      "SELECT get_student_latest_logon(11);",
      "SELECT get_student_latest_logon(15);"
    ],
    "summary": "Create a function named get_student_latest_logon that takes a student_id_input (BIGINT) and returns a TIMESTAMP. It retrieves the student's latest logon date from the Students table. If the date is NULL, return the current timestamp.",
    "natural_language": "Construct a function called get_student_latest_logon, which is designed to accept a single input parameter of type BIGINT representing a student's unique identifier, and which will return a value of type TIMESTAMP. This function's purpose is to meticulously query the Students table in order to extract the most recent logon timestamp specifically associated with the provided student ID. In the event that this retrieved logon date is found to be NULL, the function should thoughtfully and automatically provide the current timestamp as its return value.",
    "id": 199
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_actor_musical_name` that accepts a single input parameter, `p_actor_id`, which is of type `integer`, and is intended to represent the unique identifier of an actor. This function is designed to return a value of type `text`, which will be the name of the musical associated with the provided actor ID. Upon execution, the function declares a local variable named `musical_name` of type `text` to temporarily store the retrieved musical name. The core operation involves a `SELECT` statement that retrieves the value from the `\"Name\"` column of the `musical` table. This retrieved value is then assigned to the `musical_name` local variable. The `SELECT` statement performs an `INNER JOIN` operation between the `musical` table (aliased as `m`) and the `actor` table (aliased as `a`). The join condition specifies that rows from both tables are matched where the value in the `\"Musical_ID\"` column of the `musical` table is equal to the value in the `\"Musical_ID\"` column of the `actor` table. Furthermore, a `WHERE` clause is applied to filter the joined results, ensuring that only rows where the value in the `\"Actor_ID\"` column of the `actor` table is equal to the value of the input parameter `p_actor_id` are considered. Finally, the function returns the value stored in the `musical_name` local variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_musical_name(p_actor_id integer)\nRETURNS text AS $$\nDECLARE\n    musical_name text;\nBEGIN\n    SELECT m.\"Name\" INTO musical_name\n    FROM musical m\n    JOIN actor a ON m.\"Musical_ID\" = a.\"Musical_ID\"\n    WHERE a.\"Actor_ID\" = p_actor_id;\n    RETURN musical_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_musical_name(1);",
      "SELECT get_actor_musical_name(2);",
      "SELECT get_actor_musical_name(3);",
      "SELECT get_actor_musical_name(4);",
      "SELECT get_actor_musical_name(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_actor_musical_name that takes an integer p_actor_id and returns text. It should return the musical's \"Name\" for the given actor by joining the musical and actor tables on Musical_ID.",
    "natural_language": "Write a PL/pgSQL function get_actor_musical_name(p_actor_id integer) returning text. It joins musical and actor on Musical_ID to output the musical's Name for the specified actor.",
    "id": 200
  },
  {
    "ir": "Write a PLpgSQL function named count_actors_in_musical that accepts a single integer input parameter named p_musical_id, which is used to identify a specific musical, and returns an integer value representing a count; within the function, it declares a local integer variable named actor_count, then executes a SELECT statement that queries the actor table to count all rows where the value in the column named \"Musical_ID\" exactly matches the provided p_musical_id parameter, storing the result of this COUNT(*) aggregation into the actor_count variable, and finally returns the value stored in the actor_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION count_actors_in_musical(p_musical_id integer)\nRETURNS integer AS $$\nDECLARE\n    actor_count integer;\nBEGIN\n    SELECT COUNT(*) INTO actor_count\n    FROM actor\n    WHERE \"Musical_ID\" = p_musical_id;\n    RETURN actor_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT count_actors_in_musical(1);",
      "SELECT count_actors_in_musical(2);",
      "SELECT count_actors_in_musical(3);",
      "SELECT count_actors_in_musical(4);",
      "SELECT count_actors_in_musical(5);"
    ],
    "summary": "Create a PL/pgSQL function named count_actors_in_musical that takes an integer p_musical_id and returns an integer. It should count and return the number of actors in the actor table where the \"Musical_ID\" matches the input parameter.",
    "natural_language": "Write a function called count_actors_in_musical that takes a musical ID number and gives back a count. It should figure out roughly how many actors are in the actor list for that specific musical, more or less.",
    "id": 201
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_oldest_actor_age that takes no input parameters and returns a single integer value; within the function, a local integer variable named oldest_age is declared, then a SELECT query is executed on the actor table to compute the maximum value found in the age column, storing that result directly into the oldest_age variable, and finally the function returns the value contained in the oldest_age variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_actor_age()\nRETURNS integer AS $$\nDECLARE\n    oldest_age integer;\nBEGIN\n    SELECT MAX(age) INTO oldest_age\n    FROM actor;\n    RETURN oldest_age;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_oldest_actor_age();"
    ],
    "summary": "Create a PL/pgSQL function named get_oldest_actor_age with no parameters that returns an integer. It should return the maximum age from the actor table.",
    "natural_language": "Write a PL/pgSQL function called get_oldest_actor_age that takes no parameters and returns an integer. The function must return the highest age found in the actor table.",
    "id": 202
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_musical_id of type integer, representing the unique identifier of a musical, and returns an integer value representing the count of nominations for that musical. The function begins by declaring a local variable award_count of type integer to store the result of the query. It then executes a SELECT statement to count the number of rows in the musical table where the Musical_ID column matches the value of the input parameter p_musical_id and the Result column equals the string 'Nominated'. The COUNT(*) function is used to calculate the total number of matching rows, and the result is stored in the award_count variable using the INTO clause. Finally, the function returns the value of award_count, which represents the total number of nominations for the specified musical. The function is written in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_musical_award_count(p_musical_id integer)\nRETURNS integer AS $$\nDECLARE\n    award_count integer;\nBEGIN\n    SELECT COUNT(*) INTO award_count\n    FROM musical\n    WHERE \"Musical_ID\" = p_musical_id AND \"Result\" = 'Nominated';\n    RETURN award_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_musical_award_count(1);",
      "SELECT get_musical_award_count(2);",
      "SELECT get_musical_award_count(3);",
      "SELECT get_musical_award_count(4);",
      "SELECT get_musical_award_count(5);"
    ],
    "summary": "Create a PL/pgSQL function that takes an integer p_musical_id and returns an integer. It should count and return the number of rows in the musical table where Musical_ID matches the input and the Result column is 'Nominated'.",
    "natural_language": "Write a function that, given a musical ID number, gives back a count. It should figure out roughly how many entries in the musical list are for that specific ID and where the outcome is something like being nominated.",
    "id": 203
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_actor_id of type integer, retrieves the value of the \"Character\" column from the actor table for the row where the \"Actor_ID\" column matches the provided p_actor_id, assigns this value to a local variable named character_name of type text, and then returns the value stored in character_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_character(p_actor_id integer)\nRETURNS text AS $$\nDECLARE\n    character_name text;\nBEGIN\n    SELECT \"Character\" INTO character_name\n    FROM actor\n    WHERE \"Actor_ID\" = p_actor_id;\n    RETURN character_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_character(1);",
      "SELECT get_actor_character(2);",
      "SELECT get_actor_character(3);",
      "SELECT get_actor_character(4);",
      "SELECT get_actor_character(5);"
    ],
    "summary": "Create a PLpgSQL function that takes an actor_id integer and returns the corresponding Character name from the actor table as text.",
    "natural_language": "What is the character name for a given actor ID, returned as text?",
    "id": 204
  },
  {
    "ir": "Write a PLpgSQL function named get_major_rankings_by_range that returns a table with three integer columns labeled \"Rank\", \"University_ID\", and \"Major_ID\", and accepts two mandatory integer input parameters named min_rank and max_rank, which define the inclusive lower and upper bounds for filtering ranking data, and whose body executes a single SQL query that selects the \"Rank\", \"University_ID\", and \"Major_ID\" columns from the \"major_ranking\" table for every row where the value in the \"Rank\" column is between the supplied min_rank and max_rank parameter values, and then returns that entire result set directly as the function output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_major_rankings_by_range(min_rank integer, max_rank integer)\nRETURNS TABLE(\"Rank\" integer, \"University_ID\" integer, \"Major_ID\" integer) AS $$\nBEGIN\n    RETURN QUERY SELECT major_ranking.\"Rank\", major_ranking.\"University_ID\", major_ranking.\"Major_ID\"\n    FROM \"major_ranking\"\n    WHERE major_ranking.\"Rank\" BETWEEN min_rank AND max_rank;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM get_major_rankings_by_range(1, 5);",
      "SELECT * FROM get_major_rankings_by_range(10, 20);",
      "SELECT * FROM get_major_rankings_by_range(1, 1);",
      "SELECT * FROM get_major_rankings_by_range(50, 100);",
      "SELECT * FROM get_major_rankings_by_range(25, 30);"
    ],
    "summary": "Create a PLpgSQL function named get_major_rankings_by_range that returns a table (Rank, University_ID, Major_ID) of integers. It takes min_rank and max_rank integer parameters and selects rows from the major_ranking table where Rank is between the parameters.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_major_rankings_by_range`. This function shall yield a table comprising integer columns for Rank, University_ID, and Major_ID. It must accept two integer input parameters, `min_rank` and `max_rank`. The function's operation is to retrieve all records from the `major_ranking` table for which the Rank column value falls within the inclusive range specified by the provided parameters.",
    "id": 205
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_reputation_ratio` that accepts two integer input parameters: `min_reputation` and `max_reputation`. This function is designed to return a set of records, effectively acting as a table, with three columns: `\"University_ID\"` of type integer, `\"Reputation_point\"` of type integer, and `\"Ratio\"` of type numeric. The core operation of this function is to perform a `SELECT` query on the table named `\"overall_ranking\"`. The `SELECT` statement retrieves the `\"University_ID\"` column and the `\"Reputation_point\"` column directly from the `\"overall_ranking\"` table. Additionally, it calculates a new column named `\"Ratio\"`. The calculation for `\"Ratio\"` involves casting the value of the `\"Reputation_point\"` column from the `\"overall_ranking\"` table to a numeric type, then dividing this numeric value by the square root of the value of the `\"Total\"` column from the `\"overall_ranking\"` table, which is also cast to a numeric type before the square root operation. The rows included in the result set are filtered by a `WHERE` clause, which specifies that only those rows from the `\"overall_ranking\"` table where the value of the `\"Reputation_point\"` column is inclusively between the `min_reputation` parameter and the `max_reputation` parameter will be returned. The `RETURN QUERY` statement is used to return the results of this `SELECT` query directly as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_reputation_ratio(min_reputation integer, max_reputation integer)\nRETURNS TABLE(\"University_ID\" integer, \"Reputation_point\" integer, \"Ratio\" numeric) AS $$\nBEGIN\n    RETURN QUERY SELECT overall_ranking.\"University_ID\", overall_ranking.\"Reputation_point\", \n    (overall_ranking.\"Reputation_point\"::numeric / sqrt(overall_ranking.\"Total\"::numeric)) AS \"Ratio\"\n    FROM \"overall_ranking\"\n    WHERE overall_ranking.\"Reputation_point\" BETWEEN min_reputation AND max_reputation;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_reputation_ratio(1, 10);",
      "SELECT * FROM calculate_reputation_ratio(3, 7);",
      "SELECT * FROM calculate_reputation_ratio(0, 5);",
      "SELECT * FROM calculate_reputation_ratio(4, 15);",
      "SELECT * FROM calculate_reputation_ratio(2, 8);"
    ],
    "summary": "Create a PLpgSQL function named calculate_reputation_ratio that returns a table (University_ID integer, Reputation_point integer, Ratio numeric). It takes min_reputation and max_reputation integer parameters. The function selects from the overall_ranking table where Reputation_point is between the parameters, calculating Ratio as Reputation_point / SQRT(Total).",
    "natural_language": "What is the PLpgSQL function definition for calculate_reputation_ratio that returns a table with University_ID, Reputation_point, and Ratio, and takes min_reputation and max_reputation as parameters to select from overall_ranking where Reputation_point falls between them, calculating the Ratio as Reputation_point divided by the square root of Total?",
    "id": 206
  },
  {
    "ir": "Write a PLpgSQL function named get_universities_by_enrollment that returns a table with three columns: an integer column \"University_ID\", a text column \"University_Name\", and an integer column \"Enrollment\". The function accepts two mandatory integer input parameters, min_enrollment and max_enrollment, which define the inclusive lower and upper bounds for filtering. The function body executes a single SQL query that selects the \"University_ID\", \"University_Name\", and \"Enrollment\" columns from the \"university\" table, aliased as 'u'. The query includes a WHERE clause with a BETWEEN condition that filters the result set to include only those rows where the value in the \"Enrollment\" column is greater than or equal to the min_enrollment parameter and less than or equal to the max_enrollment parameter. The function then returns the complete result set of this query directly as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_universities_by_enrollment(min_enrollment integer, max_enrollment integer)\nRETURNS TABLE(\"University_ID\" integer, \"University_Name\" text, \"Enrollment\" integer) AS $$\nBEGIN\n    RETURN QUERY SELECT u.\"University_ID\", u.\"University_Name\", u.\"Enrollment\"\n    FROM \"university\" u\n    WHERE u.\"Enrollment\" BETWEEN min_enrollment AND max_enrollment;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM get_universities_by_enrollment(1000, 2000);",
      "SELECT * FROM get_universities_by_enrollment(2000, 3000);",
      "SELECT * FROM get_universities_by_enrollment(3000, 5000);",
      "SELECT * FROM get_universities_by_enrollment(1000, 5000);",
      "SELECT * FROM get_universities_by_enrollment(0, 10000);"
    ],
    "summary": "Create a PLpgSQL function named get_universities_by_enrollment that returns a table (University_ID integer, University_Name text, Enrollment integer). It takes min_enrollment and max_enrollment integer parameters and selects from the university table where Enrollment is between the parameters.",
    "natural_language": "Write a PLpgSQL function called get_universities_by_enrollment that gives back a table with University_ID, University_Name, and Enrollment. It should use two integer inputs for a lower and upper student count and pick from the university table where the Enrollment is roughly within that kind of range.",
    "id": 207
  },
  {
    "ir": "Write a PLpgSQL function that takes two integer parameters, min_code and max_code, and returns a table containing three columns: Major_ID (integer), Major_Name (text), and Major_Code (integer). The function retrieves data from the \"major\" table, specifically selecting the columns \"Major_ID\", \"Major_Name\", and \"Major_Code\". It filters the rows based on the condition that the \"Major_Code\" column value must fall within the inclusive range defined by the min_code and max_code parameters. The function uses the RETURN QUERY statement to execute the SELECT query and return the resulting rows as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_major_by_code_range(min_code integer, max_code integer)\nRETURNS TABLE(\"Major_ID\" integer, \"Major_Name\" text, \"Major_Code\" integer) AS $$\nBEGIN\n    RETURN QUERY \n    SELECT m.\"Major_ID\", m.\"Major_Name\", m.\"Major_Code\"\n    FROM \"major\" m\n    WHERE m.\"Major_Code\" BETWEEN min_code AND max_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM get_major_by_code_range(1050, 1060);",
      "SELECT * FROM get_major_by_code_range(1000, 1100);",
      "SELECT * FROM get_major_by_code_range(1053, 1054);",
      "SELECT * FROM get_major_by_code_range(1150, 1160);",
      "SELECT * FROM get_major_by_code_range(1040, 1200);"
    ],
    "summary": "Create a PLpgSQL function that returns a table (Major_ID integer, Major_Name text, Major_Code integer). It takes min_code and max_code integer parameters and selects from the major table where Major_Code is between the parameters.",
    "natural_language": "What PLpgSQL function can be written to return a table with columns for Major_ID, Major_Name, and Major_Code, given integer parameters for min_code and max_code, that selects from the major table where Major_Code falls between those two values?",
    "id": 208
  },
  {
    "ir": "Write a PLpgSQL function that takes two integer parameters, min_citation and max_citation, and returns a table containing three columns: University_ID (integer), Citation_point (integer), and Ratio (numeric). The function operates on the \"overall_ranking\" table, which contains columns \"University_ID\" (integer), \"Citation_point\" (integer), and \"Total\" (integer). The function begins by executing a query that selects rows from the \"overall_ranking\" table where the \"Citation_point\" column value falls within the inclusive range specified by the min_citation and max_citation parameters. For each selected row, the function retrieves the \"University_ID\" and \"Citation_point\" values directly and calculates the \"Ratio\" value by dividing the \"Citation_point\" column (cast to numeric) by the square root of the \"Total\" column (also cast to numeric). The calculated \"Ratio\" value is included in the output along with the corresponding \"University_ID\" and \"Citation_point\" values. The function then returns the result set as a table with the specified columns.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_citation_ratio(min_citation integer, max_citation integer)\nRETURNS TABLE(\"University_ID\" integer, \"Citation_point\" integer, \"Ratio\" numeric) AS $$\nBEGIN\n    RETURN QUERY SELECT \"overall_ranking\".\"University_ID\", \"overall_ranking\".\"Citation_point\", \n    (\"overall_ranking\".\"Citation_point\"::numeric / sqrt(\"overall_ranking\".\"Total\"::numeric)) AS \"Ratio\"\n    FROM \"overall_ranking\"\n    WHERE \"overall_ranking\".\"Citation_point\" BETWEEN min_citation AND max_citation;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_citation_ratio(0, 10);",
      "SELECT * FROM calculate_citation_ratio(5, 20);",
      "SELECT * FROM calculate_citation_ratio(1, 50);",
      "SELECT * FROM calculate_citation_ratio(10, 100);",
      "SELECT * FROM calculate_citation_ratio(0, 1000);"
    ],
    "summary": "Create a PL/pgSQL function that returns a table with University_ID, Citation_point, and Ratio columns. Filter the overall_ranking table where Citation_point is between min_citation and max_citation (inclusive). Calculate Ratio as Citation_point (numeric) divided by the square root of Total (numeric).",
    "natural_language": "What are the University_ID, Citation_point, and Ratio for entries in the overall_ranking table where the Citation_point falls between a given minimum and maximum value, with the Ratio calculated as the Citation_point divided by the square root of Total?",
    "id": 209
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_employee_salary` that accepts a single input parameter, `p_employee_id`, which is of the `numeric` data type. This function is designed to return a `numeric` value representing an employee's salary. The core logic of the function involves a conditional check: if the value of `p_employee_id` is strictly greater than `0`, the function proceeds to execute a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"SALARY\"` from the table named `employees`. The retrieval is filtered by a `WHERE` clause, ensuring that only the row where the column `\"EMPLOYEE_ID\"` matches the provided `p_employee_id` is considered. The value obtained from this `SELECT` statement is then returned as the result of the function. Conversely, if the value of `p_employee_id` is not strictly greater than `0` (i.e., it is less than or equal to `0`), the function explicitly returns a `NULL` value, indicating that no valid salary could be retrieved under that condition.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_salary(p_employee_id numeric)\nRETURNS numeric\nAS $$\nBEGIN\n    IF p_employee_id > 0 THEN\n        RETURN (SELECT \"SALARY\" FROM employees WHERE \"EMPLOYEE_ID\" = p_employee_id);\n    ELSE\n        RETURN NULL; -- Explicitly return NULL if p_employee_id is not positive\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "hr_1",
    "tables": [
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations"
    ],
    "call_sqls": [
      "SELECT get_employee_salary(100);",
      "SELECT get_employee_salary(101);",
      "SELECT get_employee_salary(102);",
      "SELECT get_employee_salary(200);",
      "SELECT get_employee_salary(201);"
    ],
    "summary": "Create a PL/pgSQL function named get_employee_salary that returns a numeric salary. If the input p_employee_id is greater than 0, return the SALARY from the employees table where EMPLOYEE_ID matches. Otherwise, return NULL.",
    "natural_language": "Write a function called get_employee_salary that gives back a salary amount. If you provide a somewhat valid employee ID, like a positive number, fetch the corresponding pay from the employees list. For any other kind of input, just return nothing.",
    "id": 210
  },
  {
    "ir": "Write a PLpgSQL function named calculate_avg_department_salary that accepts a single input parameter named p_dept_id of type numeric, which is intended to represent a specific department identifier, and returns a single numeric value; the function's logic begins by evaluating if the provided p_dept_id parameter is not null, and if this condition is true, it executes a SQL query that calculates the arithmetic average of the values in the SALARY column, using the AVG aggregate function, from the employees table, but only for those rows where the value in the DEPARTMENT_ID column is exactly equal to the value of the input parameter p_dept_id, and then returns this computed average value as the function's result; if the initial condition is false, meaning the p_dept_id parameter is null, the function's logic follows the ELSE branch and returns a null value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_department_salary(p_dept_id numeric)\nRETURNS numeric\nAS $$\nBEGIN\n    IF p_dept_id IS NOT NULL THEN\n        RETURN (SELECT AVG(\"SALARY\") FROM employees WHERE \"DEPARTMENT_ID\" = p_dept_id);\n    ELSE\n        RETURN NULL;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "hr_1",
    "tables": [
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations"
    ],
    "call_sqls": [
      "SELECT calculate_avg_department_salary(10);",
      "SELECT calculate_avg_department_salary(20);",
      "SELECT calculate_avg_department_salary(30);",
      "SELECT calculate_avg_department_salary(NULL);",
      "SELECT calculate_avg_department_salary(90);"
    ],
    "summary": "Create a PL/pgSQL function named calculate_avg_department_salary that takes a numeric department ID parameter. If the parameter is not null, return the average salary from the employees table for that department. Otherwise, return null.",
    "natural_language": "Construct a PL/pgSQL function, which should be named calculate_avg_department_salary, that accepts a single numeric parameter representing a department's unique identifier. In the event that the provided department ID parameter holds a non-null value, the function must compute and return the precise average salary, meticulously derived from all relevant records within the employees table that are associated with that specific department. Conversely, if the supplied parameter is determined to be null, the function should explicitly return a null value.",
    "id": 211
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `categorize_gymnast_performance` that accepts a single input parameter, `p_gymnast_id`, which is of type `integer`. The function is designed to return a `text` value representing the performance category of a specific gymnast. Upon execution, the function first initiates a conditional evaluation. It performs a `SELECT` operation to retrieve the value of the `\"Total_Points\"` column from the `gymnast` table, specifically for the row where the `\"Gymnast_ID\"` column matches the value provided by the `p_gymnast_id` input parameter. The retrieved `\"Total_Points\"` value is then compared. If this value is strictly greater than `58.0`, the function immediately returns the string literal `'Elite'`. If the first condition is not met, the function proceeds to the next conditional check. It again performs a `SELECT` operation to retrieve the `\"Total_Points\"` from the `gymnast` table for the same `p_gymnast_id`. If this retrieved `\"Total_Points\"` value is strictly greater than `56.0` (and implicitly not greater than `58.0` due to the previous condition), the function returns the string literal `'Advanced'`. If neither of the preceding conditions is satisfied, the function moves to the subsequent conditional evaluation. It once more executes a `SELECT` operation to fetch the `\"Total_Points\"` from the `gymnast` table for the identical `p_gymnast_id`. If this `\"Total_Points\"` value is strictly greater than `54.0` (and implicitly not greater than `56.0` due to prior conditions), the function returns the string literal `'Intermediate'`. Finally, if none of the aforementioned conditions are met, meaning the `\"Total_Points\"` for the specified gymnast is `54.0` or less, the function executes its `ELSE` block and returns the string literal `'Beginner'`.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_gymnast_performance(p_gymnast_id integer)\nRETURNS text AS $$\nBEGIN\n    IF (SELECT \"Total_Points\" FROM gymnast WHERE \"Gymnast_ID\" = p_gymnast_id) > 58.0 THEN\n        RETURN 'Elite';\n    ELSIF (SELECT \"Total_Points\" FROM gymnast WHERE \"Gymnast_ID\" = p_gymnast_id) > 56.0 THEN\n        RETURN 'Advanced';\n    ELSIF (SELECT \"Total_Points\" FROM gymnast WHERE \"Gymnast_ID\" = p_gymnast_id) > 54.0 THEN\n        RETURN 'Intermediate';\n    ELSE\n        RETURN 'Beginner';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT categorize_gymnast_performance(1);",
      "SELECT categorize_gymnast_performance(2);",
      "SELECT categorize_gymnast_performance(4);",
      "SELECT categorize_gymnast_performance(3);",
      "SELECT categorize_gymnast_performance(5);"
    ],
    "summary": "Create a PL/pgSQL function named categorize_gymnast_performance that takes a gymnast ID integer parameter. Return a text category based on the gymnast's Total_Points: 'Elite' if > 58.0, 'Advanced' if > 56.0, 'Intermediate' if > 54.0, otherwise 'Beginner'.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be named categorize_gymnast_performance, that accepts a single input parameter specifically for the gymnast's unique ID as an integer. This function must meticulously evaluate the gymnast's recorded Total_Points and return a descriptive textual category: it should designate the gymnast as 'Elite' if their score is impressively greater than 58.0, as 'Advanced' if it is commendably above 56.0, or as 'Intermediate' if it exceeds 54.0; otherwise, for all other cases, it should appropriately classify the gymnast under the 'Beginner' category.",
    "id": 212
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_next_competitor_score` that accepts one input parameter: `p_gymnast_id`, which is an integer representing the unique identifier of a gymnast. This function is designed to return a `real` (single-precision floating-point) value, which represents a specific score of a \"next\" competitor based on the provided `p_gymnast_id` and a series of conditional logic.\n\nThe function's execution flow is determined by a series of `IF-ELSIF-ELSE` conditional statements, evaluating the value of `p_gymnast_id`.\n\n**Conditional Branch 1: `IF p_gymnast_id > 3 THEN`**\nIf the value of `p_gymnast_id` is strictly greater than 3, the function executes a `SELECT` statement to retrieve a score. This `SELECT` statement operates on a subquery named `subq`.\nThe `subq` subquery performs the following operations:\n1. It selects the `\"Gymnast_ID\"` column and calculates a `next_score` column from the `gymnast` table.\n2. The `next_score` is computed using the `LEAD` window function.\n3. The `LEAD` function is applied to the `\"Total_Points\"` column.\n4. It looks ahead by 2 rows (`2`) in the ordered set of data.\n5. If there is no row at the specified offset (2 rows ahead), it defaults to `0.0` cast as a `real` data type.\n6. The ordering for the `LEAD` function is based on the `\"Total_Points\"` column in descending order (`ORDER BY \"Total_Points\" DESC`).\nAfter the `subq` is evaluated, the outer `SELECT` statement filters the results of `subq` to find the `next_score` where the `\"Gymnast_ID\"` column matches the input parameter `p_gymnast_id`. The retrieved `next_score` is then returned by the function.\n\n**Conditional Branch 2: `ELSIF p_gymnast_id > 2 THEN`**\nIf the first condition is false (i.e., `p_gymnast_id` is not greater than 3) and `p_gymnast_id` is strictly greater than 2, the function executes a `SELECT` statement similar to the first branch. This `SELECT` statement also operates on a subquery named `subq`.\nThe `subq` subquery performs the following operations:\n1. It selects the `\"Gymnast_ID\"` column and calculates a `next_score` column from the `gymnast` table.\n2. The `next_score` is computed using the `LEAD` window function.\n3. The `LEAD` function is applied to the `\"Total_Points\"` column.\n4. It looks ahead by 1 row (`1`) in the ordered set of data.\n5. If there is no row at the specified offset (1 row ahead), it defaults to `0.0` cast as a `real` data type.\n6. The ordering for the `LEAD` function is based on the `\"Total_Points\"` column in descending order (`ORDER BY \"Total_Points\" DESC`).\nAfter the `subq` is evaluated, the outer `SELECT` statement filters the results of `subq` to find the `next_score` where the `\"Gymnast_ID\"` column matches the input parameter `p_gymnast_id`. The retrieved `next_score` is then returned by the function.\n\n**Conditional Branch 3: `ELSIF p_gymnast_id > 1 THEN`**\nIf the previous conditions are false (i.e., `p_gymnast_id` is not greater than 3 and not greater than 2) and `p_gymnast_id` is strictly greater than 1, the function executes a `SELECT` statement, again operating on a subquery named `subq`.\nThe `subq` subquery performs the following operations:\n1. It selects the `\"Gymnast_ID\"` column and calculates a `next_score` column from the `gymnast` table.\n2. The `next_score` is computed using the `LEAD` window function.\n3. The `LEAD` function is applied to the `\"Floor_Exercise_Points\"` column.\n4. It looks ahead by 1 row (`1`) in the ordered set of data.\n5. If there is no row at the specified offset (1 row ahead), it defaults to `0.0` cast as a `real` data type.\n6. The ordering for the `LEAD` function is based on the `\"Floor_Exercise_Points\"` column in descending order (`ORDER BY \"Floor_Exercise_Points\" DESC`).\nAfter the `subq` is evaluated, the outer `SELECT` statement filters the results of `subq` to find the `next_score` where the `\"Gymnast_ID\"` column matches the input parameter `p_gymnast_id`. The retrieved `next_score` is then returned by the function.\n\n**Conditional Branch 4: `ELSE`**\nIf none of the preceding conditions are met (i.e., `p_gymnast_id` is less than or equal to 1), the function executes a final `SELECT` statement, operating on a subquery named `subq`.\nThe `subq` subquery performs the following operations:\n1. It selects the `\"Gymnast_ID\"` column and calculates a `next_score` column from the `gymnast` table.\n2. The `next_score` is computed using the `LEAD` window function.\n3. The `LEAD` function is applied to the `\"Vault_Points\"` column.\n4. It looks ahead by 1 row (`1`) in the ordered set of data.\n5. If there is no row at the specified offset (1 row ahead), it defaults to `0.0` cast as a `real` data type.\n6. The ordering for the `LEAD` function is based on the `\"Vault_Points\"` column in descending order (`ORDER BY \"Vault_Points\" DESC`).\nAfter the `subq` is evaluated, the outer `SELECT` statement filters the results of `subq` to find the `next_score` where the `\"Gymnast_ID\"` column matches the input parameter `p_gymnast_id`. The retrieved `next_score` is then returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_next_competitor_score(p_gymnast_id integer)\nRETURNS real AS $$\nBEGIN\n    IF p_gymnast_id > 3 THEN\n        RETURN (\n            SELECT next_score\n            FROM (\n                SELECT \"Gymnast_ID\",\n                       LEAD(\"Total_Points\", 2, 0.0::real) OVER (ORDER BY \"Total_Points\" DESC) AS next_score\n                FROM gymnast\n            ) subq\n            WHERE \"Gymnast_ID\" = p_gymnast_id\n        );\n    ELSIF p_gymnast_id > 2 THEN\n        RETURN (\n            SELECT next_score\n            FROM (\n                SELECT \"Gymnast_ID\",\n                       LEAD(\"Total_Points\", 1, 0.0::real) OVER (ORDER BY \"Total_Points\" DESC) AS next_score\n                FROM gymnast\n            ) subq\n            WHERE \"Gymnast_ID\" = p_gymnast_id\n        );\n    ELSIF p_gymnast_id > 1 THEN\n        RETURN (\n            SELECT next_score\n            FROM (\n                SELECT \"Gymnast_ID\",\n                       LEAD(\"Floor_Exercise_Points\", 1, 0.0::real) OVER (ORDER BY \"Floor_Exercise_Points\" DESC) AS next_score\n                FROM gymnast\n            ) subq\n            WHERE \"Gymnast_ID\" = p_gymnast_id\n        );\n    ELSE\n        RETURN (\n            SELECT next_score\n            FROM (\n                SELECT \"Gymnast_ID\",\n                       LEAD(\"Vault_Points\", 1, 0.0::real) OVER (ORDER BY \"Vault_Points\" DESC) AS next_score\n                FROM gymnast\n            ) subq\n            WHERE \"Gymnast_ID\" = p_gymnast_id\n        );\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_next_competitor_score(1);",
      "SELECT get_next_competitor_score(2);",
      "SELECT get_next_competitor_score(4);",
      "SELECT get_next_competitor_score(3);",
      "SELECT get_next_competitor_score(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_next_competitor_score that takes a gymnast ID integer parameter. Return a real score using LEAD window function on different columns with different offsets based on the ID: Total_Points with offset 2 if ID > 3, Total_Points with offset 1 if ID > 2, Floor_Exercise_Points with offset 1 if ID > 1, otherwise Vault_Points with offset 1. Order by the respective column descending.",
    "natural_language": "Make function get_next_competitor_score(gymnast_id int) return real. Use LEAD: offset 2 on Total_Points if ID>3, offset 1 on Total_Points if ID>2, offset 1 on Floor_Exercise_Points if ID>1, else offset 1 on Vault_Points. Order by column descending.",
    "id": 213
  },
  {
    "ir": "Write a PLpgSQL function that takes two input parameters, p_course_id of type bigint and p_name_format of type integer, and returns a text value. The function retrieves the name of an author associated with a specific course from the database, with the format of the name determined by the value of p_name_format. If p_name_format equals 1, the function performs a SELECT operation to retrieve the \"personal_name\" column from the \"Course_Authors_and_Tutors\" table, joining it with the \"Courses\" table on the condition that the \"author_id\" column in \"Course_Authors_and_Tutors\" matches the \"author_id\" column in \"Courses\", and further filters the result by ensuring that the \"course_id\" column in the \"Courses\" table matches the value of p_course_id. If p_name_format does not equal 1, the function performs a SELECT operation to retrieve the \"family_name\" column from the \"Course_Authors_and_Tutors\" table, using the same join condition and filter criteria as described above. The function uses an IF conditional statement to determine which column to return based on the value of p_name_format and executes the corresponding SELECT query accordingly.",
    "plsql": "CREATE OR REPLACE FUNCTION get_author_name_by_course(p_course_id bigint, p_name_format integer)\nRETURNS text AS $$\nBEGIN\n    IF p_name_format = 1 THEN\n        RETURN (SELECT \"personal_name\" FROM \"Course_Authors_and_Tutors\" cat JOIN \"Courses\" c ON cat.\"author_id\" = c.\"author_id\" WHERE c.\"course_id\" = p_course_id);\n    ELSE\n        RETURN (SELECT \"family_name\" FROM \"Course_Authors_and_Tutors\" cat JOIN \"Courses\" c ON cat.\"author_id\" = c.\"author_id\" WHERE c.\"course_id\" = p_course_id);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Courses",
      "Course_Authors_and_Tutors",
      "Student_Course_Enrolment",
      "Students"
    ],
    "call_sqls": [
      "SELECT get_author_name_by_course(1, 1);",
      "SELECT get_author_name_by_course(2, 2);",
      "SELECT get_author_name_by_course(3, 1);",
      "SELECT get_author_name_by_course(1, 2);",
      "SELECT get_author_name_by_course(2, 1);"
    ],
    "summary": "Create a function that returns an author's name for a given course. The function takes a course ID and a format code. If the format code is 1, return the author's personal name. Otherwise, return the author's family name. Retrieve the name by joining the Course_Authors_and_Tutors and Courses tables on author_id, filtered by the provided course ID.",
    "natural_language": "List the author's name for a specified course. Use the course ID and a format code. When the format code is 1, show the author's personal name; otherwise, show the family name. Join the Course_Authors_and_Tutors and Courses tables on author_id, filtering by the given course ID.",
    "id": 214
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, p_course_id of type bigint and p_date of type timestamp with time zone, and returns an integer value representing the count of rows in the \"Student_Course_Enrolment\" table where the \"course_id\" column matches the value of p_course_id and the \"date_of_enrolment\" column is less than or equal to the value of p_date. The function performs a SELECT operation with a COUNT aggregate function on the \"Student_Course_Enrolment\" table, applying a WHERE clause to filter rows based on the equality condition for \"course_id\" and the comparison condition for \"date_of_enrolment\". The result of the COUNT operation is returned directly as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_enrolment_count(p_course_id bigint, p_date timestamp with time zone)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM \"Student_Course_Enrolment\" WHERE \"course_id\" = p_course_id AND \"date_of_enrolment\" <= p_date);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Courses",
      "Course_Authors_and_Tutors",
      "Student_Course_Enrolment",
      "Students"
    ],
    "call_sqls": [
      "SELECT get_student_enrolment_count(1, '2017-12-31 23:59:59+08:00');",
      "SELECT get_student_enrolment_count(2, '2018-01-01 00:00:00+00:00');",
      "SELECT get_student_enrolment_count(3, CURRENT_TIMESTAMP);",
      "SELECT get_student_enrolment_count(4, '2017-11-15 12:00:00+08:00');",
      "SELECT get_student_enrolment_count(5, '2018-03-01 10:30:00+08:00');"
    ],
    "summary": "Create a function that returns the count of student enrolments for a specific course up to a given date. The function takes a course ID and a cutoff timestamp. Count the rows in the Student_Course_Enrolment table where the course_id matches and the date_of_enrolment is less than or equal to the provided date.",
    "natural_language": "Count student enrolments for a course by a given date.",
    "id": 215
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_course_completion_rate` that accepts two input parameters: `p_course_id`, which is of type `bigint` and represents the unique identifier for a specific course, and `p_date`, which is of type `timestamp with time zone` and represents a specific point in time up to which enrolment data should be considered. This function is designed to return a `numeric` value representing the completion rate for the specified course up to the given date. The function's core logic involves a single `SELECT` statement that calculates this completion rate. This `SELECT` statement operates on the `Student_Course_Enrolment` table. Within this table, it filters records based on two conditions: first, the `course_id` column must be equal to the value provided by the `p_course_id` input parameter; second, the `date_of_enrolment` column must be less than or equal to the value provided by the `p_date` input parameter. For the filtered set of records, the `SELECT` statement performs two aggregate calculations: it counts the number of non-NULL occurrences in the `date_of_completion` column, casting this count to a `numeric` type, and it counts the total number of records using `COUNT(*)`. The count of non-NULL `date_of_completion` values is then divided by the total count of records. To prevent division by zero errors, the `NULLIF` function is used, which replaces the total count with `NULL` if it is zero, effectively causing the division to result in `NULL` instead of an error. The result of this division is then rounded to two decimal places using the `ROUND` function. The final calculated and rounded numeric value representing the course completion rate is then returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_course_completion_rate(p_course_id bigint, p_date timestamp with time zone)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT ROUND(CAST(COUNT(\"date_of_completion\") AS numeric) / NULLIF(COUNT(*), 0), 2) FROM \"Student_Course_Enrolment\" WHERE \"course_id\" = p_course_id AND \"date_of_enrolment\" <= p_date);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Courses",
      "Course_Authors_and_Tutors",
      "Student_Course_Enrolment",
      "Students"
    ],
    "call_sqls": [
      "SELECT get_course_completion_rate(1, '2018-01-01 00:00:00+08:00');",
      "SELECT get_course_completion_rate(2, '2018-06-30 23:59:59+08:00');",
      "SELECT get_course_completion_rate(3, '2017-12-31 12:00:00+08:00');",
      "SELECT get_course_completion_rate(4, '2018-03-15 15:30:00+08:00');",
      "SELECT get_course_completion_rate(5, '2018-12-31 23:59:59+08:00');"
    ],
    "summary": "Create a function named get_course_completion_rate that calculates the completion rate for a course up to a specified date. The function takes a course ID and a cutoff timestamp. For enrolments in that course on or before the date, calculate the rate by dividing the count of non-null completion dates by the total number of enrolments. Round the result to two decimal places and handle division by zero by returning NULL.",
    "natural_language": "Alright, so we need a function called get_course_completion_rate. Basically, you give it a course ID and a date to stop counting. For everyone who signed up for that course on or before that cutoff date, figure out what percentage actually finished (that's when their completion date isn't empty). Take the number of folks who finished, divide it by the total number of sign-ups, and round it to two decimal spots. Oh, and if there are no sign-ups at all, just spit out NULL instead of crashing.",
    "id": 216
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, p_student_id of type bigint and p_date_format of type integer, and retrieves the latest logon date of a student from the \"Students\" table in a specific format based on the value of p_date_format. The function begins by checking the value of p_date_format using an IF conditional statement. If p_date_format equals 1, the function executes a SELECT query on the \"Students\" table to retrieve the \"date_of_latest_logon\" column for the row where the \"student_id\" column matches the value of p_student_id, and formats the date using the TO_CHAR function with the format 'YYYY-MM-DD'. If p_date_format does not equal 1, the function executes a similar SELECT query on the \"Students\" table to retrieve the \"date_of_latest_logon\" column for the row where the \"student_id\" column matches the value of p_student_id, but formats the date using the TO_CHAR function with the format 'DD-Mon-YYYY HH24:MI:SS'. The function then returns the formatted date as a text value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_latest_logon(p_student_id bigint, p_date_format integer)\nRETURNS text AS $$\nBEGIN\n    IF p_date_format = 1 THEN\n        RETURN (SELECT TO_CHAR(\"date_of_latest_logon\", 'YYYY-MM-DD') FROM \"Students\" WHERE \"student_id\" = p_student_id);\n    ELSE\n        RETURN (SELECT TO_CHAR(\"date_of_latest_logon\", 'DD-Mon-YYYY HH24:MI:SS') FROM \"Students\" WHERE \"student_id\" = p_student_id);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Courses",
      "Course_Authors_and_Tutors",
      "Student_Course_Enrolment",
      "Students"
    ],
    "call_sqls": [
      "SELECT get_student_latest_logon(1, 1);",
      "SELECT get_student_latest_logon(2, 2);",
      "SELECT get_student_latest_logon(3, 1);",
      "SELECT get_student_latest_logon(1, 2);",
      "SELECT get_student_latest_logon(2, 1);"
    ],
    "summary": "Create a function that returns a student's latest logon date in a specified format. The function takes a student ID and a format code. If the format code is 1, return the date as 'YYYY-MM-DD'. Otherwise, return it as 'DD-Mon-YYYY HH24:MI:SS'. Retrieve the date from the Students table for the given student ID.",
    "natural_language": "Function to get a student's last logon date. Input: student ID and format code. Code 1 returns 'YYYY-MM-DD', else returns 'DD-Mon-YYYY HH24:MI:SS'. Fetch date from Students table.",
    "id": 217
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_course_author_login` that accepts two input parameters: `p_course_id` of type `bigint` and `p_format` of type `integer`. The function is designed to return a `text` value. The core logic of the function involves a conditional statement based on the value of the `p_format` parameter. If `p_format` is equal to `1`, the function executes a `SELECT` statement to retrieve the `login_name` column. This `SELECT` statement performs an `INNER JOIN` between the `\"Course_Authors_and_Tutors\"` table, aliased as `cat`, and the `\"Courses\"` table, aliased as `c`. The join condition is established by matching the `author_id` column from the `cat` table with the `author_id` column from the `c` table (`cat.\"author_id\" = c.\"author_id\"`). The `WHERE` clause further filters the results to include only rows where the `course_id` column in the `c` table matches the input parameter `p_course_id` (`c.\"course_id\" = p_course_id`). The `login_name` value obtained from this query is then returned by the function. If `p_format` is not equal to `1` (i.e., it falls into the `ELSE` block), the function executes a different `SELECT` statement. This `SELECT` statement retrieves the `author_tutor_ATB` column. Similar to the previous case, this `SELECT` statement also performs an `INNER JOIN` between the `\"Course_Authors_and_Tutors\"` table (aliased as `cat`) and the `\"Courses\"` table (aliased as `c`), using the same join condition (`cat.\"author_id\" = c.\"author_id\"`). The `WHERE` clause also applies the same filtering condition, matching the `course_id` column in the `c` table with the input parameter `p_course_id` (`c.\"course_id\" = p_course_id`). The `author_tutor_ATB` value obtained from this query is then returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_course_author_login(p_course_id bigint, p_format integer)\nRETURNS text AS $$\nBEGIN\n    IF p_format = 1 THEN\n        RETURN (SELECT \"login_name\" FROM \"Course_Authors_and_Tutors\" cat JOIN \"Courses\" c ON cat.\"author_id\" = c.\"author_id\" WHERE c.\"course_id\" = p_course_id);\n    ELSE\n        RETURN (SELECT \"author_tutor_ATB\" FROM \"Course_Authors_and_Tutors\" cat JOIN \"Courses\" c ON cat.\"author_id\" = c.\"author_id\" WHERE c.\"course_id\" = p_course_id);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Courses",
      "Course_Authors_and_Tutors",
      "Student_Course_Enrolment",
      "Students"
    ],
    "call_sqls": [
      "SELECT get_course_author_login(1, 1);",
      "SELECT get_course_author_login(2, 2);",
      "SELECT get_course_author_login(3, 1);",
      "SELECT get_course_author_login(1, 2);",
      "SELECT get_course_author_login(2, 1);"
    ],
    "summary": "Create a function named get_course_author_login that returns an author's login identifier for a given course. The function takes a course ID and a format code. If the format code is 1, return the login_name. Otherwise, return the author_tutor_ATB. Retrieve the value by joining the Course_Authors_and_Tutors and Courses tables on author_id, filtered by the provided course ID.",
    "natural_language": "Define a function designated as 'get_course_author_login' that accepts a course identifier and a format code as parameters. This function shall return the author's login identifier for the specified course. The implementation must join the 'Course_Authors_and_Tutors' and 'Courses' tables utilizing the author_id field, constrained by the provided course identifier. Conditional logic is required: if the format code is equal to 1, the function must return the 'login_name'; otherwise, it must return the 'author_tutor_ATB'.",
    "id": 218
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_first_enum_value` that is designed to return a single text value. This function does not accept any input parameters. Upon execution, the function's internal logic directly returns the static string literal `'red'`. There are no conditional statements, loops, database operations (such as SELECT, INSERT, UPDATE, DELETE), or calls to other functions or special operations within its body. The function's sole purpose is to provide a predefined text string as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_first_enum_value()\nRETURNS text AS $$\nBEGIN\n    RETURN 'red';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collection_Subset_Members",
      "Collection_Subsets",
      "Collections",
      "Document_Objects",
      "Documents_in_Collections",
      "Document_Subsets"
    ],
    "call_sqls": [
      "SELECT get_first_enum_value();"
    ],
    "summary": "Create a function named get_first_enum_value that returns the text value 'red' without any parameters, logic, or database operations.",
    "natural_language": "What is the definition of a function named get_first_enum_value that returns the text value 'red' without any parameters, logic, or database operations?",
    "id": 219
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter, country_name of type text, and returns a text value representing the performance category of the specified country based on its average score calculated from three columns in the countries table. The function begins by declaring a local variable avg_score of type real to store the computed average score. It then performs a SELECT query on the countries table, retrieving the values of the justice_score, health_score, and education_score columns for the row where the name column matches the input parameter country_name. These three scores are summed and divided by 3 to calculate the average score, which is stored in the avg_score variable. The function then evaluates the avg_score using a series of conditional statements. If avg_score is greater than 95.0, the function returns the text value 'Excellent'. If avg_score is not greater than 95.0 but is greater than 85.0, the function returns the text value 'Good'. If neither condition is met, the function returns the text value 'Needs Improvement'. The function does not modify any data in the database and solely performs a read operation followed by conditional logic to determine the appropriate return value.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_country_performance(\"country_name\" text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"avg_score\" real;\nBEGIN\n    SELECT (\"justice_score\" + \"health_score\" + \"education_score\") / 3 INTO \"avg_score\" FROM \"countries\" WHERE \"name\" = \"country_name\";\n    IF \"avg_score\" > 95.0 THEN\n        RETURN 'Excellent';\n    ELSE\n        IF \"avg_score\" > 85.0 THEN\n            RETURN 'Good';\n        ELSE\n            RETURN 'Needs Improvement';\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT categorize_country_performance('Iceland');",
      "SELECT categorize_country_performance('Sweden');",
      "SELECT categorize_country_performance('Canada');",
      "SELECT categorize_country_performance('United States');",
      "SELECT categorize_country_performance('Germany');"
    ],
    "summary": "Create a function that takes a country name and returns a performance category ('Excellent', 'Good', 'Needs Improvement') based on the average of its justice, health, and education scores from the countries table.",
    "natural_language": "Write a function that, given a country name, returns a performance category of 'Excellent', 'Good', or 'Needs Improvement' based on the average of its justice, health, and education scores from the countries table.",
    "id": 220
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_language_status that accepts two input parameters: a text parameter named lang_name representing a language name and a text parameter named country_name representing a country name, and returns a text value. The function declares a local integer variable named lang_count. It executes a SELECT statement that performs a COUNT(*) operation by joining three tables: the official_languages table aliased as ol, the languages table aliased as l, and the countries table aliased as c. The join condition links ol.language_id to l.id and ol.country_id to c.id. The WHERE clause filters the joined result set to rows where the name column from the languages table equals the input lang_name and the name column from the countries table equals the input country_name. The result of the count is stored into the lang_count variable. Following this, an IF statement checks if lang_count is greater than zero; if true, the function returns the string 'Official Language'. If the condition is false, the function executes a nested IF statement containing an EXISTS subquery. The subquery selects the constant value 1 from the languages table where the name column equals the input lang_name. If the EXISTS subquery returns true, the function returns the string 'Not Official'. If the EXISTS subquery returns false, the function returns the string 'Unknown Language'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_language_status(\"lang_name\" text, \"country_name\" text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"lang_count\" integer;\nBEGIN\n    SELECT COUNT(*) INTO \"lang_count\" FROM \"official_languages\" \"ol\" JOIN \"languages\" \"l\" ON \"ol\".\"language_id\" = \"l\".\"id\" JOIN \"countries\" \"c\" ON \"ol\".\"country_id\" = \"c\".\"id\" WHERE \"l\".\"name\" = \"lang_name\" AND \"c\".\"name\" = \"country_name\";\n    IF \"lang_count\" > 0 THEN\n        RETURN 'Official Language';\n    ELSE\n        IF EXISTS(SELECT 1 FROM \"languages\" WHERE \"name\" = \"lang_name\") THEN\n            RETURN 'Not Official';\n        ELSE\n            RETURN 'Unknown Language';\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT get_language_status('English', 'Canada');",
      "SELECT get_language_status('Swedish', 'Sweden');",
      "SELECT get_language_status('Icelandic', 'Iceland');",
      "SELECT get_language_status('French', 'Canada');",
      "SELECT get_language_status('Spanish', 'Sweden');"
    ],
    "summary": "Create a function named get_language_status that takes a language name and a country name. Return 'Official Language' if the language is officially used in that country, 'Not Official' if the language exists but is not official there, or 'Unknown Language' if the language does not exist.",
    "natural_language": "Define a function called 'get_language_status' that accepts two parameters: a language name and a country name. The function shall return the string 'Official Language' if the specified language holds official status in the given country. Should the language be present in the country but not possess official status, the function must return 'Not Official'. In the event the language is not associated with the country, the function is to return 'Unknown Language'.",
    "id": 221
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `count_ready_deliveries_today` that is designed to return a single `bigint` value. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_count` of type `bigint`. The core operation of this function involves performing a `SELECT` statement to count the number of rows from the table named `\"Order_Deliveries\"`. This count is then stored into the previously declared local variable `v_count`. The selection of rows for counting is subject to two conditions combined with a logical `AND` operator. The first condition specifies that the value in the `delivery_status_code` column of the `\"Order_Deliveries\"` table must be exactly equal to the string literal `'Ready'`. The second condition requires that the date part of the value in the `delivery_date` column of the `\"Order_Deliveries\"` table, extracted using the `DATE()` function, must be equal to the current date, which is obtained using the `CURRENT_DATE` function. After the count is determined and stored in `v_count`, the function returns the final value of `v_count` as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION count_ready_deliveries_today()\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM \"Order_Deliveries\" od\n    WHERE od.delivery_status_code = 'Ready'\n    AND DATE(od.delivery_date) = CURRENT_DATE;\n    \n    RETURN v_count;\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Actual_Order_Products",
      "Order_Deliveries"
    ],
    "call_sqls": [
      "SELECT count_ready_deliveries_today();"
    ],
    "summary": "Create a function named count_ready_deliveries_today with no parameters that returns a bigint. Count and return the number of rows in the \"Order_Deliveries\" table where the delivery_status_code is 'Ready' and the delivery_date is today.",
    "natural_language": "How many rows in the \"Order_Deliveries\" table have a delivery_status_code of 'Ready' and a delivery_date of today?",
    "id": 222
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_avg_products_per_success_order` that accepts no input parameters. This function is designed to calculate and return the average number of products associated with successfully completed orders. The function declares a local variable `v_avg` of type `numeric` to store the calculated average. The core operation involves a `SELECT` statement that populates `v_avg`. This `SELECT` statement operates on a subquery. The subquery first joins the `\"Actual_Orders\"` table, aliased as `ao`, with the `\"Actual_Order_Products\"` table, aliased as `aop`, using the join condition `ao.actual_order_id = aop.actual_order_id`. This join links individual orders to the products contained within them. From the joined results, the subquery filters records where the `order_status_code` column in the `\"Actual_Orders\"` table is equal to the string literal `'Success'`. After filtering, the subquery groups the results by `ao.actual_order_id`, effectively creating a distinct group for each successful order. For each of these groups (i.e., for each successful order), the subquery counts the number of `product_id` values from the `\"Actual_Order_Products\"` table using the `COUNT()` aggregate function, and aliases this count as `product_count`. The outer `SELECT` statement then calculates the `AVG()` of these `product_count` values generated by the subquery, and stores this overall average into the `v_avg` variable. Finally, the function returns the value of `v_avg`. If `v_avg` happens to be `NULL` (which could occur if there are no successful orders), the `COALESCE()` function ensures that `0` is returned instead of `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_avg_products_per_success_order()\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg numeric;\nBEGIN\n    SELECT AVG(product_count) INTO v_avg\n    FROM (\n        SELECT COUNT(aop.product_id) as product_count\n        FROM \"Actual_Orders\" ao\n        JOIN \"Actual_Order_Products\" aop ON ao.actual_order_id = aop.actual_order_id\n        WHERE ao.order_status_code = 'Success'\n        GROUP BY ao.actual_order_id\n    ) subquery;\n    \n    RETURN COALESCE(v_avg, 0);\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Actual_Order_Products",
      "Order_Deliveries"
    ],
    "call_sqls": [
      "SELECT get_avg_products_per_success_order();"
    ],
    "summary": "Create a function named get_avg_products_per_success_order with no parameters that returns a numeric. Calculate and return the average number of products per order, considering only orders with a status of 'Success'. Return 0 if there are no such orders.",
    "natural_language": "Alright, so I need you to whip up a function called get_avg_products_per_success_order. Don't worry about passing anything into it. This thing should spit out a number. Basically, figure out the average number of products in an order, but only count the orders that are marked as 'Success'. If there aren't any successful orders, just give me a zero.",
    "id": 223
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_actor_by_musical_and_age` that accepts three input parameters: `p_musical_id` of type `integer`, `p_min_age` of type `integer`, and `p_character_prefix` of type `text`. This function is designed to return a single value of type `text`. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `actor` table. Specifically, it selects the value from the column named `\"Name\"` from the `actor` table. The selection is subject to three conditions combined with the logical `AND` operator. The first condition requires that the value in the `\"Musical_ID\"` column of the `actor` table must be equal to the value provided in the `p_musical_id` input parameter. The second condition specifies that the value in the `age` column of the `actor` table must be greater than or equal to the value provided in the `p_min_age` input parameter. The third condition involves a string manipulation function: it uses `split_part(a.\"Character\", ' ', 1)` to extract the first part of the string in the `\"Character\"` column of the `actor` table, using a space character (' ') as the delimiter. The result of this `split_part` operation must be equal to the value provided in the `p_character_prefix` input parameter. After applying these filtering conditions, the `SELECT` statement is further constrained by a `LIMIT 1` clause, which ensures that only the first row satisfying all the conditions is considered. The value retrieved from the `\"Name\"` column of this single, first matching row is then returned as the result of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_by_musical_and_age(p_musical_id integer, p_min_age integer, p_character_prefix text)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT a.\"Name\" FROM actor a WHERE a.\"Musical_ID\" = p_musical_id AND a.age >= p_min_age AND split_part(a.\"Character\", ' ', 1) = p_character_prefix LIMIT 1);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_by_musical_and_age(1, 20, 'Alf');",
      "SELECT get_actor_by_musical_and_age(2, 25, 'Lou');",
      "SELECT get_actor_by_musical_and_age(1, 21, 'Irene');",
      "SELECT get_actor_by_musical_and_age(1, 30, 'John');",
      "SELECT get_actor_by_musical_and_age(2, 22, 'Lou');"
    ],
    "summary": "Create a function named get_actor_by_musical_and_age that returns a text value. It takes a musical ID, a minimum age, and a character prefix as inputs. The function selects the \"Name\" from the actor table where the \"Musical_ID\" matches the input ID, the age is greater than or equal to the input minimum age, and the first word of the \"Character\" column matches the input prefix. It returns only the first matching name found.",
    "natural_language": "Create a function called get_actor_by_musical_and_age that gives back a text result. It needs a musical ID, a not-so-young age threshold, and a kind of character prefix. The function should look in the actor table for entries where the Musical_ID fits the given one, the person's age is at least around that minimum, and the start of what's in the Character column somewhat aligns with the provided prefix. It then returns the first name it comes across from those results.",
    "id": 224
  },
  {
    "ir": "Write a PLpgSQL function that takes three input parameters: p_musical_id of type integer, p_age_threshold of type integer, and p_duration_prefix of type text, and returns an integer value. The function performs a SELECT operation to count the number of rows in the actor table that satisfy the following conditions: the value in the Musical_ID column matches the value of the p_musical_id parameter, the value in the age column is greater than the value of the p_age_threshold parameter, and the first part of the value in the Duration column (split by the delimiter '—') matches the value of the p_duration_prefix parameter. The split_part function is used to extract the first segment of the Duration column's value based on the delimiter '—'. The COUNT(*) function is applied to determine the total number of rows meeting these criteria, and this count is returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION count_actors_by_criteria(p_musical_id integer, p_age_threshold integer, p_duration_prefix text)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM actor WHERE \"Musical_ID\" = p_musical_id AND age > p_age_threshold AND split_part(\"Duration\", '—', 1) = p_duration_prefix);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT count_actors_by_criteria(1, 25, '1988');",
      "SELECT count_actors_by_criteria(2, 20, '1992');",
      "SELECT count_actors_by_criteria(1, 30, '1988');",
      "SELECT count_actors_by_criteria(3, 18, '1993');",
      "SELECT count_actors_by_criteria(2, 25, '1988');"
    ],
    "summary": "Create a function that returns an integer count. It takes a musical ID, an age threshold, and a duration prefix as inputs. The function counts rows in the actor table where the \"Musical_ID\" matches the input ID, the age is greater than the input threshold, and the first part of the \"Duration\" column (split by '—') matches the input prefix.",
    "natural_language": "How many actors are there where the Musical_ID matches a given ID, their age is above a specified threshold, and the first part of the Duration (before the '—') matches a provided prefix?",
    "id": 225
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_major_statistics_by_rank that accepts a single integer input parameter named p_rank_level and returns an integer value, which performs a conditional operation based on the value of p_rank_level to compute and return a specific statistical result by querying the 'major' and 'major_ranking' tables, where for p_rank_level values 1 through 5, it executes a SELECT COUNT(*) query that joins the 'major' table (aliased as m) and the 'major_ranking' table (aliased as mr) on the condition that m.\"Major_ID\" equals mr.\"Major_ID\", filtering the results where mr.\"Rank\" equals the corresponding p_rank_level value (1, 2, 3, 4, or 5), and stores the count of matching rows into the local integer variable stat_result, for p_rank_level value 6, it executes a SELECT AVG(m.\"Major_Code\") query from the same joined tables, filtering where mr.\"Rank\" is less than or equal to 3, and stores the average of the \"Major_Code\" column into stat_result, for p_rank_level value 7, it executes a SELECT MAX(m.\"Major_Code\") query from the joined tables, filtering where mr.\"Rank\" is greater than 3, and stores the maximum \"Major_Code\" value, for p_rank_level value 8, it executes a SELECT MIN(m.\"Major_Code\") query from the joined tables, filtering where mr.\"Rank\" is between 2 and 4 inclusive, and stores the minimum \"Major_Code\" value, for p_rank_level value 9, it executes a SELECT SUM(m.\"Major_Code\") query from the joined tables, filtering where mr.\"Rank\" is less than 5, and stores the sum of the \"Major_Code\" values, for p_rank_level value 10, it executes a SELECT COUNT(DISTINCT m.\"Major_Code\") query from the joined tables without any rank filter, counting the distinct values of the \"Major_Code\" column, and for any p_rank_level value not matching 1 through 10, it assigns the value 0 to stat_result, and finally, the function returns the value of stat_result using the COALESCE function to ensure a null result is converted to 0 before returning.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_major_statistics_by_rank(p_rank_level INTEGER)\nRETURNS INTEGER AS $$\nDECLARE\n    stat_result INTEGER := 0;\nBEGIN\n    IF p_rank_level = 1 THEN\n        SELECT COUNT(*) INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" = 1;\n    ELSIF p_rank_level = 2 THEN\n        SELECT COUNT(*) INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" = 2;\n    ELSIF p_rank_level = 3 THEN\n        SELECT COUNT(*) INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" = 3;\n    ELSIF p_rank_level = 4 THEN\n        SELECT COUNT(*) INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" = 4;\n    ELSIF p_rank_level = 5 THEN\n        SELECT COUNT(*) INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" = 5;\n    ELSIF p_rank_level = 6 THEN\n        SELECT AVG(\"Major_Code\") INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" <= 3;\n    ELSIF p_rank_level = 7 THEN\n        SELECT MAX(\"Major_Code\") INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" > 3;\n    ELSIF p_rank_level = 8 THEN\n        SELECT MIN(\"Major_Code\") INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" BETWEEN 2 AND 4;\n    ELSIF p_rank_level = 9 THEN\n        SELECT SUM(\"Major_Code\") INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\" WHERE mr.\"Rank\" < 5;\n    ELSIF p_rank_level = 10 THEN\n        SELECT COUNT(DISTINCT m.\"Major_Code\") INTO stat_result FROM major m JOIN major_ranking mr ON m.\"Major_ID\" = mr.\"Major_ID\";\n    ELSE\n        SELECT 0 INTO stat_result;\n    END IF;\n    RETURN COALESCE(stat_result, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking"
    ],
    "call_sqls": [
      "SELECT calculate_major_statistics_by_rank(1);",
      "SELECT calculate_major_statistics_by_rank(5);",
      "SELECT calculate_major_statistics_by_rank(6);",
      "SELECT calculate_major_statistics_by_rank(8);",
      "SELECT calculate_major_statistics_by_rank(10);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named calculate_major_statistics_by_rank that takes an integer parameter p_rank_level and returns an integer. Based on p_rank_level, it queries joined 'major' and 'major_ranking' tables to compute a statistic: for levels 1-5, return the count of rows with matching Rank; for level 6, return the average Major_Code where Rank <=3; for level 7, return the max Major_Code where Rank >3; for level 8, return the min Major_Code where Rank between 2 and 4; for level 9, return the sum of Major_Code where Rank <5; for level 10, return the count of distinct Major_Code. For any other level, return 0. Use COALESCE to handle nulls.",
    "natural_language": "Please construct a PostgreSQL PL/pgSQL function entitled 'calculate_major_statistics_by_rank'. This function shall accept a single integer parameter, designated as `p_rank_level`, and shall return an integer value. The function's logic is to be derived from a join of the 'major' and 'major_ranking' tables. The specific computation is contingent upon the provided `p_rank_level` parameter, as follows: for parameter values 1 through 5, the function must return the count of rows where the 'Rank' matches the parameter. For a parameter value of 6, it shall return the average of the 'Major_Code' for records where 'Rank' is less than or equal to 3. For a value of 7, it must return the maximum 'Major_Code' where 'Rank' exceeds 3. For a value of 8, it should return the minimum 'Major_Code' where 'Rank' falls within the inclusive range of 2 to 4. For a value of 9, it is to return the summation of all 'Major_Code' values where 'Rank' is less than 5. For a value of 10, the function must return the count of distinct 'Major_Code' values. Should the `p_rank_level` parameter correspond to none of the aforementioned cases, the function is to return 0. It is imperative to employ the COALESCE function to manage any potential null results appropriately.",
    "id": 226
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_city_code of type text, representing a city code, and returns a table with three columns: StuID of type bigint, Fname of type text, and LName of type text. The function retrieves data from the Student table by executing a SELECT query that filters rows based on the condition that the city_code column in the Student table matches the value of the input parameter p_city_code. Specifically, the function performs the following operations: it queries the Student table, selecting the StuID column, which represents the unique identifier for a student; the Fname column, which stores the first name of the student; and the LName column, which stores the last name of the student. The WHERE clause in the query ensures that only rows where the city_code column equals the value of p_city_code are included in the result set. The function uses the RETURN QUERY statement to return the filtered rows as the output of the function. The function is implemented in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_city_students(p_city_code text)\nRETURNS TABLE(StuID bigint, Fname text, LName text) AS $$\nBEGIN\n    RETURN QUERY SELECT \"StuID\", \"Fname\", \"LName\" FROM \"Student\" WHERE \"city_code\" = p_city_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_city_students('BAL');",
      "SELECT * FROM get_city_students('PIT');",
      "SELECT * FROM get_city_students('PHL');",
      "SELECT * FROM get_city_students('HKG');",
      "SELECT * FROM get_city_students('WAS');"
    ],
    "summary": "Create a PLpgSQL function that takes a text parameter p_city_code and returns a table with columns StuID (bigint), Fname (text), and LName (text). The function queries the Student table, selecting those columns for rows where the city_code column matches the input p_city_code, and returns the result set using RETURN QUERY.",
    "natural_language": "How can I create a PLpgSQL function that accepts a text parameter called p_city_code and returns a table containing StuID (as bigint), Fname (text), and LName (text) for all students in the Student table whose city_code matches the provided parameter?",
    "id": 227
  },
  {
    "ir": "Write a PLpgSQL function named get_distance_between_cities that accepts two input parameters, p_city1_code of type text and p_city2_code of type text, and returns a single bigint value; the function's logic consists of executing a SELECT query on the table named Direct_distance, specifically retrieving the value from the column named distance for the row where the column city1_code is equal to the first input parameter p_city1_code and simultaneously the column city2_code is equal to the second input parameter p_city2_code, and then returning that retrieved distance value directly as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_distance_between_cities(p_city1_code text, p_city2_code text)\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT \"distance\" FROM \"Direct_distance\" WHERE \"city1_code\" = p_city1_code AND \"city2_code\" = p_city2_code);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_distance_between_cities('BAL', 'PIT');",
      "SELECT get_distance_between_cities('PHL', 'BAL');",
      "SELECT get_distance_between_cities('ATL', 'BKK');",
      "SELECT get_distance_between_cities('BAL', 'BAL');",
      "SELECT get_distance_between_cities('PIT', 'PHL');"
    ],
    "summary": "Create a PL/pgSQL function named get_distance_between_cities that takes two text parameters (p_city1_code, p_city2_code) and returns a bigint. The function selects the distance column from the Direct_distance table where city1_code equals p_city1_code and city2_code equals p_city2_code, then returns that value.",
    "natural_language": "Write a PL/pgSQL function called get_distance_between_cities that accepts a couple of text inputs for city codes and gives back a big integer. It should look in the Direct_distance table and return the distance value for when the city codes are roughly matching the provided ones.",
    "id": 228
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_students_by_major` that accepts a single input parameter, `p_major`, which is of data type `bigint`. This function is designed to return a set of records, effectively acting as a table-returning function. The structure of the returned table is defined by four columns: `StuID` of type `bigint`, `Fname` of type `text`, `LName` of type `text`, and `Age` of type `bigint`. The core operation of this function involves executing a `SELECT` statement. Specifically, it selects the columns `StuID`, `Fname`, `LName`, and `Age` from the table named `\"Student\"`. The selection of rows from the `\"Student\"` table is filtered by a `WHERE` clause, which specifies that only those rows where the value in the `\"Major\"` column is equal to the value provided in the input parameter `p_major` should be included in the result set. The `RETURN QUERY` statement is used to return the entire result set of this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_by_major(p_major bigint)\nRETURNS TABLE(StuID bigint, Fname text, LName text, Age bigint) AS $$\nBEGIN\n    RETURN QUERY SELECT \"StuID\", \"Fname\", \"LName\", \"Age\" FROM \"Student\" WHERE \"Major\" = p_major;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_by_major(600);",
      "SELECT * FROM get_students_by_major(1121);",
      "SELECT * FROM get_students_by_major(7712);",
      "SELECT * FROM get_students_by_major(7792);",
      "SELECT * FROM get_students_by_major(1001);"
    ],
    "summary": "Create a PL/pgSQL function named get_students_by_major that takes a bigint parameter p_major and returns a table with columns (StuID bigint, Fname text, LName text, Age bigint). The function returns a query selecting StuID, Fname, LName, and Age from the \"Student\" table where the \"Major\" column equals p_major.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_students_by_major'. This function shall accept a single input parameter of type bigint, named 'p_major'. It is required to return a table comprising the following columns: StuID (bigint), Fname (text), LName (text), and Age (bigint). The function's logic must execute a query to select the StuID, Fname, LName, and Age fields from the database table named \"Student\", specifically for those records where the value in the \"Major\" column is equivalent to the provided 'p_major' parameter.",
    "id": 229
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_city_code of type text, retrieves data from the City table, and returns a result set containing two columns: latitude and longitude, both of type double precision. The function begins by executing a SQL SELECT query on the City table, specifically targeting the latitude and longitude columns. The query includes a WHERE clause that filters rows based on the condition that the city_code column in the City table matches the value of the input parameter p_city_code. The function uses the RETURN QUERY statement to return the result set directly to the caller. The City table is referenced with its column names enclosed in double quotes, indicating case sensitivity or special characters in the column names. The function is written in the PLpgSQL language and is designed to return a table structure with the specified columns and data types.",
    "plsql": "CREATE OR REPLACE FUNCTION get_city_coordinates(p_city_code text)\nRETURNS TABLE(latitude double precision, longitude double precision) AS $$\nBEGIN\n    RETURN QUERY SELECT \"City\".\"latitude\", \"City\".\"longitude\" FROM \"City\" WHERE \"city_code\" = p_city_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_city_coordinates('BAL');",
      "SELECT * FROM get_city_coordinates('PIT');",
      "SELECT * FROM get_city_coordinates('PHL');",
      "SELECT * FROM get_city_coordinates('ATL');",
      "SELECT * FROM get_city_coordinates('BKK');"
    ],
    "summary": "Create a PL/pgSQL function that takes a text parameter p_city_code and returns a table with columns (latitude double precision, longitude double precision). The function returns a query selecting the latitude and longitude columns from the City table where the city_code column equals p_city_code.",
    "natural_language": "Function returning latitude and longitude for a given city code.",
    "id": 230
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_students_in_country` that accepts one input parameter, `p_country`, which is of type `text`. This function is designed to return a set of records, effectively acting as a table, with each record containing four columns: `StuID` of type `bigint`, `Fname` of type `text`, `LName` of type `text`, and `city_name` of type `text`. The core operation of this function is to perform a `SELECT` query to retrieve specific student and city information. The query selects the `StuID` column from the `\"Student\"` table, aliased as `s`, the `Fname` column from the `\"Student\"` table, aliased as `s`, the `LName` column from the `\"Student\"` table, aliased as `s`, and the `city_name` column from the `\"City\"` table, aliased as `c`. This selection is performed by joining the `\"Student\"` table (aliased as `s`) with the `\"City\"` table (aliased as `c`). The join condition specifies that records from `\"Student\"` and `\"City\"` tables are matched when the value in the `city_code` column of the `\"Student\"` table is equal to the value in the `city_code` column of the `\"City\"` table. Furthermore, the results are filtered by a `WHERE` clause, which ensures that only records where the `country` column in the `\"City\"` table (aliased as `c`) is equal to the value provided in the input parameter `p_country` are included in the final output. The `RETURN QUERY` statement then returns the entire result set of this `SELECT` statement as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_in_country(p_country text)\nRETURNS TABLE(StuID bigint, Fname text, LName text, city_name text) AS $$\nBEGIN\n    RETURN QUERY SELECT s.\"StuID\", s.\"Fname\", s.\"LName\", c.\"city_name\"\n                 FROM \"Student\" s\n                 JOIN \"City\" c ON s.\"city_code\" = c.\"city_code\"\n                 WHERE c.\"country\" = p_country;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_in_country('USA');",
      "SELECT * FROM get_students_in_country('Canada');",
      "SELECT StuID, Fname FROM get_students_in_country('USA') WHERE city_name = 'Baltimore';",
      "SELECT * FROM get_students_in_country('Mexico');",
      "SELECT COUNT(*) FROM get_students_in_country('USA');"
    ],
    "summary": "Create a PL/pgSQL function named get_students_in_country that takes a text parameter p_country and returns a table with columns (StuID bigint, Fname text, LName text, city_name text). The function returns a query selecting s.StuID, s.Fname, s.LName, and c.city_name from the \"Student\" table s joined with the \"City\" table c on s.city_code = c.city_code, where c.country equals p_country.",
    "natural_language": "Write a PL/pgSQL function called get_students_in_country that accepts a text parameter p_country and outputs a table with columns StuID (bigint), Fname (text), LName (text), and city_name (text). The function must execute a query that selects s.StuID, s.Fname, s.LName, and c.city_name from the \"Student\" table s, inner-joining the \"City\" table c on s.city_code = c.city_code, filtering for rows where c.country matches the provided p_country.",
    "id": 231
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_department_count` that accepts a single input parameter, `p_location_id`, which is of the `numeric` data type. This function is designed to return an `integer` value. Inside the function, a local variable named `v_count` of type `integer` is declared to store the result of a count operation. The core logic of the function is controlled by a conditional statement: it first checks if the value of the input parameter `p_location_id` is strictly greater than `1500`. If this condition evaluates to true, the function proceeds to execute a `SELECT` statement. This `SELECT` statement counts the total number of rows (`COUNT(*)`) from the table named `\"departments\"`. The result of this count is then assigned to the local variable `v_count`. The `SELECT` statement includes a `WHERE` clause that filters the rows based on the condition that the value in the column named `\"LOCATION_ID\"` within the `\"departments\"` table must be equal to the value of the input parameter `p_location_id`. If the initial condition (`p_location_id > 1500`) evaluates to false, the `SELECT` statement is not executed, and the `v_count` variable retains its default uninitialized value (which would be `NULL` in PL/pgSQL for an integer variable if not explicitly assigned). Finally, the function returns the current value of the `v_count` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_count(p_location_id numeric)\nRETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    IF p_location_id > 1500 THEN\n        SELECT COUNT(*) INTO v_count FROM \"departments\" WHERE \"LOCATION_ID\" = p_location_id;\n    END IF;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_department_count(1700);",
      "SELECT get_department_count(1800);",
      "SELECT get_department_count(2000);",
      "SELECT get_department_count(1501);",
      "SELECT get_department_count(2500);"
    ],
    "summary": "Create a function named get_department_count that takes a numeric p_location_id and returns an integer. If p_location_id > 1500, set a variable v_count to the number of rows in the departments table where LOCATION_ID equals p_location_id. Return v_count.",
    "natural_language": "Create a function called get_department_count, which accepts a numeric input parameter named p_location_id and is designed to return an integer value. In the detailed implementation, if the provided p_location_id is found to be greater than 1500, you should carefully assign a variable named v_count. This variable must be set to the precise count of rows retrieved from the departments table, specifically where the LOCATION_ID column matches the supplied p_location_id parameter. Finally, the function should explicitly return the calculated v_count.",
    "id": 232
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_nth_highest_salary` that accepts a single input parameter, `p_position`, which is of type `integer`. The purpose of this function is to retrieve the salary value corresponding to the Nth highest salary found within the `employees` table, where N is determined by the value of `p_position`. The function declares a local variable `v_salary` of type `numeric` to temporarily store the retrieved salary. The function's execution flow is controlled by a conditional statement: if the value of `p_position` is strictly greater than `0`, then a `SELECT` statement is executed. This `SELECT` statement queries the `employees` table. Within this query, the `nth_value` window function is applied to the `\"SALARY\"` column. The `nth_value` function is configured to retrieve the value at the position specified by `p_position` within the ordered set of salaries. The ordering for this window function is established by sorting the `\"SALARY\"` column in `DESC`ending order, meaning from highest to lowest salary. The result of this `nth_value` operation is then limited to a single row using `LIMIT 1` and the extracted salary value is assigned to the local variable `v_salary`. If the condition `p_position > 0` is not met (i.e., `p_position` is `0` or negative), the `SELECT` statement is skipped, and `v_salary` retains its default (likely `NULL`) value. Finally, the function returns the value stored in `v_salary` as its output, which is of type `numeric`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_nth_highest_salary(p_position integer)\nRETURNS numeric AS $$\nDECLARE\n    v_salary numeric;\nBEGIN\n    IF p_position > 0 THEN\n        SELECT nth_value(\"SALARY\", p_position) OVER (ORDER BY \"SALARY\" DESC) INTO v_salary FROM \"employees\" LIMIT 1;\n    END IF;\n    RETURN v_salary;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_nth_highest_salary(1);",
      "SELECT get_nth_highest_salary(2);",
      "SELECT get_nth_highest_salary(3);",
      "SELECT get_nth_highest_salary(4);",
      "SELECT get_nth_highest_salary(5);"
    ],
    "summary": "Create a function named get_nth_highest_salary that takes an integer p_position and returns a numeric. If p_position > 0, set a variable v_salary to the Nth highest salary (where N is p_position) from the employees table, ordered descending. Return v_salary.",
    "natural_language": "Define a function called `get_nth_highest_salary` that accepts an integer parameter `p_position` and yields a numeric value. The function's logic shall be as follows: if the provided `p_position` is greater than zero, assign to a variable `v_salary` the salary value corresponding to the Nth highest distinct salary, where N equals `p_position`, as retrieved from the `employees` table in descending order. Subsequently, return the value of `v_salary`.",
    "id": 233
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns a table containing the columns StuID (bigint), Fname (text), LName (text), PetType (text), and pet_age (bigint) by performing a query that joins three tables: \"Student\", \"Has_Pet\", and \"Pets\". The function does not take any input parameters and is designed to return a result set. The query begins by selecting the \"StuID\", \"Fname\", and \"LName\" columns from the \"Student\" table, which represents student information. It then performs an inner join between the \"Student\" table and the \"Has_Pet\" table on the condition that the \"StuID\" column in the \"Student\" table matches the \"StuID\" column in the \"Has_Pet\" table. The \"Has_Pet\" table serves as a linking table that associates students with their pets through the \"StuID\" and \"PetID\" columns. Next, the query performs another inner join between the \"Has_Pet\" table and the \"Pets\" table on the condition that the \"PetID\" column in the \"Has_Pet\" table matches the \"PetID\" column in the \"Pets\" table. The \"Pets\" table contains information about the pets, including the \"PetType\" column, which specifies the type of pet, and the \"pet_age\" column, which specifies the age of the pet. The result of the query is a combined dataset that includes the student ID, first name, last name, pet type, and pet age for all students who have pets, and this dataset is returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_with_pets()\nRETURNS TABLE(StuID bigint, Fname text, LName text, PetType text, pet_age bigint) AS $$\nBEGIN\n  RETURN QUERY \n  SELECT s.\"StuID\", s.\"Fname\", s.\"LName\", p.\"PetType\", p.\"pet_age\"\n  FROM \"Student\" s\n  JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n  JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_with_pets();"
    ],
    "summary": "Create a function that returns a table with columns StuID (bigint), Fname (text), LName (text), PetType (text), and pet_age (bigint). The function should join the Student, Has_Pet, and Pets tables on their respective ID columns to return data for all students who have pets.",
    "natural_language": "Please construct a function that yields a table comprising the following columns: StuID, of type bigint; Fname and LName, both of type text; PetType, of type text; and pet_age, of type bigint. The function must execute a join operation on the Student, Has_Pet, and Pets tables, utilizing their respective identifier columns, to retrieve data for every student who possesses a pet.",
    "id": 234
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_students_with_heavy_pets that returns a table structure with columns StuID of type bigint, Fname of type text, LName of type text, PetID of type bigint, and weight of type real, and whose body begins by executing a RETURN QUERY operation to produce and return the result set from a SELECT statement that queries the Student table aliased as s, joining it with the Has_Pet table aliased as hp on the condition that the StuID column from the Student table equals the StuID column from the Has_Pet table, and further joining the result with the Pets table aliased as p on the condition that the PetID column from the Has_Pet table equals the PetID column from the Pets table, and finally applying a WHERE filter to include only those rows where the weight column from the Pets table is strictly greater than the numeric value 10.0, thereby selecting and returning the StuID, Fname, and LName columns from the Student table along with the PetID and weight columns from the Pets table for every student-pet combination where the associated pet's weight exceeds 10.0.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_with_heavy_pets()\nRETURNS TABLE(StuID bigint, Fname text, LName text, PetID bigint, weight real) AS $$\nBEGIN\n  RETURN QUERY \n  SELECT s.\"StuID\", s.\"Fname\", s.\"LName\", p.\"PetID\", p.\"weight\"\n  FROM \"Student\" s\n  JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n  JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\"\n  WHERE p.\"weight\" > 10.0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_with_heavy_pets();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_students_with_heavy_pets that returns a table (StuID bigint, Fname text, LName text, PetID bigint, weight real). The function uses RETURN QUERY to select from the Student (s), Has_Pet (hp), and Pets (p) tables. Join s to hp on s.StuID = hp.StuID, then join to p on hp.PetID = p.PetID. Filter where p.weight > 10.0 and return s.StuID, s.Fname, s.LName, p.PetID, p.weight.",
    "natural_language": "Please construct a PostgreSQL PL/pgSQL function entitled 'get_students_with_heavy_pets'. This function shall be defined to return a table comprising the following columns: StuID of type bigint, Fname of type text, LName of type text, PetID of type bigint, and weight of type real. The implementation must utilize the RETURN QUERY statement to execute a selection from the Student (aliased as 's'), Has_Pet (aliased as 'hp'), and Pets (aliased as 'p') tables. It is required to perform an inner join from the Student table to the Has_Pet table on the condition s.StuID = hp.StuID, followed by an inner join to the Pets table on the condition hp.PetID = p.PetID. The result set must be filtered to include only those records where the pet's weight exceeds 10.0. The final output of the query should be the columns s.StuID, s.Fname, s.LName, p.PetID, and p.weight.",
    "id": 235
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_students_with_pet_age_mod that returns a table structure with five columns: StuID of type bigint, Fname of type text, LName of type text, PetID of type bigint, and pet_age_mod of type bigint. The function begins execution by issuing a RETURN QUERY command to return the result set of a SELECT statement. This SELECT statement retrieves data from three tables: Student (aliased as s), Has_Pet (aliased as hp), and Pets (aliased as p). It specifically selects the StuID column from the Student table, the Fname column from the Student table, the LName column from the Student table, the PetID column from the Pets table, and a computed column using the MOD function. The MOD function is applied to the pet_age column from the Pets table with a divisor of 2, and the result is aliased as pet_age_mod. The tables are joined using INNER JOIN operations: first, the Student table is joined with the Has_Pet table on the condition that the StuID column from Student equals the StuID column from Has_Pet. Then, the result of that join is joined with the Pets table on the condition that the PetID column from Has_Pet equals the PetID column from Pets. The function returns all rows resulting from this joined query, effectively listing each student, their associated pet, and a modified pet age which is the remainder when the pet's age is divided by two.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_with_pet_age_mod()\nRETURNS TABLE(StuID bigint, Fname text, LName text, PetID bigint, pet_age_mod bigint) AS $$\nBEGIN\n  RETURN QUERY \n  SELECT s.\"StuID\", s.\"Fname\", s.\"LName\", p.\"PetID\", MOD(p.\"pet_age\", 2) AS pet_age_mod\n  FROM \"Student\" s\n  JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n  JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_with_pet_age_mod();",
      "SELECT StuID, Fname, LName FROM get_students_with_pet_age_mod() WHERE pet_age_mod = 0;",
      "SELECT * FROM get_students_with_pet_age_mod() WHERE LName = 'Smith';",
      "SELECT * FROM get_students_with_pet_age_mod() ORDER BY pet_age_mod DESC, LName;",
      "SELECT COUNT(*) AS student_count, AVG(pet_age_mod) AS avg_age_mod FROM get_students_with_pet_age_mod();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_students_with_pet_age_mod that returns a table (StuID bigint, Fname text, LName text, PetID bigint, pet_age_mod bigint). The function uses RETURN QUERY to select from the Student (s), Has_Pet (hp), and Pets (p) tables. Join s to hp on s.StuID = hp.StuID, then join to p on hp.PetID = p.PetID. Return s.StuID, s.Fname, s.LName, p.PetID, and MOD(p.pet_age, 2) as pet_age_mod.",
    "natural_language": "What PostgreSQL PL/pgSQL function can be created to return a table with StuID, Fname, LName, PetID, and pet_age_mod by selecting and joining the Student, Has_Pet, and Pets tables, and calculating MOD(p.pet_age, 2)?",
    "id": 236
  },
  {
    "ir": "Write a PLpgSQL function that returns a table with four columns: Department_ID (integer), Department_Name (text), Head_Name (text), and Head_Age (real). The function retrieves data by performing a SELECT query that joins three tables: department, management, and head. The department table is aliased as \"d\" and contains the columns Department_ID and Name, where Department_ID is the unique identifier for each department, and Name represents the department's name. The management table is aliased as \"m\" and contains the columns department_ID and head_ID, where department_ID is a foreign key referencing the Department_ID column in the department table, and head_ID is a foreign key referencing the head_ID column in the head table. The head table is aliased as \"h\" and contains the columns name and age, where name represents the name of the department head, and age represents the age of the department head. The function filters the results to include only those rows where the age of the department head (h.age) is greater than 60. The SELECT query retrieves the Department_ID and Name columns from the department table, the name column from the head table as Head_Name, and the age column from the head table as Head_Age. The function uses the RETURN QUERY statement to return the result set of the SELECT query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_head_details()\nRETURNS TABLE(\"Department_ID\" integer, \"Department_Name\" text, \"Head_Name\" text, \"Head_Age\" real) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT d.\"Department_ID\", d.\"Name\", h.\"name\", h.\"age\"\n  FROM \"department\" d\n  JOIN \"management\" m ON d.\"Department_ID\" = m.\"department_ID\"\n  JOIN \"head\" h ON m.\"head_ID\" = h.\"head_ID\"\n  WHERE h.\"age\" > 60;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT * FROM get_department_head_details();"
    ],
    "summary": "Create a PLpgSQL function that returns a table (Department_ID integer, Department_Name text, Head_Name text, Head_Age real). The function uses RETURN QUERY to select from the department (d), management (m), and head (h) tables. Join d to m on d.Department_ID = m.department_ID, then join to h on m.head_ID = h.head_ID. Filter where h.age > 60. Return d.Department_ID, d.Name as Department_Name, h.name as Head_Name, and h.age as Head_Age.",
    "natural_language": "What are the department ID, department name, head name, and head age for departments where the head is over 60 years old? The data should be retrieved by joining the department, management, and head tables.",
    "id": 237
  },
  {
    "ir": "Write a PLpgSQL function that retrieves data from the department table and returns a result set containing three columns: Department_ID (integer), Department_Name (text), and Employee_Category (text). The function does not take any input parameters and is designed to classify departments based on the number of employees they have. It begins by executing a SELECT query on the department table, which is aliased as d. The query retrieves the Department_ID column, the Name column (renamed as Department_Name in the output), and a derived column named Employee_Category. The Employee_Category column is determined using a CASE statement that evaluates the Num_Employees column of the department table. Specifically, if the value of Num_Employees exceeds 100,000, the Employee_Category is set to 'Large'; if the value falls between 50,000 and 100,000 (inclusive), the Employee_Category is set to 'Medium'; otherwise, the Employee_Category is set to 'Small'. The function uses the RETURN QUERY statement to return the result set directly to the caller. The function is implemented in the PLpgSQL language and is designed to provide a categorized view of department data based on employee count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_employee_stats()\nRETURNS TABLE(\"Department_ID\" integer, \"Department_Name\" text, \"Employee_Category\" text) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT d.\"Department_ID\", d.\"Name\",\n         CASE \n           WHEN d.\"Num_Employees\" > 100000 THEN 'Large'\n           WHEN d.\"Num_Employees\" BETWEEN 50000 AND 100000 THEN 'Medium'\n           ELSE 'Small'\n         END AS \"Employee_Category\"\n  FROM \"department\" d;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT * FROM get_department_employee_stats();",
      "SELECT \"Department_ID\", \"Department_Name\" FROM get_department_employee_stats() WHERE \"Employee_Category\" = 'Large';",
      "SELECT * FROM get_department_employee_stats() ORDER BY \"Department_ID\";",
      "SELECT \"Department_Name\", \"Employee_Category\" FROM get_department_employee_stats() WHERE \"Employee_Category\" IN ('Medium', 'Small');",
      "SELECT COUNT(*) AS total_departments, \"Employee_Category\" FROM get_department_employee_stats() GROUP BY \"Employee_Category\";"
    ],
    "summary": "Create a PLpgSQL function that returns a table (Department_ID integer, Department_Name text, Employee_Category text). The function uses RETURN QUERY to select from the department table (d). Return d.Department_ID, d.Name as Department_Name, and a CASE expression: when d.Num_Employees > 100000 then 'Large', when d.Num_Employees between 50000 and 100000 then 'Medium', else 'Small' end as Employee_Category.",
    "natural_language": "Hey, can you whip up a PLpgSQL function that spits out a table with Department_ID (as an integer), Department_Name (as text), and Employee_Category (as text)? Use RETURN QUERY to grab stuff from the department table (call it 'd'). We need d.Department_ID, d.Name labeled as Department_Name, and then figure out the Employee_Category with a CASE thing: if d.Num_Employees is over 100,000, call it 'Large'; if it's between 50,000 and 100,000, call it 'Medium'; otherwise, just tag it as 'Small'.",
    "id": 238
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_department_ranking_summary` that returns a table with two columns: `\"Ranking\"` of type `integer` and `\"Department_Count\"` of type `integer`. This function performs a selection operation on the `department` table. It groups the rows of the `department` table based on the values in its `\"Ranking\"` column. For each distinct group formed by the `\"Ranking\"` column, it calculates the count of rows within that group. This count is then explicitly cast to an `integer` data type. The function then filters these grouped results, retaining only those groups where the calculated count of rows is strictly greater than 1. Finally, for each of the filtered groups, it selects the distinct value of the `\"Ranking\"` column and the calculated count of rows, returning these as the `\"Ranking\"` and `\"Department_Count\"` columns, respectively, in the result set.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_ranking_summary()\nRETURNS TABLE(\"Ranking\" integer, \"Department_Count\" integer) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT d.\"Ranking\", COUNT(*)::integer\n  FROM \"department\" d\n  GROUP BY d.\"Ranking\"\n  HAVING COUNT(*) > 1;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT * FROM get_department_ranking_summary();",
      "SELECT \"Ranking\", \"Department_Count\" FROM get_department_ranking_summary();",
      "SELECT * FROM get_department_ranking_summary() WHERE \"Ranking\" < 5;",
      "SELECT \"Ranking\", \"Department_Count\" FROM get_department_ranking_summary() ORDER BY \"Ranking\" DESC;",
      "SELECT * FROM get_department_ranking_summary() WHERE \"Department_Count\" > 2;"
    ],
    "summary": "Create a PL/pgSQL function named `get_department_ranking_summary` that returns a table with columns `Ranking` (integer) and `Department_Count` (integer). The function should group the `department` table by the `Ranking` column, count the number of departments in each group, and return only those groups where the count is greater than 1.",
    "natural_language": "What is the PL/pgSQL function definition for `get_department_ranking_summary` that returns a table with `Ranking` and `Department_Count` columns, grouping the department table by ranking, counting departments per group, and filtering for groups with a count greater than 1?",
    "id": 239
  },
  {
    "ir": "Write a PL/pgSQL function named `calculate_settlement_ratio` that accepts two input parameters: `claim_id` of type `bigint` and `settlement_id` of type `bigint`. This function is designed to return a `decimal` value representing a calculated ratio. The core operation of the function involves executing a `SELECT` statement against the `\"Claims\"` table. Within this `SELECT` statement, it retrieves two column values: `\"Amount_Settled\"` and `\"Amount_Claimed\"`. The `\"Amount_Settled\"` column's value is explicitly cast to a `decimal` data type. This cast `decimal` value of `\"Amount_Settled\"` is then divided by the value of the `\"Amount_Claimed\"` column. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `\"Claims\"` table, ensuring that only the row where the `\"Claim_ID\"` column's value matches the input parameter `claim_id` is considered for the calculation. The result of this division operation, which is a `decimal` value, is then returned as the output of the `calculate_settlement_ratio` function. The `settlement_id` parameter is declared but not utilized within the current implementation of the function's logic.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_settlement_ratio(\"claim_id\" bigint, \"settlement_id\" bigint)\nRETURNS decimal AS $$\nBEGIN\n    RETURN (SELECT (\"Amount_Settled\"::decimal / \"Amount_Claimed\") FROM \"Claims\" WHERE \"Claim_ID\" = \"claim_id\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT calculate_settlement_ratio(143, 357);",
      "SELECT calculate_settlement_ratio(423, 412);",
      "SELECT calculate_settlement_ratio(442, 476);",
      "SELECT calculate_settlement_ratio(143, NULL);",
      "SELECT calculate_settlement_ratio(423, NULL);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_settlement_ratio` that takes `claim_id` (bigint) and `settlement_id` (bigint) as parameters and returns a decimal. The function should calculate and return the ratio of `Amount_Settled` to `Amount_Claimed` from the `Claims` table for the specified `claim_id`. The `settlement_id` parameter is not used.",
    "natural_language": "How can I create a PL/pgSQL function named `calculate_settlement_ratio` that returns a decimal by calculating the ratio of `Amount_Settled` to `Amount_Claimed` from the `Claims` table for a given `claim_id`, while accepting an unused `settlement_id` parameter?",
    "id": 240
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, claim_id of type bigint and hour_offset of type integer, and calculates the processing time for a specific claim by performing the following operations: It queries the Claims table to retrieve the Date_Claim_Settled and Date_Claim_Made columns for the row where the Claim_ID column matches the value of the claim_id parameter. It then calculates the difference between the Date_Claim_Settled and Date_Claim_Made columns, which represents the number of days between the claim being made and the claim being settled. This difference is multiplied by the interval '1 day' to convert the result into an interval type. Additionally, the function adds an interval created using the make_interval function, which takes the hour_offset parameter as the number of hours to include in the interval. The final result is an interval value representing the total processing time for the claim, including the additional hours specified by the hour_offset parameter. The function returns this interval value as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_processing_time(\"claim_id\" bigint, \"hour_offset\" integer)\nRETURNS interval AS $$\nBEGIN\n    RETURN (SELECT ((\"Date_Claim_Settled\" - \"Date_Claim_Made\") * INTERVAL '1 day' + make_interval(hours => \"hour_offset\")) FROM \"Claims\" WHERE \"Claim_ID\" = \"claim_id\");\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT get_processing_time(143, 5);",
      "SELECT get_processing_time(423, 10);",
      "SELECT get_processing_time(442, 3);",
      "SELECT get_processing_time(143, 8);",
      "SELECT get_processing_time(423, 12);"
    ],
    "summary": "Create a PL/pgSQL function that calculates the processing interval for a claim. It retrieves the Date_Claim_Made and Date_Claim_Settled for a given claim_id, calculates the day difference, converts it to an interval, and adds a specified number of hours. Return the total interval.",
    "natural_language": "Write a function to compute a claim's processing interval. For a given claim_id, find Date_Claim_Made and Date_Claim_Settled, get day difference, convert to interval, add specified hours, and return total interval.",
    "id": 241
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_gymnast_total_points` that accepts two input parameters: `gymnast_id` of type `integer`, representing the unique identifier of a gymnast, and `event_name` of type `text`, representing the name of a specific gymnastics event. This function is designed to return a single value of type `real`, which will be the total points scored by the specified gymnast in the given event.\n\nThe function begins by declaring a local variable named `total_points` of type `real` to store the retrieved points.\n\nThe core logic of the function is implemented using a series of conditional `IF-ELSIF-ELSE` statements, which evaluate the value of the `event_name` parameter to determine which specific points column to query from the `\"gymnast\"` table.\n\n1.  **If** `event_name` is exactly equal to the string `'Floor_Exercise'`, the function executes a `SELECT` statement to retrieve the value from the `\"Floor_Exercise_Points\"` column of the `\"gymnast\"` table. This value is then assigned to the `total_points` variable. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Gymnast_ID\"` column matches the input `gymnast_id` parameter is considered.\n\n2.  **Else If** `event_name` is exactly equal to the string `'Pommel_Horse'`, the function executes a `SELECT` statement to retrieve the value from the `\"Pommel_Horse_Points\"` column of the `\"gymnast\"` table. This value is then assigned to the `total_points` variable. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Gymnast_ID\"` column matches the input `gymnast_id` parameter is considered.\n\n3.  **Else If** `event_name` is exactly equal to the string `'Rings'`, the function executes a `SELECT` statement to retrieve the value from the `\"Rings_Points\"` column of the `\"gymnast\"` table. This value is then assigned to the `total_points` variable. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Gymnast_ID\"` column matches the input `gymnast_id` parameter is considered.\n\n4.  **Else If** `event_name` is exactly equal to the string `'Vault'`, the function executes a `SELECT` statement to retrieve the value from the `\"Vault_Points\"` column of the `\"gymnast\"` table. This value is then assigned to the `total_points` variable. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Gymnast_ID\"` column matches the input `gymnast_id` parameter is considered.\n\n5.  **Else If** `event_name` is exactly equal to the string `'Parallel_Bars'`, the function executes a `SELECT` statement to retrieve the value from the `\"Parallel_Bars_Points\"` column of the `\"gymnast\"` table. This value is then assigned to the `total_points` variable. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Gymnast_ID\"` column matches the input `gymnast_id` parameter is considered.\n\n6.  **Else If** `event_name` is exactly equal to the string `'Horizontal_Bar'`, the function executes a `SELECT` statement to retrieve the value from the `\"Horizontal_Bar_Points\"` column of the `\"gymnast\"` table. This value is then assigned to the `total_points` variable. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `\"Gymnast_ID\"` column matches the input `gymnast_id` parameter is considered.\n\n7.  **Else** (if `event_name` does not match any of the specified event names), the `total_points` variable is explicitly assigned a `NULL` value.\n\nFinally, after the conditional logic has been executed and `total_points` has been assigned a value (either from a database query or `NULL`), the function returns the current value of the `total_points` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_total_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT \"Floor_Exercise_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT \"Pommel_Horse_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT \"Rings_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT \"Vault_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT \"Parallel_Bars_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT \"Horizontal_Bar_Points\" INTO total_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        total_points := NULL;\n    END IF;\n    RETURN total_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_total_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_total_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_total_points(4, 'Rings');",
      "SELECT get_gymnast_total_points(1, 'Vault');",
      "SELECT get_gymnast_total_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PL/pgSQL function named get_gymnast_total_points that returns a real value. It takes a gymnast_id integer and an event_name text. Using conditional logic, query the gymnast table to return the points from the column corresponding to the event_name (e.g., 'Floor_Exercise' maps to Floor_Exercise_Points) for the given gymnast_id. If the event_name is not recognized, return NULL.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_gymnast_total_points', which shall yield a real data type. This function must accept two parameters: an integer representing a gymnast identifier and a text string denoting an event name. The implementation must employ conditional logic to query the gymnast table. It should retrieve the point value from the column that corresponds to the provided event name; for instance, the input 'Floor_Exercise' should map to the 'Floor_Exercise_Points' column for the specified gymnast identifier. Should the supplied event name not correspond to a recognized column, the function is to return a NULL value.",
    "id": 242
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_gymnast_average_points` that accepts two input parameters: `gymnast_id` of type `integer` and `event_name` of type `text`. This function is designed to calculate and return the average points for a specific gymnast in a particular event, with the return type being `real`.\n\nUpon execution, the function declares a local variable named `average_points` of type `real` to store the calculated average. The core logic of the function is implemented using a series of conditional statements (`IF...ELSIF...ELSE`) that evaluate the value of the `event_name` parameter.\n\nIf the `event_name` is exactly equal to the string literal 'Floor_Exercise', the function executes a `SELECT` statement to calculate the average of the values in the `\"Floor_Exercise_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise' but is exactly equal to the string literal 'Pommel_Horse', the function executes a `SELECT` statement to calculate the average of the values in the `\"Pommel_Horse_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise' or 'Pommel_Horse' but is exactly equal to the string literal 'Rings', the function executes a `SELECT` statement to calculate the average of the values in the `\"Rings_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', or 'Rings' but is exactly equal to the string literal 'Vault', the function executes a `SELECT` statement to calculate the average of the values in the `\"Vault_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', 'Rings', or 'Vault' but is exactly equal to the string literal 'Parallel_Bars', the function executes a `SELECT` statement to calculate the average of the values in the `\"Parallel_Bars_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', 'Rings', 'Vault', or 'Parallel_Bars' but is exactly equal to the string literal 'Horizontal_Bar', the function executes a `SELECT` statement to calculate the average of the values in the `\"Horizontal_Bar_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` does not match any of the specified event names ('Floor_Exercise', 'Pommel_Horse', 'Rings', 'Vault', 'Parallel_Bars', 'Horizontal_Bar'), the `ELSE` block is executed, and the `average_points` variable is explicitly set to `NULL`.\n\nFinally, after the conditional logic has been processed and `average_points` has been assigned a value (either a calculated average or `NULL`), the function returns the value stored in the `average_points` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_average_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    average_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT AVG(\"Floor_Exercise_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT AVG(\"Pommel_Horse_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT AVG(\"Rings_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT AVG(\"Vault_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT AVG(\"Parallel_Bars_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT AVG(\"Horizontal_Bar_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        average_points := NULL;\n    END IF;\n    \n    RETURN average_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_average_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_average_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_average_points(4, 'Rings');",
      "SELECT get_gymnast_average_points(1, 'Vault');",
      "SELECT get_gymnast_average_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PL/pgSQL function named get_gymnast_average_points that returns a real value. It takes a gymnast_id integer and an event_name text. Using conditional logic, calculate the average of the column corresponding to the event_name (e.g., 'Floor_Exercise' maps to Floor_Exercise_Points) from the gymnast table for the given gymnast_id. If the event_name is not recognized, return NULL.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called get_gymnast_average_points that spits back a real number? It needs a gymnast's ID (as an integer) and the name of an event (as text). Basically, you gotta use some IF/ELSE logic to figure out the average score for that specific event column in the gymnast table for that athlete. Like, if the event_name is 'Floor_Exercise', you'd average the Floor_Exercise_Points column. If someone throws in an event name we don't handle, just give back NULL.",
    "id": 243
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, gymnast_id of type integer and event_name of type text, and returns a real value representing the minimum points scored by the specified gymnast in the specified event. The function begins by declaring a local variable min_points of type real to store the result. It then uses a conditional structure to determine the event specified by the event_name parameter. If the event_name matches 'Floor_Exercise', the function executes a SELECT statement to retrieve the minimum value of the \"Floor_Exercise_Points\" column from the \"gymnast\" table for rows where the \"Gymnast_ID\" column matches the gymnast_id parameter, and assigns this value to the min_points variable. Similarly, if the event_name matches 'Pommel_Horse', the function retrieves the minimum value of the \"Pommel_Horse_Points\" column under the same condition and assigns it to min_points. This pattern is repeated for the events 'Rings', 'Vault', 'Parallel_Bars', and 'Horizontal_Bar', with the function querying the respective columns \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", and \"Horizontal_Bar_Points\" in the \"gymnast\" table, always filtering rows based on the \"Gymnast_ID\" column matching the gymnast_id parameter. If the event_name does not match any of the predefined event names, the function assigns NULL to the min_points variable. Finally, the function returns the value stored in min_points.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_event_min_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    min_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT MIN(\"Floor_Exercise_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT MIN(\"Pommel_Horse_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT MIN(\"Rings_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT MIN(\"Vault_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT MIN(\"Parallel_Bars_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT MIN(\"Horizontal_Bar_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        min_points := NULL;\n    END IF;\n    \n    RETURN min_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_event_min_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_event_min_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_event_min_points(4, 'Rings');",
      "SELECT get_gymnast_event_min_points(1, 'Vault');",
      "SELECT get_gymnast_event_min_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PL/pgSQL function that returns a real value representing the minimum points for a gymnast in a specific event. It takes a gymnast_id integer and an event_name text. Using conditional logic, query the gymnast table to find the minimum value from the column corresponding to the event_name for the given gymnast_id. If the event_name is not recognized, return NULL.",
    "natural_language": "Please construct a PL/pgSQL function that yields a real number, which shall represent the minimum score achieved by a specified gymnast in a designated event. The function must accept two parameters: an integer for the gymnast's identifier and a text value for the event name. The implementation shall employ conditional logic to query the gymnast table, retrieving the minimum value from the column that corresponds to the provided event name for the given gymnast identifier. Should the supplied event name not correspond to a recognized column, the function is to return a NULL value.",
    "id": 244
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, gymnast_id of type integer and event_name of type text, and returns a real value representing the total points scored by a gymnast in a specific gymnastics event. The function begins by declaring a local variable total_points of type real to store the result. It then evaluates the value of the event_name parameter using a series of conditional statements (IF, ELSIF). If the event_name is 'Floor_Exercise', the function executes a SELECT statement to calculate the sum of the \"Floor_Exercise_Points\" column from the gymnast table for rows where the \"Gymnast_ID\" column matches the gymnast_id parameter, and assigns the result to the total_points variable. If the event_name is 'Pommel_Horse', it performs a similar operation, summing the \"Pommel_Horse_Points\" column for the specified gymnast_id. This pattern is repeated for the events 'Rings', 'Vault', 'Parallel_Bars', and 'Horizontal_Bar', where the function sums the respective columns \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", and \"Horizontal_Bar_Points\" from the gymnast table for the given gymnast_id. If the event_name does not match any of these predefined values, the function assigns NULL to the total_points variable. Finally, the function returns the value of total_points.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_event_total_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT SUM(\"Floor_Exercise_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT SUM(\"Pommel_Horse_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT SUM(\"Rings_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT SUM(\"Vault_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT SUM(\"Parallel_Bars_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT SUM(\"Horizontal_Bar_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        total_points := NULL;\n    END IF;\n    RETURN total_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_event_total_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_event_total_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_event_total_points(4, 'Rings');",
      "SELECT get_gymnast_event_total_points(1, 'Vault');",
      "SELECT get_gymnast_event_total_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PLpgSQL function that takes a gymnast_id (integer) and an event_name (text) and returns a real value. The function calculates the total points for the specified gymnast by summing the column in the gymnast table that corresponds to the event_name (e.g., 'Floor_Exercise' sums the \"Floor_Exercise_Points\" column). If the event_name is not recognized, return NULL.",
    "natural_language": "How can I create a PLpgSQL function that, given a gymnast's ID and an event name, calculates and returns their total points for that event by summing the corresponding column in the gymnast table, and returns NULL if the event name is not recognized?",
    "id": 245
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named classify_institution_by_enrollment that accepts a single input parameter named inst_id of type text, which represents the unique identifier for an institution, and returns a text value; within the function, declare a local integer variable v_enrollment, then perform a SELECT query on the \"Institution\" table to retrieve the value from its \"Enrollment\" column for the specific row where the \"Institution_id\" column matches the provided inst_id parameter, storing the result into the v_enrollment variable; after the data retrieval, evaluate the value of v_enrollment using a series of conditional IF-ELSIF-ELSE statements: if v_enrollment is greater than 2000, the function returns the text 'Large'; otherwise, if v_enrollment is greater than 1000, it returns 'Medium'; otherwise, if v_enrollment is greater than 500, it returns 'Small'; for all other cases where v_enrollment is 500 or less, the function returns the text 'Micro'.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_institution_by_enrollment(inst_id text)\nRETURNS text AS $$\nDECLARE\n    v_enrollment integer;\nBEGIN\n    SELECT \"Enrollment\" INTO v_enrollment FROM \"Institution\" WHERE \"Institution_id\" = inst_id;\n    IF v_enrollment > 2000 THEN\n        RETURN 'Large';\n    ELSIF v_enrollment > 1000 THEN\n        RETURN 'Medium';\n    ELSIF v_enrollment > 500 THEN\n        RETURN 'Small';\n    ELSE\n        RETURN 'Micro';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "SELECT classify_institution_by_enrollment('0');",
      "SELECT classify_institution_by_enrollment('1');",
      "SELECT classify_institution_by_enrollment('2');",
      "SELECT classify_institution_by_enrollment('3');",
      "SELECT classify_institution_by_enrollment('4');"
    ],
    "summary": "Create a PLpgSQL function named classify_institution_by_enrollment that takes an institution_id (text) and returns a text classification. The function retrieves the enrollment value for the given ID from the Institution table and classifies it as 'Large' (if >2000), 'Medium' (if >1000), 'Small' (if >500), or 'Micro' (if <=500).",
    "natural_language": "Write a PLpgSQL function called classify_institution_by_enrollment that accepts an institution_id as text and outputs a text classification. Fetch the enrollment for the provided ID from the Institution table and label it 'Large' for over 2000, 'Medium' for over 1000, 'Small' for over 500, and 'Micro' for 500 or less.",
    "id": 246
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `categorize_protein_divergence` that accepts a single input parameter named `prot_name` of data type `text`. This function is designed to return a `text` value representing a categorical description of a protein's evolutionary divergence. Inside the function, a local variable named `v_divergence` of data type `real` is declared to temporarily store a numerical divergence value. The function then executes a `SELECT` statement to retrieve the `divergence_from_human_lineage` column's value from the `protein` table. This retrieval is conditional, specifically targeting the row where the `protein_name` column in the `protein` table exactly matches the value provided by the input parameter `prot_name`. The retrieved `divergence_from_human_lineage` value is then assigned to the `v_divergence` variable. Following this data retrieval, a series of conditional checks are performed on the `v_divergence` value. If `v_divergence` is strictly greater than `700`, the function immediately returns the text string `'Very Distant'`. Otherwise, if the first condition is false, it checks if `v_divergence` is strictly greater than `500`. If this second condition is true, the function returns the text string `'Distant'`. If both previous conditions are false, it proceeds to check if `v_divergence` is strictly greater than `300`. If this third condition is true, the function returns the text string `'Moderate'`. Finally, if none of the preceding conditions are met (meaning `v_divergence` is less than or equal to `300`), the function returns the text string `'Close'`.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_protein_divergence(prot_name text)\nRETURNS text AS $$\nDECLARE\n    v_divergence real;\nBEGIN\n    SELECT divergence_from_human_lineage INTO v_divergence FROM protein WHERE protein.protein_name = prot_name;\n    IF v_divergence > 700 THEN\n        RETURN 'Very Distant';\n    ELSIF v_divergence > 500 THEN\n        RETURN 'Distant';\n    ELSIF v_divergence > 300 THEN\n        RETURN 'Moderate';\n    ELSE\n        RETURN 'Close';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "SELECT categorize_protein_divergence('uncharacterized protein C20orf...');",
      "SELECT categorize_protein_divergence('uncharacterized protein LOC578...');",
      "SELECT categorize_protein_divergence('Centromeric protein E, putativ...');",
      "SELECT categorize_protein_divergence('protein_name_example_1');",
      "SELECT categorize_protein_divergence('protein_name_example_2');"
    ],
    "summary": "Create a PLpgSQL function named categorize_protein_divergence that takes a protein_name (text) and returns a text category. The function retrieves the protein's divergence_from_human_lineage value and categorizes it as 'Very Distant' (>700), 'Distant' (>500), 'Moderate' (>300), or 'Close' (<=300).",
    "natural_language": "Develop a PLpgSQL function, to be named categorize_protein_divergence, which accepts a single input parameter of type text representing a protein name and yields a text-based classification. This function should first query and obtain the specific value for divergence_from_human_lineage associated with the given protein. It must then perform a detailed categorization, meticulously assigning one of four descriptive labels based on the retrieved numerical value: if the divergence exceeds 700, it is deemed 'Very Distant'; if it is greater than 500 but up to 700, it is classified as 'Distant'; for values surpassing 300 up to 500, the category is 'Moderate'; and finally, for any value that is less than or equal to 300, it is considered 'Close'.",
    "id": 247
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_course_duration that accepts a single input parameter p_registration_id of type bigint, which represents a specific registration identifier, and returns an integer value. The function begins by declaring three local variables: v_days as an integer, v_enrollment_date as a timestamp with time zone, and v_completion_date as a timestamp with time zone. It then executes a SELECT statement to query the \"Student_Course_Enrolment\" table, retrieving the date_of_enrolment and date_of_completion columns for the specific row where the registration_id column matches the provided p_registration_id input parameter, storing these values into the v_enrollment_date and v_completion_date variables respectively. Following this data retrieval, the function implements a conditional check: if the v_completion_date variable is not NULL, it calculates the duration by subtracting v_enrollment_date from v_completion_date, extracts the day component from this resulting interval using the EXTRACT(DAY FROM ...) function, and assigns this integer day count to the v_days variable. If the v_completion_date is NULL, the function instead calculates the duration by subtracting v_enrollment_date from the current system timestamp obtained via CURRENT_TIMESTAMP, extracts the day component from this interval, and assigns that value to v_days. Finally, the function returns the calculated integer value stored in the v_days variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_course_duration(p_registration_id bigint)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_days integer;\n    v_enrollment_date timestamp with time zone;\n    v_completion_date timestamp with time zone;\nBEGIN\n    SELECT date_of_enrolment, date_of_completion\n    INTO v_enrollment_date, v_completion_date\n    FROM \"Student_Course_Enrolment\"\n    WHERE registration_id = p_registration_id;\n\n    IF v_completion_date IS NOT NULL THEN\n        v_days := EXTRACT(DAY FROM (v_completion_date - v_enrollment_date));\n    ELSE\n        v_days := EXTRACT(DAY FROM (CURRENT_TIMESTAMP - v_enrollment_date));\n    END IF;\n    RETURN v_days;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Courses",
      "Student_Course_Enrolment"
    ],
    "call_sqls": [
      "SELECT calculate_course_duration(1);",
      "SELECT calculate_course_duration(2);",
      "SELECT calculate_course_duration(3);",
      "SELECT calculate_course_duration(registration_id) FROM \"Student_Course_Enrolment\" WHERE student_id = 11;",
      "SELECT registration_id, calculate_course_duration(registration_id) AS duration_days FROM \"Student_Course_Enrolment\" WHERE course_id = 2;"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_course_duration` that takes a registration ID as bigint input and returns an integer. It retrieves the enrollment and completion dates for the registration. If a completion date exists, it calculates the duration in days between enrollment and completion. If the completion date is NULL, it calculates the duration in days from enrollment to the current timestamp. The function returns the calculated number of days.",
    "natural_language": "Please construct a PL/pgSQL function designated as `calculate_course_duration`. This function shall accept a single input parameter of type bigint, representing a registration identifier, and shall yield an integer value. The procedure involves retrieving the enrollment date and the completion date associated with the provided registration. Should a completion date be present, the function computes the duration in days between the enrollment and completion dates. In the event the completion date is null, the function instead calculates the duration in days from the enrollment date to the current timestamp. The integer result returned is the computed number of days.",
    "id": 248
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_employee_delivery_count that accepts a single input parameter p_employee_id of type bigint, which represents the unique identifier of an employee, and returns a single bigint value; the function declares a local variable v_count of type bigint, then executes a SELECT statement that queries the \"Order_Deliveries\" table to count all rows where the value in the \"driver_employee_id\" column is exactly equal to the provided p_employee_id parameter, storing the result of this COUNT(*) aggregation into the v_count variable, and finally returns the value stored in v_count as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_delivery_count(p_employee_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM \"Order_Deliveries\" WHERE \"driver_employee_id\" = p_employee_id;\n    RETURN v_count;\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Regular_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Addresses",
      "Employees",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT get_employee_delivery_count(1);",
      "SELECT get_employee_delivery_count(2);",
      "SELECT get_employee_delivery_count(3);",
      "SELECT get_employee_delivery_count(4);",
      "SELECT get_employee_delivery_count(6);"
    ],
    "summary": "Create a PLpgSQL function named get_employee_delivery_count that accepts an employee_id (bigint) and returns a bigint. The function should count and return the number of rows in the Order_Deliveries table where the driver_employee_id matches the provided parameter.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_employee_delivery_count'. This function must accept a single parameter of type bigint, named 'employee_id', and yield a return value of type bigint. Its purpose is to compute and return the total count of records within the 'Order_Deliveries' table for which the 'driver_employee_id' column corresponds precisely to the supplied argument.",
    "id": 249
  },
  {
    "ir": "Write a PLpgSQL function named calculate_days_since_order that accepts a single input parameter p_order_id of type bigint, which represents the unique identifier for an order, and returns an integer value; within the function, a local variable days_diff of type integer is declared, then a SELECT statement is executed to query the \"Actual_Orders\" table, specifically retrieving the \"actual_order_date\" column for the row where the \"actual_order_id\" column matches the provided p_order_id parameter, and for that row, it calculates the difference between the current system timestamp (CURRENT_TIMESTAMP) and the retrieved \"actual_order_date\" value, which yields an interval, from which the EXTRACT function isolates the day component, casts that result to an integer using the ::integer operator, and assigns the resulting integer value into the days_diff variable, which is then returned as the function's output, representing the number of whole days that have elapsed since the order's actual order date up to the current moment.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_days_since_order(p_order_id bigint)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    days_diff integer;\nBEGIN\n    SELECT EXTRACT(DAY FROM (CURRENT_TIMESTAMP - \"actual_order_date\"))::integer INTO days_diff\n    FROM \"Actual_Orders\" WHERE \"actual_order_id\" = p_order_id;\n    RETURN days_diff;\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Regular_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Addresses",
      "Employees",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT calculate_days_since_order(1);",
      "SELECT calculate_days_since_order(2);",
      "SELECT calculate_days_since_order(3);",
      "SELECT calculate_days_since_order(15);",
      "SELECT calculate_days_since_order(8);"
    ],
    "summary": "Create a PLpgSQL function named calculate_days_since_order that accepts an order_id (bigint) and returns an integer. The function should calculate and return the number of whole days between the current timestamp and the actual_order_date for the specified order in the Actual_Orders table.",
    "natural_language": "Develop a PLpgSQL function called calculate_days_since_order that takes a single input parameter, which is an order identifier of the bigint type, and yields an integer as its output. This function should meticulously compute and then deliver the precise count of complete, entire days that have elapsed between the exact moment the function is called and the specific actual_order_date timestamp associated with the given order, which is to be retrieved from the Actual_Orders table.",
    "id": 250
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_truck_usage_percentage that accepts a single input parameter p_truck_id of type bigint, representing the unique identifier of a truck, and returns a numeric value. The function calculates the percentage of total deliveries assigned to the specified truck. It begins by declaring three local variables: total_deliveries of type bigint, truck_deliveries of type bigint, and usage_percent of type numeric. The function then executes a SELECT statement that counts all rows from the \"Order_Deliveries\" table and stores the result in the total_deliveries variable. Next, it executes another SELECT statement that counts rows from the \"Order_Deliveries\" table where the \"truck_id\" column exactly matches the input parameter p_truck_id, storing this count in the truck_deliveries variable. Following this, a conditional IF statement checks if the total_deliveries count is greater than zero. If true, the usage_percent variable is computed by first explicitly casting both truck_deliveries and total_deliveries to the numeric data type, then dividing the truck-specific deliveries count by the total deliveries count, and finally multiplying the result by 100 to obtain a percentage. If the condition is false, meaning total_deliveries is zero, the usage_percent variable is directly assigned a value of zero. The function concludes by returning the calculated or assigned usage_percent value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_truck_usage_percentage(p_truck_id bigint)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_deliveries bigint;\n    truck_deliveries bigint;\n    usage_percent numeric;\nBEGIN\n    SELECT COUNT(*) INTO total_deliveries FROM \"Order_Deliveries\";\n    SELECT COUNT(*) INTO truck_deliveries FROM \"Order_Deliveries\" WHERE \"truck_id\" = p_truck_id;\n    IF total_deliveries > 0 THEN\n        usage_percent := (truck_deliveries::numeric / total_deliveries::numeric) * 100;\n    ELSE\n        usage_percent := 0;\n    END IF;\n    RETURN usage_percent;\nEND;\n$$;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Regular_Orders",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Delivery_Routes",
      "Addresses",
      "Employees",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT get_truck_usage_percentage(1);",
      "SELECT get_truck_usage_percentage(2);",
      "SELECT get_truck_usage_percentage(3);",
      "SELECT get_truck_usage_percentage(10);",
      "SELECT get_truck_usage_percentage(11);"
    ],
    "summary": "Create a PLpgSQL function named get_truck_usage_percentage that accepts a truck_id (bigint) and returns a numeric value. The function should calculate the percentage of total deliveries assigned to the specified truck from the Order_Deliveries table. If there are no total deliveries, return zero.",
    "natural_language": "Calculate and return the percentage of total deliveries assigned to the specified truck ID from the Order_Deliveries table. If there are no total deliveries, return zero. Implement this as a PLpgSQL function named get_truck_usage_percentage that takes a truck_id (bigint) as input and returns a numeric value.",
    "id": 251
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_resident_id of type bigint, retrieves the property_address associated with the resident whose resident_id matches the provided p_resident_id, and returns the property_address as a text value. The function begins by declaring a local variable v_property_address of type text to store the result of the query. It then performs a nested SELECT operation: first, it queries the Residents table to find the property_id corresponding to the given resident_id, using the condition WHERE \"resident_id\" = p_resident_id. Next, it uses this property_id to query the Properties table and retrieve the property_address, using the condition WHERE \"property_id\" = (result of the inner query). The retrieved property_address is stored in the v_property_address variable, which is then returned as the output of the function. The function is implemented in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_resident_property(p_resident_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_property_address text;\nBEGIN\n    SELECT \"property_address\"\n    INTO v_property_address\n    FROM \"Properties\"\n    WHERE \"property_id\" = (\n        SELECT \"property_id\"\n        FROM \"Residents\"\n        WHERE \"resident_id\" = p_resident_id\n    );\n    RETURN v_property_address;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Properties",
      "Residents_Services"
    ],
    "call_sqls": [
      "SELECT get_resident_property(6);",
      "SELECT get_resident_property(10);",
      "SELECT get_resident_property(23);",
      "SELECT get_resident_property(28);",
      "SELECT get_resident_property(1);"
    ],
    "summary": "Create a PLpgSQL function that takes a resident_id (bigint) and returns the property_address (text). Query the Residents table to get the property_id for the given resident_id, then use that property_id to query the Properties table for the corresponding property_address.",
    "natural_language": "Hey, can you whip up a PLpgSQL function that, when I give it a resident's ID (as a bigint), spits out their property address? First, it needs to look up the property_id for that resident from the Residents table. Then, using that property_id, it should grab the matching property_address from the Properties table.",
    "id": 252
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_property_id of type integer, representing the unique identifier of a property, and returns an integer value. The function begins by declaring a local variable v_resident_count of type integer to store the result of a query. It then executes a SELECT statement to count the number of rows in the \"Residents\" table where the \"property_id\" column matches the value of the input parameter p_property_id (converted to a bigint type) and the \"date_moved_out\" column is NULL, indicating that the resident has not moved out. The result of this query, which represents the number of active residents associated with the specified property, is stored in the v_resident_count variable. Finally, the function returns the value of v_resident_count as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_active_reservations(p_property_id integer)\nRETURNS integer AS $$\nDECLARE\n    v_resident_count integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_resident_count\n    FROM \"Residents\"\n    WHERE \"property_id\" = p_property_id::bigint\n    AND \"date_moved_out\" IS NULL;\n    RETURN v_resident_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Properties",
      "Residents_Services"
    ],
    "call_sqls": [
      "SELECT count_active_reservations(605);",
      "SELECT count_active_reservations(879);",
      "SELECT count_active_reservations(954);",
      "SELECT count_active_reservations(24);",
      "SELECT count_active_reservations(107);"
    ],
    "summary": "Create a PLpgSQL function that takes a property_id (integer) and returns an integer count. Count the number of active residents in the Residents table where the property_id matches the input (cast to bigint) and date_moved_out is NULL.",
    "natural_language": "How many active residents are there for a given property, where an active resident is defined as one with a NULL date_moved_out?",
    "id": 253
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_service_details` that accepts a single input parameter, `p_resident_id`, which is of type `bigint`. This function is designed to return a single value of type `text`. Inside the function, a local variable named `v_service_details` of type `text` is declared to temporarily store the retrieved service details. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `other_details` column from the table named `\"Residents_Services\"`. The retrieved value is then immediately assigned to the local variable `v_service_details`. The selection of rows from the `\"Residents_Services\"` table is constrained by two conditions in the `WHERE` clause: first, the value in the `resident_id` column must be equal to the value provided in the input parameter `p_resident_id`; and second, the value in the `date_provided` column must not be `NULL`. The results of this filtered selection are then ordered in descending order based on the values in the `date_provided` column. Finally, the `LIMIT 1` clause ensures that only the first row from the ordered result set is considered. After the `SELECT` statement completes and the `v_service_details` variable is populated, the function returns the value currently stored in `v_service_details` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_service_details(p_resident_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_service_details text;\nBEGIN\n    SELECT \"other_details\"\n    INTO v_service_details\n    FROM \"Residents_Services\"\n    WHERE \"resident_id\" = p_resident_id\n    AND \"date_provided\" IS NOT NULL\n    ORDER BY \"date_provided\" DESC\n    LIMIT 1;\n    RETURN v_service_details;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Properties",
      "Residents_Services"
    ],
    "call_sqls": [
      "SELECT get_service_details(6);",
      "SELECT get_service_details(23);",
      "SELECT get_service_details(28);",
      "SELECT get_service_details(10);",
      "SELECT get_service_details(19);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_service_details that takes a resident_id (bigint) and returns a text value. Select the other_details from the Residents_Services table where the resident_id matches the input and date_provided is not NULL, order by date_provided descending, and return the first result.",
    "natural_language": "Write a function called get_service_details that, given a resident's ID number, fetches a text field. It should look up records for that resident where a service date is recorded, sort them to put newer entries first, and give back the details from the most recent one.",
    "id": 254
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_customer_details that accepts a single input parameter p_customer_id of type bigint, which is used to identify a specific customer record, and returns a value of type text; within the function, a local variable v_customer_details of type text is declared to temporarily hold the result; the function's logic executes a SELECT query that retrieves the value from the column named customer_details in the table named Customers, specifically from the row where the column customer_id exactly matches the provided input parameter p_customer_id, and stores the retrieved value into the local variable v_customer_details; finally, the function returns the content of the v_customer_details variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_details(p_customer_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_customer_details text;\nBEGIN\n    SELECT \"customer_details\"\n    INTO v_customer_details\n    FROM \"Customers\"\n    WHERE \"customer_id\" = p_customer_id;\n    RETURN v_customer_details;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Properties",
      "Residents_Services"
    ],
    "call_sqls": [
      "SELECT get_customer_details(4);",
      "SELECT get_customer_details(5);",
      "SELECT get_customer_details(16);",
      "SELECT get_customer_details(19);",
      "SELECT get_customer_details(70);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_customer_details that takes a customer_id (bigint) and returns a text value. Select the customer_details from the Customers table where the customer_id matches the input parameter.",
    "natural_language": "Write a function called get_customer_details that fetches a text result. It should look in the Customers table for a record where the customer_id is roughly the one provided and then give back the customer_details from that entry.",
    "id": 255
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named `find_social_connections` that takes two input parameters: `p_student_id` of type INTEGER, representing the ID of a student whose social connections are to be analyzed, and `p_connection_type` of type TEXT, specifying the type of connection to evaluate, which can either be 'FRIENDS' or 'LIKES'. The function returns a table with three columns: `direct_connections` of type INTEGER, representing the count of direct connections for the student; `mutual_connections` of type INTEGER, representing the count of mutual connections; and `connection_ratio` of type NUMERIC, representing the ratio of mutual connections to direct connections. The function begins by declaring three local variables: `v_direct_connections` of type INTEGER to store the count of direct connections, `v_mutual_connections` of type INTEGER to store the count of mutual connections, and `v_connection_ratio` of type NUMERIC to store the calculated connection ratio. The function uses conditional logic to determine the behavior based on the value of `p_connection_type`. If `p_connection_type` equals 'FRIENDS', the function first calculates the number of direct connections by counting rows in the `Friend` table where the `student_id` column matches `p_student_id`. Then, it calculates the number of mutual connections by performing a self-join on the `Friend` table, where the `friend_id` of one row matches the `student_id` of another row, excluding cases where the `friend_id` equals `p_student_id` or is already a direct connection of `p_student_id`. If `p_connection_type` equals 'LIKES', the function calculates the number of direct connections by counting rows in the `Likes` table where the `student_id` column matches `p_student_id`, and calculates the number of mutual connections by counting rows in the `Likes` table where the `liked_id` column matches `p_student_id`. After determining the counts, the function calculates the connection ratio by dividing `v_mutual_connections` by `v_direct_connections` if `v_direct_connections` is greater than zero; otherwise, it sets the ratio to zero. Finally, the function assigns the calculated values to the output columns `direct_connections`, `mutual_connections`, and `connection_ratio`, and returns the result as a row in the output table.",
    "plsql": "CREATE OR REPLACE FUNCTION find_social_connections(\n    IN p_student_id INTEGER,\n    IN p_connection_type TEXT\n)\nRETURNS TABLE(\n    direct_connections INTEGER,\n    mutual_connections INTEGER,\n    connection_ratio NUMERIC\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_direct_connections INTEGER;\n    v_mutual_connections INTEGER;\n    v_connection_ratio NUMERIC;\nBEGIN\n    IF p_connection_type = 'FRIENDS' THEN\n        SELECT COUNT(*)\n        INTO v_direct_connections\n        FROM \"Friend\"\n        WHERE student_id = p_student_id;\n        \n        SELECT COUNT(DISTINCT f2.friend_id)\n        INTO v_mutual_connections\n        FROM \"Friend\" f1\n        JOIN \"Friend\" f2 ON f1.friend_id = f2.student_id\n        WHERE f1.student_id = p_student_id \n          AND f2.friend_id != p_student_id\n          AND f2.friend_id NOT IN (\n              SELECT friend_id \n              FROM \"Friend\" \n              WHERE student_id = p_student_id\n          );\n    ELSE\n        SELECT COUNT(*)\n        INTO v_direct_connections\n        FROM \"Likes\"\n        WHERE student_id = p_student_id;\n        \n        SELECT COUNT(*)\n        INTO v_mutual_connections\n        FROM \"Likes\"\n        WHERE liked_id = p_student_id;\n    END IF;\n    \n    v_connection_ratio := CASE \n        WHEN v_direct_connections > 0 THEN v_mutual_connections::NUMERIC / v_direct_connections \n        ELSE 0 \n    END;\n    \n    direct_connections := v_direct_connections;\n    mutual_connections := v_mutual_connections;\n    connection_ratio := v_connection_ratio;\n    \n    RETURN NEXT;\nEND;\n$$;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT * FROM find_social_connections(1510, 'FRIENDS');",
      "SELECT * FROM find_social_connections(1689, 'FRIENDS');",
      "SELECT * FROM find_social_connections(1381, 'LIKES');",
      "SELECT * FROM find_social_connections(1709, 'LIKES');",
      "SELECT * FROM find_social_connections(1782, 'FRIENDS');"
    ],
    "summary": "Create a PL/pgSQL function named `find_social_connections` that takes a student ID (integer) and a connection type ('FRIENDS' or 'LIKES') as input. It returns a table with columns for direct_connections (integer), mutual_connections (integer), and connection_ratio (numeric). The function calculates direct and mutual connection counts from the appropriate tables based on the connection type, computes the ratio (mutual/direct, or 0 if no direct connections), and returns the result.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be meticulously named `find_social_connections`. This function must accept two distinct input parameters: a student ID, specified as an integer, and a connection type, which is a string that must be explicitly either 'FRIENDS' or 'LIKES'. The function is designed to return a detailed result set structured as a table containing three specific columns: direct_connections (as an integer), mutual_connections (as an integer), and a precisely calculated connection_ratio (as a numeric value). To achieve this, the function will intelligently query the relevant database tables—selecting the appropriate ones based on the provided connection type—in order to diligently count both the direct connections and the mutual connections for the given student. Subsequently, it will compute a meaningful ratio by dividing the mutual connections count by the direct connections count; however, if there are no direct connections at all, it must gracefully handle this scenario by returning a ratio of zero. Finally, the function will elegantly output the complete calculated result.",
    "id": 256
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_department_budget` that accepts a single input parameter, `p_department_id`, which is of type `integer`. This function is designed to retrieve the budget associated with a specific department. Internally, the function declares a local variable named `v_budget` of type `real` to temporarily store the retrieved budget value. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the table named `\"department\"`. Specifically, it selects the value from the column named `\"Budget_in_Billions\"` and attempts to store this retrieved value into the local variable `v_budget`. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `\"department\"` table. The condition in the `WHERE` clause specifies that only the row where the value in the column `\"Department_ID\"` is equal to the value provided by the input parameter `p_department_id` should be considered. After successfully retrieving the budget value into `v_budget`, the function then returns the value stored in `v_budget` as its output. The return type of the function is `real`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_budget(p_department_id integer) RETURNS real AS $$\nDECLARE\n    v_budget real;\nBEGIN\n    SELECT \"Budget_in_Billions\" INTO v_budget FROM \"department\" WHERE \"Department_ID\" = p_department_id;\n    RETURN v_budget;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_department_budget(1);",
      "SELECT get_department_budget(2);",
      "SELECT get_department_budget(3);",
      "SELECT get_department_budget(15);",
      "SELECT get_department_budget(NULL);"
    ],
    "summary": "Create a PL/pgSQL function named `get_department_budget` that accepts a department ID (integer) and returns the department's budget (real) by selecting the \"Budget_in_Billions\" column from the \"department\" table where the \"Department_ID\" matches the input.",
    "natural_language": "Write a PL/pgSQL function called `get_department_budget` that takes a department ID as an integer and returns the department's budget as a real number. The function should fetch the \"Budget_in_Billions\" from the \"department\" table where the \"Department_ID\" equals the provided ID.",
    "id": 257
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_head_id of type integer, retrieves the value of the age column from the head table for the row where the head_ID column matches the provided p_head_id, and returns this age value as a real type. The function begins by declaring a local variable v_age of type real to store the retrieved age value. It then performs a SELECT operation on the head table, specifying the age column in the SELECT clause and using a WHERE condition to filter rows where the head_ID column equals the input parameter p_head_id. The result of this SELECT operation is assigned to the v_age variable using the INTO clause. Finally, the function returns the value stored in v_age.",
    "plsql": "CREATE OR REPLACE FUNCTION get_head_age(p_head_id integer) RETURNS real AS $$\nDECLARE\n    v_age real;\nBEGIN\n    SELECT \"age\" INTO v_age FROM \"head\" WHERE \"head_ID\" = p_head_id;\n    RETURN v_age;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_head_age(1);",
      "SELECT get_head_age(2);",
      "SELECT get_head_age(3);"
    ],
    "summary": "Create a PL/pgSQL function that takes a head ID (integer) and returns the age (real) of that head by selecting the age column from the head table where the head_ID matches the input.",
    "natural_language": "Write a function that, given a head's identifier number, fetches and gives back roughly how old that head is. You'll need to look it up in the head table where the IDs line up.",
    "id": 258
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_department_head_count that accepts a single integer input parameter named p_department_id, which represents the identifier of a specific department, and returns an integer value; within the function, a local integer variable v_count is declared, then a SELECT statement is executed to query the management table, specifically counting all rows where the value in the department_ID column exactly matches the provided p_department_id parameter value, and this resulting count is stored into the v_count variable, which is subsequently returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_head_count(p_department_id integer) RETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM \"management\" WHERE \"department_ID\" = p_department_id;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_department_head_count(1);",
      "SELECT get_department_head_count(2);",
      "SELECT get_department_head_count(3);",
      "SELECT get_department_head_count(15);",
      "SELECT get_department_head_count(NULL);"
    ],
    "summary": "Create a PL/pgSQL function named `get_department_head_count` that accepts a department ID (integer) and returns an integer count of heads in that department by counting rows in the management table where the department_ID matches the input.",
    "natural_language": "Function `get_department_head_count` returns head count for a given department ID from management table.",
    "id": 259
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_department_creation_year` that accepts a single input parameter, `p_department_id`, which is of type `integer`. This function is designed to retrieve the creation year of a specific department. Inside the function, a local variable named `v_creation_year` is declared, which is of type `text`. The function then executes a `SELECT` statement to query the `department` table. Specifically, it selects the value from the column named `\"Creation\"` and attempts to store this value into the `v_creation_year` variable. This selection is conditional, applying a `WHERE` clause that filters rows based on the `\"Department_ID\"` column. Only the row where the value in the `\"Department_ID\"` column exactly matches the value provided in the `p_department_id` input parameter will be considered. After successfully retrieving the `Creation` value into `v_creation_year`, the function returns the value stored in `v_creation_year` as its output, which is of type `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_creation_year(p_department_id integer) RETURNS text AS $$\nDECLARE\n    v_creation_year text;\nBEGIN\n    SELECT \"Creation\" INTO v_creation_year FROM \"department\" WHERE \"Department_ID\" = p_department_id;\n    RETURN v_creation_year;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_department_creation_year(1);",
      "SELECT get_department_creation_year(2);",
      "SELECT get_department_creation_year(3);",
      "SELECT get_department_creation_year(4);",
      "SELECT get_department_creation_year(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_department_creation_year` that accepts a department ID (integer) and returns the department's creation year (text) by selecting the \"Creation\" column from the department table where the \"Department_ID\" matches the input.",
    "natural_language": "Write a function called `get_department_creation_year` that, when given a department ID number, fetches and returns a text value for roughly when that department was set up. It should look in the department table for a matching ID and pull the date from the \"Creation\" field.",
    "id": 260
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_head_born_state` that accepts a single input parameter named `p_head_id` of data type `integer`. This function is designed to return a value of data type `text`. Inside the function, a local variable named `v_born_state` of data type `text` is declared. The function then proceeds to execute a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"born_state\"` from the table named `\"head\"`. The retrieved value is then assigned to the local variable `v_born_state`. The `SELECT` statement includes a `WHERE` clause that filters the rows based on a condition: it selects only those rows where the value in the column named `\"head_ID\"` is equal to the value provided by the input parameter `p_head_id`. Finally, the function returns the value currently stored in the local variable `v_born_state`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_head_born_state(p_head_id integer) RETURNS text AS $$\nDECLARE\n    v_born_state text;\nBEGIN\n    SELECT \"born_state\" INTO v_born_state FROM \"head\" WHERE \"head_ID\" = p_head_id;\n    RETURN v_born_state;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_head_born_state(1);",
      "SELECT get_head_born_state(2);",
      "SELECT get_head_born_state(3);",
      "SELECT get_head_born_state(4);",
      "SELECT get_head_born_state(5);"
    ],
    "summary": "Create a function named get_head_born_state that takes a head_id integer and returns the born_state text for that head from the head table.",
    "natural_language": "What is the born_state text for a given head_id from the head table, and how can I create a function named get_head_born_state to return it?",
    "id": 261
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_settlement_ratio that accepts a single input parameter named policy_id_param of type bigint, which represents the unique identifier of an insurance policy, and returns a numeric value; the function begins by declaring two local bigint variables, claimed_amount and settled_amount; it then executes a SELECT query on the \"Claims\" table to retrieve and sum the values from the \"Amount_Claimed\" and \"Amount_Settled\" columns for all rows where the \"Policy_ID\" column matches the provided policy_id_param; the COALESCE function is used in the SELECT statement to convert any NULL summation results from the SUM aggregate function to the numeric value 0, ensuring both variables are initialized; the results of these aggregated sums are assigned into the declared variables claimed_amount and settled_amount; following this data retrieval, the function implements a conditional IF-THEN-ELSE block: if the value of claimed_amount is equal to 0, the function immediately returns the numeric value 0; otherwise, the function proceeds to calculate a ratio by dividing the settled_amount by the claimed_amount, explicitly casting both bigint variables to the numeric data type to ensure precise decimal division, and then applies the ROUND function to the result of this division, rounding the numeric quotient to two decimal places, and this rounded value is returned as the function's final result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_settlement_ratio(policy_id_param bigint) RETURNS numeric AS $$\nDECLARE\n    claimed_amount bigint;\n    settled_amount bigint;\nBEGIN\n    SELECT COALESCE(SUM(\"Amount_Claimed\"), 0), COALESCE(SUM(\"Amount_Settled\"), 0)\n    INTO claimed_amount, settled_amount\n    FROM \"Claims\"\n    WHERE \"Policy_ID\" = policy_id_param;\n    \n    IF claimed_amount = 0 THEN\n        RETURN 0;\n    ELSE\n        RETURN ROUND(settled_amount::numeric / claimed_amount::numeric, 2);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT calculate_settlement_ratio(744);",
      "SELECT calculate_settlement_ratio(552);",
      "SELECT calculate_settlement_ratio(473);",
      "SELECT calculate_settlement_ratio(119);",
      "SELECT calculate_settlement_ratio(141);"
    ],
    "summary": "Create a function named calculate_settlement_ratio that takes a policy_id bigint and returns a numeric value. It calculates the ratio of total settled amount to total claimed amount for the policy, returning 0 if no claims exist, and rounds the result to two decimal places.",
    "natural_language": "Create a function, which should be named calculate_settlement_ratio, that accepts a single input parameter: a policy identifier of the bigint data type. This function is designed to compute a precise numeric ratio by carefully dividing the aggregate sum of all settled amounts by the total sum of all claimed amounts specifically associated with the provided policy. To ensure robustness, it must gracefully handle scenarios where no claims exist by explicitly returning a value of zero. Finally, for clear and standardized presentation, the computed result must be rounded to exactly two decimal places before being returned.",
    "id": 262
  },
  {
    "ir": "Write a PLpgSQL function named find_customer_with_most_claims that returns a bigint value, where the function declares a local variable result_customer_id of type bigint, then executes a SELECT statement that retrieves data by joining the Claims table (aliased as c) with the Customer_Policies table (aliased as cp) using the condition that the Policy_ID column from the Claims table equals the Policy_ID column from the Customer_Policies table, groups the combined result set by the Customer_ID column from the Customer_Policies table, orders the groups in descending sequence based on the count of distinct Claim_ID values from the Claims table within each group, and then selects the single Customer_ID value from the first row of this ordered result set, assigning that value into the result_customer_id variable, which is subsequently returned as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION find_customer_with_most_claims() RETURNS bigint AS $$\nDECLARE\n    result_customer_id bigint;\nBEGIN\n    SELECT cp.\"Customer_ID\" INTO result_customer_id\n    FROM \"Claims\" c\n    JOIN \"Customer_Policies\" cp ON c.\"Policy_ID\" = cp.\"Policy_ID\"\n    GROUP BY cp.\"Customer_ID\"\n    ORDER BY COUNT(c.\"Claim_ID\") DESC\n    LIMIT 1;\n    \n    RETURN result_customer_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT find_customer_with_most_claims();"
    ],
    "summary": "Create a function named find_customer_with_most_claims that returns a bigint. It identifies and returns the customer ID with the highest number of distinct claims by joining the Claims and Customer_Policies tables.",
    "natural_language": "What is the customer ID of the customer who has filed the highest number of distinct claims, based on a join of the Claims and Customer_Policies tables?",
    "id": 263
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_unsettled_claims_count` that accepts no input parameters. This function is designed to return a single value of type `bigint`. Upon execution, the function declares a local variable named `unsettled_count` of type `bigint`. The core operation of the function involves performing a `SELECT` statement to count the total number of rows in the table named `\"Claims\"`. This count is specifically filtered by a `WHERE` clause that checks if the value in the column named `\"Date_Claim_Settled\"` is `NULL`. The result of this `COUNT(*)` aggregation is then assigned to the previously declared local variable `unsettled_count`. Finally, the function returns the value stored in the `unsettled_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_unsettled_claims_count() RETURNS bigint AS $$\nDECLARE\n    unsettled_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO unsettled_count\n    FROM \"Claims\"\n    WHERE \"Date_Claim_Settled\" IS NULL;\n    \n    RETURN unsettled_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT get_unsettled_claims_count();",
      "SELECT * FROM get_unsettled_claims_count();",
      "SELECT get_unsettled_claims_count() AS unsettled_claims;",
      "DO $$\nDECLARE\n    result bigint;\nBEGIN\n    result := get_unsettled_claims_count();\n    RAISE NOTICE 'Unsettled claims: %', result;\nEND $$;",
      "SELECT get_unsettled_claims_count() FROM (VALUES (1)) AS t;"
    ],
    "summary": "Create a function named get_unsettled_claims_count that returns a bigint. It counts and returns the number of claims where the settlement date is NULL.",
    "natural_language": "Count and return the number of claims with a NULL settlement date. Name the function get_unsettled_claims_count and have it return a bigint.",
    "id": 264
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the claim history for a specific insurance policy identified by the input parameter policy_id_input of type bigint. The function returns a table with three columns: claim_date of type date, amount_claimed of type bigint, and amount_settled of type bigint. Within the function, a SQL query is executed to select data from the \"Claims\" table, specifically the \"Date_Claim_Made\" column for the claim date, the \"Amount_Claimed\" column for the amount claimed, and the \"Amount_Settled\" column for the amount settled. The query filters rows where the \"Policy_ID\" column in the \"Claims\" table matches the value of the input parameter policy_id_input. The results are ordered in descending order based on the \"Date_Claim_Made\" column, ensuring that the most recent claims appear first. The function uses the RETURN QUERY statement to directly return the result set of the query to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION get_policy_claim_history(policy_id_input bigint) RETURNS TABLE(claim_date date, amount_claimed bigint, amount_settled bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT c.\"Date_Claim_Made\", c.\"Amount_Claimed\", c.\"Amount_Settled\"\n    FROM \"Claims\" c\n    WHERE c.\"Policy_ID\" = policy_id_input\n    ORDER BY c.\"Date_Claim_Made\" DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT * FROM get_policy_claim_history(744);",
      "SELECT * FROM get_policy_claim_history(552);",
      "SELECT * FROM get_policy_claim_history(473);",
      "SELECT * FROM get_policy_claim_history(119);",
      "SELECT * FROM get_policy_claim_history(141);"
    ],
    "summary": "Create a function that takes a policy_id bigint and returns a table of claim history. The table includes claim_date, amount_claimed, and amount_settled for the specified policy, ordered by the most recent claim date first.",
    "natural_language": "Function returning claim_date, amount_claimed, amount_settled for given policy_id, sorted by latest claim_date.",
    "id": 265
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_device_stock_total` that accepts a single input parameter, `p_device_id`, which is of type `integer`. This function is designed to return an `integer` value. Upon execution, the function declares a local variable named `v_total` of type `integer`. The core operation involves performing a `SELECT` statement to calculate the sum of all values in the column named `\"Quantity\"` from the table named `\"stock\"`. This summation is conditional, applying only to rows where the value in the column named `\"Device_ID\"` is equal to the value provided by the input parameter `p_device_id`. The result of this `SUM` aggregation is then stored into the local variable `v_total`. Finally, the function returns the value of `v_total`. If `v_total` is `NULL` (which would occur if no matching rows were found in the `\"stock\"` table for the given `p_device_id`), the `COALESCE` function ensures that `0` is returned instead of `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_stock_total(p_device_id integer) RETURNS integer AS $$\nDECLARE\n    v_total integer;\nBEGIN\n    SELECT SUM(\"Quantity\") INTO v_total FROM \"stock\" WHERE \"Device_ID\" = p_device_id;\n    RETURN COALESCE(v_total, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT get_device_stock_total(1);",
      "SELECT get_device_stock_total(2);",
      "SELECT get_device_stock_total(3);",
      "SELECT get_device_stock_total(6);",
      "SELECT get_device_stock_total(NULL);"
    ],
    "summary": "Create a function named get_device_stock_total that takes a device ID as input and returns the total quantity of that device from the stock table. Return 0 if no stock is found.",
    "natural_language": "Function get_device_stock_total returns total stock for a given device ID, or 0 if none.",
    "id": 266
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `find_shop_with_max_stock` that accepts a single input parameter, `p_device_id`, which is of type `integer`. The purpose of this function is to identify and return the `Shop_ID` of the shop that holds the maximum quantity of a specific device. Inside the function, a local variable named `v_shop_id` of type `integer` is declared to temporarily store the retrieved `Shop_ID`. The core operation involves executing a `SELECT` statement to query the table named `\"stock\"`. This `SELECT` statement retrieves the value from the `\"Shop_ID\"` column. The `WHERE` clause filters the rows in the `\"stock\"` table, considering only those where the value in the `\"Device_ID\"` column is equal to the value provided by the input parameter `p_device_id`. The results of this filtered selection are then ordered in descending order based on the values in the `\"Quantity\"` column. Finally, the `LIMIT 1` clause restricts the output to only the first row after sorting, which corresponds to the shop with the highest quantity for the specified device. The `INTO v_shop_id` clause assigns the `\"Shop_ID\"` value from this single selected row into the local variable `v_shop_id`. After the `SELECT` statement completes, the function returns the value stored in `v_shop_id` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION find_shop_with_max_stock(p_device_id integer) RETURNS integer AS $$\nDECLARE\n    v_shop_id integer;\nBEGIN\n    SELECT \"Shop_ID\" INTO v_shop_id FROM \"stock\" WHERE \"Device_ID\" = p_device_id ORDER BY \"Quantity\" DESC LIMIT 1;\n    RETURN v_shop_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT find_shop_with_max_stock(1);",
      "SELECT find_shop_with_max_stock(2);",
      "SELECT find_shop_with_max_stock(3);",
      "SELECT find_shop_with_max_stock(6);",
      "SELECT find_shop_with_max_stock(10);"
    ],
    "summary": "Create a function named find_shop_with_max_stock that takes a device ID as input and returns the shop ID that has the highest quantity of that device in the stock table.",
    "natural_language": "Function find_shop_with_max_stock: input device ID, output shop ID with highest device quantity in stock.",
    "id": 267
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `count_shops_by_location` that accepts a single input parameter, `p_location`, which is of type `text`. This function is designed to return an integer value. Upon execution, the function declares a local variable named `v_count` of type `integer`. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement calculates the total number of rows in the table named `\"shop\"`. The count is determined by applying a `COUNT(*)` aggregate function, which counts all rows that satisfy a specific condition. The condition for counting is `WHERE \"Location\" = p_location`, meaning only rows where the value in the column named `\"Location\"` exactly matches the value provided in the `p_location` input parameter are included in the count. The result of this `COUNT(*)` operation is then assigned to the local variable `v_count`. Finally, the function returns the integer value stored in `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_shops_by_location(p_location text) RETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM \"shop\" WHERE \"Location\" = p_location;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT count_shops_by_location('Dinas');",
      "SELECT count_shops_by_location('Cymmer');",
      "SELECT count_shops_by_location('Blaenllechau');",
      "SELECT count_shops_by_location('Cardiff');",
      "SELECT count_shops_by_location('Swansea');"
    ],
    "summary": "Create a function named count_shops_by_location that takes a location text as input and returns the count of shops in that location from the shop table.",
    "natural_language": "Count shops in a given location.",
    "id": 268
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_device_carrier that accepts a single integer input parameter named p_device_id, which represents the unique identifier for a device record, and returns a text value; within the function, a local text variable v_carrier is declared to temporarily hold the result, then a SELECT query is executed to retrieve the value from the \"Carrier\" column of the \"device\" table specifically from the row where the \"Device_ID\" column exactly matches the provided p_device_id input parameter, and this retrieved value is stored into the v_carrier variable using the INTO clause, after which the function concludes by returning the value contained in the v_carrier variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_carrier(p_device_id integer) RETURNS text AS $$\nDECLARE\n    v_carrier text;\nBEGIN\n    SELECT \"Carrier\" INTO v_carrier FROM \"device\" WHERE \"Device_ID\" = p_device_id;\n    RETURN v_carrier;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT get_device_carrier(1);",
      "SELECT get_device_carrier(2);",
      "SELECT get_device_carrier(3);",
      "SELECT get_device_carrier(6);",
      "SELECT get_device_carrier(10);"
    ],
    "summary": "Create a function named get_device_carrier that takes a device ID as input and returns the carrier text for that device from the device table.",
    "natural_language": "Make a function called get_device_carrier that, when given a device identifier, fetches and gives back the roughly corresponding service provider details from the device records.",
    "id": 269
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_stock_per_shop that accepts a single integer input parameter named p_device_id, which is used to identify a specific device, and returns a numeric value; within the function, a local numeric variable v_avg is declared, then a SELECT query is executed against the table named \"stock\" to compute the average value of the column named \"Quantity\" for all rows where the column named \"Device_ID\" is exactly equal to the provided p_device_id parameter, and this computed average is stored into the v_avg variable; the function concludes by returning the value of v_avg, but if the SELECT query found no matching rows resulting in v_avg being NULL, the COALESCE function is used to substitute that NULL with the numeric value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_stock_per_shop(p_device_id integer) RETURNS numeric AS $$\nDECLARE\n    v_avg numeric;\nBEGIN\n    SELECT AVG(\"Quantity\") INTO v_avg FROM \"stock\" WHERE \"Device_ID\" = p_device_id;\n    RETURN COALESCE(v_avg, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT calculate_average_stock_per_shop(1);",
      "SELECT calculate_average_stock_per_shop(2);",
      "SELECT calculate_average_stock_per_shop(3);",
      "SELECT calculate_average_stock_per_shop(6);",
      "SELECT calculate_average_stock_per_shop(10);"
    ],
    "summary": "Create a function named calculate_average_stock_per_shop that takes a device ID as input and returns the average quantity of that device per shop from the stock table. Return 0 if no average can be calculated.",
    "natural_language": "Develop a function called calculate_average_stock_per_shop which, when provided with a specific device identifier as its input parameter, meticulously computes and delivers the mean quantity of that particular device held in inventory across each individual retail outlet, as recorded in the stock table; if for any reason an average value cannot be determined, the function should gracefully return a default result of zero.",
    "id": 270
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the total value of all orders by summing the product prices of all items in the \"Order_Items\" table. The function does not take any parameters and returns a numeric value. Inside the function, a variable named total_value of type numeric is declared to store the result of the calculation. The function performs a SELECT statement that joins the \"Order_Items\" table (aliased as oi) with the \"Products\" table (aliased as p) on the condition that the product_id column in \"Order_Items\" matches the product_id column in \"Products\". For each matching pair of rows, the product_price column from the \"Products\" table is summed using the SUM() aggregate function. The result of this summation is assigned to the total_value variable using the INTO clause. Finally, the function returns the value stored in total_value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_order_value()\nRETURNS numeric AS $$\nDECLARE\n    total_value numeric;\nBEGIN\n    SELECT SUM(p.product_price)\n    INTO total_value\n    FROM \"Order_Items\" oi\n    JOIN \"Products\" p ON oi.product_id = p.product_id;\n    RETURN total_value;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_total_order_value();"
    ],
    "summary": "Create a PL/pgSQL function with no parameters that returns a numeric value. The function should calculate the total value of all orders by summing the product prices from the \"Order_Items\" table, joined with the \"Products\" table on product_id.",
    "natural_language": "Design a PL/pgSQL function that accepts no parameters and yields a numeric return value. This function should meticulously compute the aggregate monetary value of every single order by performing a comprehensive summation of all individual product prices. To achieve this, it must access the \"Order_Items\" table and seamlessly join it with the \"Products\" table using the common product_id field, thereby ensuring an accurate and complete financial total.",
    "id": 271
  },
  {
    "ir": "Write a PL/pgSQL function named `get_customer_order_count` that is designed to return a single `bigint` value representing the total number of orders. This function does not accept any input parameters. Upon execution, the function declares a local variable named `order_count` of type `bigint` to temporarily store the calculated count. The core operation involves executing a `SELECT` statement to count all rows (`COUNT(*)`) from the table named `\"Customer_Orders\"`. The result of this count operation is then immediately assigned to the `order_count` variable. Finally, the function returns the value currently held by the `order_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_order_count()\nRETURNS bigint AS $$\nDECLARE\n    order_count bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO order_count\n    FROM \"Customer_Orders\";\n    RETURN order_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_customer_order_count();"
    ],
    "summary": "Create a PL/pgSQL function named `get_customer_order_count` with no parameters that returns a bigint. The function should count and return the total number of rows in the \"Customer_Orders\" table.",
    "natural_language": "Write a PL/pgSQL function called `get_customer_order_count` that takes no parameters and returns a bigint. It must calculate and return the total count of rows from the \"Customer_Orders\" table.",
    "id": 272
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the value of the customer_code column from the Customers table for the row where the customer_id column equals 1, duplicates this value by repeating it twice using the repeat() function, and then returns the resulting repeated string. The function does not take any input parameters and returns a single text value. Inside the function, a local variable named repeated_code of type text is declared to store the intermediate result. The SELECT statement is used to fetch the customer_code value from the Customers table, apply the repeat() function to duplicate the string, and assign the result to the repeated_code variable. The WHERE clause in the SELECT statement ensures that only the row with customer_id equal to 1 is considered. After the SELECT operation, the function returns the value stored in repeated_code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_repeated_customer_code()\nRETURNS text AS $$\nDECLARE\n    repeated_code text;\nBEGIN\n    SELECT repeat(customer_code, 2)\n    INTO repeated_code\n    FROM \"Customers\"\n    WHERE customer_id = 1;\n    RETURN repeated_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_repeated_customer_code();"
    ],
    "summary": "Create a PL/pgSQL function with no parameters that returns a text value. The function should retrieve the customer_code for customer_id 1 from the \"Customers\" table, repeat the string twice using the repeat() function, and return the result.",
    "natural_language": "What is the result of creating a PL/pgSQL function with no parameters that returns the customer_code for customer_id 1 from the \"Customers\" table, repeated twice?",
    "id": 273
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_latest_order_date that takes no input parameters and returns a single value of data type timestamp with time zone; within the function, a local variable named latest_date is declared to also hold a timestamp with time zone; the function's logic executes a SELECT statement that retrieves the maximum value from the order_date column found in the table named \"Customer_Orders\" using the MAX aggregate function, and this retrieved value is stored into the local variable latest_date via the INTO clause; the function then concludes by returning the value contained in the latest_date variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_order_date()\nRETURNS timestamp with time zone AS $$\nDECLARE\n    latest_date timestamp with time zone;\nBEGIN\n    SELECT MAX(order_date)\n    INTO latest_date\n    FROM \"Customer_Orders\";\n    RETURN latest_date;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_latest_order_date();",
      "SELECT * FROM get_latest_order_date();",
      "SELECT get_latest_order_date() AS latest_order_date;",
      "DO $$\nDECLARE\n    latest timestamp with time zone;\nBEGIN\n    latest := get_latest_order_date();\n    RAISE NOTICE 'Latest order date: %', latest;\nEND $$;",
      "SELECT get_latest_order_date() INTO TEMP latest_date_result;"
    ],
    "summary": "Create a PL/pgSQL function named `get_latest_order_date` with no parameters that returns a timestamp with time zone. The function should find and return the maximum order_date from the \"Customer_Orders\" table.",
    "natural_language": "Write a PL/pgSQL function called `get_latest_order_date` that takes no parameters and returns a timestamp with time zone. It must retrieve and return the latest order_date from the \"Customer_Orders\" table.",
    "id": 274
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the product_name column value from the \"Products\" table in the public schema for the row where the product_id column equals 1, repeats this value three times using the repeat() function, assigns the resulting repeated string to a variable named repeated_name, and then returns this repeated string as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_name_repeated()\nRETURNS text AS $$\nDECLARE\n    repeated_name text;\nBEGIN\n    SELECT repeat(product_name, 3)\n    INTO repeated_name\n    FROM public.\"Products\"\n    WHERE product_id = 1;\n    RETURN repeated_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_product_name_repeated();"
    ],
    "summary": "Create a PL/pgSQL function with no parameters that returns a text value. The function should retrieve the product_name for product_id 1 from the public.\"Products\" table, repeat the string three times using the repeat() function, and return the result.",
    "natural_language": "Write a function that gives back some text. It should look in the public.\"Products\" table and get the product name for the product with ID 1. Then, take that name and repeat it a few times, maybe three or so, using the repeat thing, and send that back.",
    "id": 275
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_country_language_count` that accepts one input parameter, `p_country_name`, which is of type `text`. This function is designed to return an `integer` value representing the count of official languages associated with the country specified by `p_country_name`. The function's logic proceeds as follows: It first converts the input parameter `p_country_name` to lowercase using the `LOWER()` function and compares it to the literal string 'iceland'. If `LOWER(p_country_name)` is exactly 'iceland', the function executes a `SELECT COUNT(*)` query on the `official_languages` table. The `COUNT(*)` operation tallies all rows in the `official_languages` table that satisfy a specific condition. This condition requires that the `country_id` column in the `official_languages` table matches the `id` of the country named 'iceland' from the `countries` table. To find this `id`, a subquery is performed: `SELECT \"id\" FROM \"countries\" WHERE LOWER(\"name\") = 'iceland'`. This subquery retrieves the `id` from the `countries` table where the `name` column, after being converted to lowercase using `LOWER()`, is equal to 'iceland'. The result of this `COUNT(*)` query is then returned as the function's output. If the initial condition (country name is 'iceland') is not met, the function proceeds to an `ELSIF` block. In this block, it converts `p_country_name` to lowercase using `LOWER()` and compares it to the literal string 'sweden'. If `LOWER(p_country_name)` is exactly 'sweden', the function executes another `SELECT COUNT(*)` query on the `official_languages` table. Similar to the previous case, this `COUNT(*)` operation counts rows in `official_languages` where the `country_id` matches the `id` of the country named 'sweden' from the `countries` table. The `id` for 'sweden' is obtained via a subquery: `SELECT \"id\" FROM \"countries\" WHERE LOWER(\"name\") = 'sweden'`, which retrieves the `id` from the `countries` table where the lowercase `name` is 'sweden'. The result of this `COUNT(*)` query is then returned. If neither of the preceding conditions (country name is 'iceland' or 'sweden') is met, the function executes the `ELSE` block. In this block, it performs a general `SELECT COUNT(*)` query on the `official_languages` table. This `COUNT(*)` operation counts rows in `official_languages` where the `country_id` matches the `id` of the country specified by the input `p_country_name` from the `countries` table. The `id` for the specified country is obtained via a subquery: `SELECT \"id\" FROM \"countries\" WHERE LOWER(\"name\") = LOWER(p_country_name)`. This subquery retrieves the `id` from the `countries` table where the `name` column, after being converted to lowercase using `LOWER()`, is equal to the lowercase version of the input `p_country_name` (also converted using `LOWER()`). The result of this final `COUNT(*)` query is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_language_count(p_country_name text)\nRETURNS integer AS $$\nBEGIN\n    IF LOWER(p_country_name) = 'iceland' THEN\n        RETURN (SELECT COUNT(*) FROM \"official_languages\" WHERE \"country_id\" = (SELECT \"id\" FROM \"countries\" WHERE LOWER(\"name\") = 'iceland'));\n    ELSIF LOWER(p_country_name) = 'sweden' THEN\n        RETURN (SELECT COUNT(*) FROM \"official_languages\" WHERE \"country_id\" = (SELECT \"id\" FROM \"countries\" WHERE LOWER(\"name\") = 'sweden'));\n    ELSE\n        RETURN (SELECT COUNT(*) FROM \"official_languages\" WHERE \"country_id\" = (SELECT \"id\" FROM \"countries\" WHERE LOWER(\"name\") = LOWER(p_country_name)));\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT get_country_language_count('Iceland');",
      "SELECT get_country_language_count('Sweden');",
      "SELECT get_country_language_count('Canada');",
      "SELECT get_country_language_count('iceland');",
      "SELECT get_country_language_count('SWEDEN');"
    ],
    "summary": "Create a PL/pgSQL function named `get_country_language_count` that takes a country name (`text`) and returns an `integer` count of its official languages. Query the `official_languages` table, counting rows where `country_id` matches the country's ID from the `countries` table. Use a case-insensitive name comparison. Return the count.",
    "natural_language": "Write a function `get_country_language_count` that returns the number of official languages for a given country name. Use case-insensitive matching.",
    "id": 276
  },
  {
    "ir": "Write a PLpgSQL function named calculate_country_average that takes a single input parameter p_country_id of type bigint, representing the unique identifier of a country, and calculates the average score for the specified country based on different criteria depending on the country ID. The function begins by declaring a local variable v_avg_score of type real to store the calculated average score. It then uses conditional logic to determine the calculation method based on the value of p_country_id. If p_country_id equals 1, the function performs a SELECT query on the countries table, specifically retrieving the row where the id column equals 1, and calculates the average of the justice_score, health_score, and education_score columns by summing these three columns and dividing the result by 3. The calculated value is stored in the v_avg_score variable. If p_country_id equals 2, the function performs a similar SELECT query on the countries table, retrieving the row where the id column equals 2, and calculates the average of the justice_score, health_score, education_score, and economics_score columns by summing these four columns and dividing the result by 4. The calculated value is stored in the v_avg_score variable. For all other values of p_country_id, the function performs a SELECT query on the countries table, retrieving the row where the id column matches the value of p_country_id, and calculates the average of the justice_score and health_score columns by summing these two columns and dividing the result by 2. The calculated value is stored in the v_avg_score variable. After determining the appropriate average score based on the conditional logic, the function returns the value of v_avg_score as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_country_average(p_country_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_avg_score real;\nBEGIN\n    IF p_country_id = 1 THEN\n        SELECT AVG(\"justice_score\" + \"health_score\" + \"education_score\") / 3 INTO v_avg_score FROM \"countries\" WHERE \"id\" = 1;\n    ELSIF p_country_id = 2 THEN\n        SELECT AVG(\"justice_score\" + \"health_score\" + \"education_score\" + \"economics_score\") / 4 INTO v_avg_score FROM \"countries\" WHERE \"id\" = 2;\n    ELSE\n        SELECT AVG(\"justice_score\" + \"health_score\") / 2 INTO v_avg_score FROM \"countries\" WHERE \"id\" = p_country_id;\n    END IF;\n    RETURN v_avg_score;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT calculate_country_average(1);",
      "SELECT calculate_country_average(2);",
      "SELECT calculate_country_average(3);",
      "SELECT calculate_country_average(4);",
      "SELECT calculate_country_average(5);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_country_average` that takes a country ID (`bigint`) and returns a `real` average score. For ID 1, calculate the average of `justice_score`, `health_score`, and `education_score`. For ID 2, calculate the average of `justice_score`, `health_score`, `education_score`, and `economics_score`. For any other ID, calculate the average of `justice_score` and `health_score`. Return the calculated average.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be distinctly named `calculate_country_average`, that is designed to accept a single input parameter: a country identifier of type `bigint`. This function must meticulously compute and then return a final average score as a `real` value. The specific calculation logic is to be determined in a detailed, case-by-case manner based on the provided country ID. For the specific case where the country ID is precisely 1, the function must carefully derive the average by summing the distinct `justice_score`, `health_score`, and `education_score` values and then dividing by three. In the alternative scenario where the country ID is exactly 2, the computation must expansively include an additional metric, requiring the average of four scores: `justice_score`, `health_score`, `education_score`, and the supplementary `economics_score`. For any other country ID value that does not match the aforementioned cases, the function should employ a more streamlined calculation, deriving the average solely from the `justice_score` and `health_score` fields. Ultimately, the function must reliably return the calculated average result.",
    "id": 277
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_hotel_rating_category` that accepts a single input parameter. This parameter, named `p_star_code`, is of data type `text` and is intended to represent a star rating code for a hotel. The function is designed to return a `text` value, which will be a descriptive category corresponding to the provided star code. The core logic of the function involves a `CASE` statement that evaluates the value of `p_star_code`. If `p_star_code` is exactly equal to the string literal `'1'`, the function will return the string literal `'Basic'`. If `p_star_code` is exactly equal to the string literal `'2'`, the function will return the string literal `'Standard'`. If `p_star_code` is exactly equal to the string literal `'3'`, the function will return the string literal `'Superior'`. For any other value of `p_star_code` that does not match `'1'`, `'2'`, or `'3'`, the function will default to returning the string literal `'Premium'`. The function does not interact with any database tables, perform any data manipulation language (DML) operations such as `INSERT`, `UPDATE`, or `DELETE`, nor does it execute any `SELECT` statements against tables. It solely performs a conditional evaluation of its input parameter to determine an appropriate output string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_hotel_rating_category(p_star_code text)\nRETURNS text AS $$\nBEGIN\n    RETURN CASE \n        WHEN p_star_code = '1' THEN 'Basic'\n        WHEN p_star_code = '2' THEN 'Standard'\n        WHEN p_star_code = '3' THEN 'Superior'\n        ELSE 'Premium'\n    END;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Theme_park",
    "tables": [
      "Hotels",
      "Ref_Hotel_Star_Ratings",
      "Features",
      "Tourist_Attraction_Features",
      "Ref_Attraction_Types"
    ],
    "call_sqls": [
      "SELECT get_hotel_rating_category('1');",
      "SELECT get_hotel_rating_category('2');",
      "SELECT get_hotel_rating_category('3');",
      "SELECT get_hotel_rating_category('4');",
      "SELECT get_hotel_rating_category('5');"
    ],
    "summary": "Create a function named get_hotel_rating_category that takes a text parameter p_star_code and returns a text value. Use a CASE statement to return 'Basic' for '1', 'Standard' for '2', 'Superior' for '3', and 'Premium' for any other input.",
    "natural_language": "Develop a function called get_hotel_rating_category, which is designed to accept a single text parameter named p_star_code and subsequently provides a text value as its output. Within this function, implement a comprehensive CASE statement that meticulously evaluates the input: specifically, it should return the descriptive label 'Basic' when the code is precisely '1', it should return 'Standard' for the exact code '2', it should yield 'Superior' if the code is '3', and finally, for any other conceivable input value, it must categorically return the designation 'Premium'.",
    "id": 278
  },
  {
    "ir": "Write a PLpgSQL function named get_document_subset_bounds that accepts three input parameters: an array of bigint values named p_subset_ids, an integer named p_lower_dim, and an integer named p_upper_dim, and returns a single integer value; within the function, a local integer variable v_bound is declared, then a SELECT statement is executed to call the built-in PostgreSQL function array_lower, which takes the input array p_subset_ids and the dimension index specified by p_lower_dim to determine the lower bound (the starting index) of that array dimension, storing the result into v_bound; the function finally returns the value of v_bound, but uses the COALESCE function to substitute a value of 0 if the result from array_lower is null, which occurs when the specified dimension p_lower_dim does not exist within the provided array p_subset_ids.",
    "plsql": "CREATE OR REPLACE FUNCTION get_document_subset_bounds(p_subset_ids bigint[], p_lower_dim integer, p_upper_dim integer)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_bound integer;\nBEGIN\n    SELECT array_lower(p_subset_ids, p_lower_dim) INTO v_bound;\n    RETURN COALESCE(v_bound, 0);\nEND;\n$$;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collection_Subset_Members",
      "Collection_Subsets",
      "Collections",
      "Document_Objects",
      "Document_Subset_Members",
      "Document_Subsets",
      "Documents_in_Collections"
    ],
    "call_sqls": [
      "SELECT get_document_subset_bounds(ARRAY[717, 981, 851], 1, 3);",
      "SELECT get_document_subset_bounds(ARRAY[684, 717, 741], 2, 3);",
      "SELECT get_document_subset_bounds(ARRAY[547, 183, 653], 1, 2);",
      "SELECT get_document_subset_bounds(ARRAY[171, 183, 216], 1, 1);",
      "SELECT get_document_subset_bounds(ARRAY[6, 7], 1, 2);"
    ],
    "summary": "Create a function named get_document_subset_bounds that takes an array of bigint p_subset_ids, an integer p_lower_dim, and an integer p_upper_dim, and returns an integer. Declare an integer variable v_bound, set it to the lower bound of p_subset_ids for dimension p_lower_dim using array_lower, and return the result using COALESCE to return 0 if the dimension does not exist.",
    "natural_language": "How can I create a function called get_document_subset_bounds that accepts an array of bigint named p_subset_ids, an integer p_lower_dim, and an integer p_upper_dim, and returns an integer? The function should declare an integer variable v_bound, set it to the lower bound of p_subset_ids for the dimension p_lower_dim using array_lower, and then return that result using COALESCE to return 0 if the specified dimension does not exist.",
    "id": 279
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `classify_hotel_rating` that accepts a single input parameter. This parameter, `p_star_code`, is of type `text` and is intended to represent a hotel's star rating, potentially as a string. The function is designed to return a `text` value, which will be a classification of the hotel's quality based on its star rating. The core logic of the function involves a conditional evaluation. First, the input parameter `p_star_code` is explicitly converted from its `text` type to an `integer` type using the `CAST` operator. This converted integer value is then compared against the literal integer value `3`. If the converted integer value of `p_star_code` is greater than or equal to `3`, the function immediately returns the literal string `'High Quality'`. Otherwise, if the converted integer value of `p_star_code` is less than `3`, the function returns the literal string `'Standard'`. The function does not interact with any database tables, nor does it perform any data manipulation operations such as inserts, updates, or deletes. It solely performs a type conversion and a conditional string return based on the input parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_hotel_rating(p_star_code text) RETURNS text AS $$\nBEGIN\n    IF CAST(p_star_code AS integer) >= 3 THEN\n        RETURN 'High Quality';\n    ELSE\n        RETURN 'Standard';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Theme_park",
    "tables": [
      "Hotels",
      "Ref_Hotel_Star_Ratings",
      "Locations",
      "Tourist_Attractions",
      "Photos",
      "Visits"
    ],
    "call_sqls": [
      "SELECT classify_hotel_rating('1');",
      "SELECT classify_hotel_rating('2');",
      "SELECT classify_hotel_rating('3');",
      "SELECT classify_hotel_rating('4');",
      "SELECT classify_hotel_rating('5');"
    ],
    "summary": "Create a function named classify_hotel_rating that takes a text parameter p_star_code and returns a text value. Convert p_star_code to an integer. If the integer is greater than or equal to 3, return 'High Quality'; otherwise, return 'Standard'.",
    "natural_language": "Create a function called classify_hotel_rating that accepts a text parameter for the star code. It should figure out the numeric value from that code. If that number seems pretty high, like at a certain good level or above, label it as 'High Quality'. If it's not up to that mark, just call it 'Standard'.",
    "id": 280
  },
  {
    "ir": "Write a PLpgSQL function named get_related_collections that accepts a single input parameter named collection_id of type bigint, which represents the unique identifier of a collection, and returns a single bigint value; within the function, a local variable named related_count of type bigint is declared; the function's logic begins by executing a SELECT statement that performs a COUNT(*) aggregation on the table named \"Collection_Subset_Members\", specifically counting all rows where the value in the column named \"Collection_ID\" is exactly equal to the input parameter collection_id; the result of this count operation is stored into the local variable related_count; the function then returns the value of related_count, which signifies the total number of related subset member records found for the given collection_id; the function includes an exception handling block that catches the specific predefined exception condition named undefined_table, which occurs if the query references a table that does not exist, and in that event, the function execution is diverted to return the value 0 instead of propagating the error.",
    "plsql": "CREATE OR REPLACE FUNCTION get_related_collections(collection_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    related_count bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO related_count\n    FROM \"Collection_Subset_Members\"\n    WHERE \"Collection_ID\" = get_related_collections.collection_id;\n\n    RETURN related_count;\nEXCEPTION\n    WHEN undefined_table THEN\n        RETURN 0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collections",
      "Collection_Subsets",
      "Collection_Subset_Members",
      "Documents_in_Collections"
    ],
    "call_sqls": [
      "SELECT get_related_collections(6);",
      "SELECT get_related_collections(7);",
      "SELECT get_related_collections(1);",
      "SELECT get_related_collections(100);",
      "SELECT get_related_collections(NULL);"
    ],
    "summary": "Create a function named get_related_collections that takes a bigint parameter collection_id and returns a bigint. Declare a bigint variable related_count. Count the rows in the \"Collection_Subset_Members\" table where \"Collection_ID\" equals collection_id and store the result in related_count. Return related_count. Handle the undefined_table exception by returning 0.",
    "natural_language": "Count the related collections for a given collection ID. To do this, create a function called get_related_collections that accepts a bigint parameter named collection_id and returns a bigint. Inside the function, declare a bigint variable named related_count. Then, count the rows in the \"Collection_Subset_Members\" table where the \"Collection_ID\" matches the provided collection_id and store that count in related_count. Finally, return the value of related_count. Ensure the function handles the undefined_table exception by returning 0.",
    "id": 281
  },
  {
    "ir": "Write a PLpgSQL function named calculate_average_age_by_school that accepts a single integer input parameter named school_id_input, returns a real number, and performs the following operations: it declares a local real variable named avg_age; it executes a SELECT query on the player table to compute the average value of the Age column for all rows where the School_ID column exactly matches the provided school_id_input parameter, storing the result into the avg_age variable; it then evaluates the value of avg_age with a conditional IF-ELSIF-ELSE block: if avg_age is NULL, it assigns the value -1 to avg_age; otherwise, if avg_age is less than 15, it multiplies avg_age by 1.1 and reassigns the result to avg_age; otherwise, for any other case where avg_age is 15 or greater, it adds 2 to avg_age and reassigns the result; finally, the function returns the final value of the avg_age variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_age_by_school(school_id_input integer)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_age real;\nBEGIN\n    SELECT AVG(\"Age\") INTO avg_age\n    FROM player\n    WHERE \"School_ID\" = school_id_input;\n\n    IF avg_age IS NULL THEN\n        avg_age := -1;\n    ELSIF avg_age < 15 THEN\n        avg_age := avg_age * 1.1;\n    ELSE\n        avg_age := avg_age + 2;\n    END IF;\n\n    RETURN avg_age;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT calculate_average_age_by_school(1);",
      "SELECT calculate_average_age_by_school(2);",
      "SELECT calculate_average_age_by_school(3);",
      "SELECT calculate_average_age_by_school(10);",
      "SELECT calculate_average_age_by_school(NULL);"
    ],
    "summary": "Create a function named calculate_average_age_by_school that takes an integer parameter school_id_input and returns a real number. Declare a real variable avg_age. Calculate the average Age from the player table where School_ID equals school_id_input and store it in avg_age. If avg_age is NULL, set it to -1. If avg_age is less than 15, multiply it by 1.1. Otherwise, add 2 to it. Return the final avg_age.",
    "natural_language": "Make a function called calculate_average_age_by_school that needs a school ID number. It should give back a real number. Figure out the typical age from the player data for that particular school. If you can't really find a solid average, just use -1. If that typical age seems on the younger side, bump it up a little, say by 10 percent. If it's not that young, just add a small amount like 2 to it. Then return whatever that final number ends up being.",
    "id": 282
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_school_performance_count that accepts a single integer input parameter named school_id_input, which is used to identify a specific school, and returns a single integer value; within the function, declare a local integer variable named performance_count; then execute a SELECT statement that queries the \"school_performance\" table to count all rows where the \"School_Id\" column value exactly matches the provided school_id_input parameter, storing the resulting count into the performance_count variable; following this, evaluate the value of performance_count with a conditional IF-ELSIF-ELSE block: if performance_count equals 0, assign the value -1 to performance_count; otherwise, if performance_count is less than 3, multiply the current performance_count value by 5 and assign the product back to performance_count; otherwise, for all cases where performance_count is 3 or greater, add 7 to the current performance_count value and assign the sum back to performance_count; finally, return the final computed value of the performance_count variable as the function result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_performance_count(school_id_input integer)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    performance_count integer;\nBEGIN\n    SELECT COUNT(*) INTO performance_count\n    FROM \"school_performance\"\n    WHERE \"School_Id\" = school_id_input;\n\n    IF performance_count = 0 THEN\n        performance_count := -1;\n    ELSIF performance_count < 3 THEN\n        performance_count := performance_count * 5;\n    ELSE\n        performance_count := performance_count + 7;\n    END IF;\n\n    RETURN performance_count;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_school_performance_count(1);",
      "SELECT get_school_performance_count(2);",
      "SELECT get_school_performance_count(3);",
      "SELECT get_school_performance_count(10);",
      "SELECT get_school_performance_count(15);"
    ],
    "summary": "Create a PL/pgSQL function named get_school_performance_count that returns an integer. It counts rows in the school_performance table for a given School_Id, then modifies the count: if zero, return -1; if less than 3, multiply by 5; otherwise, add 7.",
    "natural_language": "Develop a PL/pgSQL function, which should be named get_school_performance_count, that is designed to return an integer value. This function will meticulously count all the existing rows within the school_performance table that correspond to a specifically provided School_Id. Subsequently, it will apply a detailed modification to this count: if the count is precisely zero, the function will distinctly return -1; if the count is less than three, it will carefully multiply the number by 5; otherwise, for all other cases, it will simply add 7 to the original count.",
    "id": 283
  },
  {
    "ir": "Write a PLpgSQL function named calculate_total_players_by_division that accepts a single input parameter named division_input of type text, which represents a school division to filter by, and returns an integer value; the function begins by declaring a local integer variable named total_players, then executes a SELECT statement that performs an INNER JOIN between the player table (aliased as p) and the school_details table (aliased as sd) using the condition that the School_ID column from the player table matches the School_ID column from the school_details table, and from this joined result set, it counts all rows where the Division column from the school_details table is exactly equal to the provided division_input parameter, storing the resulting count into the total_players variable; following this query, the function evaluates the value of total_players with a conditional IF-ELSIF-ELSE block: if total_players equals 0, it reassigns the variable to the value -1; otherwise, if total_players is less than 20, it multiplies the current total_players value by 2 and reassigns the result back to total_players; in all other cases (where total_players is 20 or greater), it adds 10 to the current total_players value and reassigns the result; finally, the function returns the final value of the total_players variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_players_by_division(division_input text)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_players integer;\nBEGIN\n    SELECT COUNT(*) INTO total_players\n    FROM player p\n    JOIN school_details sd ON p.\"School_ID\" = sd.\"School_ID\"\n    WHERE sd.\"Division\" = division_input;\n\n    IF total_players = 0 THEN\n        total_players := -1;\n    ELSIF total_players < 20 THEN\n        total_players := total_players * 2;\n    ELSE\n        total_players := total_players + 10;\n    END IF;\n\n    RETURN total_players;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT calculate_total_players_by_division('Division 1');",
      "SELECT calculate_total_players_by_division('Division 2');",
      "SELECT calculate_total_players_by_division('Division 3');",
      "SELECT calculate_total_players_by_division('Division 4');",
      "SELECT calculate_total_players_by_division('Division 5');"
    ],
    "summary": "Create a PL/pgSQL function named calculate_total_players_by_division that returns an integer. It counts players in a given school division via a join. It then modifies the count: if zero, return -1; if less than 20, multiply by 2; otherwise, add 10.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be distinctly named calculate_total_players_by_division, designed to return an integer value. This function must meticulously count all players associated with a specified school division by performing a detailed join operation between the relevant database tables. Subsequently, it must apply a specific modification to the resulting count: if the count is precisely zero, the function should deliberately return a value of negative one; if the count is found to be less than twenty, it should strategically double the count by multiplying it by two; and in all other cases, where the count is twenty or greater, it should simply augment the count by adding ten.",
    "id": 284
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_customer_summary that returns a table with three columns: customer_name of type text, overpayment_count of type bigint, and council_tax_count of type bigint, and accepts a single input parameter p_source_system of type text, then within its body, first checks if the lowercased version of the p_source_system parameter equals the string literal 'rent' using the LOWER function, and if this condition is true, it executes and returns the result of a query that selects the cmi_details column from the Customer_Master_Index table aliased as cmi, a count of distinct council_tax_id values from the Benefits_Overpayments table aliased as bo, and a count of distinct council_tax_id values from the Council_Tax table aliased as ct, by performing an inner join between the Customer_Master_Index table and the CMI_Cross_References table aliased as ccr on the condition that the master_customer_id column from Customer_Master_Index equals the master_customer_id column from CMI_Cross_References, then performing a left outer join from the CMI_Cross_References table to the Benefits_Overpayments table on the condition that the cmi_cross_ref_id column from CMI_Cross_References equals the cmi_cross_ref_id column from Benefits_Overpayments, and a left outer join from the CMI_Cross_References table to the Council_Tax table on the condition that the cmi_cross_ref_id column from CMI_Cross_References equals the cmi_cross_ref_id column from Council_Tax, then filtering the results where the source_system_code column from the CMI_Cross_References table equals the input parameter p_source_system, and finally grouping all results by the cmi_details column from the Customer_Master_Index table; otherwise, if the lowercased p_source_system does not equal 'rent', the function executes and returns the result of a different query that selects the cmi_details column from the Customer_Master_Index table, a literal zero cast as a bigint, and a count of distinct council_tax_id values from the Council_Tax table, by performing an inner join between the Customer_Master_Index table and the CMI_Cross_References table on the condition that the master_customer_id column from Customer_Master_Index equals the master_customer_id column from CMI_Cross_References, then performing an inner join between the CMI_Cross_References table and the Council_Tax table on the condition that the cmi_cross_ref_id column from CMI_Cross_References equals the cmi_cross_ref_id column from Council_Tax, and finally grouping all results by the cmi_details column from the Customer_Master_Index table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_summary(p_source_system text)\nRETURNS TABLE(customer_name text, overpayment_count bigint, council_tax_count bigint) AS $$\nBEGIN\n    IF LOWER(p_source_system) = 'rent' THEN\n        RETURN QUERY SELECT cmi.cmi_details, COUNT(DISTINCT bo.council_tax_id), COUNT(DISTINCT ct.council_tax_id)\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.master_customer_id = ccr.master_customer_id\n        LEFT JOIN \"Benefits_Overpayments\" bo ON ccr.cmi_cross_ref_id = bo.cmi_cross_ref_id\n        LEFT JOIN \"Council_Tax\" ct ON ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id\n        WHERE ccr.source_system_code = p_source_system\n        GROUP BY cmi.cmi_details;\n    ELSE\n        RETURN QUERY SELECT cmi.cmi_details, 0::bigint, COUNT(DISTINCT ct.council_tax_id)\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.master_customer_id = ccr.master_customer_id\n        JOIN \"Council_Tax\" ct ON ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id\n        GROUP BY cmi.cmi_details;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_Cross_References",
      "Customer_Master_Index",
      "Council_Tax",
      "Benefits_Overpayments"
    ],
    "call_sqls": [
      "SELECT * FROM get_customer_summary('Rent');",
      "SELECT * FROM get_customer_summary('Parking');",
      "SELECT * FROM get_customer_summary('rent');",
      "SELECT * FROM get_customer_summary('RENT');",
      "SELECT * FROM get_customer_summary('parking');"
    ],
    "summary": "Create a PL/pgSQL function named get_customer_summary that returns a table with customer_name, overpayment_count, and council_tax_count. If the input source system is 'rent', it returns counts from left joins to Benefits_Overpayments and Council_Tax. Otherwise, it returns a zero overpayment count and counts from an inner join to Council_Tax only.",
    "natural_language": "Write a PL/pgSQL function get_customer_summary returning customer_name, overpayment_count, and council_tax_count. For source system 'rent', left join Benefits_Overpayments and Council_Tax. Otherwise, overpayment_count is zero and inner join Council_Tax.",
    "id": 285
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named analyze_customer_data that returns a table with three columns: system_code of type text, customer_count of type bigint, and avg_name_length of type numeric, and accepts a single integer input parameter named p_min_length; the function's logic is conditional based on the value of p_min_length: if p_min_length is greater than 15, the function executes and returns a query that selects from the \"CMI_Cross_References\" table (aliased as ccr) joined with the \"Customer_Master_Index\" table (aliased as cmi) on the equality of the master_customer_id column from both tables, filtering the joined result to include only rows where the length of the cmi.cmi_details column value is greater than the input parameter p_min_length, and then groups the filtered results by the ccr.source_system_code column, calculating for each group the distinct count of ccr.master_customer_id values and the average length of the cmi.cmi_details values; if the condition is not met (i.e., p_min_length is 15 or less), the function executes and returns a different query that selects from the same joined tables without any row filter, grouping by ccr.source_system_code and calculating for each group the non-distinct count of ccr.master_customer_id values and the average length of the cmi.cmi_details values.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_customer_data(p_min_length integer)\nRETURNS TABLE(system_code text, customer_count bigint, avg_name_length numeric) AS $$\nBEGIN\n    IF p_min_length > 15 THEN\n        RETURN QUERY SELECT ccr.source_system_code, COUNT(DISTINCT ccr.master_customer_id), AVG(LENGTH(cmi.cmi_details))\n        FROM \"CMI_Cross_References\" ccr\n        JOIN \"Customer_Master_Index\" cmi ON ccr.master_customer_id = cmi.master_customer_id\n        WHERE LENGTH(cmi.cmi_details) > p_min_length\n        GROUP BY ccr.source_system_code;\n    ELSE\n        RETURN QUERY SELECT ccr.source_system_code, COUNT(ccr.master_customer_id), AVG(LENGTH(cmi.cmi_details))\n        FROM \"CMI_Cross_References\" ccr\n        JOIN \"Customer_Master_Index\" cmi ON ccr.master_customer_id = cmi.master_customer_id\n        GROUP BY ccr.source_system_code;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_Cross_References",
      "Customer_Master_Index",
      "Council_Tax",
      "Benefits_Overpayments"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_customer_data(10);",
      "SELECT * FROM analyze_customer_data(5);",
      "SELECT * FROM analyze_customer_data(20);",
      "SELECT * FROM analyze_customer_data(15);",
      "SELECT * FROM analyze_customer_data(12);"
    ],
    "summary": "Create a function named analyze_customer_data that returns a table with columns system_code (text), customer_count (bigint), and avg_name_length (numeric). It accepts an integer parameter p_min_length. If p_min_length > 15, return a query joining CMI_Cross_References and Customer_Master_Index on master_customer_id, filtering where length(cmi.cmi_details) > p_min_length, grouping by source_system_code, and calculating distinct count of master_customer_id and average length of cmi_details. Otherwise, return the same join without the filter, grouping by source_system_code and calculating non-distinct count of master_customer_id and average length of cmi_details.",
    "natural_language": "Construct a function called analyze_customer_data that yields a result table containing the columns system_code (as text), customer_count (as a bigint), and avg_name_length (as a numeric). This function must accept a single integer input parameter named p_min_length. In the detailed scenario where the provided p_min_length parameter exceeds the value of 15, the function should execute a query that performs an inner join between the CMI_Cross_References and Customer_Master_Index tables using the master_customer_id field, applying a specific filter to include only those records where the character length of the cmi_details column from the joined Customer_Master_Index table is strictly greater than the supplied p_min_length. Subsequently, it should group the results by the source_system_code and compute both the distinct count of master_customer_id and the average length of the cmi_details column for each group. Conversely, if the p_min_length parameter is 15 or less, the function should return data from the same join operation between the tables but without applying the aforementioned length filter, grouping the results by source_system_code and calculating the standard count (non-distinct) of master_customer_id alongside the average length of cmi_details for each grouping.",
    "id": 286
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_overpayment_details` that accepts one input parameter, `p_system_code`, which is of type `text`. This function is designed to return a set of rows, specifically a table, with two columns: `customer_name` of type `text` and `overpayment_count` of type `bigint`. The function's primary purpose is to retrieve customer details and, conditionally, their associated overpayment counts based on the provided system code.\n\nUpon execution, the function first evaluates a conditional statement. It converts the `p_system_code` parameter to lowercase using the `LOWER()` function and compares it to the literal string 'parking'.\n\nIf the lowercase `p_system_code` is equal to 'parking', the function executes a `RETURN QUERY` statement to select data from multiple tables. It selects the `cmi_details` column from the `\"Customer_Master_Index\"` table, aliased as `cmi`, and counts the occurrences of the `council_tax_id` column from the `\"Benefits_Overpayments\"` table, aliased as `bo`, using the `COUNT()` aggregate function. These selections are performed by joining three tables: `\"Customer_Master_Index\"` (`cmi`), `\"CMI_Cross_References\"` (`ccr`), and `\"Benefits_Overpayments\"` (`bo`). The first join connects `cmi` and `ccr` on the condition that `cmi.\"master_customer_id\"` is equal to `ccr.\"master_customer_id\"`. The second join connects `ccr` and `bo` on the condition that `ccr.\"cmi_cross_ref_id\"` is equal to `bo.\"cmi_cross_ref_id\"`. A `WHERE` clause further filters the results, ensuring that only rows where `ccr.\"source_system_code\"` is equal to the literal string 'Parking' are considered. Finally, the results are grouped by `cmi.\"cmi_details\"`.\n\nIf the lowercase `p_system_code` is not equal to 'parking', the function executes an alternative `RETURN QUERY` statement. In this case, it selects the `cmi_details` column from the `\"Customer_Master_Index\"` table, aliased as `cmi`, and a constant value of `0` cast to `bigint` for the `overpayment_count`. This selection is performed by joining two tables: `\"Customer_Master_Index\"` (`cmi`) and `\"CMI_Cross_References\"` (`ccr`). The join condition is `cmi.\"master_customer_id\"` equals `ccr.\"master_customer_id\"`. A `WHERE` clause filters these results, including only rows where `ccr.\"source_system_code\"` is equal to the value of the `p_system_code` parameter. The results are then grouped by `cmi.\"cmi_details\"`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_overpayment_details(p_system_code text)\nRETURNS TABLE(customer_name text, overpayment_count bigint) AS $$\nBEGIN\n    IF LOWER(p_system_code) = 'parking' THEN\n        RETURN QUERY SELECT cmi.\"cmi_details\", COUNT(bo.\"council_tax_id\")\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.\"master_customer_id\" = ccr.\"master_customer_id\"\n        JOIN \"Benefits_Overpayments\" bo ON ccr.\"cmi_cross_ref_id\" = bo.\"cmi_cross_ref_id\"\n        WHERE ccr.\"source_system_code\" = 'Parking'\n        GROUP BY cmi.\"cmi_details\";\n    ELSE\n        RETURN QUERY SELECT cmi.\"cmi_details\", 0::bigint\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.\"master_customer_id\" = ccr.\"master_customer_id\"\n        WHERE ccr.\"source_system_code\" = p_system_code\n        GROUP BY cmi.\"cmi_details\";\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_Cross_References",
      "Customer_Master_Index",
      "Council_Tax",
      "Benefits_Overpayments"
    ],
    "call_sqls": [
      "SELECT * FROM get_overpayment_details('Parking');",
      "SELECT * FROM get_overpayment_details('Rent');",
      "SELECT * FROM get_overpayment_details('parking');",
      "SELECT * FROM get_overpayment_details('Council Tax');",
      "SELECT * FROM get_overpayment_details('Unknown System');"
    ],
    "summary": "Create a function named get_overpayment_details that returns a table with columns customer_name (text) and overpayment_count (bigint). It accepts a text parameter p_system_code. If the lowercased p_system_code equals 'parking', return a query joining Customer_Master_Index, CMI_Cross_References, and Benefits_Overpayments, filtering where source_system_code = 'Parking', grouping by cmi_details, and selecting cmi_details and count of council_tax_id. Otherwise, return a query joining Customer_Master_Index and CMI_Cross_References, filtering where source_system_code = p_system_code, grouping by cmi_details, and selecting cmi_details and a constant 0 for overpayment_count.",
    "natural_language": "Write a function called get_overpayment_details that returns a table with customer_name (text) and overpayment_count (bigint) columns. It should take a text parameter p_system_code. If the lowercased parameter is 'parking', join Customer_Master_Index, CMI_Cross_References, and Benefits_Overpayments, filter for source_system_code = 'Parking', group by cmi_details, and select cmi_details and the count of council_tax_id. Otherwise, join just Customer_Master_Index and CMI_Cross_References, filter for source_system_code = p_system_code, group by cmi_details, and select cmi_details and a constant 0 as overpayment_count.",
    "id": 287
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_council_tax_summary that returns a table with two columns, customer_name of type text and tax_count of type bigint, and accepts one input parameter p_min_tax_id of type bigint, which serves as a threshold identifier for filtering council tax records. The function's logic is determined by a conditional IF statement that checks if the input parameter p_min_tax_id is greater than 100. If this condition is true, the function executes a RETURN QUERY that performs a SELECT statement joining three tables: it starts from the \"Customer_Master_Index\" table aliased as cmi, performs an INNER JOIN with the \"CMI_Cross_References\" table aliased as ccr on the condition that cmi.master_customer_id equals ccr.master_customer_id, and then performs an INNER JOIN with the \"Council_Tax\" table aliased as ct on the condition that ccr.cmi_cross_ref_id equals ct.cmi_cross_ref_id. The WHERE clause filters the results to include only rows from the \"Council_Tax\" table where the ct.council_tax_id column value is strictly greater than the input parameter p_min_tax_id. The query then groups the result set by the cmi.cmi_details column and, for each group, returns the cmi.cmi_details value and a count of the number of ct.council_tax_id entries in that group. If the initial IF condition is false (meaning p_min_tax_id is less than or equal to 100), the function executes an alternative RETURN QUERY with a SELECT statement that also queries from the \"Customer_Master_Index\" table aliased as cmi but uses LEFT JOIN operations: first a LEFT JOIN with the \"CMI_Cross_References\" table aliased as ccr on cmi.master_customer_id = ccr.master_customer_id, and then a LEFT JOIN with the \"Council_Tax\" table aliased as ct on ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id. This query groups all results by the cmi.cmi_details column and, for each unique cmi.cmi_details value, returns that value along with a constant integer 0 cast explicitly as a bigint, effectively returning a zero count for every customer regardless of the existence of related cross-reference or council tax records.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_council_tax_summary(p_min_tax_id bigint)\nRETURNS TABLE(customer_name text, tax_count bigint) AS $$\nBEGIN\n    IF p_min_tax_id > 100 THEN\n        RETURN QUERY SELECT cmi.cmi_details, COUNT(ct.council_tax_id)\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.master_customer_id = ccr.master_customer_id\n        JOIN \"Council_Tax\" ct ON ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id\n        WHERE ct.council_tax_id > p_min_tax_id\n        GROUP BY cmi.cmi_details;\n    ELSE\n        RETURN QUERY SELECT cmi.cmi_details, 0::bigint\n        FROM \"Customer_Master_Index\" cmi\n        LEFT JOIN \"CMI_Cross_References\" ccr ON cmi.master_customer_id = ccr.master_customer_id\n        LEFT JOIN \"Council_Tax\" ct ON ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id\n        GROUP BY cmi.cmi_details;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_Cross_References",
      "Customer_Master_Index",
      "Council_Tax",
      "Benefits_Overpayments"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_council_tax_summary(1);",
      "SELECT * FROM calculate_council_tax_summary(50);",
      "SELECT * FROM calculate_council_tax_summary(101);",
      "SELECT * FROM calculate_council_tax_summary(1000);",
      "SELECT * FROM calculate_council_tax_summary(0);"
    ],
    "summary": "Create a function named calculate_council_tax_summary that returns a table with columns customer_name (text) and tax_count (bigint). It accepts a bigint parameter p_min_tax_id. If p_min_tax_id > 100, return a query joining Customer_Master_Index, CMI_Cross_References, and Council_Tax with INNER JOINs, filtering where council_tax_id > p_min_tax_id, grouping by cmi_details, and selecting cmi_details and count of council_tax_id. Otherwise, return a query joining the same tables with LEFT JOINs, grouping by cmi_details, and selecting cmi_details and a constant 0 for tax_count.",
    "natural_language": "Create function calculate_council_tax_summary returning table(customer_name text, tax_count bigint). Takes bigint p_min_tax_id. If p_min_tax_id > 100, inner join Customer_Master_Index, CMI_Cross_References, and Council_Tax where council_tax_id > p_min_tax_id, group by cmi_details, select cmi_details and count(council_tax_id). Else, left join same tables, group by cmi_details, select cmi_details and 0 as tax_count.",
    "id": 288
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_social_score` that accepts a single input parameter, `p_student_id`, which is of type `integer` and represents the unique identifier of a student. This function is designed to compute and return a textual social score for the student identified by `p_student_id`. The function begins by declaring two local variables: `friend_count` of type `integer` to store the number of friends a student has, and `like_count` of type `integer` to store the number of likes a student has received. The first operation performed is a `SELECT COUNT(*)` statement that queries the table named `\"Friend\"`. This query counts all rows in the `\"Friend\"` table where the `student_id` column matches the value provided in the `p_student_id` input parameter. The result of this count is then stored into the `friend_count` local variable. Immediately following this, another `SELECT COUNT(*)` statement is executed. This second query targets the table named `\"Likes\"`. It counts all rows in the `\"Likes\"` table where the `student_id` column corresponds to the value of the `p_student_id` input parameter. The outcome of this count is subsequently stored into the `like_count` local variable. After retrieving these two counts, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) to determine the social score. The first condition checks if the value of `friend_count` is strictly greater than 10. If this condition is true, the function immediately returns the text string 'Highly Social'. If the first condition is false, the function then evaluates the second condition, which checks if the value of `like_count` is strictly greater than 5. If this second condition is true, the function returns the text string 'Popular'. If both the first and second conditions are false, the function proceeds to evaluate the third condition, which checks if the value of `friend_count` is strictly greater than 0. If this third condition is true, the function returns the text string 'Moderately Social'. Finally, if none of the preceding conditions are met (meaning `friend_count` is 0 or less, and `like_count` is 5 or less), the function executes the `ELSE` block and returns the text string 'Isolated'. The function is implemented using the `plpgsql` language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_social_score(p_student_id integer)\nRETURNS text AS $$\nDECLARE\n    friend_count integer;\n    like_count integer;\nBEGIN\n    SELECT COUNT(*) INTO friend_count FROM \"Friend\" WHERE student_id = p_student_id;\n    SELECT COUNT(*) INTO like_count FROM \"Likes\" WHERE student_id = p_student_id;\n\n    IF friend_count > 10 THEN\n        RETURN 'Highly Social';\n    ELSIF like_count > 5 THEN\n        RETURN 'Popular';\n    ELSIF friend_count > 0 THEN\n        RETURN 'Moderately Social';\n    ELSE\n        RETURN 'Isolated';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT calculate_social_score(1510);",
      "SELECT calculate_social_score(1689);",
      "SELECT calculate_social_score(1381);",
      "SELECT calculate_social_score(1709);",
      "SELECT calculate_social_score(1782);"
    ],
    "summary": "Create a function named calculate_social_score that returns a text score. It accepts an integer parameter p_student_id. Declare variables friend_count and like_count. Set friend_count to the count of rows in Friend where student_id = p_student_id. Set like_count to the count of rows in Likes where student_id = p_student_id. Return 'Highly Social' if friend_count > 10, 'Popular' if like_count > 5, 'Moderately Social' if friend_count > 0, otherwise return 'Isolated'.",
    "natural_language": "What function can be created to return a text score based on a student's social activity? The function, named calculate_social_score, should take a student ID as an integer parameter. How should it determine the score? It should count the number of friends for that student in the Friend table and the number of likes in the Likes table. What score should it return? It should return 'Highly Social' if the friend count is greater than 10, 'Popular' if the like count is greater than 5, 'Moderately Social' if there is at least one friend, and 'Isolated' otherwise.",
    "id": 289
  },
  {
    "ir": "Write a PLpgSQL function that takes a single integer parameter p_student_id, representing the ID of a student, and analyzes the friendship patterns of that student based on data stored in the \"Friend\" table. The function begins by declaring two local integer variables, friend_count and mutual_friend_count, to store the total number of friends and the number of mutual friendships, respectively. It first calculates the total number of friends for the given student by executing a SELECT COUNT(*) query on the \"Friend\" table, filtering rows where the student_id column matches the value of p_student_id, and stores the result in the friend_count variable. Next, it calculates the number of mutual friendships by performing a JOIN operation between two instances of the \"Friend\" table, where the first instance (f1) represents friendships initiated by the given student and the second instance (f2) represents friendships initiated by the student's friends. The JOIN condition ensures that f1.friend_id matches f2.student_id and f2.friend_id matches the original p_student_id, effectively identifying mutual friendships. The result of this query is stored in the mutual_friend_count variable. The function then evaluates the relationship between mutual_friend_count and friend_count using conditional logic. If mutual_friend_count is greater than half of friend_count, the function returns the text 'Strong mutual connections'. If mutual_friend_count is greater than zero but not more than half of friend_count, it returns 'Some mutual connections'. If mutual_friend_count is zero, it returns 'No mutual connections'. The function uses the RETURN statement to output the appropriate text based on the conditions evaluated.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_friendship_pattern(p_student_id integer)\nRETURNS text AS $$\nDECLARE\n    friend_count integer;\n    mutual_friend_count integer;\nBEGIN\n    SELECT COUNT(*) INTO friend_count FROM \"Friend\" WHERE student_id = p_student_id;\n    SELECT COUNT(*) INTO mutual_friend_count FROM \"Friend\" f1\n    JOIN \"Friend\" f2 ON f1.friend_id = f2.student_id\n    WHERE f1.student_id = p_student_id AND f2.friend_id = p_student_id;\n\n    IF mutual_friend_count > friend_count / 2 THEN\n        RETURN 'Strong mutual connections';\n    ELSIF mutual_friend_count > 0 THEN\n        RETURN 'Some mutual connections';\n    ELSE\n        RETURN 'No mutual connections';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT analyze_friendship_pattern(1510);",
      "SELECT analyze_friendship_pattern(1689);",
      "SELECT analyze_friendship_pattern(1381);",
      "SELECT analyze_friendship_pattern(1709);",
      "SELECT analyze_friendship_pattern(1782);"
    ],
    "summary": "Create a PLpgSQL function that takes a student ID and returns a text analysis of their friendship patterns. It counts the student's total friends and mutual friendships from the Friend table. Return 'Strong mutual connections' if mutual friends are more than half of total friends, 'Some mutual connections' if mutual friends exist but are half or less, or 'No mutual connections' if none exist.",
    "natural_language": "Hey, can you whip up a PLpgSQL function that, given a student's ID, gives us the lowdown on their friend scene? It should tally up their total buddies and mutual pals from the Friend table. Then, spit out 'Strong mutual connections' if the mutual friends are over half the total, 'Some mutual connections' if there are mutuals but they're half or less, or 'No mutual connections' if there aren't any.",
    "id": 290
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_grade of type integer, representing a specific grade level, and calculates the number of \"popular\" students in that grade based on specific criteria. The function begins by declaring a local variable popular_count of type integer, initialized to 0, which will store the count of popular students. It then performs a SELECT query to count the number of rows in the \"Highschooler\" table (aliased as h) joined with the \"Likes\" table (aliased as l) on the condition that the \"ID\" column of the \"Highschooler\" table matches the liked_id column of the \"Likes\" table. The query filters rows where the grade column in the \"Highschooler\" table matches the input parameter p_grade and where the student_id column in the \"Likes\" table is not equal to the liked_id column, ensuring that students are not liking themselves. The result of this query is stored in the popular_count variable. The function then evaluates the value of popular_count using conditional logic: if popular_count is greater than 10, the function returns the value of popular_count; if popular_count is greater than 5 but less than or equal to 10, the function returns half of popular_count (using integer division); otherwise, if popular_count is 5 or less, the function returns 0. The function is written in the PLpgSQL language and is designed to return an integer value.",
    "plsql": "CREATE OR REPLACE FUNCTION find_popular_students(p_grade integer)\nRETURNS integer AS $$\nDECLARE\n    popular_count integer := 0;\nBEGIN\n    SELECT COUNT(*) INTO popular_count FROM \"Highschooler\" h\n    JOIN \"Likes\" l ON h.\"ID\" = l.liked_id\n    WHERE h.grade = p_grade AND l.student_id <> l.liked_id;\n\n    IF popular_count > 10 THEN\n        RETURN popular_count;\n    ELSIF popular_count > 5 THEN\n        RETURN popular_count / 2;\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT find_popular_students(9);",
      "SELECT find_popular_students(10);",
      "SELECT find_popular_students(11);",
      "SELECT find_popular_students(12);",
      "SELECT find_popular_students(8);"
    ],
    "summary": "Create a PLpgSQL function that takes a grade level and returns an integer count of popular students in that grade. A popular student is defined as a Highschooler in that grade who is liked by someone other than themselves in the Likes table. If the count is greater than 10, return the count. If between 6 and 10, return half the count. Otherwise, return 0.",
    "natural_language": "Write a PLpgSQL function that, for a given grade level, figures out roughly how many students are considered popular there. We're talking about Highschoolers in that grade who are liked by at least one other person (not themselves) according to the Likes data. If that number seems pretty high—say, more than 10—just give back the total. If it's a moderate amount, somewhere around 6 to 10, then return about half of it. Otherwise, if it's just a few or none, return 0.",
    "id": 291
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_student_id of type integer, representing the ID of a student, and returns a text value describing the level of mutual likes between the specified student and others in the \"Likes\" table. The function begins by declaring a local variable mutual_like_count of type integer to store the count of mutual likes. It then executes a SELECT query that calculates the number of mutual likes for the given student. This query joins the \"Likes\" table, aliased as l1, with itself, aliased as l2, using the condition that the liked_id column in l1 matches the student_id column in l2. The WHERE clause further filters the rows to include only those where the student_id in l1 matches the input parameter p_student_id and the liked_id in l2 matches the input parameter p_student_id, effectively identifying mutual likes where both students have liked each other. The result of this query is stored in the mutual_like_count variable. The function then evaluates the value of mutual_like_count using a series of conditional statements. If mutual_like_count is greater than 5, the function returns the text 'Strong mutual likes'. If mutual_like_count is greater than 0 but less than or equal to 5, the function returns the text 'Some mutual likes'. If mutual_like_count is 0, the function returns the text 'No mutual likes'. The function is implemented in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION mutual_like_analysis(p_student_id integer)\nRETURNS text AS $$\nDECLARE\n    mutual_like_count integer;\nBEGIN\n    SELECT COUNT(*) INTO mutual_like_count FROM \"Likes\" l1\n    JOIN \"Likes\" l2 ON l1.liked_id = l2.student_id\n    WHERE l1.student_id = p_student_id AND l2.liked_id = p_student_id;\n\n    IF mutual_like_count > 5 THEN\n        RETURN 'Strong mutual likes';\n    ELSIF mutual_like_count > 0 THEN\n        RETURN 'Some mutual likes';\n    ELSE\n        RETURN 'No mutual likes';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT mutual_like_analysis(1510);",
      "SELECT mutual_like_analysis(1689);",
      "SELECT mutual_like_analysis(1381);",
      "SELECT mutual_like_analysis(1709);",
      "SELECT mutual_like_analysis(1782);"
    ],
    "summary": "Create a PLpgSQL function that takes a student ID and returns a text description of their mutual likes level. It counts how many mutual likes (where two students like each other) the student has in the Likes table. Return 'Strong mutual likes' if count > 5, 'Some mutual likes' if count is between 1 and 5, or 'No mutual likes' if count is 0.",
    "natural_language": "Write a PLpgSQL function that, given a student's ID, gives back a text summary about their mutual likes situation. It should figure out the approximate number of mutual likes (where two students are into each other) for that student from the Likes table. If the number seems pretty high, say more than a handful, return 'Strong mutual likes'. If there are a few, maybe between one and a small number, return 'Some mutual likes'. If there aren't really any, return 'No mutual likes'.",
    "id": 292
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named find_top_volume_song that accepts two input parameters: an integer parameter p_artist_id representing a specific artist identifier and a real number parameter p_weeks_threshold representing a minimum number of weeks. The function returns a single text value. The function's logic executes a SELECT query on the table named volume, retrieving data from the column named Song. The query filters rows where the column Artist_ID exactly matches the provided p_artist_id parameter and where the column Weeks_on_Top contains a value strictly greater than the provided p_weeks_threshold parameter. From the resulting filtered set of rows, the query orders all entries in descending order based on the values in the Weeks_on_Top column, placing the row with the highest number of weeks at the top. The query then limits the result set to only the first row using the LIMIT 1 clause. The value from the Song column of this single top-ranked row is assigned to the local variable top_song. The function concludes by returning the value stored in the top_song variable, which is the name of the song with the highest Weeks_on_Top value for the specified artist that also exceeds the specified weeks threshold.",
    "plsql": "CREATE OR REPLACE FUNCTION find_top_volume_song(p_artist_id integer, p_weeks_threshold real)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    top_song text;\nBEGIN\n    SELECT \"Song\" INTO top_song\n    FROM volume\n    WHERE \"Artist_ID\" = p_artist_id AND \"Weeks_on_Top\" > p_weeks_threshold\n    ORDER BY \"Weeks_on_Top\" DESC\n    LIMIT 1;\n\n    RETURN top_song;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT find_top_volume_song(1, 2.5);",
      "SELECT find_top_volume_song(2, 0.5);",
      "SELECT find_top_volume_song(1, 1.0);",
      "SELECT find_top_volume_song(2, 1.5);",
      "SELECT find_top_volume_song(1, 0.0);"
    ],
    "summary": "Create a PLpgSQL function named find_top_volume_song that takes an artist ID and a weeks threshold. It returns the name of the song from the volume table for that artist with the highest Weeks_on_Top value, but only if that value exceeds the provided threshold.",
    "natural_language": "Find the song with the highest Weeks_on_Top value for a given artist, but only if that value exceeds a specified threshold. Return the song name from the volume table.",
    "id": 293
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the total outstanding balance for all customers in the \"Customers\" table who have a customer_status_code equal to 'Good Customer'. The function is named get_total_outstanding_balance and does not take any input parameters. It returns a value of type double precision. Inside the function, a variable named total_balance of type double precision is declared to store the result of the calculation. The function executes a SELECT statement that computes the sum of the values in the amount_outstanding column from the public.\"Customers\" table, but only for rows where the customer_status_code column has the value 'Good Customer'. The result of this aggregation is assigned to the total_balance variable using the INTO clause. Finally, the function returns the value stored in total_balance.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_outstanding_balance()\nRETURNS double precision AS $$\nDECLARE\n    total_balance double precision;\nBEGIN\n    SELECT SUM(amount_outstanding)\n    INTO total_balance\n    FROM public.\"Customers\"\n    WHERE customer_status_code = 'Good Customer';\n    RETURN total_balance;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT get_total_outstanding_balance();",
      "SELECT * FROM get_total_outstanding_balance();",
      "SELECT get_total_outstanding_balance() AS total_good_customer_balance;",
      "DO $$\nDECLARE\n    total double precision;\nBEGIN\n    total := get_total_outstanding_balance();\n    RAISE NOTICE 'Total outstanding balance for good customers: %', total;\nEND $$;",
      "SELECT get_total_outstanding_balance()\nFROM (VALUES (1)) AS t;"
    ],
    "summary": "Create a PLpgSQL function named get_total_outstanding_balance with no parameters. It returns a double precision value representing the sum of the amount_outstanding column from the Customers table for all rows where customer_status_code is 'Good Customer'.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_total_outstanding_balance'. This function shall accept no parameters and must yield a value of type double precision. The returned value should constitute the aggregate sum of the 'amount_outstanding' column, sourced from the 'Customers' table, specifically for those records where the 'customer_status_code' is equivalent to 'Good Customer'.",
    "id": 294
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_recent_payment_customer` that takes no input parameters. This function is designed to return a single `text` value representing the full name of the customer associated with the most recent payment recorded in the database. The function begins by declaring a local variable named `customer_name` of type `text` to temporarily store the retrieved customer's full name. The core operation involves a `SELECT` statement that constructs the full name by concatenating the `first_name` and `last_name` columns from the `\"Customers\"` table, separated by a space. This concatenated string is then assigned to the `customer_name` variable using the `INTO` clause. The selection of the customer is determined by joining the `\"Customers\"` table, aliased as `c`, with the `\"Customer_Payments\"` table, aliased as `cp`. The join condition `c.customer_id = cp.customer_id` links customers to their respective payments based on a matching `customer_id`. A `WHERE` clause further filters these joined records to identify the payment that occurred most recently. This is achieved by comparing the `datetime_payment` column from the `cp` alias (representing the `\"Customer_Payments\"` table) with the maximum `datetime_payment` found across all records in the `\"Customer_Payments\"` table. The maximum `datetime_payment` is determined by a subquery `SELECT MAX(datetime_payment) FROM \"Customer_Payments\"`. After successfully retrieving and assigning the customer's full name to the `customer_name` variable, the function concludes by returning the value stored in `customer_name`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_payment_customer()\nRETURNS text AS $$\nDECLARE\n    customer_name text;\nBEGIN\n    SELECT CONCAT(c.first_name, ' ', c.last_name)\n    INTO customer_name\n    FROM \"Customers\" c\n    JOIN \"Customer_Payments\" cp ON c.customer_id = cp.customer_id\n    WHERE cp.datetime_payment = (\n        SELECT MAX(datetime_payment) FROM \"Customer_Payments\"\n    );\n    RETURN customer_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT get_recent_payment_customer();"
    ],
    "summary": "Create a PL/pgSQL function named `get_recent_payment_customer` with no parameters that returns a text value. The function should return the full name (first_name and last_name concatenated with a space) of the customer associated with the most recent payment, based on the maximum datetime_payment.",
    "natural_language": "What is the full name of the customer linked to the most recent payment, based on the latest datetime_payment?",
    "id": 295
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_customer_count_by_city that takes no input parameters and returns a single integer value, which performs a query to count customers located in a specific city by first declaring a local integer variable named customer_count, then executing a SELECT statement that retrieves the count of all rows from a join between the Customers table (aliased as c) and the Addresses table (aliased as a) using the join condition that the customer_address_id column from the Customers table matches the address_id column from the Addresses table, applying a filter condition in the WHERE clause that uses the LOWER function to convert the city column from the Addresses table to lowercase and compares it to the lowercase string literal 'port melyssa', storing the resulting count value into the declared customer_count variable, and finally returning the value stored in the customer_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_count_by_city()\nRETURNS integer AS $$\nDECLARE\n    customer_count integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO customer_count\n    FROM \"Customers\" c\n    JOIN \"Addresses\" a ON c.customer_address_id = a.address_id\n    WHERE LOWER(a.city) = 'port melyssa';\n    RETURN customer_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT get_customer_count_by_city();"
    ],
    "summary": "Create a PL/pgSQL function named `get_customer_count_by_city` with no parameters that returns an integer. The function should count customers whose associated address has a city (case-insensitive comparison) equal to 'port melyssa'.",
    "natural_language": "Write a PL/pgSQL function `get_customer_count_by_city` (no parameters, returns integer) to count customers with address city 'port melyssa' (case-insensitive).",
    "id": 296
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_highest_payment_customer that takes no input parameters and returns a single text value, which is designed to retrieve the full name of the customer who has made the highest individual payment amount recorded in the database. The function begins by declaring a local variable `customer_name` of type text to hold the result. It then executes a SELECT statement that performs a join between the \"Customers\" table (aliased as `c`) and the \"Customer_Payments\" table (aliased as `cp`) using the condition `c.customer_id = cp.customer_id` to link customer records with their corresponding payment records. Within this query, a scalar subquery `(SELECT MAX(amount_payment) FROM \"Customer_Payments\")` is used in the WHERE clause to find the maximum value present in the `amount_payment` column of the \"Customer_Payments\" table, and the main query filters the joined result to only include rows where `cp.amount_payment` equals this maximum value. For the resulting row, the CONCAT function is applied to combine the `first_name` column from the \"Customers\" table, a literal space character, and the `last_name` column from the same table, forming a full name string, and this concatenated value is assigned into the `customer_name` variable. The function concludes by returning the content of the `customer_name` variable, which will be the full name of the customer associated with the highest payment; if the subquery finds multiple payments tied for the maximum amount and these payments belong to different customers, the function will return the name from one of those matching rows, but the exact row is non-deterministic without an ORDER BY clause.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_payment_customer()\nRETURNS text AS $$\nDECLARE\n    customer_name text;\nBEGIN\n    SELECT CONCAT(c.first_name, ' ', c.last_name)\n    INTO customer_name\n    FROM \"Customers\" c\n    JOIN \"Customer_Payments\" cp ON c.customer_id = cp.customer_id\n    WHERE cp.amount_payment = (\n        SELECT MAX(amount_payment) FROM \"Customer_Payments\"\n    );\n    RETURN customer_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT get_highest_payment_customer();",
      "SELECT * FROM get_highest_payment_customer();",
      "SELECT get_highest_payment_customer() AS highest_paying_customer;",
      "DO $$\nDECLARE\n    result text;\nBEGIN\n    result := get_highest_payment_customer();\n    RAISE NOTICE 'Highest paying customer: %', result;\nEND $$;",
      "WITH customer_info AS (\n    SELECT get_highest_payment_customer() AS customer_name\n)\nSELECT customer_name FROM customer_info;"
    ],
    "summary": "Create a PL/pgSQL function named `get_highest_payment_customer` with no parameters that returns a text value. The function should return the full name (first_name and last_name concatenated with a space) of the customer associated with the payment having the maximum amount_payment.",
    "natural_language": "What is the full name (first and last name combined with a space) of the customer linked to the payment with the highest amount, and can you provide it as a PL/pgSQL function called `get_highest_payment_customer` that takes no parameters and returns a text value?",
    "id": 297
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the average value of the amount_outstanding column from the Customers table, but only for rows where the customer_status_code column equals 'Good Customer'. The function is named get_average_outstanding_balance and has no input parameters. It declares a local variable avg_balance of type double precision to store the result of the calculation. Within the function body, a SELECT statement is executed to compute the average of the amount_outstanding column using the AVG aggregate function. The result of this calculation is stored into the avg_balance variable using the INTO clause. The SELECT statement filters rows by applying a WHERE condition that checks if the customer_status_code column has the value 'Good Customer'. After the SELECT statement completes, the function returns the value stored in the avg_balance variable as the output. The function is implemented in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_outstanding_balance()\nRETURNS double precision AS $$\nDECLARE\n    avg_balance double precision;\nBEGIN\n    SELECT AVG(amount_outstanding)\n    INTO avg_balance\n    FROM \"Customers\"\n    WHERE customer_status_code = 'Good Customer';\n    RETURN avg_balance;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT get_average_outstanding_balance();"
    ],
    "summary": "Create a PL/pgSQL function named `get_average_outstanding_balance` with no parameters that returns a double precision value. The function should calculate and return the average amount_outstanding for customers where customer_status_code equals 'Good Customer'.",
    "natural_language": "Please construct a PL/pgSQL function, designated as `get_average_outstanding_balance`, which accepts no parameters and yields a value of type double precision. This function must compute and return the mean value of the `amount_outstanding` column, specifically for those customer records where the `customer_status_code` is set to 'Good Customer'.",
    "id": 298
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_players_and_schools_by_location` that accepts a single input parameter, `location_name`, of type `TEXT`. This function is designed to return a `REFCURSOR`, which is a pointer to a result set, allowing the calling environment to fetch rows iteratively. Inside the function, a local variable named `result_set` is declared, also of type `REFCURSOR`, to hold the reference to the query's output. The core operation of the function involves opening this `result_set` by executing a `SELECT` statement. This `SELECT` statement retrieves specific columns from two tables: `player` and `school`. From the `player` table, it selects the columns `\"Player_ID\"`, `\"Player\"`, `\"Team\"`, `\"Age\"`, and `\"Position\"`. From the `school` table, it selects the columns `\"School\"` and `\"Location\"`. These two tables, `player` and `school`, are joined together using an `INNER JOIN` operation. The join condition specifies that rows from `player` and `school` are matched when the value in the `player` table's `\"School_ID\"` column is equal to the value in the `school` table's `\"School_ID\"` column. Furthermore, a `WHERE` clause is applied to filter the joined results. This `WHERE` clause ensures that only rows where the value in the `school` table's `\"Location\"` column exactly matches the value provided in the `location_name` input parameter are included in the final result set. After the `result_set` is populated with the filtered and joined data, the function then returns this `result_set` to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION get_players_and_schools_by_location(location_name TEXT)\nRETURNS REFCURSOR\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    result_set REFCURSOR;\nBEGIN\n    OPEN result_set FOR\n    SELECT player.\"Player_ID\", player.\"Player\", player.\"Team\", player.\"Age\", player.\"Position\", school.\"School\", school.\"Location\"\n    FROM player\n    JOIN school ON player.\"School_ID\" = school.\"School_ID\"\n    WHERE school.\"Location\" = location_name;\n    \n    RETURN result_set;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school"
    ],
    "call_sqls": [
      "SELECT get_players_and_schools_by_location('Milsons Point');",
      "SELECT get_players_and_schools_by_location('Hornsby');",
      "SELECT get_players_and_schools_by_location('Bellevue Hill');",
      "SELECT get_players_and_schools_by_location('Sydney');",
      "SELECT get_players_and_schools_by_location('Melbourne');"
    ],
    "summary": "Create a PL/pgSQL function named `get_players_and_schools_by_location` that accepts a TEXT parameter `location_name` and returns a REFCURSOR. The function should open a cursor for a query that selects player and school details by joining the player and school tables where their School_IDs match and the school's Location matches the input parameter.",
    "natural_language": "Write a PL/pgSQL function called `get_players_and_schools_by_location` that takes a TEXT parameter `location_name` and returns a REFCURSOR. The function must open a cursor for a query joining the player and school tables on matching School_IDs and filtering for schools where the Location equals the provided parameter.",
    "id": 299
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter school_id of type INTEGER and returns a REFCURSOR containing aggregated statistics for a specific school. The function begins by declaring a local variable result_set of type REFCURSOR to hold the query result. It then opens the result_set cursor for a SELECT query that retrieves detailed information about the school with the specified school_id. The query accesses the school table to fetch the columns \"School\" (name of the school), \"Location\" (geographical location of the school), \"Enrollment\" (number of students enrolled), \"Founded\" (year the school was established), and \"Denomination\" (religious or organizational affiliation of the school). Additionally, the query performs a LEFT JOIN operation with the player table using the condition school.\"School_ID\" = player.\"School_ID\" to include data about players associated with the school. The LEFT JOIN ensures that schools without any associated players are still included in the result. The query calculates the total number of players for the school by using the COUNT function on the \"Player_ID\" column from the player table. The WHERE clause filters the results to include only the school whose \"School_ID\" matches the input parameter school_id. The GROUP BY clause is used to group the results by the columns \"School\", \"Location\", \"Enrollment\", \"Founded\", and \"Denomination\" to ensure accurate aggregation of the player count. Finally, the function returns the result_set cursor containing the aggregated data.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_statistics(school_id INTEGER)\nRETURNS REFCURSOR\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    result_set REFCURSOR;\nBEGIN\n    OPEN result_set FOR\n    SELECT school.\"School\", school.\"Location\", school.\"Enrollment\", school.\"Founded\", school.\"Denomination\", COUNT(player.\"Player_ID\") AS total_players\n    FROM school\n    LEFT JOIN player ON school.\"School_ID\" = player.\"School_ID\"\n    WHERE school.\"School_ID\" = school_id\n    GROUP BY school.\"School\", school.\"Location\", school.\"Enrollment\", school.\"Founded\", school.\"Denomination\";\n\n    RETURN result_set;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school"
    ],
    "call_sqls": [
      "SELECT get_school_statistics(1);",
      "SELECT get_school_statistics(2);",
      "SELECT get_school_statistics(3);",
      "SELECT get_school_statistics(4);",
      "SELECT get_school_statistics(5);"
    ],
    "summary": "Create a PL/pgSQL function that takes a school_id integer and returns a REFCURSOR. The cursor should contain the school's name, location, enrollment, founding year, and denomination, along with the total count of associated players from a LEFT JOIN with the player table, grouped by the school details.",
    "natural_language": "How can I create a PL/pgSQL function that, given a school_id integer, returns a REFCURSOR containing the school's name, location, enrollment, founding year, and denomination, as well as the total count of associated players from a LEFT JOIN with the player table, grouped by those school details?",
    "id": 300
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_master_customer_id that takes no input parameters and returns a numeric value. The function declares a local numeric variable named avg_master_customer_id. The function's logic executes a single SQL SELECT statement that calculates the average value of the master_customer_id column from the public.\"CMI_Cross_References\" table. This calculation is performed only on a filtered subset of rows from the CMI_Cross_References table, specifically those rows where the cmi_cross_ref_id column value is present in the result set of a nested subquery. The subquery selects all cmi_cross_ref_id values from the public.\"Business_Rates\" table. The computed average value is stored into the local variable avg_master_customer_id using the INTO clause. Finally, the function returns the value stored in the avg_master_customer_id variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_master_customer_id()\nRETURNS numeric AS $$\nDECLARE\n    avg_master_customer_id numeric;\nBEGIN\n    SELECT AVG(master_customer_id)\n    INTO avg_master_customer_id\n    FROM public.\"CMI_Cross_References\"\n    WHERE cmi_cross_ref_id IN (SELECT cmi_cross_ref_id FROM public.\"Business_Rates\");\n    RETURN avg_master_customer_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Business_Rates",
      "CMI_Cross_References"
    ],
    "call_sqls": [
      "SELECT calculate_average_master_customer_id();",
      "SELECT * FROM calculate_average_master_customer_id();",
      "SELECT calculate_average_master_customer_id() AS average_master_customer_id;",
      "DO $$\nDECLARE\n    result numeric;\nBEGIN\n    result := calculate_average_master_customer_id();\n    RAISE NOTICE 'Average master customer ID: %', result;\nEND $$;",
      "WITH avg_result AS (\n    SELECT calculate_average_master_customer_id() AS avg_value\n)\nSELECT avg_value FROM avg_result;"
    ],
    "summary": "Create a PL/pgSQL function named calculate_average_master_customer_id with no parameters that returns a numeric value. It should calculate and return the average of the master_customer_id from the CMI_Cross_References table, but only for rows where the cmi_cross_ref_id is present in the Business_Rates table.",
    "natural_language": "Write a function called calculate_average_master_customer_id that gives back a number. It should figure out the typical master_customer_id from the CMI_Cross_References table, but only for those entries that are also listed somewhere in the Business_Rates table.",
    "id": 301
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the total sum of the values in the business_rates_id column from the Business_Rates table, but only for rows where the cmi_cross_ref_id column matches any value in the cmi_cross_ref_id column of the CMI_Cross_References table. The function does not take any input parameters and returns a single bigint value. Inside the function, a local variable named total_business_rates of type bigint is declared to store the result of the calculation. The function performs a SELECT statement with a SUM aggregate function on the business_rates_id column from the Business_Rates table, applying a WHERE clause to filter rows based on the cmi_cross_ref_id column. The filtering condition uses a subquery that retrieves all cmi_cross_ref_id values from the CMI_Cross_References table. The result of the SUM operation is assigned to the total_business_rates variable using the INTO clause. Finally, the function returns the value stored in total_business_rates.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_business_rates()\nRETURNS bigint AS $$\nDECLARE\n    total_business_rates bigint;\nBEGIN\n    SELECT SUM(business_rates_id)\n    INTO total_business_rates\n    FROM public.\"Business_Rates\"\n    WHERE cmi_cross_ref_id IN (SELECT cmi_cross_ref_id FROM public.\"CMI_Cross_References\");\n    RETURN total_business_rates;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Business_Rates",
      "CMI_Cross_References"
    ],
    "call_sqls": [
      "SELECT calculate_total_business_rates();",
      "SELECT * FROM calculate_total_business_rates();",
      "SELECT calculate_total_business_rates() AS total_business_rates;",
      "DO $$\nDECLARE\n    result bigint;\nBEGIN\n    result := calculate_total_business_rates();\n    RAISE NOTICE 'Total Business Rates: %', result;\nEND $$;",
      "WITH total AS (SELECT calculate_total_business_rates() AS total_value)\nSELECT total_value FROM total;"
    ],
    "summary": "Create a PL/pgSQL function with no parameters that returns a bigint. It should calculate and return the total sum of the business_rates_id column from the Business_Rates table, but only for rows where the cmi_cross_ref_id exists in the CMI_Cross_References table.",
    "natural_language": "Calculate and return the total sum of the business_rates_id column from the Business_Rates table, but only for rows where the cmi_cross_ref_id exists in the CMI_Cross_References table. Implement this as a PL/pgSQL function with no parameters that returns a bigint.",
    "id": 302
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_teacher_name` that accepts a single input parameter, `p_classroom`, which is of type `bigint`. This function is designed to retrieve the first name and last name of a teacher associated with a specific classroom and then concatenate them into a single text string. The function declares two local variables: `v_lastname` of type `text` and `v_firstname` of type `text`. The first operation performed is an assignment to `v_lastname`. This assignment is the result of a `SELECT` statement that queries the `teachers` table. Specifically, it selects the value from the `\"LastName\"` column where the `\"Classroom\"` column matches the value provided in the `p_classroom` input parameter. The second operation is an assignment to `v_firstname`. This assignment is also the result of a `SELECT` statement that queries the `teachers` table. It selects the value from the `\"FirstName\"` column where the `\"Classroom\"` column again matches the value provided in the `p_classroom` input parameter. Finally, the function returns a `text` value which is the concatenation of the `v_lastname` variable and the `v_firstname` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_name(p_classroom bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lastname text;\n    v_firstname text;\nBEGIN\n    v_lastname := (SELECT \"LastName\" FROM teachers WHERE \"Classroom\" = p_classroom);\n    v_firstname := (SELECT \"FirstName\" FROM teachers WHERE \"Classroom\" = p_classroom);\n    RETURN v_lastname || v_firstname;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT get_teacher_name(101);",
      "SELECT get_teacher_name(102);",
      "SELECT get_teacher_name(103);",
      "SELECT get_teacher_name(112);",
      "SELECT get_teacher_name(107);"
    ],
    "summary": "Create a PL/pgSQL function named get_teacher_name that takes a p_classroom bigint parameter. It should retrieve the first and last name of the teacher from the teachers table for the given classroom and return them as a single concatenated text string.",
    "natural_language": "Write a function called get_teacher_name that uses a classroom number. It should find the teacher for that room and give back their full name, pulling from the teachers list.",
    "id": 303
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_grade_stats` that accepts a single input parameter named `p_classroom` of data type `bigint`. This function is designed to compute and return a `numeric` value. Upon execution, the function first declares two local variables: `v_avg_grade` of data type `numeric` and `v_min_grade` of data type `bigint`. The function then proceeds to perform two separate `SELECT` operations. The first `SELECT` statement calculates the average of the values in the `\"Grade\"` column from the table named `list`, specifically for rows where the value in the `\"Classroom\"` column is equal to the value provided in the `p_classroom` input parameter. The result of this average calculation is assigned to the local variable `v_avg_grade`. The second `SELECT` statement calculates the minimum value in the `\"Grade\"` column from the table named `list`, again specifically for rows where the value in the `\"Classroom\"` column is equal to the value provided in the `p_classroom` input parameter. The result of this minimum calculation is assigned to the local variable `v_min_grade`. Finally, the function returns the sum of the values stored in `v_avg_grade` and `v_min_grade`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_grade_stats(p_classroom bigint)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_grade numeric;\n    v_min_grade bigint;\nBEGIN\n    v_avg_grade := (SELECT AVG(\"Grade\") FROM list WHERE \"Classroom\" = p_classroom);\n    v_min_grade := (SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = p_classroom);\n    RETURN v_avg_grade + v_min_grade;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT calculate_grade_stats(101);",
      "SELECT calculate_grade_stats(112);",
      "SELECT calculate_grade_stats(107);",
      "SELECT calculate_grade_stats(102);",
      "SELECT calculate_grade_stats(103);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_grade_stats` that takes a `bigint` parameter `p_classroom`. It calculates the average and minimum `\"Grade\"` from the `list` table for that classroom, storing them in local variables. The function returns the sum of the average and minimum grade.",
    "natural_language": "Write a PL/pgSQL function called `calculate_grade_stats` that accepts a `bigint` parameter `p_classroom`. Compute the average and minimum `\"Grade\"` from the `list` table for the specified classroom, storing the results in local variables. Then, return the sum of the computed average and minimum grade.",
    "id": 304
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_lastname of type text, retrieves the \"FirstName\" and \"Classroom\" values from the \"list\" table for the row where the \"LastName\" column matches the value of p_lastname, and returns a concatenated string consisting of the retrieved \"FirstName\" value, followed by the string ' - Room ', and then the retrieved \"Classroom\" value. The function begins by declaring two local variables, v_firstname of type text and v_classroom of type bigint, to store the retrieved values. It then assigns to v_firstname the result of a SELECT query that retrieves the \"FirstName\" column from the \"list\" table where the \"LastName\" column equals the input parameter p_lastname. Similarly, it assigns to v_classroom the result of a SELECT query that retrieves the \"Classroom\" column from the \"list\" table where the \"LastName\" column equals the input parameter p_lastname. Finally, the function concatenates the values of v_firstname, the string ' - Room ', and v_classroom, and returns the resulting string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_info(p_lastname text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_firstname text;\n    v_classroom bigint;\nBEGIN\n    v_firstname := (SELECT \"FirstName\" FROM list WHERE \"LastName\" = p_lastname);\n    v_classroom := (SELECT \"Classroom\" FROM list WHERE \"LastName\" = p_lastname);\n    RETURN v_firstname || ' - Room ' || v_classroom;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT get_student_info('CAR');",
      "SELECT get_student_info('KRISTENSEN');",
      "SELECT get_student_info('VANDERWOUDE');",
      "SELECT get_student_info('MACROSTIE');",
      "SELECT get_student_info('MOYER');"
    ],
    "summary": "Create a PL/pgSQL function that takes a `text` parameter `p_lastname`. It retrieves the `\"FirstName\"` and `\"Classroom\"` from the `list` table where `\"LastName\"` matches the parameter. The function returns a concatenated string in the format: `FirstName - Room Classroom`.",
    "natural_language": "How can I create a PL/pgSQL function that, given a last name as a text parameter, fetches the first name and classroom from the list table for matching records and returns them formatted as 'FirstName - Room Classroom'?",
    "id": 305
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_classroom of type bigint, representing the identifier of a classroom, and calculates a value based on the number of students and their total grades in that classroom. The function begins by declaring two local variables: v_student_count of type bigint, which will store the count of students in the specified classroom, and v_grade_sum of type bigint, which will store the sum of grades for all students in the same classroom. It then assigns to v_student_count the result of a SELECT COUNT(*) query on the list table, where the \"Classroom\" column matches the value of the input parameter p_classroom. Next, it assigns to v_grade_sum the result of a SELECT SUM(\"Grade\") query on the same table, again filtering rows where the \"Classroom\" column equals p_classroom. Finally, the function returns the product of v_student_count and v_grade_sum as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION compute_class_total(p_classroom bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_count bigint;\n    v_grade_sum bigint;\nBEGIN\n    v_student_count := (SELECT COUNT(*) FROM list WHERE \"Classroom\" = p_classroom);\n    v_grade_sum := (SELECT SUM(\"Grade\") FROM list WHERE \"Classroom\" = p_classroom);\n    RETURN v_student_count * v_grade_sum;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT compute_class_total(101);",
      "SELECT compute_class_total(112);",
      "SELECT compute_class_total(107);",
      "SELECT compute_class_total(102);",
      "SELECT compute_class_total(103);"
    ],
    "summary": "Create a PL/pgSQL function that takes a `bigint` parameter `p_classroom`. It calculates the count of students and the sum of their `\"Grade\"` values from the `list` table for that classroom. The function returns the product of the student count and the total grade sum.",
    "natural_language": "Please construct a PL/pgSQL function that accepts a parameter `p_classroom` of type `bigint`. This function shall compute both the number of students and the aggregate sum of their `\"Grade\"` values from the `list` table, specifically for the provided classroom identifier. The function is then to return the mathematical product of the aforementioned student count and the total grade sum.",
    "id": 306
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named find_teacher_classroom that accepts a single input parameter p_lastname of type text, which is intended to represent a teacher's last name, and returns a value of type bigint. The function begins by declaring two local variables: v_classroom of type bigint to store the result, and v_firstname of type text. The function's logic executes two separate SELECT queries sequentially against the teachers table. The first query retrieves the value from the \"Classroom\" column for the row where the \"LastName\" column exactly matches the provided p_lastname parameter value, and assigns this retrieved value to the v_classroom variable. The second query retrieves the value from the \"FirstName\" column for the row where the \"LastName\" column again exactly matches the provided p_lastname parameter, and assigns this retrieved value to the v_firstname variable. The function concludes by returning the value stored in the v_classroom variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION find_teacher_classroom(p_lastname text)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_classroom bigint;\n    v_firstname text;\nBEGIN\n    v_classroom := (SELECT \"Classroom\" FROM teachers WHERE \"LastName\" = p_lastname);\n    v_firstname := (SELECT \"FirstName\" FROM teachers WHERE \"LastName\" = p_lastname);\n    RETURN v_classroom;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT find_teacher_classroom('MACROSTIE');",
      "SELECT find_teacher_classroom('COVIN');",
      "SELECT find_teacher_classroom('MOYER');",
      "SELECT find_teacher_classroom('CAR');",
      "SELECT find_teacher_classroom('KRISTENSEN');"
    ],
    "summary": "Create a PL/pgSQL function named `find_teacher_classroom` that takes a `text` parameter `p_lastname`. It retrieves the `\"Classroom\"` and `\"FirstName\"` from the `teachers` table where `\"LastName\"` matches the parameter. The function returns the `\"Classroom\"` value as a `bigint`.",
    "natural_language": "Develop a PL/pgSQL function, which should be named `find_teacher_classroom`, that accepts a single input parameter of type `text` called `p_lastname`. This function is designed to carefully retrieve and return the specific `\"Classroom\"` number, formatted as a `bigint`, along with the associated `\"FirstName\"`, by querying the `teachers` table precisely where the `\"LastName\"` column matches the provided parameter value.",
    "id": 307
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_wedding_church_name` that accepts three input parameters: `p_male_id` of type `integer`, representing the unique identifier for the male participant in a wedding; `p_female_id` of type `integer`, representing the unique identifier for the female participant in a wedding; and `p_year` of type `integer`, representing the year in which the wedding took place. This function is designed to return a single value of type `text`, which will be the name of the church where a specific wedding occurred. The function's core operation involves executing a `SELECT` statement to retrieve data. Specifically, it selects the value from the `\"Name\"` column of the `church` table. This selection is performed by joining the `church` table (aliased as `c`) with the `wedding` table (aliased as `w`). The join condition establishes a link between these two tables where the value in the `\"Church_ID\"` column of the `church` table is equal to the value in the `\"Church_ID\"` column of the `wedding` table. Furthermore, the `SELECT` statement includes a `WHERE` clause to filter the results. This `WHERE` clause specifies three conditions that must all be met for a row to be included in the result set: first, the value in the `\"Male_ID\"` column of the `wedding` table must be equal to the `p_male_id` input parameter; second, the value in the `\"Female_ID\"` column of the `wedding` table must be equal to the `p_female_id` input parameter; and third, the value in the `\"Year\"` column of the `wedding` table must be equal to the `p_year` input parameter. The function then returns the single `text` value obtained from this `SELECT` query.",
    "plsql": "CREATE OR REPLACE FUNCTION get_wedding_church_name(p_male_id integer, p_female_id integer, p_year integer)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT c.\"Name\" FROM church c JOIN wedding w ON c.\"Church_ID\" = w.\"Church_ID\" WHERE w.\"Male_ID\" = p_male_id AND w.\"Female_ID\" = p_female_id AND w.\"Year\" = p_year);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_wedding_church_name(1, 2, 2014);",
      "SELECT get_wedding_church_name(3, 4, 2015);",
      "SELECT get_wedding_church_name(5, 6, 2016);",
      "SELECT get_wedding_church_name(7, 8, 2017);",
      "SELECT get_wedding_church_name(9, 10, 2018);"
    ],
    "summary": "Create a PL/pgSQL function named `get_wedding_church_name` that takes three `integer` parameters: `p_male_id`, `p_female_id`, and `p_year`. It retrieves the church `\"Name\"` by joining the `wedding` and `church` tables on `\"Church_ID\"`, where the wedding's `\"Male_ID\"`, `\"Female_ID\"`, and `\"Year\"` match the input parameters. The function returns the church name as `text`.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_wedding_church_name`. This function shall accept three integer parameters: `p_male_id`, `p_female_id`, and `p_year`. Its purpose is to retrieve the `\"Name\"` of a church by performing an inner join between the `wedding` and `church` tables, utilizing the `\"Church_ID\"` column as the join condition. The selection must be constrained to records where the wedding's `\"Male_ID\"`, `\"Female_ID\"`, and `\"Year\"` correspond precisely to the provided input parameters. The function is to return the church name as a text data type.",
    "id": 308
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named count_church_weddings_by_organizer that returns an integer value, which accepts three input parameters: a text parameter named p_organizer used to search for a substring within a specific column, an integer parameter named p_min_year representing the lower bound of a year range, and an integer parameter named p_max_year representing the upper bound of a year range, and whose body executes a single SQL SELECT statement that performs a COUNT(*) aggregation on the result of an inner join between a table named wedding (aliased as w) and a table named church (aliased as c) based on the equality condition of the wedding table's \"Church_ID\" column and the church table's \"Church_ID\" column, where the join result is filtered by a condition that uses the strpos function to check if the text value in the church table's \"Organized_by\" column contains the p_organizer parameter value as a substring (specifically where the strpos result is greater than 0), and also filtered by a condition that the wedding table's \"Year\" column value must be between the p_min_year and p_max_year parameters inclusive, and finally returns the computed count integer as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION count_church_weddings_by_organizer(p_organizer text, p_min_year integer, p_max_year integer)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM wedding w JOIN church c ON w.\"Church_ID\" = c.\"Church_ID\" WHERE strpos(c.\"Organized_by\", p_organizer) > 0 AND w.\"Year\" BETWEEN p_min_year AND p_max_year);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT count_church_weddings_by_organizer('Wycam Clark', 2010, 2020);",
      "SELECT count_church_weddings_by_organizer('Ezra Booth', 2014, 2016);",
      "SELECT count_church_weddings_by_organizer('– Hoton', 2000, 2015);",
      "SELECT count_church_weddings_by_organizer('Wycam Clark', 1990, 2000);",
      "SELECT count_church_weddings_by_organizer('Ezra Booth', 2010, 2025);"
    ],
    "summary": "Create a PL/pgSQL function named `count_church_weddings_by_organizer` that returns an integer count of weddings. It counts weddings from the \"wedding\" table joined with the \"church\" table where the church's \"Organized_by\" column contains a specified substring and the wedding year is within a given inclusive range.",
    "natural_language": "Please construct a PL/pgSQL function, designated as `count_church_weddings_by_organizer`, which shall return an integer value representing a count of weddings. This function must ascertain the count from the \"wedding\" table, joined with the \"church\" table, under the conditions that the \"Organized_by\" column of the church contains a provided substring and the year of the wedding falls within a specified inclusive range.",
    "id": 309
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, p_catalog_id of type bigint and p_attribute_id of type bigint, and returns an integer representing the count of distinct catalog entries. The function begins by declaring a local variable v_count of type integer to store the result of the count operation. It then performs a SELECT query to count the number of distinct catalog_entry_id values from the \"Catalog_Contents\" table, which is aliased as cc. This table is joined with the \"Catalog_Structure\" table, aliased as cs, using the catalog_level_number column from both tables to establish the relationship. Additionally, the \"Catalog_Contents_Additional_Attributes\" table, aliased as ccaa, is joined using the catalog_entry_id column from both the \"Catalog_Contents\" and \"Catalog_Contents_Additional_Attributes\" tables. The WHERE clause of the query filters the results to include only those rows where the catalog_id in the \"Catalog_Structure\" table matches the p_catalog_id parameter and the attribute_id in the \"Catalog_Contents_Additional_Attributes\" table matches the p_attribute_id parameter. The result of the COUNT operation is stored in the v_count variable, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION count_entries_by_attribute(p_catalog_id bigint, p_attribute_id bigint)\nRETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(DISTINCT cc.catalog_entry_id) INTO v_count FROM \"Catalog_Contents\" cc JOIN \"Catalog_Structure\" cs ON cc.catalog_level_number = cs.catalog_level_number JOIN \"Catalog_Contents_Additional_Attributes\" ccaa ON cc.catalog_entry_id = ccaa.catalog_entry_id WHERE cs.catalog_id = p_catalog_id AND ccaa.attribute_id = p_attribute_id;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "SELECT count_entries_by_attribute(1, 1);",
      "SELECT count_entries_by_attribute(2, 2);",
      "SELECT count_entries_by_attribute(3, 3);",
      "SELECT count_entries_by_attribute(1, 2);",
      "SELECT count_entries_by_attribute(2, 3);"
    ],
    "summary": "Create a PL/pgSQL function that takes a catalog_id and an attribute_id (both bigint) and returns an integer count of distinct catalog_entry_id values. The count is derived from joining Catalog_Contents, Catalog_Structure (on catalog_level_number), and Catalog_Contents_Additional_Attributes (on catalog_entry_id), filtered by the provided catalog_id and attribute_id.",
    "natural_language": "How many distinct catalog entries are there for a given catalog and attribute, based on a join of the Catalog_Contents, Catalog_Structure, and Catalog_Contents_Additional_Attributes tables?",
    "id": 310
  },
  {
    "ir": "Write a PLpgSQL function that retrieves a specific dimension of a catalog entry from the \"Catalog_Contents\" table based on the provided parameters. The function, named get_catalog_entry_dimensions, accepts two parameters: p_entry_id of type bigint, which specifies the unique identifier of the catalog entry, and p_dimension_type of type integer, which determines which dimension to retrieve. The function returns a text value corresponding to the requested dimension. If p_dimension_type equals 1, the function executes a SELECT query to retrieve the capacity column value from the \"Catalog_Contents\" table where the catalog_entry_id matches the provided p_entry_id. If p_dimension_type equals 2, it retrieves the length column value under the same condition. For any other value of p_dimension_type, the function retrieves the height column value, again where the catalog_entry_id matches p_entry_id. The function uses conditional logic with IF, ELSIF, and ELSE statements to determine which column value to return based on the value of p_dimension_type.",
    "plsql": "CREATE OR REPLACE FUNCTION get_catalog_entry_dimensions(p_entry_id bigint, p_dimension_type integer)\nRETURNS text AS $$\nBEGIN\n    IF p_dimension_type = 1 THEN\n        RETURN (SELECT capacity FROM \"Catalog_Contents\" WHERE catalog_entry_id = p_entry_id);\n    ELSIF p_dimension_type = 2 THEN\n        RETURN (SELECT length FROM \"Catalog_Contents\" WHERE catalog_entry_id = p_entry_id);\n    ELSE\n        RETURN (SELECT height FROM \"Catalog_Contents\" WHERE catalog_entry_id = p_entry_id);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "SELECT get_catalog_entry_dimensions(1, 1);",
      "SELECT get_catalog_entry_dimensions(2, 2);",
      "SELECT get_catalog_entry_dimensions(3, 3);",
      "SELECT get_catalog_entry_dimensions(1, 2);",
      "SELECT get_catalog_entry_dimensions(2, 3);"
    ],
    "summary": "Create a PL/pgSQL function named get_catalog_entry_dimensions that takes a catalog entry ID (bigint) and a dimension type (integer). It returns a text value: capacity if type is 1, length if type is 2, or height for any other type, by querying the Catalog_Contents table for the matching entry_id.",
    "natural_language": "What is the text value returned by a PL/pgSQL function named get_catalog_entry_dimensions when given a catalog entry ID and a dimension type, where it queries the Catalog_Contents table and returns capacity for type 1, length for type 2, or height for any other type?",
    "id": 311
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named \"CalculateSingerRanking\" that accepts two input parameters: \"birthYearLimit\" of type REAL and \"minNetWorth\" of type REAL. This function is designed to return a REFCURSOR, which is a pointer to a result set. Inside the function, a local variable named \"rankings\" of type REFCURSOR is declared. The core operation of the function involves opening this \"rankings\" REFCURSOR. The REFCURSOR is populated by executing a SELECT statement against the \"singer\" table. This SELECT statement retrieves three columns: \"Name\", \"Net_Worth_Millions\", and a calculated column named \"wealth_rank\". The \"wealth_rank\" column is determined by applying the RANK() window function over the result set, ordering the rows by the \"Net_Worth_Millions\" column in descending order. The rows included in this result set are filtered by a WHERE clause that applies two conditions: the \"Birth_Year\" column must be greater than or equal to the \"birthYearLimit\" parameter, AND the \"Net_Worth_Millions\" column must be greater than or equal to the \"minNetWorth\" parameter. Finally, the entire result set is ordered by the \"Net_Worth_Millions\" column in descending order. After populating the \"rankings\" REFCURSOR, the function returns this REFCURSOR to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION \"CalculateSingerRanking\"(\"birthYearLimit\" REAL, \"minNetWorth\" REAL)\nRETURNS REFCURSOR\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"rankings\" REFCURSOR;\nBEGIN\n    OPEN \"rankings\" FOR\n    SELECT \"Name\", \n           \"Net_Worth_Millions\",\n           RANK() OVER (ORDER BY \"Net_Worth_Millions\" DESC) as wealth_rank\n    FROM \"singer\"\n    WHERE \"Birth_Year\" >= \"birthYearLimit\" AND \"Net_Worth_Millions\" >= \"minNetWorth\"\n    ORDER BY \"Net_Worth_Millions\" DESC;\n    \n    RETURN \"rankings\";\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "SELECT \"CalculateSingerRanking\"(1940.0, 25.0);",
      "SELECT \"CalculateSingerRanking\"(1950.0, 30.0);",
      "SELECT \"CalculateSingerRanking\"(1960.0, 20.0);",
      "SELECT \"CalculateSingerRanking\"(1970.0, 10.0);",
      "SELECT \"CalculateSingerRanking\"(1980.0, 5.0);"
    ],
    "summary": "Create a PL/pgSQL function named CalculateSingerRanking that takes a birth year limit and a minimum net worth (both real). It returns a REFCURSOR containing singer Name, Net_Worth_Millions, and a wealth_rank (using RANK() ordered by net worth descending) for singers meeting the birth year and net worth criteria, ordered by net worth descending.",
    "natural_language": "Write a PL/pgSQL function called CalculateSingerRanking that accepts a birth year limit and a minimum net worth, both as real numbers. Have it return a REFCURSOR with the singer's Name, Net_Worth_Millions, and a wealth_rank (assigned using RANK() over descending net worth) for all singers who meet the provided birth year and net worth thresholds. Order the results by net worth in descending order.",
    "id": 312
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_payment_info` that accepts two input parameters: `p_customer_id` of type `bigint` and `p_payment_method` of type `text`. This function is designed to return a set of records, specifically a table with three columns: `customer_id` of type `bigint`, `datetime_payment` of type `timestamp with time zone`, and `amount_payment` of type `double precision`. The core operation of this function is to perform a `SELECT` query on the table named `\"Customer_Payments\"`. The `SELECT` statement retrieves the values from the `customer_id` column, the `datetime_payment` column, and the `amount_payment` column from the `\"Customer_Payments\"` table. The selection of rows is filtered by two conditions connected with an `AND` logical operator. The first condition requires that the value in the `customer_id` column of the `\"Customer_Payments\"` table must be exactly equal to the value provided in the `p_customer_id` input parameter. The second condition utilizes the `strpos` function to check for the presence of a substring. Specifically, it checks if the string provided in the `p_payment_method` input parameter exists within the string value of the `payment_method_code` column of the `\"Customer_Payments\"` table. The `strpos` function returns the starting position of the first occurrence of the substring within the string, or 0 if the substring is not found. The condition `strpos(\"Customer_Payments\".\"payment_method_code\", p_payment_method) > 0` ensures that only rows where the `p_payment_method` string is found as a substring within the `payment_method_code` column are included in the result set. The `RETURN QUERY` statement then returns all rows that satisfy these combined conditions as the result of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_payment_info(p_customer_id bigint, p_payment_method text)\nRETURNS TABLE(customer_id bigint, datetime_payment timestamp with time zone, amount_payment double precision)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Customer_Payments\".\"customer_id\", \"Customer_Payments\".\"datetime_payment\", \"Customer_Payments\".\"amount_payment\"\n    FROM \"Customer_Payments\"\n    WHERE \"Customer_Payments\".\"customer_id\" = p_customer_id\n    AND strpos(\"Customer_Payments\".\"payment_method_code\", p_payment_method) > 0;\nEND;\n$$;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT * FROM get_customer_payment_info(11, 'Direct');",
      "SELECT * FROM get_customer_payment_info(2, 'Debit');",
      "SELECT * FROM get_customer_payment_info(14, 'Direct Debit');",
      "SELECT customer_id, datetime_payment, amount_payment FROM get_customer_payment_info(1, 'Credit');",
      "SELECT * FROM get_customer_payment_info(3, 'Card');"
    ],
    "summary": "Create a PL/pgSQL function named `get_customer_payment_info` that returns a table with columns `customer_id` (bigint), `datetime_payment` (timestamptz), and `amount_payment` (double precision). The function accepts `p_customer_id` (bigint) and `p_payment_method` (text). It queries the `\"Customer_Payments\"` table where `customer_id` equals `p_customer_id` and the `payment_method_code` contains the substring `p_payment_method`.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called `get_customer_payment_info`? It should spit out a table with `customer_id` (as a bigint), `datetime_payment` (timestamptz), and `amount_payment` (double precision). The function needs to take in `p_customer_id` (bigint) and `p_payment_method` (text). Basically, it's gotta look through the `\"Customer_Payments\"` table, grab the rows where the `customer_id` matches the given `p_customer_id`, and where the `payment_method_code` kinda has that `p_payment_method` string in it somewhere.",
    "id": 313
  },
  {
    "ir": "Write a PLpgSQL function that retrieves specific address information for a customer based on provided parameters. The function, named get_customer_address_info, accepts two parameters: p_customer_id of type bigint, which represents the unique identifier of a customer, and p_city of type text, which specifies a city name or substring to filter the address records. The function returns a table with three columns: line_1_number_building, city, and zip_postcode, all of type text. The function performs a SELECT operation to extract data from the Addresses table, specifically the columns line_1_number_building, city, and zip_postcode. It joins the Customers table with the Addresses table using the condition that the customer_address_id column in the Customers table matches the address_id column in the Addresses table. The WHERE clause filters the results to include only those rows where the customer_id column in the Customers table equals the value of the p_customer_id parameter and the city column in the Addresses table contains the substring specified by the p_city parameter, using the strpos function to determine if p_city is present within the city column.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_address_info(p_customer_id bigint, p_city text)\nRETURNS TABLE(line_1_number_building text, city text, zip_postcode text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Addresses\".\"line_1_number_building\", \"Addresses\".\"city\", \"Addresses\".\"zip_postcode\"\n    FROM \"Customers\"\n    JOIN \"Addresses\" ON \"Customers\".\"customer_address_id\" = \"Addresses\".\"address_id\"\n    WHERE \"Customers\".\"customer_id\" = p_customer_id\n    AND strpos(\"Addresses\".\"city\", p_city) > 0;\nEND;\n$$;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT * FROM get_customer_address_info(1, 'Port Melyssa');",
      "SELECT * FROM get_customer_address_info(2, 'Hagenesfurt');",
      "SELECT * FROM get_customer_address_info(3, 'Lake Elaina');",
      "SELECT * FROM get_customer_address_info(1, 'Lake Elaina');",
      "SELECT * FROM get_customer_address_info(2, 'Port Melyssa');"
    ],
    "summary": "Create a PL/pgSQL function named `get_customer_address_info` that returns a table with columns `line_1_number_building`, `city`, and `zip_postcode` (all text). The function accepts `p_customer_id` (bigint) and `p_city` (text). It queries the `Addresses` table, joining with the `Customers` table on `address_id` = `customer_address_id`. Return rows where `customer_id` equals `p_customer_id` and the `city` column contains the substring `p_city`.",
    "natural_language": "What are the line_1_number_building, city, and zip_postcode details for a specific customer ID, filtered to addresses in a city containing a given substring?",
    "id": 314
  },
  {
    "ir": "Write a PLpgSQL function that retrieves recent payment records from the Customer_Payments table for a specified customer and within a given time interval. The function, named get_recent_payments, accepts two parameters: p_customer_id of type bigint, which represents the unique identifier of the customer whose payment records are to be fetched, and p_days_interval of type integer, which specifies the number of days to look back from the current date to filter the payment records. The function returns a table with three columns: customer_id of type bigint, datetime_payment of type timestamp with time zone, and amount_payment of type double precision. The function executes a SELECT query on the Customer_Payments table, filtering records where the customer_id column matches the provided p_customer_id parameter and the datetime_payment column is greater than the current timestamp minus the interval defined by p_days_interval days. The query results are returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_payments(p_customer_id bigint, p_days_interval integer)\nRETURNS TABLE(customer_id bigint, datetime_payment timestamp with time zone, amount_payment double precision)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Customer_Payments\".\"customer_id\", \"Customer_Payments\".\"datetime_payment\", \"Customer_Payments\".\"amount_payment\"\n    FROM \"Customer_Payments\"\n    WHERE \"Customer_Payments\".\"customer_id\" = p_customer_id\n    AND \"Customer_Payments\".\"datetime_payment\" > NOW() - INTERVAL '1 day' * p_days_interval;\nEND;\n$$;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT * FROM get_recent_payments(11, 30);",
      "SELECT * FROM get_recent_payments(2, 7);",
      "SELECT * FROM get_recent_payments(14, 90);",
      "SELECT * FROM get_recent_payments(1, 1);",
      "SELECT * FROM get_recent_payments(3, 60);"
    ],
    "summary": "Create a PL/pgSQL function named `get_recent_payments` that returns a table with columns `customer_id` (bigint), `datetime_payment` (timestamptz), and `amount_payment` (double precision). The function accepts `p_customer_id` (bigint) and `p_days_interval` (integer). It queries the `Customer_Payments` table where `customer_id` equals `p_customer_id` and `datetime_payment` is within the last `p_days_interval` days from the current timestamp.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_recent_payments`. This function shall yield a table comprising the following columns: `customer_id` of type bigint, `datetime_payment` of type timestamptz, and `amount_payment` of type double precision. The function must accept two input parameters: `p_customer_id` as a bigint and `p_days_interval` as an integer. Its operational logic is to query the `Customer_Payments` table, retrieving records where the `customer_id` matches the provided `p_customer_id` parameter and where the `datetime_payment` falls within the specified number of days (`p_days_interval`) preceding the current timestamp.",
    "id": 315
  },
  {
    "ir": "Write a PLpgSQL function named get_outstanding_customers that accepts two parameters: p_amount_threshold of type double precision, which specifies the minimum amount of outstanding balance a customer must have to be considered, and p_country of type text, which specifies the country of residence for the customers to be retrieved. The function returns a table with columns first_name of type text, last_name of type text, and amount_outstanding of type double precision. The function begins by executing a RETURN QUERY statement, which performs a SELECT operation to retrieve data from the Customers table. Specifically, it selects the first_name, last_name, and amount_outstanding columns from the Customers table. The function joins the Customers table with the Addresses table using the customer_address_id column from the Customers table and the address_id column from the Addresses table to establish a relationship between the two tables. The WHERE clause filters the results to include only those customers whose amount_outstanding is greater than the value specified by the p_amount_threshold parameter and whose country, as specified in the Addresses table, matches the value provided in the p_country parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION get_outstanding_customers(p_amount_threshold double precision, p_country text)\nRETURNS TABLE(first_name text, last_name text, amount_outstanding double precision)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Customers\".\"first_name\", \"Customers\".\"last_name\", \"Customers\".\"amount_outstanding\"\n    FROM \"Customers\"\n    JOIN \"Addresses\" ON \"Customers\".\"customer_address_id\" = \"Addresses\".\"address_id\"\n    WHERE \"Customers\".\"amount_outstanding\" > p_amount_threshold\n    AND \"Addresses\".\"country\" = p_country;\nEND;\n$$;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT * FROM get_outstanding_customers(5000.0, 'USA');",
      "SELECT * FROM get_outstanding_customers(1000.0, 'USA');",
      "SELECT * FROM get_outstanding_customers(7000.0, 'USA');",
      "SELECT * FROM get_outstanding_customers(3000.0, 'USA');",
      "SELECT * FROM get_outstanding_customers(9000.0, 'USA');"
    ],
    "summary": "Create a PL/pgSQL function named `get_outstanding_customers` that returns a table with columns `first_name`, `last_name` (both text), and `amount_outstanding` (double precision). The function accepts `p_amount_threshold` (double precision) and `p_country` (text). It queries the `Customers` table, joining with the `Addresses` table on `customer_address_id` = `address_id`. Return rows where `amount_outstanding` exceeds `p_amount_threshold` and the `country` equals `p_country`.",
    "natural_language": "What are the first names, last names, and outstanding amounts for customers whose outstanding balance exceeds a specified threshold and who are located in a given country?",
    "id": 316
  },
  {
    "ir": "Write a PLpgSQL function named get_school_colors that accepts a single parameter p_school_id of type integer, which represents the unique identifier for a school. The function returns a text value. Within the function, declare a local variable v_school_colors of type text to store the result of a query. Execute a SELECT statement that retrieves the school colors by first attempting to select the \"School_Colors\" column from the \"school\" table, and if it is null, then select the \"Colors\" column from the \"school_details\" table. Use the COALESCE function to achieve this, which returns the first non-null value from the provided arguments. Perform a LEFT JOIN operation between the \"school\" table and the \"school_details\" table on the condition that the \"School_ID\" column from the \"school\" table matches the \"School_ID\" column from the \"school_details\" table. Filter the results of the query using a WHERE clause that specifies the \"School_ID\" column in the \"school\" table must equal the input parameter p_school_id. Assign the result of the query to the local variable v_school_colors. Finally, return the value stored in v_school_colors as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_colors(p_school_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_school_colors text;\nBEGIN\n    SELECT COALESCE(s.\"School_Colors\", sd.\"Colors\") INTO v_school_colors\n    FROM \"school\" s\n    LEFT JOIN \"school_details\" sd ON s.\"School_ID\" = sd.\"School_ID\"\n    WHERE s.\"School_ID\" = p_school_id;\n\n    RETURN v_school_colors;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_school_colors(1);",
      "SELECT get_school_colors(2);",
      "SELECT get_school_colors(3);"
    ],
    "summary": "Create a PL/pgSQL function named `get_school_colors` that returns a text value. The function accepts `p_school_id` (integer). It queries the `\"school\"` table, left-joining with the `\"school_details\"` table on `\"School_ID\"`. For the given `p_school_id`, return the first non-null value from the `\"School_Colors\"` column (from `\"school\"`) or the `\"Colors\"` column (from `\"school_details\"`).",
    "natural_language": "Construct a PL/pgSQL function called `get_school_colors` that yields a text output. This function should take a single integer parameter, specifically `p_school_id`. The implementation must perform a query on the `\"school\"` table, carefully employing a left outer join with the `\"school_details\"` table, linking them precisely on their shared `\"School_ID\"` column. For the provided school identifier, the function must then return, in a prioritized manner, the very first non-null value it encounters, checking initially the `\"School_Colors\"` column from the primary `\"school\"` table and subsequently, if necessary, falling back to the `\"Colors\"` column from the joined `\"school_details\"` table.",
    "id": 317
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_player_team that accepts a single integer input parameter named p_player_id, which is used to identify a specific player, and returns a text value; within the function, a local text variable v_team is declared to hold the result, then a SELECT query is executed against the player table to retrieve the value from the column named \"Team\" for the single row where the column named \"Player_ID\" exactly matches the provided p_player_id parameter value, and this retrieved value is stored into the v_team variable, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_team(p_player_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_team text;\nBEGIN\n    SELECT \"Team\" INTO v_team\n    FROM player\n    WHERE \"Player_ID\" = p_player_id;\n\n    RETURN v_team;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_player_team(1);",
      "SELECT get_player_team(2);",
      "SELECT get_player_team(3);",
      "SELECT get_player_team(15);",
      "SELECT get_player_team(16);"
    ],
    "summary": "Create a PLpgSQL function named get_player_team that takes an integer parameter p_player_id and returns a text value. The function should retrieve the 'Team' column value from the player table where the 'Player_ID' column matches the input parameter.",
    "natural_language": "Write a PLpgSQL function get_player_team(p_player_id integer) returning text to fetch the Team from player where Player_ID equals p_player_id.",
    "id": 318
  },
  {
    "ir": "Write a PLpgSQL function that takes an integer parameter p_school_id and returns an integer. The function is designed to calculate the number of records in the school_performance table where the School_Id column matches the provided p_school_id parameter. It begins by declaring a local variable v_performance_count of type integer to store the result of the count operation. The function then executes a SELECT statement that counts all rows in the school_performance table where the School_Id column is equal to the value of p_school_id. The result of this count is stored in the v_performance_count variable. Finally, the function returns the value of v_performance_count, which represents the total number of matching records found in the school_performance table for the specified school identifier.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_performance_count(p_school_id integer)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_performance_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_performance_count\n    FROM school_performance\n    WHERE \"School_Id\" = p_school_id;\n\n    RETURN v_performance_count;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_school_performance_count(1);",
      "SELECT get_school_performance_count(2);",
      "SELECT get_school_performance_count(3);",
      "SELECT get_school_performance_count(10);",
      "SELECT get_school_performance_count(99);"
    ],
    "summary": "Create a PLpgSQL function that takes an integer parameter p_school_id and returns an integer. The function should count and return the number of records in the school_performance table where the 'School_Id' column equals the input parameter.",
    "natural_language": "Please construct a PL/pgSQL function that accepts an integer parameter designated as p_school_id and yields an integer as its return value. The function's purpose is to compute and provide the count of records within the school_performance table for which the value in the 'School_Id' column is equivalent to the supplied input parameter.",
    "id": 319
  },
  {
    "ir": "Write a PLpgSQL function named get_player_position that accepts a single parameter, p_player_id, which is of integer type and represents the unique identifier of a player. The function is designed to return a text value that corresponds to the position of the player within a sports team or organization. The function begins by declaring a local variable, v_position, of text type, which will be used to store the position retrieved from the database. The core operation of the function involves executing a SELECT statement that targets the player table, specifically aiming to extract the value from the \"Position\" column. This extraction is conditional upon the \"Player_ID\" column matching the value provided in the p_player_id parameter. The result of this SELECT operation is stored into the v_position variable using the INTO clause, which is a mechanism in PLpgSQL for assigning the result of a query to a variable. After successfully retrieving the position, the function concludes by returning the value stored in v_position, thereby providing the caller with the position of the player identified by the given player ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_position(p_player_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_position text;\nBEGIN\n    SELECT \"Position\" INTO v_position\n    FROM player\n    WHERE \"Player_ID\" = p_player_id;\n\n    RETURN v_position;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_player_position(1);",
      "SELECT get_player_position(2);",
      "SELECT get_player_position(3);",
      "SELECT get_player_position(15);",
      "SELECT get_player_position(NULL);"
    ],
    "summary": "Create a PLpgSQL function named get_player_position that takes an integer parameter p_player_id and returns a text value. The function should retrieve the 'Position' column value from the player table where the 'Player_ID' column matches the input parameter.",
    "natural_language": "How can I create a PLpgSQL function called get_player_position that accepts a player ID as an integer parameter and returns the text value of that player's position from the player table?",
    "id": 320
  }
]