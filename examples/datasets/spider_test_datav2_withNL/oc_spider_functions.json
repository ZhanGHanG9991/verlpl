[
  {
    "ir": "Write an Oracle PL/SQL function named `fn_get_total_students_by_state` that accepts a single input parameter, `p_state`, which is of data type `VARCHAR2`. This function is designed to return a `NUMBER` representing the total count of students associated with the specified state. Upon execution, the function declares a local variable named `v_total` of data type `NUMBER` to temporarily store the calculated student count. The core operation involves executing a `SELECT` statement to retrieve data. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows that satisfy the specified conditions. The data for this count is sourced from two tables: `STUDENT` (aliased as `s`) and `CITY` (aliased as `c`). These two tables are joined using an `INNER JOIN` operation. The join condition specifies that rows from `STUDENT` and `CITY` are matched when the value in the `CITY_CODE` column of the `STUDENT` table (`s.CITY_CODE`) is equal to the value in the `CITY_CODE` column of the `CITY` table (`c.CITY_CODE`). After the join, a `WHERE` clause is applied to filter the results. This `WHERE` clause specifies that only rows where the value in the `STATE` column of the `CITY` table (`c.STATE`) is equal to the value provided in the input parameter `p_state` are considered for the count. The result of this `COUNT(*)` aggregation is then stored into the local variable `v_total`. Finally, the function returns the value stored in `v_total` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_total_students_by_state(p_state VARCHAR2) RETURN NUMBER IS\n    v_total NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total FROM STUDENT s JOIN CITY c ON s.CITY_CODE = c.CITY_CODE WHERE c.STATE = p_state;\n    RETURN v_total;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_total_students_by_state('MD') FROM DUAL",
      "SELECT fn_get_total_students_by_state('PA') FROM DUAL",
      "SELECT fn_get_total_students_by_state('NY') FROM DUAL",
      "SELECT fn_get_total_students_by_state('CA') FROM DUAL",
      "SELECT fn_get_total_students_by_state('TX') FROM DUAL"
    ],
    "summary": "Create a function named `fn_get_total_students_by_state` that accepts a state parameter and returns the count of students from that state by joining the STUDENT and CITY tables on CITY_CODE.",
    "natural_language": "Develop a comprehensive function, to be designated as `fn_get_total_students_by_state`, which will take a specific state as its input parameter. This function should meticulously calculate and deliver the precise total number of students who are officially registered as residing within that particular state. To achieve this accurate count, it is essential to perform a detailed join operation between the primary STUDENT table and the supplementary CITY table, carefully linking them on their shared CITY_CODE field to ensure correct geographical attribution.",
    "id": 1
  },
  {
    "ir": "Write an Oracle PL/SQL function named `fn_calculate_avg_distance_for_city` that is designed to compute and return the average distance associated with a specific city. This function accepts one input parameter: `p_city_code`, which is of data type `VARCHAR2` and represents the unique identifier or code for a city. The function is declared to return a single value of data type `NUMBER`, which will be the calculated average distance.\n\nUpon execution, the function declares a local variable named `v_avg_distance` of data type `NUMBER` to temporarily store the result of the average distance calculation. The core operation of the function involves a `SELECT` statement that calculates the average of the `DISTANCE` column. This calculation is performed on rows retrieved from the `DIRECT_DISTANCE` table. The rows considered for this average calculation are filtered by a `WHERE` clause. Specifically, a row is included if its `CITY1_CODE` column value is equal to the value provided in the `p_city_code` input parameter, OR if its `CITY2_CODE` column value is equal to the value provided in the `p_city_code` input parameter. This means the function considers distances where the specified city is either the origin or the destination. The computed average value is then stored into the `v_avg_distance` local variable using the `INTO` clause. Finally, the function returns the value stored in `v_avg_distance` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_calculate_avg_distance_for_city(p_city_code VARCHAR2) RETURN NUMBER IS\n    v_avg_distance NUMBER;\nBEGIN\n    SELECT AVG(DISTANCE) INTO v_avg_distance FROM DIRECT_DISTANCE WHERE CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code;\n    RETURN v_avg_distance;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_calculate_avg_distance_for_city('BAL') FROM dual",
      "SELECT fn_calculate_avg_distance_for_city('PIT') FROM dual",
      "SELECT fn_calculate_avg_distance_for_city('PHL') FROM dual",
      "SELECT fn_calculate_avg_distance_for_city('ATL') FROM dual",
      "SELECT fn_calculate_avg_distance_for_city('BKK') FROM dual"
    ],
    "summary": "Create a function named `fn_calculate_avg_distance_for_city` that accepts a city code and returns the average distance where the city is either CITY1_CODE or CITY2_CODE in the DIRECT_DISTANCE table.",
    "natural_language": "Make function `fn_calculate_avg_distance_for_city` that takes a city code and returns the average distance for it from the DIRECT_DISTANCE table, whether it's CITY1_CODE or CITY2_CODE.",
    "id": 2
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_student_location_info that accepts a single parameter, p_stuid, which is of type NUMBER and represents the student ID. The function returns a VARCHAR2 value containing detailed location information about the student. Within the function, declare a local variable v_location_info of type VARCHAR2 with a maximum length of 1000 characters to store the concatenated result. Execute a SELECT statement that retrieves the first name (FNAME) and last name (LNAME) of the student from the STUDENT table, and the city name (CITY_NAME) and state from the CITY table. The STUDENT table is joined with the CITY table using the CITY_CODE column, which is common to both tables, ensuring that the student's city code matches the city code in the CITY table. The WHERE clause filters the STUDENT table to find the row where the STUID column matches the input parameter p_stuid. Concatenate the retrieved first name, last name, city name, and state into a single string formatted as 'FirstName LastName lives in CityName, State', and store this string in the v_location_info variable. Finally, return the v_location_info variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_student_location_info(p_stuid NUMBER) RETURN VARCHAR2 IS\n    v_location_info VARCHAR2(1000);\nBEGIN\n    SELECT s.FNAME || ' ' || s.LNAME || ' lives in ' || c.CITY_NAME || ', ' || c.STATE INTO v_location_info FROM STUDENT s JOIN CITY c ON s.CITY_CODE = c.CITY_CODE WHERE s.STUID = p_stuid;\n    RETURN v_location_info;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_student_location_info(1001) FROM dual",
      "SELECT fn_get_student_location_info(1002) FROM dual",
      "SELECT fn_get_student_location_info(1003) FROM dual"
    ],
    "summary": "Create a function named `fn_get_student_location_info` that accepts a student ID and returns a formatted string containing the student's name and their city and state information by joining the STUDENT and CITY tables.",
    "natural_language": "Develop a comprehensive function, to be designated as `fn_get_student_location_info`, which will take a specific student ID as its input parameter. This function should meticulously construct and deliver a neatly formatted string that encapsulates the full name of the student along with a detailed geographical profile comprising their associated city and state. This information is to be accurately compiled by performing an inner join operation between the STUDENT table and the CITY table, ensuring the data is correctly correlated.",
    "id": 3
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_find_farthest_city_pair that takes no parameters and returns a single VARCHAR2 string of up to 255 characters, which is designed to identify and return a textual representation of the pair of cities with the greatest distance between them by querying a table named DIRECT_DISTANCE, which contains at least the columns CITY1_CODE, CITY2_CODE, and DISTANCE, by first executing a subquery to find the maximum numeric value in the DISTANCE column across all rows in the DIRECT_DISTANCE table, then using that maximum distance value as a condition in the main query to select from the DIRECT_DISTANCE table the row or rows where the DISTANCE column equals that maximum value, and from that resulting row set, using the MAX aggregate function on the concatenated string formed by joining the CITY1_CODE value, the literal string ' to ', and the CITY2_CODE value, which ensures a deterministic single result even if multiple city pairs share the identical maximum distance, and finally storing that resulting concatenated string into the local variable v_city_pair and returning it as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_find_farthest_city_pair RETURN VARCHAR2 IS\n    v_city_pair VARCHAR2(255);\nBEGIN\n    SELECT MAX(CITY1_CODE || ' to ' || CITY2_CODE) INTO v_city_pair FROM DIRECT_DISTANCE WHERE DISTANCE = (SELECT MAX(DISTANCE) FROM DIRECT_DISTANCE);\n    RETURN v_city_pair;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_find_farthest_city_pair FROM DUAL"
    ],
    "summary": "Create a function named `fn_find_farthest_city_pair` with no parameters that returns a string in the format 'CITY1_CODE to CITY2_CODE' representing the pair of cities with the maximum distance in the DIRECT_DISTANCE table.",
    "natural_language": "Create a function called `fn_find_farthest_city_pair` that doesn't take any inputs and gives back a text result. It should show something like 'CITY1_CODE to CITY2_CODE' for a couple of cities that are pretty much the farthest apart you can find in the DIRECT_DISTANCE table.",
    "id": 4
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_student_count_by_country that accepts a single input parameter p_country of type VARCHAR2 and returns a value of type NUMBER. The function declares a local variable v_count of type NUMBER. The function's logic executes a SELECT statement that performs a COUNT(*) aggregation. This SELECT statement queries from a join between two tables: the STUDENT table, aliased as 's', and the CITY table, aliased as 'c'. The tables are joined using the condition that the CITY_CODE column from the STUDENT table equals the CITY_CODE column from the CITY table. The query includes a WHERE clause with a condition that compares the COUNTRY column from the CITY table to the input parameter p_country. To ensure a case-insensitive comparison, both sides of the condition are transformed to lowercase using the LOWER function: LOWER(c.COUNTRY) is compared to LOWER(p_country). The result of the COUNT(*) operation, which is the total number of student records associated with cities in the specified country, is retrieved into the local variable v_count using an INTO clause. The function concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_student_count_by_country(p_country VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM STUDENT s JOIN CITY c ON s.CITY_CODE = c.CITY_CODE WHERE LOWER(c.COUNTRY) = LOWER(p_country);\n    RETURN v_count;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_student_count_by_country('USA') FROM dual",
      "SELECT fn_get_student_count_by_country('Canada') FROM dual",
      "SELECT fn_get_student_count_by_country('India') FROM dual",
      "SELECT fn_get_student_count_by_country('Australia') FROM dual",
      "SELECT fn_get_student_count_by_country('UK') FROM dual"
    ],
    "summary": "Create a function named `fn_get_student_count_by_country` that accepts a country parameter and returns the count of students from that country using a case-insensitive join between the STUDENT and CITY tables.",
    "natural_language": "Write a function called `fn_get_student_count_by_country` that takes a country name and gives back the number of students from around there. It should match up the STUDENT and CITY tables in a way that ignores differences in letter casing.",
    "id": 5
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_country_score_sum` that is designed to calculate and return the total sum of various score components for a specific country. This function accepts a single input parameter, `p_country_id`, which is of data type `NUMBER` and represents the unique identifier of the country for which the score sum is to be computed. Internally, the function declares a local variable named `v_sum_score` of data type `NUMBER` to temporarily store the calculated sum of scores. The core operation involves a `SELECT` statement that retrieves data from the `COUNTRIES` table. This `SELECT` statement calculates the sum of six distinct score columns: `OVERALL_SCORE`, `JUSTICE_SCORE`, `HEALTH_SCORE`, `EDUCATION_SCORE`, `ECONOMICS_SCORE`, and `POLITICS_SCORE`. The values from these six columns are added together to produce a single cumulative score. This calculated sum is then immediately assigned to the `v_sum_score` local variable. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `COUNTRIES` table, ensuring that the score sum is calculated only for the row where the `ID` column matches the value provided by the input parameter `p_country_id`. After the sum is calculated and stored in `v_sum_score`, the function concludes by returning the value held in `v_sum_score` as its output, which is of data type `NUMBER`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_score_sum(p_country_id NUMBER) RETURN NUMBER IS\n  v_sum_score NUMBER;\nBEGIN\n  SELECT OVERALL_SCORE + JUSTICE_SCORE + HEALTH_SCORE + EDUCATION_SCORE + ECONOMICS_SCORE + POLITICS_SCORE INTO v_sum_score FROM COUNTRIES WHERE ID = p_country_id;\n  RETURN v_sum_score;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_country_score_sum(1) FROM DUAL",
      "SELECT get_country_score_sum(2) FROM DUAL",
      "SELECT get_country_score_sum(3) FROM DUAL",
      "SELECT c.NAME, get_country_score_sum(c.ID) AS total_score FROM COUNTRIES c WHERE c.ID = 1",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total Score for Country ID 2: ' || get_country_score_sum(2));\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_country_score_sum that accepts a country ID and returns the sum of its OVERALL_SCORE, JUSTICE_SCORE, HEALTH_SCORE, EDUCATION_SCORE, ECONOMICS_SCORE, and POLITICS_SCORE from the COUNTRIES table.",
    "natural_language": "Sum OVERALL_SCORE, JUSTICE_SCORE, HEALTH_SCORE, EDUCATION_SCORE, ECONOMICS_SCORE, and POLITICS_SCORE for a given country ID.",
    "id": 6
  },
  {
    "ir": "Write an Oracle PL/SQL function named `has_english_language` that accepts a single input parameter, `p_country_id`, which is of data type `NUMBER` and represents the unique identifier for a country. This function is designed to determine if the specified country has 'English' listed as one of its official languages. The function declares a local variable `v_exists` of data type `NUMBER` to store the result of a database query. The core operation of the function involves executing a `SELECT` statement to count the number of records. This `SELECT` statement performs an `INNER JOIN` between two tables: `OFFICIAL_LANGUAGES` (aliased as `ol`) and `LANGUAGES` (aliased as `l`). The join condition `ol.LANGUAGE_ID = l.ID` links records from `OFFICIAL_LANGUAGES` to `LANGUAGES` based on their respective language identifiers. The `WHERE` clause of the `SELECT` statement applies two conditions: `ol.COUNTRY_ID = p_country_id` filters the results to include only official languages associated with the country identified by the input parameter `p_country_id`, and `l.NAME = 'English'` further restricts the results to only those languages whose name is exactly 'English'. The `COUNT(*)` aggregate function counts the number of rows that satisfy both the join condition and the `WHERE` clause conditions. The result of this count is then stored into the local variable `v_exists`. Finally, the function returns the value stored in `v_exists`, which will be `1` if 'English' is an official language for the given country, or `0` if it is not.",
    "plsql": "CREATE OR REPLACE FUNCTION has_english_language(p_country_id NUMBER) RETURN NUMBER IS\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_exists FROM OFFICIAL_LANGUAGES ol JOIN LANGUAGES l ON ol.LANGUAGE_ID = l.ID WHERE ol.COUNTRY_ID = p_country_id AND l.NAME = 'English';\n  RETURN v_exists;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT has_english_language(1) FROM DUAL",
      "SELECT has_english_language(2) FROM DUAL",
      "SELECT has_english_language(3) FROM DUAL",
      "SELECT has_english_language(999) FROM DUAL",
      "SELECT has_english_language(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named has_english_language that accepts a country ID and returns 1 if 'English' is an official language for that country (by checking the OFFICIAL_LANGUAGES and LANGUAGES tables), otherwise returns 0.",
    "natural_language": "Construct a PL/SQL function, which should be named has_english_language, that takes as its input a specific country ID. This function must then perform a detailed check by querying both the OFFICIAL_LANGUAGES and LANGUAGES tables to determine whether 'English' is formally registered as an official language for the given nation. If the meticulous verification confirms this fact, the function should thoughtfully return a value of 1; otherwise, it must definitively return a value of 0.",
    "id": 7
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_min_justice_score that returns a NUMBER data type, which declares a local variable v_min_score of type NUMBER, then executes a SELECT statement that retrieves the single minimum value from the JUSTICE_SCORE column of the COUNTRIES table using the MIN aggregate function, stores that result into the local variable v_min_score via an INTO clause, and finally returns the value stored in v_min_score as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_min_justice_score RETURN NUMBER IS\n  v_min_score NUMBER;\nBEGIN\n  SELECT MIN(JUSTICE_SCORE) INTO v_min_score FROM COUNTRIES;\n  RETURN v_min_score;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_min_justice_score FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_min_justice_score that returns the minimum value from the JUSTICE_SCORE column in the COUNTRIES table.",
    "natural_language": "Write a PL/SQL function called get_min_justice_score to return the smallest JUSTICE_SCORE from the COUNTRIES table.",
    "id": 8
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_score_difference` that accepts a single input parameter, `p_country_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function's primary operation involves querying the `COUNTRIES` table. Specifically, it selects the difference between the values in the `OVERALL_SCORE` column and the `ECONOMICS_SCORE` column. This calculated difference is then stored into a local variable named `v_difference`, which is also of data type `NUMBER`. The selection of the row from the `COUNTRIES` table is conditional, based on matching the value in the `ID` column of the `COUNTRIES` table with the value provided in the input parameter `p_country_id`. After successfully calculating and storing this difference in `v_difference`, the function then returns the value held by `v_difference` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_score_difference(p_country_id NUMBER) RETURN NUMBER IS\n  v_difference NUMBER;\nBEGIN\n  SELECT OVERALL_SCORE - ECONOMICS_SCORE INTO v_difference FROM COUNTRIES WHERE ID = p_country_id;\n  RETURN v_difference;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT calculate_score_difference(1) FROM dual",
      "SELECT calculate_score_difference(2) FROM dual",
      "SELECT calculate_score_difference(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_score_difference that accepts a country ID and returns the difference between its OVERALL_SCORE and ECONOMICS_SCORE from the COUNTRIES table.",
    "natural_language": "Please construct a PL/SQL function designated as 'calculate_score_difference'. This function should accept a country identifier as an input parameter and be designed to return the arithmetic difference between the OVERALL_SCORE and the ECONOMICS_SCORE for the specified country, as retrieved from the COUNTRIES table.",
    "id": 9
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_languages_by_length that accepts a single parameter p_length of type NUMBER, which represents the desired length of language names to be counted. The function performs a SELECT operation on the LANGUAGES table, specifically targeting the NAME column, to determine the number of entries where the length of the NAME matches the value provided in p_length. The LENGTH function is used to calculate the length of each NAME entry. The COUNT function is then applied to count all rows that satisfy the condition of having a NAME length equal to p_length. The result of this COUNT operation is stored in a local variable v_count of type NUMBER. Finally, the function returns the value of v_count, which represents the total number of language names in the LANGUAGES table that have the specified length.",
    "plsql": "CREATE OR REPLACE FUNCTION count_languages_by_length(p_length NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM LANGUAGES WHERE LENGTH(NAME) = p_length;\n  RETURN v_count;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT count_languages_by_length(9) FROM DUAL",
      "SELECT count_languages_by_length(7) FROM DUAL",
      "SELECT count_languages_by_length(10) FROM DUAL",
      "SELECT count_languages_by_length(5) FROM DUAL",
      "SELECT count_languages_by_length(12) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named count_languages_by_length that accepts a length parameter and returns the count of language names in the LANGUAGES table where the length of the NAME matches the provided value.",
    "natural_language": "Count languages where name length equals a given value.",
    "id": 10
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_total_orders that accepts two parameters: p_customer_id of type NUMBER, which represents the unique identifier of a customer, and p_days_back of type NUMBER, which specifies the number of days to look back from the current date. The function returns a NUMBER representing the total count of orders placed by the specified customer within the given timeframe. Inside the function, a local variable v_count of type NUMBER is declared to store the result of the query. The function executes a SELECT statement that counts the number of rows in the CUSTOMER_ORDERS table where the CUSTOMER_ID column matches the value of p_customer_id and the ORDER_DATE column, converted to a date format using TO_DATE with the pattern 'YYYY-MM-DD HH24:MI:SS', is greater than or equal to the current system date minus the value of p_days_back. The result of this count is stored in the v_count variable, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_total_orders(p_customer_id NUMBER, p_days_back NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND TO_DATE(ORDER_DATE, 'YYYY-MM-DD HH24:MI:SS') >= SYSDATE - p_days_back;\n    RETURN v_count;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_customer_total_orders(1, 30) FROM DUAL",
      "SELECT get_customer_total_orders(4, 7) FROM DUAL",
      "SELECT get_customer_total_orders(5, 365) FROM DUAL",
      "SELECT get_customer_total_orders(12, 90) FROM DUAL",
      "SELECT get_customer_total_orders(3, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_total_orders that accepts a customer ID and a number of days. It returns the count of orders for that customer from the CUSTOMER_ORDERS table where the ORDER_DATE is within the specified number of days from the current date.",
    "natural_language": "What is the total number of orders for a given customer ID placed within a specified number of days from the current date, based on the CUSTOMER_ORDERS table?",
    "id": 11
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_price that accepts two input parameters: a numeric parameter named p_product_id which identifies a specific product, and a numeric parameter named p_multiplier which serves as a scaling factor. The function's purpose is to retrieve and calculate a modified price for a product. It begins by declaring a local numeric variable named v_price to hold the calculation result. The function's execution logic performs a SELECT query on the PRODUCTS table, specifically targeting the PRODUCT_PRICE column for the row where the PRODUCT_ID column matches the provided p_product_id parameter value. It multiplies the retrieved PRODUCT_PRICE value by the p_multiplier parameter and stores the resulting product directly into the v_price variable. Finally, the function returns the calculated value stored in v_price as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price(p_product_id NUMBER, p_multiplier NUMBER) RETURN NUMBER IS\n    v_price NUMBER;\nBEGIN\n    SELECT PRODUCT_PRICE * p_multiplier INTO v_price FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n    RETURN v_price;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_price(1, 1.1) FROM DUAL",
      "SELECT get_product_price(2, 0.9) FROM DUAL",
      "SELECT get_product_price(3, 1.5) FROM DUAL",
      "SELECT get_product_price(10, 2) FROM DUAL",
      "SELECT get_product_price(13, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_product_price that accepts a product ID and a multiplier. It retrieves the product's price from the PRODUCTS table, multiplies it by the given multiplier, and returns the calculated value.",
    "natural_language": "Write a PL/SQL function called get_product_price that takes a product ID and a multiplier. It should fetch the product's price from the PRODUCTS table, apply the multiplier to it in some way, and give back the final amount.",
    "id": 12
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_avg_rank` that accepts one input parameter, `p_member_id`, which is of data type `NUMBER` and represents the unique identifier for a member. This function is designed to return a single value of data type `NUMBER`, representing the average rank of the specified member across various rounds. The function declares a local variable `v_avg_rank` of data type `NUMBER` to temporarily store the calculated average rank. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `ROUND` table. Within this `SELECT` statement, the `REGR_AVGX` aggregate function is utilized. The `REGR_AVGX` function calculates the average of the independent variable in a linear regression model. In this specific context, `REGR_AVGX` is applied to the `ROUND_ID` column as the independent variable and `RANK_IN_ROUND` as the dependent variable. This effectively calculates the average of the `ROUND_ID` values, weighted by their corresponding `RANK_IN_ROUND` values, for all records where the `MEMBER_ID` column in the `ROUND` table matches the value provided by the input parameter `p_member_id`. The result of this `REGR_AVGX` calculation is then stored into the local variable `v_avg_rank`. Finally, the function returns the value stored in `v_avg_rank` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_avg_rank(p_member_id NUMBER) RETURN NUMBER IS\n  v_avg_rank NUMBER;\nBEGIN\n  SELECT REGR_AVGX(r.RANK_IN_ROUND, r.ROUND_ID) INTO v_avg_rank FROM ROUND r WHERE r.MEMBER_ID = p_member_id;\n  RETURN v_avg_rank;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_avg_rank(1) FROM DUAL",
      "SELECT get_member_avg_rank(2) FROM DUAL",
      "SELECT get_member_avg_rank(3) FROM DUAL",
      "SELECT get_member_avg_rank(10) FROM DUAL",
      "SELECT get_member_avg_rank(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_avg_rank that accepts a member ID. It uses the REGR_AVGX function on the ROUND table to calculate the average of ROUND_ID weighted by RANK_IN_ROUND for the given member and returns this value.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_member_avg_rank, which is designed to receive a specific member ID as its input parameter. This function will meticulously employ the REGR_AVGX function, applied to the dataset within the ROUND table, in order to compute a precise weighted average. This calculation specifically determines the average of the ROUND_ID values, where each round ID is thoughtfully weighted according to its corresponding RANK_IN_ROUND, exclusively for the member identified by the provided ID, and subsequently returns this computed numerical result.",
    "id": 13
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_round_stats` that accepts a single input parameter, `p_round_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function's primary purpose is to compute a specific statistical measure related to a given round. Upon execution, the function declares a local variable named `v_avg_rank` of data type `NUMBER` to temporarily store the calculated statistical result. The core operation involves a `SELECT` statement that queries the `ROUND` table. This `SELECT` statement utilizes the `REGR_AVGX` analytic function. The `REGR_AVGX` function calculates the average of the independent variable (X) in a linear regression model. In this specific context, `REGR_AVGX` is applied to the `RANK_IN_ROUND` column as the dependent variable (Y) and the `MEMBER_ID` column as the independent variable (X), effectively calculating the average `MEMBER_ID` for a given `RANK_IN_ROUND` within the specified data set. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `ROUND` table, ensuring that only records where the `ROUND_ID` column matches the value provided by the input parameter `p_round_id` are considered for the calculation. The result of this `REGR_AVGX` calculation is then assigned to the local variable `v_avg_rank`. Finally, the function returns the value stored in `v_avg_rank` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_round_stats(p_round_id NUMBER) RETURN NUMBER IS\n  v_avg_rank NUMBER;\nBEGIN\n  SELECT REGR_AVGX(r.RANK_IN_ROUND, r.MEMBER_ID) INTO v_avg_rank FROM ROUND r WHERE r.ROUND_ID = p_round_id;\n  RETURN v_avg_rank;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT calculate_round_stats(1) FROM DUAL",
      "SELECT calculate_round_stats(2) FROM DUAL",
      "SELECT calculate_round_stats(3) FROM DUAL",
      "SELECT calculate_round_stats(10) FROM DUAL",
      "SELECT calculate_round_stats(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_round_stats` that accepts a `p_round_id` (NUMBER) and returns a NUMBER. It calculates the average `MEMBER_ID` for a given `RANK_IN_ROUND` using the `REGR_AVGX` function on the `ROUND` table, filtered by the provided `ROUND_ID`.",
    "natural_language": "Please construct a PL/SQL function designated as `calculate_round_stats`. This function shall accept a single numeric parameter, `p_round_id`, and return a numeric value. Its purpose is to compute the average `MEMBER_ID` corresponding to a specified `RANK_IN_ROUND`. This computation is to be performed by applying the `REGR_AVGX` function to data within the `ROUND` table, with the dataset restricted to records matching the supplied `ROUND_ID`.",
    "id": 14
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_email` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_date_from` of type `VARCHAR2`, and `p_date_to` of type `VARCHAR2`. This function is designed to return a single `VARCHAR2` value representing a customer's email address. Internally, the function declares a local variable `v_customer_email` of type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved email. The core operation of the function involves executing a `SELECT` statement to retrieve the `CUSTOMER_EMAIL` column from the `CUSTOMERS` table. This `SELECT` statement joins the `CUSTOMERS` table, aliased as `c`, with the `CUSTOMER_ADDRESSES` table, aliased as `ca`. The join condition specifies that the `CUSTOMER_ID` column from the `CUSTOMERS` table (`c.CUSTOMER_ID`) must be equal to the `CUSTOMER_ID` column from the `CUSTOMER_ADDRESSES` table (`ca.CUSTOMER_ID`). The `WHERE` clause of the `SELECT` statement applies three conditions: first, the `CUSTOMER_ID` column from the `CUSTOMERS` table (`c.CUSTOMER_ID`) must be equal to the input parameter `p_customer_id`; second, the `DATE_FROM` column from the `CUSTOMER_ADDRESSES` table (`ca.DATE_FROM`) must be less than or equal to the input parameter `p_date_from`; and third, the `DATE_TO` column from the `CUSTOMER_ADDRESSES` table (`ca.DATE_TO`) must be greater than or equal to the input parameter `p_date_to`. The result of this `SELECT` statement, specifically the value of `c.CUSTOMER_EMAIL`, is then stored into the local variable `v_customer_email`. Finally, the function returns the value stored in `v_customer_email` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_email(p_customer_id NUMBER, p_date_from VARCHAR2, p_date_to VARCHAR2) RETURN VARCHAR2 IS\n    v_customer_email VARCHAR2(255);\nBEGIN\n    SELECT c.CUSTOMER_EMAIL INTO v_customer_email\n    FROM CUSTOMERS c\n    JOIN CUSTOMER_ADDRESSES ca ON c.CUSTOMER_ID = ca.CUSTOMER_ID\n    WHERE c.CUSTOMER_ID = p_customer_id\n      AND ca.DATE_FROM <= p_date_from\n      AND ca.DATE_TO >= p_date_to;\n    RETURN v_customer_email;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_ADDRESSES",
      "ORDER_ITEMS",
      "SUPPLIERS"
    ],
    "call_sqls": [
      "SELECT get_customer_email(1, '2017-12-01', '2018-01-01') FROM dual",
      "SELECT get_customer_email(2, '2017-10-01', '2018-02-01') FROM dual",
      "SELECT get_customer_email(10, '2017-04-01', '2018-02-15') FROM dual",
      "SELECT get_customer_email(5, '2017-06-01', '2017-12-31') FROM dual",
      "SELECT get_customer_email(8, '2017-08-15', '2018-03-01') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_customer_email` that accepts `p_customer_id` (NUMBER), `p_date_from` (VARCHAR2), and `p_date_to` (VARCHAR2) and returns a VARCHAR2. It retrieves the `CUSTOMER_EMAIL` by joining the `CUSTOMERS` and `CUSTOMER_ADDRESSES` tables where the customer ID matches and the address is valid within the specified date range.",
    "natural_language": "Write a PL/SQL function called `get_customer_email` that takes a customer ID number, a vague starting date, and a vague ending date as text. It should fetch the customer's email by linking the customer and address tables for that customer, but only for addresses that were considered valid around those loosely specified times.",
    "id": 15
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_device_stock_info` that accepts a single input parameter, `p_device_id`, which is of the `NUMBER` data type. This function is designed to return a single value of the `NUMBER` data type. Upon execution, the function declares a local variable named `v_total_stock` of the `NUMBER` data type. The core operation of the function involves executing a `SELECT` statement to calculate the sum of the `QUANTITY` column from the `STOCK` table. This summation is performed only for rows where the `DEVICE_ID` column in the `STOCK` table matches the value provided by the input parameter `p_device_id`. The result of this summation is then stored into the local variable `v_total_stock`. Finally, the function returns the value of `v_total_stock`. If `v_total_stock` is `NULL` (which would occur if no matching `DEVICE_ID` records are found in the `STOCK` table), the `NVL` function is used to return `0` instead of `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_stock_info(p_device_id IN NUMBER) RETURN NUMBER IS\n    v_total_stock NUMBER;\nBEGIN\n    SELECT SUM(QUANTITY) INTO v_total_stock FROM STOCK WHERE DEVICE_ID = p_device_id;\n    RETURN NVL(v_total_stock, 0);\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_device_stock_info(1) FROM DUAL",
      "SELECT get_device_stock_info(2) FROM DUAL",
      "SELECT get_device_stock_info(3) FROM DUAL",
      "SELECT get_device_stock_info(6) FROM DUAL",
      "SELECT get_device_stock_info(99) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_device_stock_info` that accepts a `p_device_id` (NUMBER) and returns a NUMBER. It calculates the total stock quantity for the given device ID from the `STOCK` table, returning 0 if no stock is found.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_device_stock_info`? It should take a device ID (as a NUMBER) and spit back a NUMBER. Basically, it needs to add up all the stock we have for that specific device from the STOCK table. If there's no stock found for it, just have it return a zero.",
    "id": 16
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_shop_device_count that accepts a single input parameter p_shop_id of type NUMBER, which represents the unique identifier for a shop, and returns a value of type NUMBER. The function declares a local variable v_device_count of type NUMBER to store the result of a query. The function executes a SELECT statement that queries the STOCK table, using the COUNT aggregate function on the DEVICE_ID column to calculate the total number of devices. The WHERE clause filters the rows in the STOCK table, including only those rows where the SHOP_ID column value is exactly equal to the value provided in the input parameter p_shop_id. The result of this COUNT operation is then assigned into the local variable v_device_count using the INTO clause. Finally, the function returns the value stored in the v_device_count variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_shop_device_count(p_shop_id IN NUMBER) RETURN NUMBER IS\n    v_device_count NUMBER;\nBEGIN\n    SELECT COUNT(DEVICE_ID) INTO v_device_count FROM STOCK WHERE SHOP_ID = p_shop_id;\n    RETURN v_device_count;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_shop_device_count(1) FROM dual",
      "SELECT get_shop_device_count(2) FROM dual",
      "SELECT get_shop_device_count(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_shop_device_count` that accepts a `p_shop_id` (NUMBER) and returns a NUMBER. It counts the number of distinct devices in the `STOCK` table for the specified shop ID.",
    "natural_language": "Write a PL/SQL function called `get_shop_device_count` that takes a shop ID number as input and gives back a number. It should figure out roughly how many different kinds of devices are listed in the `STOCK` table for that particular shop.",
    "id": 17
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_stock_value that accepts a single input parameter p_shop_id of type NUMBER, which is used to identify a specific shop, and returns a single value of type NUMBER. The function begins by declaring a local variable v_total_value of type NUMBER to hold the result of a calculation. The core operation is a SELECT statement that queries the STOCK table, specifically targeting the QUANTITY column. It applies a condition using a WHERE clause to filter rows, selecting only those records where the value in the SHOP_ID column is exactly equal to the value passed in the p_shop_id parameter. The function then uses the SQL aggregate function SUM to calculate the total sum of all QUANTITY values from the filtered rows and stores this computed result directly into the local variable v_total_value using the INTO clause. The function concludes by using the RETURN statement to send back the final result; it employs the NVL function on the v_total_value variable, which checks if v_total_value is NULL—a scenario that would occur if the SELECT statement found no rows matching the WHERE condition—and if it is NULL, the NVL function substitutes the value with 0, otherwise it returns the calculated sum stored in v_total_value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_stock_value(p_shop_id IN NUMBER) RETURN NUMBER IS\n    v_total_value NUMBER;\nBEGIN\n    SELECT SUM(QUANTITY) INTO v_total_value FROM STOCK WHERE SHOP_ID = p_shop_id;\n    RETURN NVL(v_total_value, 0);\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_total_stock_value(1) FROM dual",
      "SELECT get_total_stock_value(2) FROM dual",
      "SELECT get_total_stock_value(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_total_stock_value` that accepts a `p_shop_id` (NUMBER) and returns a NUMBER. It sums the total quantity of all stock items for the given shop ID from the `STOCK` table, returning 0 if no stock is found.",
    "natural_language": "Write a PL/SQL function called `get_total_stock_value` that takes a shop ID number and gives back a number. It should figure out the overall amount of stock items for that particular shop from the STOCK table. If there isn't much stock to speak of, just return zero.",
    "id": 18
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_device_availability` that accepts a single input parameter, `p_device_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_availability` of data type `NUMBER`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT` aggregation on the `SHOP_ID` column from the `STOCK` table. The `COUNT` aggregation counts the number of rows in the `STOCK` table that satisfy a specific condition. The condition for row selection is `DEVICE_ID = p_device_id`, meaning only rows where the value in the `DEVICE_ID` column of the `STOCK` table is equal to the value passed in the `p_device_id` input parameter are included in the count. The result of this `COUNT` aggregation is then stored into the local variable `v_availability`. Finally, the function returns the value currently held by the `v_availability` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_availability(p_device_id IN NUMBER) RETURN NUMBER IS\n    v_availability NUMBER;\nBEGIN\n    SELECT COUNT(SHOP_ID) INTO v_availability FROM STOCK WHERE DEVICE_ID = p_device_id;\n    RETURN v_availability;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_device_availability(1) FROM DUAL",
      "SELECT get_device_availability(2) FROM DUAL",
      "SELECT get_device_availability(3) FROM DUAL",
      "SELECT get_device_availability(6) FROM DUAL",
      "SELECT get_device_availability(99) FROM DUAL"
    ],
    "summary": "Create a function named `get_device_availability` that accepts a `NUMBER` parameter `p_device_id` and returns a `NUMBER`. It should count the rows in the `STOCK` table where `DEVICE_ID` equals the input parameter and return that count.",
    "natural_language": "Make a function `get_device_availability` that takes a NUMBER `p_device_id` and returns a NUMBER. Count STOCK rows where DEVICE_ID matches the input and return the count.",
    "id": 19
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_shop_open_year` that accepts a single input parameter, `p_shop_id`, which is of data type `NUMBER` and represents the unique identifier for a shop. This function is designed to return a single value of data type `NUMBER`, which will be the opening year of the specified shop. Upon execution, the function declares a local variable named `v_open_year` of data type `NUMBER` to temporarily store the retrieved opening year. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `SHOP` table. Specifically, it selects the value from the `OPEN_YEAR` column and attempts to store this value into the `v_open_year` local variable. This selection is conditional, applying a `WHERE` clause that filters the rows in the `SHOP` table. The condition `SHOP_ID = p_shop_id` ensures that only the row where the value in the `SHOP_ID` column matches the value provided in the `p_shop_id` input parameter is considered. After successfully retrieving the `OPEN_YEAR` for the specified shop into `v_open_year`, the function then returns the value currently held in `v_open_year` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_shop_open_year(p_shop_id IN NUMBER) RETURN NUMBER IS\n    v_open_year NUMBER;\nBEGIN\n    SELECT OPEN_YEAR INTO v_open_year FROM SHOP WHERE SHOP_ID = p_shop_id;\n    RETURN v_open_year;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_shop_open_year(1) FROM DUAL",
      "SELECT get_shop_open_year(2) FROM DUAL",
      "SELECT get_shop_open_year(3) FROM DUAL",
      "SELECT get_shop_open_year(10) FROM DUAL",
      "SELECT get_shop_open_year(100) FROM DUAL"
    ],
    "summary": "Create a function named `get_shop_open_year` that accepts a `NUMBER` parameter `p_shop_id` and returns a `NUMBER`. It should select the `OPEN_YEAR` from the `SHOP` table where `SHOP_ID` equals the input parameter and return that value.",
    "natural_language": "Write a function called `get_shop_open_year` that takes a `NUMBER` parameter `p_shop_id` and returns a `NUMBER`. Fetch the `OPEN_YEAR` from the `SHOP` table for the matching `SHOP_ID` and return it.",
    "id": 20
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_breed_stats` that accepts a single input parameter, `p_breed_code`, which is of type `VARCHAR2`, representing the unique identifier for a dog breed. This function is designed to return a `NUMBER` value, which represents a calculated statistical score for the specified breed.\n\nUpon execution, the function first declares two local variables: `v_total_dogs` of type `NUMBER` to store the count of dogs belonging to the given breed, and `v_avg_weight` of type `NUMBER` to store the average weight of those dogs.\n\nThe core logic begins by performing a `SELECT` statement on the `dogs` table. This statement calculates two aggregate values: the total count of rows (dogs) and the average of the `weight` column. The `weight` column, which is presumably stored as a `VARCHAR2` or similar type, is explicitly converted to a `NUMBER` using the `TO_NUMBER()` function before the `AVG()` aggregation is applied. These calculated values are then assigned to the `v_total_dogs` and `v_avg_weight` variables, respectively. The selection of rows for this calculation is filtered by a `WHERE` clause, ensuring that only records where the `breed_code` column matches the input parameter `p_breed_code` are considered.\n\nFollowing the data retrieval, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) to determine the final return value based on the calculated statistics:\n\n1.  **First Condition:** If `v_total_dogs` is equal to `0`, meaning no dogs were found for the specified `p_breed_code`, the function immediately returns the numeric value `0`.\n\n2.  **Second Condition:** If the first condition is not met (i.e., `v_total_dogs` is greater than `0`), the function then checks if `v_avg_weight` is less than `5`. If this condition is true, the function returns the product of `v_total_dogs` multiplied by `10`.\n\n3.  **Third Condition:** If neither of the previous conditions is met, the function checks if `v_avg_weight` is greater than or equal to `5` AND `v_avg_weight` is less than or equal to `15`. If this compound condition is true, the function returns the product of `v_total_dogs` multiplied by `20`.\n\n4.  **Else Condition:** If none of the preceding conditions are met, implying that `v_total_dogs` is greater than `0` and `v_avg_weight` is greater than `15`, the function executes the `ELSE` block and returns the product of `v_total_dogs` multiplied by `30`.\n\nThe function concludes after one of these return statements is executed.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_breed_stats(p_breed_code VARCHAR2) RETURN NUMBER IS\n    v_total_dogs NUMBER;\n    v_avg_weight NUMBER;\nBEGIN\n    SELECT COUNT(*), AVG(TO_NUMBER(weight)) INTO v_total_dogs, v_avg_weight FROM dogs WHERE breed_code = p_breed_code;\n    IF v_total_dogs = 0 THEN\n        RETURN 0;\n    ELSIF v_avg_weight < 5 THEN\n        RETURN v_total_dogs * 10;\n    ELSIF v_avg_weight >= 5 AND v_avg_weight <= 15 THEN\n        RETURN v_total_dogs * 20;\n    ELSE\n        RETURN v_total_dogs * 30;\n    END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "BREEDS",
      "SIZES"
    ],
    "call_sqls": [
      "SELECT calculate_breed_stats('ESK') FROM DUAL",
      "SELECT calculate_breed_stats('HUS') FROM DUAL",
      "SELECT calculate_breed_stats('BUL') FROM DUAL",
      "SELECT breed_code, calculate_breed_stats(breed_code) AS breed_stat FROM breeds",
      "SELECT b.breed_name, calculate_breed_stats(b.breed_code) AS breed_stat FROM breeds b"
    ],
    "summary": "Create a function named `calculate_breed_stats` that accepts a `VARCHAR2` parameter `p_breed_code` and returns a `NUMBER`. It should calculate the total count and average weight (converted to NUMBER) of dogs from the `dogs` table for the given breed. Return 0 if no dogs are found. Otherwise, return the total count multiplied by 10, 20, or 30 based on whether the average weight is less than 5, between 5 and 15 inclusive, or greater than 15, respectively.",
    "natural_language": "Define a function called `calculate_breed_stats` that receives a `VARCHAR2` input parameter designated as `p_breed_code` and yields a `NUMBER` as its output. The function's purpose is to compute the aggregate number and the mean weight, cast as a `NUMBER`, for canines associated with the specified breed code within the `dogs` table. Should no corresponding records be located, the function must return a value of zero. If records are present, the return value shall be determined by multiplying the total count by a factor of 10, 20, or 30. This factor is contingent upon the calculated average weight: a factor of 10 is applied if the average is below 5, a factor of 20 if it falls within the inclusive range of 5 to 15, and a factor of 30 if it exceeds 15.",
    "id": 21
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_adoption_priority that accepts a single parameter p_dog_id of type NUMBER, which represents the unique identifier of a dog in the database. The function returns a NUMBER indicating the adoption priority of the specified dog. Within the function, a SELECT statement retrieves two values from the dogs table: the number of days the dog has been waiting for adoption, calculated by subtracting the date_arrived column from the current system date (SYSDATE) and truncating the result to remove the time component, and the abandoned status, stored in the abandoned_yn column, which is a VARCHAR2(1) indicating whether the dog was abandoned ('1' for abandoned, '0' for not abandoned). These values are stored in local variables v_days_waiting and v_abandoned, respectively. The function then evaluates a series of conditional statements using an IF-ELSIF-ELSE structure to determine the adoption priority based on the dog's abandoned status and the number of days waiting. If the dog is abandoned (v_abandoned = '1') and has been waiting for more than 90 days, the function returns a priority value of 1. If the dog is abandoned and has been waiting for 90 days or fewer, the function returns a priority value of 2. If the dog has been waiting for more than 180 days, regardless of the abandoned status, the function returns a priority value of 3. For all other cases, the function returns a priority value of 4.",
    "plsql": "CREATE OR REPLACE FUNCTION get_adoption_priority(p_dog_id NUMBER) RETURN NUMBER IS\n    v_days_waiting NUMBER;\n    v_abandoned VARCHAR2(1);\nBEGIN\n    SELECT TRUNC(SYSDATE - TO_DATE(date_arrived, 'YYYY-MM-DD HH24:MI:SS')), abandoned_yn INTO v_days_waiting, v_abandoned FROM dogs WHERE dog_id = p_dog_id;\n    IF v_abandoned = '1' AND v_days_waiting > 90 THEN\n        RETURN 1;\n    ELSIF v_abandoned = '1' AND v_days_waiting <= 90 THEN\n        RETURN 2;\n    ELSIF v_days_waiting > 180 THEN\n        RETURN 3;\n    ELSE\n        RETURN 4;\n    END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "BREEDS",
      "SIZES"
    ],
    "call_sqls": [
      "SELECT get_adoption_priority(1) FROM dual",
      "SELECT get_adoption_priority(2) FROM dual",
      "SELECT get_adoption_priority(3) FROM dual",
      "SELECT get_adoption_priority(4) FROM dual",
      "SELECT get_adoption_priority(5) FROM dual"
    ],
    "summary": "Create a function named `get_adoption_priority` that accepts a `NUMBER` parameter `p_dog_id` and returns a `NUMBER`. It should retrieve the dog's abandoned status (`abandoned_yn`) and the truncated number of days waiting (SYSDATE - `date_arrived`). Return priority 1 if abandoned and waiting >90 days, priority 2 if abandoned and waiting <=90 days, priority 3 if waiting >180 days, and priority 4 for all other cases.",
    "natural_language": "What function should be created to return a priority number for a given dog ID, based on whether the dog is abandoned and how many days it has been waiting, with priorities assigned as 1 for abandoned dogs waiting over 90 days, 2 for abandoned dogs waiting 90 days or less, 3 for any dog waiting over 180 days, and 4 for all other cases?",
    "id": 22
  },
  {
    "ir": "Write an Oracle PL/SQL function named determine_size_category that accepts a single input parameter p_size_code of type VARCHAR2 and returns a VARCHAR2 value, which begins by declaring two local NUMBER variables v_dog_count and v_max_weight, then executes a SELECT statement that queries the dogs table to count all rows and find the maximum numeric value of the weight column for rows where the size_code column exactly matches the provided p_size_code parameter, converting the weight column to a NUMBER using the TO_NUMBER function, and stores the resulting count and maximum weight into the variables v_dog_count and v_max_weight respectively, after which it uses an IF-ELSIF-ELSE conditional block to evaluate the retrieved data: if the v_dog_count equals zero, the function returns the string literal 'NO_DOGS'; otherwise, if the v_max_weight is less than 10, it returns 'LIGHTWEIGHT_GROUP'; otherwise, if the v_max_weight is greater than or equal to 10 and less than 25, it returns 'MEDIUM_GROUP'; and in all other cases where v_max_weight is 25 or greater, it returns 'HEAVYWEIGHT_GROUP'.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_size_category(p_size_code VARCHAR2) RETURN VARCHAR2 IS\n    v_dog_count NUMBER;\n    v_max_weight NUMBER;\nBEGIN\n    SELECT COUNT(*), MAX(TO_NUMBER(weight)) INTO v_dog_count, v_max_weight FROM dogs WHERE size_code = p_size_code;\n    IF v_dog_count = 0 THEN\n        RETURN 'NO_DOGS';\n    ELSIF v_max_weight < 10 THEN\n        RETURN 'LIGHTWEIGHT_GROUP';\n    ELSIF v_max_weight >= 10 AND v_max_weight < 25 THEN\n        RETURN 'MEDIUM_GROUP';\n    ELSE\n        RETURN 'HEAVYWEIGHT_GROUP';\n    END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "BREEDS",
      "SIZES"
    ],
    "call_sqls": [
      "SELECT determine_size_category('LGE') FROM DUAL",
      "SELECT determine_size_category('MED') FROM DUAL",
      "SELECT determine_size_category('SML') FROM DUAL",
      "SELECT determine_size_category('XL') FROM DUAL",
      "SELECT determine_size_category('XXL') FROM DUAL"
    ],
    "summary": "Create a function named `determine_size_category` that accepts a `VARCHAR2` parameter `p_size_code` and returns a `VARCHAR2`. It should count the dogs and find the maximum weight (converted to NUMBER) for the given `size_code`. Return 'NO_DOGS' if count is zero. Otherwise, return 'LIGHTWEIGHT_GROUP' if max weight <10, 'MEDIUM_GROUP' if between 10 and 25 (inclusive of 10), or 'HEAVYWEIGHT_GROUP' if 25 or greater.",
    "natural_language": "Alright, so we need a function called `determine_size_category`. It takes a `VARCHAR2` parameter, let's call it `p_size_code`, and spits back a `VARCHAR2`. Here's what it's gotta do: first, check how many dogs there are for that size code and also find the heaviest one (make sure that weight is a NUMBER). If there aren't any dogs for that code, just return 'NO_DOGS'. If there are dogs, look at that max weight. If it's under 10, return 'LIGHTWEIGHT_GROUP'. If it's 10 up to and including 25, that's 'MEDIUM_GROUP'. If it's 25 or more, that's 'HEAVYWEIGHT_GROUP'.",
    "id": 23
  },
  {
    "ir": "Write an Oracle PL/SQL function named assess_dog_status that accepts a single parameter p_dog_id of type NUMBER, which represents the unique identifier of a dog in the database. The function retrieves the gender and age of the dog from the dogs table, where the dog_id column matches the provided p_dog_id. The gender column is expected to contain a VARCHAR2 value representing the dog's gender, with '1' indicating male and '0' indicating female. The age column is converted to a NUMBER type using the TO_NUMBER function to ensure numerical comparison. The function then evaluates the dog's gender and age using a series of conditional statements. If the gender is '1' and the age is less than 5, the function returns the string 'YOUNG_MALE'. If the gender is '1' and the age is 5 or greater, it returns 'MATURE_MALE'. If the gender is '0' and the age is less than 5, it returns 'YOUNG_FEMALE'. Otherwise, if the gender is '0' and the age is 5 or greater, it returns 'MATURE_FEMALE'. The function uses an IF-ELSIF-ELSE control structure to determine the appropriate status based on the dog's gender and age.",
    "plsql": "CREATE OR REPLACE FUNCTION assess_dog_status(p_dog_id NUMBER) RETURN VARCHAR2 IS\n    v_gender VARCHAR2(1);\n    v_age NUMBER;\nBEGIN\n    SELECT gender, TO_NUMBER(age) INTO v_gender, v_age FROM dogs WHERE dog_id = p_dog_id;\n    IF v_gender = '1' AND v_age < 5 THEN\n        RETURN 'YOUNG_MALE';\n    ELSIF v_gender = '1' AND v_age >= 5 THEN\n        RETURN 'MATURE_MALE';\n    ELSIF v_gender = '0' AND v_age < 5 THEN\n        RETURN 'YOUNG_FEMALE';\n    ELSE\n        RETURN 'MATURE_FEMALE';\n    END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "BREEDS",
      "SIZES"
    ],
    "call_sqls": [
      "SELECT assess_dog_status(1) FROM DUAL",
      "SELECT assess_dog_status(2) FROM DUAL",
      "SELECT assess_dog_status(3) FROM DUAL",
      "SELECT assess_dog_status(4) FROM DUAL",
      "SELECT assess_dog_status(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named assess_dog_status that takes a dog ID and returns a status string. It retrieves the dog's gender and age from the dogs table. Based on gender ('1' for male, '0' for female) and age (threshold of 5), it returns 'YOUNG_MALE', 'MATURE_MALE', 'YOUNG_FEMALE', or 'MATURE_FEMALE'.",
    "natural_language": "Please construct a PL/SQL function designated as 'assess_dog_status'. This function shall accept a dog identifier as an input parameter and yield a textual status as its output. The implementation must query the 'dogs' table to obtain the specified dog's gender and age. Utilizing conditional logic, where a gender value of '1' denotes male and '0' denotes female, and an age threshold of five years is established, the function is to return one of the following status strings: 'YOUNG_MALE', 'MATURE_MALE', 'YOUNG_FEMALE', or 'MATURE_FEMALE'.",
    "id": 24
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_customer_balance that accepts a single parameter, p_customer_id, of type NUMBER, representing the unique identifier of a customer. The function calculates and returns the outstanding balance for the specified customer. It begins by declaring three local variables: v_total_payments, v_total_lessons, and v_outstanding, all of type NUMBER. The function first performs a SELECT operation on the CUSTOMER_PAYMENTS table, summing the AMOUNT_PAYMENT column for rows where the CUSTOMER_ID matches the provided p_customer_id, and stores the result in v_total_payments, using COALESCE to ensure a default value of 0 if no payments are found. Next, it performs another SELECT operation on the LESSONS table, summing the PRICE column for rows where the CUSTOMER_ID matches p_customer_id and the LESSON_STATUS_CODE is not 'Cancelled', storing the result in v_total_lessons, again using COALESCE to default to 0 if no lessons are found. The function then calculates the outstanding balance by subtracting v_total_payments from v_total_lessons and assigns this value to v_outstanding. It proceeds with conditional logic: if v_outstanding is less than 0, the function returns 0; if v_outstanding exceeds 10,000, it returns 10,000; if v_outstanding is greater than 5,000, it returns v_outstanding multiplied by 1.1; otherwise, it returns v_outstanding as is.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_customer_balance(p_customer_id NUMBER) RETURN NUMBER\nIS\n    v_total_payments NUMBER;\n    v_total_lessons NUMBER;\n    v_outstanding NUMBER;\nBEGIN\n    SELECT COALESCE(SUM(AMOUNT_PAYMENT), 0) INTO v_total_payments FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = p_customer_id;\n    SELECT COALESCE(SUM(PRICE), 0) INTO v_total_lessons FROM LESSONS WHERE CUSTOMER_ID = p_customer_id AND LESSON_STATUS_CODE != 'Cancelled';\n    v_outstanding := v_total_lessons - v_total_payments;\n    IF v_outstanding < 0 THEN\n        RETURN 0;\n    ELSIF v_outstanding > 10000 THEN\n        RETURN 10000;\n    ELSIF v_outstanding > 5000 THEN\n        RETURN v_outstanding * 1.1;\n    ELSE\n        RETURN v_outstanding;\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "SELECT calculate_customer_balance(1) FROM DUAL",
      "SELECT calculate_customer_balance(3) FROM DUAL",
      "SELECT calculate_customer_balance(4) FROM DUAL",
      "SELECT calculate_customer_balance(6) FROM DUAL",
      "SELECT calculate_customer_balance(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_customer_balance that takes a customer ID and returns their outstanding balance. It sums payments from the CUSTOMER_PAYMENTS table and sums lesson prices from the LESSONS table where the status is not 'Cancelled'. The balance is the difference. The return value is capped: negative becomes 0, over 10,000 becomes 10,000, over 5,000 is increased by 10%, otherwise the raw balance is returned.",
    "natural_language": "Write a PL/SQL function called calculate_customer_balance that accepts a customer ID and gives back their outstanding balance. Sum all payments from the CUSTOMER_PAYMENTS table for that customer. Then, sum the prices of all lessons from the LESSONS table for the same customer where the status is not 'Cancelled'. Calculate the balance as the lesson total minus the payment total. Cap the return value: if the result is negative, return 0; if it's over 10,000, return 10,000; if it's over 5,000, increase it by 10%; otherwise, return the raw balance.",
    "id": 25
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_staff_performance` that accepts a single input parameter, `p_staff_id`, which is of data type `NUMBER` and represents the unique identifier for a staff member. This function is designed to return a `VARCHAR2` value indicating the performance rating of the specified staff member.\n\nUpon execution, the function first declares three local variables: `v_completed_lessons` of type `NUMBER`, `v_cancelled_lessons` of type `NUMBER`, and `v_success_rate` of type `NUMBER`.\n\nThe function then proceeds to perform two `SELECT` statements to retrieve data from the `LESSONS` table.\nThe first `SELECT` statement counts the total number of lessons that are considered \"completed\" for the staff member identified by `p_staff_id`. This count is achieved by querying the `LESSONS` table, filtering rows where the `STAFF_ID` column matches the input `p_staff_id` and the `LESSON_STATUS_CODE` column is not equal to the string literal 'Cancelled'. The result of this count is stored in the `v_completed_lessons` variable.\nThe second `SELECT` statement counts the total number of lessons that are considered \"cancelled\" for the same staff member. This count is achieved by querying the `LESSONS` table, filtering rows where the `STAFF_ID` column matches the input `p_staff_id` and the `LESSON_STATUS_CODE` column is equal to the string literal 'Cancelled'. The result of this count is stored in the `v_cancelled_lessons` variable.\n\nFollowing these data retrievals, the function enters a conditional block. It first checks if the sum of `v_completed_lessons` and `v_cancelled_lessons` is equal to 0. This condition effectively determines if the staff member has any recorded lessons (either completed or cancelled).\nIf this sum is 0, indicating no activity for the staff member, the function immediately returns the string literal 'NO_ACTIVITY' and terminates.\n\nIf the sum of `v_completed_lessons` and `v_cancelled_lessons` is not 0, the function proceeds to calculate the `v_success_rate`. This is computed by dividing `v_completed_lessons` by the sum of `v_completed_lessons` and `v_cancelled_lessons`.\n\nAfter calculating the `v_success_rate`, the function enters another series of conditional statements to determine the performance rating based on this rate:\nIf `v_success_rate` is greater than 0.9, the function returns the string literal 'EXCELLENT'.\nOtherwise, if `v_success_rate` is greater than 0.7, the function returns the string literal 'GOOD'.\nOtherwise, if `v_success_rate` is greater than 0.5, the function returns the string literal 'AVERAGE'.\nIn all other cases (i.e., if `v_success_rate` is 0.5 or less), the function returns the string literal 'POOR'.\n\nThe function then concludes its execution.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_performance(p_staff_id NUMBER) RETURN VARCHAR2\nIS\n    v_completed_lessons NUMBER;\n    v_cancelled_lessons NUMBER;\n    v_success_rate NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_completed_lessons FROM LESSONS WHERE STAFF_ID = p_staff_id AND LESSON_STATUS_CODE != 'Cancelled';\n    SELECT COUNT(*) INTO v_cancelled_lessons FROM LESSONS WHERE STAFF_ID = p_staff_id AND LESSON_STATUS_CODE = 'Cancelled';\n    IF v_completed_lessons + v_cancelled_lessons = 0 THEN\n        RETURN 'NO_ACTIVITY';\n    END IF;\n    v_success_rate := v_completed_lessons / (v_completed_lessons + v_cancelled_lessons);\n    IF v_success_rate > 0.9 THEN\n        RETURN 'EXCELLENT';\n    ELSIF v_success_rate > 0.7 THEN\n        RETURN 'GOOD';\n    ELSIF v_success_rate > 0.5 THEN\n        RETURN 'AVERAGE';\n    ELSE\n        RETURN 'POOR';\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "SELECT get_staff_performance(8) FROM DUAL",
      "SELECT get_staff_performance(14) FROM DUAL",
      "SELECT get_staff_performance(11) FROM DUAL",
      "SELECT get_staff_performance(1) FROM DUAL",
      "SELECT get_staff_performance(2) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_staff_performance that takes a staff ID and returns a performance rating. It counts the staff's completed lessons (status not 'Cancelled') and cancelled lessons (status 'Cancelled') from the LESSONS table. If there are no lessons, return 'NO_ACTIVITY'. Otherwise, calculate the success rate (completed / total). Return 'EXCELLENT' if rate > 0.9, 'GOOD' if > 0.7, 'AVERAGE' if > 0.5, else 'POOR'.",
    "natural_language": "Write a PL/SQL function called get_staff_performance that accepts a staff ID and outputs a performance rating. Count the staff's completed lessons (where status is not 'Cancelled') and cancelled lessons (where status is 'Cancelled') from the LESSONS table. If no lessons exist, output 'NO_ACTIVITY'. Otherwise, compute the success rate (completed divided by total). Output 'EXCELLENT' if the rate exceeds 0.9, 'GOOD' if it exceeds 0.7, 'AVERAGE' if it exceeds 0.5, otherwise output 'POOR'.",
    "id": 26
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_customer_age_group that accepts a single parameter, p_customer_id of type NUMBER, representing the unique identifier of a customer. The function returns a VARCHAR2 value indicating the age group of the customer. Inside the function, declare a variable v_date_of_birth of type VARCHAR2(255) to store the date of birth of the customer, and a variable v_age_years of type NUMBER to store the calculated age in years. Begin by executing a SELECT statement to retrieve the DATE_OF_BIRTH column from the CUSTOMERS table where the CUSTOMER_ID matches the input parameter p_customer_id, and store the result in v_date_of_birth. Calculate the customer's age in years by subtracting the year extracted from v_date_of_birth, converted to a date using TO_DATE with the format 'YYYY-MM-DD HH24:MI:SS', from the current year extracted from CURRENT_TIMESTAMP. Use a series of conditional statements to determine the age group based on v_age_years: if the age is less than 18, return 'MINOR'; if the age is less than 25, return 'YOUNG_ADULT'; if the age is less than 40, return 'ADULT'; if the age is less than 60, return 'MIDDLE_AGED'; otherwise, return 'SENIOR'.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_customer_age_group(p_customer_id NUMBER) RETURN VARCHAR2\nIS\n    v_date_of_birth VARCHAR2(255);\n    v_age_years NUMBER;\nBEGIN\n    SELECT DATE_OF_BIRTH INTO v_date_of_birth FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    v_age_years := EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM TO_DATE(v_date_of_birth, 'YYYY-MM-DD HH24:MI:SS'));\n    IF v_age_years < 18 THEN\n        RETURN 'MINOR';\n    ELSIF v_age_years < 25 THEN\n        RETURN 'YOUNG_ADULT';\n    ELSIF v_age_years < 40 THEN\n        RETURN 'ADULT';\n    ELSIF v_age_years < 60 THEN\n        RETURN 'MIDDLE_AGED';\n    ELSE\n        RETURN 'SENIOR';\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "SELECT calculate_customer_age_group(1) FROM DUAL",
      "SELECT calculate_customer_age_group(3) FROM DUAL",
      "SELECT calculate_customer_age_group(4) FROM DUAL",
      "SELECT calculate_customer_age_group(13) FROM DUAL",
      "SELECT calculate_customer_age_group(10) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_customer_age_group that takes a customer ID and returns an age group string. It retrieves the customer's date of birth from the CUSTOMERS table, calculates their age in years, and returns: 'MINOR' if age < 18, 'YOUNG_ADULT' if < 25, 'ADULT' if < 40, 'MIDDLE_AGED' if < 60, else 'SENIOR'.",
    "natural_language": "Write a PL/SQL function called calculate_customer_age_group that accepts a customer ID and outputs an age group string. Fetch the customer's date of birth from the CUSTOMERS table, determine their age in years, and return 'MINOR' for age under 18, 'YOUNG_ADULT' for under 25, 'ADULT' for under 40, 'MIDDLE_AGED' for under 60, and 'SENIOR' for all other cases.",
    "id": 27
  },
  {
    "ir": "Write an Oracle PL/SQL function named determine_payment_status that accepts a single input parameter p_customer_id of type NUMBER and returns a VARCHAR2 string. The function first declares three local variables: v_total_outstanding of type NUMBER, v_last_payment_date of type VARCHAR2 with a length of 255, and v_days_since_payment of type NUMBER. The function's logic begins by executing a SELECT statement to retrieve the AMOUNT_OUTSTANDING column value from the CUSTOMERS table for the specific row where the CUSTOMER_ID column equals the input parameter p_customer_id, storing this result into the variable v_total_outstanding. It then executes a second SELECT statement to retrieve the maximum value of the DATETIME_PAYMENT column from the CUSTOMER_PAYMENTS table for all rows where the CUSTOMER_ID column equals p_customer_id, storing this result into the variable v_last_payment_date. The function then uses a conditional IF statement to check if the retrieved v_last_payment_date is NULL; if true, it assigns the value 999 to the variable v_days_since_payment. If v_last_payment_date is not NULL, it calculates v_days_since_payment by first using the TRUNC function on the CURRENT_TIMESTAMP to get the current date without a time component, then using the TO_DATE function to convert the string in v_last_payment_date into a date using the format model 'YYYY-MM-DD HH24:MI:SS', applying the TRUNC function to that date to also remove its time component, and finally subtracting the truncated payment date from the truncated current date. The core business logic is implemented with a series of nested IF-ELSIF-ELSE conditional statements: first, it checks if v_total_outstanding equals 0, and if true, returns the string 'PAID_IN_FULL'. If not, it checks if v_total_outstanding is less than 1000 AND v_days_since_payment is less than 30, and if true, returns the string 'CURRENT'. If not, it checks if v_total_outstanding is greater than 5000 AND v_days_since_payment is greater than 60, and if true, returns the string 'DELINQUENT'. If none of the previous conditions are met, the function executes the final ELSE clause and returns the string 'OVERDUE'.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_payment_status(p_customer_id NUMBER) RETURN VARCHAR2\nIS\n    v_total_outstanding NUMBER;\n    v_last_payment_date VARCHAR2(255);\n    v_days_since_payment NUMBER;\nBEGIN\n    SELECT AMOUNT_OUTSTANDING INTO v_total_outstanding FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    SELECT MAX(DATETIME_PAYMENT) INTO v_last_payment_date FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = p_customer_id;\n    IF v_last_payment_date IS NULL THEN\n        v_days_since_payment := 999;\n    ELSE\n        v_days_since_payment := TRUNC(CURRENT_TIMESTAMP) - TRUNC(TO_DATE(v_last_payment_date, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\n    IF v_total_outstanding = 0 THEN\n        RETURN 'PAID_IN_FULL';\n    ELSIF v_total_outstanding < 1000 AND v_days_since_payment < 30 THEN\n        RETURN 'CURRENT';\n    ELSIF v_total_outstanding > 5000 AND v_days_since_payment > 60 THEN\n        RETURN 'DELINQUENT';\n    ELSE\n        RETURN 'OVERDUE';\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "SELECT determine_payment_status(1) FROM DUAL",
      "SELECT determine_payment_status(3) FROM DUAL",
      "SELECT determine_payment_status(4) FROM DUAL",
      "SELECT determine_payment_status(11) FROM DUAL",
      "SELECT determine_payment_status(2) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named determine_payment_status that takes a customer ID and returns a payment status string. It retrieves the outstanding amount from the CUSTOMERS table and the last payment date from the CUSTOMER_PAYMENTS table. It calculates days since the last payment (999 if no payment). Return 'PAID_IN_FULL' if outstanding is 0, 'CURRENT' if outstanding < 1000 and days < 30, 'DELINQUENT' if outstanding > 5000 and days > 60, else 'OVERDUE'.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be named determine_payment_status, which is designed to accept a specific customer ID as its input parameter and subsequently provide a detailed textual status regarding payment. This function meticulously fetches the precise outstanding balance from the detailed CUSTOMERS table and also retrieves the exact date of the most recent transaction from the meticulously maintained CUSTOMER_PAYMENTS table. It then expertly computes the total number of days that have elapsed since that final payment, gracefully defaulting to a value of 999 days in scenarios where no prior payment history is found. The function will thoughtfully return the status 'PAID_IN_FULL' if the outstanding amount is definitively zero, 'CURRENT' if the outstanding balance is comfortably under 1000 units and the duration since the last payment is less than 30 days, 'DELINQUENT' for cases where the outstanding sum exceeds 5000 units and the period since the last payment is regrettably more than 60 days, and in all other circumstances, it will cautiously return the status 'OVERDUE'.",
    "id": 28
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_gymnast_name_by_id that accepts a single input parameter gymnast_id of type NUMBER, which represents the unique identifier of a gymnast. The function is designed to return a value of type VARCHAR2, specifically the name of the gymnast associated with the provided gymnast_id. Within the function, declare a local variable gymnast_name of type VARCHAR2 with a maximum length of 255 characters to store the name of the gymnast. Begin the function logic by checking if the input parameter gymnast_id is not NULL. If gymnast_id is not NULL, execute a SELECT statement to retrieve the NAME column from the PEOPLE table where the PEOPLE_ID column matches the value of gymnast_id. Assign the result of this query to the gymnast_name variable. If the gymnast_id is NULL, the SELECT statement is not executed, and the function proceeds to return the current value of gymnast_name, which would be NULL if no assignment has occurred. The function concludes by returning the value stored in gymnast_name, which is either the name of the gymnast corresponding to the provided gymnast_id or NULL if no such gymnast exists or if the input parameter was NULL.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_name_by_id(gymnast_id IN NUMBER) RETURN VARCHAR2 IS\n  gymnast_name VARCHAR2(255);\nBEGIN\n  IF gymnast_id IS NOT NULL THEN\n    SELECT NAME INTO gymnast_name FROM PEOPLE WHERE PEOPLE_ID = gymnast_id;\n  END IF;\n  RETURN gymnast_name;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT get_gymnast_name_by_id(1) FROM DUAL",
      "SELECT get_gymnast_name_by_id(2) FROM DUAL",
      "SELECT get_gymnast_name_by_id(4) FROM DUAL",
      "SELECT get_gymnast_name_by_id(gymnast_id) FROM GYMNAST WHERE GYMNAST_ID = 1",
      "SELECT NAME, get_gymnast_name_by_id(PEOPLE_ID) FROM PEOPLE WHERE PEOPLE_ID = 3"
    ],
    "summary": "Create a PL/SQL function named get_gymnast_name_by_id that accepts a gymnast_id NUMBER and returns the gymnast's name (VARCHAR2) from the PEOPLE table where PEOPLE_ID matches the input. Return NULL if the ID is NULL or no match is found.",
    "natural_language": "Function get_gymnast_name_by_id: takes gymnast_id NUMBER, returns name VARCHAR2 from PEOPLE where PEOPLE_ID matches. Return NULL for NULL or no match.",
    "id": 29
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_gymnast_age_by_id` that is designed to retrieve the age of a gymnast based on their unique identifier. This function accepts one input parameter: `gymnast_id`, which is of data type `NUMBER` and represents the unique identifier for a gymnast. The function is declared to return a single value of data type `NUMBER`, which will represent the age of the gymnast. Inside the function's executable block, a local variable named `gymnast_age` of data type `NUMBER` is declared to temporarily store the retrieved age. The function then proceeds with a conditional check: it evaluates whether the `gymnast_id` input parameter is not null. If `gymnast_id` is determined to be not null, the function executes a `SELECT` statement. This `SELECT` statement retrieves the value from the `AGE` column from the `PEOPLE` table. The retrieved `AGE` value is then assigned to the local variable `gymnast_age`. This selection is performed under a specific condition: the `PEOPLE_ID` column in the `PEOPLE` table must be equal to the value provided by the `gymnast_id` input parameter. If the `gymnast_id` input parameter is null, the `SELECT` statement is skipped, and the `gymnast_age` variable retains its default uninitialized value (which is `NULL` in PL/SQL for `NUMBER` types). Finally, the function returns the current value stored in the `gymnast_age` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_age_by_id(gymnast_id IN NUMBER) RETURN NUMBER IS\n  gymnast_age NUMBER;\nBEGIN\n  IF gymnast_id IS NOT NULL THEN\n    SELECT AGE INTO gymnast_age FROM PEOPLE WHERE PEOPLE_ID = gymnast_id;\n  END IF;\n  RETURN gymnast_age;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT get_gymnast_age_by_id(1) FROM dual",
      "SELECT get_gymnast_age_by_id(2) FROM dual",
      "SELECT get_gymnast_age_by_id(3) FROM dual",
      "SELECT get_gymnast_age_by_id(4) FROM dual",
      "SELECT get_gymnast_age_by_id(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_gymnast_age_by_id that accepts a gymnast_id NUMBER and returns the gymnast's age (NUMBER) from the AGE column in the PEOPLE table where PEOPLE_ID matches the input. Return NULL if the ID is NULL or no match is found.",
    "natural_language": "Function get_gymnast_age_by_id: takes gymnast_id, returns AGE from PEOPLE where PEOPLE_ID matches. Return NULL for NULL or no match.",
    "id": 30
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_gymnast_height_by_id that accepts a single input parameter gymnast_id of type NUMBER, which represents the unique identifier of a gymnast. The function is designed to return a value of type NUMBER, specifically the height of the gymnast associated with the provided gymnast_id. Within the function, a local variable gymnast_height of type NUMBER is declared to store the height of the gymnast. The function begins by checking if the input parameter gymnast_id is not NULL using an IF conditional statement. If gymnast_id is indeed not NULL, the function executes a SELECT statement to retrieve the HEIGHT column value from the PEOPLE table, where the PEOPLE_ID column matches the provided gymnast_id. The retrieved HEIGHT value is then stored in the local variable gymnast_height. After the conditional logic, the function concludes by returning the value stored in gymnast_height, which represents the height of the specified gymnast.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_height_by_id(gymnast_id IN NUMBER) RETURN NUMBER IS\n  gymnast_height NUMBER;\nBEGIN\n  IF gymnast_id IS NOT NULL THEN\n    SELECT HEIGHT INTO gymnast_height FROM PEOPLE WHERE PEOPLE_ID = gymnast_id;\n  END IF;\n  RETURN gymnast_height;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT get_gymnast_height_by_id(1) FROM DUAL",
      "SELECT get_gymnast_height_by_id(2) FROM DUAL",
      "SELECT get_gymnast_height_by_id(3) FROM DUAL",
      "SELECT get_gymnast_height_by_id(4) FROM DUAL",
      "SELECT get_gymnast_height_by_id(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_gymnast_height_by_id that accepts a gymnast_id NUMBER and returns the gymnast's height (NUMBER) from the HEIGHT column in the PEOPLE table where PEOPLE_ID matches the input. Return NULL if the ID is NULL or no match is found.",
    "natural_language": "What is the height of the gymnast with the specified ID, retrieved from the PEOPLE table?",
    "id": 31
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_customers that takes no input parameters and returns a single numeric value, which is the total count of all rows in the CUSTOMER_MASTER_INDEX table; the function declares a local numeric variable v_count, executes a SELECT statement that uses the COUNT(*) aggregate function to calculate the total number of rows from the CUSTOMER_MASTER_INDEX table, stores the resulting count into the variable v_count, and then returns the value of v_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_customers\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM CUSTOMER_MASTER_INDEX;\n    RETURN v_count;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "ELECTORAL_REGISTER",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_total_customers FROM DUAL",
      "SELECT get_total_customers() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_total_customers;\n  DBMS_OUTPUT.PUT_LINE('Total customers: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total customers: ' || get_total_customers);\nEND;",
      "SELECT 'Total customers: ' || get_total_customers AS result FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_customers with no parameters that returns a NUMBER. The function should count all rows in the CUSTOMER_MASTER_INDEX table and return the total.",
    "natural_language": "Write a PL/SQL function called get_total_customers that doesn't take any inputs and gives back a NUMBER. It should figure out roughly how many entries are in the CUSTOMER_MASTER_INDEX table and return that approximate total count.",
    "id": 32
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_cross_ref_id` that is designed to return a single `NUMBER` value. This function declares a local variable `v_max_id` of type `NUMBER` to temporarily store the result of a database query. The core logic of the function involves executing a `SELECT` statement to retrieve the maximum value from the `CMI_CROSS_REF_ID` column within the `CMI_CROSS_REFERENCES` table. The `NVL` function is applied to the result of `MAX(CMI_CROSS_REF_ID)`, ensuring that if `MAX(CMI_CROSS_REF_ID)` returns `NULL` (which would happen if the `CMI_CROSS_REFERENCES` table is empty or if all `CMI_CROSS_REF_ID` values are `NULL`), the value `0` is returned instead. The result of this `SELECT` statement, whether it's the actual maximum ID or `0`, is then stored into the `v_max_id` variable. After successfully retrieving and storing the maximum ID, the function returns the value held in `v_max_id`. The function includes an exception handling block. Specifically, if a `NO_DATA_FOUND` exception occurs during the `SELECT` statement (though this is unlikely given the `NVL` function and `MAX` aggregate, which always return a value, even `NULL` if no rows exist), the function will return `0`. For any other exceptions that might occur during its execution, the function will re-raise the original exception, propagating it to the calling environment.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_cross_ref_id\nRETURN NUMBER\nIS\n    v_max_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(CMI_CROSS_REF_ID), 0)\n    INTO v_max_id\n    FROM CMI_CROSS_REFERENCES;\n    \n    RETURN v_max_id;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "ELECTORAL_REGISTER",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_max_cross_ref_id FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_max_cross_ref_id that returns a NUMBER. It should retrieve the maximum CMI_CROSS_REF_ID from the CMI_CROSS_REFERENCES table, returning 0 if the result is NULL or no data is found. Include exception handling to return 0 for NO_DATA_FOUND and re-raise any other exceptions.",
    "natural_language": "What is the PL/SQL function definition for get_max_cross_ref_id that returns a NUMBER, retrieves the maximum CMI_CROSS_REF_ID from the CMI_CROSS_REFERENCES table, returns 0 for a NULL result or no data, and includes exception handling to return 0 for NO_DATA_FOUND while re-raising other exceptions?",
    "id": 33
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_rent_system_count that returns a NUMBER data type. This function initializes a local variable v_count of type NUMBER to store the result of a query. It performs a SELECT operation to count the total number of rows in the CMI_CROSS_REFERENCES table where the SOURCE_SYSTEM_CODE column, after being processed by the NVL function to replace any NULL values with a single space character and then trimmed of any leading or trailing spaces using the TRIM function, equals the string 'Rent'. The result of this count is stored in the v_count variable. The function then returns the value of v_count. If any exception occurs during the execution of the function, the exception handler catches it and returns 0.",
    "plsql": "CREATE OR REPLACE FUNCTION get_rent_system_count\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM CMI_CROSS_REFERENCES\n    WHERE TRIM(NVL(SOURCE_SYSTEM_CODE, ' ')) = 'Rent';\n    \n    RETURN v_count;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN 0;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "ELECTORAL_REGISTER",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_rent_system_count FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_rent_system_count that returns a NUMBER. It counts rows from the CMI_CROSS_REFERENCES table where the trimmed and space-replaced NULL values in SOURCE_SYSTEM_CODE equal 'Rent'. Return the count, or 0 if an exception occurs.",
    "natural_language": "Create function get_rent_system_count returning NUMBER. Count CMI_CROSS_REFERENCES rows where trimmed, space-replaced NULLs in SOURCE_SYSTEM_CODE equal 'Rent'. Return count or 0 on exception.",
    "id": 34
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_council_tax_total` that is designed to return a single numeric value. This function does not accept any input parameters. Upon execution, it declares a local variable named `v_total` of type `NUMBER` to temporarily store the calculated sum. The core operation involves executing a `SELECT` statement to query the `COUNCIL_TAX` table. Within this `SELECT` statement, it calculates the sum of all values in the `COUNCIL_TAX_ID` column. The `NVL` (Null Value Logic) function is applied to the `SUM(COUNCIL_TAX_ID)` result, ensuring that if the `SUM` operation returns `NULL` (which would happen if the `COUNCIL_TAX` table is empty or if all `COUNCIL_TAX_ID` values are `NULL`), the `NVL` function will substitute `0` instead of `NULL`. The result of this `SUM` (or `0` if `NULL`) is then stored into the `v_total` variable. After successfully calculating and storing the sum, the function returns the value currently held in `v_total`. The function also includes an exception handling block. If any unhandled exception occurs during the execution of the `SELECT` statement or any other part of the `BEGIN...END` block, the `WHEN OTHERS` clause will catch it, and in such an event, the function will return the numeric value `0` instead of the calculated sum.",
    "plsql": "CREATE OR REPLACE FUNCTION get_council_tax_total\nRETURN NUMBER\nIS\n    v_total NUMBER;\nBEGIN\n    SELECT NVL(SUM(COUNCIL_TAX_ID), 0)\n    INTO v_total\n    FROM COUNCIL_TAX;\n    \n    RETURN v_total;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN 0;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "ELECTORAL_REGISTER",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_council_tax_total FROM DUAL",
      "SELECT get_council_tax_total() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_council_tax_total;\n  DBMS_OUTPUT.PUT_LINE('Total: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Council Tax Total: ' || get_council_tax_total);\nEND;",
      "SELECT get_council_tax_total AS total_sum FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_council_tax_total that returns a NUMBER with no parameters. It sums the COUNCIL_TAX_ID column from the COUNCIL_TAX table, returning 0 for NULL or empty results. Return the sum, or 0 if an exception occurs.",
    "natural_language": "Write a PL/SQL function get_council_tax_total with no parameters returning NUMBER. Sum COUNCIL_TAX_ID from COUNCIL_TAX. Return sum, 0 for NULL/empty, or 0 on exception.",
    "id": 35
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_festival_participation that accepts a single parameter p_artist_id of type NUMBER, which represents the unique identifier of an artist. The function returns a NUMBER that indicates the count of distinct music festivals in which the specified artist has participated. Within the function, a local variable v_count of type NUMBER is declared to store the result of the query operation. The function performs a SELECT statement that counts the distinct occurrences of the ID column from the MUSIC_FESTIVAL table, which represents unique music festival identifiers. This count is stored into the v_count variable. The MUSIC_FESTIVAL table is joined with the VOLUME table using the VOLUME column from MUSIC_FESTIVAL and the VOLUME_ID column from VOLUME, establishing a relationship between music festivals and their respective volumes. The WHERE clause filters the results to include only those rows where the ARTIST_ID column in the VOLUME table matches the value of the input parameter p_artist_id, thereby ensuring that only festivals associated with the specified artist are considered. Finally, the function returns the value stored in v_count, which represents the total number of distinct music festivals associated with the given artist ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_festival_participation(p_artist_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT mf.ID)\n    INTO v_count\n    FROM MUSIC_FESTIVAL mf\n    JOIN VOLUME v ON mf.VOLUME = v.VOLUME_ID\n    WHERE v.ARTIST_ID = p_artist_id;\n    RETURN v_count;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_artist_festival_participation(1) FROM DUAL",
      "SELECT get_artist_festival_participation(2) FROM DUAL",
      "SELECT get_artist_festival_participation(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_artist_festival_participation that accepts a p_artist_id NUMBER and returns a NUMBER. It counts distinct music festival IDs from the MUSIC_FESTIVAL table joined with the VOLUME table where the VOLUME.ARTIST_ID matches the input parameter.",
    "natural_language": "Function get_artist_festival_participation(p_artist_id NUMBER) returns NUMBER. Count distinct festival IDs for the given artist from MUSIC_FESTIVAL and VOLUME.",
    "id": 36
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_festival_award_count that accepts a single parameter, p_festival_id, of type NUMBER, which represents the unique identifier of a music festival. The function is designed to return a NUMBER that indicates the count of awards associated with the specified festival. Within the function, a local variable v_award_count of type NUMBER is declared to store the result of the query operation. The function executes a SELECT statement that counts the number of rows in the MUSIC_FESTIVAL table where the ID column matches the value of the p_festival_id parameter and the RESULT column has the value 'Awarded'. The COUNT(*) function is used to determine the total number of such rows, and the result is stored in the v_award_count variable. Finally, the function returns the value of v_award_count, which represents the total number of awards for the given festival ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_festival_award_count(p_festival_id NUMBER) RETURN NUMBER IS\n    v_award_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_award_count\n    FROM MUSIC_FESTIVAL\n    WHERE ID = p_festival_id AND RESULT = 'Awarded';\n    RETURN v_award_count;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_festival_award_count(1) FROM DUAL",
      "SELECT get_festival_award_count(2) FROM DUAL",
      "SELECT get_festival_award_count(3) FROM DUAL",
      "SELECT get_festival_award_count(10) FROM DUAL",
      "SELECT get_festival_award_count(ID) FROM MUSIC_FESTIVAL WHERE ID = 1"
    ],
    "summary": "Create a PL/SQL function named get_festival_award_count that accepts a p_festival_id NUMBER and returns a NUMBER. It counts rows in the MUSIC_FESTIVAL table where the ID matches the input and the RESULT column equals 'Awarded'.",
    "natural_language": "Function get_festival_award_count(p_festival_id NUMBER) returns NUMBER. Count MUSIC_FESTIVAL rows where ID matches input and RESULT is 'Awarded'.",
    "id": 37
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_artist_song_count` that accepts a single input parameter, `p_artist_id`, which is of data type `NUMBER` and represents the unique identifier for an artist. This function is designed to return a single value of data type `NUMBER`, which will represent the total count of songs associated with the specified artist. Upon execution, the function declares a local variable named `v_song_count` of data type `NUMBER` to temporarily store the calculated song count. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `VOLUME` table. Specifically, it performs a `COUNT(*)` aggregation, which counts all rows that satisfy the specified condition. The result of this count operation is then immediately stored into the `v_song_count` local variable using the `INTO` clause. The `WHERE` clause of the `SELECT` statement filters the rows from the `VOLUME` table, ensuring that only those rows where the value in the `ARTIST_ID` column is exactly equal to the value provided in the input parameter `p_artist_id` are included in the count. Finally, the function returns the value currently held in the `v_song_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_song_count(p_artist_id NUMBER) RETURN NUMBER IS\n    v_song_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_song_count\n    FROM VOLUME\n    WHERE ARTIST_ID = p_artist_id;\n    RETURN v_song_count;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_artist_song_count(1) FROM DUAL",
      "SELECT get_artist_song_count(2) FROM DUAL",
      "SELECT get_artist_song_count(4) FROM DUAL",
      "SELECT get_artist_song_count(999) FROM DUAL",
      "SELECT get_artist_song_count(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_artist_song_count that accepts a p_artist_id NUMBER and returns a NUMBER. It counts all rows in the VOLUME table where the ARTIST_ID column equals the input parameter.",
    "natural_language": "Count the songs for a specific artist by writing a PL/SQL function called get_artist_song_count. The function should take an artist ID as a NUMBER input and return the total NUMBER of entries in the VOLUME table that match that ARTIST_ID.",
    "id": 38
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_famous_title_count that accepts a single input parameter p_artist_id of the NUMBER data type and returns a value of the NUMBER data type, which is designed to calculate and return the count of famous titles associated with a specific artist. The function declares a local variable v_title_count of type NUMBER to store the result. The core operation is a SELECT statement that queries the ARTIST table, using the COUNT(*) aggregate function to count all rows. This count is performed with a WHERE clause that specifies two conditions: the ARTIST_ID column must exactly equal the provided input parameter p_artist_id, and the FAMOUS_TITLE column for that row must not be NULL, as checked by the IS NOT NULL condition. The result of this count is retrieved from the database and stored directly into the local variable v_title_count using the INTO clause. Finally, the function concludes by returning the value stored in v_title_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_famous_title_count(p_artist_id NUMBER) RETURN NUMBER IS\n    v_title_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_title_count\n    FROM ARTIST\n    WHERE ARTIST_ID = p_artist_id AND FAMOUS_TITLE IS NOT NULL;\n    RETURN v_title_count;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_artist_famous_title_count(1) FROM DUAL",
      "SELECT get_artist_famous_title_count(2) FROM DUAL",
      "SELECT get_artist_famous_title_count(4) FROM DUAL",
      "SELECT get_artist_famous_title_count(99) FROM DUAL",
      "SELECT get_artist_famous_title_count(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_artist_famous_title_count that takes an artist ID (NUMBER) and returns the count (NUMBER) of rows for that artist where the FAMOUS_TITLE column is not NULL.",
    "natural_language": "Write a PL/SQL function to get a rough number of notable works for a particular artist, based on their ID. The function should count how many entries for that artist have something filled in the column for famous titles.",
    "id": 39
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_discounted_price that accepts a single parameter, p_entry_id, of type NUMBER, which represents the identifier of a catalog entry. The function retrieves the price of the catalog entry from the CATALOG_CONTENTS table by selecting the PRICE_IN_DOLLARS column where the CATALOG_ENTRY_ID matches the provided p_entry_id. The retrieved price is stored in a local variable v_price of type NUMBER. The function then determines a discount rate based on the value of v_price using conditional logic: if v_price is greater than 500, the discount rate v_discount is set to 0.8; if v_price is greater than 300, v_discount is set to 0.85; if v_price is greater than 100, v_discount is set to 0.9; otherwise, v_discount is set to 1.0, indicating no discount. The function calculates the discounted price by multiplying v_price by v_discount and rounds the result to two decimal places using the ROUND function. Finally, the function returns the rounded discounted price as a NUMBER.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_discounted_price(p_entry_id NUMBER) RETURN NUMBER IS\n    v_discount NUMBER;\n    v_price NUMBER;\nBEGIN\n    SELECT PRICE_IN_DOLLARS INTO v_price FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_price > 500 THEN v_discount := 0.8;\n    ELSIF v_price > 300 THEN v_discount := 0.85;\n    ELSIF v_price > 100 THEN v_discount := 0.9;\n    ELSE v_discount := 1.0;\n    END IF;\n    RETURN ROUND(v_price * v_discount, 2);\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT calculate_discounted_price(1) FROM DUAL",
      "SELECT calculate_discounted_price(2) FROM DUAL",
      "SELECT calculate_discounted_price(3) FROM DUAL",
      "SELECT CATALOG_ENTRY_ID, PRICE_IN_DOLLARS, calculate_discounted_price(CATALOG_ENTRY_ID) AS DISCOUNTED_PRICE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = 1",
      "SELECT CATALOG_ENTRY_ID, CATALOG_ENTRY_NAME, PRICE_IN_DOLLARS, calculate_discounted_price(CATALOG_ENTRY_ID) FROM CATALOG_CONTENTS WHERE PRICE_IN_DOLLARS > 100"
    ],
    "summary": "Create a PL/SQL function named calculate_discounted_price that takes a catalog entry ID (NUMBER) and returns the discounted price (NUMBER). Apply a discount based on the original price: 20% off for prices over 500, 15% off for over 300, 10% off for over 100, and no discount otherwise. Round the final price to two decimal places.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be named calculate_discounted_price, which is designed to accept a single input parameter—specifically a catalog entry ID of the NUMBER data type—and subsequently returns a calculated discounted price, also as a NUMBER. This function should meticulously apply a tiered discount structure to the original price associated with the provided ID: a substantial twenty percent reduction is granted for any price exceeding 500, a fifteen percent discount is applied for prices greater than 300, a ten percent discount is offered for prices over 100, and, in all other cases, no discount is applied whatsoever. Finally, the computed final price must be precisely rounded to exactly two decimal places for accuracy.",
    "id": 40
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_volume_category that accepts a single input parameter p_entry_id of type NUMBER, which represents the identifier of a catalog entry. The function returns a value of type VARCHAR2. Within the function, declare two local variables: v_capacity of type VARCHAR2(255) and v_category of type VARCHAR2(20). The function begins by executing a SELECT statement to retrieve the CAPACITY column value from the CATALOG_CONTENTS table, where the CATALOG_ENTRY_ID column matches the value of the input parameter p_entry_id. The retrieved CAPACITY value is stored in the v_capacity variable. The function then evaluates the value of v_capacity using a series of conditional statements. If v_capacity equals '8', the function assigns the string 'LARGE' to the v_category variable. If v_capacity equals '5', it assigns 'MEDIUM' to v_category. If v_capacity equals '1', it assigns 'SMALL' to v_category. If none of these conditions are met, the function assigns 'UNKNOWN' to v_category. Finally, the function returns the value of v_category, which represents the category of the volume based on its capacity.",
    "plsql": "CREATE OR REPLACE FUNCTION get_volume_category(p_entry_id NUMBER) RETURN VARCHAR2 IS\n    v_capacity VARCHAR2(255);\n    v_category VARCHAR2(20);\nBEGIN\n    SELECT CAPACITY INTO v_capacity FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_capacity = '8' THEN v_category := 'LARGE';\n    ELSIF v_capacity = '5' THEN v_category := 'MEDIUM';\n    ELSIF v_capacity = '1' THEN v_category := 'SMALL';\n    ELSE v_category := 'UNKNOWN';\n    END IF;\n    RETURN v_category;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT get_volume_category(1) FROM DUAL",
      "SELECT get_volume_category(2) FROM DUAL",
      "SELECT get_volume_category(3) FROM DUAL",
      "SELECT CATALOG_ENTRY_ID, CAPACITY, get_volume_category(CATALOG_ENTRY_ID) AS VOLUME_CATEGORY FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = 1",
      "SELECT CATALOG_ENTRY_ID, CATALOG_ENTRY_NAME, get_volume_category(CATALOG_ENTRY_ID) FROM CATALOG_CONTENTS WHERE CAPACITY IN ('1', '5', '8')"
    ],
    "summary": "Create a PL/SQL function named get_volume_category that takes a catalog entry ID (NUMBER) and returns a category string (VARCHAR2). The category is determined by the entry's CAPACITY: 'LARGE' for '8', 'MEDIUM' for '5', 'SMALL' for '1', and 'UNKNOWN' for any other value.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_volume_category? It should take a catalog entry ID (that's a NUMBER) and spit back a category as a string (VARCHAR2). Basically, we need to figure out the category based on the entry's CAPACITY: if it's '8', call it 'LARGE'; if it's '5', that's 'MEDIUM'; if it's '1', that's 'SMALL'; and for anything else, just say 'UNKNOWN'.",
    "id": 41
  },
  {
    "ir": "Write an Oracle PL/SQL function named determine_best_currency that accepts a single input parameter p_entry_id of type NUMBER, which represents a catalog entry identifier, and returns a VARCHAR2 string. The function begins by declaring local variables v_euro_price and v_pound_price, both of type NUMBER, and v_currency of type VARCHAR2(10). It executes a SELECT statement to query the CATALOG_CONTENTS table, retrieving the PRICE_IN_EUROS and PRICE_IN_POUNDS column values for the specific row where the CATALOG_ENTRY_ID column equals the provided p_entry_id parameter, and stores these values into the v_euro_price and v_pound_price variables respectively. Following the data retrieval, the function uses a conditional IF-ELSIF-ELSE block to determine the return value. The first condition checks if v_euro_price is less than v_pound_price AND if v_euro_price is also less than 200; if true, it assigns the string 'EUR_CHEAP' to v_currency. If the first condition is false, the first ELSIF condition checks if v_pound_price is less than v_euro_price AND if v_pound_price is less than 200; if true, it assigns 'GBP_CHEAP' to v_currency. If the second condition is also false, the next ELSIF condition checks if v_euro_price is less than v_pound_price (without the price being under 200); if true, it assigns 'EUR' to v_currency. If none of the preceding conditions are met, the final ELSE block assigns 'GBP' to v_currency. The function concludes by returning the value stored in the v_currency variable.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_best_currency(p_entry_id NUMBER) RETURN VARCHAR2 IS\n    v_euro_price NUMBER;\n    v_pound_price NUMBER;\n    v_currency VARCHAR2(10);\nBEGIN\n    SELECT PRICE_IN_EUROS, PRICE_IN_POUNDS INTO v_euro_price, v_pound_price FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_euro_price < v_pound_price AND v_euro_price < 200 THEN v_currency := 'EUR_CHEAP';\n    ELSIF v_pound_price < v_euro_price AND v_pound_price < 200 THEN v_currency := 'GBP_CHEAP';\n    ELSIF v_euro_price < v_pound_price THEN v_currency := 'EUR';\n    ELSE v_currency := 'GBP';\n    END IF;\n    RETURN v_currency;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT determine_best_currency(1) FROM dual",
      "SELECT determine_best_currency(2) FROM dual",
      "SELECT determine_best_currency(3) FROM dual",
      "SELECT determine_best_currency(5) FROM dual",
      "SELECT determine_best_currency(6) FROM dual"
    ],
    "summary": "Create a PL/SQL function named determine_best_currency that takes a catalog entry ID (NUMBER) and returns a currency recommendation (VARCHAR2). Compare the entry's PRICE_IN_EUROS and PRICE_IN_POUNDS. Return 'EUR_CHEAP' if the Euro price is lower than the Pound price and under 200, 'GBP_CHEAP' if the Pound price is lower and under 200, 'EUR' if only the Euro price is lower, otherwise return 'GBP'.",
    "natural_language": "Make function determine_best_currency. Input: catalog ID (NUMBER). Output: currency (VARCHAR2). Compare PRICE_IN_EUROS and PRICE_IN_POUNDS. Return 'EUR_CHEAP' if Euro cheaper and <200, 'GBP_CHEAP' if Pound cheaper and <200, 'EUR' if only Euro cheaper, else 'GBP'.",
    "id": 42
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_size_score that accepts a single parameter p_entry_id of type NUMBER, which represents the identifier of a catalog entry. The function retrieves the LENGTH and HEIGHT values from the CATALOG_CONTENTS table where the CATALOG_ENTRY_ID matches the provided p_entry_id. These values are stored in local variables v_length and v_height, both of type VARCHAR2 with a maximum length of 255 characters. The function then evaluates these values using a series of conditional statements. If both v_length and v_height are equal to '9', the function assigns a score of 10 to the local variable v_score of type NUMBER. If v_length is '6' and v_height is '5', v_score is set to 7. If v_length is '3' and v_height is '7', v_score is set to 5. For all other combinations of v_length and v_height, v_score is assigned a default value of 3. Finally, the function returns the computed score stored in v_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_size_score(p_entry_id NUMBER) RETURN NUMBER IS\n    v_length VARCHAR2(255);\n    v_height VARCHAR2(255);\n    v_score NUMBER;\nBEGIN\n    SELECT LENGTH, HEIGHT INTO v_length, v_height FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_length = '9' AND v_height = '9' THEN v_score := 10;\n    ELSIF v_length = '6' AND v_height = '5' THEN v_score := 7;\n    ELSIF v_length = '3' AND v_height = '7' THEN v_score := 5;\n    ELSE v_score := 3;\n    END IF;\n    RETURN v_score;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT calculate_size_score(1) FROM DUAL",
      "SELECT calculate_size_score(2) FROM DUAL",
      "SELECT calculate_size_score(3) FROM DUAL",
      "SELECT CATALOG_ENTRY_ID, calculate_size_score(CATALOG_ENTRY_ID) AS SIZE_SCORE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = 1",
      "SELECT CC.*, calculate_size_score(CC.CATALOG_ENTRY_ID) AS SIZE_SCORE FROM CATALOG_CONTENTS CC WHERE CC.LENGTH = '9' AND CC.HEIGHT = '9'"
    ],
    "summary": "Create a PL/SQL function named calculate_size_score that takes a catalog entry ID (NUMBER) and returns a score (NUMBER). The score is based on the entry's LENGTH and HEIGHT values: 10 for ('9','9'), 7 for ('6','5'), 5 for ('3','7'), and 3 for all other combinations.",
    "natural_language": "Please construct a PL/SQL function designated as `calculate_size_score`. This function shall accept a single input parameter of type NUMBER, specifically a catalog entry identifier, and shall return a computed score, also of type NUMBER. The scoring logic is to be derived from the LENGTH and HEIGHT attributes associated with the provided entry. The function must implement the following conditional mapping: a score of 10 is to be returned for the combination ('9', '9'); a score of 7 for ('6', '5'); and a score of 5 for ('3', '7'). For any other combination of LENGTH and HEIGHT values, the function must return a score of 3.",
    "id": 43
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_price_tier` that accepts a single input parameter, `p_entry_id`, which is of data type `NUMBER` and represents a unique identifier for a catalog entry. This function is designed to return a `VARCHAR2` value with a maximum length of 15 characters, indicating the price tier of the catalog entry.\n\nUpon execution, the function first declares two local variables: `v_dollar_price` of data type `NUMBER` to store the price of the catalog entry, and `v_tier` of data type `VARCHAR2` with a maximum length of 15 characters to store the determined price tier.\n\nThe function then performs a `SELECT` operation to retrieve the `PRICE_IN_DOLLARS` column value from the `CATALOG_CONTENTS` table. This retrieval is conditioned on matching the `CATALOG_ENTRY_ID` column in the `CATALOG_CONTENTS` table with the value provided in the input parameter `p_entry_id`. The retrieved `PRICE_IN_DOLLARS` value is then stored into the local variable `v_dollar_price`.\n\nFollowing the data retrieval, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) based on the value stored in `v_dollar_price` to determine the appropriate price tier:\n1. If the value of `v_dollar_price` is strictly greater than 600, the local variable `v_tier` is assigned the string literal 'PREMIUM'.\n2. Otherwise, if the value of `v_dollar_price` is strictly greater than 400, the local variable `v_tier` is assigned the string literal 'MID_RANGE'.\n3. Otherwise, if the value of `v_dollar_price` is strictly greater than 200, the local variable `v_tier` is assigned the string literal 'STANDARD'.\n4. In all other cases (i.e., if `v_dollar_price` is less than or equal to 200), the local variable `v_tier` is assigned the string literal 'BUDGET'.\n\nFinally, the function returns the determined price tier, which is the value stored in the `v_tier` variable, as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_price_tier(p_entry_id NUMBER) RETURN VARCHAR2 IS\n    v_dollar_price NUMBER;\n    v_tier VARCHAR2(15);\nBEGIN\n    SELECT PRICE_IN_DOLLARS INTO v_dollar_price FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_dollar_price > 600 THEN v_tier := 'PREMIUM';\n    ELSIF v_dollar_price > 400 THEN v_tier := 'MID_RANGE';\n    ELSIF v_dollar_price > 200 THEN v_tier := 'STANDARD';\n    ELSE v_tier := 'BUDGET';\n    END IF;\n    RETURN v_tier;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT get_price_tier(1) FROM DUAL",
      "SELECT get_price_tier(2) FROM DUAL",
      "SELECT get_price_tier(3) FROM DUAL",
      "SELECT get_price_tier(4) FROM DUAL",
      "SELECT get_price_tier(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_price_tier that accepts a catalog entry ID (NUMBER) and returns a VARCHAR2(15) price tier. Retrieve the price from CATALOG_CONTENTS and classify it: >600 as 'PREMIUM', >400 as 'MID_RANGE', >200 as 'STANDARD', otherwise 'BUDGET'.",
    "natural_language": "Develop a PL/SQL function, which should be named get_price_tier, that is designed to accept a single input parameter: a catalog entry ID of the NUMBER data type. This function must return a price tier classification as a VARCHAR2 string with a maximum length of fifteen characters. To determine the appropriate tier, you must first retrieve the associated price value from the CATALOG_CONTENTS table. Subsequently, you should implement a detailed classification logic: if the price is found to be greater than 600, it should be categorized as 'PREMIUM'; if it is greater than 400, it should be labeled 'MID_RANGE'; if it exceeds 200, it should be designated 'STANDARD'; and for all other cases, the entry should be assigned the 'BUDGET' tier.",
    "id": 44
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_protein_avg_length_by_institution` that is designed to calculate and return the average sequence length of proteins based on specific criteria. This function accepts two input parameters: `p_institution_id`, which is of data type `VARCHAR2` and represents the unique identifier of an institution, and `p_divergence_threshold`, which is of data type `NUMBER` and represents a numerical threshold for the divergence from the human lineage. The function is declared to return a single value of data type `NUMBER`, which will be the calculated average length. Inside the function's `BEGIN` block, a local variable `v_avg_length` of data type `NUMBER` is declared to temporarily store the result of the aggregation. The core operation involves a `SELECT` statement that calculates the average of the `SEQUENCE_LENGTH` column. This average is computed from rows in the `PROTEIN` table. The selection of rows for this calculation is constrained by two conditions: first, the `INSTITUTION_ID` column in the `PROTEIN` table must exactly match the value provided by the `p_institution_id` input parameter; second, the `DIVERGENCE_FROM_HUMAN_LINEAGE` column in the `PROTEIN` table must have a value strictly greater than the `p_divergence_threshold` input parameter. The result of this `AVG` aggregation is then stored into the `v_avg_length` local variable using the `INTO` clause. Finally, the function returns the value stored in `v_avg_length` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_protein_avg_length_by_institution(p_institution_id VARCHAR2, p_divergence_threshold NUMBER) RETURN NUMBER IS\n    v_avg_length NUMBER;\nBEGIN\n    SELECT AVG(SEQUENCE_LENGTH) INTO v_avg_length FROM PROTEIN WHERE INSTITUTION_ID = p_institution_id AND DIVERGENCE_FROM_HUMAN_LINEAGE > p_divergence_threshold;\n    RETURN v_avg_length;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_protein_avg_length_by_institution('1', 300) FROM DUAL",
      "SELECT get_protein_avg_length_by_institution('3', 500) FROM DUAL",
      "SELECT get_protein_avg_length_by_institution('1', 400) FROM DUAL",
      "SELECT get_protein_avg_length_by_institution('3', 600) FROM DUAL",
      "SELECT get_protein_avg_length_by_institution('1', 700) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_protein_avg_length_by_institution that accepts an institution ID (VARCHAR2) and a divergence threshold (NUMBER). Return the average SEQUENCE_LENGTH from the PROTEIN table where INSTITUTION_ID matches and DIVERGENCE_FROM_HUMAN_LINEAGE exceeds the threshold.",
    "natural_language": "Write a PL/SQL function called get_protein_avg_length_by_institution that takes an institution ID and a divergence number. It should give back the typical SEQUENCE_LENGTH from the PROTEIN table for that institution, but only for entries where the DIVERGENCE_FROM_HUMAN_LINEAGE is more than a certain amount.",
    "id": 45
  },
  {
    "ir": "Write an Oracle PL/SQL function named `count_institutions_by_type_and_enrollment` that is designed to return a single numeric value. This function accepts two input parameters: `p_institution_type`, which is of data type `VARCHAR2` and represents the specific type of institution to be considered, and `p_min_enrollment`, which is of data type `NUMBER` and represents the minimum enrollment threshold for institutions. Internally, the function declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `INSTITUTION` table. Specifically, it performs a `COUNT(*)` aggregation, which calculates the total number of rows that satisfy a set of specified conditions. The conditions applied to filter the rows are: first, the `TYPE` column in the `INSTITUTION` table must exactly match the value provided by the `p_institution_type` input parameter; and second, the `ENROLLMENT` column in the `INSTITUTION` table must be greater than or equal to the value provided by the `p_min_enrollment` input parameter. The result of this `COUNT(*)` aggregation is then immediately assigned to the local variable `v_count`. Finally, the function returns the value stored in `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_institutions_by_type_and_enrollment(p_institution_type VARCHAR2, p_min_enrollment NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM INSTITUTION WHERE TYPE = p_institution_type AND ENROLLMENT >= p_min_enrollment;\n    RETURN v_count;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT count_institutions_by_type_and_enrollment('Private', 1000) FROM DUAL",
      "SELECT count_institutions_by_type_and_enrollment('Public', 3000) FROM DUAL",
      "SELECT count_institutions_by_type_and_enrollment('Tribal', 500) FROM DUAL",
      "SELECT count_institutions_by_type_and_enrollment('Private', 2000) FROM DUAL",
      "SELECT count_institutions_by_type_and_enrollment('Public', 1500) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named count_institutions_by_type_and_enrollment that accepts an institution type (VARCHAR2) and a minimum enrollment (NUMBER). Return the count of rows from the INSTITUTION table where TYPE matches and ENROLLMENT is greater than or equal to the minimum.",
    "natural_language": "Please construct a PL/SQL function designated as 'count_institutions_by_type_and_enrollment'. This function shall accept two parameters: an institution type, defined as a VARCHAR2, and a minimum enrollment threshold, defined as a NUMBER. The function's purpose is to return a numerical count of the records within the INSTITUTION table for which the TYPE column corresponds exactly to the provided type parameter and the ENROLLMENT column contains a value greater than or equal to the specified minimum.",
    "id": 46
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_building_for_protein that accepts two parameters: p_common_name of type VARCHAR2, which represents the common name of a protein, and p_min_floors of type NUMBER, which specifies the minimum number of floors a building must have. The function returns a VARCHAR2 value representing the name of a building. Within the function, a local variable v_building_name of type VARCHAR2 with a maximum length of 255 characters is declared to store the name of the building. The function executes a SELECT statement that retrieves the NAME column from the BUILDING table and assigns it to the v_building_name variable. This selection is performed by joining three tables: PROTEIN, INSTITUTION, and BUILDING. The PROTEIN table is joined with the INSTITUTION table using the INSTITUTION_ID column, and the INSTITUTION table is joined with the BUILDING table using the BUILDING_ID column. The WHERE clause of the SELECT statement filters the results by matching the COMMON_NAME column in the PROTEIN table with the p_common_name parameter and ensuring that the FLOORS column in the BUILDING table is greater than or equal to the p_min_floors parameter. After successfully retrieving the building name, the function returns the value stored in v_building_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_building_for_protein(p_common_name VARCHAR2, p_min_floors NUMBER) RETURN VARCHAR2 IS\n    v_building_name VARCHAR2(255);\nBEGIN\n    SELECT b.NAME INTO v_building_name FROM PROTEIN p JOIN INSTITUTION i ON p.INSTITUTION_ID = i.INSTITUTION_ID JOIN BUILDING b ON i.BUILDING_ID = b.BUILDING_ID WHERE p.COMMON_NAME = p_common_name AND b.FLOORS >= p_min_floors;\n    RETURN v_building_name;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_building_for_protein('Tropical Clawed Frog', 10) FROM DUAL",
      "SELECT get_building_for_protein('purple sea urchin', 15) FROM DUAL",
      "SELECT get_building_for_protein('body louse', 12) FROM DUAL",
      "SELECT get_building_for_protein('Tropical Clawed Frog', 5) FROM DUAL",
      "SELECT get_building_for_protein('purple sea urchin', 20) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_building_for_protein that accepts a protein common name (VARCHAR2) and a minimum floor count (NUMBER). Return the building NAME by joining PROTEIN, INSTITUTION, and BUILDING tables where the protein's COMMON_NAME matches and the building's FLOORS meet or exceed the minimum.",
    "natural_language": "What is the name of the building associated with a given protein common name, where the building has at least a specified number of floors?",
    "id": 47
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_height_per_floor that accepts two parameters: p_building_id of type VARCHAR2, which specifies the unique identifier of a building, and p_adjustment_factor of type NUMBER, which is used to adjust the calculated height per floor. The function returns a NUMBER representing the adjusted height per floor of the specified building. Within the function, a local variable v_height_per_floor of type NUMBER is declared to store the result of the calculation. The function executes a SELECT statement to retrieve the total height in feet (HEIGHT_FEET) and the number of floors (FLOORS) from the BUILDING table for the row where the BUILDING_ID column matches the provided p_building_id parameter. The SELECT statement calculates the height per floor by dividing the HEIGHT_FEET by the FLOORS and then multiplies the result by the p_adjustment_factor. The calculated value is stored in the v_height_per_floor variable. Finally, the function returns the value of v_height_per_floor as the result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_height_per_floor(p_building_id VARCHAR2, p_adjustment_factor NUMBER) RETURN NUMBER IS\n    v_height_per_floor NUMBER;\nBEGIN\n    SELECT HEIGHT_FEET / FLOORS * p_adjustment_factor INTO v_height_per_floor FROM BUILDING WHERE BUILDING_ID = p_building_id;\n    RETURN v_height_per_floor;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT calculate_height_per_floor('0', 1.0) FROM DUAL",
      "SELECT calculate_height_per_floor('1', 1.2) FROM DUAL",
      "SELECT calculate_height_per_floor('2', 0.9) FROM DUAL",
      "SELECT calculate_height_per_floor('0', 1.5) FROM DUAL",
      "SELECT calculate_height_per_floor('1', 0.8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_height_per_floor that accepts a building ID (VARCHAR2) and an adjustment factor (NUMBER). Return the adjusted height per floor by selecting the building's HEIGHT_FEET divided by FLOORS and multiplied by the factor from the BUILDING table where BUILDING_ID matches.",
    "natural_language": "Make a function calculate_height_per_floor. It takes a building ID and an adjustment factor. Return (HEIGHT_FEET / FLOORS) * factor for the matching building.",
    "id": 48
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_school_competition_status` that accepts a single input parameter, `p_school_id`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing the competition status of a school based on its entry year. Upon execution, the function first declares a local variable named `v_year_entered` of data type `NUMBER` to temporarily store the year a school entered a competition. Subsequently, it performs a `SELECT` operation to retrieve the value from the `year_entered_competition` column from the `school` table. This retrieval is conditional, specifically targeting the row where the `school_id` column matches the value provided by the input parameter `p_school_id`. The retrieved `year_entered_competition` value is then immediately stored into the `v_year_entered` local variable. Following this data retrieval, the function proceeds with a conditional logic block. It evaluates the value stored in `v_year_entered`. If `v_year_entered` is strictly less than the numerical literal `1950`, the function immediately returns the string literal `'Old Competitor'`. Otherwise, if the first condition is not met, it proceeds to evaluate a second condition: if `v_year_entered` is greater than or equal to the numerical literal `1950`, the function then returns the string literal `'New Competitor'`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_competition_status(p_school_id NUMBER) RETURN VARCHAR2 IS\n    v_year_entered NUMBER;\nBEGIN\n    SELECT year_entered_competition INTO v_year_entered FROM school WHERE school_id = p_school_id;\n    IF v_year_entered < 1950 THEN RETURN 'Old Competitor'; ELSIF v_year_entered >= 1950 THEN RETURN 'New Competitor'; END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "SELECT get_school_competition_status(2) FROM DUAL",
      "SELECT get_school_competition_status(3) FROM DUAL",
      "SELECT get_school_competition_status(4) FROM DUAL",
      "SELECT get_school_competition_status(1) FROM DUAL",
      "SELECT get_school_competition_status(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_school_competition_status that takes a school ID (NUMBER) and returns a VARCHAR2. It retrieves the school's competition entry year. Return 'Old Competitor' if the year is before 1950, otherwise return 'New Competitor'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_school_competition_status? It needs to take a school's ID (as a NUMBER) and spit back a VARCHAR2. Basically, it should look up what year that school entered the competition. If the year's way back, like before 1950, just say 'Old Competitor'. Otherwise, call 'em a 'New Competitor'.",
    "id": 49
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_school_league_status that accepts a single input parameter p_school_id of type NUMBER, which is used to identify a specific school, and returns a VARCHAR2 value. The function begins by declaring a local variable v_league of type VARCHAR2(255). It then executes a SELECT statement to query the school_details table, specifically retrieving the value from the league column for the row where the school_id column matches the provided input parameter p_school_id, and stores this retrieved value into the local variable v_league. Following the data retrieval, the function uses an IF-ELSIF conditional block to evaluate the content of v_league: if the value is exactly equal to the string literal 'DSHA', the function returns the string 'High League'; alternatively, if the value is exactly equal to the string literal 'Flight B', the function returns the string 'Low League'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_league_status(p_school_id NUMBER) RETURN VARCHAR2 IS\n    v_league VARCHAR2(255);\nBEGIN\n    SELECT league INTO v_league FROM school_details WHERE school_id = p_school_id;\n    IF v_league = 'DSHA' THEN RETURN 'High League'; ELSIF v_league = 'Flight B' THEN RETURN 'Low League'; END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "SELECT get_school_league_status(1) FROM DUAL",
      "SELECT get_school_league_status(2) FROM DUAL",
      "SELECT get_school_league_status(3) FROM DUAL",
      "SELECT p.PLAYER, get_school_league_status(p.SCHOOL_ID) AS LEAGUE_STATUS FROM PLAYER p WHERE p.SCHOOL_ID = 1",
      "SELECT s.SCHOOL, get_school_league_status(s.SCHOOL_ID) AS LEAGUE_STATUS FROM SCHOOL s WHERE s.SCHOOL_ID IN (1,2,3)"
    ],
    "summary": "Create a PL/SQL function named get_school_league_status that takes a school ID (NUMBER) and returns a VARCHAR2. It retrieves the school's league from the school_details table. Return 'High League' if the league is 'DSHA', or 'Low League' if the league is 'Flight B'.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_school_league_status'. This function shall accept a single input parameter of the NUMBER data type, representing a school identifier. Its purpose is to query the 'school_details' table to ascertain the associated league for the provided school. The function must return a VARCHAR2 value. Specifically, it should return the string 'High League' if the retrieved league value is 'DSHA', and it should return the string 'Low League' if the retrieved league value is 'Flight B'.",
    "id": 50
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_count_by_classroom that accepts a single input parameter, p_classroom, of type NUMBER, which represents the classroom identifier. The function is designed to return a value of type NUMBER, which indicates the total count of students associated with the specified classroom. Within the function, a local variable v_count of type NUMBER is declared to store the result of a query operation. The function begins by executing a SELECT statement that counts all rows in the LIST table where the CLASSROOM column matches the value provided in the p_classroom parameter. The result of this COUNT operation is stored into the v_count variable. Finally, the function returns the value of v_count, which represents the number of students in the specified classroom.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_count_by_classroom(p_classroom NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM LIST WHERE CLASSROOM = p_classroom;\n  RETURN v_count;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_student_count_by_classroom(101) FROM dual",
      "SELECT get_student_count_by_classroom(202) FROM dual",
      "SELECT get_student_count_by_classroom(303) FROM dual",
      "SELECT get_student_count_by_classroom(404) FROM dual",
      "SELECT get_student_count_by_classroom(505) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_student_count_by_classroom that takes a classroom ID (NUMBER) and returns a NUMBER. It counts and returns the number of students in the LIST table for the specified classroom.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_student_count_by_classroom'. This function shall accept a single input parameter of the NUMBER data type, representing a classroom identifier. Its purpose is to ascertain and return, as a NUMBER, the total count of student records associated with the specified classroom within the LIST table.",
    "id": 51
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_teacher_name_by_classroom that accepts a single input parameter named p_classroom of the NUMBER data type, which represents a specific classroom identifier, and returns a value of the VARCHAR2 data type; within the function's execution block, it declares a local variable v_full_name of type VARCHAR2 with a maximum length of 511 characters; the function then executes a SELECT statement that queries the TEACHERS table, specifically retrieving the FIRSTNAME and LASTNAME columns for the row where the CLASSROOM column value is equal to the provided input parameter p_classroom; the SELECT statement concatenates the retrieved FIRSTNAME value, a single space character, and the retrieved LASTNAME value using the concatenation operator (||) and stores the resulting full name string into the local variable v_full_name; finally, the function returns the value stored in the v_full_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_name_by_classroom(p_classroom NUMBER) RETURN VARCHAR2 IS\n  v_full_name VARCHAR2(511);\nBEGIN\n  SELECT FIRSTNAME || ' ' || LASTNAME INTO v_full_name FROM TEACHERS WHERE CLASSROOM = p_classroom;\n  RETURN v_full_name;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_teacher_name_by_classroom(101) FROM DUAL",
      "SELECT get_teacher_name_by_classroom(205) FROM DUAL",
      "SELECT get_teacher_name_by_classroom(312) FROM DUAL",
      "SELECT get_teacher_name_by_classroom(118) FROM DUAL",
      "SELECT get_teacher_name_by_classroom(400) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_teacher_name_by_classroom that takes a classroom ID (NUMBER) and returns a VARCHAR2. It retrieves the teacher's first and last name from the TEACHERS table for the specified classroom, concatenates them with a space, and returns the full name.",
    "natural_language": "Write a PL/SQL function that, when given a certain classroom number, fetches and returns the name of the teacher associated with it. The function should combine the teacher's first and last names into a single string from the relevant table.",
    "id": 52
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_average_grade_by_classroom` that is designed to calculate and return the average grade for a specific classroom. This function accepts one input parameter: `p_classroom`, which is of data type `NUMBER` and represents the unique identifier for the classroom whose average grade is to be computed. Inside the function, a local variable named `v_avg_grade` of data type `NUMBER` is declared to temporarily store the calculated average grade. The core operation involves executing a `SELECT` statement. This `SELECT` statement calculates the average of the `GRADE` column from the table named `LIST`. The `AVG()` aggregate function is used to perform this calculation. The result of this average calculation is then stored into the `v_avg_grade` variable. This selection is conditional, meaning it only considers rows where the value in the `CLASSROOM` column of the `LIST` table matches the value provided by the input parameter `p_classroom`. Finally, the function returns the value stored in the `v_avg_grade` variable, which represents the average grade for the specified classroom.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_grade_by_classroom(p_classroom NUMBER) RETURN NUMBER IS\n  v_avg_grade NUMBER;\nBEGIN\n  SELECT AVG(GRADE) INTO v_avg_grade FROM LIST WHERE CLASSROOM = p_classroom;\n  RETURN v_avg_grade;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_average_grade_by_classroom(101) FROM dual",
      "SELECT get_average_grade_by_classroom(202) FROM dual",
      "SELECT get_average_grade_by_classroom(303) FROM dual",
      "SELECT get_average_grade_by_classroom(404) FROM dual",
      "SELECT get_average_grade_by_classroom(505) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_average_grade_by_classroom` that accepts a classroom ID (NUMBER) and returns the average grade (NUMBER) for that classroom from the LIST table.",
    "natural_language": "Write function `get_average_grade_by_classroom` returning average grade for a given classroom ID from LIST.",
    "id": 53
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_full_name that accepts two input parameters: p_lastname and p_firstname, both of type VARCHAR2, representing the last name and first name of a student, respectively. The function returns a VARCHAR2 value. Within the function, declare a local variable v_full_name of type VARCHAR2 with a maximum length of 511 characters to store the concatenated full name of the student. The function executes a SELECT statement to retrieve the concatenated string of the FIRSTNAME and LASTNAME columns from the LIST table, separated by a space, where the LASTNAME column matches the value of the p_lastname parameter and the FIRSTNAME column matches the value of the p_firstname parameter. The result of this SELECT operation is stored in the v_full_name variable. Finally, the function returns the value of v_full_name, which represents the full name of the student as retrieved from the LIST table based on the specified first name and last name conditions.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_full_name(p_lastname VARCHAR2, p_firstname VARCHAR2) RETURN VARCHAR2 IS\n  v_full_name VARCHAR2(511);\nBEGIN\n  SELECT FIRSTNAME || ' ' || LASTNAME INTO v_full_name FROM LIST WHERE LASTNAME = p_lastname AND FIRSTNAME = p_firstname;\n  RETURN v_full_name;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_student_full_name('Smith', 'John') FROM DUAL",
      "SELECT get_student_full_name('Doe', 'Jane') FROM DUAL",
      "SELECT get_student_full_name('Williams', 'Robert') FROM DUAL",
      "SELECT get_student_full_name('Brown', 'Emily') FROM DUAL",
      "SELECT get_student_full_name('Johnson', 'Michael') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_student_full_name` that accepts a last name and first name (both VARCHAR2) and returns a concatenated full name (VARCHAR2) from the LIST table where the names match.",
    "natural_language": "Construct a PL/SQL function, to be designated as `get_student_full_name`, which will take as its input parameters a student's last name and first name, both defined as VARCHAR2 data types, and will meticulously return a single, neatly concatenated full name, also as a VARCHAR2, by querying and extracting the relevant record from the comprehensive LIST table where the provided first and last names correspond exactly.",
    "id": 54
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_teacher_classroom that accepts two input parameters: a VARCHAR2 parameter named p_lastname representing a teacher's last name and a VARCHAR2 parameter named p_firstname representing a teacher's first name, and returns a NUMBER data type; within the function's execution block, it declares a local NUMBER variable named v_classroom, then executes a SELECT statement that queries the CLASSROOM column from the TEACHERS table, retrieving a single value into the v_classroom variable where the table's LASTNAME column exactly matches the input parameter p_lastname and the table's FIRSTNAME column exactly matches the input parameter p_firstname, and finally returns the value stored in the v_classroom variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_classroom(p_lastname VARCHAR2, p_firstname VARCHAR2) RETURN NUMBER IS\n  v_classroom NUMBER;\nBEGIN\n  SELECT CLASSROOM INTO v_classroom FROM TEACHERS WHERE LASTNAME = p_lastname AND FIRSTNAME = p_firstname;\n  RETURN v_classroom;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_teacher_classroom('Smith', 'John') FROM dual",
      "SELECT get_teacher_classroom('Doe', 'Jane') FROM dual",
      "SELECT get_teacher_classroom('Brown', 'Charlie') FROM dual",
      "SELECT get_teacher_classroom('Johnson', 'Emily') FROM dual",
      "SELECT get_teacher_classroom('Williams', 'Michael') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_teacher_classroom` that accepts a teacher's last name and first name (both VARCHAR2) and returns the classroom number (NUMBER) for that teacher from the TEACHERS table.",
    "natural_language": "What is the classroom number for the teacher with the specified first and last name?",
    "id": 55
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_problems` that is designed to return a single numeric value. This function declares a local variable named `v_total` of the `NUMBER` data type to temporarily store the result of a database query. The core operation performed by this function is a `SELECT` statement that calculates the total count of all rows present in the table named `PROBLEMS`. Specifically, it uses the aggregate function `COUNT(*)` to count every row in the `PROBLEMS` table, irrespective of the values in its columns. The result of this `COUNT(*)` operation is then immediately stored into the previously declared local variable `v_total`. Finally, the function concludes its execution by returning the numeric value currently held by the `v_total` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_problems RETURN NUMBER IS\n    v_total NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total FROM PROBLEMS;\n    RETURN v_total;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_total_problems FROM DUAL",
      "SELECT get_total_problems() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_total_problems;\n  DBMS_OUTPUT.PUT_LINE('Total problems: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total problems: ' || get_total_problems);\nEND;",
      "SELECT get_total_problems AS total_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_total_problems` that takes no parameters and returns the total count of all rows (NUMBER) in the PROBLEMS table.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be named `get_total_problems`, that accepts no input parameters whatsoever and is designed to meticulously calculate and return, as a NUMBER data type, the complete and total count of every single row contained within the PROBLEMS table.",
    "id": 56
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_unsolved_problems that takes no input parameters and returns a single numeric value of type NUMBER. The function declares a local variable v_count of type NUMBER to store the result of a query. The function's logic executes a SELECT statement that queries the PROBLEMS table, using the COUNT(*) aggregate function to calculate the total number of rows. The count is specifically performed with a condition in the WHERE clause that filters rows where the DATE_PROBLEM_CLOSED column contains a NULL value. The result of this count operation is stored into the local variable v_count using the INTO clause. Finally, the function returns the value stored in v_count, which represents the total count of rows in the PROBLEMS table for which the DATE_PROBLEM_CLOSED column is not populated.",
    "plsql": "CREATE OR REPLACE FUNCTION get_unsolved_problems RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM PROBLEMS WHERE DATE_PROBLEM_CLOSED IS NULL;\n    RETURN v_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_unsolved_problems FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_unsolved_problems` that takes no parameters and returns the count (NUMBER) of rows in the PROBLEMS table where the DATE_PROBLEM_CLOSED column is NULL.",
    "natural_language": "Please construct a PL/SQL function, designated as `get_unsolved_problems`, which accepts no input parameters. This function shall return a value of the NUMBER data type, corresponding to the total count of records within the PROBLEMS table for which the DATE_PROBLEM_CLOSED column contains a NULL value.",
    "id": 57
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_staff_with_most_problems that takes no input parameters and returns a single numeric value. The function's purpose is to identify and return the staff ID of the employee who has reported the highest number of problems. It begins by declaring a local variable `v_staff_id` of type NUMBER to hold the result. The core logic executes a single SQL SELECT statement that queries the PROBLEMS table. This statement uses an inner query to group all rows in the PROBLEMS table by the REPORTED_BY_STAFF_ID column, counting the number of rows (problems) for each distinct staff ID using the COUNT(*) aggregate function, aliasing this count as `cnt`. The inner query's result set is then ordered in descending order based on this `cnt` value, so the staff ID with the highest count appears first. The outer query selects only the REPORTED_BY_STAFF_ID column from the first row of this ordered inner result set by applying the condition `WHERE ROWNUM = 1`. The selected staff ID value is fetched directly into the local variable `v_staff_id`. Finally, the function returns the value stored in `v_staff_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_with_most_problems RETURN NUMBER IS\n    v_staff_id NUMBER;\nBEGIN\n    SELECT REPORTED_BY_STAFF_ID INTO v_staff_id FROM (\n        SELECT REPORTED_BY_STAFF_ID, COUNT(*) as cnt FROM PROBLEMS \n        GROUP BY REPORTED_BY_STAFF_ID ORDER BY cnt DESC\n    ) WHERE ROWNUM = 1;\n    RETURN v_staff_id;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_staff_with_most_problems FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_staff_with_most_problems that returns the staff ID of the employee who has reported the highest number of problems from the PROBLEMS table.",
    "natural_language": "Write a PL/SQL function to find the staff member who has been involved with a significant number of issues lately, returning their ID. The function should look at the PROBLEMS table and figure out who seems to have the most problems associated with them.",
    "id": 58
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_avg_logs_per_problem that takes no parameters and returns a single NUMBER value, which begins by declaring a local NUMBER variable v_avg to hold the result, then executes a SQL query that first groups all rows from the PROBLEM_LOG table by the PROBLEM_ID column, calculates the count of rows per group using COUNT(*), and aliases this count as cnt, then uses this grouped result set as an inline view from which it calculates the overall arithmetic average of all these per-group counts using the AVG aggregate function on the cnt column, stores this computed average value into the local variable v_avg, and finally returns the value stored in v_avg as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_avg_logs_per_problem RETURN NUMBER IS\n    v_avg NUMBER;\nBEGIN\n    SELECT AVG(cnt) INTO v_avg FROM (\n        SELECT COUNT(*) as cnt FROM PROBLEM_LOG GROUP BY PROBLEM_ID\n    );\n    RETURN v_avg;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_avg_logs_per_problem FROM DUAL",
      "SELECT get_avg_logs_per_problem() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average logs per problem: ' || get_avg_logs_per_problem);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_avg_logs_per_problem;\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "SELECT get_avg_logs_per_problem AS avg_logs FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_avg_logs_per_problem that returns the average number of log entries per problem from the PROBLEM_LOG table.",
    "natural_language": "Write a PL/SQL function called get_avg_logs_per_problem to return the average count of log entries for each problem from the PROBLEM_LOG table.",
    "id": 59
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_warehouse_min_value` that accepts a single input parameter, `p_warehouse`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable `v_result` of data type `NUMBER` to store the computed minimum value. The core logic of the function involves a series of conditional checks based on the value of the `p_warehouse` parameter.\n\nSpecifically, if the value of `p_warehouse` is exactly `1`, the function executes a `SELECT` statement to retrieve the minimum `VALUE` from the `BOXES` table, specifically for rows where the `WAREHOUSE` column is equal to `1`. This minimum `VALUE` is then stored into the `v_result` variable.\n\nAlternatively, if the value of `p_warehouse` is not `1` but is exactly `2`, the function proceeds to execute a `SELECT` statement to retrieve the minimum `VALUE` from the `BOXES` table, specifically for rows where the `WAREHOUSE` column is equal to `2`. This minimum `VALUE` is then stored into the `v_result` variable.\n\nFurthermore, if the value of `p_warehouse` is neither `1` nor `2` but is exactly `3`, the function executes a `SELECT` statement to retrieve the minimum `VALUE` from the `BOXES` table, specifically for rows where the `WAREHOUSE` column is equal to `3`. This minimum `VALUE` is then stored into the `v_result` variable.\n\nFinally, if none of the preceding conditions are met (i.e., `p_warehouse` is not `1`, `2`, or `3`), the function executes a `SELECT` statement to retrieve the minimum `VALUE` from the `BOXES` table, specifically for rows where the `WAREHOUSE` column is equal to `4`. This minimum `VALUE` is then stored into the `v_result` variable.\n\nAfter one of these `SELECT` statements has been executed and `v_result` has been populated, the function concludes by returning the final value stored in the `v_result` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_warehouse_min_value(p_warehouse NUMBER) RETURN NUMBER IS\n  v_result NUMBER;\nBEGIN\n  IF p_warehouse = 1 THEN\n    SELECT MIN(VALUE) INTO v_result FROM BOXES WHERE WAREHOUSE = 1;\n  ELSIF p_warehouse = 2 THEN\n    SELECT MIN(VALUE) INTO v_result FROM BOXES WHERE WAREHOUSE = 2;\n  ELSIF p_warehouse = 3 THEN\n    SELECT MIN(VALUE) INTO v_result FROM BOXES WHERE WAREHOUSE = 3;\n  ELSE\n    SELECT MIN(VALUE) INTO v_result FROM BOXES WHERE WAREHOUSE = 4;\n  END IF;\n  RETURN v_result;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES"
    ],
    "call_sqls": [
      "SELECT get_warehouse_min_value(1) FROM DUAL",
      "SELECT get_warehouse_min_value(2) FROM DUAL",
      "SELECT get_warehouse_min_value(3) FROM DUAL",
      "SELECT get_warehouse_min_value(4) FROM DUAL",
      "SELECT get_warehouse_min_value(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_warehouse_min_value that accepts a warehouse number parameter. It returns the minimum VALUE from the BOXES table for the specified warehouse. If the parameter is 1, 2, or 3, query for that warehouse. For any other value, query for warehouse 4.",
    "natural_language": "Write a PL/SQL function called get_warehouse_min_value that takes a warehouse identifier. It should find the smallest VALUE in the BOXES table for a given warehouse. For a few common warehouse numbers, like 1, 2, or 3, look up that specific one. For any other input number, just check the data for warehouse 4.",
    "id": 60
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_warehouse_status that accepts a single parameter p_warehouse_id of type NUMBER, which represents the identifier of a warehouse. The function returns a value of type VARCHAR2. The function begins by declaring a local variable v_min_val of type NUMBER to store the result of a query operation. The function uses a conditional structure to determine the logic based on the value of p_warehouse_id. If p_warehouse_id equals 1, the function executes a SELECT statement to retrieve the minimum value from the VALUE column in the BOXES table where the WAREHOUSE column equals 1 and the CONTENTS column equals 'Rocks', storing the result in v_min_val. If p_warehouse_id equals 2, the function performs a similar SELECT operation to find the minimum VALUE from the BOXES table where WAREHOUSE equals 2 and CONTENTS equals 'Scissors', again storing the result in v_min_val. If p_warehouse_id equals 3, the function retrieves the minimum VALUE from the BOXES table where WAREHOUSE equals 3 and CONTENTS equals 'Paper', storing the result in v_min_val. If p_warehouse_id does not match any of the specified values (1, 2, or 3), the function defaults to selecting the minimum VALUE from the BOXES table where WAREHOUSE equals 4 and the CONTENTS column is not NULL, storing the result in v_min_val. After determining the minimum value based on the warehouse and contents conditions, the function concatenates the string 'STATUS_' with the string representation of v_min_val using the TO_CHAR function and returns this concatenated result as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_warehouse_status(p_warehouse_id NUMBER) RETURN VARCHAR2 IS\n  v_min_val NUMBER;\nBEGIN\n  IF p_warehouse_id = 1 THEN\n    SELECT MIN(VALUE) INTO v_min_val FROM BOXES WHERE WAREHOUSE = 1 AND CONTENTS = 'Rocks';\n  ELSIF p_warehouse_id = 2 THEN\n    SELECT MIN(VALUE) INTO v_min_val FROM BOXES WHERE WAREHOUSE = 2 AND CONTENTS = 'Scissors';\n  ELSIF p_warehouse_id = 3 THEN\n    SELECT MIN(VALUE) INTO v_min_val FROM BOXES WHERE WAREHOUSE = 3 AND CONTENTS = 'Paper';\n  ELSE\n    SELECT MIN(VALUE) INTO v_min_val FROM BOXES WHERE WAREHOUSE = 4 AND CONTENTS IS NOT NULL;\n  END IF;\n  RETURN 'STATUS_' || TO_CHAR(v_min_val);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES"
    ],
    "call_sqls": [
      "SELECT get_warehouse_status(1) FROM DUAL",
      "SELECT get_warehouse_status(2) FROM DUAL",
      "SELECT get_warehouse_status(3) FROM DUAL",
      "SELECT get_warehouse_status(4) FROM DUAL"
    ],
    "summary": "Create a function named get_warehouse_status that takes a warehouse ID number and returns a VARCHAR2. It finds the minimum VALUE from the BOXES table based on the ID: for ID 1, filter CONTENTS='Rocks'; for ID 2, filter CONTENTS='Scissors'; for ID 3, filter CONTENTS='Paper'; for any other ID, filter WAREHOUSE=4 and CONTENTS IS NOT NULL. The function returns 'STATUS_' concatenated with this minimum value.",
    "natural_language": "Define a function called `get_warehouse_status` that accepts a warehouse ID as a numeric input and yields a VARCHAR2 output. The function shall compute the minimum VALUE from the BOXES table according to the following conditional logic: if the provided ID is 1, restrict the selection to entries where CONTENTS equals 'Rocks'; if the ID is 2, restrict to CONTENTS equal to 'Scissors'; if the ID is 3, restrict to CONTENTS equal to 'Paper'; for any other ID value, restrict to records where WAREHOUSE is 4 and CONTENTS is not null. The function's return value must be the string 'STATUS_' appended to the derived minimum value.",
    "id": 61
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_creation_count that accepts two parameters: p_artist_id of type NUMBER, which represents the unique identifier of an artist, and p_year of type NUMBER, which specifies a particular year. The function returns a NUMBER that indicates the count of paintings created by the artist with the given identifier during the specified year. Within the function, a local variable v_count of type NUMBER is declared to store the result of a query. The function executes a SELECT statement that counts the total number of rows in the PAINTINGS table where the PAINTERID column matches the value of p_artist_id and the YEAR column matches the value of p_year. The result of this count is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the number of paintings created by the specified artist in the specified year.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_creation_count(p_artist_id NUMBER, p_year NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM PAINTINGS\n    WHERE PAINTERID = p_artist_id AND YEAR = p_year;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_creation_count(111, 1884) FROM DUAL",
      "SELECT get_artist_creation_count(222, 1930) FROM DUAL",
      "SELECT get_artist_creation_count(111, 1890) FROM DUAL",
      "SELECT get_artist_creation_count(333, 1855) FROM DUAL",
      "SELECT ARTISTID, LNAME, get_artist_creation_count(ARTISTID, 1881) AS paintings_in_1881 FROM ARTISTS"
    ],
    "summary": "Create a function named get_artist_creation_count that takes an artist ID and a year as numbers. It returns the count of paintings from the PAINTINGS table where the PAINTERID and YEAR match the input parameters.",
    "natural_language": "Hey, can you whip up a function called get_artist_creation_count? It needs to take an artist's ID and a specific year, both as numbers. Basically, it should tell us how many paintings in the PAINTINGS table were done by that artist in that exact year.",
    "id": 62
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_sculpture_count that accepts two input parameters: a numeric parameter p_artist_id representing the unique identifier of an artist, and a numeric parameter p_year representing a specific calendar year. The function returns a single numeric value. The function's logic begins by declaring a local numeric variable v_count to store the result of a subsequent query. It then executes a SELECT statement that performs a COUNT(*) aggregation on the SCULPTURES table. The query specifically counts all rows where the SCULPTORID column value is exactly equal to the provided p_artist_id parameter and, simultaneously, the YEAR column value is exactly equal to the provided p_year parameter. The result of this count operation is retrieved into the local variable v_count using an INTO clause. Finally, the function concludes by returning the value stored in the v_count variable, which represents the total number of sculptures created by the specified artist in the specified year.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_sculpture_count(p_artist_id NUMBER, p_year NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM SCULPTURES\n    WHERE SCULPTORID = p_artist_id AND YEAR = p_year;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_sculpture_count(222, 1945) FROM DUAL",
      "SELECT get_artist_sculpture_count(555, 1885) FROM DUAL",
      "SELECT get_artist_sculpture_count(222, 1883) FROM DUAL",
      "SELECT get_artist_sculpture_count(111, 1900) FROM DUAL",
      "SELECT get_artist_sculpture_count(333, 1880) FROM DUAL"
    ],
    "summary": "Create a function named get_artist_sculpture_count that takes an artist ID and a year as numbers. It returns the count of sculptures from the SCULPTURES table where the SCULPTORID and YEAR match the input parameters.",
    "natural_language": "What is the count of sculptures for a given artist ID and year, based on the SCULPTURES table where the SCULPTORID and YEAR match the provided parameters?",
    "id": 63
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_total_creations that accepts two input parameters: p_artist_id of type NUMBER, which represents the unique identifier of an artist, and p_year of type NUMBER, which specifies the year for which the total number of creations is to be calculated. The function returns a NUMBER that represents the total count of creations made by the specified artist in the given year. Inside the function, declare a local variable v_total of type NUMBER to store the result. The function performs a SELECT statement that calculates the sum of two subqueries. The first subquery counts the number of rows in the PAINTINGS table where the PAINTERID column matches the input parameter p_artist_id and the YEAR column matches the input parameter p_year. The second subquery counts the number of rows in the SCULPTURES table where the SCULPTORID column matches the input parameter p_artist_id and the YEAR column matches the input parameter p_year. The results of these two subqueries are added together, and the total is stored in the variable v_total. The function then returns the value of v_total, which represents the total number of paintings and sculptures created by the specified artist in the specified year.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_total_creations(p_artist_id NUMBER, p_year NUMBER) RETURN NUMBER IS\n    v_total NUMBER;\nBEGIN\n    SELECT (SELECT COUNT(*) FROM PAINTINGS WHERE PAINTERID = p_artist_id AND YEAR = p_year) +\n           (SELECT COUNT(*) FROM SCULPTURES WHERE SCULPTORID = p_artist_id AND YEAR = p_year)\n    INTO v_total\n    FROM DUAL;\n    RETURN v_total;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_total_creations(111, 1884) FROM DUAL",
      "SELECT get_artist_total_creations(222, 1930) FROM DUAL",
      "SELECT get_artist_total_creations(222, 1945) FROM DUAL",
      "SELECT get_artist_total_creations(333, 1890) FROM DUAL",
      "SELECT get_artist_total_creations(555, 1885) FROM DUAL"
    ],
    "summary": "Create a function named get_artist_total_creations that takes an artist ID and a year as numbers. It returns the total count of creations by summing the count of matching records from the PAINTINGS table and the count of matching records from the SCULPTURES table for the given artist and year.",
    "natural_language": "Make a function called get_artist_total_creations that uses an artist ID and a year. It should figure out a rough total number of creations by combining a decent count from the PAINTINGS table and a fair number from the SCULPTURES table for that artist around that year.",
    "id": 64
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_artist_medium_count` that accepts two input parameters: `p_artist_id` of data type `NUMBER` which represents the unique identifier for an artist, and `p_medium` of data type `VARCHAR2` which represents the artistic medium. This function is designed to return a single value of data type `NUMBER`. Internally, the function declares a local variable `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement to count the number of records in the `PAINTINGS` table. This count is determined by applying two filtering conditions: first, the `PAINTERID` column in the `PAINTINGS` table must exactly match the value provided by the `p_artist_id` input parameter, and second, the `MEDIUM` column in the `PAINTINGS` table must exactly match the value provided by the `p_medium` input parameter. The result of this `COUNT(*)` aggregation is then stored into the `v_count` local variable. Finally, the function returns the value stored in `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_medium_count(p_artist_id NUMBER, p_medium VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM PAINTINGS\n    WHERE PAINTERID = p_artist_id AND MEDIUM = p_medium;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_medium_count(111, 'oil') FROM DUAL",
      "SELECT get_artist_medium_count(222, 'lithograph') FROM DUAL",
      "SELECT get_artist_medium_count(111, 'watercolor') FROM DUAL",
      "SELECT get_artist_medium_count(333, 'oil') FROM DUAL",
      "SELECT get_artist_medium_count(222, 'oil') FROM DUAL"
    ],
    "summary": "Create a function named get_artist_medium_count that takes an artist ID number and a medium string. It returns the count of paintings from the PAINTINGS table where the PAINTERID and MEDIUM match the input parameters.",
    "natural_language": "Function get_artist_medium_count: count paintings by artist ID and medium.",
    "id": 65
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_sculpture_medium_count that accepts two input parameters: a numeric parameter p_artist_id and a string parameter p_medium, and returns a numeric value. The function declares a local numeric variable v_count. The function executes a SELECT statement that queries the SCULPTURES table, using the COUNT(*) aggregate function to calculate the total number of rows. The SELECT statement includes a WHERE clause with two conditions joined by a logical AND operator: the first condition checks that the SCULPTORID column in the SCULPTURES table is equal to the input parameter p_artist_id, and the second condition checks that the MEDIUM column in the SCULPTURES table is equal to the input parameter p_medium. The result of the COUNT(*) operation is stored into the local variable v_count using an INTO clause. The function then concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_sculpture_medium_count(p_artist_id NUMBER, p_medium VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM SCULPTURES\n    WHERE SCULPTORID = p_artist_id AND MEDIUM = p_medium;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_sculpture_medium_count(222, 'bronze') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(555, 'bronze') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(111, 'bronze') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(222, 'wood') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(555, 'marble') FROM DUAL"
    ],
    "summary": "Create a function named get_artist_sculpture_medium_count that returns a number. It takes an artist ID (number) and a medium (string) as input. The function should count and return the number of rows in the SCULPTURES table where the SCULPTORID matches the given artist ID and the MEDIUM matches the given medium.",
    "natural_language": "How many sculptures by a specific artist, identified by their ID, are made using a specified medium?",
    "id": 66
  },
  {
    "ir": "Write an Oracle PL/SQL function named `fn_get_club_ranking` that accepts a single input parameter, `p_club_id`, which is of data type `NUMBER`. This function is designed to retrieve and return the overall ranking of a specific club. Internally, the function declares a local variable named `v_ranking`, also of data type `NUMBER`, to temporarily store the retrieved ranking value. The core operation involves executing a `SELECT` statement to query the `CLUB` table. This `SELECT` statement retrieves the value from the `OVERALL_RANKING` column. The retrieval is conditional, specifically targeting the row where the value in the `CLUB_ID` column matches the value provided by the input parameter `p_club_id`. The value obtained from the `OVERALL_RANKING` column for the matching row is then immediately assigned to the local variable `v_ranking`. Finally, the function returns the value stored in `v_ranking` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_club_ranking(p_club_id NUMBER) RETURN NUMBER IS\n    v_ranking NUMBER;\nBEGIN\n    SELECT OVERALL_RANKING INTO v_ranking FROM CLUB WHERE CLUB_ID = p_club_id;\n    RETURN v_ranking;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT fn_get_club_ranking(1) FROM DUAL",
      "SELECT fn_get_club_ranking(3) FROM DUAL",
      "SELECT fn_get_club_ranking(4) FROM DUAL",
      "SELECT fn_get_club_ranking(10) FROM DUAL",
      "SELECT fn_get_club_ranking(99) FROM DUAL"
    ],
    "summary": "Create a function named fn_get_club_ranking that returns a number. It takes a club ID (number) as input. The function should retrieve and return the OVERALL_RANKING value from the CLUB table for the row where CLUB_ID matches the given club ID.",
    "natural_language": "Please construct a function designated as 'fn_get_club_ranking' that yields a numeric value. This function shall accept a club identifier, represented as a number, as its input parameter. Its operation must involve querying the CLUB table to obtain the OVERALL_RANKING figure corresponding to the record whose CLUB_ID matches the provided identifier, and subsequently returning that value.",
    "id": 67
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_calculate_max_age_diff that does not take any parameters and returns a NUMBER type value. The function is designed to calculate the absolute difference between the maximum and minimum ages of members stored in the MEMBER table. Within the function, two local variables, v_max_age and v_min_age, both of type NUMBER, are declared to store the maximum and minimum age values, respectively. The function begins by executing a SELECT statement that retrieves the maximum and minimum values from the AGE column of the MEMBER table and assigns these values to the v_max_age and v_min_age variables using the INTO clause. The SELECT statement does not include any WHERE clause, meaning it considers all rows in the MEMBER table. After obtaining the maximum and minimum ages, the function calculates the absolute difference between these two values using the ABS function, which returns the absolute value of a number, ensuring the result is non-negative. Finally, the function returns this calculated absolute difference as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_calculate_max_age_diff RETURN NUMBER IS\n    v_max_age NUMBER;\n    v_min_age NUMBER;\nBEGIN\n    SELECT MAX(AGE), MIN(AGE) INTO v_max_age, v_min_age FROM MEMBER;\n    RETURN ABS(v_max_age - v_min_age);\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT fn_calculate_max_age_diff FROM DUAL"
    ],
    "summary": "Create a function named fn_calculate_max_age_diff that returns a number and takes no parameters. The function should calculate the absolute difference between the maximum and minimum AGE values found in the MEMBER table and return this result.",
    "natural_language": "Calculate the absolute difference between the maximum and minimum AGE values in the MEMBER table. Return this result from a function named fn_calculate_max_age_diff that takes no parameters.",
    "id": 68
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_country_language_score that accepts a single input parameter p_country_id of the NUMBER data type, which is used to identify a specific country record, and returns a single NUMBER value; the function declares a local variable v_score of type NUMBER; the function's execution logic begins by performing a SELECT query on the COUNTRIES table to retrieve the value from the OVERALL_SCORE column for the specific row where the ID column exactly equals the provided input parameter p_country_id, and this retrieved value is stored into the local variable v_score; the function then returns the result of applying the ROUND function to the arithmetic expression v_score multiplied by 1.1, which calculates a 10 percent increase on the original score and rounds the final result to the nearest whole number.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_language_score(p_country_id NUMBER) RETURN NUMBER IS\n    v_score NUMBER;\nBEGIN\n    SELECT COUNTRIES.OVERALL_SCORE INTO v_score FROM COUNTRIES WHERE COUNTRIES.ID = p_country_id;\n    RETURN ROUND(v_score * 1.1);\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_country_language_score(1) FROM DUAL",
      "SELECT get_country_language_score(2) FROM DUAL",
      "SELECT get_country_language_score(3) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_country_language_score that accepts a country ID number and returns a number. It retrieves the country's overall score, increases it by 10%, rounds the result to the nearest whole number, and returns it.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_country_language_score? It should take a country ID number and spit back a number. Basically, it needs to grab the country's overall score, bump it up by 10%, round that off to the nearest whole number, and hand it back.",
    "id": 69
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_combined_score that accepts a single parameter, p_country_id, which is of type NUMBER. This function is designed to compute a combined score for a country by accessing the COUNTRIES table. The function begins by declaring a local variable, v_combined, of type NUMBER, which will be used to store the result of the score calculation. Within the function's execution block, a SELECT statement is used to retrieve and sum the EDUCATION_SCORE and HEALTH_SCORE columns from the COUNTRIES table for the row where the ID column matches the value provided in the p_country_id parameter. The result of this addition is stored in the v_combined variable. The function then returns the ceiling value of v_combined, which is obtained by applying the CEIL function to round up the combined score to the nearest whole number.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_combined_score(p_country_id NUMBER) RETURN NUMBER IS\n    v_combined NUMBER;\nBEGIN\n    SELECT COUNTRIES.EDUCATION_SCORE + COUNTRIES.HEALTH_SCORE INTO v_combined FROM COUNTRIES WHERE COUNTRIES.ID = p_country_id;\n    RETURN CEIL(v_combined);\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT calculate_combined_score(1) FROM DUAL",
      "SELECT calculate_combined_score(2) FROM DUAL",
      "SELECT calculate_combined_score(3) FROM DUAL",
      "SELECT calculate_combined_score( (SELECT ID FROM COUNTRIES WHERE NAME = 'Iceland') ) FROM DUAL",
      "SELECT calculate_combined_score( (SELECT ID FROM COUNTRIES WHERE NAME = 'Canada') ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_combined_score that accepts a country ID number and returns a number. It calculates the sum of the country's education and health scores, rounds the result up to the nearest whole number, and returns it.",
    "natural_language": "Write a PL/SQL function called calculate_combined_score that takes a country ID number as input and outputs a number. This function should sum the country's education and health scores, round the total up to the nearest integer, and then return that value.",
    "id": 70
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_language_count that accepts a single input parameter p_language_id of type NUMBER, which represents the identifier of a language. The function declares a local variable v_count of type NUMBER to store the result of a query. Within the function body, it performs a SELECT operation to count the number of rows in the OFFICIAL_LANGUAGES table where the LANGUAGE_ID column matches the value of the input parameter p_language_id. The result of this count is stored in the variable v_count. The function then returns the value of v_count multiplied by 10.",
    "plsql": "CREATE OR REPLACE FUNCTION get_language_count(p_language_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM OFFICIAL_LANGUAGES WHERE OFFICIAL_LANGUAGES.LANGUAGE_ID = p_language_id;\n    RETURN v_count * 10;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_language_count(1) FROM DUAL",
      "SELECT get_language_count(2) FROM DUAL",
      "SELECT get_language_count(3) FROM DUAL",
      "SELECT get_language_count(10) FROM DUAL",
      "SELECT get_language_count(100) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_language_count that accepts a language ID number and returns a number. It counts the number of times the language appears in the official languages table, multiplies the count by 10, and returns the result.",
    "natural_language": "What is the result of multiplying by 10 the count of how many times a given language ID appears in the official languages table?",
    "id": 71
  },
  {
    "ir": "Write an Oracle PL/SQL function named compute_score_difference that accepts a single parameter, p_country_id, of type NUMBER, which represents the unique identifier of a country. The function calculates the difference between the JUSTICE_SCORE and POLITICS_SCORE columns for the row in the COUNTRIES table where the ID column matches the provided p_country_id. It stores this difference in a local variable named v_difference of type NUMBER. The function then returns the absolute value of v_difference using the ABS() function, which ensures that the result is always a non-negative number.",
    "plsql": "CREATE OR REPLACE FUNCTION compute_score_difference(p_country_id NUMBER) RETURN NUMBER IS\n    v_difference NUMBER;\nBEGIN\n    SELECT COUNTRIES.JUSTICE_SCORE - COUNTRIES.POLITICS_SCORE INTO v_difference FROM COUNTRIES WHERE COUNTRIES.ID = p_country_id;\n    RETURN ABS(v_difference);\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT compute_score_difference(1) FROM DUAL",
      "SELECT compute_score_difference(2) FROM DUAL",
      "SELECT compute_score_difference(3) FROM DUAL",
      "SELECT compute_score_difference(100) FROM DUAL",
      "SELECT compute_score_difference(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named compute_score_difference that accepts a country ID number and returns a number. It calculates the absolute difference between the country's justice score and politics score and returns the non-negative result.",
    "natural_language": "Compute the absolute difference between the justice and politics scores for a specified country ID. Return the non-negative result.",
    "id": 72
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_country_name_length that accepts a single parameter, p_country_id, of type NUMBER, which represents the unique identifier of a country in the COUNTRIES table. The function performs a SELECT operation to retrieve the NAME column from the COUNTRIES table where the ID column matches the provided p_country_id. It calculates the length of the retrieved country name using the LENGTH function and stores this length in a local variable v_length of type NUMBER. The function then multiplies the length of the country name by 5 and returns the resulting value as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_name_length(p_country_id NUMBER) RETURN NUMBER IS\n    v_length NUMBER;\nBEGIN\n    SELECT LENGTH(COUNTRIES.NAME) INTO v_length FROM COUNTRIES WHERE COUNTRIES.ID = p_country_id;\n    RETURN v_length * 5;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_country_name_length(1) FROM DUAL",
      "SELECT get_country_name_length(2) FROM DUAL",
      "SELECT get_country_name_length(3) FROM DUAL",
      "SELECT get_country_name_length(100) FROM DUAL",
      "SELECT get_country_name_length(999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_country_name_length that accepts a country ID number and returns a number. It retrieves the country's name, calculates its length, multiplies the length by 5, and returns the result.",
    "natural_language": "Write a PL/SQL function called get_country_name_length that takes a country ID number as input and returns a number. The function should fetch the country's name, determine its length, multiply that length by 5, and then output the final value.",
    "id": 73
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_product_price_sum` that accepts a single input parameter, `p_regular_order_id`, which is of the `NUMBER` data type. This function is designed to return a single value of the `NUMBER` data type. The primary purpose of this function is to calculate the sum of product prices associated with a specific regular order.\n\nUpon execution, the function declares a local variable named `v_total_price` of the `NUMBER` data type to temporarily store the calculated sum. The core operation involves a `SELECT` statement that performs a join between two tables: `REGULAR_ORDER_PRODUCTS` (aliased as `rop`) and `PRODUCTS` (aliased as `p`). The join condition `rop.PRODUCT_ID = p.PRODUCT_ID` links records from `REGULAR_ORDER_PRODUCTS` to their corresponding product details in the `PRODUCTS` table based on matching `PRODUCT_ID` values.\n\nThe `SELECT` statement then calculates the `SUM` of the `PRODUCT_PRICE` column from the `PRODUCTS` table. This summation is performed only for those records where the `REGULAR_ORDER_ID` column in the `REGULAR_ORDER_PRODUCTS` table matches the value provided by the input parameter `p_regular_order_id`. The result of this summation is then stored into the local variable `v_total_price`.\n\nFinally, the function returns the value stored in `v_total_price` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price_sum(p_regular_order_id NUMBER) RETURN NUMBER IS\n  v_total_price NUMBER;\nBEGIN\n  SELECT SUM(p.PRODUCT_PRICE)\n  INTO v_total_price\n  FROM REGULAR_ORDER_PRODUCTS rop\n  JOIN PRODUCTS p ON rop.PRODUCT_ID = p.PRODUCT_ID\n  WHERE rop.REGULAR_ORDER_ID = p_regular_order_id;\n  RETURN v_total_price;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "REGULAR_ORDERS",
      "REGULAR_ORDER_PRODUCTS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_price_sum(8) FROM DUAL",
      "SELECT get_product_price_sum(15) FROM DUAL",
      "SELECT get_product_price_sum(4) FROM DUAL",
      "SELECT get_product_price_sum(5) FROM DUAL",
      "SELECT get_product_price_sum(2) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_product_price_sum` that accepts a regular order ID (NUMBER) and returns the total sum of product prices for that order by joining the REGULAR_ORDER_PRODUCTS and PRODUCTS tables.",
    "natural_language": "Please construct a PL/SQL function, designated as `get_product_price_sum`, which shall receive a regular order identifier of the NUMBER data type as its input parameter. This function is required to compute and return the aggregate sum of product prices corresponding to the specified order. The calculation must be performed by executing an appropriate join operation between the REGULAR_ORDER_PRODUCTS and PRODUCTS database tables.",
    "id": 74
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_order_count_by_status that accepts a single input parameter p_status of type VARCHAR2, which represents the status code of orders. The function returns a value of type NUMBER. Within the function, declare a local variable v_count of type NUMBER to store the result of a query. Execute a SELECT statement that counts all rows in the ACTUAL_ORDERS table where the ORDER_STATUS_CODE column matches the value of the input parameter p_status. Store the result of this count operation into the variable v_count. Finally, return the value of v_count as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_order_count_by_status(p_status VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO v_count\n  FROM ACTUAL_ORDERS\n  WHERE ORDER_STATUS_CODE = p_status;\n  RETURN v_count;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "REGULAR_ORDERS",
      "REGULAR_ORDER_PRODUCTS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_order_count_by_status('Success') FROM dual",
      "SELECT get_order_count_by_status('Cancel') FROM dual",
      "SELECT get_order_count_by_status('Pending') FROM dual",
      "SELECT get_order_count_by_status('Failed') FROM dual",
      "SELECT get_order_count_by_status('Processing') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_order_count_by_status` that accepts an order status code (VARCHAR2) and returns the count of orders with that status from the ACTUAL_ORDERS table.",
    "natural_language": "Write function `get_order_count_by_status` returning order count for given status from ACTUAL_ORDERS.",
    "id": 75
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_product_price that calculates and returns the average price of products from the PRODUCTS table. The function does not take any input parameters and returns a value of type NUMBER. Inside the function, a local variable v_avg_price of type NUMBER is declared to store the result of the average calculation. The function performs a SELECT operation to compute the average of the PRODUCT_PRICE column from the PRODUCTS table, and the result is stored into the v_avg_price variable using the INTO clause. The function then returns the value stored in v_avg_price, which represents the average product price. There are no conditional statements or special operations such as function calls like UPPER() or LOWER() involved in this function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_product_price RETURN NUMBER IS\n  v_avg_price NUMBER;\nBEGIN\n  SELECT AVG(PRODUCT_PRICE)\n  INTO v_avg_price\n  FROM PRODUCTS;\n  RETURN v_avg_price;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "REGULAR_ORDERS",
      "REGULAR_ORDER_PRODUCTS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_average_product_price FROM DUAL",
      "SELECT get_average_product_price() FROM DUAL",
      "DECLARE\n  v_avg NUMBER;\nBEGIN\n  v_avg := get_average_product_price;\n  DBMS_OUTPUT.PUT_LINE('Average Price: ' || v_avg);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average Product Price: ' || get_average_product_price);\nEND;",
      "SELECT get_average_product_price AS avg_price FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_average_product_price` with no parameters that returns the average price of all products from the PRODUCTS table.",
    "natural_language": "Write a PL/SQL function `get_average_product_price` with no parameters to return the average price from PRODUCTS.",
    "id": 76
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_order_id` that is designed to retrieve the maximum value from the `ACTUAL_ORDER_ID` column within the `ACTUAL_ORDERS` table. This function does not accept any input parameters. It declares a local variable named `v_max_order_id` of data type `NUMBER` to temporarily store the result of the database query. The core operation involves executing a `SELECT` statement to compute the maximum value of the `ACTUAL_ORDER_ID` column from all rows present in the `ACTUAL_ORDERS` table. The result of this aggregation, which is a single numeric value representing the highest `ACTUAL_ORDER_ID` found, is then immediately assigned to the `v_max_order_id` variable using the `INTO` clause. Finally, the function returns the value currently held by the `v_max_order_id` variable, which is the maximum `ACTUAL_ORDER_ID` found, as its output. The return type of this function is `NUMBER`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_order_id RETURN NUMBER IS\n  v_max_order_id NUMBER;\nBEGIN\n  SELECT MAX(ACTUAL_ORDER_ID)\n  INTO v_max_order_id\n  FROM ACTUAL_ORDERS;\n  RETURN v_max_order_id;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "REGULAR_ORDERS",
      "REGULAR_ORDER_PRODUCTS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_max_order_id FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_max_order_id` with no parameters that returns the maximum ACTUAL_ORDER_ID value from the ACTUAL_ORDERS table.",
    "natural_language": "Write a PL/SQL function called `get_max_order_id` that takes no parameters and fetches the highest ACTUAL_ORDER_ID from the ACTUAL_ORDERS table.",
    "id": 77
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_min_product_price that does not take any parameters and returns a NUMBER type value. The function is designed to determine the minimum price of products listed in the PRODUCTS table. It begins by declaring a local variable v_min_price of type NUMBER, which will be used to store the result of the query operation. The function then executes a SELECT statement that retrieves the smallest value from the PRODUCT_PRICE column within the PRODUCTS table. This operation uses the MIN() aggregate function to identify the lowest price among all entries in the PRODUCT_PRICE column. The result of this query is stored into the v_min_price variable using the INTO clause. After successfully obtaining the minimum product price, the function concludes by returning the value stored in v_min_price, thereby providing the caller with the minimum product price found in the PRODUCTS table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_min_product_price RETURN NUMBER IS\n  v_min_price NUMBER;\nBEGIN\n  SELECT MIN(PRODUCT_PRICE)\n  INTO v_min_price\n  FROM PRODUCTS;\n  RETURN v_min_price;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "REGULAR_ORDERS",
      "REGULAR_ORDER_PRODUCTS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_min_product_price FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_min_product_price` with no parameters that returns the minimum product price from the PRODUCTS table.",
    "natural_language": "What is the PL/SQL function, named `get_min_product_price` with no parameters, that returns the minimum product price from the PRODUCTS table?",
    "id": 78
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_member_rank_category that accepts a single input parameter, p_member_id, of type NUMBER, which represents the unique identifier of a member. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_rank of type NUMBER to store the rank of the member and another local variable v_category of type VARCHAR2 with a maximum length of 20 characters to store the category of the member. The function begins by executing a SELECT statement to retrieve the RANK_IN_ROUND value from the ROUND table where the MEMBER_ID column matches the input parameter p_member_id. The retrieved rank value is stored in the v_rank variable. The function then evaluates the value of v_rank using an IF statement. If v_rank is less than or equal to 2, the function assigns the string 'TOP_TIER' to the v_category variable. Otherwise, it assigns the string 'OTHER' to v_category. Finally, the function returns the value of v_category, which indicates the rank category of the member based on their rank in the ROUND table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_rank_category(p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_rank NUMBER;\n  v_category VARCHAR2(20);\nBEGIN\n  SELECT RANK_IN_ROUND INTO v_rank FROM ROUND WHERE MEMBER_ID = p_member_id;\n  IF v_rank <= 2 THEN\n    v_category := 'TOP_TIER';\n  ELSE\n    v_category := 'OTHER';\n  END IF;\n  RETURN v_category;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_rank_category(1) FROM DUAL",
      "SELECT get_member_rank_category(2) FROM DUAL",
      "SELECT get_member_rank_category(10) FROM DUAL",
      "SELECT get_member_rank_category(3) FROM DUAL",
      "SELECT get_member_rank_category(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_rank_category that accepts a member ID number and returns a VARCHAR2. It retrieves the member's rank from the ROUND table. If the rank is 1 or 2, return 'TOP_TIER'; otherwise, return 'OTHER'.",
    "natural_language": "Develop a PL/SQL function, which should be named get_member_rank_category, that is designed to accept a specific member ID number as its input parameter and will subsequently return a value of the VARCHAR2 data type. This function will meticulously query the ROUND table to retrieve the precise rank associated with the provided member. In the detailed scenario where the retrieved rank is determined to be exactly 1 or 2, the function must thoughtfully return the descriptive string 'TOP_TIER'; for all other rank values, it should comprehensively return the string 'OTHER'.",
    "id": 79
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_college_score that accepts a single input parameter p_college_id of type NUMBER, which represents the unique identifier for a college, and returns a single numeric value of type NUMBER. The function begins by declaring a local variable v_total_score of type NUMBER to store the computed result. The core operation is a SELECT statement that queries the database to calculate a sum: it retrieves the sum of all values from the column RANK_IN_ROUND in the table ROUND, which is aliased as 'r'. This table is joined with the MEMBER table, aliased as 'm', using the condition that the MEMBER_ID column in the ROUND table equals the MEMBER_ID column in the MEMBER table. The query includes a WHERE clause that filters the joined result set to only include rows where the COLLEGE_ID column in the MEMBER table matches the input parameter p_college_id. The result of this SUM aggregation is then assigned into the local variable v_total_score. Following the query, a conditional IF statement checks if the v_total_score variable is NULL, which would occur if the SELECT statement returned no rows for the given college_id, and if true, assigns the value 0 to v_total_score. Finally, the function concludes by using a RETURN statement to output the value stored in v_total_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_college_score(p_college_id NUMBER) RETURN NUMBER IS\n  v_total_score NUMBER;\nBEGIN\n  SELECT SUM(RANK_IN_ROUND) INTO v_total_score FROM ROUND r JOIN MEMBER m ON r.MEMBER_ID = m.MEMBER_ID WHERE m.COLLEGE_ID = p_college_id;\n  IF v_total_score IS NULL THEN\n    v_total_score := 0;\n  END IF;\n  RETURN v_total_score;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT calculate_college_score(1) FROM DUAL",
      "SELECT calculate_college_score(2) FROM DUAL",
      "SELECT calculate_college_score(3) FROM DUAL",
      "SELECT COLLEGE_ID, NAME, calculate_college_score(COLLEGE_ID) AS TOTAL_SCORE FROM COLLEGE",
      "SELECT calculate_college_score(COLLEGE_ID) FROM COLLEGE WHERE NAME = 'Saskatchewan School'"
    ],
    "summary": "Create a PL/SQL function named calculate_college_score that accepts a college ID number and returns a NUMBER. It calculates the total score by summing the RANK_IN_ROUND values from the ROUND table for all members belonging to the specified college. If no data is found, return 0.",
    "natural_language": "Hey, can you whip up a PL/SQL function called calculate_college_score? It should take a college ID number and spit back a NUMBER. Basically, it needs to add up all the RANK_IN_ROUND numbers from the ROUND table for every member who's part of that college. If there's nothing there, just give back a zero.",
    "id": 80
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_member_country` that accepts a single input parameter, `p_member_id`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` value. The function begins by declaring two local variables: `v_country`, a `VARCHAR2` variable capable of holding up to 255 characters, and `v_result`, a `VARCHAR2` variable capable of holding up to 10 characters. The core logic of the function involves performing a `SELECT` operation on the `MEMBER` table. Specifically, it retrieves the value from the `COUNTRY` column for the row where the `MEMBER_ID` column matches the value provided in the `p_member_id` input parameter. The retrieved `COUNTRY` value is then stored into the `v_country` local variable. Following this data retrieval, the function executes a conditional `IF` statement. It converts the value stored in `v_country` to uppercase using the `UPPER()` function and then compares this uppercase value to the string literal 'UNITED STATES'. If the uppercase `v_country` is exactly equal to 'UNITED STATES', the `v_result` variable is assigned the string literal 'USA'. Otherwise, if the uppercase `v_country` is not equal to 'UNITED STATES', the `v_result` variable is assigned the string literal 'OTHER'. Finally, the function returns the value currently stored in the `v_result` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION check_member_country(p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_country VARCHAR2(255);\n  v_result VARCHAR2(10);\nBEGIN\n  SELECT COUNTRY INTO v_country FROM MEMBER WHERE MEMBER_ID = p_member_id;\n  IF UPPER(v_country) = 'UNITED STATES' THEN\n    v_result := 'USA';\n  ELSE\n    v_result := 'OTHER';\n  END IF;\n  RETURN v_result;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT check_member_country(1) FROM DUAL",
      "SELECT check_member_country(2) FROM DUAL",
      "SELECT check_member_country(3) FROM DUAL",
      "SELECT check_member_country(4) FROM DUAL",
      "SELECT check_member_country(10) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_member_country that accepts a member ID number and returns a VARCHAR2. It retrieves the member's country from the MEMBER table. If the country is 'UNITED STATES', return 'USA'; otherwise, return 'OTHER'.",
    "natural_language": "Please construct a PL/SQL function designated as 'check_member_country'. This function should accept a single input parameter of the member ID number and yield a VARCHAR2 data type as its output. Its operational logic is to query the MEMBER table to obtain the country associated with the provided member ID. Subsequently, if the retrieved country is identified as 'UNITED STATES', the function must return the string 'USA'. In all other instances, it should return the string 'OTHER'.",
    "id": 81
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_leader_for_round` that accepts one input parameter, `p_round_id`, which is of data type `NUMBER` and represents the unique identifier for a specific round. This function is designed to return a `VARCHAR2` value, specifically the name of the leader associated with the specified round, or a default string if no leader is found.\n\nUpon execution, the function declares a local variable `v_leader_name` of type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved leader's name.\n\nThe core logic involves a `SELECT` statement that attempts to retrieve the leader's name. This `SELECT` statement performs a join operation across three tables:\n1.  `COLLEGE` (aliased as `c`): This table presumably stores information about colleges, including a `LEADER_NAME` column and a `COLLEGE_ID` column.\n2.  `MEMBER` (aliased as `m`): This table presumably stores information about members, including a `MEMBER_ID` column and a `COLLEGE_ID` column.\n3.  `ROUND` (aliased as `r`): This table presumably stores information about rounds, including a `ROUND_ID` column and a `MEMBER_ID` column.\n\nThe join conditions are as follows:\n*   `c.COLLEGE_ID = m.COLLEGE_ID`: This links records from the `COLLEGE` table to the `MEMBER` table based on their common `COLLEGE_ID`.\n*   `m.MEMBER_ID = r.MEMBER_ID`: This links records from the `MEMBER` table to the `ROUND` table based on their common `MEMBER_ID`.\n\nThe `WHERE` clause filters the joined results, specifically looking for records where the `ROUND_ID` column in the `ROUND` table (`r.ROUND_ID`) matches the value provided in the input parameter `p_round_id`.\n\nFrom the filtered and joined records, the `SELECT` statement uses the `MAX()` aggregate function on the `LEADER_NAME` column from the `COLLEGE` table (`c.LEADER_NAME`). The result of this `MAX()` function is then stored into the local variable `v_leader_name`. The use of `MAX()` here implies that if multiple `LEADER_NAME` values were associated with the given `p_round_id` (which would be unusual for a single leader, but possible if the joins result in multiple rows for a single round), it would pick the alphabetically last one. However, in the context of finding \"the leader,\" it's more likely intended to simply retrieve the single leader's name if one exists, and `MAX()` would effectively return that single value. If no rows match the `WHERE` clause, `MAX()` will return `NULL`.\n\nFollowing the `SELECT` statement, an `IF` conditional statement checks if the `v_leader_name` variable is `NULL`. If `v_leader_name` is indeed `NULL` (meaning no leader was found for the given `p_round_id` through the `SELECT` query), the variable `v_leader_name` is then assigned the string literal `'NO_LEADER'`.\n\nFinally, the function returns the current value of `v_leader_name`.\n\nThe function also includes an `EXCEPTION` handling block. Specifically, it catches the `NO_DATA_FOUND` exception. This exception typically occurs when a `SELECT INTO` statement returns no rows. If this exception is raised during the execution of the `SELECT` statement, the function immediately returns the string literal `'NO_LEADER'`, overriding any previous assignment to `v_leader_name` or the `IF` condition check.",
    "plsql": "CREATE OR REPLACE FUNCTION get_leader_for_round(p_round_id NUMBER) RETURN VARCHAR2 IS\n  v_leader_name VARCHAR2(255);\nBEGIN\n  SELECT MAX(c.LEADER_NAME) INTO v_leader_name \n  FROM COLLEGE c \n  JOIN MEMBER m ON c.COLLEGE_ID = m.COLLEGE_ID \n  JOIN ROUND r ON m.MEMBER_ID = r.MEMBER_ID \n  WHERE r.ROUND_ID = p_round_id;\n  \n  IF v_leader_name IS NULL THEN\n    v_leader_name := 'NO_LEADER';\n  END IF;\n  \n  RETURN v_leader_name;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 'NO_LEADER';\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_leader_for_round(1) FROM DUAL",
      "SELECT get_leader_for_round(2) FROM DUAL",
      "SELECT get_leader_for_round(10) FROM DUAL",
      "SELECT get_leader_for_round(15) FROM DUAL",
      "SELECT get_leader_for_round(100) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_leader_for_round that accepts a round ID number and returns a VARCHAR2. It retrieves the leader's name by joining the COLLEGE, MEMBER, and ROUND tables for the specified round. If no leader is found or a NO_DATA_FOUND exception occurs, return 'NO_LEADER'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_leader_for_round? It should take a round ID number and spit back a VARCHAR2. Basically, it needs to grab the leader's name by linking up the COLLEGE, MEMBER, and ROUND tables for that specific round. If it comes up empty or hits a NO_DATA_FOUND error, just have it return 'NO_LEADER'.",
    "id": 82
  },
  {
    "ir": "Write an Oracle PL/SQL function named evaluate_theme_length that accepts a single input parameter p_member_id of type NUMBER, which is used to identify a specific member, and returns a VARCHAR2 string. The function begins by declaring two local VARCHAR2 variables: v_theme with a maximum length of 255 characters to hold a decoration theme, and v_evaluation with a maximum length of 20 characters to hold the result. The function executes a SELECT statement that retrieves a single value from the DECORATION_THEME column of the ROUND table, specifically for the row where the MEMBER_ID column matches the provided input parameter p_member_id, and stores this retrieved theme into the variable v_theme. Following the data retrieval, the function uses an IF-THEN-ELSE conditional statement to evaluate the length of the string stored in v_theme by calling the LENGTH function. If the length of v_theme is greater than 15 characters, the function assigns the string literal 'LONG_THEME' to the variable v_evaluation; otherwise, it assigns the string literal 'SHORT_THEME' to v_evaluation. Finally, the function returns the value stored in the v_evaluation variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION evaluate_theme_length(p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_theme VARCHAR2(255);\n  v_evaluation VARCHAR2(20);\nBEGIN\n  SELECT DECORATION_THEME INTO v_theme FROM ROUND WHERE MEMBER_ID = p_member_id;\n  IF LENGTH(v_theme) > 15 THEN\n    v_evaluation := 'LONG_THEME';\n  ELSE\n    v_evaluation := 'SHORT_THEME';\n  END IF;\n  RETURN v_evaluation;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT evaluate_theme_length(1) FROM DUAL",
      "SELECT evaluate_theme_length(2) FROM DUAL",
      "SELECT evaluate_theme_length(10) FROM DUAL",
      "SELECT evaluate_theme_length(3) FROM DUAL",
      "SELECT evaluate_theme_length(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named evaluate_theme_length that accepts a member ID number and returns a VARCHAR2. It retrieves the decoration theme from the ROUND table for the member. If the theme's length is greater than 15 characters, return 'LONG_THEME'; otherwise, return 'SHORT_THEME'.",
    "natural_language": "Make a function evaluate_theme_length(member_id NUMBER) returning VARCHAR2. It gets the member's theme from ROUND. Return 'LONG_THEME' if theme length > 15, else 'SHORT_THEME'.",
    "id": 83
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_payment_method` that is designed to retrieve the payment method associated with a specific customer. This function accepts two input parameters: `p_customer_id`, which is of data type `NUMBER` and represents the unique identifier for a customer, and `p_customer_code`, which is of data type `VARCHAR2` and represents an alphanumeric code associated with the customer. The function is declared to return a value of data type `VARCHAR2`, which will be the retrieved payment method code. Internally, the function declares a local variable `v_payment_method` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the payment method code fetched from the database. The core operation of this function involves a `SELECT` statement that queries the `CUSTOMERS` table. This `SELECT` statement specifically retrieves the value from the `PAYMENT_METHOD_CODE` column. The retrieved value is then immediately assigned to the local variable `v_payment_method`. The selection of the row from which to retrieve this value is based on two conditions combined with a logical `AND` operator: the `CUSTOMER_ID` column in the `CUSTOMERS` table must exactly match the value provided in the `p_customer_id` input parameter, AND the `CUSTOMER_CODE` column in the `CUSTOMERS` table must exactly match the value provided in the `p_customer_code` input parameter. After successfully executing the `SELECT` statement and populating `v_payment_method`, the function then returns the value stored in `v_payment_method` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_payment_method(p_customer_id NUMBER, p_customer_code VARCHAR2) RETURN VARCHAR2 IS\n    v_payment_method VARCHAR2(255);\nBEGIN\n    SELECT PAYMENT_METHOD_CODE INTO v_payment_method FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id AND CUSTOMER_CODE = p_customer_code;\n    RETURN v_payment_method;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "ORDER_ITEMS",
      "STAFF",
      "STAFF_DEPARTMENT_ASSIGNMENTS"
    ],
    "call_sqls": [
      "SELECT get_customer_payment_method(101, 'CUST001') FROM DUAL",
      "SELECT get_customer_payment_method(205, 'CUST205A') FROM DUAL",
      "SELECT get_customer_payment_method(500, 'C500') FROM DUAL",
      "SELECT get_customer_payment_method(1, 'C001') FROM DUAL",
      "SELECT get_customer_payment_method(999, 'VIP999') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_customer_payment_method` that returns a VARCHAR2. It accepts a customer ID (NUMBER) and a customer code (VARCHAR2). The function retrieves the PAYMENT_METHOD_CODE from the CUSTOMERS table where CUSTOMER_ID and CUSTOMER_CODE match the input parameters.",
    "natural_language": "Develop a PL/SQL function called `get_customer_payment_method` that yields a VARCHAR2 value. This function should be designed to accept two distinct input parameters: a numeric customer identifier and an alphanumeric customer code. Its primary purpose is to meticulously query the CUSTOMERS table, specifically to extract and return the PAYMENT_METHOD_CODE for the precise customer record where both the provided CUSTOMER_ID and the supplied CUSTOMER_CODE perfectly correspond to the table's respective columns.",
    "id": 84
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_staff_department that accepts two mandatory input parameters: a numeric parameter p_staff_id representing a staff member's identifier and a numeric parameter p_department_id representing a department's identifier, and returns a single VARCHAR2 string value. The function declares a local variable v_job_title of type VARCHAR2 with a maximum length of 255 characters to hold the result. The function's execution block performs a single SELECT operation, querying the STAFF_DEPARTMENT_ASSIGNMENTS table to retrieve the value from its JOB_TITLE_CODE column. The SELECT statement uses a WHERE clause with an AND condition to find the specific row where the table's STAFF_ID column exactly matches the input parameter p_staff_id and the table's DEPARTMENT_ID column exactly matches the input parameter p_department_id. The value retrieved from the JOB_TITLE_CODE column for that matching row is stored into the local variable v_job_title. The function then concludes by using a RETURN statement to output the value stored in v_job_title as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_department(p_staff_id NUMBER, p_department_id NUMBER) RETURN VARCHAR2 IS\n    v_job_title VARCHAR2(255);\nBEGIN\n    SELECT JOB_TITLE_CODE INTO v_job_title FROM STAFF_DEPARTMENT_ASSIGNMENTS WHERE STAFF_ID = p_staff_id AND DEPARTMENT_ID = p_department_id;\n    RETURN v_job_title;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "ORDER_ITEMS",
      "STAFF",
      "STAFF_DEPARTMENT_ASSIGNMENTS"
    ],
    "call_sqls": [
      "SELECT get_staff_department(5, 4) FROM DUAL",
      "SELECT get_staff_department(10, 5) FROM DUAL",
      "SELECT get_staff_department(1, 4) FROM DUAL",
      "SELECT get_staff_department(5, 5) FROM DUAL",
      "SELECT get_staff_department(10, 4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_staff_department` that returns a VARCHAR2. It accepts a staff ID (NUMBER) and a department ID (NUMBER). The function retrieves the JOB_TITLE_CODE from the STAFF_DEPARTMENT_ASSIGNMENTS table where STAFF_ID and DEPARTMENT_ID match the input parameters.",
    "natural_language": "Develop a PL/SQL function called `get_staff_department` that yields a VARCHAR2 data type. This function is designed to accept two distinct numeric parameters: a specific staff identifier and a corresponding department identifier. Its primary purpose is to meticulously query the STAFF_DEPARTMENT_ASSIGNMENTS table in order to fetch and return the precise JOB_TITLE_CODE for the unique record where the provided STAFF_ID perfectly aligns with the given staff parameter and, simultaneously, where the DEPARTMENT_ID exactly matches the supplied department parameter.",
    "id": 85
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes two parameters: p_customer_id of type NUMBER and p_customer_name of type VARCHAR2, and returns a VARCHAR2 value. The function retrieves the CUSTOMER_ADDRESS from the CUSTOMERS table by executing a SELECT statement that searches for a row where the CUSTOMER_ID column matches the value of p_customer_id and the CUSTOMER_NAME column matches the value of p_customer_name. The result of this SELECT statement is stored in a local variable v_address of type VARCHAR2 with a maximum length of 255 characters. The function then returns the value stored in v_address.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_address(p_customer_id NUMBER, p_customer_name VARCHAR2) RETURN VARCHAR2 IS\n    v_address VARCHAR2(255);\nBEGIN\n    SELECT CUSTOMER_ADDRESS INTO v_address FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id AND CUSTOMER_NAME = p_customer_name;\n    RETURN v_address;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "ORDER_ITEMS",
      "STAFF",
      "STAFF_DEPARTMENT_ASSIGNMENTS"
    ],
    "call_sqls": [
      "SELECT get_customer_address(101, 'John Smith') FROM dual",
      "SELECT get_customer_address(205, 'Jane Doe') FROM dual",
      "SELECT get_customer_address(500, 'Robert Johnson') FROM dual",
      "SELECT get_customer_address(42, 'Alice Brown') FROM dual",
      "SELECT get_customer_address(789, 'Michael Wilson') FROM dual"
    ],
    "summary": "Create a PL/SQL function that returns a VARCHAR2. It accepts a customer ID (NUMBER) and a customer name (VARCHAR2). The function retrieves the CUSTOMER_ADDRESS from the CUSTOMERS table where CUSTOMER_ID and CUSTOMER_NAME match the input parameters.",
    "natural_language": "Function returning VARCHAR2: get customer address by ID and name.",
    "id": 86
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_staff_name that accepts two parameters: p_staff_id of type NUMBER and p_staff_gender of type VARCHAR2. The purpose of this function is to retrieve and return the name of a staff member from the STAFF table. The function begins by declaring a local variable v_name of type VARCHAR2 with a maximum length of 255 characters, which will be used to store the staff name retrieved from the database. The function then executes a SELECT statement to fetch the STAFF_NAME from the STAFF table, where the STAFF_ID column matches the value of the p_staff_id parameter and the STAFF_GENDER column matches the value of the p_staff_gender parameter. The result of this query is stored in the v_name variable. Finally, the function returns the value of v_name, which contains the name of the staff member that meets the specified criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_name(p_staff_id NUMBER, p_staff_gender VARCHAR2) RETURN VARCHAR2 IS\n    v_name VARCHAR2(255);\nBEGIN\n    SELECT STAFF_NAME INTO v_name FROM STAFF WHERE STAFF_ID = p_staff_id AND STAFF_GENDER = p_staff_gender;\n    RETURN v_name;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "ORDER_ITEMS",
      "STAFF",
      "STAFF_DEPARTMENT_ASSIGNMENTS"
    ],
    "call_sqls": [
      "SELECT get_staff_name(1, '1') FROM DUAL",
      "SELECT get_staff_name(2, '1') FROM DUAL",
      "SELECT get_staff_name(3, '1') FROM DUAL",
      "SELECT get_staff_name(1, '0') FROM DUAL",
      "SELECT get_staff_name(4, '1') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_staff_name` that returns a VARCHAR2. It accepts a staff ID (NUMBER) and a staff gender (VARCHAR2). The function retrieves the STAFF_NAME from the STAFF table where STAFF_ID and STAFF_GENDER match the input parameters.",
    "natural_language": "Write a PL/SQL function called `get_staff_name` that gives back a text string. It should take a staff number and a gender indicator. The function needs to look up and return the staff member's name from the STAFF records when the provided ID and general gender description seem to match the table's data.",
    "id": 87
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_individual_full_name` that is designed to retrieve the concatenated full name of an individual based on their unique identifier. This function accepts one input parameter: `p_individual_id`, which is of data type `NUMBER` and represents the primary key or unique identifier for an individual record in the `INDIVIDUALS` table. The function is declared to return a `VARCHAR2` data type, which will hold the full name of the individual.\n\nInside the function's execution block, a local variable `v_full_name` of type `VARCHAR2` with a maximum length of 255 characters is declared to temporarily store the retrieved full name. The core operation involves a `SELECT` statement that queries the `INDIVIDUALS` table. This `SELECT` statement concatenates the values from the `INDIVIDUAL_FIRST_NAME` column and the `INDIVIDUAL_LAST_NAME` column, separated by a single space character. The `TRIM` function is applied to the result of this concatenation to remove any leading or trailing whitespace that might result from empty first or last names, or from the concatenation itself. The concatenated and trimmed full name is then assigned to the `v_full_name` variable using the `INTO` clause. The `WHERE` clause of the `SELECT` statement filters the records in the `INDIVIDUALS` table, ensuring that only the row where the `INDIVIDUAL_ID` column matches the value provided in the input parameter `p_individual_id` is selected. After successfully retrieving and assigning the full name to `v_full_name`, the function concludes by returning the value stored in `v_full_name` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_individual_full_name(p_individual_id NUMBER) RETURN VARCHAR2 IS\n  v_full_name VARCHAR2(255);\nBEGIN\n  SELECT TRIM(INDIVIDUAL_FIRST_NAME || ' ' || INDIVIDUAL_LAST_NAME) INTO v_full_name\n  FROM INDIVIDUALS\n  WHERE INDIVIDUAL_ID = p_individual_id;\n  RETURN v_full_name;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_individual_full_name(1) FROM DUAL",
      "SELECT get_individual_full_name(2) FROM DUAL",
      "SELECT get_individual_full_name(3) FROM DUAL",
      "SELECT get_individual_full_name(10) FROM DUAL",
      "SELECT get_individual_full_name(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_individual_full_name` that returns a VARCHAR2. It accepts an individual ID (NUMBER). The function retrieves the trimmed concatenation of INDIVIDUAL_FIRST_NAME and INDIVIDUAL_LAST_NAME (separated by a space) from the INDIVIDUALS table where INDIVIDUAL_ID matches the input parameter.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_individual_full_name`? It should spit back a VARCHAR2. You'll give it an individual's ID (as a NUMBER). What it does is grab the person's first and last name from the INDIVIDUALS table, smoosh 'em together with a space in between (and trim off any extra spaces), but only for the record where the INDIVIDUAL_ID matches the number you passed in.",
    "id": 88
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_organization_vat that accepts a single input parameter p_organization_id of the NUMBER data type and returns a value of the VARCHAR2 data type, which executes a SELECT statement to query the UK_VAT_NUMBER column from the ORGANIZATIONS table, specifically retrieving the value from the row where the ORGANIZATION_ID column exactly matches the provided p_organization_id parameter value, storing the result into a local variable v_vat_number of VARCHAR2(255), and then returns the content of this v_vat_number variable as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_organization_vat(p_organization_id NUMBER) RETURN VARCHAR2 IS\n  v_vat_number VARCHAR2(255);\nBEGIN\n  SELECT UK_VAT_NUMBER INTO v_vat_number\n  FROM ORGANIZATIONS\n  WHERE ORGANIZATION_ID = p_organization_id;\n  RETURN v_vat_number;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_organization_vat(1) FROM DUAL",
      "SELECT get_organization_vat(2) FROM DUAL",
      "SELECT get_organization_vat(3) FROM DUAL"
    ],
    "summary": "Create a function named get_organization_vat that accepts a NUMBER parameter p_organization_id and returns a VARCHAR2. It queries the UK_VAT_NUMBER from the ORGANIZATIONS table where ORGANIZATION_ID matches the parameter, stores it in a VARCHAR2(255) variable, and returns that value.",
    "natural_language": "Write a function get_organization_vat that takes a NUMBER p_organization_id and returns a VARCHAR2. Fetch UK_VAT_NUMBER from ORGANIZATIONS for the given ID into a VARCHAR2(255) variable and return it.",
    "id": 89
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_address_country that accepts a single parameter, p_address_id, which is of type NUMBER and represents the unique identifier of an address. The function is designed to return a value of type VARCHAR2, specifically the country associated with the given address ID. Within the function, a local variable v_country of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the country name. The function executes a SELECT statement to retrieve the COUNTRY column from the ADDRESSES table, where the ADDRESS_ID column matches the value of the input parameter p_address_id. The retrieved country name is stored in the v_country variable. Finally, the function returns the value stored in v_country, which is the country name corresponding to the specified address ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_address_country(p_address_id NUMBER) RETURN VARCHAR2 IS\n  v_country VARCHAR2(255);\nBEGIN\n  SELECT COUNTRY INTO v_country\n  FROM ADDRESSES\n  WHERE ADDRESS_ID = p_address_id;\n  RETURN v_country;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_address_country(1) FROM dual",
      "SELECT get_address_country(2) FROM dual",
      "SELECT get_address_country(3) FROM dual",
      "SELECT get_address_country(4) FROM dual",
      "SELECT get_address_country(5) FROM dual"
    ],
    "summary": "Create a function named get_address_country that accepts a NUMBER parameter p_address_id and returns a VARCHAR2. It queries the COUNTRY from the ADDRESSES table where ADDRESS_ID matches the parameter, stores it in a VARCHAR2(255) variable, and returns that value.",
    "natural_language": "Create a function called get_address_country that takes a NUMBER for the address identifier and gives back a VARCHAR2. It should look up the general area or COUNTRY from the ADDRESSES list for entries that are kind of close to the provided ID, put that into a text variable, and then hand back that result.",
    "id": 90
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_party_form_status` that accepts a single input parameter, `p_party_id`, which is of data type `NUMBER` and represents a unique identifier for a party. This function is designed to return a `VARCHAR2` value, specifically a form status code. Upon execution, the function initializes a local variable `v_form_status` of type `VARCHAR2` with a maximum length of 255 characters. The primary operation involves attempting to retrieve a `FORM_STATUS_CODE` from the `PARTY_FORMS` table. This retrieval is performed by selecting the `FORM_STATUS_CODE` column and storing its value into the `v_form_status` variable. The selection is constrained by two conditions: first, the `PARTY_ID` column in the `PARTY_FORMS` table must match the value provided in the `p_party_id` input parameter; second, `ROWNUM = 1` is used to ensure that only the first row encountered that satisfies the `PARTY_ID` condition is considered, effectively limiting the result set to a single row. After this selection, the function immediately returns the value stored in `v_form_status`. The function includes exception handling for two specific scenarios. If a `NO_DATA_FOUND` exception occurs, meaning no rows in the `PARTY_FORMS` table match the provided `p_party_id`, the function returns `NULL`. If a `TOO_MANY_ROWS` exception occurs, indicating that the initial `SELECT` statement found more than one row matching the `p_party_id` (despite the `ROWNUM = 1` clause, which would prevent the exception from being raised by the `SELECT` itself, but rather by the implicit assumption of a single row return for `INTO` clause without `ROWNUM=1` or if `ROWNUM=1` was not effective in preventing multiple rows from being considered by the database engine before the `INTO` clause), the function executes a second `SELECT` statement. This second `SELECT` statement is identical to the first: it selects the `FORM_STATUS_CODE` into `v_form_status` from the `PARTY_FORMS` table where `PARTY_ID` matches `p_party_id` and `ROWNUM = 1`. This ensures that even if multiple rows exist for the given `p_party_id`, only the `FORM_STATUS_CODE` from the first encountered row is retrieved and subsequently returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_party_form_status(p_party_id NUMBER) RETURN VARCHAR2 IS\n  v_form_status VARCHAR2(255);\nBEGIN\n  SELECT FORM_STATUS_CODE INTO v_form_status\n  FROM PARTY_FORMS\n  WHERE PARTY_ID = p_party_id\n  AND ROWNUM = 1;\n  \n  RETURN v_form_status;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    -- Get the first status if multiple exist\n    SELECT FORM_STATUS_CODE INTO v_form_status\n    FROM PARTY_FORMS\n    WHERE PARTY_ID = p_party_id\n    AND ROWNUM = 1;\n    RETURN v_form_status;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_party_form_status(2) FROM dual",
      "SELECT get_party_form_status(15) FROM dual",
      "SELECT get_party_form_status(8) FROM dual",
      "SELECT get_party_form_status(10) FROM dual",
      "SELECT get_party_form_status(4) FROM dual"
    ],
    "summary": "Create a function named get_party_form_status that accepts a NUMBER parameter p_party_id and returns a VARCHAR2. It queries the FORM_STATUS_CODE from the PARTY_FORMS table where PARTY_ID matches the parameter, returning the first row's value. Handle NO_DATA_FOUND by returning NULL and TOO_MANY_ROWS by re-querying with ROWNUM = 1.",
    "natural_language": "Function get_party_form_status(p_party_id NUMBER) returns VARCHAR2. Fetch FORM_STATUS_CODE from PARTY_FORMS for given PARTY_ID. Return first row's value. On NO_DATA_FOUND return NULL. On TOO_MANY_ROWS requery with ROWNUM=1.",
    "id": 91
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_contact_date_range` that accepts two input parameters: `p_individual_id` of data type `NUMBER`, representing a unique identifier for an individual, and `p_organization_id` of data type `NUMBER`, representing a unique identifier for an organization. This function is designed to return a single `VARCHAR2` value, which will represent a formatted date range. Upon execution, the function declares a local variable `v_date_range` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved and formatted date range. The core operation of the function involves executing a `SELECT` statement to retrieve specific date information from the `ORGANIZATION_CONTACT_INDIVIDUALS` table. Specifically, it selects the `DATE_CONTACT_FROM` column and the `DATE_CONTACT_TO` column. Before concatenation, the `DATE_CONTACT_FROM` value is converted to a character string using the `TO_CHAR` function, and similarly, the `DATE_CONTACT_TO` value is converted to a character string using the `TO_CHAR` function. These two formatted date strings are then concatenated together with the literal string ' to ' in between them, forming a single string representing the date range. This resulting concatenated string is then assigned to the `v_date_range` local variable. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `ORGANIZATION_CONTACT_INDIVIDUALS` table. The filtering conditions require that the `INDIVIDUAL_ID` column in the table must be equal to the value passed in the `p_individual_id` input parameter, AND the `ORGANIZATION_ID` column in the table must be equal to the value passed in the `p_organization_id` input parameter. After successfully retrieving and formatting the date range into `v_date_range`, the function then returns the value stored in `v_date_range` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_contact_date_range(p_individual_id NUMBER, p_organization_id NUMBER) RETURN VARCHAR2 IS\n  v_date_range VARCHAR2(255);\nBEGIN\n  SELECT TO_CHAR(DATE_CONTACT_FROM) || ' to ' || TO_CHAR(DATE_CONTACT_TO) INTO v_date_range\n  FROM ORGANIZATION_CONTACT_INDIVIDUALS\n  WHERE INDIVIDUAL_ID = p_individual_id AND ORGANIZATION_ID = p_organization_id;\n  RETURN v_date_range;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_contact_date_range(13, 1) FROM DUAL",
      "SELECT get_contact_date_range(11, 3) FROM DUAL",
      "SELECT get_contact_date_range(10, 1) FROM DUAL",
      "SELECT get_contact_date_range(1, 1) FROM DUAL",
      "SELECT get_contact_date_range(2, 2) FROM DUAL"
    ],
    "summary": "Create a function named get_contact_date_range that accepts two NUMBER parameters, p_individual_id and p_organization_id, and returns a VARCHAR2. It queries the DATE_CONTACT_FROM and DATE_CONTACT_TO from the ORGANIZATION_CONTACT_INDIVIDUALS table where INDIVIDUAL_ID and ORGANIZATION_ID match the parameters, formats them with TO_CHAR, concatenates them with ' to ', stores the result in a VARCHAR2(255) variable, and returns it.",
    "natural_language": "Please construct a function designated as 'get_contact_date_range'. This function shall accept two parameters of the NUMBER data type, specifically 'p_individual_id' and 'p_organization_id', and will return a value of type VARCHAR2. The function's logic must query the ORGANIZATION_CONTACT_INDIVIDUALS table to retrieve the DATE_CONTACT_FROM and DATE_CONTACT_TO columns for records where the INDIVIDUAL_ID and ORGANIZATION_ID match the provided parameters. These date values are to be formatted using the TO_CHAR function, concatenated with the string ' to ', and assigned to a local variable declared as VARCHAR2(255). The function must ultimately return the content of this variable.",
    "id": 92
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_service_type_by_event that accepts two mandatory input parameters: para_event_id of type NUMBER, which represents the unique identifier for an event, and para_participant_id of type NUMBER, which represents the unique identifier for a participant. The function returns a single VARCHAR2 value with a maximum length of 255 characters. The function's execution begins by declaring a local variable v_service_type of type VARCHAR2(255) to hold the result. The core logic performs a SELECT operation that retrieves data from three tables: EVENTS (aliased as e), SERVICES (aliased as s), and PARTICIPANTS_IN_EVENTS (aliased as pie). It joins the EVENTS table to the SERVICES table using the condition that the SERVICE_ID column in the EVENTS table matches the SERVICE_ID column in the SERVICES table. It also joins the EVENTS table to the PARTICIPANTS_IN_EVENTS table using the condition that the EVENT_ID column in the EVENTS table matches the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table. The SELECT statement specifically fetches the value from the SERVICE_TYPE_CODE column of the SERVICES table. The WHERE clause filters the combined result set to include only rows where the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table is equal to the input parameter para_event_id and where the PARTICIPANT_ID column in the PARTICIPANTS_IN_EVENTS table is equal to the input parameter para_participant_id. The retrieved SERVICE_TYPE_CODE value is assigned into the local variable v_service_type. Finally, the function returns the value stored in v_service_type.",
    "plsql": "CREATE OR REPLACE FUNCTION get_service_type_by_event(para_event_id NUMBER, para_participant_id NUMBER) RETURN VARCHAR2 IS\n  v_service_type VARCHAR2(255);\nBEGIN\n  SELECT s.SERVICE_TYPE_CODE INTO v_service_type\n  FROM EVENTS e\n  JOIN SERVICES s ON e.SERVICE_ID = s.SERVICE_ID\n  JOIN PARTICIPANTS_IN_EVENTS pie ON e.EVENT_ID = pie.EVENT_ID\n  WHERE pie.EVENT_ID = para_event_id AND pie.PARTICIPANT_ID = para_participant_id;\n  RETURN v_service_type;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_service_type_by_event(3, 26) FROM DUAL",
      "SELECT get_service_type_by_event(8, 66) FROM DUAL",
      "SELECT get_service_type_by_event(13, 86) FROM DUAL",
      "SELECT get_service_type_by_event(3, 9) FROM DUAL",
      "SELECT get_service_type_by_event(8, 28) FROM DUAL"
    ],
    "summary": "Create a function named get_service_type_by_event that accepts two NUMBER parameters, para_event_id and para_participant_id, and returns a VARCHAR2(255). It queries the SERVICE_TYPE_CODE from the SERVICES table by joining EVENTS and PARTICIPANTS_IN_EVENTS where the EVENT_ID and PARTICIPANT_ID match the parameters, stores the result in a variable, and returns it.",
    "natural_language": "Create a function called get_service_type_by_event that takes a couple of NUMBER inputs, para_event_id and para_participant_id, and gives back a VARCHAR2(255). It should look up the SERVICE_TYPE_CODE from the SERVICES table by connecting it with EVENTS and PARTICIPANTS_IN_EVENTS where the IDs are roughly the same as the provided ones, put whatever it finds into a variable, and then return that result.",
    "id": 93
  },
  {
    "ir": "Write an Oracle PL/SQL function named `count_participants` that is designed to calculate and return the total number of participants associated with a specific event and of a particular type. This function accepts two input parameters: `para_event_id`, which is of data type `NUMBER` and represents the unique identifier for the event for which participants are to be counted, and `para_participant_type`, which is of data type `VARCHAR2` and specifies the type or category of participants to be included in the count. The function is declared to return a single value of data type `NUMBER`, which will be the calculated count.\n\nUpon execution, the function declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of the counting operation. The core logic of the function involves a single `SELECT` statement. This `SELECT` statement performs a count of rows (`COUNT(*)`) and stores this aggregated value into the `v_count` variable. The data for this count is retrieved by joining two tables: `PARTICIPANTS` (aliased as `p`) and `PARTICIPANTS_IN_EVENTS` (aliased as `pie`). The join condition `p.PARTICIPANT_ID = pie.PARTICIPANT_ID` establishes a relationship between participants and their event participations based on their common participant identifier.\n\nThe rows considered for the count are filtered by a `WHERE` clause that applies two conditions. The first condition, `pie.EVENT_ID = para_event_id`, ensures that only participations related to the event identified by the `para_event_id` input parameter are included. The second condition, `p.PARTICIPANT_TYPE_CODE = para_participant_type`, further restricts the selection to only those participants whose `PARTICIPANT_TYPE_CODE` column matches the value provided in the `para_participant_type` input parameter. After the `SELECT` statement has executed and the count is stored in `v_count`, the function then returns the final value of `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_participants(para_event_id NUMBER, para_participant_type VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count\n  FROM PARTICIPANTS p\n  JOIN PARTICIPANTS_IN_EVENTS pie ON p.PARTICIPANT_ID = pie.PARTICIPANT_ID\n  WHERE pie.EVENT_ID = para_event_id AND p.PARTICIPANT_TYPE_CODE = para_participant_type;\n  RETURN v_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT count_participants(3, 'Organizer') FROM DUAL",
      "SELECT count_participants(8, 'Organizer') FROM DUAL",
      "SELECT count_participants(13, 'Organizer') FROM DUAL",
      "SELECT count_participants(3, 'Attendee') FROM DUAL",
      "SELECT count_participants(8, 'Speaker') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `count_participants` that returns the number of participants for a given event ID and participant type code by counting rows from the PARTICIPANTS and PARTICIPANTS_IN_EVENTS tables where the IDs match and the conditions are met.",
    "natural_language": "How can I create a PL/SQL function named `count_participants` that returns the number of participants for a specific event ID and participant type code by counting the relevant rows from the PARTICIPANTS and PARTICIPANTS_IN_EVENTS tables?",
    "id": 94
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_event_details that accepts two mandatory input parameters: para_event_id of type NUMBER, which is used to identify a specific event, and para_service_id of type NUMBER, which is used to identify a specific service, and returns a single VARCHAR2 value with a maximum length of 255 characters; within the function's execution block, it declares a local variable v_event_details of type VARCHAR2(255) to hold the result, then performs a SELECT operation on the EVENTS table, aliased as 'e', to retrieve the value from the EVENT_DETAILS column for the single row where the condition e.EVENT_ID equals the input para_event_id AND the condition e.SERVICE_ID equals the input para_service_id is true, storing the retrieved value into the local variable v_event_details, and finally returns the content of v_event_details as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_event_details(para_event_id NUMBER, para_service_id NUMBER) RETURN VARCHAR2 IS\n  v_event_details VARCHAR2(255);\nBEGIN\n  SELECT e.EVENT_DETAILS INTO v_event_details\n  FROM EVENTS e\n  WHERE e.EVENT_ID = para_event_id AND e.SERVICE_ID = para_service_id;\n  RETURN v_event_details;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_event_details(3, 5) FROM dual",
      "SELECT get_event_details(8, 5) FROM dual",
      "SELECT get_event_details(13, 5) FROM dual",
      "SELECT get_event_details(3, 8) FROM dual",
      "SELECT get_event_details(8, 8) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_event_details` that returns the EVENT_DETAILS (as VARCHAR2(255)) for a specific event ID and service ID by selecting from the EVENTS table where both conditions match.",
    "natural_language": "What is the PL/SQL function definition for `get_event_details` that selects and returns the EVENT_DETAILS (as a VARCHAR2(255)) from the EVENTS table for a given event ID and service ID?",
    "id": 95
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_participant_details` that accepts two input parameters: `para_participant_id` of data type `NUMBER` which represents the unique identifier for a participant, and `para_event_id` of data type `NUMBER` which represents the unique identifier for an event. This function is designed to return a single value of data type `VARCHAR2`. Internally, the function declares a local variable named `v_participant_details` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved participant details. The core operation of this function involves executing a `SELECT` statement to retrieve specific participant information. This `SELECT` statement queries the `PARTICIPANTS` table, aliased as `p`, and performs an `INNER JOIN` with the `PARTICIPANTS_IN_EVENTS` table, aliased as `pie`. The join condition links rows from `PARTICIPANTS` to `PARTICIPANTS_IN_EVENTS` where the `PARTICIPANT_ID` column in the `PARTICIPANTS` table (`p.PARTICIPANT_ID`) matches the `PARTICIPANT_ID` column in the `PARTICIPANTS_IN_EVENTS` table (`pie.PARTICIPANT_ID`). The `WHERE` clause of the `SELECT` statement filters the joined results to include only those rows where the `PARTICIPANT_ID` column in the `PARTICIPANTS_IN_EVENTS` table (`pie.PARTICIPANT_ID`) is equal to the value provided in the `para_participant_id` input parameter, AND the `EVENT_ID` column in the `PARTICIPANTS_IN_EVENTS` table (`pie.EVENT_ID`) is equal to the value provided in the `para_event_id` input parameter. The value from the `PARTICIPANT_DETAILS` column of the `PARTICIPANTS` table (`p.PARTICIPANT_DETAILS`) for the single row that satisfies these conditions is then selected and stored into the local variable `v_participant_details`. Finally, the function returns the value stored in `v_participant_details` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_participant_details(para_participant_id NUMBER, para_event_id NUMBER) RETURN VARCHAR2 IS\n  v_participant_details VARCHAR2(255);\nBEGIN\n  SELECT p.PARTICIPANT_DETAILS INTO v_participant_details\n  FROM PARTICIPANTS p\n  JOIN PARTICIPANTS_IN_EVENTS pie ON p.PARTICIPANT_ID = pie.PARTICIPANT_ID\n  WHERE pie.PARTICIPANT_ID = para_participant_id AND pie.EVENT_ID = para_event_id;\n  RETURN v_participant_details;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_participant_details(26, 3) FROM dual",
      "SELECT get_participant_details(26, 8) FROM dual",
      "SELECT get_participant_details(9, 3) FROM dual",
      "SELECT get_participant_details(9, 8) FROM dual",
      "SELECT get_participant_details(28, 3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_participant_details` that returns the PARTICIPANT_DETAILS (as VARCHAR2(255)) for a specific participant ID and event ID by joining the PARTICIPANTS and PARTICIPANTS_IN_EVENTS tables where both IDs match.",
    "natural_language": "Develop a PL/SQL function called `get_participant_details` that meticulously retrieves and returns the PARTICIPANT_DETAILS, which is defined as a VARCHAR2(255) data type, for a precisely specified participant ID and a corresponding event ID. This is accomplished by carefully joining the PARTICIPANTS table with the PARTICIPANTS_IN_EVENTS table, ensuring a match on both the participant identifier and the event identifier.",
    "id": 96
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_service_type_by_participant that accepts two mandatory input parameters: a numeric parameter named para_participant_id and a numeric parameter named para_event_id, and returns a variable-length character string with a maximum length of 255 characters. The function declares a local variable v_service_type of type VARCHAR2(255) to hold the result. The function's execution block performs a single SELECT statement that queries the SERVICES table, aliased as 's', the EVENTS table, aliased as 'e', and the PARTICIPANTS_IN_EVENTS table, aliased as 'pie'. It joins the SERVICES table to the EVENTS table using the condition that the SERVICE_ID column in the SERVICES table must equal the SERVICE_ID column in the EVENTS table. It then joins the result to the PARTICIPANTS_IN_EVENTS table using the condition that the EVENT_ID column in the EVENTS table must equal the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table. The SELECT statement includes a WHERE clause with two conditions combined with an AND operator: the first condition requires the PARTICPANT_ID column from the PARTICIPANTS_IN_EVENTS table to be equal to the input parameter para_participant_id, and the second condition requires the EVENT_ID column from the PARTICIPANTS_IN_EVENTS table to be equal to the input parameter para_event_id. From the resulting joined row set, the SELECT statement retrieves the value from the SERVICE_TYPE_CODE column of the SERVICES table and stores it into the local variable v_service_type. Finally, the function returns the value stored in the v_service_type variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_service_type_by_participant(para_participant_id NUMBER, para_event_id NUMBER) RETURN VARCHAR2 IS\n  v_service_type VARCHAR2(255);\nBEGIN\n  SELECT s.SERVICE_TYPE_CODE INTO v_service_type\n  FROM SERVICES s\n  JOIN EVENTS e ON s.SERVICE_ID = e.SERVICE_ID\n  JOIN PARTICIPANTS_IN_EVENTS pie ON e.EVENT_ID = pie.EVENT_ID\n  WHERE pie.PARTICIPANT_ID = para_participant_id AND pie.EVENT_ID = para_event_id;\n  RETURN v_service_type;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_service_type_by_participant(26, 3) FROM dual",
      "SELECT get_service_type_by_participant(26, 8) FROM dual",
      "SELECT get_service_type_by_participant(9, 3) FROM dual",
      "SELECT get_service_type_by_participant(9, 8) FROM dual",
      "SELECT get_service_type_by_participant(28, 3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_service_type_by_participant` that returns the SERVICE_TYPE_CODE (as VARCHAR2(255)) for a given participant ID and event ID by joining the SERVICES, EVENTS, and PARTICIPANTS_IN_EVENTS tables where the IDs match.",
    "natural_language": "Write a function `get_service_type_by_participant` to return SERVICE_TYPE_CODE for a participant and event ID.",
    "id": 97
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_movie_count` that is designed to return a single numeric value representing the total number of records present in the `MOVIE` table. This function does not accept any input parameters. Internally, it declares a local variable named `movie_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation involves executing a `SELECT` statement that calculates the count of all rows in the `MOVIE` table using the aggregate function `COUNT(*)`. The result of this `COUNT(*)` operation is then immediately assigned to the `movie_count` local variable using the `INTO` clause. Finally, the function returns the value currently held by the `movie_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_count RETURN NUMBER IS\n  movie_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO movie_count FROM MOVIE;\n  RETURN movie_count;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_count FROM dual",
      "SELECT get_movie_count() FROM dual",
      "SELECT get_movie_count FROM sys.dual",
      "SELECT get_movie_count() FROM sys.dual",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_movie_count;\n  DBMS_OUTPUT.PUT_LINE('Movie count: ' || v_count);\nEND;"
    ],
    "summary": "Create a PL/SQL function named `get_movie_count` that returns the total number of records in the MOVIE table using COUNT(*), with no input parameters.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_movie_count` for me? It shouldn't need any inputs, and it's gotta just spit out how many movies are in the MOVIE table—you know, by counting all the rows.",
    "id": 98
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_highest_rating that takes no input parameters and returns a single numeric value; within its execution block, it performs a SELECT query on the RATING table to retrieve the maximum value found in the STARS column, storing this result into a local variable named highest_rating, and then returns the value contained in this highest_rating variable as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_rating RETURN NUMBER IS\n  highest_rating NUMBER;\nBEGIN\n  SELECT MAX(STARS) INTO highest_rating FROM RATING;\n  RETURN highest_rating;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_highest_rating FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_highest_rating;\n  DBMS_OUTPUT.PUT_LINE('Highest Rating: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Highest Rating is: ' || get_highest_rating);\nEND;",
      "SELECT m.title, r.stars\nFROM movie m\nJOIN rating r ON m.mid = r.mid\nWHERE r.stars = get_highest_rating",
      "INSERT INTO rating (rid, mid, stars, ratingdate)\nVALUES (205, 103, get_highest_rating, '2024-01-15')"
    ],
    "summary": "Create a PL/SQL function named get_highest_rating that returns the maximum value from the STARS column of the RATING table.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be designated as get_highest_rating, that meticulously retrieves and returns the absolutely greatest numerical value found within the STARS column, which is part of the extensively detailed RATING table.",
    "id": 99
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_rating that calculates and returns the average value of the STARS column from the RATING table. The function does not take any input parameters and returns a NUMBER type value. Within the function body, a SELECT statement is executed to compute the average of all values in the STARS column, which is a numeric column representing ratings, and the result is stored in a local variable named avg_rating of type NUMBER. The SELECT statement uses the AVG() aggregate function to perform the calculation across all rows in the RATING table, without any filtering conditions, thereby considering every entry in the STARS column. After the average is computed and stored in avg_rating, the function returns this value as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_rating RETURN NUMBER IS\n  avg_rating NUMBER;\nBEGIN\n  SELECT AVG(STARS) INTO avg_rating FROM RATING;\n  RETURN avg_rating;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_average_rating FROM DUAL",
      "SELECT get_average_rating() FROM DUAL",
      "DECLARE\n  avg_val NUMBER;\nBEGIN\n  avg_val := get_average_rating;\n  DBMS_OUTPUT.PUT_LINE('Average: ' || avg_val);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average Rating: ' || get_average_rating);\nEND;",
      "SELECT m.title, get_average_rating AS overall_avg FROM movie m WHERE rownum = 1"
    ],
    "summary": "Create a PL/SQL function named get_average_rating that returns the average value of the STARS column from the RATING table.",
    "natural_language": "Write a function get_average_rating to return the average STARS from RATING.",
    "id": 100
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_reviewer_count that takes no input parameters and returns a single numeric value of type NUMBER, which is the total count of all rows currently present in the database table named REVIEWER, by executing a SELECT COUNT(*) query that aggregates all rows from the REVIEWER table without any filtering conditions or joins, storing the resulting scalar count value into a local variable named reviewer_count of type NUMBER, and then immediately returning that variable's value as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_reviewer_count RETURN NUMBER IS\n  reviewer_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO reviewer_count FROM REVIEWER;\n  RETURN reviewer_count;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_reviewer_count FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_reviewer_count that returns the total number of rows in the REVIEWER table.",
    "natural_language": "What is the total number of rows in the REVIEWER table? Create a PL/SQL function named get_reviewer_count to return this value.",
    "id": 101
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_movie_title_length that calculates and returns a numeric value representing the average length of movie titles stored in the TITLE column of the MOVIE table. The function does not take any input parameters. Inside the function, a local variable named avg_length of type NUMBER is declared to store the result of the calculation. The function executes a SQL SELECT statement that computes the average length of all values in the TITLE column by using the LENGTH function to determine the length of each title. The AVG function is then applied to these lengths to calculate the average. The result of this calculation is stored in the avg_length variable using the INTO clause. Finally, the function returns the value of avg_length, which represents the average length of the movie titles in the MOVIE table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_title_length RETURN NUMBER IS\n  avg_length NUMBER;\nBEGIN\n  SELECT AVG(LENGTH(TITLE)) INTO avg_length FROM MOVIE;\n  RETURN avg_length;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_title_length FROM dual",
      "SELECT get_movie_title_length() FROM dual",
      "DECLARE\n  avg_len NUMBER;\nBEGIN\n  avg_len := get_movie_title_length;\n  DBMS_OUTPUT.PUT_LINE('Average title length: ' || avg_len);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Result: ' || get_movie_title_length);\nEND;",
      "SELECT m.title, LENGTH(m.title), get_movie_title_length AS avg_length FROM movie m WHERE m.mid = 101"
    ],
    "summary": "Create a PL/SQL function named get_movie_title_length that returns the average character length of the TITLE column in the MOVIE table.",
    "natural_language": "Write a PL/SQL function called get_movie_title_length that gives us a rough idea of the typical length, in characters, for the TITLE entries in the MOVIE table.",
    "id": 102
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_album_song_count that accepts a single input parameter p_album_id of the NUMBER data type, which represents the unique identifier of an album, and returns a single NUMBER value. The function declares a local variable v_count of type NUMBER, initializing it to zero. The core operation is a SELECT statement that queries the TRACKLISTS table, using the COUNT(*) aggregate function to calculate the total number of rows. This count is performed with a condition specified in the WHERE clause, which filters the rows to only those where the value in the ALBUMID column is exactly equal to the value provided in the input parameter p_album_id. The result of this COUNT(*) operation is then stored into the local variable v_count using the INTO clause. Finally, the function concludes by using a RETURN statement to output the value stored in v_count, which represents the total count of tracks associated with the specified album ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_album_song_count(p_album_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM TRACKLISTS WHERE ALBUMID = p_album_id;\n    RETURN v_count;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "SONGS",
      "TRACKLISTS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_album_song_count(1) FROM DUAL",
      "SELECT get_album_song_count(5) FROM DUAL",
      "SELECT get_album_song_count(AID) FROM ALBUMS WHERE TITLE = 'Let It Be'",
      "SELECT AID, TITLE, get_album_song_count(AID) AS SONG_COUNT FROM ALBUMS WHERE YEAR = 1969",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Album 3 has ' || get_album_song_count(3) || ' songs.');\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_album_song_count that accepts an album ID parameter and returns the count of tracks for that album from the TRACKLISTS table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_album_song_count? It should take an album ID as input and spit back how many tracks are on that album, pulling the info from the TRACKLISTS table.",
    "id": 103
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_song_instrument_count that accepts a single parameter, p_song_id, which is of type NUMBER and represents the unique identifier of a song. The function is designed to return a NUMBER that indicates the count of instruments associated with the specified song. Within the function, a local variable v_instrument_count of type NUMBER is initialized to zero to store the result of the count operation. The function performs a SELECT statement that counts the total number of rows in the INSTRUMENTS table where the SONGID column matches the value of the input parameter p_song_id. The result of this count operation is stored into the local variable v_instrument_count using the INTO clause. Finally, the function returns the value of v_instrument_count, which represents the number of instruments linked to the song identified by p_song_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_song_instrument_count(p_song_id NUMBER) RETURN NUMBER IS\n    v_instrument_count NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_instrument_count FROM INSTRUMENTS WHERE SONGID = p_song_id;\n    RETURN v_instrument_count;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "SONGS",
      "TRACKLISTS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_song_instrument_count(1) FROM DUAL",
      "SELECT get_song_instrument_count(2) FROM DUAL",
      "SELECT get_song_instrument_count(3) FROM DUAL",
      "SELECT get_song_instrument_count(4) FROM DUAL",
      "SELECT get_song_instrument_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_song_instrument_count that accepts a song ID (NUMBER) and returns the total count of instruments associated with that song from the INSTRUMENTS table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_song_instrument_count? It should take a song's ID (as a NUMBER) and spit back how many instruments from the INSTRUMENTS table are linked to that tune.",
    "id": 104
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_album_year that accepts a single parameter, p_album_id, which is of type NUMBER and represents the unique identifier of an album. The function is designed to return a NUMBER that corresponds to the year of the album specified by the given album ID. Within the function, a local variable v_year of type NUMBER is initialized to 0 to store the year of the album. The function performs a SELECT operation on the ALBUMS table, specifically retrieving the YEAR column value for the row where the AID column matches the value of the input parameter p_album_id. The result of this SELECT operation is stored into the local variable v_year using the INTO clause. After successfully retrieving the year, the function returns the value stored in v_year, which represents the year of the album associated with the provided album ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_album_year(p_album_id NUMBER) RETURN NUMBER IS\n    v_year NUMBER := 0;\nBEGIN\n    SELECT YEAR INTO v_year FROM ALBUMS WHERE AID = p_album_id;\n    RETURN v_year;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "SONGS",
      "TRACKLISTS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_album_year(1) FROM DUAL",
      "SELECT get_album_year(2) FROM DUAL",
      "SELECT get_album_year(3) FROM DUAL",
      "SELECT get_album_year(4) FROM DUAL",
      "SELECT get_album_year(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_album_year that accepts an album ID (NUMBER) and returns the year (NUMBER) of that album from the ALBUMS table.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_album_year, which will take a single numeric input parameter representing a specific album ID and will meticulously retrieve and return the corresponding release year, also as a NUMBER data type, by querying the detailed records stored within the ALBUMS table.",
    "id": 105
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_song_title` that accepts a single input parameter, `p_song_id`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` data type. Upon execution, the function first declares a local variable named `v_title` of type `VARCHAR2` with a maximum length of 255 characters and initializes it to an empty string. Subsequently, the function performs a `SELECT` operation to retrieve the value from the `TITLE` column of the `SONGS` table. The retrieved `TITLE` value is then assigned to the `v_title` variable. This `SELECT` operation is constrained by a `WHERE` clause, which specifies that only the row where the `SONGID` column in the `SONGS` table matches the value provided in the `p_song_id` input parameter should be considered. Finally, the function returns the value currently stored in the `v_title` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_song_title(p_song_id NUMBER) RETURN VARCHAR2 IS\n    v_title VARCHAR2(255) := '';\nBEGIN\n    SELECT TITLE INTO v_title FROM SONGS WHERE SONGID = p_song_id;\n    RETURN v_title;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "SONGS",
      "TRACKLISTS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_song_title(1) FROM dual",
      "SELECT get_song_title(2) FROM dual",
      "SELECT get_song_title(3) FROM dual",
      "SELECT get_song_title(4) FROM dual",
      "SELECT get_song_title(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_song_title that accepts a song ID (NUMBER) and returns the title (VARCHAR2) of that song from the SONGS table.",
    "natural_language": "Function get_song_title: input song ID (NUMBER), output its title (VARCHAR2) from SONGS.",
    "id": 106
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_vocal_type_count` that accepts a single input parameter, `p_song_id`, which is of the `NUMBER` data type. The purpose of this `p_song_id` parameter is to identify a specific song for which the vocal type count is to be determined. The function is designed to return a single value of the `NUMBER` data type. Upon execution, the function declares a local variable named `v_type_count` of the `NUMBER` data type and initializes its value to `0`. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `VOCALS` table. Within this query, it calculates the count of distinct values found in the `TYPE` column. The `DISTINCT` keyword ensures that only unique vocal types are considered in the count. This count is performed under a specific condition: only rows where the value in the `SONGID` column of the `VOCALS` table is equal to the value provided by the input parameter `p_song_id` are included in the aggregation. The result of this `COUNT(DISTINCT TYPE)` operation is then assigned to the local variable `v_type_count`. Finally, the function returns the value stored in `v_type_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_vocal_type_count(p_song_id NUMBER) RETURN NUMBER IS\n    v_type_count NUMBER := 0;\nBEGIN\n    SELECT COUNT(DISTINCT TYPE) INTO v_type_count FROM VOCALS WHERE SONGID = p_song_id;\n    RETURN v_type_count;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "SONGS",
      "TRACKLISTS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_vocal_type_count(1) FROM DUAL",
      "SELECT get_vocal_type_count(2) FROM DUAL",
      "SELECT get_vocal_type_count(3) FROM DUAL",
      "SELECT get_vocal_type_count(4) FROM DUAL",
      "SELECT get_vocal_type_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_vocal_type_count that accepts a song ID (NUMBER) and returns the count of distinct vocal types (NUMBER) associated with that song from the VOCALS table.",
    "natural_language": "Write a PL/SQL function called get_vocal_type_count that takes a song ID as a NUMBER and returns a NUMBER representing the count of unique vocal types for that song from the VOCALS table.",
    "id": 107
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_weeks that accepts a single parameter, p_artist_id, which is of type NUMBER and represents the unique identifier of an artist. The function initializes a local variable v_weeks of type NUMBER to zero, which will store the total number of weeks an artist has been on top. Another local variable, v_bonus, also of type NUMBER, is initialized to the value 5, representing a bonus number of weeks to be added to the artist's total weeks. The function performs a SELECT operation on the VOLUME table, specifically targeting the WEEKS_ON_TOP column, and uses the NVL function to ensure that if the SUM of WEEKS_ON_TOP is NULL, it defaults to zero. This sum is calculated for rows where the ARTIST_ID column matches the value of the input parameter p_artist_id. The result of this SELECT operation is stored in the v_weeks variable. Finally, the function returns the sum of v_weeks and v_bonus, effectively providing the total number of weeks the artist has been on top, including the bonus weeks.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_weeks(p_artist_id NUMBER) RETURN NUMBER IS\n    v_weeks NUMBER := 0;\n    v_bonus NUMBER := 5;\nBEGIN\n    SELECT NVL(SUM(WEEKS_ON_TOP), 0) INTO v_weeks FROM VOLUME WHERE ARTIST_ID = p_artist_id;\n    RETURN v_weeks + v_bonus;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_artist_weeks(1) FROM DUAL",
      "SELECT get_artist_weeks(2) FROM DUAL",
      "SELECT get_artist_weeks(4) FROM DUAL",
      "SELECT get_artist_weeks(100) FROM DUAL",
      "SELECT get_artist_weeks(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_artist_weeks that accepts an artist ID (NUMBER). It calculates the total weeks on top from the VOLUME table for that artist, adds a bonus of 5 weeks, and returns the final total (NUMBER).",
    "natural_language": "Calculate the total weeks on top for a specified artist ID from the VOLUME table, add a 5-week bonus, and return the final total. Implement this as a PL/SQL function named get_artist_weeks that takes an artist ID (NUMBER) as input and returns a NUMBER.",
    "id": 108
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_next_ceremony_date that accepts a single parameter p_festival_id of type NUMBER, which is intended to represent the unique identifier of a festival. The function is designed to calculate and return a DATE value. It begins by initializing a local variable v_result_date with the current system date obtained using the SYSDATE function. Another local variable, v_next_monday, is declared and initialized to store the date of the next Monday following the current system date, which is determined using the NEXT_DAY function with 'MONDAY' as the specified day of the week. The function then updates the v_result_date variable by adding 30 days to the value stored in v_next_monday, effectively setting v_result_date to a date that is 30 days after the next Monday. Finally, the function returns the value of v_result_date, which represents the calculated date for the next ceremony. The function does not perform any database operations such as updates, inserts, deletes, or selects, nor does it involve any conditional logic or interaction with database tables.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_next_ceremony_date(p_festival_id NUMBER) RETURN DATE IS\n    v_result_date DATE := SYSDATE;\n    v_next_monday DATE := NEXT_DAY(SYSDATE, 'MONDAY');\nBEGIN\n    v_result_date := v_next_monday + 30;\n    RETURN v_result_date;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT calculate_next_ceremony_date(1) FROM DUAL",
      "SELECT calculate_next_ceremony_date(2) FROM DUAL",
      "SELECT calculate_next_ceremony_date(3) FROM DUAL",
      "SELECT calculate_next_ceremony_date(10) FROM DUAL",
      "SELECT calculate_next_ceremony_date(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_next_ceremony_date that accepts a festival ID (NUMBER) and returns a DATE. The function should calculate the date as 30 days after the next Monday from the current system date.",
    "natural_language": "Write a PL/SQL function called calculate_next_ceremony_date that takes a festival ID and gives back a date. It should figure out the date by adding a fair number of days, like around a month or so, after the upcoming Monday from today's date.",
    "id": 109
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_festival_volume_total that accepts a single input parameter p_category of type VARCHAR2 and returns a value of type NUMBER. The function declares two local NUMBER variables: v_total, initialized to 0, and v_multiplier, initialized to 2. The function executes a SELECT statement that queries the MUSIC_FESTIVAL table, applying a filter condition where the CATEGORY column equals the input parameter p_category. Within this query, the SQL aggregate function SUM is applied to the VOLUME column for all rows matching the condition, and the NVL function is used to convert a potential NULL result from the SUM operation to the numeric value 0. The result of this SELECT statement is stored into the local variable v_total. The function's return value is computed by multiplying the retrieved v_total by the constant multiplier v_multiplier.",
    "plsql": "CREATE OR REPLACE FUNCTION get_festival_volume_total(p_category VARCHAR2) RETURN NUMBER IS\n    v_total NUMBER := 0;\n    v_multiplier NUMBER := 2;\nBEGIN\n    SELECT NVL(SUM(VOLUME), 0) INTO v_total FROM MUSIC_FESTIVAL WHERE CATEGORY = p_category;\n    RETURN v_total * v_multiplier;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_festival_volume_total('Best Song') FROM DUAL",
      "SELECT get_festival_volume_total('Best Lyrics') FROM DUAL",
      "SELECT get_festival_volume_total('Best Album') FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total: ' || get_festival_volume_total('Best Song'));\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_festival_volume_total('Best Lyrics');\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_festival_volume_total that accepts a category (VARCHAR2) and returns a NUMBER. The function should query the MUSIC_FESTIVAL table, sum the VOLUME for the given category (defaulting to 0 if NULL), and return the total multiplied by 2.",
    "natural_language": "Construct a PL/SQL function called get_festival_volume_total, which is designed to receive a single input parameter of type VARCHAR2 representing a music category and will output a value of type NUMBER. This function should perform a detailed query against the MUSIC_FESTIVAL table, meticulously calculating the sum of all VOLUME entries that precisely match the specified category. To ensure robustness, if the summed total is found to be NULL, it must gracefully default to zero. Finally, the function must return this carefully derived total amount after it has been distinctly multiplied by two.",
    "id": 110
  },
  {
    "ir": "Write an Oracle PL/SQL function named compute_artist_age_factor that accepts a single input parameter, p_artist_id, of type NUMBER, which represents the unique identifier of an artist. The function is designed to calculate and return a numerical value. It begins by declaring two local variables: v_age, initialized to 0, and v_factor, initialized to 10. The function then performs a SELECT statement to retrieve the AGE column from the ARTIST table for the row where the ARTIST_ID column matches the provided p_artist_id. The NVL function is used in the SELECT statement to ensure that if the AGE column contains a NULL value, it is replaced with 0 before being assigned to the v_age variable. After retrieving the age, the function calculates the result by adding the value of v_age to v_factor. Finally, the function returns this computed sum as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION compute_artist_age_factor(p_artist_id NUMBER) RETURN NUMBER IS\n    v_age NUMBER := 0;\n    v_factor NUMBER := 10;\nBEGIN\n    SELECT NVL(AGE, 0) INTO v_age FROM ARTIST WHERE ARTIST_ID = p_artist_id;\n    RETURN v_age + v_factor;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT compute_artist_age_factor(1) FROM dual",
      "SELECT compute_artist_age_factor(2) FROM dual",
      "SELECT compute_artist_age_factor(4) FROM dual"
    ],
    "summary": "Create a PL/SQL function named compute_artist_age_factor that accepts an artist ID (NUMBER) and returns a NUMBER. The function should retrieve the artist's AGE from the ARTIST table (defaulting to 0 if NULL) and return the age plus 10.",
    "natural_language": "Hey, can you whip up a PL/SQL function called compute_artist_age_factor? It should take an artist's ID (as a NUMBER) and spit back a NUMBER. Here's the deal: grab the artist's AGE from the ARTIST table (if it's NULL, just treat it as 0), and then return that age plus 10.",
    "id": 111
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_next_volume_date that accepts a single input parameter p_volume_id of the NUMBER data type and returns a value of the DATE data type. The function's purpose is to calculate a specific future date. The logic begins by declaring a local DATE variable v_base_date and initializing it to the current system date and time using the SYSDATE function. It then declares a second local DATE variable v_target_date and initializes it using the NEXT_DAY function, which takes the current SYSDATE and the literal string 'FRIDAY' as arguments, thereby computing the date of the first Friday occurring on or after the current date. The core calculation modifies the v_target_date variable by adding 14 days to its value using the arithmetic expression v_target_date + 14. The function concludes by returning the resulting v_target_date value as its output. The input parameter p_volume_id is declared but is not referenced or used within any of the function's operational logic.",
    "plsql": "CREATE OR REPLACE FUNCTION get_next_volume_date(p_volume_id NUMBER) RETURN DATE IS\n    v_base_date DATE := SYSDATE;\n    v_target_date DATE := NEXT_DAY(SYSDATE, 'FRIDAY');\nBEGIN\n    v_target_date := v_target_date + 14;\n    RETURN v_target_date;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_next_volume_date(1) FROM DUAL",
      "SELECT get_next_volume_date(2) FROM DUAL",
      "SELECT get_next_volume_date(3) FROM DUAL",
      "SELECT get_next_volume_date(4) FROM DUAL",
      "SELECT get_next_volume_date(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_next_volume_date that accepts a volume ID (NUMBER) and returns a DATE. The function should calculate the date as 14 days after the next Friday from the current system date. The input parameter is not used in the calculation.",
    "natural_language": "Write a PL/SQL function called get_next_volume_date that takes a volume ID (NUMBER) and gives back a DATE. Make the function compute the date to be 14 days after the upcoming Friday from today's date. Do not use the input parameter in the calculation.",
    "id": 112
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_highschooler_grade that accepts a single input parameter p_student_id of type NUMBER, which represents the unique identifier for a student, and returns a value of type NUMBER. The function begins by declaring a local variable v_grade of type NUMBER. It then executes a SELECT statement to query the HIGHSCHOOLER table, specifically retrieving the value from the GRADE column for the row where the ID column exactly matches the provided p_student_id parameter value, and stores this retrieved value into the v_grade variable. Following the data retrieval, the function uses an IF-THEN-ELSE conditional statement to evaluate the content of v_grade. If the v_grade variable is found to be NULL, the function returns the numeric value -1. Conversely, if v_grade contains a non-NULL value, the function returns that specific v_grade value directly.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highschooler_grade(p_student_id NUMBER) RETURN NUMBER IS\n    v_grade NUMBER;\nBEGIN\n    SELECT GRADE INTO v_grade FROM HIGHSCHOOLER WHERE ID = p_student_id;\n    IF v_grade IS NULL THEN\n        RETURN -1;\n    ELSE\n        RETURN v_grade;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_highschooler_grade(1510) FROM dual",
      "SELECT get_highschooler_grade(1689) FROM dual",
      "SELECT get_highschooler_grade(1381) FROM dual",
      "SELECT get_highschooler_grade(1101) FROM dual",
      "SELECT get_highschooler_grade(1247) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_highschooler_grade that accepts a student ID (NUMBER) and returns a NUMBER. The function should retrieve the student's GRADE from the HIGHSCHOOLER table. If the grade is NULL, return -1; otherwise, return the grade.",
    "natural_language": "Develop a PL/SQL function, which should be named get_highschooler_grade, that is designed to take a single input parameter—specifically a student ID represented as a NUMBER—and subsequently returns a NUMBER as its output. This function's primary purpose is to carefully query the HIGHSCHOOLER table in order to fetch the precise GRADE value associated with the provided student identifier. Importantly, if the retrieved grade value is found to be NULL, the function must explicitly return a value of -1; otherwise, it should dutifully return the actual, non-null grade figure that was successfully obtained from the database.",
    "id": 113
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_likes that accepts a single input parameter p_student_id of type NUMBER, which represents the identifier of a student, and returns a value of type NUMBER. The function begins by declaring a local variable v_count of type NUMBER. It executes a SELECT statement that queries the LIKES table, using the COUNT(*) aggregate function to calculate the total number of rows where the STUDENT_ID column value is equal to the provided input parameter p_student_id, and stores this result into the local variable v_count. The function then uses an IF-THEN-ELSE conditional statement to evaluate the value of v_count. If v_count is greater than 0, the function returns the value of v_count directly. If the condition is not met, meaning v_count is 0 or null, the function instead returns the literal value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION count_likes(p_student_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM LIKES WHERE STUDENT_ID = p_student_id;\n    IF v_count > 0 THEN\n        RETURN v_count;\n    ELSE\n        RETURN 0;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT count_likes(1025) FROM DUAL",
      "SELECT count_likes(1247) FROM DUAL",
      "SELECT count_likes(1316) FROM DUAL",
      "SELECT count_likes(1101) FROM DUAL",
      "SELECT count_likes(9999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named count_likes that accepts a student ID (NUMBER) and returns a NUMBER. It counts the rows in the LIKES table for that student ID. Return the count if greater than 0, otherwise return 0.",
    "natural_language": "Develop a PL/SQL function called count_likes, which is designed to take a single numeric input parameter representing a specific student's ID. This function should meticulously calculate and return the total number of entries found within the LIKES table that are associated with the provided student identifier. If the resulting count exceeds zero, the function must output that precise numerical value; however, if no matching records are discovered, it should gracefully return a value of zero.",
    "id": 114
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_friendship that accepts two parameters: p_student_id and p_friend_id, both of which are of the NUMBER data type. The purpose of this function is to determine whether a friendship exists between two students in the FRIEND table. The function begins by declaring a local variable v_exists of type NUMBER, which will be used to store the result of a query. The function then executes a SELECT statement that counts the number of rows in the FRIEND table where the STUDENT_ID column matches the value of p_student_id and the FRIEND_ID column matches the value of p_friend_id. The result of this count is stored in the v_exists variable. Following the SELECT statement, the function evaluates a conditional statement: if the value of v_exists is greater than 0, indicating that at least one matching row was found, the function returns the string 'YES'. If no matching rows are found, indicated by v_exists being 0, the function returns the string 'NO'. This logic effectively checks for the existence of a friendship relationship between the two specified student IDs in the FRIEND table.",
    "plsql": "CREATE OR REPLACE FUNCTION check_friendship(p_student_id NUMBER, p_friend_id NUMBER) RETURN VARCHAR2 IS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM FRIEND WHERE STUDENT_ID = p_student_id AND FRIEND_ID = p_friend_id;\n    IF v_exists > 0 THEN\n        RETURN 'YES';\n    ELSE\n        RETURN 'NO';\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT check_friendship(1101, 1641) FROM DUAL",
      "SELECT check_friendship(1247, 1501) FROM DUAL",
      "SELECT check_friendship(1101, 1911) FROM DUAL",
      "SELECT check_friendship(1000, 2000) FROM DUAL",
      "SELECT check_friendship(1247, 1641) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_friendship that accepts two student IDs (NUMBER) and returns a VARCHAR2. It checks the FRIEND table for a matching friendship row. Return 'YES' if found, otherwise return 'NO'.",
    "natural_language": "Make a function check_friendship that takes two student IDs and returns 'YES' if they are friends in the FRIEND table, else 'NO'.",
    "id": 115
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_mutual_friend_count that accepts two input parameters, p_student_id of type NUMBER and p_friend_id of type NUMBER, and returns a NUMBER value. The function declares a local variable v_count of type NUMBER. The function's logic begins by executing a SELECT statement that uses the COUNT(*) aggregate function to calculate a total and stores the result into the v_count variable. This SELECT statement queries from the FRIEND table, which is aliased as f1, and performs an inner JOIN with another instance of the FRIEND table, aliased as f2, on the condition that the FRIEND_ID column value from the f1 table alias is equal to the FRIEND_ID column value from the f2 table alias. The WHERE clause of this query specifies two conditions that must both be true: the STUDENT_ID column from the f1 table alias must equal the input parameter p_student_id, and the STUDENT_ID column from the f2 table alias must equal the input parameter p_friend_id. After the SELECT statement executes, the function uses an IF-THEN-ELSE conditional statement to evaluate the v_count variable. If the v_count variable is found to be NULL, the function returns the value 0. Otherwise, if v_count is not NULL, the function returns the value stored in the v_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mutual_friend_count(p_student_id NUMBER, p_friend_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM FRIEND f1\n    JOIN FRIEND f2 ON f1.FRIEND_ID = f2.FRIEND_ID\n    WHERE f1.STUDENT_ID = p_student_id AND f2.STUDENT_ID = p_friend_id;\n    IF v_count IS NULL THEN\n        RETURN 0;\n    ELSE\n        RETURN v_count;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_mutual_friend_count(1101, 1247) FROM DUAL",
      "SELECT get_mutual_friend_count(1381, 1689) FROM DUAL",
      "SELECT get_mutual_friend_count(1510, 1911) FROM DUAL",
      "SELECT get_mutual_friend_count(1025, 1316) FROM DUAL",
      "SELECT get_mutual_friend_count(1468, 1304) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_mutual_friend_count that accepts two student IDs (NUMBER) and returns a NUMBER. It counts mutual friends by joining the FRIEND table on FRIEND_ID where each ID is a STUDENT_ID. Return the count, or 0 if NULL.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_mutual_friend_count, which will gracefully accept two distinct student identifiers, both of the NUMBER data type, and will subsequently yield a NUMBER as its result. This function is tasked with meticulously calculating the precise count of mutual friends shared between the two specified students. It achieves this by intelligently querying the FRIEND table, performing a join operation on the FRIEND_ID column where each provided identifier corresponds to a valid STUDENT_ID entry. The function must thoughtfully return the final tally of these mutual connections; however, in the event that the result is determined to be NULL, it should considerately and automatically return a value of zero instead.",
    "id": 116
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_highschooler_name that accepts a single input parameter p_student_id of the NUMBER data type and returns a value of the VARCHAR2 data type, where the function's logic begins by declaring a local variable v_name of type VARCHAR2 with a maximum length of 255 characters, then executes a SELECT statement to query the NAME column from the HIGHSCHOOLER table for the specific row where the ID column exactly equals the provided p_student_id parameter value, storing the retrieved result into the v_name variable, after which a conditional IF statement evaluates whether the v_name variable contains a NULL value, and if this condition is true, the function returns the literal string 'Unknown', but if the condition is false, meaning v_name is not NULL, the function instead returns the value stored in the v_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highschooler_name(p_student_id NUMBER) RETURN VARCHAR2 IS\n    v_name VARCHAR2(255);\nBEGIN\n    SELECT NAME INTO v_name FROM HIGHSCHOOLER WHERE ID = p_student_id;\n    IF v_name IS NULL THEN\n        RETURN 'Unknown';\n    ELSE\n        RETURN v_name;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_highschooler_name(1510) FROM dual",
      "SELECT get_highschooler_name(1689) FROM dual",
      "SELECT get_highschooler_name(1381) FROM dual",
      "SELECT get_highschooler_name(1101) FROM dual",
      "SELECT get_highschooler_name(1247) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_highschooler_name that accepts a student ID (NUMBER) and returns a VARCHAR2. It retrieves the name from the HIGHSCHOOLER table for that ID. Return the name, or 'Unknown' if NULL.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_highschooler_name? It should take a student ID (that's a NUMBER) and spit back a VARCHAR2. Basically, it grabs the name from the HIGHSCHOOLER table for that ID. If it finds a name, return it; if it's NULL, just give back 'Unknown'.",
    "id": 117
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_protein_divergence` that is designed to return a single numerical value. This function does not accept any input parameters. Internally, it declares a local variable named `v_max_divergence` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement queries the `PROTEIN` table. Specifically, it calculates the maximum value present in the `DIVERGENCE_FROM_HUMAN_LINEAGE` column within the `PROTEIN` table. The result of this aggregation (the single maximum value) is then immediately stored into the `v_max_divergence` local variable. Finally, the function returns the value currently held by the `v_max_divergence` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_protein_divergence RETURN NUMBER IS\n  v_max_divergence NUMBER;\nBEGIN\n  SELECT MAX(DIVERGENCE_FROM_HUMAN_LINEAGE) INTO v_max_divergence FROM PROTEIN;\n  RETURN v_max_divergence;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_max_protein_divergence FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_max_protein_divergence with no parameters that returns a NUMBER. It retrieves the maximum value from the DIVERGENCE_FROM_HUMAN_LINEAGE column in the PROTEIN table and returns it.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_max_protein_divergence? It doesn't need any inputs and should spit back a NUMBER. Basically, it's gotta grab the biggest number from the DIVERGENCE_FROM_HUMAN_LINEAGE column in the PROTEIN table and hand that back.",
    "id": 118
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_enrollment_public that takes no parameters and returns a single NUMBER data type, which begins by declaring a local variable v_total_enrollment of type NUMBER, then executes a SELECT statement that queries the INSTITUTION table, specifically using the SUM aggregate function on the ENROLLMENT column, and applies a WHERE clause condition to include only those rows where the TYPE column has the exact string value 'Public', storing the result of this summation into the local variable v_total_enrollment, and finally uses a RETURN statement to output the value held in v_total_enrollment.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_enrollment_public RETURN NUMBER IS\n  v_total_enrollment NUMBER;\nBEGIN\n  SELECT SUM(ENROLLMENT) INTO v_total_enrollment FROM INSTITUTION WHERE TYPE = 'Public';\n  RETURN v_total_enrollment;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_total_enrollment_public FROM DUAL",
      "SELECT get_total_enrollment_public() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_total_enrollment_public;\n  DBMS_OUTPUT.PUT_LINE('Total Public Enrollment: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total: ' || get_total_enrollment_public);\nEND;",
      "SELECT institution, enrollment FROM institution WHERE type = 'Public'\nUNION ALL\nSELECT 'TOTAL', get_total_enrollment_public FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_enrollment_public that returns the total enrollment from the INSTITUTION table where TYPE is 'Public'.",
    "natural_language": "Please construct a PL/SQL function, designated as get_total_enrollment_public, which shall compute and return the aggregate enrollment figure. This calculation must be derived from the INSTITUTION table, specifically for those records where the TYPE column holds the value 'Public'.",
    "id": 119
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_avg_sequence_length` that is designed to return a single numerical value. This function declares a local variable named `v_avg_length` of data type `NUMBER` to temporarily store the calculated average. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement calculates the average of the values found in the `SEQUENCE_LENGTH` column. The `SEQUENCE_LENGTH` column is retrieved from the `PROTEIN` table. The result of this average calculation is then immediately stored into the `v_avg_length` local variable. Finally, the function concludes by returning the numerical value currently held by the `v_avg_length` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_avg_sequence_length RETURN NUMBER IS\n  v_avg_length NUMBER;\nBEGIN\n  SELECT AVG(SEQUENCE_LENGTH) INTO v_avg_length FROM PROTEIN;\n  RETURN v_avg_length;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_avg_sequence_length FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_avg_sequence_length that returns the average SEQUENCE_LENGTH from the PROTEIN table.",
    "natural_language": "Develop a PL/SQL function, which should be named get_avg_sequence_length, that is designed to calculate and return the detailed average value of the SEQUENCE_LENGTH column meticulously extracted from all records within the PROTEIN table.",
    "id": 120
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_oldest_institution_founded that takes no input parameters and returns a single numeric value, which is the earliest founding year found in the institution table; the function declares a local numeric variable v_oldest_founded, executes a SELECT statement that retrieves the minimum value from the FOUNDED column of the INSTITUTION table using the MIN aggregate function, stores that result into the local variable, and then returns the value of that variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_institution_founded RETURN NUMBER IS\n  v_oldest_founded NUMBER;\nBEGIN\n  SELECT MIN(FOUNDED) INTO v_oldest_founded FROM INSTITUTION;\n  RETURN v_oldest_founded;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_oldest_institution_founded FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_oldest_institution_founded that returns the earliest founding year (minimum FOUNDED) from the INSTITUTION table.",
    "natural_language": "What is the earliest founding year recorded in the INSTITUTION table?",
    "id": 121
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_building_count_over_150` that is designed to return a single numeric value. This function does not accept any input parameters. The function's primary purpose is to calculate and return the total number of buildings that exceed a specific height threshold. Internally, the function declares a local variable named `v_building_count` of type `NUMBER` to temporarily store the result of its computation. The core operation involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows that satisfy a given condition. The data is retrieved from the `BUILDING` table. The condition applied to filter the rows is `HEIGHT_FEET > 150`, meaning only rows where the value in the `HEIGHT_FEET` column is strictly greater than 150 are included in the count. The result of this `COUNT(*)` operation is then immediately assigned to the `v_building_count` variable using the `INTO` clause. Finally, the function returns the value stored in `v_building_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_building_count_over_150 RETURN NUMBER IS\n  v_building_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_building_count FROM BUILDING WHERE HEIGHT_FEET > 150;\n  RETURN v_building_count;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_building_count_over_150 FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_building_count_over_150 that returns the count of buildings from the BUILDING table where HEIGHT_FEET is greater than 150.",
    "natural_language": "Develop a PL/SQL function, which should be named get_building_count_over_150, that is designed to calculate and return the total number of buildings, specifically those tall structures recorded in the BUILDING table, whose HEIGHT_FEET measurement definitively exceeds the considerable threshold of 150 feet.",
    "id": 122
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_university_name` that is designed to retrieve the name of a university based on its unique identifier. This function accepts two input parameters: `p_university_id`, which is of data type `NUMBER` and represents the primary key or unique identifier for a university record, and `p_dummy`, which is also of data type `NUMBER` but is not utilized within the function's logic. The function is declared to return a value of data type `VARCHAR2`. Internally, the function declares a local variable `v_name` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved university name. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `UNIVERSITY` table to fetch the value from the `UNIVERSITY_NAME` column. The retrieval is conditioned by a `WHERE` clause, which specifies that the `UNIVERSITY_ID` column in the `UNIVERSITY` table must exactly match the value provided in the `p_university_id` input parameter. The result of this `SELECT` statement, specifically the `UNIVERSITY_NAME`, is then assigned to the `v_name` local variable. Finally, the function returns the value stored in the `v_name` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_university_name(p_university_id NUMBER, p_dummy NUMBER) RETURN VARCHAR2 IS\n  v_name VARCHAR2(255);\nBEGIN\n  SELECT UNIVERSITY_NAME INTO v_name FROM UNIVERSITY WHERE UNIVERSITY_ID = p_university_id;\n  RETURN v_name;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT get_university_name(1, 0) FROM DUAL",
      "SELECT get_university_name(2, 0) FROM DUAL",
      "SELECT get_university_name(3, 0) FROM DUAL",
      "SELECT get_university_name(1, 1) FROM DUAL",
      "SELECT get_university_name(2, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_university_name that accepts a university ID (p_university_id) and returns the corresponding UNIVERSITY_NAME from the UNIVERSITY table.",
    "natural_language": "What is the name of the university associated with a given university ID?",
    "id": 123
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_total_points that accepts two input parameters: a numeric parameter p_university_id to identify a specific university and a numeric parameter p_multiplier to serve as a scaling factor, and returns a single numeric value; the function declares a local numeric variable v_total to hold the computed result, then executes a SELECT statement that queries the OVERALL_RANKING table for the row where the UNIVERSITY_ID column matches the provided p_university_id parameter, and for that row, calculates a sum by adding the values from the REPUTATION_POINT, RESEARCH_POINT, and CITATION_POINT columns together, multiplies that sum by the p_multiplier parameter, and stores the final product into the v_total variable, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_points(p_university_id NUMBER, p_multiplier NUMBER) RETURN NUMBER IS\n  v_total NUMBER;\nBEGIN\n  SELECT (REPUTATION_POINT + RESEARCH_POINT + CITATION_POINT) * p_multiplier INTO v_total FROM OVERALL_RANKING WHERE UNIVERSITY_ID = p_university_id;\n  RETURN v_total;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT calculate_total_points(1, 1.5) FROM DUAL",
      "SELECT calculate_total_points(2, 2.0) FROM DUAL",
      "SELECT calculate_total_points(3, 1.2) FROM DUAL",
      "SELECT calculate_total_points(1, 1.8) FROM DUAL",
      "SELECT calculate_total_points(2, 2.5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_total_points that accepts a university ID and a multiplier, and returns the sum of reputation, research, and citation points for that university, multiplied by the multiplier.",
    "natural_language": "Please construct a PL/SQL function designated as 'calculate_total_points'. This function shall accept two parameters: a university identifier and a numerical multiplier. Its purpose is to compute and return a value derived from the summation of the specified university's reputation, research, and citation points, subsequently multiplied by the provided multiplier.",
    "id": 124
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_major_code that accepts two input parameters: a numeric parameter p_major_id and a numeric parameter p_offset, and returns a single numeric value. The function declares a local numeric variable v_code. The function's logic executes a single SQL SELECT statement that queries the MAJOR table. The SELECT statement retrieves the value from the MAJOR_CODE column for the specific row where the MAJOR_ID column exactly equals the value of the input parameter p_major_id. The retrieved MAJOR_CODE value is then added to the value of the input parameter p_offset using the arithmetic plus operator. The result of this addition operation is stored into the local variable v_code. The function concludes by returning the value stored in v_code as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_major_code(p_major_id NUMBER, p_offset NUMBER) RETURN NUMBER IS\n  v_code NUMBER;\nBEGIN\n  SELECT MAJOR_CODE + p_offset INTO v_code FROM MAJOR WHERE MAJOR_ID = p_major_id;\n  RETURN v_code;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT get_major_code(1, 10) FROM DUAL",
      "SELECT get_major_code(2, 5) FROM DUAL",
      "SELECT get_major_code(3, 0) FROM DUAL",
      "SELECT get_major_code(1, -5) FROM DUAL",
      "SELECT get_major_code(2, 20) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_major_code that accepts a major ID and an offset, and returns the major code for that ID plus the offset.",
    "natural_language": "Please construct a PL/SQL function designated as `get_major_code`. This function shall accept two parameters: a major identifier and an offset value. Its purpose is to compute and return the major code corresponding to the provided identifier, incremented by the specified offset.",
    "id": 125
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_enrollment_category that accepts two input parameters: a numeric parameter p_university_id and a numeric parameter p_threshold, and returns a VARCHAR2 string. The function executes a SELECT statement that queries the UNIVERSITY table, specifically retrieving the ENROLLMENT column for the row where the UNIVERSITY_ID column exactly matches the provided p_university_id parameter. For that retrieved row, it uses a CASE expression to evaluate the ENROLLMENT value: if the ENROLLMENT value is strictly greater than the input p_threshold parameter, the expression yields the string 'LARGE'; otherwise, it yields the string 'SMALL'. This resulting string is assigned to the local variable result via an INTO clause. The function then returns the value stored in the result variable. If the SELECT statement finds no rows matching the p_university_id condition, a NO_DATA_FOUND exception is raised and handled by returning a NULL value. If the SELECT statement unexpectedly finds more than one row matching the p_university_id condition, a TOO_MANY_ROWS exception is raised and handled by also returning a NULL value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_enrollment_category(p_university_id NUMBER, p_threshold NUMBER) RETURN VARCHAR2 IS\n  result VARCHAR2(10);\nBEGIN\n  SELECT CASE WHEN ENROLLMENT > p_threshold THEN 'LARGE' ELSE 'SMALL' END \n  INTO result \n  FROM UNIVERSITY \n  WHERE UNIVERSITY_ID = p_university_id;\n  \n  RETURN result;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    RETURN NULL;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT get_enrollment_category(1, 2000) FROM dual",
      "SELECT get_enrollment_category(2, 3000) FROM dual",
      "SELECT get_enrollment_category(3, 1500) FROM dual",
      "SELECT get_enrollment_category(1, 2500) FROM dual",
      "SELECT get_enrollment_category(2, 4000) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_enrollment_category that accepts a university ID and a threshold. It returns 'LARGE' if the university's enrollment exceeds the threshold, otherwise 'SMALL'. Handle no data found and too many rows exceptions by returning NULL.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_enrollment_category? It should take a uni ID and a cutoff number. If the uni's student count is bigger than that cutoff, spit out 'LARGE'. If not, just say 'SMALL'. Oh, and if it can't find the uni or finds too many, just have it return NULL to keep things simple.",
    "id": 126
  },
  {
    "ir": "Write an Oracle PL/SQL function named `format_university_info` that accepts two input parameters: `p_university_id` of data type `NUMBER`, intended to represent the unique identifier of a university, and `p_format_type` of data type `NUMBER`, which is currently unused within the function's logic. This function is designed to return a `VARCHAR2` string. Upon execution, the function declares a local variable `v_result` of data type `VARCHAR2` with a maximum length of 500 characters. The core operation involves a `SELECT` statement that retrieves data from the `UNIVERSITY` table. Specifically, it concatenates the value from the `UNIVERSITY_NAME` column, a literal string ' - ', and the value from the `CITY` column. The result of this concatenation is then assigned to the `v_result` variable. This selection is performed under a specific condition: the `UNIVERSITY_ID` column in the `UNIVERSITY` table must exactly match the value provided in the `p_university_id` input parameter. After successfully retrieving and concatenating the university name and city based on the provided ID, the function immediately returns the value stored in the `v_result` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION format_university_info(p_university_id NUMBER, p_format_type NUMBER) RETURN VARCHAR2 IS\n  v_result VARCHAR2(500);\nBEGIN\n  SELECT UNIVERSITY_NAME || ' - ' || CITY INTO v_result FROM UNIVERSITY WHERE UNIVERSITY_ID = p_university_id;\n  RETURN v_result;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT format_university_info(1, 1) FROM DUAL",
      "SELECT format_university_info(2, 1) FROM DUAL",
      "SELECT format_university_info(3, 1) FROM DUAL",
      "SELECT UNIVERSITY_ID, format_university_info(UNIVERSITY_ID, 1) FROM UNIVERSITY WHERE UNIVERSITY_ID = 1",
      "SELECT format_university_info(UNIVERSITY_ID, 1) FROM UNIVERSITY WHERE CITY = 'Aurora'"
    ],
    "summary": "Create a PL/SQL function named format_university_info that accepts a university ID and an unused format type. It returns a concatenated string of the university name and city for the given ID.",
    "natural_language": "Write a PL/SQL function called format_university_info that takes a university ID and an unused format type. It should output a string combining the university's name and city for the specified ID.",
    "id": 127
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_english_country_avg that takes no parameters and returns a single NUMBER value, which executes a SELECT statement to compute the average of the OVERALL_SCORE column from the COUNTRIES table, aliased as c, but only for those country rows where a correlated subquery condition is satisfied, where the subquery checks for the existence of at least one related record by joining the OFFICIAL_LANGUAGES table, aliased as ol, to the LANGUAGES table, aliased as l, on the condition that ol.LANGUAGE_ID equals l.ID, and then filters for rows where the ol.COUNTRY_ID matches the c.ID from the outer query and where the l.NAME column has the exact string value 'English', storing the result of the AVG aggregation into a local variable v_avg_score of type NUMBER, and finally returns the value contained in v_avg_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_english_country_avg RETURN NUMBER IS\n  v_avg_score NUMBER;\nBEGIN\n  SELECT AVG(c.OVERALL_SCORE) INTO v_avg_score\n  FROM COUNTRIES c\n  WHERE EXISTS (SELECT 1 FROM OFFICIAL_LANGUAGES ol JOIN LANGUAGES l ON ol.LANGUAGE_ID = l.ID WHERE ol.COUNTRY_ID = c.ID AND l.NAME = 'English');\n  RETURN v_avg_score;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT calculate_english_country_avg FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_english_country_avg that calculates and returns the average OVERALL_SCORE from the COUNTRIES table for countries that have 'English' listed as an official language.",
    "natural_language": "Calculate and return the average OVERALL_SCORE for countries with 'English' as an official language using a PL/SQL function named calculate_english_country_avg.",
    "id": 128
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_highest_scoring_english_country` that returns a `VARCHAR2` value representing the name of a country. This function does not accept any input parameters. The function's execution begins by declaring a local variable `v_country_name` of type `VARCHAR2` with a maximum length of 255 characters, which will be used to store the retrieved country name. The core operation of the function is a `SELECT` statement that retrieves the `NAME` column from the `COUNTRIES` table, aliased as `c`, and stores this value into the `v_country_name` variable. The selection of the country is based on two conditions: first, it must be a country that has 'English' as an official language, and second, among all such countries, it must be the one with the highest `OVERALL_SCORE`. The condition for having 'English' as an official language is checked using an `EXISTS` subquery. This subquery selects the literal value `1` if there is at least one record in the `OFFICIAL_LANGUAGES` table, aliased as `ol`, that satisfies specific criteria. The `OFFICIAL_LANGUAGES` table is joined with the `LANGUAGES` table, aliased as `l`, on the condition that `ol.LANGUAGE_ID` equals `l.ID`. Within this join, the subquery further filters records where `ol.COUNTRY_ID` matches the `ID` of the current country (`c.ID`) from the outer query, and where the `NAME` column in the `LANGUAGES` table (`l.NAME`) is exactly 'English'. After filtering for English-speaking countries, the main `SELECT` statement orders the results in descending order based on the `OVERALL_SCORE` column from the `COUNTRIES` table (`c.OVERALL_SCORE`). Finally, it retrieves only the first row from this ordered set using `FETCH FIRST 1 ROW ONLY`, effectively selecting the country with the highest overall score among those that speak English. After successfully executing the `SELECT` statement and populating `v_country_name`, the function returns the value stored in `v_country_name`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_scoring_english_country RETURN VARCHAR2 IS\n  v_country_name VARCHAR2(255);\nBEGIN\n  SELECT c.NAME INTO v_country_name FROM COUNTRIES c\n  WHERE EXISTS (SELECT 1 FROM OFFICIAL_LANGUAGES ol JOIN LANGUAGES l ON ol.LANGUAGE_ID = l.ID WHERE ol.COUNTRY_ID = c.ID AND l.NAME = 'English')\n  ORDER BY c.OVERALL_SCORE DESC FETCH FIRST 1 ROW ONLY;\n  RETURN v_country_name;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_highest_scoring_english_country() FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_highest_scoring_english_country that returns the name of the country with the highest OVERALL_SCORE among countries that have 'English' as an official language.",
    "natural_language": "Return the top-scoring English-speaking country.",
    "id": 129
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_countries_by_language that returns a numeric value representing the count of distinct countries. This function does not take any input parameters. It begins by declaring a local variable v_count of type NUMBER, which will store the result of the count operation. The function executes a SELECT statement that performs a COUNT operation on distinct country IDs from the COUNTRIES table, aliased as c. The COUNTRIES table is joined with the OFFICIAL_LANGUAGES table, aliased as ol, using the COUNTRY_ID column from OFFICIAL_LANGUAGES and the ID column from COUNTRIES to establish the relationship between countries and their official languages. Additionally, the OFFICIAL_LANGUAGES table is joined with the LANGUAGES table, aliased as l, using the LANGUAGE_ID column from OFFICIAL_LANGUAGES and the ID column from LANGUAGES to link official languages to their respective language details. The WHERE clause of the SELECT statement filters the results to include only those languages whose NAME column matches one of the specified values: 'English', 'Swedish', or 'Icelandic'. The COUNT function calculates the number of distinct country IDs that meet these criteria, and the result is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the number of distinct countries that have English, Swedish, or Icelandic as an official language.",
    "plsql": "CREATE OR REPLACE FUNCTION count_countries_by_language RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(DISTINCT c.ID) INTO v_count FROM COUNTRIES c\n  JOIN OFFICIAL_LANGUAGES ol ON c.ID = ol.COUNTRY_ID\n  JOIN LANGUAGES l ON ol.LANGUAGE_ID = l.ID\n  WHERE l.NAME IN ('English', 'Swedish', 'Icelandic');\n  RETURN v_count;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT count_countries_by_language FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named count_countries_by_language that returns a NUMBER. It counts distinct countries from the COUNTRIES table that have an official language (via OFFICIAL_LANGUAGES and LANGUAGES tables) with a NAME of 'English', 'Swedish', or 'Icelandic'.",
    "natural_language": "Count distinct countries where the official language is English, Swedish, or Icelandic.",
    "id": 130
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_order_summary` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER` and represents the unique identifier for a customer. This function is designed to return a `VARCHAR2` string indicating a summary category for the customer's order activity.\n\nInside the function, three local variables are declared: `v_order_count` of type `NUMBER` to store the distinct count of orders, `v_total_quantity` of type `NUMBER` to store the sum of product quantities across all order items, and `v_avg_unit_price` of type `NUMBER` to store the average unit price of products in the customer's orders.\n\nThe core logic begins with a `SELECT` statement that queries data from three tables: `orders` (aliased as `o`), `order_items` (aliased as `oi`), and `products` (aliased as `p`). This query performs a `LEFT JOIN` between `orders` and `order_items` on the condition `o.order_id = oi.order_id`, linking orders to their respective items. Subsequently, it performs another `LEFT JOIN` between `order_items` and `products` on the condition `oi.product_id = p.product_id`, connecting order items to the details of the products they contain.\n\nThe `WHERE` clause filters the results to include only orders associated with the `p_customer_id` provided as input to the function, specifically `o.customer_id = p_customer_id`.\n\nThe `SELECT` list calculates three aggregate values:\n1. `COUNT(DISTINCT o.order_id)`: This counts the number of unique orders placed by the specified customer.\n2. `NVL(SUM(TO_NUMBER(oi.product_quantity)), 0)`: This calculates the sum of `product_quantity` from the `order_items` table. The `TO_NUMBER` function is used to explicitly convert `oi.product_quantity` to a numeric type before summation, ensuring correct arithmetic if the column is not already numeric. The `NVL` function ensures that if `SUM` returns `NULL` (e.g., if there are no order items for the customer), the result for `v_total_quantity` will be `0` instead of `NULL`.\n3. `NVL(AVG(p.unit_price), 0)`: This calculates the average `unit_price` from the `products` table for all products included in the customer's orders. The `NVL` function ensures that if `AVG` returns `NULL` (e.g., if there are no products associated with the order items), the result for `v_avg_unit_price` will be `0` instead of `NULL`.\n\nThese three calculated values are then assigned to the respective local variables: `v_order_count`, `v_total_quantity`, and `v_avg_unit_price`.\n\nFollowing the data retrieval, a series of `IF-ELSIF-ELSE` conditional statements determine the customer's order summary category:\n1. `IF v_order_count = 0 THEN RETURN 'NO_ORDERS';`: If the `v_order_count` is zero, meaning the customer has placed no orders, the function immediately returns the string 'NO_ORDERS'.\n2. `ELSIF v_total_quantity > 20 THEN RETURN 'HIGH_VOLUME';`: If the customer has placed at least one order (`v_order_count` is not zero) and the `v_total_quantity` of all products ordered exceeds 20, the function returns the string 'HIGH_VOLUME'.\n3. `ELSIF v_avg_unit_price > 500 THEN RETURN 'PREMIUM';`: If the customer has placed at least one order, the total quantity is not greater than 20, and the `v_avg_unit_price` of products ordered exceeds 500, the function returns the string 'PREMIUM'.\n4. `ELSE RETURN 'STANDARD';`: If none of the above conditions are met (i.e., the customer has placed at least one order, the total quantity is 20 or less, and the average unit price is 500 or less), the function returns the string 'STANDARD'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_order_summary(p_customer_id NUMBER) RETURN VARCHAR2 IS\n    v_order_count NUMBER;\n    v_total_quantity NUMBER;\n    v_avg_unit_price NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT o.order_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity)), 0),\n           NVL(AVG(p.unit_price), 0)\n    INTO v_order_count, v_total_quantity, v_avg_unit_price\n    FROM orders o\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    LEFT JOIN products p ON oi.product_id = p.product_id\n    WHERE o.customer_id = p_customer_id;\n    \n    IF v_order_count = 0 THEN\n        RETURN 'NO_ORDERS';\n    ELSIF v_total_quantity > 20 THEN\n        RETURN 'HIGH_VOLUME';\n    ELSIF v_avg_unit_price > 500 THEN\n        RETURN 'PREMIUM';\n    ELSE\n        RETURN 'STANDARD';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_customer_order_summary(1) FROM DUAL",
      "SELECT get_customer_order_summary(5) FROM DUAL",
      "SELECT get_customer_order_summary(7) FROM DUAL",
      "SELECT get_customer_order_summary(12) FROM DUAL",
      "SELECT get_customer_order_summary(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_order_summary that accepts a p_customer_id NUMBER and returns a VARCHAR2. It calculates the customer's distinct order count, total product quantity (converted to NUMBER), and average product unit price. Return 'NO_ORDERS' if order count is 0, 'HIGH_VOLUME' if total quantity > 20, 'PREMIUM' if average price > 500, else 'STANDARD'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_customer_order_summary? It needs to take a customer ID (as a NUMBER) and spit back a VARCHAR2. Basically, it should figure out: how many different orders the customer has, the total number of products they've bought (as a NUMBER), and the average price per item. If they haven't placed any orders, just return 'NO_ORDERS'. If they've bought more than 20 items total, call it 'HIGH_VOLUME'. If their average price is over 500 bucks, that's 'PREMIUM'. Otherwise, just tag it as 'STANDARD'.",
    "id": 131
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_category_sales that accepts a single input parameter p_category of type VARCHAR2 and returns a NUMBER. The function begins by declaring four local NUMBER variables: v_total_sales initialized to 0, v_item_count initialized to 0, v_avg_price initialized to 0, and v_vat_rate initialized to 0. It then executes a SELECT statement that queries the order_items, products, and product_categories tables. The query joins the order_items table to the products table using the product_id column, and joins the products table to the product_categories table using the production_type_code column. The WHERE clause filters the results to only include rows where the production_type_code column from the products table matches the input parameter p_category. The SELECT statement calculates four aggregate values: the sum of the product of the order_items.product_quantity (converted to a NUMBER) and the products.unit_price, wrapped in a NVL function to return 0 if the result is null; the count of all rows; the average of the products.unit_price, wrapped in a NVL function to return 0 if the result is null; and the maximum value of the product_categories.vat_rating, wrapped in a NVL function to return 0 if the result is null. These four calculated values are assigned into the local variables v_total_sales, v_item_count, v_avg_price, and v_vat_rate respectively. After the query, the function uses an IF-ELSIF-ELSE conditional block to determine the return value. If v_item_count equals 0, the function returns 0. Otherwise, if v_avg_price is greater than 600, the function returns the value of v_total_sales multiplied by 1.1. Otherwise, if v_vat_rate is greater than 14, the function returns the value of v_total_sales multiplied by 0.95. If none of the previous conditions are met, the function returns the unmodified v_total_sales value. The function includes an EXCEPTION handler that catches the NO_DATA_FOUND exception and returns 0, and a generic WHEN OTHERS handler that re-raises the caught exception.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_category_sales(p_category VARCHAR2) RETURN NUMBER IS\n    v_total_sales NUMBER := 0;\n    v_item_count NUMBER := 0;\n    v_avg_price NUMBER := 0;\n    v_vat_rate NUMBER := 0;\nBEGIN\n    SELECT NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0), \n           COUNT(*),\n           NVL(AVG(p.unit_price), 0),\n           NVL(MAX(pc.vat_rating), 0)\n    INTO v_total_sales, v_item_count, v_avg_price, v_vat_rate\n    FROM order_items oi\n    JOIN products p ON oi.product_id = p.product_id\n    JOIN product_categories pc ON p.production_type_code = pc.production_type_code\n    WHERE p.production_type_code = p_category;\n    \n    IF v_item_count = 0 THEN\n        RETURN 0;\n    ELSIF v_avg_price > 600 THEN\n        RETURN v_total_sales * 1.1;\n    ELSIF v_vat_rate > 14 THEN\n        RETURN v_total_sales * 0.95;\n    ELSE\n        RETURN v_total_sales;\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT calculate_category_sales('Food') FROM DUAL",
      "SELECT calculate_category_sales('Books') FROM DUAL",
      "SELECT calculate_category_sales('Electronics') FROM DUAL",
      "SELECT calculate_category_sales('DVDs') FROM DUAL",
      "SELECT calculate_category_sales('Clothing') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_category_sales that accepts a p_category VARCHAR2 and returns a NUMBER. It calculates total sales, item count, average price, and max VAT rate for a product category. Return 0 if item count is 0. If average price > 600, return total sales * 1.1. If VAT rate > 14, return total sales * 0.95. Otherwise, return total sales. Handle NO_DATA_FOUND by returning 0 and re-raise other exceptions.",
    "natural_language": "Please construct a PL/SQL function designated as 'calculate_category_sales'. This function shall accept a single input parameter, 'p_category', of type VARCHAR2, and shall return a value of type NUMBER. Its purpose is to compute the aggregate sales total, the count of items, the average price, and the maximum VAT rate pertinent to the specified product category. Should the item count be zero, the function must return zero. Subsequently, if the computed average price exceeds 600, the function is to return the total sales multiplied by 1.1. Alternatively, if the maximum VAT rate is greater than 14, the function shall return the total sales multiplied by 0.95. In all other cases, the total sales figure is to be returned. It is required to handle the NO_DATA_FOUND exception by returning a value of zero, while all other exceptions must be re-raised.",
    "id": 132
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_sales_status that accepts a single parameter p_product_id of type NUMBER, which represents the unique identifier of a product. The function returns a VARCHAR2 value indicating the sales status of the specified product. Within the function, declare three local variables: v_sales_count, v_total_revenue, and v_avg_price, all of type NUMBER. Execute a SELECT statement that retrieves the count of order items, the total revenue generated, and the average unit price for the product with the given product ID. The SELECT statement joins the order_items table, aliased as oi, with the products table, aliased as p, using the product_id column as the joining key. The COUNT function calculates the number of order items associated with the product, while the SUM function computes the total revenue by multiplying the product_quantity from the order_items table by the unit_price from the products table, using the NVL function to ensure a default value of 0 if the result is NULL. Similarly, the AVG function calculates the average unit price, again using NVL to default to 0 if the result is NULL. Store the results of the SELECT statement into the local variables v_sales_count, v_total_revenue, and v_avg_price. Implement conditional logic using an IF-ELSIF-ELSE structure to determine the sales status based on the values of these variables. If v_sales_count equals 0, return 'NO_SALES' indicating no sales have been made for the product. If v_total_revenue exceeds 10,000, return 'HIGH_REVENUE' indicating significant revenue generation. If v_avg_price is greater than 500, return 'PREMIUM_PRODUCT' indicating the product is priced at a premium. If none of these conditions are met, return 'STANDARD_PRODUCT' indicating a regular sales status.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_sales_status(p_product_id NUMBER) RETURN VARCHAR2 IS\n    v_sales_count NUMBER;\n    v_total_revenue NUMBER;\n    v_avg_price NUMBER;\nBEGIN\n    SELECT COUNT(oi.order_item_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0),\n           NVL(AVG(p.unit_price), 0)\n    INTO v_sales_count, v_total_revenue, v_avg_price\n    FROM order_items oi\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE oi.product_id = p_product_id;\n    \n    IF v_sales_count = 0 THEN\n        RETURN 'NO_SALES';\n    ELSIF v_total_revenue > 10000 THEN\n        RETURN 'HIGH_REVENUE';\n    ELSIF v_avg_price > 500 THEN\n        RETURN 'PREMIUM_PRODUCT';\n    ELSE\n        RETURN 'STANDARD_PRODUCT';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_product_sales_status(1) FROM dual",
      "SELECT get_product_sales_status(2) FROM dual",
      "SELECT get_product_sales_status(3) FROM dual",
      "SELECT get_product_sales_status(4) FROM dual",
      "SELECT get_product_sales_status(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_product_sales_status that accepts a p_product_id NUMBER and returns a VARCHAR2. It calculates the product's sales count, total revenue (quantity * price), and average price. Return 'NO_SALES' if sales count is 0, 'HIGH_REVENUE' if total revenue > 10000, 'PREMIUM_PRODUCT' if average price > 500, else 'STANDARD_PRODUCT'.",
    "natural_language": "Write a PL/SQL function called get_product_sales_status that takes a product ID number and gives back a text string. It should figure out roughly how many times the product sold, the overall money made from it, and the typical price. If it hasn't sold much at all, say 'NO_SALES'. If the money made is pretty high, say 'HIGH_REVENUE'. If the typical price is on the expensive side, say 'PREMIUM_PRODUCT'. Otherwise, just call it 'STANDARD_PRODUCT'.",
    "id": 133
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_purchase_behavior that accepts a single input parameter p_customer_id of type NUMBER and returns a VARCHAR2 string, which analyzes a customer's purchase history by performing a SELECT query that joins the orders, order_items, and products tables, specifically retrieving the count of distinct orders for the given customer into variable v_order_count, the sum of the product of the product_quantity from order_items and the unit_price from products (with the product_quantity converted from a string to a number using TO_NUMBER) into variable v_total_spent, and the average of that same product calculation into variable v_avg_order_value, using NVL to substitute a value of 0 for any NULL results from the aggregate functions, all filtered by the condition that the customer_id in the orders table matches the input p_customer_id, and then, using conditional IF-ELSIF-ELSE logic, returns the string 'NO_PURCHASES' if v_order_count equals 0, returns 'BIG_SPENDER' if v_total_spent is greater than 5000, returns 'HIGH_AVG_ORDER' if v_avg_order_value is greater than 300, and otherwise returns the string 'REGULAR_CUSTOMER'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_purchase_behavior(p_customer_id NUMBER) RETURN VARCHAR2 IS\n    v_order_count NUMBER;\n    v_total_spent NUMBER;\n    v_avg_order_value NUMBER;\nBEGIN\n    SELECT COUNT(o.order_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0),\n           NVL(AVG(TO_NUMBER(oi.product_quantity) * p.unit_price), 0)\n    INTO v_order_count, v_total_spent, v_avg_order_value\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE o.customer_id = p_customer_id;\n    \n    IF v_order_count = 0 THEN\n        RETURN 'NO_PURCHASES';\n    ELSIF v_total_spent > 5000 THEN\n        RETURN 'BIG_SPENDER';\n    ELSIF v_avg_order_value > 300 THEN\n        RETURN 'HIGH_AVG_ORDER';\n    ELSE\n        RETURN 'REGULAR_CUSTOMER';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_customer_purchase_behavior(1) FROM DUAL",
      "SELECT get_customer_purchase_behavior(5) FROM DUAL",
      "SELECT get_customer_purchase_behavior(7) FROM DUAL",
      "SELECT get_customer_purchase_behavior(12) FROM DUAL",
      "SELECT get_customer_purchase_behavior(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_purchase_behavior that accepts a p_customer_id NUMBER and returns a VARCHAR2. It calculates the customer's distinct order count, total spent (converted quantity * price), and average order value. Return 'NO_PURCHASES' if order count is 0, 'BIG_SPENDER' if total spent > 5000, 'HIGH_AVG_ORDER' if average value > 300, else 'REGULAR_CUSTOMER'.",
    "natural_language": "What PL/SQL function can be created to return a VARCHAR2 classification for a customer's purchase behavior based on their distinct order count, total amount spent, and average order value, given a customer ID, and how should it categorize them as 'NO_PURCHASES', 'BIG_SPENDER', 'HIGH_AVG_ORDER', or 'REGULAR_CUSTOMER'?",
    "id": 134
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_category_performance that accepts a single input parameter p_category of type VARCHAR2 and returns a VARCHAR2 value. The function begins by declaring three local NUMBER variables: v_product_count, v_total_revenue, and v_avg_price. It then executes a SELECT statement that queries the products table (aliased as p) by joining it with the order_items table (aliased as oi) on the condition that the product_id column from the products table matches the product_id column in the order_items table. The SELECT statement filters rows where the production_type_code column in the products table equals the input parameter p_category. For the filtered result set, the query calculates three aggregate values: the count of distinct product_id values from the products table, the sum of the product of the product_quantity column from order_items (converted to a NUMBER using the TO_NUMBER function) and the unit_price column from products (with the NVL function ensuring a result of 0 if the sum is null), and the average of the unit_price column from products (with NVL returning 0 if the average is null). These three calculated values are assigned into the local variables v_product_count, v_total_revenue, and v_avg_price respectively. After the query, the function uses an IF-ELSIF-ELSE conditional block to determine the return value. If v_product_count equals 0, the function returns the string literal 'NO_PRODUCTS'. Otherwise, if v_total_revenue is greater than 20000, it returns 'HIGH_REVENUE_CATEGORY'. Otherwise, if v_avg_price is greater than 400, it returns 'PREMIUM_CATEGORY'. If none of the previous conditions are met, the function returns 'STANDARD_CATEGORY'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_category_performance(p_category VARCHAR2) RETURN VARCHAR2 IS\n    v_product_count NUMBER;\n    v_total_revenue NUMBER;\n    v_avg_price NUMBER;\nBEGIN\n    SELECT COUNT(p.product_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0),\n           NVL(AVG(p.unit_price), 0)\n    INTO v_product_count, v_total_revenue, v_avg_price\n    FROM products p\n    JOIN order_items oi ON p.product_id = oi.product_id\n    WHERE p.production_type_code = p_category;\n    \n    IF v_product_count = 0 THEN\n        RETURN 'NO_PRODUCTS';\n    ELSIF v_total_revenue > 20000 THEN\n        RETURN 'HIGH_REVENUE_CATEGORY';\n    ELSIF v_avg_price > 400 THEN\n        RETURN 'PREMIUM_CATEGORY';\n    ELSE\n        RETURN 'STANDARD_CATEGORY';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_product_category_performance('Food') FROM DUAL",
      "SELECT get_product_category_performance('Books') FROM DUAL",
      "SELECT get_product_category_performance('Electronics') FROM DUAL",
      "SELECT get_product_category_performance('DVDs') FROM DUAL",
      "SELECT get_product_category_performance('Clothing') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_product_category_performance that accepts a category name (VARCHAR2) and returns a VARCHAR2. It calculates the product count, total revenue, and average price for that category from the products and order_items tables. It returns 'NO_PRODUCTS' if count is zero, 'HIGH_REVENUE_CATEGORY' if revenue > 20000, 'PREMIUM_CATEGORY' if average price > 400, else 'STANDARD_CATEGORY'.",
    "natural_language": "Write a function get_product_category_performance(category_name VARCHAR2) returning VARCHAR2. It finds product count, total revenue, and average price for that category. Return 'NO_PRODUCTS' if count zero, 'HIGH_REVENUE_CATEGORY' if revenue > 20000, 'PREMIUM_CATEGORY' if avg price > 400, else 'STANDARD_CATEGORY'.",
    "id": 135
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_price_by_name that accepts a single input parameter p_product_name of type VARCHAR2, which represents the name of a product to look up, and returns a value of type NUMBER. The function declares a local variable v_price of type NUMBER to temporarily hold the retrieved price. The function's logic executes a SELECT statement that queries the PRODUCTS table, specifically retrieving the value from the PRODUCT_PRICE column for the single row where the PRODUCT_NAME column exactly matches the value provided in the p_product_name input parameter; this retrieved value is stored into the local variable v_price using an INTO clause. The function then concludes by using a RETURN statement to output the value stored in the v_price variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price_by_name(p_product_name VARCHAR2) RETURN NUMBER IS\n  v_price NUMBER;\nBEGIN\n  SELECT PRODUCT_PRICE INTO v_price FROM PRODUCTS WHERE PRODUCT_NAME = p_product_name;\n  RETURN v_price;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_product_price_by_name('Chocolate') FROM DUAL",
      "SELECT get_product_price_by_name('The Great Gatsby') FROM DUAL",
      "SELECT get_product_price_by_name('Keyboard') FROM DUAL",
      "SELECT get_product_price_by_name('Handmade chocolate') FROM DUAL",
      "SELECT get_product_price_by_name('Designed for games') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_product_price_by_name that accepts a product name (VARCHAR2) and returns a NUMBER. It retrieves the product price from the PRODUCTS table where the product name matches the input parameter.",
    "natural_language": "Write a PL/SQL function called get_product_price_by_name that takes a product name as a VARCHAR2 parameter and returns a NUMBER. It should fetch the price from the PRODUCTS table for the matching product name.",
    "id": 136
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_active_complaints that returns a NUMBER data type. This function does not take any input parameters. Within the function, declare a local variable v_count of type NUMBER to store the result of a query. The function executes a SELECT statement that counts all rows in the COMPLAINTS table where the value in the COMPLAINT_STATUS_CODE column is not equal to 'Closed'. The result of this count is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the total number of complaints that are not marked as 'Closed'.",
    "plsql": "CREATE OR REPLACE FUNCTION count_active_complaints RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM COMPLAINTS WHERE COMPLAINT_STATUS_CODE != 'Closed';\n  RETURN v_count;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT count_active_complaints FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named count_active_complaints that returns a NUMBER. It counts and returns the number of rows in the COMPLAINTS table where the complaint status is not 'Closed'.",
    "natural_language": "Count the active complaints. Write a PL/SQL function called count_active_complaints that returns a NUMBER. It should count and return the rows from the COMPLAINTS table where the complaint status is not 'Closed'.",
    "id": 137
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_state that accepts a single input parameter p_customer_id of the NUMBER data type and returns a value of the VARCHAR2 data type, where the function's execution logic begins by declaring a local variable v_state of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT operation to query the STATE column from the CUSTOMERS table, using a WHERE clause condition to filter rows where the CUSTOMER_ID column exactly equals the value provided in the input parameter p_customer_id, and stores the retrieved STATE value into the local variable v_state, and finally concludes by using a RETURN statement to output the value stored in v_state.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_state(p_customer_id NUMBER) RETURN VARCHAR2 IS\n  v_state VARCHAR2(255);\nBEGIN\n  SELECT STATE INTO v_state FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n  RETURN v_state;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_customer_state(113) FROM DUAL",
      "SELECT get_customer_state(114) FROM DUAL",
      "SELECT get_customer_state(115) FROM DUAL",
      "SELECT get_customer_state(120) FROM DUAL",
      "SELECT get_customer_state(117) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_state that accepts a customer ID (NUMBER) and returns a VARCHAR2. It retrieves and returns the state from the CUSTOMERS table for the given customer ID.",
    "natural_language": "Write a PL/SQL function called get_customer_state that takes a customer ID number and gives back a text string. It should fetch and hand back the general area or region from the CUSTOMERS list for that particular customer ID.",
    "id": 138
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_total_product_value that returns a NUMBER data type, which declares a local variable v_total of type NUMBER, then executes a SELECT statement that retrieves the sum of all values in the PRODUCT_PRICE column from the PRODUCTS table, storing the result into the v_total variable, and finally returns the value contained in v_total.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_product_value RETURN NUMBER IS\n  v_total NUMBER;\nBEGIN\n  SELECT SUM(PRODUCT_PRICE) INTO v_total FROM PRODUCTS;\n  RETURN v_total;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT calculate_total_product_value FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_total_product_value that returns a NUMBER. It calculates and returns the sum of all product prices from the PRODUCTS table.",
    "natural_language": "Write a PL/SQL function calculate_total_product_value returning NUMBER to sum product prices from PRODUCTS.",
    "id": 139
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_staff_email that accepts a single parameter, p_staff_id, which is of type NUMBER and represents the unique identifier of a staff member. The function is designed to return a value of type VARCHAR2, specifically the email address associated with the given staff ID. Within the function, a local variable v_email of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the email address retrieved from the database. The function executes a SELECT statement that queries the STAFF table, specifically targeting the EMAIL_ADDRESS column, and retrieves the email address for the row where the STAFF_ID column matches the value provided in the p_staff_id parameter. The retrieved email address is stored in the v_email variable. After successfully obtaining the email address, the function returns the value stored in v_email, effectively providing the email address associated with the specified staff ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_email(p_staff_id NUMBER) RETURN VARCHAR2 IS\n  v_email VARCHAR2(255);\nBEGIN\n  SELECT EMAIL_ADDRESS INTO v_email FROM STAFF WHERE STAFF_ID = p_staff_id;\n  RETURN v_email;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_staff_email(114) FROM DUAL",
      "SELECT get_staff_email(115) FROM DUAL",
      "SELECT get_staff_email(116) FROM DUAL",
      "SELECT get_staff_email(117) FROM DUAL",
      "SELECT get_staff_email(120) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_staff_email that accepts a staff_id number and returns the corresponding email_address as a varchar2 from the STAFF table.",
    "natural_language": "Write a PL/SQL function to get the email for a staff member. The function should take a staff identifier and give back the email address from the staff records.",
    "id": 140
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_shop_stock_value` that accepts a single input parameter, `p_shop_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Internally, the function declares a local variable named `v_total_value` of data type `NUMBER` to temporarily store the calculated sum. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `STOCK` table. Specifically, it calculates the `SUM` of the values in the `QUANTITY` column from the `STOCK` table. This summation is performed only for those rows in the `STOCK` table where the value in the `SHOP_ID` column matches the value provided in the input parameter `p_shop_id`. The result of this `SUM` aggregation is then stored into the local variable `v_total_value`. Finally, the function returns the value currently held by the `v_total_value` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_shop_stock_value(p_shop_id NUMBER) RETURN NUMBER IS\n  v_total_value NUMBER;\nBEGIN\n  SELECT SUM(s.QUANTITY) INTO v_total_value FROM STOCK s WHERE s.SHOP_ID = p_shop_id;\n  RETURN v_total_value;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT calculate_shop_stock_value(1) FROM dual",
      "SELECT calculate_shop_stock_value(2) FROM dual",
      "SELECT calculate_shop_stock_value(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_shop_stock_value that accepts a shop_id number and returns the total sum of quantity from the STOCK table for that shop.",
    "natural_language": "Hey, can you whip up a PL/SQL function called calculate_shop_stock_value? It should take a shop's ID number, look up all the stock for that shop, and just add up all the quantities to give us the total.",
    "id": 141
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_device_count_by_location` that accepts a single input parameter, `p_location`, which is of data type `VARCHAR2`. This function is designed to return a `NUMBER` representing a count. Internally, the function declares a local variable named `v_count` of data type `NUMBER` to store the result of a database query. The core operation of this function involves executing a `SELECT` statement to calculate the total number of devices associated with a specific location. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows returned by the query. The query joins three tables: `DEVICE` (aliased as `d`), `STOCK` (aliased as `s`), and `SHOP` (aliased as `sh`). The `DEVICE` table is joined with the `STOCK` table using the join condition `d.DEVICE_ID = s.DEVICE_ID`, meaning rows are matched where the `DEVICE_ID` column in the `DEVICE` table is equal to the `DEVICE_ID` column in the `STOCK` table. Subsequently, the result of this join is further joined with the `SHOP` table using the join condition `s.SHOP_ID = sh.SHOP_ID`, meaning rows are matched where the `SHOP_ID` column in the `STOCK` table is equal to the `SHOP_ID` column in the `SHOP` table. A `WHERE` clause is applied to filter the results, specifically `sh.LOCATION = p_location`, which restricts the count to only those records where the `LOCATION` column in the `SHOP` table matches the value provided in the input parameter `p_location`. The aggregated count obtained from this `SELECT` statement is then stored into the local variable `v_count`. Finally, the function returns the value stored in `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_count_by_location(p_location VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM DEVICE d JOIN STOCK s ON d.DEVICE_ID = s.DEVICE_ID JOIN SHOP sh ON s.SHOP_ID = sh.SHOP_ID WHERE sh.LOCATION = p_location;\n  RETURN v_count;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_device_count_by_location('Dinas') FROM dual",
      "SELECT get_device_count_by_location('Cymmer') FROM dual",
      "SELECT get_device_count_by_location('Blaenllechau') FROM dual",
      "SELECT get_device_count_by_location('Newport') FROM dual",
      "SELECT get_device_count_by_location('Cardiff') FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_device_count_by_location that accepts a location varchar2 and returns the count of devices by joining the DEVICE, STOCK, and SHOP tables where the shop's location matches the input.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_device_count_by_location? It should take a location (as a varchar2) and spit back how many devices are there. You'll need to pull data from the DEVICE, STOCK, and SHOP tables, but only count 'em up if the shop's location matches the one we give it.",
    "id": 142
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_shop_has_device that accepts two input parameters: a numeric parameter p_shop_id representing a shop identifier and a numeric parameter p_device_id representing a device identifier, and returns a numeric value; the function logic executes a SELECT statement that queries the STOCK table to count the number of rows where the SHOP_ID column value is equal to the input parameter p_shop_id and the DEVICE_ID column value is equal to the input parameter p_device_id, storing the result of the COUNT(*) aggregate function into a local numeric variable v_exists, and then returns the value of v_exists, which represents the count of matching records found in the STOCK table.",
    "plsql": "CREATE OR REPLACE FUNCTION check_shop_has_device(p_shop_id NUMBER, p_device_id NUMBER) RETURN NUMBER IS\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_exists FROM STOCK WHERE SHOP_ID = p_shop_id AND DEVICE_ID = p_device_id;\n  RETURN v_exists;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT check_shop_has_device(1, 6) FROM DUAL",
      "SELECT check_shop_has_device(2, 1) FROM DUAL",
      "SELECT check_shop_has_device(3, 2) FROM DUAL",
      "SELECT check_shop_has_device(1, 2) FROM DUAL",
      "SELECT check_shop_has_device(2, 6) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_shop_has_device that accepts a shop_id number and a device_id number, and returns the count of matching records from the STOCK table.",
    "natural_language": "Please construct a PL/SQL function designated as 'check_shop_has_device'. This function shall accept two numerical parameters: a shop identifier and a device identifier. Its purpose is to query the STOCK table and return a count of records where both provided parameter values correspond.",
    "id": 143
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_carrier_device_quantity` that accepts a single input parameter, `p_carrier`, which is of data type `VARCHAR2`. This function is designed to return a single numerical value representing the total quantity of devices associated with the specified carrier. Upon execution, the function declares a local variable named `v_total_quantity` of data type `NUMBER` to temporarily store the calculated sum. The core operation involves a `SELECT` statement that calculates the sum of quantities. Specifically, it retrieves data from two tables: `DEVICE` (aliased as `d`) and `STOCK` (aliased as `s`). These two tables are joined using an `INNER JOIN` operation, where the join condition is `d.DEVICE_ID = s.DEVICE_ID`, meaning rows are matched when the `DEVICE_ID` column in the `DEVICE` table is equal to the `DEVICE_ID` column in the `STOCK` table. From the joined result set, the `SUM` aggregate function is applied to the `QUANTITY` column from the `STOCK` table (`s.QUANTITY`). This summation is performed only for those rows where the `CARRIER` column in the `DEVICE` table (`d.CARRIER`) matches the value provided in the input parameter `p_carrier`. The calculated sum is then stored into the `v_total_quantity` local variable. Finally, the function returns the value stored in `v_total_quantity` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_carrier_device_quantity(p_carrier VARCHAR2) RETURN NUMBER IS\n  v_total_quantity NUMBER;\nBEGIN\n  SELECT SUM(s.QUANTITY) INTO v_total_quantity FROM DEVICE d JOIN STOCK s ON d.DEVICE_ID = s.DEVICE_ID WHERE d.CARRIER = p_carrier;\n  RETURN v_total_quantity;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_carrier_device_quantity('MTS Mobility') FROM DUAL",
      "SELECT get_carrier_device_quantity('Verizon Wireless') FROM DUAL",
      "SELECT get_carrier_device_quantity('Telus Mobility') FROM DUAL",
      "SELECT get_carrier_device_quantity('AT&T') FROM DUAL",
      "SELECT get_carrier_device_quantity('Sprint') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_carrier_device_quantity that accepts a carrier varchar2 and returns the total sum of quantity from the STOCK table for devices associated with that carrier, using a join with the DEVICE table.",
    "natural_language": "Write a PL/SQL function that, for a given carrier, figures out the total number of devices we have in stock. You'll need to look at the STOCK and DEVICE tables together and add up the quantities for that carrier's devices.",
    "id": 144
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_average_stock_per_shop that takes no input parameters and returns a single numeric value; within its execution block, it declares a local numeric variable v_average, then performs a SELECT statement that queries the STOCK table, specifically applying the AVG aggregate function to the QUANTITY column to compute the arithmetic mean of all values in that column across every row in the table, storing the resulting computed average directly into the local variable v_average, and finally returns the value contained in v_average as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_stock_per_shop RETURN NUMBER IS\n  v_average NUMBER;\nBEGIN\n  SELECT AVG(QUANTITY) INTO v_average FROM STOCK;\n  RETURN v_average;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT calculate_average_stock_per_shop FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_average_stock_per_shop that returns the average quantity from all rows in the STOCK table.",
    "natural_language": "What is the PL/SQL function definition for calculating the average stock quantity per shop from the STOCK table?",
    "id": 145
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_dog_treatment_count that accepts a single input parameter p_dog_id of the NUMBER data type and returns a value of the NUMBER data type; the function declares a local variable v_count of the NUMBER data type; within the execution block, the function performs a SELECT statement that queries the TREATMENTS table, using the COUNT(*) aggregate function to calculate the total number of rows where the value in the DOG_ID column is exactly equal to the value provided in the input parameter p_dog_id; the result of this count operation is stored into the local variable v_count using an INTO clause; the function then concludes its execution by using a RETURN statement to send the value stored in v_count back to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION get_dog_treatment_count(p_dog_id IN NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM TREATMENTS WHERE DOG_ID = p_dog_id;\n    RETURN v_count;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "SELECT get_dog_treatment_count(1) FROM dual",
      "SELECT get_dog_treatment_count(2) FROM dual",
      "SELECT get_dog_treatment_count(3) FROM dual",
      "SELECT get_dog_treatment_count(4) FROM dual",
      "SELECT get_dog_treatment_count(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_dog_treatment_count that accepts a dog_id number and returns the count of rows for that dog_id from the TREATMENTS table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_dog_treatment_count? It should take a dog's ID number and spit back how many times that pup shows up in the TREATMENTS table.",
    "id": 146
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_average_treatment_cost` that is designed to return a single numeric value representing the average cost of all treatments recorded in the database. This function does not accept any input parameters. Internally, it declares a local variable named `v_avg_cost` of data type `NUMBER` to temporarily store the calculated average. The core operation involves executing a `SELECT` statement to compute the average of the `COST_OF_TREATMENT` column from all rows within the `TREATMENTS` table. The result of this aggregation, which is the average cost, is then immediately stored into the `v_avg_cost` variable. Finally, the function returns the value held by `v_avg_cost` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_treatment_cost RETURN NUMBER IS\n    v_avg_cost NUMBER;\nBEGIN\n    SELECT AVG(COST_OF_TREATMENT) INTO v_avg_cost FROM TREATMENTS;\n    RETURN v_avg_cost;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "SELECT calculate_average_treatment_cost FROM DUAL",
      "SELECT calculate_average_treatment_cost() FROM DUAL",
      "DECLARE\n  v_avg NUMBER;\nBEGIN\n  v_avg := calculate_average_treatment_cost;\n  DBMS_OUTPUT.PUT_LINE('Average cost: ' || v_avg);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average treatment cost: ' || calculate_average_treatment_cost);\nEND;",
      "SELECT TREATMENT_ID, DOG_ID, COST_OF_TREATMENT, calculate_average_treatment_cost AS AVG_COST FROM TREATMENTS WHERE ROWNUM <= 3"
    ],
    "summary": "Create a PL/SQL function named calculate_average_treatment_cost that returns the average cost from the COST_OF_TREATMENT column in the TREATMENTS table.",
    "natural_language": "What is the average cost from the COST_OF_TREATMENT column in the TREATMENTS table? Create a PL/SQL function named calculate_average_treatment_cost to return this value.",
    "id": 147
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_current_timezone that takes no input parameters and returns a single VARCHAR2 value, which is the function's output. The function declares a local variable v_timezone of type VARCHAR2 with a maximum length of 255 characters to hold the result. The function's execution block begins by performing a SELECT statement that queries the built-in pseudo-table DUAL to retrieve the value of the SESSIONTIMEZONE function, which returns the time zone of the current database session; this selected value is stored into the local variable v_timezone using an INTO clause. The function then concludes by using a RETURN statement to output the value stored in the v_timezone variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_current_timezone RETURN VARCHAR2 IS\n    v_timezone VARCHAR2(255);\nBEGIN\n    SELECT SESSIONTIMEZONE INTO v_timezone FROM DUAL;\n    RETURN v_timezone;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "SELECT get_current_timezone FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_current_timezone that returns the current session's timezone as a string.",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_current_timezone', which shall provide the timezone of the current session in the form of a character string.",
    "id": 148
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_timezone_adoption_date` that accepts a single input parameter, `p_dog_id`, which is of data type `NUMBER` and represents the unique identifier for a dog. This function is designed to return a `VARCHAR2` string, specifically a formatted date and time string. The function's primary purpose is to retrieve the adoption date for a specific dog, convert it to a `TIMESTAMP` data type, adjust it to the current database session's time zone, and then format it as a string.\n\nInside the function's `BEGIN` block, a local variable `v_date_adopted` of type `VARCHAR2(255)` is declared to temporarily store the formatted adoption date. The core operation involves a `SELECT` statement that queries the `DOGS` table. This `SELECT` statement retrieves the `DATE_ADOPTED` column. The `DATE_ADOPTED` column's value is first converted to a `TIMESTAMP` data type using the `TO_TIMESTAMP` function, with the format mask `'YYYY-MM-DD HH24:MI:SS'` indicating that the original `DATE_ADOPTED` string is expected to be in the format of year-month-day hour:minute:second. This `TIMESTAMP` value is then explicitly adjusted to the time zone of the current database session using the `AT TIME ZONE SESSIONTIMEZONE` clause. Finally, the resulting time zone-adjusted `TIMESTAMP` is converted back into a `VARCHAR2` string using the `TO_CHAR` function, again with the format mask `'YYYY-MM-DD HH24:MI:SS'`. The result of this conversion is then stored into the `v_date_adopted` variable. The `WHERE` clause of the `SELECT` statement filters the records in the `DOGS` table, ensuring that only the row where the `DOG_ID` column matches the input parameter `p_dog_id` is considered.\n\nAfter the `SELECT` statement successfully executes and populates `v_date_adopted`, the function returns the value stored in `v_date_adopted`.\n\nThe function includes an `EXCEPTION` block to handle potential errors. If the `SELECT` statement does not find any row matching the provided `p_dog_id` (i.e., `NO_DATA_FOUND` exception occurs), the function catches this specific exception and returns `NULL`. If any other type of error occurs during the execution of the `SELECT` statement, such as an invalid date format in the `DATE_ADOPTED` column that prevents `TO_TIMESTAMP` from succeeding, or any other conversion error (caught by the `WHEN OTHERS` clause), the function also catches this general exception and returns `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_timezone_adoption_date(p_dog_id IN NUMBER) RETURN VARCHAR2 IS\n    v_date_adopted VARCHAR2(255);\nBEGIN\n    SELECT TO_CHAR(\n             TO_TIMESTAMP(DATE_ADOPTED, 'YYYY-MM-DD HH24:MI:SS') AT TIME ZONE SESSIONTIMEZONE,\n             'YYYY-MM-DD HH24:MI:SS'\n           )\n    INTO v_date_adopted\n    FROM DOGS\n    WHERE DOG_ID = p_dog_id;\n    \n    RETURN v_date_adopted;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN OTHERS THEN\n        -- Handle invalid date format or other conversion errors\n        RETURN NULL;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "SELECT get_timezone_adoption_date(1) FROM dual",
      "SELECT get_timezone_adoption_date(2) FROM dual",
      "SELECT get_timezone_adoption_date(3) FROM dual",
      "SELECT get_timezone_adoption_date(4) FROM dual",
      "SELECT get_timezone_adoption_date(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_timezone_adoption_date` that accepts a dog ID (NUMBER) and returns a VARCHAR2. It retrieves the adoption date for the specified dog from the DOGS table, converts it to a TIMESTAMP, adjusts it to the session time zone, formats it as 'YYYY-MM-DD HH24:MI:SS', and returns the string. Return NULL if no data is found or if any error occurs.",
    "natural_language": "Develop a PL/SQL function called `get_timezone_adjustment_date` that takes a single numeric input representing a dog's unique identifier and yields a VARCHAR2 string. This function should meticulously query the DOGS table to locate the precise adoption date for the provided dog ID. Upon finding the record, it must carefully convert the date into a TIMESTAMP, thoughtfully adjust that timestamp to align with the current session's time zone, and then elegantly format the final result into the specific 'YYYY-MM-DD HH24:MI:SS' pattern. It is essential that the function gracefully handles cases where no corresponding data exists or if any unforeseen errors arise during execution, securely returning a NULL value in such instances.",
    "id": 149
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_form_type_count that accepts two parameters: p_form_type_code of type VARCHAR2 and p_service_id of type NUMBER. This function is designed to return a NUMBER. Within the function, declare a local variable v_count of type NUMBER to store the result of a query. The function executes a SELECT statement that counts the number of rows in the FORMS table where the FORM_TYPE_CODE column matches the value of the p_form_type_code parameter and the SERVICE_ID column matches the value of the p_service_id parameter. The result of this count is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the total number of forms that meet the specified criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION get_form_type_count(p_form_type_code VARCHAR2, p_service_id NUMBER)\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count \n    FROM FORMS \n    WHERE FORM_TYPE_CODE = p_form_type_code \n    AND SERVICE_ID = p_service_id;\n    RETURN v_count;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_form_type_count('Basic', 13) FROM dual",
      "SELECT get_form_type_count('Complex', 9) FROM dual",
      "SELECT get_form_type_count('Basic', 2) FROM dual",
      "SELECT get_form_type_count('Complex', 13) FROM dual",
      "SELECT get_form_type_count('Basic', 9) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_form_type_count` that accepts a form type code (VARCHAR2) and a service ID (NUMBER) and returns a NUMBER. It counts and returns the number of rows in the FORMS table where the FORM_TYPE_CODE and SERVICE_ID match the input parameters.",
    "natural_language": "Please construct a PL/SQL function designated as `get_form_type_count`. This function shall accept two input parameters: a form type code, defined as VARCHAR2, and a service ID, defined as NUMBER. Its purpose is to ascertain and return a NUMBER representing the count of records within the FORMS table for which the FORM_TYPE_CODE and SERVICE_ID columns correspond precisely to the provided input arguments.",
    "id": 150
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_service_name_by_type that accepts three input parameters: a VARCHAR2 parameter named p_service_type_code, a VARCHAR2 parameter named p_country, and a VARCHAR2 parameter named p_state, and returns a single VARCHAR2 value; within the function, it declares a local VARCHAR2 variable v_service_name with a maximum length of 255 characters; the function executes a SELECT statement that queries the SERVICES table, specifically retrieving the value from the SERVICE_NAME column; the SELECT statement includes a WHERE clause with three conditions that must all be true for a row to be selected: the first condition checks that the SERVICE_TYPE_CODE column value is exactly equal to the input parameter p_service_type_code, the second condition uses the LIKE operator to check that the SERVICE_DESCRIPTIO column value contains the string from the input parameter p_country by using pattern matching with '%' || p_country || '%', and the third condition also uses the LIKE operator to check that the same SERVICE_DESCRIPTIO column value contains the string from the input parameter p_state by using pattern matching with '%' || p_state || '%'; the result of this SELECT query is assigned into the local variable v_service_name using an INTO clause; finally, the function returns the value stored in the v_service_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_service_name_by_type(p_service_type_code VARCHAR2, p_country VARCHAR2, p_state VARCHAR2)\nRETURN VARCHAR2\nIS\n    v_service_name VARCHAR2(255);\nBEGIN\n    SELECT SERVICE_NAME INTO v_service_name \n    FROM SERVICES \n    WHERE SERVICE_TYPE_CODE = p_service_type_code \n    AND SERVICE_DESCRIPTIO LIKE '%' || p_country || '%' \n    AND SERVICE_DESCRIPTIO LIKE '%' || p_state || '%';\n    RETURN v_service_name;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_service_name_by_type('Education', 'USA', 'NorthCarolina') FROM DUAL",
      "SELECT get_service_name_by_type('Welfare', 'USA', 'Colorado') FROM DUAL",
      "SELECT get_service_name_by_type('Health', 'USA', 'NewHampshire') FROM DUAL",
      "SELECT get_service_name_by_type('Education', 'USA', 'California') FROM DUAL",
      "SELECT get_service_name_by_type('Welfare', 'Canada', 'Ontario') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_service_name_by_type` that accepts a service type code, a country string, and a state string (all VARCHAR2) and returns a VARCHAR2. It retrieves the SERVICE_NAME from the SERVICES table where the SERVICE_TYPE_CODE matches exactly and the SERVICE_DESCRIPTIO contains both the country and state strings. Return the service name.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be named `get_service_name_by_type`, that meticulously accepts three distinct input parameters: a service type code, a country string, and a state string, all explicitly defined as VARCHAR2 data types, and subsequently returns a value as a VARCHAR2. This function's primary purpose is to carefully retrieve the precise SERVICE_NAME from the detailed SERVICES table, specifically under the condition that the SERVICE_TYPE_CODE matches the provided input exactly and, furthermore, the SERVICE_DESCRIPTIO text field thoroughly contains both the specified country and state strings within its content. Finally, it must return the identified service name.",
    "id": 151
  },
  {
    "ir": "Write an Oracle PL/SQL function named `count_party_addresses_by_type` that is designed to return a single numeric value. This function accepts three input parameters: `p_party_id`, which is a `NUMBER` type representing the unique identifier of a party; `p_address_type_code`, which is a `VARCHAR2` type representing the specific type of address (e.g., 'HOME', 'WORK'); and `p_year`, which is a `NUMBER` type representing the year for which addresses are to be counted. Internally, the function declares a local variable `v_count` of `NUMBER` type to store the result of a counting operation. The core logic of the function involves executing a `SELECT` statement to retrieve data. This `SELECT` statement performs a `COUNT(*)` operation, which counts the total number of rows that satisfy specific conditions. The count is then stored into the `v_count` variable. The data is retrieved from the `PARTY_ADDRESSES` table. The conditions applied in the `WHERE` clause are as follows: first, the `PARTY_ID` column in the `PARTY_ADDRESSES` table must be equal to the value provided in the `p_party_id` input parameter; second, the `ADDRESS_TYPE_CODE` column in the `PARTY_ADDRESSES` table must be equal to the value provided in the `p_address_type_code` input parameter; and third, the year extracted from the `DATE_ADDRESS_FROM` column must be equal to the value provided in the `p_year` input parameter. To achieve this third condition, the `DATE_ADDRESS_FROM` column, which is assumed to be a string, is first explicitly converted to a `DATE` data type using the `TO_DATE` function with the format mask `'YYYY-MM-DD HH24:MI:SS'`, and then the `EXTRACT(YEAR FROM ...)` function is used to extract the year component from the resulting date value. Finally, after the `SELECT` statement has executed and the count is stored in `v_count`, the function returns the value of `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_party_addresses_by_type(p_party_id NUMBER, p_address_type_code VARCHAR2, p_year NUMBER)\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count \n    FROM PARTY_ADDRESSES \n    WHERE PARTY_ID = p_party_id \n    AND ADDRESS_TYPE_CODE = p_address_type_code \n    AND EXTRACT(YEAR FROM TO_DATE(DATE_ADDRESS_FROM, 'YYYY-MM-DD HH24:MI:SS')) = p_year;\n    RETURN v_count;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT count_party_addresses_by_type(10, 'Residence', 2016) FROM DUAL",
      "SELECT count_party_addresses_by_type(15, 'Billing', 2016) FROM DUAL",
      "SELECT count_party_addresses_by_type(4, 'Delivery', 2016) FROM DUAL",
      "SELECT count_party_addresses_by_type(10, 'Billing', 2016) FROM DUAL",
      "SELECT count_party_addresses_by_type(15, 'Residence', 2016) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `count_party_addresses_by_type` that accepts a party ID (NUMBER), an address type code (VARCHAR2), and a year (NUMBER) and returns a NUMBER. It counts and returns the number of addresses in the PARTY_ADDRESSES table for the specified party, address type, and where the year extracted from the DATE_ADDRESS_FROM column matches the input year.",
    "natural_language": "Develop a PL/SQL function called `count_party_addresses_by_type` that takes three distinct input parameters: a party identifier of type NUMBER, a specific address type code as a VARCHAR2, and a particular year also as a NUMBER. This function should meticulously calculate and deliver a NUMBER result, which represents the precise count of address records. It must query the PARTY_ADDRESSES table, carefully filtering to include only those entries that correspond exactly to the provided party ID, match the specified address type code, and where the year component meticulously extracted from the DATE_ADDRESS_FROM column is identical to the input year parameter.",
    "id": 152
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_party_email_by_phone that accepts three input parameters: p_party_phone of type VARCHAR2, p_payment_method_code of type VARCHAR2, and p_country of type VARCHAR2. The function returns a value of type VARCHAR2. The purpose of this function is to retrieve the email address of a party from the PARTIES table based on specific criteria. The function begins by declaring a local variable v_party_email of type VARCHAR2 with a maximum length of 255 characters to store the email address retrieved from the database. The function then executes a SELECT statement to fetch the PARTY_EMAIL column from the PARTIES table. The selection criteria for this query include three conditions: the PARTY_PHONE column must match the value of the input parameter p_party_phone, the PAYMENT_METHOD_CODE column must match the value of the input parameter p_payment_method_code, and the PARTY_EMAIL column must contain the value of the input parameter p_country as a substring. The LIKE operator is used in conjunction with the concatenation of '%' wildcards around the p_country parameter to achieve this substring match. If a row satisfying all these conditions is found, the PARTY_EMAIL value is stored in the v_party_email variable. Finally, the function returns the value of v_party_email, which contains the email address of the party that meets the specified criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION get_party_email_by_phone(p_party_phone VARCHAR2, p_payment_method_code VARCHAR2, p_country VARCHAR2)\nRETURN VARCHAR2\nIS\n    v_party_email VARCHAR2(255);\nBEGIN\n    SELECT PARTY_EMAIL INTO v_party_email \n    FROM PARTIES \n    WHERE PARTY_PHONE = p_party_phone \n    AND PAYMENT_METHOD_CODE = p_payment_method_code \n    AND PARTY_EMAIL LIKE '%' || p_country || '%';\n    RETURN v_party_email;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_party_email_by_phone('05374656172', 'Cheque', 'com') FROM dual",
      "SELECT get_party_email_by_phone('1-525-947-7867x51521', 'Credit Card', 'org') FROM dual",
      "SELECT get_party_email_by_phone('1-606-232-3728x3568', 'Cheque', 'example') FROM dual",
      "SELECT get_party_email_by_phone('05374656172', 'Credit Card', 'net') FROM dual",
      "SELECT get_party_email_by_phone('1-525-947-7867x51521', 'Cheque', 'example') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_party_email_by_phone` that accepts a party phone number, a payment method code, and a country string (all VARCHAR2) and returns a VARCHAR2. It retrieves the PARTY_EMAIL from the PARTIES table where the PARTY_PHONE and PAYMENT_METHOD_CODE match the inputs and the PARTY_EMAIL contains the country string as a substring. Return the email address.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be named `get_party_email_by_phone`, which is designed to meticulously accept three distinct VARCHAR2 parameters: a specific party phone number, a precise payment method code, and a descriptive country string. This function's primary purpose is to carefully retrieve and subsequently return, as a VARCHAR2, the relevant PARTY_EMAIL from the detailed PARTIES table. This retrieval occurs only under the exact condition where the table's PARTY_PHONE and PAYMENT_METHOD_CODE columns perfectly match the provided input arguments, while also ensuring that the located PARTY_EMAIL field meaningfully contains the supplied country string as an identifiable substring within it.",
    "id": 153
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_director_gender_by_series that accepts a single input parameter named series_id of the NUMBER data type and returns a VARCHAR2 value. The function begins by declaring a local variable named director_gender of type VARCHAR2(255). The core operation is a SELECT statement that retrieves a single value into this variable. This query performs an INNER JOIN between the DIRECTOR table (aliased as 'd') and the DIRECTED_BY table (aliased as 'db') using the condition that the DID column from the DIRECTOR table equals the DID column from the DIRECTED_BY table. From the joined result set, it selects the GENDER column from the DIRECTOR table specifically for the row where the MSID column in the DIRECTED_BY table matches the provided series_id input parameter. After the SELECT, the function executes a conditional IF statement to check if the retrieved director_gender value is NULL. If the condition evaluates to TRUE, meaning no matching director was found or the gender value was NULL, the function assigns the literal string 'Unknown' to the director_gender variable. Finally, the function concludes by using a RETURN statement to output the value held in the director_gender variable, which will be either the retrieved gender string or the string 'Unknown'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_director_gender_by_series(series_id NUMBER) RETURN VARCHAR2 IS\n  director_gender VARCHAR2(255);\nBEGIN\n  SELECT d.GENDER INTO director_gender FROM DIRECTOR d JOIN DIRECTED_BY db ON d.DID = db.DID WHERE db.MSID = series_id;\n  IF director_gender IS NULL THEN\n    director_gender := 'Unknown';\n  END IF;\n  RETURN director_gender;\nEND;",
    "database_name": "imdb",
    "tables": [
      "DIRECTOR",
      "DIRECTED_BY",
      "TV_SERIES",
      "WRITTEN_BY"
    ],
    "call_sqls": [
      "SELECT get_director_gender_by_series(101) FROM DUAL",
      "SELECT get_director_gender_by_series(205) FROM DUAL",
      "SELECT get_director_gender_by_series(312) FROM DUAL",
      "SELECT get_director_gender_by_series(418) FROM DUAL",
      "SELECT get_director_gender_by_series(529) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_director_gender_by_series that accepts a series_id (NUMBER) and returns a VARCHAR2. It retrieves the director's gender by joining the DIRECTOR and DIRECTED_BY tables on DID, where DIRECTED_BY.MSID matches the input. If the result is NULL, return 'Unknown'; otherwise, return the gender.",
    "natural_language": "Write a PL/SQL function that takes a series number and gives back a text string. It should figure out the director's gender by looking through the DIRECTOR and DIRECTED_BY tables, connecting them where the IDs match and the series ID fits the one provided. If it finds a gender, return that; if nothing comes up or it's unclear, just say 'Unknown'.",
    "id": 154
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_series_budget_threshold that accepts two parameters: series_title of type VARCHAR2, which represents the title of a TV series, and threshold of type VARCHAR2, which represents a budget threshold value. The function retrieves the budget value associated with the given series_title from the TV_SERIES table by selecting the BUDGET column where the TITLE column matches the series_title parameter. It stores this budget value in a local variable named budget_val of type VARCHAR2 with a maximum length of 255 characters. The function then compares the length of the budget_val string with the length of the threshold string using the LENGTH function. If the length of budget_val is greater than the length of threshold, the function assigns the string 'HIGH' to a local variable named result of type VARCHAR2 with a maximum length of 10 characters. Otherwise, it assigns the string 'LOW' to the result variable. Finally, the function returns the value stored in the result variable, indicating whether the budget length is considered 'HIGH' or 'LOW' compared to the threshold length.",
    "plsql": "CREATE OR REPLACE FUNCTION check_series_budget_threshold(series_title VARCHAR2, threshold VARCHAR2) RETURN VARCHAR2 IS\n  budget_val VARCHAR2(255);\n  result VARCHAR2(10);\nBEGIN\n  SELECT BUDGET INTO budget_val FROM TV_SERIES WHERE TITLE = series_title;\n  IF LENGTH(budget_val) > LENGTH(threshold) THEN\n    result := 'HIGH';\n  ELSE\n    result := 'LOW';\n  END IF;\n  RETURN result;\nEND;",
    "database_name": "imdb",
    "tables": [
      "DIRECTOR",
      "DIRECTED_BY",
      "TV_SERIES",
      "WRITTEN_BY"
    ],
    "call_sqls": [
      "SELECT check_series_budget_threshold('Stranger Things', '1000000') FROM DUAL",
      "SELECT check_series_budget_threshold('The Crown', '50000000') FROM DUAL",
      "SELECT check_series_budget_threshold('Game of Thrones', '15000000') FROM DUAL",
      "SELECT check_series_budget_threshold('Breaking Bad', '3000000') FROM DUAL",
      "SELECT check_series_budget_threshold('The Mandalorian', '120000000') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_series_budget_threshold that accepts a series_title (VARCHAR2) and a threshold (VARCHAR2). It retrieves the budget for the given title from the TV_SERIES table. It compares the string length of the budget to the threshold's length. If the budget length is greater, return 'HIGH'; otherwise, return 'LOW'.",
    "natural_language": "Write a PL/SQL function called check_series_budget_threshold that takes a series title and a threshold value. It should look up the budget for that show and see if the length of the budget string seems a bit long compared to the threshold's length. If it looks like it's generally longer, then come back with 'HIGH'; if not, just say 'LOW'.",
    "id": 155
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_director_birth_year_by_writer that accepts a single input parameter named writer_id of type NUMBER, which identifies a writer, and returns a value of type NUMBER. The function begins by declaring a local variable named birth_year of type NUMBER. It then executes a SELECT statement to retrieve a value into this variable. The query joins three tables: the DIRECTOR table (aliased as d), the DIRECTED_BY table (aliased as db), and the WRITTEN_BY table (aliased as wb). The join condition links the DIRECTOR and DIRECTED_BY tables on the equality of the d.DID column and the db.DID column. A second join condition links the DIRECTED_BY and WRITTEN_BY tables on the equality of the db.MSID column and the wb.MSID column. The WHERE clause filters the result set to only those rows where the wb.WID column equals the input parameter writer_id. The selected column is d.BIRTH_YEAR from the DIRECTOR table. Following the data retrieval, the function uses an IF conditional statement to check if the retrieved birth_year value is less than 1950. If this condition evaluates to TRUE, the function reassigns the birth_year variable to the value 1950. Finally, the function returns the value of the birth_year variable, which is either the original BIRTH_YEAR from the database or the adjusted value of 1950.",
    "plsql": "CREATE OR REPLACE FUNCTION get_director_birth_year_by_writer(writer_id NUMBER) RETURN NUMBER IS\n  birth_year NUMBER;\nBEGIN\n  SELECT d.BIRTH_YEAR INTO birth_year FROM DIRECTOR d JOIN DIRECTED_BY db ON d.DID = db.DID JOIN WRITTEN_BY wb ON db.MSID = wb.MSID WHERE wb.WID = writer_id;\n  IF birth_year < 1950 THEN\n    birth_year := 1950;\n  END IF;\n  RETURN birth_year;\nEND;",
    "database_name": "imdb",
    "tables": [
      "DIRECTOR",
      "DIRECTED_BY",
      "TV_SERIES",
      "WRITTEN_BY"
    ],
    "call_sqls": [
      "SELECT get_director_birth_year_by_writer(1) FROM DUAL",
      "SELECT get_director_birth_year_by_writer(2) FROM DUAL",
      "SELECT get_director_birth_year_by_writer(3) FROM DUAL",
      "SELECT get_director_birth_year_by_writer(4) FROM DUAL",
      "SELECT get_director_birth_year_by_writer(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_director_birth_year_by_writer that accepts a writer_id (NUMBER) and returns a NUMBER. It retrieves a director's birth year by joining DIRECTOR, DIRECTED_BY, and WRITTEN_BY tables, where WRITTEN_BY.WID matches the input. If the birth year is less than 1950, return 1950; otherwise, return the birth year.",
    "natural_language": "Write a PL/SQL function called get_director_birth_year_by_writer that takes a writer_id number. It should figure out a director's birth year by connecting the DIRECTOR, DIRECTED_BY, and WRITTEN_BY tables, using the given writer ID. If the birth year seems kind of old, like before 1950, just give back 1950; otherwise, return whatever year it finds.",
    "id": 156
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_series_age that accepts a single parameter series_id of type NUMBER, which represents the unique identifier of a TV series. The function begins by declaring two local variables: release_year and current_year, both of type NUMBER. It then performs a SELECT operation to retrieve the RELEASE_YEAR from the TV_SERIES table where the SID column matches the provided series_id, storing the result in the release_year variable. Next, the function assigns the current year to the current_year variable by extracting the year component from the CURRENT_TIMESTAMP using the EXTRACT function. The function then evaluates a conditional statement: if the difference between current_year and release_year is greater than 20, it adjusts the current_year to be 20 years after the release_year. Finally, the function returns the difference between current_year and release_year, effectively calculating the age of the series, but capping it at 20 years if it exceeds that threshold.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_series_age(series_id NUMBER) RETURN NUMBER IS\n  release_year NUMBER;\n  current_year NUMBER;\nBEGIN\n  SELECT RELEASE_YEAR INTO release_year FROM TV_SERIES WHERE SID = series_id;\n  current_year := EXTRACT(YEAR FROM CURRENT_TIMESTAMP);\n  IF current_year - release_year > 20 THEN\n    current_year := release_year + 20;\n  END IF;\n  RETURN current_year - release_year;\nEND;",
    "database_name": "imdb",
    "tables": [
      "DIRECTOR",
      "DIRECTED_BY",
      "TV_SERIES",
      "WRITTEN_BY"
    ],
    "call_sqls": [
      "SELECT calculate_series_age(1) FROM DUAL",
      "SELECT calculate_series_age(2) FROM DUAL",
      "SELECT calculate_series_age(3) FROM DUAL",
      "SELECT calculate_series_age(4) FROM DUAL",
      "SELECT calculate_series_age(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_series_age that accepts a series_id (NUMBER) and returns a NUMBER. It calculates the series age by subtracting its release year (from TV_SERIES) from the current year. If the age exceeds 20, cap it at 20 and return that value.",
    "natural_language": "Please construct a PL/SQL function designated as 'calculate_series_age'. This function shall accept a single input parameter of type NUMBER, identified as 'series_id', and shall yield a return value of type NUMBER. The function's purpose is to compute the age of a television series by determining the difference between the current year and the series' release year, as obtained from the 'TV_SERIES' table. Should the computed age surpass 20 years, the function must impose an upper limit and return the value of 20.",
    "id": 157
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_director_nationality_by_series_title that accepts a single input parameter called title_input of type VARCHAR2 and returns a value of type VARCHAR2, which executes a SELECT statement to retrieve a value into a local variable nationality_val by querying the DIRECTOR table (aliased as d), the DIRECTED_BY table (aliased as db), and the TV_SERIES table (aliased as ts), where the join condition links the DIRECTOR table to the DIRECTED_BY table on the equality of the DID column from both tables, and links the DIRECTED_BY table to the TV_SERIES table on the equality of the MSID column from the DIRECTED_BY table and the SID column from the TV_SERIES table, with a filter condition specifying that the TITLE column from the TV_SERIES table must exactly match the provided title_input parameter, and the selected column is the NATIONALITY column from the DIRECTOR table; after the selection, the function uses a conditional IF statement to check if the first character of the retrieved nationality_val string, obtained using the SUBSTR function with arguments nationality_val, 1, and 1, is equal to the uppercase letter 'U', and if this condition is true, it reassigns the nationality_val variable to the string literal 'US'; finally, the function returns the value of the nationality_val variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_director_nationality_by_series_title(title_input VARCHAR2) RETURN VARCHAR2 IS\n  nationality_val VARCHAR2(255);\nBEGIN\n  SELECT d.NATIONALITY INTO nationality_val FROM DIRECTOR d JOIN DIRECTED_BY db ON d.DID = db.DID JOIN TV_SERIES ts ON db.MSID = ts.SID WHERE ts.TITLE = title_input;\n  IF SUBSTR(nationality_val, 1, 1) = 'U' THEN\n    nationality_val := 'US';\n  END IF;\n  RETURN nationality_val;\nEND;",
    "database_name": "imdb",
    "tables": [
      "DIRECTOR",
      "DIRECTED_BY",
      "TV_SERIES",
      "WRITTEN_BY"
    ],
    "call_sqls": [
      "SELECT get_director_nationality_by_series_title('Breaking Bad') FROM DUAL",
      "SELECT get_director_nationality_by_series_title('Stranger Things') FROM DUAL",
      "SELECT get_director_nationality_by_series_title('The Crown') FROM DUAL",
      "SELECT get_director_nationality_by_series_title('Game of Thrones') FROM DUAL",
      "SELECT get_director_nationality_by_series_title('The Office') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_director_nationality_by_series_title that accepts a title_input (VARCHAR2) and returns a VARCHAR2. It retrieves the director's nationality by joining DIRECTOR, DIRECTED_BY, and TV_SERIES tables, where TV_SERIES.TITLE matches the input. If the nationality's first character is 'U', return 'US'; otherwise, return the nationality.",
    "natural_language": "Write a PL/SQL function called get_director_nationality_by_series_title that takes a series title as input. It should figure out the director's country by linking the relevant tables. If the country seems to be from the US or something similar starting with 'U', just say 'US'. Otherwise, give back whatever the nationality is.",
    "id": 158
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_claim_amount` that accepts a single input parameter. This parameter, named `para_Policy_ID`, is of the `NUMBER` data type and is intended to represent a unique identifier for a policy. The function is designed to return a single value of the `NUMBER` data type, which will represent the total claim amount associated with the provided policy ID.\n\nUpon execution, the function declares a local variable named `claim_amount` of the `NUMBER` data type to temporarily store the calculated sum of claimed amounts. The core operation involves a `SELECT` statement that calculates the sum of values from the `AMOUNT_CLAIMED` column. This summation is performed on rows within the `CLAIMS` table. The `WHERE` clause of the `SELECT` statement filters these rows, ensuring that only those records where the `POLICY_ID` column matches the value provided by the input parameter `para_Policy_ID` are included in the sum. The result of this summation is then stored into the `claim_amount` local variable.\n\nFollowing the data retrieval, the function proceeds with a conditional check using an `IF` statement. It evaluates whether the `claim_amount` variable is `NOT NULL`. If `claim_amount` contains a non-null value (meaning that at least one claim was found for the given `para_Policy_ID` and its `AMOUNT_CLAIMED` was summed), the function immediately returns the value stored in `claim_amount`. Conversely, if the `claim_amount` variable is `NULL` (which would occur if no claims were found for the specified `para_Policy_ID`, resulting in `SUM()` returning `NULL`), the `ELSE` block is executed, and the function returns the numeric value `0`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_claim_amount(para_Policy_ID NUMBER) RETURN NUMBER IS claim_amount NUMBER;\nBEGIN\n  SELECT SUM(AMOUNT_CLAIMED) INTO claim_amount FROM CLAIMS WHERE POLICY_ID = para_Policy_ID;\n  \n  IF claim_amount IS NOT NULL THEN\n    RETURN claim_amount;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS"
    ],
    "call_sqls": [
      "SELECT get_claim_amount(744) FROM DUAL",
      "SELECT get_claim_amount(552) FROM DUAL",
      "SELECT get_claim_amount(473) FROM DUAL",
      "SELECT get_claim_amount(119) FROM DUAL",
      "SELECT get_claim_amount(141) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_claim_amount` that accepts a policy ID number and returns the total sum of claimed amounts for that policy from the CLAIMS table. If no claims are found, return 0.",
    "natural_language": "Please construct a PL/SQL function designated as `get_claim_amount`. This function shall receive a policy ID number as its input parameter. Its purpose is to compute and return the aggregate sum of all claimed amounts associated with the specified policy, as recorded in the CLAIMS table. In the event that no corresponding claims are located, the function must yield a value of zero.",
    "id": 159
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_settled_amount` that accepts a single input parameter, `para_Policy_ID`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Internally, the function declares a local variable named `settled_amount` of data type `NUMBER` to temporarily store the calculated sum. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `CLAIMS` table. Specifically, it calculates the `SUM` of the values in the `AMOUNT_SETTLED` column. This summation is performed only for those rows in the `CLAIMS` table where the value in the `POLICY_ID` column matches the value provided in the input parameter `para_Policy_ID`. The result of this summation is then stored into the local variable `settled_amount`. Following this data retrieval, the function proceeds with a conditional check: it evaluates whether the value stored in `settled_amount` `IS NOT NULL`. If `settled_amount` contains a non-null value, the function returns the value of `settled_amount`. Otherwise, if `settled_amount` `IS NULL` (which would occur if no matching records were found in the `CLAIMS` table for the given `para_Policy_ID`, resulting in a `SUM` of `NULL`), the function returns the numeric literal `0`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_settled_amount(para_Policy_ID NUMBER) RETURN NUMBER IS settled_amount NUMBER;\nBEGIN\n  SELECT SUM(AMOUNT_SETTLED) INTO settled_amount FROM CLAIMS WHERE POLICY_ID = para_Policy_ID;\n  \n  IF settled_amount IS NOT NULL THEN\n    RETURN settled_amount;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS"
    ],
    "call_sqls": [
      "SELECT get_settled_amount(744) FROM DUAL",
      "SELECT get_settled_amount(552) FROM DUAL",
      "SELECT get_settled_amount(473) FROM DUAL",
      "SELECT get_settled_amount(119) FROM DUAL",
      "SELECT get_settled_amount(141) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_settled_amount` that accepts a policy ID number and returns the total sum of settled amounts for that policy from the CLAIMS table. If no matching records are found, return 0.",
    "natural_language": "Write a PL/SQL function called `get_settled_amount` that takes a policy ID and gives back roughly the overall settled total for that policy from the CLAIMS data. If there aren't really any matching entries, just return zero.",
    "id": 160
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_policy_dates that accepts a single input parameter named para_Policy_ID of the NUMBER data type, which is intended to identify a specific policy record, and returns a VARCHAR2 string. The function declares a local variable named policy_dates of type VARCHAR2(255). The function executes a SELECT statement that queries the CUSTOMER_POLICIES table, specifically retrieving the START_DATE and END_DATE columns for the row where the POLICY_ID column matches the provided para_Policy_ID parameter value. The SELECT statement concatenates these two date values into a single string using the concatenation operator, placing the literal string ' to ' between the START_DATE and END_DATE values, and stores the result directly into the local policy_dates variable. Following the data retrieval, the function uses an IF-THEN-ELSE conditional statement to evaluate if the policy_dates variable is NOT NULL. If the condition is true, meaning a row was found and the concatenated string was successfully assigned, the function returns the content of the policy_dates variable. If the condition is false, meaning the SELECT statement found no matching row and the policy_dates variable remains NULL, the function returns the literal string 'No Dates'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_policy_dates(para_Policy_ID NUMBER) RETURN VARCHAR2 IS policy_dates VARCHAR2(255);\nBEGIN\n  SELECT START_DATE || ' to ' || END_DATE INTO policy_dates FROM CUSTOMER_POLICIES WHERE POLICY_ID = para_Policy_ID;\n  \n  IF policy_dates IS NOT NULL THEN\n    RETURN policy_dates;\n  ELSE\n    RETURN 'No Dates';\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS"
    ],
    "call_sqls": [
      "SELECT get_policy_dates(119) FROM DUAL",
      "SELECT get_policy_dates(141) FROM DUAL",
      "SELECT get_policy_dates(143) FROM DUAL",
      "SELECT get_policy_dates(744) FROM DUAL",
      "SELECT get_policy_dates(552) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_policy_dates` that accepts a policy ID number and returns a concatenated string of the policy's start and end dates from the CUSTOMER_POLICIES table in the format 'START_DATE to END_DATE'. If the policy is not found, return the string 'No Dates'.",
    "natural_language": "Write a PL/SQL function called `get_policy_dates` that takes a policy ID as input and returns a string combining the start and end dates from the CUSTOMER_POLICIES table in the format 'START_DATE to END_DATE'. If no policy is found, output 'No Dates'.",
    "id": 161
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_events_count` that is designed to return a single numeric value representing the total number of records present in the `EVENTS` table. This function does not accept any input parameters. Internally, it declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement to count all rows in the `EVENTS` table. Specifically, it uses the `COUNT(*)` aggregate function to determine the total number of rows, and the result of this count is then stored into the `v_count` variable. Following this, the function returns the value currently held by `v_count` as its output. The function also includes an exception handling block. If any runtime error occurs during the execution of the `SELECT` statement or any other part of the `BEGIN...END` block, the `WHEN OTHERS THEN` clause will catch the exception, and in such an event, the function will return the numeric value `0` instead of the actual count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_events_count\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM EVENTS;\n    RETURN v_count;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN 0;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_total_events_count FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_total_events_count` with no parameters that returns the total number of records in the EVENTS table. If any error occurs, return 0.",
    "natural_language": "Develop a PL/SQL function, which should be named `get_total_events_count`, that accepts no input parameters and is designed to return the total count of all records currently stored within the EVENTS table. In the event that any error or exception is encountered during its execution, the function must gracefully handle this and return a value of zero.",
    "id": 162
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_max_service_id that takes no input parameters and returns a single NUMBER data type value, which begins by declaring a local variable v_max_service_id of type NUMBER, then executes a SELECT statement that retrieves the maximum value from the SERVICE_ID column of the SERVICES table and stores that result directly into the local variable v_max_service_id, and finally concludes by using a RETURN statement to output the value contained in the v_max_service_id variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_service_id\nRETURN NUMBER\nIS\n    v_max_service_id NUMBER;\nBEGIN\n    SELECT MAX(SERVICE_ID) INTO v_max_service_id FROM SERVICES;\n    RETURN v_max_service_id;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_max_service_id FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_max_service_id` with no parameters that returns the maximum SERVICE_ID value from the SERVICES table.",
    "natural_language": "Develop a PL/SQL function, which should be named `get_max_service_id`, that accepts no input parameters and is designed to meticulously retrieve and return the single highest, or maximum, SERVICE_ID value currently stored within the comprehensive SERVICES table.",
    "id": 163
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_participant_count_in_events that takes no input parameters and returns a single numeric value of type NUMBER. The function declares a local variable v_count of type NUMBER to hold the result. The function's logic executes a SELECT statement that queries the PARTICIPANTS_IN_EVENTS table, specifically performing a COUNT operation on the distinct values found in the PARTICIPANT_ID column. The result of this count, which represents the total number of unique participant identifiers present in the table, is retrieved and stored into the local variable v_count using an INTO clause. The function then returns the value stored in v_count. The function includes an EXCEPTION handler that catches any exception raised during execution under the WHEN OTHERS condition; if any exception occurs, the handler executes a RETURN statement that returns a NULL value instead of the count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_participant_count_in_events\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT PARTICIPANT_ID)\n    INTO v_count\n    FROM PARTICIPANTS_IN_EVENTS;\n    \n    RETURN v_count;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN NULL;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_participant_count_in_events FROM DUAL",
      "SELECT get_participant_count_in_events() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_participant_count_in_events;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Participant Count: ' || get_participant_count_in_events);\nEND;",
      "SELECT EVENT_ID, get_participant_count_in_events AS TOTAL_UNIQUE_PARTICIPANTS FROM EVENTS WHERE ROWNUM <= 1"
    ],
    "summary": "Create a PL/SQL function named get_participant_count_in_events with no parameters that returns a NUMBER. It should count the distinct PARTICIPANT_ID values from the PARTICIPANTS_IN_EVENTS table. Handle any exception by returning NULL.",
    "natural_language": "How can I create a PL/SQL function called get_participant_count_in_events that takes no parameters and returns a NUMBER, which counts the distinct PARTICIPANT_ID values from the PARTICIPANTS_IN_EVENTS table while handling any exception by returning NULL?",
    "id": 164
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_average_participants_per_event` that is designed to calculate and return the average number of participants across all events. This function does not accept any input parameters. It declares a local variable named `v_avg_participants` of type `NUMBER` to temporarily store the calculated average. The core operation involves a `SELECT` statement that calculates the average. This `SELECT` statement operates on a subquery. The subquery first selects the `COUNT` of `PARTICIPANT_ID` from the `PARTICIPANTS_IN_EVENTS` table, aliasing this count as `participant_count`. This count is performed for each distinct `EVENT_ID` by using a `GROUP BY EVENT_ID` clause. The outer `SELECT` statement then calculates the `AVG` (average) of these `participant_count` values, which represent the total number of participants for each event. The result of this average calculation is then stored into the `v_avg_participants` variable. Finally, the function returns the value stored in `v_avg_participants`, which represents the overall average number of participants per event.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_participants_per_event\nRETURN NUMBER\nIS\n    v_avg_participants NUMBER;\nBEGIN\n    SELECT AVG(participant_count)\n    INTO v_avg_participants\n    FROM (SELECT COUNT(PARTICIPANT_ID) as participant_count FROM PARTICIPANTS_IN_EVENTS GROUP BY EVENT_ID);\n\n    RETURN v_avg_participants;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_average_participants_per_event FROM DUAL",
      "SELECT get_average_participants_per_event() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_average_participants_per_event;\n  DBMS_OUTPUT.PUT_LINE('Average: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average participants: ' || get_average_participants_per_event);\nEND;",
      "SELECT EVENT_ID, (SELECT get_average_participants_per_event FROM DUAL) AS AVG_PARTICIPANTS FROM EVENTS WHERE ROWNUM <= 3"
    ],
    "summary": "Create a PL/SQL function named get_average_participants_per_event with no parameters that returns a NUMBER. It should calculate the average number of participants per event by first counting participants per EVENT_ID in the PARTICIPANTS_IN_EVENTS table, then averaging those counts.",
    "natural_language": "Write a function get_average_participants_per_event returning NUMBER. Average the participant counts per EVENT_ID from PARTICIPANTS_IN_EVENTS.",
    "id": 165
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_services_with_events_count that takes no input parameters and returns a single numeric value of type NUMBER, which is the count of distinct service identifiers that have at least one associated event record, by performing a query that joins the SERVICES table (aliased as 's') and the EVENTS table (aliased as 'e') using an inner join condition where the SERVICE_ID column from the SERVICES table matches the SERVICE_ID column in the EVENTS table, then calculates the count of distinct values from the s.SERVICE_ID column from the result set of that join, stores this computed count into a local variable named v_service_count of type NUMBER, and finally returns the value stored in that v_service_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_services_with_events_count\nRETURN NUMBER\nIS\n    v_service_count NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT s.SERVICE_ID)\n    INTO v_service_count\n    FROM SERVICES s\n    INNER JOIN EVENTS e ON s.SERVICE_ID = e.SERVICE_ID;\n\n    RETURN v_service_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_services_with_events_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_services_with_events_count with no parameters that returns a NUMBER. It should count the distinct SERVICE_ID values from the SERVICES table that have at least one matching record in the EVENTS table via an inner join on SERVICE_ID.",
    "natural_language": "Count the distinct services that have associated events. Write a PL/SQL function called get_services_with_events_count with no parameters to return this total as a NUMBER.",
    "id": 166
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_manufacturer_status that accepts a single input parameter p_code of type NUMBER, which represents the code of a manufacturer. The function retrieves the REVENUE value from the MANUFACTURERS table for the row where the CODE column matches the provided p_code. It stores this REVENUE value in a local variable v_revenue of type NUMBER. The function then evaluates the value of v_revenue using a conditional statement. If v_revenue is greater than 100, the function returns the string 'Premium'. If v_revenue is less than or equal to 100, it returns the string 'Standard'. If none of these conditions are met, which is theoretically impossible given the conditions, it returns 'Unknown'. The function is designed to categorize manufacturers based on their revenue into 'Premium' or 'Standard' status.",
    "plsql": "CREATE OR REPLACE FUNCTION check_manufacturer_status(p_code NUMBER) RETURN VARCHAR2 IS\n  v_revenue NUMBER;\nBEGIN\n  SELECT REVENUE INTO v_revenue FROM MANUFACTURERS WHERE CODE = p_code;\n  \n  IF v_revenue > 100 THEN\n    RETURN 'Premium';\n  ELSIF v_revenue <= 100 THEN\n    RETURN 'Standard';\n  ELSE\n    RETURN 'Unknown';\n  END IF;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT check_manufacturer_status(1) FROM DUAL",
      "SELECT check_manufacturer_status(2) FROM DUAL",
      "SELECT check_manufacturer_status(3) FROM DUAL",
      "SELECT check_manufacturer_status(4) FROM DUAL",
      "SELECT check_manufacturer_status(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_manufacturer_status that accepts a NUMBER parameter p_code. It should retrieve the REVENUE from the MANUFACTURERS table for the matching CODE. Return 'Premium' if revenue > 100, 'Standard' if <= 100, otherwise 'Unknown'.",
    "natural_language": "Develop a PL/SQL function, which should be named check_manufacturer_status, that is designed to accept a single numeric parameter identified as p_code. This function must query the MANUFACTURERS table to carefully extract the REVENUE value specifically associated with the provided CODE. Subsequently, it should return the descriptive label 'Premium' in cases where the retrieved revenue definitively exceeds 100, the label 'Standard' if the revenue is determined to be less than or equal to 100, and finally, the label 'Unknown' for any other scenario.",
    "id": 167
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_category that accepts a single parameter p_code of type NUMBER, which represents the product code. The function retrieves the price of the product from the PRODUCTS table by selecting the PRICE column where the CODE column matches the provided p_code. The retrieved price is stored in a local variable v_price, which is defined with the same data type as the PRICE column in the PRODUCTS table. The function then evaluates the value of v_price using conditional logic: if v_price is not null and is greater than or equal to 200, the function returns the string 'Luxury'; if v_price is not null and is less than 200, it returns 'Budget'. If v_price is null or the product is not found, the function returns 'Unknown'. The function includes exception handling to manage cases where no data is found for the given p_code, returning 'Unknown' in such scenarios, and re-raises any other unexpected errors using the OTHERS exception handler.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_category(p_code NUMBER) RETURN VARCHAR2 IS\n  v_price PRODUCTS.PRICE%TYPE;\nBEGIN\n  SELECT PRICE INTO v_price FROM PRODUCTS WHERE CODE = p_code;\n\n  IF v_price IS NOT NULL AND v_price >= 200 THEN\n    RETURN 'Luxury';\n  ELSIF v_price IS NOT NULL AND v_price < 200 THEN\n    RETURN 'Budget';\n  ELSE\n    RETURN 'Unknown'; -- Handle cases where price is NULL or product not found\n  END IF;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 'Unknown'; -- Handle case where p_code does not exist\n  WHEN OTHERS THEN\n    RAISE; -- Re-raise any other unexpected errors\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_category(1) FROM DUAL",
      "SELECT get_product_category(2) FROM DUAL",
      "SELECT get_product_category(3) FROM DUAL",
      "SELECT get_product_category(100) FROM DUAL",
      "SELECT p.code, p.name, get_product_category(p.code) AS category FROM products p WHERE p.code IN (1,2,3)"
    ],
    "summary": "Create a PL/SQL function named get_product_category that accepts a NUMBER parameter p_code. It should retrieve the PRICE from the PRODUCTS table for the matching CODE. Return 'Luxury' if price >= 200, 'Budget' if price < 200 and not null, otherwise 'Unknown'. Handle NO_DATA_FOUND by returning 'Unknown' and re-raise other exceptions.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_product_category? It needs to take in a number parameter, let's call it p_code. Basically, it should go grab the PRICE from the PRODUCTS table where the CODE matches. If the price is 200 or more, spit back 'Luxury'. If it's less than 200 and not empty, say 'Budget'. Otherwise, just return 'Unknown'. Oh, and if it can't find the data, just give back 'Unknown', but if any other weird errors pop up, let those bubble up.",
    "id": 168
  },
  {
    "ir": "Write an Oracle PL/SQL function named evaluate_company_size that accepts a single parameter p_code of type NUMBER, which represents the code of a manufacturer. The function retrieves the REVENUE value from the MANUFACTURERS table where the CODE column matches the provided p_code parameter. It stores the retrieved REVENUE value in a local variable v_revenue of type NUMBER. The function then evaluates the size of the company based on the value of v_revenue using conditional logic: if v_revenue is greater than 75, the function returns the string 'Large'; if v_revenue is less than or equal to 75, it returns 'Small'. An additional condition is included to return 'Unknown', although this condition is not strictly necessary given the existing logic. The function includes exception handling to manage cases where no data is found for the given p_code, returning NULL in such instances, and re-raises any other unexpected errors using the OTHERS exception handler.",
    "plsql": "CREATE OR REPLACE FUNCTION evaluate_company_size(p_code NUMBER) RETURN VARCHAR2 IS\n  v_revenue NUMBER;\nBEGIN\n  SELECT REVENUE INTO v_revenue FROM MANUFACTURERS WHERE CODE = p_code;\n\n  IF v_revenue > 75 THEN\n    RETURN 'Large';\n  ELSIF v_revenue <= 75 THEN\n    RETURN 'Small';\n  ELSE\n    RETURN 'Unknown'; -- Added for completeness, though not strictly required by original logic\n  END IF;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL; -- Handle cases where p_code does not exist\n  WHEN OTHERS THEN\n    RAISE; -- Re-raise any other unexpected errors\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT evaluate_company_size(1) FROM DUAL",
      "SELECT evaluate_company_size(2) FROM DUAL",
      "SELECT evaluate_company_size(3) FROM DUAL",
      "SELECT evaluate_company_size(999) FROM DUAL",
      "SELECT evaluate_company_size(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named evaluate_company_size that takes a manufacturer code as input, retrieves its revenue from the MANUFACTURERS table, and returns 'Large' if revenue > 75, 'Small' if <= 75, or NULL if no data is found.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be named evaluate_company_size, which accepts a specific manufacturer code as its input parameter. This function should then proceed to meticulously retrieve the associated revenue figure from the detailed records held within the MANUFACTURERS table. Based on this retrieved value, it must thoughtfully return a descriptive classification: specifically, it should return the string 'Large' if the revenue is determined to be strictly greater than 75, or the string 'Small' if the revenue is found to be less than or equal to 75. Furthermore, the function must gracefully handle cases where no corresponding data is located for the provided code, in which instance it should deliberately return a NULL value.",
    "id": 169
  },
  {
    "ir": "Write an Oracle PL/SQL function named classify_product_price that accepts a single parameter p_code of type NUMBER, which represents the code of a product. The function retrieves the price of the product from the PRODUCTS table by selecting the PRICE column where the CODE column matches the provided p_code parameter. The retrieved price is stored in a local variable v_price of type NUMBER. The function then evaluates the value of v_price using a conditional statement: if v_price is greater than 150, the function returns the string 'High'; otherwise, if v_price is less than or equal to 150, the function returns the string 'Low'.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_product_price(p_code NUMBER) RETURN VARCHAR2 IS\n  v_price NUMBER;\nBEGIN\n  SELECT PRICE INTO v_price FROM PRODUCTS WHERE CODE = p_code;\n  \n  IF v_price > 150 THEN\n    RETURN 'High';\n  ELSIF v_price <= 150 THEN\n    RETURN 'Low';\n  END IF;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT classify_product_price(1) FROM dual",
      "SELECT classify_product_price(2) FROM dual",
      "SELECT classify_product_price(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named classify_product_price that takes a product code as input, retrieves its price from the PRODUCTS table, and returns 'High' if price > 150, otherwise returns 'Low'.",
    "natural_language": "Write a function classify_product_price that, given a product code, fetches its price from PRODUCTS and returns 'High' if price exceeds 150, else 'Low'.",
    "id": 170
  },
  {
    "ir": "Write an Oracle PL/SQL function named determine_revenue_tier that accepts a single parameter p_code of type NUMBER, which represents the code of a manufacturer. The function retrieves the REVENUE value from the MANUFACTURERS table where the CODE column matches the provided p_code parameter. The retrieved REVENUE value is stored in a local variable v_revenue of type NUMBER. The function then evaluates the value of v_revenue using conditional logic: if v_revenue is greater than or equal to 120, the function returns the string 'Top'; if v_revenue is less than 120, it returns the string 'Base'. Additionally, there is a provision to return 'Unknown' for cases where the revenue might be NULL or any other unexpected value, although this condition is not explicitly handled in the code. The function includes an exception handling block to manage scenarios where no data is found for the given manufacturer code, returning 'N/A' in such cases.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_revenue_tier(p_code NUMBER) RETURN VARCHAR2 IS\n  v_revenue NUMBER;\nBEGIN\n  SELECT REVENUE INTO v_revenue FROM MANUFACTURERS WHERE CODE = p_code;\n\n  IF v_revenue >= 120 THEN\n    RETURN 'Top';\n  ELSIF v_revenue < 120 THEN\n    RETURN 'Base';\n  ELSE\n    RETURN 'Unknown'; -- Handle cases where revenue might be NULL or other unexpected values\n  END IF;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 'N/A'; -- Handle case where no manufacturer is found for the given code\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT determine_revenue_tier(1) FROM DUAL",
      "SELECT determine_revenue_tier(2) FROM DUAL",
      "SELECT determine_revenue_tier(3) FROM DUAL",
      "SELECT determine_revenue_tier(999) FROM DUAL",
      "SELECT determine_revenue_tier( (SELECT CODE FROM MANUFACTURERS WHERE REVENUE = 120 AND ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named determine_revenue_tier that takes a manufacturer code as input, retrieves its revenue from the MANUFACTURERS table, and returns 'Top' if revenue >= 120, 'Base' if < 120, or 'N/A' if no data is found.",
    "natural_language": "What revenue tier—'Top', 'Base', or 'N/A'—should be assigned to a given manufacturer code based on its revenue from the MANUFACTURERS table?",
    "id": 171
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_movie_rating_status that accepts a single input parameter p_mid of the NUMBER data type, which represents a movie identifier, and returns a VARCHAR2 string. The function begins by declaring a local variable v_avg_stars of type NUMBER. It executes a SELECT statement that calculates the average value of the stars column from the rating table, specifically for all rows where the mid column equals the input parameter p_mid, and stores this computed average into the variable v_avg_stars. Following this query, the function uses an IF-ELSIF-ELSE conditional block to determine the return value: if the v_avg_stars variable is NULL, indicating no matching rows were found in the rating table for the given p_mid, the function returns the string 'No Ratings'; otherwise, if the v_avg_stars value is greater than or equal to 4, the function returns the string 'Highly Rated'; in all other cases where v_avg_stars is not NULL and is less than 4, the function returns the string 'Moderately Rated'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_rating_status(p_mid IN NUMBER) RETURN VARCHAR2 IS\n    v_avg_stars NUMBER;\nBEGIN\n    SELECT AVG(stars) INTO v_avg_stars FROM rating WHERE mid = p_mid;\n    IF v_avg_stars IS NULL THEN\n        RETURN 'No Ratings';\n    ELSIF v_avg_stars >= 4 THEN\n        RETURN 'Highly Rated';\n    ELSE\n        RETURN 'Moderately Rated';\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_rating_status(101) FROM dual",
      "SELECT get_movie_rating_status(102) FROM dual",
      "SELECT get_movie_rating_status(103) FROM dual",
      "SELECT get_movie_rating_status(106) FROM dual",
      "SELECT get_movie_rating_status(104) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_movie_rating_status that takes a movie ID as input, calculates the average stars from the RATING table, and returns 'Highly Rated' if average >= 4, 'Moderately Rated' if average < 4 and not null, or 'No Ratings' if no ratings exist.",
    "natural_language": "Write a PL/SQL function called get_movie_rating_status. It should accept a movie ID and figure out the typical star score from the RATING table. Based on that, it needs to return something like 'Highly Rated' if the typical score is pretty high, maybe around 4 or more. If the score is lower than that but there is some data, then return 'Moderately Rated'. If there aren't really any ratings to speak of, then just return 'No Ratings'.",
    "id": 172
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_reviewer_existence that accepts a single input parameter p_rid of type NUMBER, which represents a reviewer identifier, and returns a VARCHAR2 string. The function begins by declaring a local variable v_count of type NUMBER. It then executes a SELECT statement that queries the reviewer table, using the COUNT(*) aggregate function to count the number of rows where the rid column value is exactly equal to the input parameter p_rid, and stores the resulting count into the variable v_count. Following this query, the function uses an IF-THEN-ELSE conditional statement to evaluate the value of v_count: if v_count equals 0, indicating no matching reviewer record was found, the function returns the literal string 'Reviewer Not Found'; otherwise, if v_count is greater than 0, the function returns the literal string 'Reviewer Exists'.",
    "plsql": "CREATE OR REPLACE FUNCTION check_reviewer_existence(p_rid IN NUMBER) RETURN VARCHAR2 IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM reviewer WHERE rid = p_rid;\n    IF v_count = 0 THEN\n        RETURN 'Reviewer Not Found';\n    ELSE\n        RETURN 'Reviewer Exists';\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT check_reviewer_existence(201) FROM dual",
      "SELECT check_reviewer_existence(202) FROM dual",
      "SELECT check_reviewer_existence(203) FROM dual",
      "SELECT check_reviewer_existence(204) FROM dual",
      "SELECT check_reviewer_existence(205) FROM dual"
    ],
    "summary": "Create a PL/SQL function named check_reviewer_existence that takes a reviewer ID as input, checks for its existence in the REVIEWER table, and returns 'Reviewer Exists' if found, otherwise 'Reviewer Not Found'.",
    "natural_language": "Please construct a PL/SQL function designated as 'check_reviewer_existence'. This function should accept a reviewer ID as its input parameter. It must verify the presence of this identifier within the REVIEWER table. The function is to return the string 'Reviewer Exists' if the ID is located; conversely, it should return the string 'Reviewer Not Found' if the ID does not exist in the specified table.",
    "id": 173
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_movie_director_status that accepts a single input parameter p_mid of type NUMBER, which represents the movie ID. The function retrieves the director's name from the movie table by selecting the director column where the mid column matches the input parameter p_mid. The result of this selection is stored in a local variable v_director of type VARCHAR2 with a maximum length of 255 characters. The function then evaluates the value of v_director using a series of conditional statements. If v_director is NULL, indicating that no director is associated with the given movie ID, the function returns the string 'Director Unknown'. If v_director is equal to 'George Lucas', the function returns the string 'Famous Director'. For any other non-null value of v_director, the function returns the string 'Director Known'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_director_status(p_mid IN NUMBER) RETURN VARCHAR2 IS\n    v_director VARCHAR2(255);\nBEGIN\n    SELECT director INTO v_director FROM movie WHERE mid = p_mid;\n    IF v_director IS NULL THEN\n        RETURN 'Director Unknown';\n    ELSIF v_director = 'George Lucas' THEN\n        RETURN 'Famous Director';\n    ELSE\n        RETURN 'Director Known';\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_director_status(101) FROM DUAL",
      "SELECT get_movie_director_status(102) FROM DUAL",
      "SELECT get_movie_director_status(103) FROM DUAL",
      "SELECT get_movie_director_status(999) FROM DUAL",
      "SELECT get_movie_director_status(100) FROM DUAL"
    ],
    "summary": "Create a function named get_movie_director_status that accepts a movie ID number and returns a status string. It retrieves the director's name for that ID. If the director is NULL, return 'Director Unknown'. If the director is 'George Lucas', return 'Famous Director'. For any other director, return 'Director Known'.",
    "natural_language": "Construct a function, to be named get_movie_director_status, which is designed to receive a specific movie ID number as its input parameter. This function will then proceed to fetch the full name of the director associated with that particular identifier. Should the director's name field be found to be empty or NULL, the function must thoughtfully return the status string 'Director Unknown'. In the distinct and notable case where the retrieved director is precisely the renowned 'George Lucas', the function should appropriately yield the status 'Famous Director'. For all other directors, whose names are successfully retrieved and are not the aforementioned individual, the function will reliably return the status 'Director Known'.",
    "id": 174
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_reviewer_rating_status` that accepts a single input parameter, `p_rid`, which is of data type `NUMBER` and represents a reviewer's unique identifier. This function is designed to return a `VARCHAR2` data type, indicating the rating status of the reviewer associated with the provided `p_rid`. Internally, the function declares a local variable `v_avg_stars` of data type `NUMBER` to temporarily store the calculated average star rating. The function's execution begins by performing a `SELECT` operation to calculate the average value of the `stars` column from the `rating` table. This aggregation is specifically filtered by a `WHERE` clause, ensuring that only rows where the `rid` column matches the input parameter `p_rid` are considered for the average calculation. The result of this average calculation is then stored into the `v_avg_stars` local variable. Following this data retrieval, the function proceeds with a series of conditional checks. The first condition evaluates whether `v_avg_stars` is `NULL`. If `v_avg_stars` is indeed `NULL`, which would occur if no ratings exist for the given `p_rid` in the `rating` table, the function immediately returns the string literal 'No Ratings'. If `v_avg_stars` is not `NULL`, the function proceeds to the next condition. This condition checks if the value of `v_avg_stars` is greater than or equal to `3`. If this condition is true, indicating a generally positive rating, the function returns the string literal 'Positive Reviewer'. If neither of the preceding conditions is met, meaning `v_avg_stars` is not `NULL` and is less than `3`, the function executes the `ELSE` block and returns the string literal 'Critical Reviewer'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_reviewer_rating_status(p_rid IN NUMBER) RETURN VARCHAR2 IS\n    v_avg_stars NUMBER;\nBEGIN\n    SELECT AVG(stars) INTO v_avg_stars FROM rating WHERE rid = p_rid;\n    IF v_avg_stars IS NULL THEN\n        RETURN 'No Ratings';\n    ELSIF v_avg_stars >= 3 THEN\n        RETURN 'Positive Reviewer';\n    ELSE\n        RETURN 'Critical Reviewer';\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_reviewer_rating_status(201) FROM DUAL",
      "SELECT get_reviewer_rating_status(202) FROM DUAL",
      "SELECT get_reviewer_rating_status(203) FROM DUAL",
      "SELECT get_reviewer_rating_status(999) FROM DUAL",
      "SELECT get_reviewer_rating_status( (SELECT MIN(RID) FROM REVIEWER) ) FROM DUAL"
    ],
    "summary": "Create a function named get_reviewer_rating_status that accepts a reviewer ID number and returns a status string. It calculates the average star rating for that reviewer. If there are no ratings (NULL), return 'No Ratings'. If the average is 3 or higher, return 'Positive Reviewer'. Otherwise, return 'Critical Reviewer'.",
    "natural_language": "Alright, so we need a function called get_reviewer_rating_status. You'll feed it a reviewer's ID number, and it'll spit back a status. Here's what it does: it figures out the average star rating for that reviewer. If the reviewer doesn't have any ratings at all, just say 'No Ratings'. If their average is a 3 or above, they're a 'Positive Reviewer'. If it's lower than that, well, they're a 'Critical Reviewer'.",
    "id": 175
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_oldest_actor_age` that is designed to return a single numerical value representing the maximum age found within the `ACTOR` table. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_age` of data type `NUMBER` to temporarily store the result of its primary operation. The core operation involves executing a `SELECT` statement. This `SELECT` statement queries the `ACTOR` table and calculates the maximum value present in the `AGE` column across all rows in the `ACTOR` table. The result of this `MAX(AGE)` aggregation is then immediately assigned to the local variable `v_age`. Finally, the function returns the numerical value currently stored in the `v_age` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_actor_age RETURN NUMBER IS\n  v_age NUMBER;\nBEGIN\n  SELECT MAX(AGE) INTO v_age FROM ACTOR;\n  RETURN v_age;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT get_oldest_actor_age FROM DUAL"
    ],
    "summary": "Create a function named get_oldest_actor_age with no parameters that returns a number. It finds and returns the maximum age from the ACTOR table.",
    "natural_language": "Create a function called get_oldest_actor_age that doesn't need any inputs and gives back a number. It should figure out and return the highest age you can find in the ACTOR table.",
    "id": 176
  },
  {
    "ir": "Write an Oracle PL/SQL function that, when called, returns a numerical value representing the total count of rows in the MUSICAL table where the RESULT column has the value 'Nominated'. The function does not take any input parameters. It declares a local variable v_count of type NUMBER to store the result of the query. Within the function's execution block, a SELECT statement is executed to count all rows in the MUSICAL table that meet the condition of having 'Nominated' as the value in the RESULT column. The COUNT(*) function is used to determine the number of such rows, and the result is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the total number of nominations found in the MUSICAL table.",
    "plsql": "CREATE OR REPLACE FUNCTION count_musical_nominations RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM MUSICAL WHERE RESULT = 'Nominated';\n  RETURN v_count;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT count_musical_nominations FROM DUAL",
      "SELECT count_musical_nominations() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Nominations: ' || count_musical_nominations);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := count_musical_nominations;\nEND;",
      "SELECT count_musical_nominations AS nomination_count FROM DUAL"
    ],
    "summary": "Create a function with no parameters that returns a number. It counts and returns the total number of rows in the MUSICAL table where the RESULT column equals 'Nominated'.",
    "natural_language": "Make a function that gives back a count, roughly the number of entries in the MUSICAL table where the RESULT is something like 'Nominated'.",
    "id": 177
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_next_musical_year that returns a NUMBER. This function does not take any input parameters. Within the function, declare a local variable v_next_year of type NUMBER to store the result. The function executes a SQL SELECT statement that retrieves the next sequential YEAR value from the MUSICAL table. It uses the LEAD analytic function to obtain the YEAR value that follows the current row when ordered by the YEAR column. The LEAD function is applied with an offset of 1, meaning it looks one row ahead in the ordered result set. The ORDER BY clause ensures that the rows are sorted by the YEAR column in ascending order. The ROWNUM = 1 condition limits the result set to the first row only, effectively selecting the first YEAR value in the ordered sequence. The selected YEAR value is stored into the v_next_year variable. Finally, the function returns the value of v_next_year, which represents the next musical year in the sequence.",
    "plsql": "CREATE OR REPLACE FUNCTION get_next_musical_year RETURN NUMBER IS\n  v_next_year NUMBER;\nBEGIN\n  SELECT LEAD(YEAR, 1) OVER (ORDER BY YEAR) INTO v_next_year FROM MUSICAL WHERE ROWNUM = 1;\n  RETURN v_next_year;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT get_next_musical_year FROM dual"
    ],
    "summary": "Create a function named get_next_musical_year with no parameters that returns a number. It retrieves the next year in sequence from the MUSICAL table by using the LEAD function on the YEAR column, ordered ascending, and returns that value.",
    "natural_language": "Please construct a function designated as 'get_next_musical_year', which accepts no parameters and yields a numeric output. The function's logic should employ the LEAD analytical function on the YEAR column of the MUSICAL table, with rows ordered in ascending sequence, to ascertain and return the subsequent chronological year.",
    "id": 178
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_actor_lead_age_diff` that is designed to return a single numeric value. This function does not accept any input parameters. Internally, it declares a local variable named `v_diff` of data type `NUMBER` to temporarily store the calculated difference. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `ACTOR` table. Within this `SELECT` statement, it calculates the difference between the `AGE` of a specific actor and the `AGE` of the subsequent actor based on a defined ordering. Specifically, it uses the `LEAD` analytic function. The `LEAD` function is configured to look ahead by `1` row (indicated by `LEAD(AGE, 1)`), meaning it retrieves the `AGE` value from the next row. The ordering for this analytic function is determined by the `ACTOR_ID` column in ascending order (`OVER (ORDER BY ACTOR_ID)`). The `AGE` column from the current row is then subtracted from the `AGE` value obtained by the `LEAD` function. This calculated difference is then stored into the `v_diff` variable. A crucial condition applied to this `SELECT` statement is `WHERE ROWNUM = 1`. This condition restricts the query to process only the first row returned by the underlying query before any analytic functions are applied, effectively calculating the age difference between the first actor and the second actor when ordered by `ACTOR_ID`. Finally, the function returns the value stored in the `v_diff` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_lead_age_diff RETURN NUMBER IS\n  v_diff NUMBER;\nBEGIN\n  SELECT LEAD(AGE, 1) OVER (ORDER BY ACTOR_ID) - AGE INTO v_diff FROM ACTOR WHERE ROWNUM = 1;\n  RETURN v_diff;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT get_actor_lead_age_diff FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_actor_lead_age_diff with no parameters that returns a NUMBER. It calculates and returns the age difference between the first and second actor when ordered by ACTOR_ID, using the LEAD analytic function.",
    "natural_language": "Write a PL/SQL function get_actor_lead_age_diff returning NUMBER. Use LEAD to find the age difference between consecutive actors by ACTOR_ID.",
    "id": 179
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_friendship_status` that accepts two input parameters: `p_student_id`, a `NUMBER` type representing the ID of the primary student, and `p_target_id`, a `NUMBER` type representing the ID of the target individual whose relationship with the primary student is to be determined. This function is designed to return a `VARCHAR2` string of up to 20 characters, indicating the nature of the relationship between the two provided IDs.\n\nUpon execution, the function first declares two local variables: `v_status`, a `VARCHAR2` variable of size 20 to store the determined relationship status, and `v_count`, a `NUMBER` variable to hold the count of records found in database queries.\n\nThe function then proceeds with a conditional check:\n1. It evaluates if the value of `p_student_id` is equal to the value of `p_target_id`.\n   a. If they are equal, indicating that the primary student and the target individual are the same person, the `v_status` variable is assigned the string literal 'SAME_PERSON'.\n   b. If they are not equal, the function proceeds to further checks to determine the relationship:\n      i. It executes a `SELECT COUNT(*)` statement to count the number of rows in the `FRIEND` table where the `STUDENT_ID` column matches `p_student_id` AND the `FRIEND_ID` column matches `p_target_id`. The result of this count is stored in the `v_count` variable.\n      ii. It then checks if the value of `v_count` is greater than 0.\n          1. If `v_count` is greater than 0, meaning a direct friendship record exists, the `v_status` variable is assigned the string literal 'DIRECT_FRIEND'.\n          2. If `v_count` is not greater than 0, indicating no direct friendship, the function performs another check:\n             a. It executes a `SELECT COUNT(*)` statement to count the number of rows in the `LIKES` table where the `STUDENT_ID` column matches `p_student_id` AND the `LIKED_ID` column matches `p_target_id`. The result of this count is again stored in the `v_count` variable.\n             b. It then checks if the value of `v_count` is greater than 0.\n                i. If `v_count` is greater than 0, meaning the primary student likes the target individual, the `v_status` variable is assigned the string literal 'LIKES_TARGET'.\n                ii. If `v_count` is not greater than 0, indicating no direct friendship and no 'likes' relationship, the `v_status` variable is assigned the string literal 'NO_RELATION'.\n\nFinally, after all conditional checks, the function returns the final value stored in the `v_status` variable.\n\nThe function also includes an exception handling block:\n1. If any unhandled exception occurs during the execution of the function (caught by `WHEN OTHERS`), the function will immediately return the string literal 'ERROR'.",
    "plsql": "CREATE OR REPLACE FUNCTION check_friendship_status(p_student_id NUMBER, p_target_id NUMBER) RETURN VARCHAR2 IS\n  v_status VARCHAR2(20);\n  v_count NUMBER;\nBEGIN\n  IF p_student_id = p_target_id THEN\n    v_status := 'SAME_PERSON';\n  ELSE\n    SELECT COUNT(*) INTO v_count FROM FRIEND WHERE STUDENT_ID = p_student_id AND FRIEND_ID = p_target_id;\n    IF v_count > 0 THEN\n      v_status := 'DIRECT_FRIEND';\n    ELSE\n      SELECT COUNT(*) INTO v_count FROM LIKES WHERE STUDENT_ID = p_student_id AND LIKED_ID = p_target_id;\n      IF v_count > 0 THEN\n        v_status := 'LIKES_TARGET';\n      ELSE\n        v_status := 'NO_RELATION';\n      END IF;\n    END IF;\n  END IF;\n  RETURN v_status;\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN 'ERROR';\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT check_friendship_status(1101, 1641) FROM dual",
      "SELECT check_friendship_status(1247, 1501) FROM dual",
      "SELECT check_friendship_status(1101, 1911) FROM dual",
      "SELECT check_friendship_status(1247, 1468) FROM dual",
      "SELECT check_friendship_status(1025, 1304) FROM dual"
    ],
    "summary": "Create a PL/SQL function named check_friendship_status that takes two NUMBER parameters (p_student_id, p_target_id) and returns a VARCHAR2(20). It returns 'SAME_PERSON' if the IDs are equal, 'DIRECT_FRIEND' if a record exists in the FRIEND table, 'LIKES_TARGET' if a record exists in the LIKES table, or 'NO_RELATION' otherwise. Handle any exception by returning 'ERROR'.",
    "natural_language": "Write a PL/SQL function check_friendship_status(p_student_id NUMBER, p_target_id NUMBER) returning VARCHAR2(20). Logic: return 'SAME_PERSON' for equal IDs, 'DIRECT_FRIEND' if in FRIEND table, 'LIKES_TARGET' if in LIKES table, else 'NO_RELATION'. On exception, return 'ERROR'.",
    "id": 180
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_grade_friend_count that accepts a single parameter p_grade of type NUMBER, which represents a specific grade level. The function returns a NUMBER that indicates the count of friends associated with high school students in the specified grade. The function begins by declaring a local variable v_count of type NUMBER to store the result of the count operation. The function then evaluates the value of p_grade using a series of conditional statements. If p_grade is less than 9, the function executes a SELECT statement that performs a COUNT operation on the FRIEND table, joining it with the HIGHSCHOOLER table on the condition that the STUDENT_ID column in the FRIEND table matches the ID column in the HIGHSCHOOLER table, and further filters the results where the GRADE column in the HIGHSCHOOLER table equals the value of p_grade. If p_grade equals 9, the function executes a similar SELECT COUNT operation, but with an additional condition that the current system timestamp, obtained using the SYSTIMESTAMP function, is greater than the timestamp '2024-01-01', converted to a timestamp using the TO_TIMESTAMP function with the format 'YYYY-MM-DD'. If p_grade is greater than 9, the function performs the same COUNT operation as in the case where p_grade is less than 9. If none of these conditions are met, the function assigns a value of 0 to v_count. Finally, the function returns the value of v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_grade_friend_count(p_grade NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  IF p_grade < 9 THEN\n    SELECT COUNT(*) INTO v_count FROM FRIEND f JOIN HIGHSCHOOLER h ON f.STUDENT_ID = h.ID WHERE h.GRADE = p_grade;\n  ELSIF p_grade = 9 THEN\n    SELECT COUNT(*) INTO v_count FROM FRIEND f JOIN HIGHSCHOOLER h ON f.STUDENT_ID = h.ID WHERE h.GRADE = p_grade AND SYSTIMESTAMP > TO_TIMESTAMP('2024-01-01', 'YYYY-MM-DD');\n  ELSIF p_grade > 9 THEN\n    SELECT COUNT(*) INTO v_count FROM FRIEND f JOIN HIGHSCHOOLER h ON f.STUDENT_ID = h.ID WHERE h.GRADE = p_grade;\n  ELSE\n    v_count := 0;\n  END IF;\n  RETURN v_count;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT calculate_grade_friend_count(8) FROM DUAL",
      "SELECT calculate_grade_friend_count(9) FROM DUAL",
      "SELECT calculate_grade_friend_count(10) FROM DUAL",
      "SELECT calculate_grade_friend_count(7) FROM DUAL",
      "SELECT calculate_grade_friend_count(11) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_grade_friend_count that accepts a NUMBER parameter p_grade and returns a NUMBER. It returns the count of friends for students in the specified grade from the FRIEND and HIGHSCHOOLER tables. If p_grade is 9, only count friends when the current system timestamp is after '2024-01-01'. If p_grade is not 9, 10, 11, or 12, return 0.",
    "natural_language": "Develop a PL/SQL function called calculate_grade_friend_count, which takes a single NUMBER parameter named p_grade and yields a NUMBER as its result. This function is designed to meticulously compute and deliver the total number of friends belonging to students who are enrolled in the precisely specified grade, by carefully joining the FRIEND and HIGHSCHOOLER tables. Importantly, if the provided p_grade parameter is exactly 9, the function will only include friends in its count under the specific condition that the current system timestamp definitively falls after the precise date of '2024-01-01'. Conversely, if the supplied p_grade value is determined not to be 9, 10, 11, or 12, the function will promptly and directly return a value of 0.",
    "id": 181
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_activity_score that accepts a single input parameter p_id of type NUMBER and returns a NUMBER value. The function calculates a composite activity score for a student based on their social interactions, with the calculation logic dependent on the student's grade level. The function begins by declaring local variables v_score, v_grade, v_friend_count, and v_liked_count, all of type NUMBER. It first queries the HIGHSCHOOLER table, selecting the GRADE column value into v_grade for the row where the ID column equals the input p_id. If the retrieved v_grade is greater than 9, the function performs a query joining the HIGHSCHOOLER table (aliased as h) to the FRIEND table (aliased as f) with a LEFT JOIN on the condition h.ID equals f.STUDENT_ID, and to the LIKES table (aliased as l) with a LEFT JOIN on the condition h.ID equals l.STUDENT_ID, specifically for the row where h.ID equals p_id. From this joined result set, it counts the distinct values of f.FRIEND_ID into v_friend_count and the distinct values of l.LIKED_ID into v_liked_count. The final v_score is then computed as (v_friend_count multiplied by 2) plus v_liked_count. If the retrieved v_grade is equal to 9, the function executes an identical query to obtain v_friend_count and v_liked_count, but computes v_score as the simple sum of v_friend_count and v_liked_count. The function returns the calculated v_score. If the initial SELECT statement raises a NO_DATA_FOUND exception because p_id does not exist in the HIGHSCHOOLER table, the exception handler is invoked. Within the handler, if p_id is greater than 0, it queries the FRIEND table, counting the distinct FRIEND_ID values into v_score for rows where STUDENT_ID equals p_id. If p_id is not greater than 0, it assigns -1 to v_score. The handler then returns this v_score value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_activity_score(p_id NUMBER) RETURN NUMBER IS\n  v_score NUMBER;\n  v_grade NUMBER;\n  v_friend_count NUMBER;\n  v_liked_count NUMBER;\nBEGIN\n  -- Check if the student exists and get their grade\n  SELECT GRADE INTO v_grade FROM HIGHSCHOOLER WHERE ID = p_id;\n\n  IF v_grade > 9 THEN\n    SELECT\n        COUNT(DISTINCT f.FRIEND_ID),\n        COUNT(DISTINCT l.LIKED_ID)\n    INTO\n        v_friend_count,\n        v_liked_count\n    FROM HIGHSCHOOLER h\n    LEFT JOIN FRIEND f ON h.ID = f.STUDENT_ID\n    LEFT JOIN LIKES l ON h.ID = l.STUDENT_ID\n    WHERE h.ID = p_id;\n    v_score := (v_friend_count * 2) + v_liked_count;\n  ELSIF v_grade = 9 THEN\n    SELECT\n        COUNT(DISTINCT f.FRIEND_ID),\n        COUNT(DISTINCT l.LIKED_ID)\n    INTO\n        v_friend_count,\n        v_liked_count\n    FROM HIGHSCHOOLER h\n    LEFT JOIN FRIEND f ON h.ID = f.STUDENT_ID\n    LEFT JOIN LIKES l ON h.ID = l.STUDENT_ID\n    WHERE h.ID = p_id;\n    v_score := v_friend_count + v_liked_count;\n  END IF;\n\n  RETURN v_score;\n\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    -- If p_id is not found in HIGHSCHOOLER, check FRIEND table or assign -1\n    IF p_id > 0 THEN\n      SELECT COUNT(DISTINCT f.FRIEND_ID) INTO v_score FROM FRIEND f WHERE f.STUDENT_ID = p_id;\n    ELSE\n      v_score := -1;\n    END IF;\n    RETURN v_score;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_student_activity_score(1510) FROM DUAL",
      "SELECT get_student_activity_score(1689) FROM DUAL",
      "SELECT get_student_activity_score(1381) FROM DUAL",
      "SELECT get_student_activity_score(1101) FROM DUAL",
      "SELECT get_student_activity_score(9999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_student_activity_score that accepts a NUMBER parameter p_id and returns a NUMBER. For a student in HIGHSCHOOLER, if their grade > 9, calculate score as (friend_count * 2) + liked_count. If grade = 9, calculate score as friend_count + liked_count. If the student ID is not found and p_id > 0, return the count of their distinct friends from the FRIEND table; otherwise, return -1.",
    "natural_language": "Alright, so I need you to whip up a PL/SQL function called get_student_activity_score. It's gotta take in a number for the student's ID and spit back a number too. Here's the deal: if the kid's in HIGHSCHOOLER and they're above 9th grade, figure out their score by doubling their friend count and then adding how many likes they've got. If they're exactly in 9th grade, just add the friend count and liked count together. Now, if you can't find the student at all but the ID passed in is a positive number, then just give me back how many unique pals they have in the FRIEND table. Otherwise, if all else fails, just return -1.",
    "id": 182
  },
  {
    "ir": "Write an Oracle PL/SQL function named verify_friendship_reciprocal that accepts two input parameters, p_id1 and p_id2, both of type NUMBER, representing the IDs of two students. The function aims to determine the nature of the friendship relationship between these two students based on entries in the FRIEND table, which contains columns STUDENT_ID and FRIEND_ID. The function initializes a local variable v_result of type NUMBER to 0, which will store the result to be returned. It also declares two additional local variables, v_count1 and v_count2, both of type NUMBER, to hold the count of specific records in the FRIEND table. The function executes a SELECT COUNT(*) query to count the number of records where STUDENT_ID equals p_id1 and FRIEND_ID equals p_id2, storing the result in v_count1. Similarly, it performs another SELECT COUNT(*) query to count the number of records where STUDENT_ID equals p_id2 and FRIEND_ID equals p_id1, storing the result in v_count2. The function then evaluates a series of conditional statements: if both v_count1 and v_count2 are greater than 0, indicating a reciprocal friendship, it sets v_result to 1; if only v_count1 is greater than 0, indicating a one-way friendship from p_id1 to p_id2, it sets v_result to 2; if only v_count2 is greater than 0, indicating a one-way friendship from p_id2 to p_id1, it sets v_result to 3. Finally, the function returns the value of v_result, which indicates the type of friendship relationship between the two students.",
    "plsql": "CREATE OR REPLACE FUNCTION verify_friendship_reciprocal(p_id1 NUMBER, p_id2 NUMBER) RETURN NUMBER IS\n  v_result NUMBER := 0;\n  v_count1 NUMBER;\n  v_count2 NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count1 FROM FRIEND WHERE STUDENT_ID = p_id1 AND FRIEND_ID = p_id2;\n  SELECT COUNT(*) INTO v_count2 FROM FRIEND WHERE STUDENT_ID = p_id2 AND FRIEND_ID = p_id1;\n\n  IF v_count1 > 0 AND v_count2 > 0 THEN\n    v_result := 1;\n  ELSIF v_count1 > 0 THEN\n    v_result := 2;\n  ELSIF v_count2 > 0 THEN\n    v_result := 3;\n  END IF;\n\n  RETURN v_result;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT verify_friendship_reciprocal(1101, 1641) FROM DUAL",
      "SELECT verify_friendship_reciprocal(1247, 1501) FROM DUAL",
      "SELECT verify_friendship_reciprocal(1101, 1501) FROM DUAL",
      "SELECT verify_friendship_reciprocal(1247, 1911) FROM DUAL",
      "SELECT verify_friendship_reciprocal(1101, 1911) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named verify_friendship_reciprocal that accepts two NUMBER parameters (p_id1, p_id2) and returns a NUMBER. Check the FRIEND table for records between the two IDs. Return 1 if friendship is reciprocal (both directions exist), 2 if only p_id1 is friends with p_id2, 3 if only p_id2 is friends with p_id1, and 0 otherwise.",
    "natural_language": "Write a PL/SQL function called verify_friendship_reciprocal that takes two NUMBER parameters, p_id1 and p_id2, and returns a NUMBER. The function should check the FRIEND table for relationships between these two IDs. Return 1 if the friendship is mutual, 2 if only p_id1 is friends with p_id2, 3 if only p_id2 is friends with p_id1, and 0 if no friendship exists in either direction.",
    "id": 183
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_canadian_architects` that is designed to return a single `VARCHAR2` string. This function does not accept any input parameters. Upon execution, the function declares a local variable named `result` of type `VARCHAR2` with a maximum length of 4000 characters. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `ARCHITECT` table. Specifically, it selects the `NAME` column from rows in the `ARCHITECT` table where the `NATIONALITY` column's value is exactly equal to the string literal 'Canadian'. For all such selected `NAME` values, the `LISTAGG` aggregate function is applied. The `LISTAGG` function concatenates these `NAME` values into a single string, using a comma and a space (`, `) as the delimiter between each name. The order in which these names are concatenated is determined by sorting them in ascending alphabetical order based on their `NAME` column values, as specified by the `WITHIN GROUP (ORDER BY NAME)` clause. The resulting concatenated string from the `LISTAGG` operation is then stored into the `result` local variable. Finally, the function returns the value currently held by the `result` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_canadian_architects RETURN VARCHAR2 IS\n  result VARCHAR2(4000);\nBEGIN\n  SELECT LISTAGG(NAME, ', ') WITHIN GROUP (ORDER BY NAME)\n  INTO result\n  FROM ARCHITECT\n  WHERE NATIONALITY = 'Canadian';\n  RETURN result;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT get_canadian_architects FROM dual"
    ],
    "summary": "Create a function named `get_canadian_architects` with no parameters that returns a VARCHAR2. It should return a comma-and-space-separated list of names from the ARCHITECT table, sorted alphabetically, where the nationality is 'Canadian'.",
    "natural_language": "What is the comma-and-space-separated list of names, sorted alphabetically, for architects who are Canadian?",
    "id": 184
  },
  {
    "ir": "Write an Oracle PL/SQL function named `count_windmills` that does not accept any input parameters. This function is designed to return a single numeric value representing the total count of specific entries within a database table. Upon execution, the function declares a local variable named `mill_count` of data type `NUMBER` to temporarily store the calculated count. The core operation of this function involves performing a `SELECT` statement to query the database. Specifically, it counts all rows (`COUNT(*)`) from the table named `MILL`. This count is then filtered by a `WHERE` clause, which specifies that only rows where the value in the `TYPE` column is exactly equal to the string literal `'Windmill'` (case-sensitive comparison) should be included in the count. The result of this `COUNT(*)` operation is then assigned to the `mill_count` variable using the `INTO` clause. Finally, the function returns the numerical value stored in the `mill_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_windmills RETURN NUMBER IS\n  mill_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO mill_count\n  FROM MILL\n  WHERE TYPE = 'Windmill';\n  RETURN mill_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT count_windmills FROM dual"
    ],
    "summary": "Create a function named `count_windmills` with no parameters that returns a NUMBER. It should return the count of all rows in the MILL table where the type is 'Windmill'.",
    "natural_language": "Create function `count_windmills` returning NUMBER to count MILL rows where type is 'Windmill'.",
    "id": 185
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_longest_bridge that takes no parameters and returns a single VARCHAR2 value, which executes a SELECT statement on the BRIDGE table to retrieve the NAME column value, specifically targeting the row or rows where the LENGTH_METERS column value is equal to the maximum LENGTH_METERS value found across the entire BRIDGE table, as determined by a scalar subquery that calculates the maximum value from the LENGTH_METERS column, and then assigns the resulting NAME value into a local variable named bridge_name of type VARCHAR2(255) and finally returns that variable's value as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_longest_bridge RETURN VARCHAR2 IS\n  bridge_name VARCHAR2(255);\nBEGIN\n  SELECT NAME\n  INTO bridge_name\n  FROM BRIDGE\n  WHERE LENGTH_METERS = (SELECT MAX(LENGTH_METERS) FROM BRIDGE);\n  RETURN bridge_name;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT get_longest_bridge FROM DUAL"
    ],
    "summary": "Create a function named `get_longest_bridge` with no parameters that returns a VARCHAR2. It should return the name of the bridge(s) from the BRIDGE table that have the maximum length in meters.",
    "natural_language": "Define a function called `get_longest_bridge` that accepts no parameters and yields a VARCHAR2 data type. This function shall retrieve and return the name or names of the bridge structure(s) recorded in the BRIDGE table which possess the greatest length measurement in meters.",
    "id": 186
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_architect_mill_count that takes no parameters and returns a single NUMBER value, which is the count of records from the MILL table, where the condition is that the ARCHITECT_ID column value in the MILL table must be present in a derived set of numeric IDs; this derived set is obtained by executing a subquery that selects the ID column from the ARCHITECT table, converts each ID value from its original data type to a NUMBER using the TO_NUMBER function specifically for each row, and filters the ARCHITECT rows to only those where the NATIONALITY column has the exact string value 'Canadian'; the result of the subquery, which is a list of numeric architect IDs, is then used in the main query's IN clause to filter the MILL table, and the final count of matching MILL rows is stored into the local variable mill_count before being returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_architect_mill_count RETURN NUMBER IS\n  mill_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO mill_count\n  FROM MILL\n  WHERE ARCHITECT_ID IN (SELECT TO_NUMBER(ID) FROM ARCHITECT WHERE NATIONALITY = 'Canadian');\n  RETURN mill_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT get_architect_mill_count FROM DUAL",
      "SELECT get_architect_mill_count() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Mill count: ' || get_architect_mill_count);\nEND;",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_architect_mill_count;\nEND;",
      "SELECT get_architect_mill_count AS canadian_architect_mill_count FROM DUAL"
    ],
    "summary": "Create a function named `get_architect_mill_count` with no parameters that returns a NUMBER. It should return the count of mills from the MILL table where the architect's ID is in the list of IDs for architects with a nationality of 'Canadian'.",
    "natural_language": "What is the count of mills from the MILL table where the architect's ID corresponds to an architect with a nationality of 'Canadian'?",
    "id": 187
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_architect_bridge_count that returns a NUMBER representing the count of bridges associated with female architects. The function does not take any input parameters. Within the function, a local variable named bridge_count of type NUMBER is declared to store the result of the query operation. The function begins by executing a SELECT statement that counts all rows in the BRIDGE table. The COUNT(*) function is used to determine the total number of rows that meet the specified condition. The result of this count is stored into the bridge_count variable using the INTO clause. The condition applied in the WHERE clause of the SELECT statement filters rows based on the ARCHITECT_ID column in the BRIDGE table. Specifically, it checks if the ARCHITECT_ID is present in a subquery result. The subquery selects the ID column from the ARCHITECT table, converting it to a NUMBER using the TO_NUMBER function. The subquery further filters the rows by checking if the GENDER column in the ARCHITECT table equals 'female'. This ensures that only bridges associated with female architects are counted. After executing the query and storing the result in bridge_count, the function returns the value of bridge_count, which represents the total number of bridges associated with female architects.",
    "plsql": "CREATE OR REPLACE FUNCTION get_architect_bridge_count RETURN NUMBER IS\n  bridge_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO bridge_count\n  FROM BRIDGE\n  WHERE ARCHITECT_ID IN (SELECT TO_NUMBER(ID) FROM ARCHITECT WHERE GENDER = 'female');\n  RETURN bridge_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT get_architect_bridge_count FROM DUAL"
    ],
    "summary": "Create a function named `get_architect_bridge_count` with no parameters that returns a NUMBER. It should return the count of bridges from the BRIDGE table that are associated with architects whose gender is 'female'.",
    "natural_language": "Define a function called `get_architect_bridge_count` that accepts no parameters and yields a NUMBER data type. The function's purpose is to compute and return the total number of bridges listed in the BRIDGE table for which the associated architect is recorded as female.",
    "id": 188
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_artist_status` that accepts a single input parameter named `artist_id` of data type `NUMBER`. This function is designed to return a `VARCHAR2` value indicating the status of an artist. Internally, the function declares a local variable named `death_year` of data type `NUMBER` to temporarily store the death year of an artist. The core operation of the function involves executing a `SELECT` statement to retrieve the value from the `DEATHYEAR` column. This `SELECT` statement targets the `ARTISTS` table and includes a `WHERE` clause that filters the results based on the condition where the `ARTISTID` column in the `ARTISTS` table matches the value provided by the input parameter `artist_id`. The retrieved `DEATHYEAR` value is then immediately stored into the `death_year` local variable. Following this data retrieval, the function proceeds with a conditional logic block (`IF...THEN...ELSE...END IF`). This block evaluates whether the `death_year` variable is `NULL`. If `death_year` is indeed `NULL`, indicating that no death year was recorded for the artist, the function returns the string literal `'Living'`. Conversely, if `death_year` is not `NULL`, meaning a death year was found, the function returns the string literal `'Deceased'`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_status(artist_id NUMBER) RETURN VARCHAR2 IS\n  death_year NUMBER;\nBEGIN\n  SELECT DEATHYEAR INTO death_year FROM ARTISTS WHERE ARTISTID = artist_id;\n  IF death_year IS NULL THEN\n    RETURN 'Living';\n  ELSE\n    RETURN 'Deceased';\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_status(111) FROM DUAL",
      "SELECT get_artist_status(222) FROM DUAL",
      "SELECT get_artist_status(333) FROM DUAL",
      "SELECT get_artist_status(555) FROM DUAL",
      "SELECT get_artist_status(ARTISTID) FROM ARTISTS WHERE LNAME = 'Seurat'"
    ],
    "summary": "Create a PL/SQL function named `get_artist_status` that takes an `artist_id` (NUMBER) and returns a VARCHAR2. It retrieves the artist's `DEATHYEAR` from the `ARTISTS` table. If `DEATHYEAR` is NULL, return 'Living'; otherwise, return 'Deceased'.",
    "natural_language": "Develop a PL/SQL function called `get_artist_status` which accepts a single numeric input parameter for the `artist_id`. This function should query the `ARTISTS` table to specifically fetch the `DEATHYEAR` value associated with the provided artist identifier. In the detailed case where the retrieved `DEATHYEAR` is determined to be NULL, the function must elaborately return the string 'Living'; conversely, if a `DEATHYEAR` is found, it should distinctly return the string 'Deceased', with the overall function result being of the VARCHAR2 data type.",
    "id": 189
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_sculpture_year` that accepts a single input parameter named `sculpture_id` of data type `NUMBER`. This function is designed to return a `VARCHAR2` string. The function begins by declaring a local variable named `sculpture_year` of data type `NUMBER`. The core operation involves executing a `SELECT` statement to retrieve the value from the `YEAR` column of the `SCULPTURES` table. This retrieval is conditional, specifically targeting the row where the value in the `SCULPTUREID` column matches the value provided in the `sculpture_id` input parameter. The retrieved `YEAR` value is then assigned to the `sculpture_year` local variable. Following this data retrieval, the function proceeds with a conditional logic block: it checks if the value stored in `sculpture_year` is strictly greater than `1900`. If this condition evaluates to true, the function immediately returns the string literal `'Modern'`. Otherwise, if the condition `sculpture_year > 1900` evaluates to false (meaning `sculpture_year` is less than or equal to `1900`), the function returns the string literal `'Classical'`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_sculpture_year(sculpture_id NUMBER) RETURN VARCHAR2 IS\n  sculpture_year NUMBER;\nBEGIN\n  SELECT YEAR INTO sculpture_year FROM SCULPTURES WHERE SCULPTUREID = sculpture_id;\n  IF sculpture_year > 1900 THEN\n    RETURN 'Modern';\n  ELSE\n    RETURN 'Classical';\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT check_sculpture_year(20) FROM DUAL",
      "SELECT check_sculpture_year(21) FROM DUAL",
      "SELECT check_sculpture_year(22) FROM DUAL",
      "SELECT SCULPTUREID, TITLE, check_sculpture_year(SCULPTUREID) AS ERA FROM SCULPTURES",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE(check_sculpture_year(20));\nEND;"
    ],
    "summary": "Create a PL/SQL function named `check_sculpture_year` that takes a `sculpture_id` (NUMBER) and returns a VARCHAR2. It retrieves the sculpture's `YEAR` from the `SCULPTURES` table. If the year is greater than 1900, return 'Modern'; otherwise, return 'Classical'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `check_sculpture_year`? It should take a `sculpture_id` (that's a NUMBER) and spit back a VARCHAR2. Basically, it needs to grab the sculpture's `YEAR` from the `SCULPTURES` table. If the year's after 1900, just say 'Modern'; if it's 1900 or older, call it 'Classical'.",
    "id": 190
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_painting_area that accepts a single input parameter named painting_id of type NUMBER, which is used to identify a specific painting, and returns a value of type NUMBER. The function begins by declaring a local variable named painting_area of type NUMBER. It then executes a SELECT statement that queries the PAINTINGS table, retrieving the product of the HEIGHT_MM column and the WIDTH_MM column for the row where the PAINTINGID column matches the provided painting_id parameter, and stores the result into the painting_area variable. Following the data retrieval, the function evaluates a conditional IF statement: if the calculated painting_area is greater than 1,000,000, the function returns the painting_area value directly; otherwise, if the painting_area is less than or equal to 1,000,000, the function returns the value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_painting_area(painting_id NUMBER) RETURN NUMBER IS\n  painting_area NUMBER;\nBEGIN\n  SELECT HEIGHT_MM * WIDTH_MM INTO painting_area FROM PAINTINGS WHERE PAINTINGID = painting_id;\n  IF painting_area > 1000000 THEN\n    RETURN painting_area;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT calculate_painting_area(80) FROM DUAL",
      "SELECT calculate_painting_area(83) FROM DUAL",
      "SELECT calculate_painting_area(84) FROM DUAL",
      "SELECT calculate_painting_area( (SELECT PAINTINGID FROM PAINTINGS WHERE TITLE = 'A Sunday on La Grande Jatte') ) FROM DUAL",
      "SELECT calculate_painting_area( (SELECT PAINTINGID FROM PAINTINGS WHERE PAINTERID = 222 AND ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_painting_area` that takes a `painting_id` (NUMBER) and returns a NUMBER. It calculates the area (HEIGHT_MM * WIDTH_MM) from the `PAINTINGS` table. If the area is greater than 1,000,000, return the area; otherwise, return 0.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `calculate_painting_area`? It should take a painting's ID (as a NUMBER) and spit back a NUMBER. Basically, it needs to grab the height and width from the `PAINTINGS` table and multiply 'em to get the area. If that area's huge—like over a million—just give back the area. Otherwise, if it's on the smaller side, just return a zero.",
    "id": 191
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_artist_full_name` that accepts a single input parameter named `artist_id` of data type `NUMBER`. This function is designed to return a `VARCHAR2` data type. Internally, the function declares two local variables: `first_name` of data type `VARCHAR2` with a maximum length of 255 characters, and `last_name` of data type `VARCHAR2` with a maximum length of 255 characters. The function then executes a `SELECT` statement to retrieve data. Specifically, it selects the value from the `FNAME` column and the value from the `LNAME` column from the `ARTISTS` table. These retrieved values are then assigned to the local variables `first_name` and `last_name`, respectively. The `SELECT` statement includes a `WHERE` clause that filters the rows based on the condition where the value in the `ARTISTID` column of the `ARTISTS` table is equal to the value passed in the `artist_id` input parameter. Following the data retrieval, the function evaluates a conditional `IF` statement. This `IF` statement checks two conditions: whether the `first_name` variable is `NOT NULL` AND whether the `last_name` variable is `NOT NULL`. If both of these conditions are true, the function returns a concatenated string consisting of the value of `first_name`, followed by a single space character, followed by the value of `last_name`. If either `first_name` or `last_name` (or both) are `NULL`, the `ELSE` block of the conditional statement is executed, and the function returns the literal string 'Unknown'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_full_name(artist_id NUMBER) RETURN VARCHAR2 IS\n  first_name VARCHAR2(255);\n  last_name VARCHAR2(255);\nBEGIN\n  SELECT FNAME, LNAME INTO first_name, last_name FROM ARTISTS WHERE ARTISTID = artist_id;\n  IF first_name IS NOT NULL AND last_name IS NOT NULL THEN\n    RETURN first_name || ' ' || last_name;\n  ELSE\n    RETURN 'Unknown';\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_full_name(111) FROM DUAL",
      "SELECT get_artist_full_name(222) FROM DUAL",
      "SELECT get_artist_full_name(333) FROM DUAL",
      "SELECT get_artist_full_name(555) FROM DUAL",
      "SELECT get_artist_full_name(999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_artist_full_name` that takes an `artist_id` (NUMBER) and returns a VARCHAR2. It retrieves the `FNAME` and `LNAME` from the `ARTISTS` table. If both names are NOT NULL, return the concatenated full name (first name + space + last name); otherwise, return 'Unknown'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_artist_full_name`? It should take an `artist_id` (that's a NUMBER) and spit back a VARCHAR2. Basically, it needs to grab the `FNAME` and `LNAME` from the `ARTISTS` table. If both the first and last name are there (not null), just stick 'em together with a space in between. If one's missing, just have it return 'Unknown'.",
    "id": 192
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_total_order_quantity` that accepts one input parameter, `p_customer_id`, which is of data type `NUMBER` and represents the unique identifier for a customer. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function first declares two local variables: `v_total_quantity` of type `NUMBER`, initialized to `0`, and `v_adjustment` of type `NUMBER`, also initialized to `0`. The core logic begins by executing a `SELECT` statement to retrieve data. This `SELECT` statement calculates the sum of product quantities for all orders associated with the provided customer ID. Specifically, it performs an implicit inner join between the `ORDERS` table (aliased as `o`) and the `ORDER_ITEMS` table (aliased as `oi`) based on the common column `ORDER_ID`, where `o.ORDER_ID` must equal `oi.ORDER_ID`. The `WHERE` clause filters these joined records to include only those where the `CUSTOMER_ID` column in the `ORDERS` table (`o.CUSTOMER_ID`) matches the input parameter `p_customer_id`. For the selected records, the `PRODUCT_QUANTITY` column from the `ORDER_ITEMS` table (`oi.PRODUCT_QUANTITY`) is explicitly converted to a `NUMBER` data type using the `TO_NUMBER()` function, and then these converted quantities are summed up. The result of this summation is then stored into the local variable `v_total_quantity`. Following this, the function calculates an adjustment value. It uses the `MOD()` function to find the remainder when `v_total_quantity` is divided by `5`. This remainder is then assigned to the local variable `v_adjustment`. Finally, the function returns the sum of `v_total_quantity` and `v_adjustment` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_order_quantity(p_customer_id NUMBER) RETURN NUMBER IS\n    v_total_quantity NUMBER := 0;\n    v_adjustment NUMBER := 0;\nBEGIN\n    SELECT SUM(TO_NUMBER(oi.PRODUCT_QUANTITY)) INTO v_total_quantity\n    FROM ORDERS o JOIN ORDER_ITEMS oi ON o.ORDER_ID = oi.ORDER_ID\n    WHERE o.CUSTOMER_ID = p_customer_id;\n    \n    v_adjustment := MOD(v_total_quantity, 5);\n    \n    RETURN v_total_quantity + v_adjustment;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT calculate_total_order_quantity(1) FROM DUAL",
      "SELECT calculate_total_order_quantity(5) FROM DUAL",
      "SELECT calculate_total_order_quantity(7) FROM DUAL",
      "SELECT calculate_total_order_quantity(12) FROM DUAL",
      "SELECT calculate_total_order_quantity(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_total_order_quantity` that takes a `p_customer_id` (NUMBER) and returns a NUMBER. It calculates the total sum of `PRODUCT_QUANTITY` (converted to NUMBER) from `ORDER_ITEMS` for all orders belonging to the given customer. The final result is the total quantity plus the remainder (MOD) of the total quantity divided by 5.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `calculate_total_order_quantity`? It needs to take a customer ID (that's a NUMBER) and spit back a NUMBER. Basically, it should add up all the `PRODUCT_QUANTITY` (make sure it's a NUMBER) from the `ORDER_ITEMS` table for every order that customer's made. Then, for the final answer, take that total and add whatever's left over when you divide it by 5.",
    "id": 193
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_order_count_with_bonus` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER` and represents the unique identifier for a customer. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function initializes a local variable named `v_order_count` to `0`, which will store the total number of orders found for the specified customer, and another local variable named `v_bonus` to `0`, which will store a calculated bonus value. The function then performs a `SELECT` operation to count the total number of rows in the `ORDERS` table. This count is restricted by a `WHERE` clause, which filters the rows to include only those where the `CUSTOMER_ID` column matches the value provided in the `p_customer_id` input parameter. The result of this count operation is then stored into the `v_order_count` local variable. Following this, the function calculates a bonus value by dividing the `v_order_count` by `2` and then applying the `CEIL` function to round the result up to the nearest whole number. This calculated bonus value is then assigned to the `v_bonus` local variable. Finally, the function returns the sum of `v_order_count` and `v_bonus` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_order_count_with_bonus(p_customer_id NUMBER) RETURN NUMBER IS\n    v_order_count NUMBER := 0;\n    v_bonus NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_order_count\n    FROM ORDERS\n    WHERE CUSTOMER_ID = p_customer_id;\n    \n    v_bonus := CEIL(v_order_count / 2);\n    \n    RETURN v_order_count + v_bonus;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_order_count_with_bonus(1) FROM DUAL",
      "SELECT get_order_count_with_bonus(5) FROM DUAL",
      "SELECT get_order_count_with_bonus(7) FROM DUAL",
      "SELECT get_order_count_with_bonus(12) FROM DUAL",
      "SELECT get_order_count_with_bonus(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_order_count_with_bonus` that accepts a `p_customer_id` (NUMBER) and returns a NUMBER. It counts the customer's orders from the ORDERS table, calculates a bonus as the ceiling of half the order count, and returns the sum of the order count and the bonus.",
    "natural_language": "Please construct a PL/SQL function designated as `get_order_count_with_bonus`. This function shall accept a single input parameter, `p_customer_id`, of the NUMBER data type, and it will return a value of the NUMBER type. Its operational logic is to query the ORDERS table to ascertain the total quantity of orders associated with the provided customer identifier. Subsequently, it must compute a bonus equivalent to the mathematical ceiling of one-half of the ascertained order count. The function's return value is to be the arithmetic sum of the initial order count and the calculated bonus.",
    "id": 194
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_average_order_quantity that accepts a single input parameter p_customer_id of type NUMBER and returns a value of type NUMBER, which begins by declaring two local NUMBER variables v_total_quantity and v_order_count, initializing both to zero, then executes a SELECT statement that retrieves data from the ORDERS table (aliased as o) and the ORDER_ITEMS table (aliased as oi) by performing an inner join on the condition that the ORDER_ID column from the ORDERS table equals the ORDER_ID column from the ORDER_ITEMS table, specifically filtering rows where the CUSTOMER_ID column in the ORDERS table matches the provided input parameter p_customer_id, and within this query, it calculates the sum of the PRODUCT_QUANTITY column from the ORDER_ITEMS table after converting each value to a NUMBER using the TO_NUMBER function, storing this result into the variable v_total_quantity, and simultaneously calculates the count of distinct ORDER_ID values from the ORDERS table, storing this result into the variable v_order_count, and finally, the function returns the result of dividing the value in v_total_quantity by the value in v_order_count.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_order_quantity(p_customer_id NUMBER) RETURN NUMBER IS\n    v_total_quantity NUMBER := 0;\n    v_order_count NUMBER := 0;\nBEGIN\n    SELECT SUM(TO_NUMBER(oi.PRODUCT_QUANTITY)), COUNT(DISTINCT o.ORDER_ID) INTO v_total_quantity, v_order_count\n    FROM ORDERS o JOIN ORDER_ITEMS oi ON o.ORDER_ID = oi.ORDER_ID\n    WHERE o.CUSTOMER_ID = p_customer_id;\n    \n    RETURN v_total_quantity / v_order_count;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT calculate_average_order_quantity(1) FROM DUAL",
      "SELECT calculate_average_order_quantity(5) FROM DUAL",
      "SELECT calculate_average_order_quantity(7) FROM DUAL",
      "SELECT calculate_average_order_quantity(12) FROM DUAL",
      "SELECT calculate_average_order_quantity(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_average_order_quantity` that accepts a `p_customer_id` (NUMBER) and returns a NUMBER. It calculates the average product quantity per order for the customer by summing the PRODUCT_QUANTITY (converted to NUMBER) from ORDER_ITEMS and dividing by the distinct count of ORDER_ID from ORDERS, joined on ORDER_ID.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be distinctly named `calculate_average_order_quantity`. This function must be designed to accept a single input parameter, specifically a `p_customer_id` of the NUMBER data type, and it will reliably return a value of the NUMBER type. Its primary purpose is to meticulously compute the average quantity of products per individual order for the specified customer. This calculation is achieved by first aggregating the total sum of the PRODUCT_QUANTITY values, which are carefully converted to NUMBER, from all relevant entries in the ORDER_ITEMS table. This sum is then divided by the precise count of distinct ORDER_ID values retrieved from the ORDERS table, ensuring an accurate average, where the two tables are properly joined using their common ORDER_ID field.",
    "id": 195
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_order_quantity` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Inside the function, two local variables are declared: `v_max_quantity` of type `NUMBER`, initialized to `0`, and `v_adjustment` of type `NUMBER`, also initialized to `0`. The function begins by executing a `SELECT` statement to retrieve the maximum product quantity for a given customer. This `SELECT` statement joins the `ORDERS` table, aliased as `o`, with the `ORDER_ITEMS` table, aliased as `oi`, using the condition `o.ORDER_ID = oi.ORDER_ID`. The `WHERE` clause filters these joined records to include only those where the `CUSTOMER_ID` column in the `ORDERS` table matches the input parameter `p_customer_id`. From the filtered and joined records, the `MAX` aggregate function is applied to the `PRODUCT_QUANTITY` column from the `ORDER_ITEMS` table. Before applying `MAX`, the `PRODUCT_QUANTITY` column, which is presumably stored as a character string, is explicitly converted to a `NUMBER` data type using the `TO_NUMBER` function. The result of this `MAX` operation is then stored into the local variable `v_max_quantity`. Following this, the function calculates an adjustment value by applying the `MOD` (modulo) function. Specifically, `v_adjustment` is assigned the remainder of `v_max_quantity` divided by `3`. Finally, the function returns the sum of `v_max_quantity` and `v_adjustment`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_order_quantity(p_customer_id NUMBER) RETURN NUMBER IS\n    v_max_quantity NUMBER := 0;\n    v_adjustment NUMBER := 0;\nBEGIN\n    SELECT MAX(TO_NUMBER(oi.PRODUCT_QUANTITY)) INTO v_max_quantity\n    FROM ORDERS o JOIN ORDER_ITEMS oi ON o.ORDER_ID = oi.ORDER_ID\n    WHERE o.CUSTOMER_ID = p_customer_id;\n    \n    v_adjustment := MOD(v_max_quantity, 3);\n    \n    RETURN v_max_quantity + v_adjustment;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_max_order_quantity(1) FROM DUAL",
      "SELECT get_max_order_quantity(5) FROM DUAL",
      "SELECT get_max_order_quantity(7) FROM DUAL",
      "SELECT get_max_order_quantity(12) FROM DUAL",
      "SELECT get_max_order_quantity(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_max_order_quantity` that accepts a `p_customer_id` (NUMBER) and returns a NUMBER. It finds the maximum PRODUCT_QUANTITY (converted to NUMBER) from ORDER_ITEMS for the customer's orders, calculates an adjustment as the remainder of this max divided by 3, and returns the sum of the max quantity and the adjustment.",
    "natural_language": "Write a PL/SQL function called `get_max_order_quantity` that takes a customer ID number and gives back a number. It should look at the order items for that customer, find the biggest product quantity (turned into a number), and then figure out a little extra bit based on what's left over when you divide that max by 3. Finally, it returns the biggest quantity plus that extra bit.",
    "id": 196
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_order_value_with_discount that accepts a single parameter p_customer_id of type NUMBER, which represents the unique identifier of a customer. The function is designed to calculate the total order value for the specified customer, applying a discount based on the total value. It initializes a local variable v_total_value of type NUMBER to zero, which will store the cumulative value of all products ordered by the customer. Another local variable, v_discount, also of type NUMBER, is initialized to zero and will hold the discount amount. The function executes a SELECT statement that calculates the sum of the product of PRODUCT_QUANTITY and a fixed price of 10 for each order item associated with the customer. This is achieved by joining the ORDERS table, aliased as o, with the ORDER_ITEMS table, aliased as oi, on the ORDER_ID column, and filtering the results where the CUSTOMER_ID column in the ORDERS table matches the input parameter p_customer_id. The result of this calculation is stored in the v_total_value variable. The function then calculates the discount by dividing v_total_value by 100 and applying the FLOOR function to round down to the nearest whole number, storing the result in v_discount. Finally, the function returns the total order value after subtracting the calculated discount, which is the difference between v_total_value and v_discount.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_order_value_with_discount(p_customer_id NUMBER) RETURN NUMBER IS\n    v_total_value NUMBER := 0;\n    v_discount NUMBER := 0;\nBEGIN\n    SELECT SUM(TO_NUMBER(oi.PRODUCT_QUANTITY) * 10) INTO v_total_value\n    FROM ORDERS o JOIN ORDER_ITEMS oi ON o.ORDER_ID = oi.ORDER_ID\n    WHERE o.CUSTOMER_ID = p_customer_id;\n    \n    v_discount := FLOOR(v_total_value / 100);\n    \n    RETURN v_total_value - v_discount;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT calculate_order_value_with_discount(1) FROM dual",
      "SELECT calculate_order_value_with_discount(5) FROM dual",
      "SELECT calculate_order_value_with_discount(7) FROM dual",
      "SELECT calculate_order_value_with_discount(12) FROM dual",
      "SELECT calculate_order_value_with_discount(8) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `calculate_order_value_with_discount` that accepts a `p_customer_id` (NUMBER) and returns a NUMBER. It calculates the total order value for the customer by summing (PRODUCT_QUANTITY * 10) from ORDER_ITEMS joined with ORDERS, applies a discount equal to the floor of (total value / 100), and returns the total value minus the discount.",
    "natural_language": "Develop a PL/SQL function called `calculate_order_value_with_discount` that takes a single numeric input parameter, specifically a `p_customer_id`, and yields a NUMBER as its output. This function meticulously computes the comprehensive total order value for the specified customer by first aggregating the sum of all product quantities, each multiplied by a unit price of 10, which are meticulously retrieved from the ORDER_ITEMS table after carefully joining it with the ORDERS table based on the relevant order identifiers. Subsequently, it thoughtfully determines an applicable discount, which is precisely calculated as the mathematical floor of the preliminary total value divided by 100. Finally, the function elegantly returns the final net amount, which is the initial total value gracefully reduced by the thoughtfully derived discount.",
    "id": 197
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes two parameters, shop_id_val and device_id_val, both of type NUMBER, and retrieves the quantity of a specific device available in a specific shop from the STOCK table. The function begins by declaring a local variable, quantity_val, of type NUMBER, which will be used to store the result of the query. It then executes a SELECT statement to fetch the QUANTITY column from the STOCK table where the SHOP_ID column matches the value of shop_id_val and the DEVICE_ID column matches the value of device_id_val. The result of this query is stored into the quantity_val variable. Finally, the function returns the value of quantity_val, which represents the quantity of the specified device in the specified shop.",
    "plsql": "CREATE OR REPLACE FUNCTION get_shop_device_quantity(shop_id_val NUMBER, device_id_val NUMBER) RETURN NUMBER IS\n  quantity_val NUMBER;\nBEGIN\n  SELECT QUANTITY INTO quantity_val FROM STOCK WHERE SHOP_ID = shop_id_val AND DEVICE_ID = device_id_val;\n  RETURN quantity_val;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_shop_device_quantity(1, 1) FROM dual",
      "SELECT get_shop_device_quantity(2, 2) FROM dual",
      "SELECT get_shop_device_quantity(3, 3) FROM dual",
      "SELECT get_shop_device_quantity(1, 2) FROM dual",
      "SELECT get_shop_device_quantity(2, 3) FROM dual"
    ],
    "summary": "Create a PL/SQL function that accepts `shop_id_val` and `device_id_val` (both NUMBER) and returns a NUMBER. It retrieves and returns the QUANTITY from the STOCK table where SHOP_ID and DEVICE_ID match the input parameters.",
    "natural_language": "Hey, can you whip up a PL/SQL function that takes in a shop ID and a device ID (both as numbers) and spits back a number? Basically, it needs to go into the STOCK table, find the row where the SHOP_ID and DEVICE_ID match the ones you gave it, and then hand over the QUANTITY from that row.",
    "id": 198
  },
  {
    "ir": "Write an Oracle PL/SQL function named `translate_device_carrier` that accepts two input parameters: `device_id_val` of data type `NUMBER` and `from_chars` of data type `VARCHAR2`. This function is designed to return a single value of data type `VARCHAR2` with a maximum length of 255 characters. Upon execution, the function declares a local variable named `result_val` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved and transformed data. The core operation of the function involves a `SELECT` statement that queries the `DEVICE` table. Specifically, it selects the `CARRIER` column from the `DEVICE` table. Before returning the `CARRIER` value, it applies the `TRANSLATE` function to it. The `TRANSLATE` function replaces all occurrences of characters specified in the `from_chars` input parameter within the `CARRIER` column's value with corresponding characters from the literal string `'ABC'`. The result of this `TRANSLATE` operation is then stored into the `result_val` local variable. This selection and translation are performed only for rows in the `DEVICE` table where the `DEVICE_ID` column's value matches the `device_id_val` input parameter. Finally, the function returns the value stored in the `result_val` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION translate_device_carrier(device_id_val NUMBER, from_chars VARCHAR2) RETURN VARCHAR2 IS\n  result_val VARCHAR2(255);\nBEGIN\n  SELECT TRANSLATE(CARRIER, from_chars, 'ABC') INTO result_val FROM DEVICE WHERE DEVICE_ID = device_id_val;\n  RETURN result_val;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT translate_device_carrier(1, 'MTS') FROM dual",
      "SELECT translate_device_carrier(2, 'Verizon') FROM dual",
      "SELECT translate_device_carrier(3, 'Telus') FROM dual",
      "SELECT translate_device_carrier(1, 'Mobility') FROM dual",
      "SELECT translate_device_carrier(2, 'Wireless') FROM dual"
    ],
    "summary": "Create a function named `translate_device_carrier` that returns a VARCHAR2. It takes a device ID (NUMBER) and a character set (VARCHAR2). It selects the CARRIER from the DEVICE table for the given ID, translates the characters in the carrier using the provided 'from_chars' and the literal 'ABC', and returns the result.",
    "natural_language": "How can I create a function called `translate_device_carrier` that returns a VARCHAR2, takes a device ID (NUMBER) and a character set (VARCHAR2) as inputs, selects the CARRIER from the DEVICE table for the specified ID, translates the characters in that carrier using the provided 'from_chars' and the literal string 'ABC', and then returns the translated result?",
    "id": 199
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_shop_exists that accepts two input parameters: a VARCHAR2 parameter named shop_name_val and a VARCHAR2 parameter named location_val, and returns a NUMBER data type. The function begins by declaring a local NUMBER variable named shop_count. It executes a SELECT statement that queries the SHOP table, using the COUNT(*) aggregate function to count the number of rows where the SHOP_NAME column exactly equals the shop_name_val parameter and the LOCATION column exactly equals the location_val parameter, and stores the resulting count into the shop_count variable. The function then uses an IF-THEN-ELSE conditional statement to evaluate if the shop_count value is greater than zero; if this condition is true, the function returns the numeric value 1, and if the condition is false, the function returns the numeric value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION check_shop_exists(shop_name_val VARCHAR2, location_val VARCHAR2) RETURN NUMBER IS\n  shop_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO shop_count FROM SHOP WHERE SHOP_NAME = shop_name_val AND LOCATION = location_val;\n  IF shop_count > 0 THEN\n    RETURN 1;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT check_shop_exists('Dinas Device', 'Dinas') FROM dual",
      "SELECT check_shop_exists('Best Buy', 'Cymmer') FROM dual",
      "SELECT check_shop_exists('Ferndale', 'Blaenllechau') FROM dual",
      "SELECT check_shop_exists('Dinas Device', 'Blaenllechau') FROM dual",
      "SELECT check_shop_exists('Best Buy', 'Dinas') FROM dual"
    ],
    "summary": "Create a function named `check_shop_exists` that returns a NUMBER. It takes a shop name and location (both VARCHAR2). It counts rows in the SHOP table where both name and location match the inputs. It returns 1 if the count is greater than zero, otherwise returns 0.",
    "natural_language": "Make a function `check_shop_exists` returning NUMBER. It accepts shop name and location (VARCHAR2). Count SHOP rows with matching name and location. Return 1 if count > 0, else 0.",
    "id": 200
  },
  {
    "ir": "Write an Oracle PL/SQL function named translate_and_compare that takes two input parameters, device_id1 of type NUMBER and device_id2 of type NUMBER, and returns a VARCHAR2 string; within the function, it declares two local VARCHAR2 variables, carrier1 and carrier2, each with a maximum length of 255 characters; the function then executes a SELECT statement querying the DEVICE table to retrieve the CARRIER column value for the row where the DEVICE_ID column equals the input parameter device_id1, and it applies the TRANSLATE function to that CARRIER value, replacing each lowercase vowel 'a' with '1', 'e' with '2', 'i' with '3', 'o' with '4', and 'u' with '5', storing the resulting transformed string into the local variable carrier1; subsequently, it executes another SELECT statement on the DEVICE table to retrieve and identically transform, using the same TRANSLATE function with the mapping 'aeiou' to '12345', the CARRIER column value for the row where the DEVICE_ID column equals the input parameter device_id2, storing that result into the local variable carrier2; the function then uses an IF-THEN-ELSE conditional statement to compare the two transformed strings, carrier1 and carrier2; if they are exactly equal, the function returns the string literal 'MATCH'; if they are not equal, the function returns the string literal 'DIFFERENT'.",
    "plsql": "CREATE OR REPLACE FUNCTION translate_and_compare(device_id1 NUMBER, device_id2 NUMBER) RETURN VARCHAR2 IS\n  carrier1 VARCHAR2(255);\n  carrier2 VARCHAR2(255);\nBEGIN\n  SELECT TRANSLATE(CARRIER, 'aeiou', '12345') INTO carrier1 FROM DEVICE WHERE DEVICE_ID = device_id1;\n  SELECT TRANSLATE(CARRIER, 'aeiou', '12345') INTO carrier2 FROM DEVICE WHERE DEVICE_ID = device_id2;\n  IF carrier1 = carrier2 THEN\n    RETURN 'MATCH';\n  ELSE\n    RETURN 'DIFFERENT';\n  END IF;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT translate_and_compare(1, 2) FROM DUAL",
      "SELECT translate_and_compare(2, 1) FROM DUAL",
      "SELECT translate_and_compare(1, 1) FROM DUAL",
      "SELECT translate_and_compare(3, 2) FROM DUAL",
      "SELECT translate_and_compare(2, 3) FROM DUAL"
    ],
    "summary": "Create a function named `translate_and_compare` that returns a VARCHAR2. It takes two device IDs (NUMBER). For each ID, it retrieves the CARRIER from the DEVICE table and translates its lowercase vowels (a,e,i,o,u) to numbers (1,2,3,4,5). It compares the two transformed strings and returns 'MATCH' if they are equal, otherwise returns 'DIFFERENT'.",
    "natural_language": "Create a function called `translate_and_compare` that gives back a text result. It needs two device identifier numbers. For each one, it should get the service provider info from the device list and change all the common lowercase letters in it to digits. Then, look at the two modified text pieces. If they seem pretty much the same, return 'MATCH', if not, return 'DIFFERENT'.",
    "id": 201
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_manufacturer_revenue that accepts a single parameter p_code of type NUMBER, which represents the unique code of a manufacturer. The function retrieves the revenue associated with the manufacturer whose CODE column in the MANUFACTURERS table matches the provided p_code parameter. It performs a SELECT operation to fetch the REVENUE column value from the MANUFACTURERS table, where the condition CODE = p_code is satisfied. The retrieved revenue value is stored in a local variable v_revenue of type NUMBER. The function then returns the value of v_revenue, which represents the revenue of the specified manufacturer.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manufacturer_revenue(p_code NUMBER) RETURN NUMBER IS\nv_revenue NUMBER;\nBEGIN\nSELECT REVENUE INTO v_revenue FROM MANUFACTURERS WHERE CODE = p_code;\nRETURN v_revenue;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_manufacturer_revenue(1) FROM dual",
      "SELECT get_manufacturer_revenue(2) FROM dual",
      "SELECT get_manufacturer_revenue(3) FROM dual"
    ],
    "summary": "Create a function named `get_manufacturer_revenue` that returns a NUMBER. It takes a manufacturer code (NUMBER). It selects the REVENUE from the MANUFACTURERS table where the CODE matches the input parameter and returns the value.",
    "natural_language": "Function `get_manufacturer_revenue` returning NUMBER. Takes manufacturer code NUMBER. Fetch REVENUE from MANUFACTURERS where CODE matches parameter.",
    "id": 202
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_price that accepts a single parameter p_code of type NUMBER, which represents the product code. The function retrieves the price of a product from the PRODUCTS table by executing a SELECT statement that targets the PRICE column. The SELECT statement uses a WHERE clause to filter the rows based on the condition that the CODE column in the PRODUCTS table matches the value of the p_code parameter. The result of the SELECT operation is stored in a local variable v_price of type NUMBER. The function then returns the value stored in v_price, which represents the price of the product corresponding to the provided product code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price(p_code NUMBER) RETURN NUMBER IS\nv_price NUMBER;\nBEGIN\nSELECT PRICE INTO v_price FROM PRODUCTS WHERE CODE = p_code;\nRETURN v_price;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_price(1) FROM dual",
      "SELECT get_product_price(2) FROM dual",
      "SELECT get_product_price(3) FROM dual"
    ],
    "summary": "Create a function named `get_product_price` that returns a NUMBER. It takes a product code (NUMBER). It selects the PRICE from the PRODUCTS table where the CODE matches the input parameter and returns the value.",
    "natural_language": "Hey, can you whip up a function called `get_product_price` that spits back a NUMBER? It needs to take a product code (that's a NUMBER too). Basically, it should grab the PRICE from the PRODUCTS table when the CODE there matches the number you give it, and then just hand that price back.",
    "id": 203
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_manufacturer_name that accepts a single input parameter named p_code of the NUMBER data type and returns a value of the VARCHAR2 data type. The function declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters. The function executes a SELECT statement that retrieves a single row from the MANUFACTURERS table, specifically the value from the NAME column, and assigns it into the local variable v_name. The selection is performed with the condition that the value in the CODE column of the MANUFACTURERS table must be exactly equal to the value provided in the input parameter p_code. The function then concludes by returning the value stored in the v_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manufacturer_name(p_code NUMBER) RETURN VARCHAR2 IS\nv_name VARCHAR2(255);\nBEGIN\nSELECT NAME INTO v_name FROM MANUFACTURERS WHERE CODE = p_code;\nRETURN v_name;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_manufacturer_name(1) FROM DUAL",
      "SELECT get_manufacturer_name(2) FROM DUAL",
      "SELECT get_manufacturer_name(3) FROM DUAL",
      "SELECT p.name, get_manufacturer_name(p.manufacturer) FROM products p",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE(get_manufacturer_name(1));\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_manufacturer_name that accepts a NUMBER parameter p_code and returns a VARCHAR2. It selects the NAME from the MANUFACTURERS table where CODE equals p_code and returns the value.",
    "natural_language": "Write a PL/SQL function called get_manufacturer_name. It must take a NUMBER parameter p_code and return a VARCHAR2. Have it fetch and return the NAME from the MANUFACTURERS table where the CODE matches p_code.",
    "id": 204
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_name that accepts a single parameter p_code of type NUMBER, which represents the code of a product. The function is designed to retrieve the name of a product from the PRODUCTS table. It declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters to store the product name. Within the function's execution block, a SELECT statement is used to query the PRODUCTS table, specifically targeting the NAME column. The query includes a WHERE clause that filters the rows based on the condition that the CODE column in the PRODUCTS table matches the value of the p_code parameter. The result of this query, which is the product name corresponding to the provided product code, is assigned to the v_name variable using the INTO clause. Finally, the function returns the value stored in v_name, which is the name of the product associated with the given product code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_name(p_code NUMBER) RETURN VARCHAR2 IS\nv_name VARCHAR2(255);\nBEGIN\nSELECT NAME INTO v_name FROM PRODUCTS WHERE CODE = p_code;\nRETURN v_name;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_name(1) FROM DUAL",
      "SELECT get_product_name(2) FROM DUAL",
      "SELECT get_product_name(3) FROM DUAL",
      "SELECT get_product_name(4) FROM DUAL",
      "SELECT get_product_name(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_product_name that accepts a NUMBER parameter p_code and returns a VARCHAR2. It selects the NAME from the PRODUCTS table where CODE equals p_code and returns the value.",
    "natural_language": "Write a PL/SQL function called get_product_name that takes a NUMBER parameter p_code and returns a VARCHAR2. Have it fetch the NAME from the PRODUCTS table where CODE matches p_code and then return that name.",
    "id": 205
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_manufacturer_headquarter` that accepts a single input parameter named `p_code`. This parameter is of data type `NUMBER` and is intended to represent a unique identifier or code for a manufacturer. The function is designed to return a single value of data type `VARCHAR2`, which will represent the headquarter location of the manufacturer. Inside the function's execution block, a local variable named `v_headquarter` is declared, capable of storing a string up to 255 characters in length (`VARCHAR2(255)`). The core operation of this function is a `SELECT` statement. This `SELECT` statement retrieves the value from the `HEADQUARTER` column. The data is retrieved from the table named `MANUFACTURERS`. The selection of the specific row is determined by a `WHERE` clause, which filters the rows based on the condition that the value in the `CODE` column of the `MANUFACTURERS` table must be equal to the value provided in the input parameter `p_code`. The retrieved `HEADQUARTER` value is then immediately assigned to the local variable `v_headquarter`. Finally, the function returns the value stored in the `v_headquarter` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manufacturer_headquarter(p_code NUMBER) RETURN VARCHAR2 IS\nv_headquarter VARCHAR2(255);\nBEGIN\nSELECT HEADQUARTER INTO v_headquarter FROM MANUFACTURERS WHERE CODE = p_code;\nRETURN v_headquarter;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_manufacturer_headquarter(1) FROM DUAL",
      "SELECT get_manufacturer_headquarter(2) FROM DUAL",
      "SELECT get_manufacturer_headquarter(3) FROM DUAL",
      "SELECT get_manufacturer_headquarter(4) FROM DUAL",
      "SELECT get_manufacturer_headquarter(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_manufacturer_headquarter that accepts a NUMBER parameter p_code and returns a VARCHAR2. It selects the HEADQUARTER from the MANUFACTURERS table where CODE equals p_code and returns the value.",
    "natural_language": "Write a PL/SQL function called get_manufacturer_headquarter that takes a NUMBER parameter p_code and returns a VARCHAR2. Have it fetch and return the HEADQUARTER from the MANUFACTURERS table for the record where CODE matches p_code.",
    "id": 206
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_photos_count that returns a NUMBER data type, has no input parameters, declares a local variable v_count of type NUMBER, executes a SELECT statement to count all rows from the PHOTOS table and stores the result into v_count, returns the value of v_count, and includes an exception handling section that returns 0 if a NO_DATA_FOUND exception is encountered and re-raises any other exception that occurs.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_photos_count\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM PHOTOS;\n    RETURN v_count;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "SELECT get_total_photos_count FROM DUAL",
      "SELECT get_total_photos_count() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_total_photos_count;\n  DBMS_OUTPUT.PUT_LINE('Total photos: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total photos count: ' || get_total_photos_count);\nEND;",
      "SELECT get_total_photos_count AS total_photos FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_photos_count with no parameters that returns a NUMBER. It counts all rows from the PHOTOS table and returns the count. Handle NO_DATA_FOUND by returning 0 and re-raise any other exception.",
    "natural_language": "What PL/SQL function, named get_total_photos_count with no parameters and a NUMBER return type, can be written to count all rows from the PHOTOS table, return 0 for NO_DATA_FOUND, and re-raise any other exception?",
    "id": 207
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_mountain_height that calculates and returns the average height of mountains from the MOUNTAIN table. The function does not take any input parameters and returns a NUMBER type value. Inside the function, a local variable v_average_height of type NUMBER is declared to store the result of the average height calculation. The function executes a SELECT statement that computes the average of the HEIGHT column from the MOUNTAIN table, rounding the result to two decimal places using the ROUND function. The computed average height is stored in the v_average_height variable. The function then returns the value of v_average_height, using the NVL function to ensure that if the average height is NULL, a default value of 0 is returned instead.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_mountain_height\nRETURN NUMBER\nIS\n    v_average_height NUMBER;\nBEGIN\n    SELECT ROUND(AVG(HEIGHT), 2)\n    INTO v_average_height\n    FROM MOUNTAIN;\n    \n    RETURN NVL(v_average_height, 0);\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "SELECT get_average_mountain_height FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_average_mountain_height with no parameters that returns a NUMBER. It calculates the average of the HEIGHT column from the MOUNTAIN table, rounds to two decimals, and returns the value. Use NVL to return 0 if the average is NULL.",
    "natural_language": "What is the PL/SQL function definition for get_average_mountain_height, which takes no parameters, returns a NUMBER, calculates the average HEIGHT from the MOUNTAIN table rounded to two decimals, and uses NVL to return 0 for a NULL average?",
    "id": 208
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_focal_length` that is designed to return a single numeric value representing the maximum focal length recorded in a specific database table. This function does not accept any input parameters. Internally, it declares a local variable named `v_max_focal_length` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `CAMERA_LENS` table. Specifically, it calculates the maximum value among all entries in the `FOCAL_LENGTH_MM` column of the `CAMERA_LENS` table. The result of this aggregation (the single maximum focal length) is then immediately assigned to the `v_max_focal_length` variable using the `INTO` clause. Finally, the function concludes its execution by returning the value currently held in the `v_max_focal_length` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_focal_length\nRETURN NUMBER\nIS\n    v_max_focal_length NUMBER;\nBEGIN\n    SELECT MAX(FOCAL_LENGTH_MM) \n    INTO v_max_focal_length \n    FROM CAMERA_LENS;\n    \n    RETURN v_max_focal_length;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "SELECT get_max_focal_length FROM DUAL",
      "SELECT get_max_focal_length() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_max_focal_length;\n  DBMS_OUTPUT.PUT_LINE('Max focal length: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Maximum focal length is: ' || get_max_focal_length);\nEND;",
      "SELECT brand, name, focal_length_mm FROM camera_lens WHERE focal_length_mm = get_max_focal_length"
    ],
    "summary": "Create a PL/SQL function named get_max_focal_length with no parameters that returns the maximum value from the FOCAL_LENGTH_MM column in the CAMERA_LENS table.",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_max_focal_length', which accepts no parameters and is defined to return the maximum numerical value present in the FOCAL_LENGTH_MM column of the CAMERA_LENS table.",
    "id": 209
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_mountain_count_by_prominence that returns a NUMBER representing the count of mountains with a prominence greater than 2000. The function does not take any input parameters. It begins by declaring a local variable named mountain_count of type NUMBER to store the result of the query. Within the function's main execution block, a SELECT statement is executed to count all rows in the MOUNTAIN table where the PROMINENCE column has a value exceeding 2000. The result of this query is stored in the mountain_count variable using the INTO clause. After successfully retrieving the count, the function returns the value stored in mountain_count. The function includes an exception handling section that captures any exceptions that may occur during execution. If an exception is raised, the function returns NULL, indicating that the operation did not complete successfully. The exception handling uses the WHEN OTHERS clause, which is a catch-all for any exceptions not explicitly handled elsewhere in the code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mountain_count_by_prominence\nRETURN NUMBER\nIS\n  mountain_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO mountain_count\n  FROM MOUNTAIN\n  WHERE PROMINENCE > 2000;\n\n  RETURN mountain_count;\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN NULL; -- or handle the exception as needed\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "SELECT get_mountain_count_by_prominence FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_mountain_count_by_prominence with no parameters that returns the count of rows from the MOUNTAIN table where the PROMINENCE column is greater than 2000. Handle any exception by returning NULL.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_mountain_count_by_prominence? It doesn't need any inputs. Basically, it should just give us the number of mountains from the MOUNTAIN table that are real standouts, you know, where the PROMINENCE is over 2000. If anything goes wrong, just have it spit out NULL.",
    "id": 210
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_sigma_lens_count that returns a NUMBER data type, has no input parameters, and declares a local variable v_count of type NUMBER; the function's execution block begins by performing a SELECT statement that queries the CAMERA_LENS table, using the COUNT(*) aggregate function to calculate the total number of rows, and stores the result into the v_count variable; the SELECT statement includes a WHERE clause with a condition that applies the UPPER function to the BRAND column to convert its value to uppercase and checks if this uppercase value is exactly equal to the string literal 'SIGMA'; after the SELECT, the function returns the value stored in v_count; the function also contains an EXCEPTION handling section with two handlers: the first handler catches the NO_DATA_FOUND exception, which would occur if the SELECT...INTO statement retrieved zero rows, and in this case the handler causes the function to return the value 0; the second handler uses the WHEN OTHERS clause to catch any other exceptions that are not NO_DATA_FOUND, and its action is to re-raise the caught exception using the RAISE statement, thereby propagating the error to the calling environment.",
    "plsql": "CREATE OR REPLACE FUNCTION get_sigma_lens_count\nRETURN NUMBER\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM CAMERA_LENS\n    WHERE UPPER(BRAND) = 'SIGMA';\n    \n    RETURN v_count;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "SELECT get_sigma_lens_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_sigma_lens_count with no parameters that returns the count of rows from the CAMERA_LENS table where the uppercase BRAND column equals 'SIGMA'. Handle NO_DATA_FOUND by returning 0 and re-raise all other exceptions.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_sigma_lens_count? It doesn't need any inputs. Basically, it should just give us the number of rows in the CAMERA_LENS table where the BRAND, in all caps, is 'SIGMA'. If it doesn't find any, just spit out a 0. But if any other weird error pops up, just let that exception fly.",
    "id": 211
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_singer_net_worth that accepts a single input parameter p_singer_id of type NUMBER, which represents the unique identifier of a singer. The function is designed to return a value of type NUMBER, specifically the net worth of the singer in millions. Within the function, a local variable v_net_worth of type NUMBER is declared to temporarily store the net worth value. The function executes a SELECT statement to retrieve the NET_WORTH_MILLIONS column from the SINGER table, where the condition SINGER_ID equals the input parameter p_singer_id is met. The retrieved value is stored into the local variable v_net_worth using the INTO clause. Finally, the function returns the value stored in v_net_worth, effectively providing the net worth of the specified singer based on the given singer ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_singer_net_worth(p_singer_id NUMBER) RETURN NUMBER IS\n  v_net_worth NUMBER;\nBEGIN\n  SELECT NET_WORTH_MILLIONS INTO v_net_worth FROM SINGER WHERE SINGER_ID = p_singer_id;\n  RETURN v_net_worth;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT get_singer_net_worth(1) FROM dual",
      "SELECT get_singer_net_worth(2) FROM dual",
      "SELECT get_singer_net_worth(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_singer_net_worth that accepts a singer_id parameter and returns the NET_WORTH_MILLIONS value for that singer from the SINGER table.",
    "natural_language": "Write a PL/SQL function called get_singer_net_worth that takes a singer_id and fetches the NET_WORTH_MILLIONS for that singer from the SINGER table.",
    "id": 212
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_total_sales that returns a NUMBER data type, which internally declares a local variable v_total_sales of type NUMBER, then executes a SELECT statement that uses the SUM aggregate function on the SALES column from the SONG table, storing the resulting total into the v_total_sales variable, and finally returns the value contained in v_total_sales as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_sales RETURN NUMBER IS\n  v_total_sales NUMBER;\nBEGIN\n  SELECT SUM(SALES) INTO v_total_sales FROM SONG;\n  RETURN v_total_sales;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT calculate_total_sales FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_total_sales with no parameters that returns the sum of the SALES column from the SONG table.",
    "natural_language": "What is the PL/SQL function definition, named calculate_total_sales with no parameters, that returns the total sum of the SALES column from the SONG table?",
    "id": 213
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_singer_name that accepts a single input parameter p_singer_id of the NUMBER data type and returns a value of the VARCHAR2 data type, where the function's execution block declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT operation on the SINGER table to retrieve the value from the NAME column for the specific row where the SINGER_ID column value is exactly equal to the provided input parameter p_singer_id, storing the retrieved value into the local variable v_name, and finally returns the content of the v_name variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_singer_name(p_singer_id NUMBER) RETURN VARCHAR2 IS\n  v_name VARCHAR2(255);\nBEGIN\n  SELECT NAME INTO v_name FROM SINGER WHERE SINGER_ID = p_singer_id;\n  RETURN v_name;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT get_singer_name(1) FROM dual",
      "SELECT get_singer_name(2) FROM dual",
      "SELECT get_singer_name(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_singer_name that accepts a singer ID (NUMBER) and returns the singer's name (VARCHAR2) by selecting from the SINGER table where SINGER_ID matches the input.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_singer_name, which will take as its sole parameter a specific singer ID of the NUMBER data type. This function's purpose is to meticulously retrieve and return the corresponding singer's full name as a VARCHAR2 value. It accomplishes this by executing a precise SELECT statement that queries the SINGER table, carefully matching the provided input parameter to the table's SINGER_ID column to ensure an accurate result.",
    "id": 214
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_song_count that accepts a single input parameter p_singer_id of the NUMBER data type, which represents the unique identifier of a singer, and returns a single value of the NUMBER data type; the function declares a local variable v_count of the NUMBER data type; within the execution block, the function performs a SELECT statement that queries the SONG table, using the COUNT(*) aggregate function to calculate the total number of rows; the SELECT statement includes a WHERE clause with the condition that the SINGER_ID column in the SONG table must be equal to the value supplied in the input parameter p_singer_id; the result of the COUNT(*) operation is stored into the local variable v_count using the INTO clause; the function then concludes its execution by using the RETURN statement to send the value stored in v_count back to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION get_song_count(p_singer_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM SONG WHERE SINGER_ID = p_singer_id;\n  RETURN v_count;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT get_song_count(1) FROM DUAL",
      "SELECT get_song_count(2) FROM DUAL",
      "SELECT get_song_count(3) FROM DUAL",
      "SELECT get_song_count(4) FROM DUAL",
      "SELECT get_song_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_song_count that accepts a singer ID (NUMBER) and returns the count of songs (NUMBER) for that singer by counting rows in the SONG table where SINGER_ID matches the input.",
    "natural_language": "What is the total number of songs for a given singer ID, obtained by counting the relevant entries in the SONG table?",
    "id": 215
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_highest_position that accepts a single input parameter p_song_id of the NUMBER data type and returns a value of the NUMBER data type, where the function's purpose is to retrieve the highest chart position for a specific song, and the function's logic begins by declaring a local variable v_position of the NUMBER data type, then executes a SELECT statement that queries the SONG table to retrieve the value from the HIGHEST_POSITION column for the single row where the SONG_ID column value exactly matches the input parameter p_song_id, storing the retrieved value directly into the local variable v_position, and finally concludes by using a RETURN statement to output the value stored in v_position as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_position(p_song_id NUMBER) RETURN NUMBER IS\n  v_position NUMBER;\nBEGIN\n  SELECT HIGHEST_POSITION INTO v_position FROM SONG WHERE SONG_ID = p_song_id;\n  RETURN v_position;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT get_highest_position(3) FROM DUAL",
      "SELECT get_highest_position(4) FROM DUAL",
      "SELECT get_highest_position(5) FROM DUAL",
      "SELECT get_highest_position(10) FROM DUAL",
      "SELECT SONG_ID, TITLE, get_highest_position(SONG_ID) AS HIGHEST_POS FROM SONG WHERE SONG_ID = 3"
    ],
    "summary": "Create a PL/SQL function named get_highest_position that accepts a song ID (NUMBER) and returns the highest chart position (NUMBER) for that song by selecting the HIGHEST_POSITION from the SONG table where SONG_ID matches the input.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_highest_position'. This function shall receive a song identifier of the NUMBER data type as its parameter. Its purpose is to retrieve and return the peak chart position, also of NUMBER type, for the specified song. This is achieved by querying the HIGHEST_POSITION column from the SONG table where the SONG_ID column corresponds to the provided input parameter.",
    "id": 216
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_city_student_count that accepts a single input parameter p_city_code of type VARCHAR2 and returns a value of type NUMBER; within the function, a local variable v_student_count of type NUMBER is declared; the function executes a SELECT statement that queries the STUDENT table, using the COUNT(*) aggregate function to calculate the total number of rows; the SELECT statement includes a WHERE clause with the condition CITY_CODE = p_city_code, which filters the rows to only those where the CITY_CODE column value matches the provided input parameter p_city_code; the result of the COUNT(*) operation is stored into the local variable v_student_count using an INTO clause; the function then concludes by using a RETURN statement to output the value stored in v_student_count.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_city_student_count(p_city_code VARCHAR2) RETURN NUMBER IS\n  v_student_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_student_count FROM STUDENT WHERE CITY_CODE = p_city_code;\n  RETURN v_student_count;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_city_student_count('BAL') FROM DUAL",
      "SELECT fn_get_city_student_count('PIT') FROM DUAL",
      "SELECT fn_get_city_student_count('PHL') FROM DUAL",
      "SELECT fn_get_city_student_count('HKG') FROM DUAL",
      "SELECT fn_get_city_student_count('WAS') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_city_student_count that accepts a city code (VARCHAR2) and returns the number of students (NUMBER) in that city by counting rows in the STUDENT table where CITY_CODE matches the input.",
    "natural_language": "Hey, can you whip up a PL/SQL function called fn_get_city_student_count? It should take a city code (as a VARCHAR2) and spit back how many students are in that city. Basically, just count up all the rows in the STUDENT table where the CITY_CODE matches the one you gave it.",
    "id": 217
  },
  {
    "ir": "Write an Oracle PL/SQL function named `fn_get_total_distance` that accepts a single input parameter, `p_city_code`, which is of data type `VARCHAR2` and represents a city code used for identifying locations. This function is designed to return a single numeric value representing the total accumulated distance. Internally, the function declares a local variable named `v_total_distance` of data type `NUMBER` to temporarily store the calculated sum of distances. The core operation involves executing a `SELECT` statement to retrieve data from the `DIRECT_DISTANCE` table. Specifically, it calculates the `SUM` of values from the `DISTANCE` column. This summation is performed under a conditional clause (`WHERE`) that includes rows where either the `CITY1_CODE` column's value is equal to the value provided in the `p_city_code` input parameter, or the `CITY2_CODE` column's value is equal to the value provided in the `p_city_code` input parameter. The result of this `SUM` aggregation is then stored into the `v_total_distance` local variable. Finally, the function returns the value held by `v_total_distance` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_total_distance(p_city_code VARCHAR2) RETURN NUMBER IS\n  v_total_distance NUMBER;\nBEGIN\n  SELECT SUM(DISTANCE) INTO v_total_distance FROM DIRECT_DISTANCE WHERE CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code;\n  RETURN v_total_distance;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_total_distance('BAL') FROM dual",
      "SELECT fn_get_total_distance('PIT') FROM dual",
      "SELECT fn_get_total_distance('PHL') FROM dual",
      "SELECT fn_get_total_distance('ATL') FROM dual",
      "SELECT fn_get_total_distance('BKK') FROM dual"
    ],
    "summary": "Create a PL/SQL function named fn_get_total_distance that accepts a city code (VARCHAR2) and returns the total distance (NUMBER) associated with that city by summing the DISTANCE from the DIRECT_DISTANCE table where the city code matches either the CITY1_CODE or CITY2_CODE column.",
    "natural_language": "Please construct a PL/SQL function designated as 'fn_get_total_distance'. This function shall accept a single input parameter of type VARCHAR2, representing a city code, and shall return a value of type NUMBER. The function's purpose is to compute the aggregate distance related to the specified city. This is achieved by summing the DISTANCE column values from the DIRECT_DISTANCE table for all records where the provided city code is present in either the CITY1_CODE or CITY2_CODE column.",
    "id": 218
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_average_student_age that accepts a single input parameter p_city_code of data type VARCHAR2 and returns a value of data type NUMBER; within the function, a local variable v_average_age of type NUMBER is declared; the function's logic executes a SELECT statement that calculates the average value of the AGE column from the STUDENT table, specifically for rows where the CITY_CODE column matches the value provided in the input parameter p_city_code; the result of this AVG aggregation is stored into the local variable v_average_age using an INTO clause; the function then concludes by returning the value contained in v_average_age.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_average_student_age(p_city_code VARCHAR2) RETURN NUMBER IS\n  v_average_age NUMBER;\nBEGIN\n  SELECT AVG(AGE) INTO v_average_age FROM STUDENT WHERE CITY_CODE = p_city_code;\n  RETURN v_average_age;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_average_student_age('BAL') FROM dual",
      "SELECT fn_get_average_student_age('PIT') FROM dual",
      "SELECT fn_get_average_student_age('PHL') FROM dual",
      "SELECT fn_get_average_student_age('HKG') FROM dual",
      "SELECT fn_get_average_student_age('WAS') FROM dual"
    ],
    "summary": "Create a PL/SQL function named fn_get_average_student_age that accepts a VARCHAR2 city code and returns the average age of students from that city as a NUMBER.",
    "natural_language": "What is the average age of students from a given city, and can you provide it as a PL/SQL function named fn_get_average_student_age that takes a VARCHAR2 city code and returns the result as a NUMBER?",
    "id": 219
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_city_latitude that accepts a single input parameter p_city_code of type VARCHAR2, which represents the code of a city. The function retrieves the latitude of the city from the CITY table by executing a SELECT statement that targets the LATITUDE column. The selection is based on the condition that the CITY_CODE column in the CITY table matches the value provided in the p_city_code parameter. The result of the SELECT operation is stored in a local variable v_latitude of type NUMBER. The function then returns the value of v_latitude, which represents the latitude of the specified city.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_city_latitude(p_city_code VARCHAR2) RETURN NUMBER IS\n  v_latitude NUMBER;\nBEGIN\n  SELECT LATITUDE INTO v_latitude FROM CITY WHERE CITY_CODE = p_city_code;\n  RETURN v_latitude;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_city_latitude('BAL') FROM dual",
      "SELECT fn_get_city_latitude('PIT') FROM dual",
      "SELECT fn_get_city_latitude('PHL') FROM dual",
      "SELECT fn_get_city_latitude('ATL') FROM dual",
      "SELECT fn_get_city_latitude('BKK') FROM dual"
    ],
    "summary": "Create a PL/SQL function named fn_get_city_latitude that accepts a VARCHAR2 city code and returns the latitude for that city from the CITY table as a NUMBER.",
    "natural_language": "Please construct a PL/SQL function designated as 'fn_get_city_latitude'. This function shall accept a single input parameter of the VARCHAR2 data type, representing a city code. Its purpose is to retrieve and return the corresponding latitude value, as a NUMBER, from the CITY table for the specified city.",
    "id": 220
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_city_longitude that accepts a single input parameter, p_city_code, of type VARCHAR2, which represents the code of a city. The function is designed to return a value of type NUMBER, specifically the longitude of the city corresponding to the provided city code. Within the function, a local variable v_longitude of type NUMBER is declared to temporarily store the longitude value retrieved from the database. The function executes a SELECT statement that queries the CITY table, specifically targeting the LONGITUDE column. The query uses a WHERE clause to filter the results based on the condition that the CITY_CODE column matches the value of the input parameter p_city_code. The result of the SELECT statement is assigned to the local variable v_longitude using the INTO clause. After successfully retrieving the longitude value, the function returns the value stored in v_longitude, effectively providing the longitude of the specified city code to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_city_longitude(p_city_code VARCHAR2) RETURN NUMBER IS\n  v_longitude NUMBER;\nBEGIN\n  SELECT LONGITUDE INTO v_longitude FROM CITY WHERE CITY_CODE = p_city_code;\n  RETURN v_longitude;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_city_longitude('BAL') FROM DUAL",
      "SELECT fn_get_city_longitude('PIT') FROM DUAL",
      "SELECT fn_get_city_longitude('PHL') FROM DUAL",
      "SELECT s.fname, s.lname, fn_get_city_longitude(s.city_code) AS city_longitude FROM student s WHERE s.stuid = 1001",
      "SELECT city_name, fn_get_city_longitude(city_code) AS longitude FROM city WHERE state = 'PA'"
    ],
    "summary": "Create a PL/SQL function named fn_get_city_longitude that accepts a VARCHAR2 city code and returns the longitude for that city from the CITY table as a NUMBER.",
    "natural_language": "Hey, can you whip up a PL/SQL function called fn_get_city_longitude? It should take a city code (as a VARCHAR2) and spit back the longitude for that city from the CITY table as a NUMBER.",
    "id": 221
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_architect_bridge_count that accepts a single parameter, p_architect_id, of type NUMBER, which represents the unique identifier of an architect. The function is designed to return a NUMBER that indicates the total count of bridges associated with the specified architect. Within the function, a local variable v_count of type NUMBER is declared to store the result of the count operation. The function executes a SELECT statement that counts all rows in the BRIDGE table where the value in the ARCHITECT_ID column matches the value of the input parameter p_architect_id. The result of this count operation is stored in the v_count variable using the INTO clause. Finally, the function returns the value stored in v_count, which represents the number of bridges designed by the architect identified by p_architect_id.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_architect_bridge_count(p_architect_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM BRIDGE WHERE ARCHITECT_ID = p_architect_id;\n  RETURN v_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT fn_get_architect_bridge_count(2) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(3) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(4) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(1) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_architect_bridge_count that accepts a NUMBER architect ID and returns the total count of bridges designed by that architect as a NUMBER.",
    "natural_language": "Function fn_get_architect_bridge_count: input architect ID (NUMBER), output their bridge count (NUMBER).",
    "id": 222
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_mill_count_by_type that accepts a single input parameter p_type of data type VARCHAR2 and returns a value of data type NUMBER; within the function, declare a local variable v_count of type NUMBER, then execute a SELECT statement that queries the MILL table to count all rows where the value in the column named TYPE is exactly equal to the value provided in the input parameter p_type, storing the result of this count operation into the local variable v_count, and finally return the value stored in v_count as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_mill_count_by_type(p_type VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM MILL WHERE TYPE = p_type;\n  RETURN v_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT fn_get_mill_count_by_type('Windmill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Watermill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Tide Mill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Post Mill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Smock Mill') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_mill_count_by_type that accepts a VARCHAR2 type and returns the count of mills with that specific type as a NUMBER.",
    "natural_language": "Make function fn_get_mill_count_by_type returning NUMBER, taking VARCHAR2 input for mill type.",
    "id": 223
  },
  {
    "ir": "Write an Oracle PL/SQL function named `fn_get_architect_mill_count` that is designed to return a single numeric value. This function accepts one input parameter, `p_architect_id`, which is of the `NUMBER` data type and represents the unique identifier of an architect. Upon execution, the function declares a local variable named `v_count` of the `NUMBER` data type to temporarily store the result of a database query. The core operation of the function involves performing a `SELECT` statement to count the total number of records in the `MILL` table. This count is specifically filtered by a `WHERE` clause, ensuring that only those records where the `ARCHITECT_ID` column matches the value provided in the `p_architect_id` input parameter are included in the count. The result of this `COUNT(*)` aggregation is then assigned to the `v_count` local variable using the `INTO` clause. Finally, the function returns the value stored in the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_architect_mill_count(p_architect_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM MILL WHERE ARCHITECT_ID = p_architect_id;\n  RETURN v_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT fn_get_architect_mill_count(1) FROM DUAL",
      "SELECT fn_get_architect_mill_count(2) FROM DUAL",
      "SELECT fn_get_architect_mill_count(3) FROM DUAL",
      "SELECT fn_get_architect_mill_count(4) FROM DUAL",
      "SELECT fn_get_architect_mill_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_architect_mill_count that accepts an architect_id number and returns the count of mills associated with that architect.",
    "natural_language": "How many mills are associated with a given architect?",
    "id": 224
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_bridge_length_in_feet that accepts a single input parameter p_bridge_id of the NUMBER data type and returns a value of the NUMBER data type, which is designed to retrieve the length measurement in feet for a specific bridge record; the function declares a local variable v_length_feet of type NUMBER to temporarily hold the retrieved value; within its execution block, it performs a SELECT operation on the BRIDGE table, specifically querying the LENGTH_FEET column, and uses an INTO clause to store the result into the local variable v_length_feet, with the selection conditioned by a WHERE clause that filters rows to only those where the value in the ID column is exactly equal to the value provided in the input parameter p_bridge_id; after the SELECT statement executes, the function concludes by using a RETURN statement to output the value stored in the v_length_feet variable.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_bridge_length_in_feet(p_bridge_id NUMBER) RETURN NUMBER IS\n  v_length_feet NUMBER;\nBEGIN\n  SELECT LENGTH_FEET INTO v_length_feet FROM BRIDGE WHERE ID = p_bridge_id;\n  RETURN v_length_feet;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT fn_get_bridge_length_in_feet(2) FROM DUAL",
      "SELECT fn_get_bridge_length_in_feet(3) FROM DUAL",
      "SELECT fn_get_bridge_length_in_feet(4) FROM DUAL",
      "SELECT fn_get_bridge_length_in_feet(1) FROM DUAL",
      "SELECT fn_get_bridge_length_in_feet(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_bridge_length_in_feet that accepts a bridge_id number and returns the length in feet for that bridge.",
    "natural_language": "Make function fn_get_bridge_length_in_feet that takes bridge_id and returns its length in feet.",
    "id": 225
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_book_title_by_review_rank that accepts a single input parameter p_rank of type NUMBER and returns a VARCHAR2 value, where the function's logic is to query the database to retrieve a book title based on a specific review ranking; the function declares a local variable v_title of type VARCHAR2 with a maximum length of 255 characters to hold the result, then executes a SELECT statement that fetches a value into v_title from the TITLE column of the BOOK table, using a subquery in the WHERE clause to determine which book to select; the subquery selects a BOOK_ID from the REVIEW table where the RANK column exactly matches the input parameter p_rank, and this BOOK_ID value is then used in the outer query's condition BOOK.BOOK_ID = (subquery result) to locate the corresponding book record; after the SELECT INTO operation populates v_title, the function returns the value stored in v_title as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_title_by_review_rank(p_rank IN NUMBER) RETURN VARCHAR2\nIS\n    v_title VARCHAR2(255);\nBEGIN\n    SELECT TITLE INTO v_title FROM BOOK WHERE BOOK_ID = (SELECT BOOK_ID FROM REVIEW WHERE RANK = p_rank);\n    RETURN v_title;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_book_title_by_review_rank(16) FROM dual",
      "SELECT get_book_title_by_review_rank(25) FROM dual",
      "SELECT get_book_title_by_review_rank(26) FROM dual",
      "SELECT get_book_title_by_review_rank(10) FROM dual",
      "SELECT get_book_title_by_review_rank(20) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_book_title_by_review_rank that accepts a rank number and returns the title of the book with a review matching that rank.",
    "natural_language": "Develop a PL/SQL function, which should be named get_book_title_by_review_rank, that is designed to take a single input parameter representing a specific rank number; this function must then meticulously retrieve and return the precise title of the book which possesses a review that has been assigned the exact rank provided.",
    "id": 226
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_review_details_by_book_id that accepts a single input parameter p_book_id of type NUMBER, which represents the unique identifier of a book. The function retrieves data from the REVIEW table, specifically selecting the RATING and READERS_IN_MILLION columns for the row where the BOOK_ID column matches the provided p_book_id parameter. The selected values are stored in local variables v_rating and v_readers, both of type NUMBER. The function then constructs a string by concatenating the text 'Rating: ', the string representation of v_rating, ', Readers: ', the string representation of v_readers, and the word ' million'. This concatenated string is returned as the function's result, providing a formatted summary of the book's rating and the number of readers in millions.",
    "plsql": "CREATE OR REPLACE FUNCTION get_review_details_by_book_id(p_book_id IN NUMBER) RETURN VARCHAR2\nIS\n    v_rating NUMBER;\n    v_readers NUMBER;\nBEGIN\n    SELECT RATING, READERS_IN_MILLION INTO v_rating, v_readers FROM REVIEW WHERE BOOK_ID = p_book_id;\n    RETURN 'Rating: ' || TO_CHAR(v_rating) || ', Readers: ' || TO_CHAR(v_readers) || ' million';\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_review_details_by_book_id(1) FROM DUAL",
      "SELECT get_review_details_by_book_id(2) FROM DUAL",
      "SELECT get_review_details_by_book_id(3) FROM DUAL",
      "SELECT get_review_details_by_book_id(4) FROM DUAL",
      "SELECT get_review_details_by_book_id(10) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_review_details_by_book_id that accepts a book_id number and returns a formatted string containing the book's rating and readers in millions.",
    "natural_language": "Write a PL/SQL function called get_review_details_by_book_id that takes a book_id and gives back a string with the book's general rating and how many millions of people have read it, formatted nicely.",
    "id": 227
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_book_audio_length_by_review_id that accepts a single input parameter p_review_id of the NUMBER data type and returns a value of the VARCHAR2 data type, where the function's purpose is to retrieve the audio length information for a book based on a specific review identifier, and the function's logic begins by declaring a local variable v_audio of type VARCHAR2 with a maximum length of 255 characters to hold the result, then executes a SELECT statement that performs a nested subquery, first querying the REVIEW table to obtain the BOOK_ID value from the row where the REVIEW_ID column matches the provided input parameter p_review_id, and then using that retrieved BOOK_ID value to query the BOOK table, selecting the value from the AUDIO column in the row where the BOOK_ID column equals the value obtained from the subquery, and storing this selected AUDIO value into the local variable v_audio, and finally the function returns the content of the v_audio variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_audio_length_by_review_id(p_review_id IN NUMBER) RETURN VARCHAR2\nIS\n    v_audio VARCHAR2(255);\nBEGIN\n    SELECT AUDIO INTO v_audio FROM BOOK WHERE BOOK_ID = (SELECT BOOK_ID FROM REVIEW WHERE REVIEW_ID = p_review_id);\n    RETURN v_audio;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_book_audio_length_by_review_id(1) FROM DUAL",
      "SELECT get_book_audio_length_by_review_id(2) FROM DUAL",
      "SELECT get_book_audio_length_by_review_id(3) FROM DUAL",
      "SELECT get_book_audio_length_by_review_id(10) FROM DUAL",
      "SELECT get_book_audio_length_by_review_id(100) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_book_audio_length_by_review_id that accepts a review_id number and returns the audio length for the book associated with that review.",
    "natural_language": "Write a PL/SQL function called get_book_audio_length_by_review_id that takes a review_id number as input and outputs the audio length of the related book.",
    "id": 228
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_book_release_by_review_rank` that is designed to retrieve the release information of a book based on a provided review rank. This function accepts one input parameter: `p_rank`, which is of data type `NUMBER` and represents the specific rank of a review used to identify the book. The function is declared to return a value of data type `VARCHAR2` with a maximum length of 255 characters, which will represent the release information of the identified book. Inside the function's executable block, a local variable named `v_release` is declared, also of data type `VARCHAR2` with a maximum length of 255 characters, to temporarily store the retrieved release information. The core operation involves a `SELECT` statement that retrieves data from the `BOOK` table. Specifically, it selects the value from the `RELEASE` column of the `BOOK` table. The `INTO v_release` clause directs the result of this selection into the `v_release` local variable. The `WHERE` clause of this outer `SELECT` statement specifies the condition for row selection: `BOOK_ID = (SELECT BOOK_ID FROM REVIEW WHERE RANK = p_rank)`. This `WHERE` clause contains a nested subquery. The inner subquery `(SELECT BOOK_ID FROM REVIEW WHERE RANK = p_rank)` first queries the `REVIEW` table. It selects the `BOOK_ID` from the `REVIEW` table where the `RANK` column matches the value provided by the input parameter `p_rank`. This subquery is expected to return a single `BOOK_ID`. The outer `SELECT` statement then uses this `BOOK_ID` to find the corresponding row in the `BOOK` table and retrieve its `RELEASE` value. Finally, after the `SELECT` statement has executed and populated `v_release`, the function returns the value stored in `v_release` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_release_by_review_rank(p_rank IN NUMBER) RETURN VARCHAR2\nIS\n    v_release VARCHAR2(255);\nBEGIN\n    SELECT RELEASE INTO v_release FROM BOOK WHERE BOOK_ID = (SELECT BOOK_ID FROM REVIEW WHERE RANK = p_rank);\n    RETURN v_release;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_book_release_by_review_rank(16) FROM DUAL",
      "SELECT get_book_release_by_review_rank(25) FROM DUAL",
      "SELECT get_book_release_by_review_rank(26) FROM DUAL",
      "SELECT get_book_release_by_review_rank(10) FROM DUAL",
      "SELECT get_book_release_by_review_rank(50) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_book_release_by_review_rank` that returns the book's release information (as VARCHAR2) for a given review rank (input NUMBER).",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_book_release_by_review_rank`? It should spit out the book's release info as a VARCHAR2 string when you give it a review rank number.",
    "id": 229
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_review_rank_by_book_title that accepts a single input parameter p_title of type VARCHAR2, which represents the title of a book, and returns a value of type NUMBER; the function declares a local variable v_rank of type NUMBER; the function's execution block begins by performing a SELECT statement that retrieves a value from the RANK column of the REVIEW table; this SELECT statement uses a WHERE clause with the condition BOOK_ID = (subquery result); the subquery is a nested SELECT statement that retrieves the BOOK_ID from the BOOK table where the TITLE column exactly matches the value of the input parameter p_title; the result of this subquery, a single BOOK_ID, is used to filter the outer SELECT from the REVIEW table; the value retrieved from the REVIEW.RANK column is assigned into the local variable v_rank; the function then concludes by using a RETURN statement to output the value stored in v_rank.",
    "plsql": "CREATE OR REPLACE FUNCTION get_review_rank_by_book_title(p_title IN VARCHAR2) RETURN NUMBER\nIS\n    v_rank NUMBER;\nBEGIN\n    SELECT RANK INTO v_rank FROM REVIEW WHERE BOOK_ID = (SELECT BOOK_ID FROM BOOK WHERE TITLE = p_title);\n    RETURN v_rank;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_review_rank_by_book_title('A Game of Thrones') FROM dual",
      "SELECT get_review_rank_by_book_title('A Clash of Kings') FROM dual",
      "SELECT get_review_rank_by_book_title('A Storm of Swords') FROM dual",
      "SELECT get_review_rank_by_book_title('A Feast for Crows') FROM dual",
      "SELECT get_review_rank_by_book_title('A Dance with Dragons') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_review_rank_by_book_title` that returns the review rank (as NUMBER) for a given book title (input VARCHAR2).",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_review_rank_by_book_title`? It should spit out the review rank (as a NUMBER) when you give it a book title (as a VARCHAR2 input).",
    "id": 230
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_name that accepts a single input parameter, p_customer_id, of type NUMBER, which represents the unique identifier of a customer. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_customer_name of type VARCHAR2 with a maximum length of 255 characters to store the full name of the customer. The function executes a SELECT statement to retrieve the concatenated first and last name of the customer from the CUSTOMERS table. Specifically, it selects the CUSTOMER_FIRST_NAME column concatenated with a space and the CUSTOMER_LAST_NAME column, and assigns the result to the v_customer_name variable. The SELECT statement includes a WHERE clause that filters the rows based on the condition that the CUSTOMER_ID column matches the value of the input parameter p_customer_id. After successfully retrieving the customer's full name, the function returns the value stored in v_customer_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_name(p_customer_id NUMBER) RETURN VARCHAR2 IS\n  v_customer_name VARCHAR2(255);\nBEGIN\n  SELECT CUSTOMER_FIRST_NAME || ' ' || CUSTOMER_LAST_NAME\n  INTO v_customer_name\n  FROM CUSTOMERS\n  WHERE CUSTOMER_ID = p_customer_id;\n  RETURN v_customer_name;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_customer_name(1) FROM DUAL",
      "SELECT get_customer_name(5) FROM DUAL",
      "SELECT get_customer_name(7) FROM DUAL",
      "SELECT get_customer_name(10) FROM DUAL",
      "SELECT get_customer_name(2) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_customer_name` that returns the customer's full name (as VARCHAR2) for a given customer ID (input NUMBER).",
    "natural_language": "How can I create a PL/SQL function called `get_customer_name` that will return a customer's full name as a VARCHAR2 when provided with a customer ID as a NUMBER input?",
    "id": 231
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_price that accepts a single input parameter p_product_id of the NUMBER data type, which is used to identify a specific product, and returns a value of the NUMBER data type; the function declares a local variable v_product_price of the NUMBER data type; within its execution block, it performs a SELECT operation on the PRODUCTS table, specifically retrieving the value from the UNIT_PRICE column for the single row where the PRODUCT_ID column value exactly matches the provided input parameter p_product_id, and stores the retrieved value into the local variable v_product_price; the function then concludes by returning the value stored in v_product_price.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price(p_product_id NUMBER) RETURN NUMBER IS\n  v_product_price NUMBER;\nBEGIN\n  SELECT UNIT_PRICE\n  INTO v_product_price\n  FROM PRODUCTS\n  WHERE PRODUCT_ID = p_product_id;\n  RETURN v_product_price;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_product_price(1) FROM DUAL",
      "SELECT get_product_price(2) FROM DUAL",
      "SELECT get_product_price(3) FROM DUAL",
      "SELECT get_product_price(10) FROM DUAL",
      "SELECT get_product_price(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_product_price` that returns a product's unit price (as NUMBER) for a given product ID (input NUMBER).",
    "natural_language": "Write a PL/SQL function called `get_product_price` that gives back a number representing what a product generally costs per unit when you provide its ID number.",
    "id": 232
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_order_date that accepts a single parameter, p_order_id, which is of type NUMBER and represents the unique identifier of an order. The function is designed to return a value of type VARCHAR2, specifically the date on which the order was placed. Within the function, a local variable v_order_date of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the date retrieved from the database. The function executes a SELECT statement to fetch the DATE_ORDER_PLACED column from the ORDERS table, where the ORDER_ID column matches the value provided in the p_order_id parameter. The result of this query is stored in the v_order_date variable. Finally, the function returns the value stored in v_order_date, which represents the date the specified order was placed.",
    "plsql": "CREATE OR REPLACE FUNCTION get_order_date(p_order_id NUMBER) RETURN VARCHAR2 IS\n  v_order_date VARCHAR2(255);\nBEGIN\n  SELECT DATE_ORDER_PLACED\n  INTO v_order_date\n  FROM ORDERS\n  WHERE ORDER_ID = p_order_id;\n  RETURN v_order_date;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_order_date(1) FROM dual",
      "SELECT get_order_date(2) FROM dual",
      "SELECT get_order_date(3) FROM dual",
      "SELECT get_order_date(10) FROM dual",
      "SELECT get_order_date(15) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_order_date` that returns the order date (as VARCHAR2) for a given order ID (input NUMBER).",
    "natural_language": "Please construct a PL/SQL function, designated as `get_order_date`, which accepts an order ID of the NUMBER data type as its input parameter and returns the corresponding order date, formatted as a VARCHAR2 data type.",
    "id": 233
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_invoice_date that accepts a single input parameter p_invoice_number of type NUMBER, which represents the identifier for an invoice, and returns a value of type VARCHAR2. The function declares a local variable v_invoice_date of type VARCHAR2 with a maximum length of 255 characters to hold the result. The function executes a SELECT statement that retrieves the value from the INVOICE_DATE column in the INVOICES table, specifically for the row where the INVOICE_NUMBER column exactly matches the value provided in the input parameter p_invoice_number, and stores the retrieved value into the local variable v_invoice_date. The function then returns the value stored in v_invoice_date.",
    "plsql": "CREATE OR REPLACE FUNCTION get_invoice_date(p_invoice_number NUMBER) RETURN VARCHAR2 IS\n  v_invoice_date VARCHAR2(255);\nBEGIN\n  SELECT INVOICE_DATE\n  INTO v_invoice_date\n  FROM INVOICES\n  WHERE INVOICE_NUMBER = p_invoice_number;\n  RETURN v_invoice_date;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_invoice_date(1) FROM DUAL",
      "SELECT get_invoice_date(2) FROM DUAL",
      "SELECT get_invoice_date(3) FROM DUAL",
      "SELECT get_invoice_date(9) FROM DUAL",
      "SELECT get_invoice_date(10) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_invoice_date that accepts an invoice number (NUMBER) and returns the corresponding invoice date (VARCHAR2) from the INVOICES table.",
    "natural_language": "Write a PL/SQL function to get the invoice date as a string. It should take an invoice number and fetch the date from the INVOICES table for that invoice.",
    "id": 234
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_account_name` that is designed to retrieve the name of an account based on its unique identifier. This function accepts a single input parameter, `p_account_id`, which is of the `NUMBER` data type and represents the primary key or unique identifier for an account record. The function is declared to return a value of the `VARCHAR2` data type, specifically a string of up to 255 characters, which will be the name of the account. Internally, the function declares a local variable named `v_account_name`, also of the `VARCHAR2(255)` data type, to temporarily store the retrieved account name. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `ACCOUNTS` table, specifically selecting the value from the `ACCOUNT_NAME` column. The retrieved `ACCOUNT_NAME` value is then immediately stored into the `v_account_name` local variable using the `INTO` clause. The selection of the row from the `ACCOUNTS` table is constrained by a `WHERE` clause, which specifies that only the row where the `ACCOUNT_ID` column's value is equal to the value passed in the `p_account_id` input parameter should be considered. After successfully retrieving the `ACCOUNT_NAME` into `v_account_name`, the function concludes by returning the value stored in `v_account_name` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_account_name(p_account_id NUMBER) RETURN VARCHAR2 IS\n  v_account_name VARCHAR2(255);\nBEGIN\n  SELECT ACCOUNT_NAME\n  INTO v_account_name\n  FROM ACCOUNTS\n  WHERE ACCOUNT_ID = p_account_id;\n  RETURN v_account_name;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_account_name(1) FROM DUAL",
      "SELECT get_account_name(2) FROM DUAL",
      "SELECT get_account_name(3) FROM DUAL",
      "SELECT get_account_name(10) FROM DUAL",
      "SELECT get_account_name(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_account_name that accepts an account ID (NUMBER) and returns the corresponding account name (VARCHAR2) from the ACCOUNTS table.",
    "natural_language": "Function get_account_name: input account ID (NUMBER), output account name (VARCHAR2) from ACCOUNTS.",
    "id": 235
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_department_name that accepts a single parameter, p_dept_id, which is of type NUMBER and represents the unique identifier for a department. The function is designed to return a value of type VARCHAR2, specifically the name of the department associated with the provided department ID. Within the function, a local variable v_dept_name of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the department name. The function executes a SELECT statement that retrieves the DEPARTMENT_NAME from the DEPARTMENTS table, where the DEPARTMENT_ID column matches the value of the input parameter p_dept_id. The retrieved department name is stored into the local variable v_dept_name using the INTO clause. After successfully obtaining the department name, the function returns the value stored in v_dept_name, effectively providing the caller with the name of the department corresponding to the specified department ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_name(p_dept_id NUMBER) RETURN VARCHAR2 IS\n    v_dept_name VARCHAR2(255);\nBEGIN\n    SELECT DEPARTMENT_NAME INTO v_dept_name FROM DEPARTMENTS WHERE DEPARTMENT_ID = p_dept_id;\n    RETURN v_dept_name;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "SELECT get_department_name(10) FROM DUAL",
      "SELECT get_department_name(20) FROM DUAL",
      "SELECT get_department_name(30) FROM DUAL",
      "SELECT get_department_name(90) FROM DUAL",
      "SELECT get_department_name(110) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_department_name that accepts a department ID (NUMBER) and returns the corresponding department name (VARCHAR2) from the DEPARTMENTS table.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_department_name'. This function shall receive a department ID, of the NUMBER data type, as its input parameter. Its purpose is to retrieve and return the associated department name, as a VARCHAR2, by querying the DEPARTMENTS table.",
    "id": 236
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_employee_email that accepts a single parameter, p_emp_id, which is of type NUMBER and represents the unique identifier of an employee. The function is designed to return a value of type VARCHAR2, specifically the email address associated with the employee whose ID matches the provided p_emp_id. Within the function, a local variable v_email of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the email address retrieved from the database. The function executes a SELECT statement that targets the EMAIL column within the EMPLOYEES table, using the condition WHERE EMPLOYEE_ID = p_emp_id to filter the results and ensure that only the email address of the employee with the specified ID is selected. The result of this query is assigned to the v_email variable using the INTO clause. Finally, the function returns the value stored in v_email, effectively providing the email address of the employee identified by the input parameter p_emp_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_email(p_emp_id NUMBER) RETURN VARCHAR2 IS\n    v_email VARCHAR2(255);\nBEGIN\n    SELECT EMAIL INTO v_email FROM EMPLOYEES WHERE EMPLOYEE_ID = p_emp_id;\n    RETURN v_email;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "SELECT get_employee_email(100) FROM dual",
      "SELECT get_employee_email(101) FROM dual",
      "SELECT get_employee_email(102) FROM dual",
      "SELECT get_employee_email(103) FROM dual",
      "SELECT get_employee_email(104) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_employee_email that accepts an employee ID (NUMBER) and returns the corresponding email address (VARCHAR2) from the EMPLOYEES table.",
    "natural_language": "Write a function get_employee_email to return an employee's email from EMPLOYEES given their ID.",
    "id": 237
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_job_title that accepts a single input parameter p_job_id of type VARCHAR2, and returns a value of type VARCHAR2. The function declares a local variable v_job_title of type VARCHAR2 with a maximum length of 255 characters. The function's execution block performs a SELECT operation on the JOBS table, specifically retrieving the value from the JOB_TITLE column for the single row where the JOB_ID column value exactly matches the value provided in the input parameter p_job_id. The retrieved JOB_TITLE value is stored into the local variable v_job_title. The function then concludes by returning the value stored in v_job_title.",
    "plsql": "CREATE OR REPLACE FUNCTION get_job_title(p_job_id VARCHAR2) RETURN VARCHAR2 IS\n    v_job_title VARCHAR2(255);\nBEGIN\n    SELECT JOB_TITLE INTO v_job_title FROM JOBS WHERE JOB_ID = p_job_id;\n    RETURN v_job_title;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "SELECT get_job_title('AD_PRES') FROM DUAL",
      "SELECT get_job_title('AD_VP') FROM DUAL",
      "SELECT get_job_title('AD_ASST') FROM DUAL",
      "SELECT get_job_title('IT_PROG') FROM DUAL",
      "SELECT get_job_title('AC_ACCOUNT') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_job_title that accepts a job ID (VARCHAR2) and returns the corresponding job title (VARCHAR2) from the JOBS table.",
    "natural_language": "Write a PL/SQL function called get_job_title that takes a job ID (VARCHAR2) as input and fetches the matching job title (VARCHAR2) from the JOBS table.",
    "id": 238
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_location_city` that accepts a single input parameter, `p_location_id`, which is of data type `NUMBER`. The purpose of this function is to retrieve the city name associated with a specific location ID from the `LOCATIONS` table. Inside the function's executable block, a local variable `v_city` of data type `VARCHAR2` with a maximum length of 255 characters is declared to temporarily store the retrieved city name. The function then performs a `SELECT` operation to fetch the value from the `CITY` column. This `SELECT` statement targets the `LOCATIONS` table and includes a `WHERE` clause to filter the results, ensuring that only the row where the `LOCATION_ID` column matches the value provided by the `p_location_id` input parameter is considered. The retrieved `CITY` value is then immediately assigned to the `v_city` variable using the `INTO` clause. Finally, the function returns the value stored in the `v_city` variable, which represents the city name corresponding to the input `p_location_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_location_city(p_location_id NUMBER) RETURN VARCHAR2 IS\n    v_city VARCHAR2(255);\nBEGIN\n    SELECT CITY INTO v_city FROM LOCATIONS WHERE LOCATION_ID = p_location_id;\n    RETURN v_city;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "SELECT get_location_city(1000) FROM dual",
      "SELECT get_location_city(1100) FROM dual",
      "SELECT get_location_city(1200) FROM dual",
      "SELECT get_location_city(1700) FROM dual",
      "SELECT get_location_city(1800) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_location_city` that accepts a `p_location_id` (NUMBER) and returns the corresponding city name (VARCHAR2) from the `CITY` column of the `LOCATIONS` table.",
    "natural_language": "Please construct a PL/SQL function designated as `get_location_city`. This function shall receive a single numeric input parameter, `p_location_id`, and is required to return a VARCHAR2 value. The function's logic must query the `LOCATIONS` table to retrieve and output the value found in the `CITY` column that corresponds to the provided location identifier.",
    "id": 239
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_employee_salary that accepts a single input parameter, p_emp_id, which is of type NUMBER and represents the unique identifier of an employee. The function is designed to return a value of type NUMBER, which corresponds to the salary of the specified employee. Within the function, a local variable v_salary of type NUMBER is declared to temporarily store the salary value retrieved from the database. The function begins by executing a SELECT statement that queries the EMPLOYEES table, specifically targeting the SALARY column. The query includes a WHERE clause that filters the results to only include the row where the EMPLOYEE_ID column matches the value provided in the p_emp_id parameter. The result of this query, which is the salary of the employee with the specified EMPLOYEE_ID, is assigned to the v_salary variable using the INTO clause. After successfully retrieving the salary, the function concludes by returning the value stored in v_salary, thereby providing the caller with the salary of the employee identified by the input parameter p_emp_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_salary(p_emp_id NUMBER) RETURN NUMBER IS\n    v_salary NUMBER;\nBEGIN\n    SELECT SALARY INTO v_salary FROM EMPLOYEES WHERE EMPLOYEE_ID = p_emp_id;\n    RETURN v_salary;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "SELECT get_employee_salary(100) FROM DUAL",
      "SELECT get_employee_salary(101) FROM DUAL",
      "SELECT get_employee_salary(102) FROM DUAL",
      "SELECT get_employee_salary(999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_employee_salary` that accepts a `p_emp_id` (NUMBER) and returns the corresponding salary (NUMBER) from the `SALARY` column of the `EMPLOYEES` table.",
    "natural_language": "Write a PL/SQL function to fetch the salary figure for a given employee. The function should take an employee identifier and return the pay amount from the employees data, focusing on entries that seem to match well.",
    "id": 240
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_rent_arrears` that accepts a single input parameter named `master_customer_id` of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `total_arrears` of data type `NUMBER` to temporarily store the calculated sum. The core operation of this function involves executing a `SELECT` statement to retrieve data. Specifically, it calculates the `SUM` of the values in the `COUNCIL_TAX_ID` column. This summation is performed on rows retrieved from two tables: `RENT_ARREARS`, aliased as `ra`, and `CMI_CROSS_REFERENCES`, aliased as `ccr`. These two tables are joined using an `INNER JOIN` operation. The join condition specifies that rows from `RENT_ARREARS` and `CMI_CROSS_REFERENCES` are matched when the value in the `CMI_CROSS_REF_ID` column of the `RENT_ARREARS` table is equal to the value in the `CMI_CROSS_REF_ID` column of the `CMI_CROSS_REFERENCES` table. Furthermore, a `WHERE` clause is applied to filter the joined results. This condition ensures that only rows where the value in the `MASTER_CUSTOMER_ID` column of the `CMI_CROSS_REFERENCES` table is equal to the value passed into the function via the `master_customer_id` input parameter are considered for the summation. The calculated `SUM` of `COUNCIL_TAX_ID` values, based on these join and filter conditions, is then stored into the `total_arrears` local variable. Finally, the function returns the value currently held in the `total_arrears` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_rent_arrears(master_customer_id IN NUMBER) RETURN NUMBER IS\n  total_arrears NUMBER;\nBEGIN\n  SELECT SUM(COUNCIL_TAX_ID)\n  INTO total_arrears\n  FROM RENT_ARREARS ra\n  JOIN CMI_CROSS_REFERENCES ccr ON ra.CMI_CROSS_REF_ID = ccr.CMI_CROSS_REF_ID\n  WHERE ccr.MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN total_arrears;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_total_rent_arrears(1) FROM dual",
      "SELECT get_total_rent_arrears(2) FROM dual",
      "SELECT get_total_rent_arrears(3) FROM dual",
      "SELECT get_total_rent_arrears(4) FROM dual",
      "SELECT get_total_rent_arrears(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_total_rent_arrears` that accepts a `master_customer_id` (NUMBER) and returns the sum of `COUNCIL_TAX_ID` (NUMBER) by joining the `RENT_ARREARS` and `CMI_CROSS_REFERENCES` tables where their `CMI_CROSS_REF_ID` columns match and the `MASTER_CUSTOMER_ID` equals the input parameter.",
    "natural_language": "Calculate the total rent arrears for a specific master customer. Write a PL/SQL function called `get_total_rent_arrears` that takes a `master_customer_id` number as input, joins the `RENT_ARREARS` and `CMI_CROSS_REFERENCES` tables on their matching `CMI_CROSS_REF_ID`, filters for the given customer ID, and returns the sum of the `COUNCIL_TAX_ID` values.",
    "id": 241
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_benefits_overpayments_count that accepts a single input parameter named master_customer_id of the NUMBER data type and returns a value of the NUMBER data type; the function declares a local variable named overpayments_count of the NUMBER data type; the function executes a SELECT statement that performs a COUNT(*) operation on the result of an inner join between the BENEFITS_OVERPAYMENTS table (aliased as bo) and the CMI_CROSS_REFERENCES table (aliased as ccr) where the join condition specifies that the CMI_CROSS_REF_ID column from the BENEFITS_OVERPAYMENTS table must equal the CMI_CROSS_REF_ID column from the CMI_CROSS_REFERENCES table; the SELECT statement includes a WHERE clause that filters the joined result set to only those rows where the MASTER_CUSTOMER_ID column from the CMI_CROSS_REFERENCES table is equal to the input parameter master_customer_id; the result of the COUNT(*) operation is stored into the local variable overpayments_count; the function then returns the value stored in the overpayments_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_benefits_overpayments_count(master_customer_id IN NUMBER) RETURN NUMBER IS\n  overpayments_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO overpayments_count\n  FROM BENEFITS_OVERPAYMENTS bo\n  JOIN CMI_CROSS_REFERENCES ccr ON bo.CMI_CROSS_REF_ID = ccr.CMI_CROSS_REF_ID\n  WHERE ccr.MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN overpayments_count;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_benefits_overpayments_count(1) FROM dual",
      "SELECT get_benefits_overpayments_count(2) FROM dual",
      "SELECT get_benefits_overpayments_count(3) FROM dual",
      "SELECT get_benefits_overpayments_count(4) FROM dual",
      "SELECT get_benefits_overpayments_count(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_benefits_overpayments_count` that accepts a `master_customer_id` (NUMBER) and returns the count of records (NUMBER) from an inner join of the `BENEFITS_OVERPAYMENTS` and `CMI_CROSS_REFERENCES` tables where their `CMI_CROSS_REF_ID` columns match and the `MASTER_CUSTOMER_ID` equals the input parameter.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_benefits_overpayments_count`? It should take a `master_customer_id` (as a NUMBER) and spit back how many records it finds. That count comes from linking the `BENEFITS_OVERPAYMENTS` and `CMI_CROSS_REFERENCES` tables together where their `CMI_CROSS_REF_ID` columns are the same, but only for the specific customer ID we give it.",
    "id": 242
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_council_tax that accepts a single input parameter, master_customer_id, of type NUMBER, which represents the unique identifier for a master customer. The function calculates and returns a NUMBER representing the average value of the COUNCIL_TAX_ID column from the COUNCIL_TAX table. This calculation is performed by executing a SELECT statement that computes the average of the COUNCIL_TAX_ID values. The SELECT statement involves a JOIN operation between the COUNCIL_TAX table and the CMI_CROSS_REFERENCES table, using the CMI_CROSS_REF_ID column as the joining key. The JOIN condition ensures that only those rows from the COUNCIL_TAX table are considered where the CMI_CROSS_REF_ID matches the corresponding CMI_CROSS_REF_ID in the CMI_CROSS_REFERENCES table. Additionally, the WHERE clause filters the results to include only those rows where the MASTER_CUSTOMER_ID column in the CMI_CROSS_REFERENCES table matches the input parameter master_customer_id. The result of the average calculation is stored in a local variable named avg_council_tax, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_council_tax(master_customer_id IN NUMBER) RETURN NUMBER IS\n  avg_council_tax NUMBER;\nBEGIN\n  SELECT AVG(COUNCIL_TAX_ID)\n  INTO avg_council_tax\n  FROM COUNCIL_TAX ct\n  JOIN CMI_CROSS_REFERENCES ccr ON ct.CMI_CROSS_REF_ID = ccr.CMI_CROSS_REF_ID\n  WHERE ccr.MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN avg_council_tax;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_average_council_tax(1) FROM DUAL",
      "SELECT get_average_council_tax(2) FROM DUAL",
      "SELECT get_average_council_tax(3) FROM DUAL",
      "SELECT get_average_council_tax(4) FROM DUAL",
      "SELECT get_average_council_tax(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_average_council_tax` that accepts a `master_customer_id` (NUMBER) and returns the average value of `COUNCIL_TAX_ID` (NUMBER) from the `COUNCIL_TAX` table, joined with `CMI_CROSS_REFERENCES` on `CMI_CROSS_REF_ID`, filtered by the input `MASTER_CUSTOMER_ID`.",
    "natural_language": "Please construct a PL/SQL function designated as `get_average_council_tax`. This function should accept a single numeric parameter, `master_customer_id`, and return the computed average of the `COUNCIL_TAX_ID` column, which is of the NUMBER data type. The average is to be derived from the `COUNCIL_TAX` table, which must be joined with the `CMI_CROSS_REFERENCES` table using the `CMI_CROSS_REF_ID` column as the join condition. The data set must be filtered such that only records corresponding to the provided `MASTER_CUSTOMER_ID` input parameter are considered in the calculation.",
    "id": 243
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_cmi_cross_ref that accepts a single input parameter, master_customer_id, of type NUMBER, which represents the identifier of a master customer. The function is designed to return a value of type NUMBER. Within the function, a local variable named total_cross_ref of type NUMBER is declared to store the result of a query. The function executes a SELECT statement that counts the total number of rows in the CMI_CROSS_REFERENCES table where the column MASTER_CUSTOMER_ID matches the value of the input parameter master_customer_id. The result of this COUNT operation is stored in the total_cross_ref variable. Finally, the function returns the value of total_cross_ref, which represents the total number of cross-references associated with the specified master customer ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_cmi_cross_ref(master_customer_id IN NUMBER) RETURN NUMBER IS\n  total_cross_ref NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO total_cross_ref\n  FROM CMI_CROSS_REFERENCES\n  WHERE MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN total_cross_ref;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_total_cmi_cross_ref(1) FROM DUAL",
      "SELECT get_total_cmi_cross_ref(2) FROM DUAL",
      "SELECT get_total_cmi_cross_ref(3) FROM DUAL",
      "SELECT get_total_cmi_cross_ref(4) FROM DUAL",
      "SELECT get_total_cmi_cross_ref(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_cmi_cross_ref that accepts a master_customer_id (NUMBER) and returns a NUMBER. The function should count and return the number of rows in the CMI_CROSS_REFERENCES table where the MASTER_CUSTOMER_ID column matches the input parameter.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_total_cmi_cross_ref'. This function must accept a single input parameter of the NUMBER data type, specifically a master_customer_id, and is required to return a value of the NUMBER data type. The function's logic shall query the CMI_CROSS_REFERENCES table, count the number of records where the MASTER_CUSTOMER_ID column corresponds to the provided input parameter, and subsequently return this computed count.",
    "id": 244
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_customer_master_index` that accepts a single input parameter, `master_customer_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `total_index` of data type `NUMBER`. The core operation of the function involves performing a `SELECT` statement to count the total number of rows in the `CUSTOMER_MASTER_INDEX` table. This count is specifically filtered by a `WHERE` clause, which ensures that only rows where the value in the `MASTER_CUSTOMER_ID` column of the `CUSTOMER_MASTER_INDEX` table is equal to the value passed in the `master_customer_id` input parameter are included in the count. The result of this `COUNT(*)` aggregation is then stored into the `total_index` local variable. Finally, the function returns the value currently held by the `total_index` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_customer_master_index(master_customer_id IN NUMBER) RETURN NUMBER IS\n  total_index NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO total_index\n  FROM CUSTOMER_MASTER_INDEX\n  WHERE MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN total_index;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_total_customer_master_index(1) FROM DUAL",
      "SELECT get_total_customer_master_index(2) FROM DUAL",
      "SELECT get_total_customer_master_index(3) FROM DUAL",
      "SELECT get_total_customer_master_index(4) FROM DUAL",
      "SELECT get_total_customer_master_index(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_customer_master_index that accepts a master_customer_id (NUMBER) and returns a NUMBER. The function should count and return the number of rows in the CUSTOMER_MASTER_INDEX table where the MASTER_CUSTOMER_ID column equals the input parameter.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_total_customer_master_index'. This function must be defined to accept a single input parameter of the NUMBER data type, specifically a master_customer_id, and must return a value of the NUMBER data type. The function's logic shall compute and yield the aggregate count of records residing within the CUSTOMER_MASTER_INDEX table for which the value in the MASTER_CUSTOMER_ID column is equivalent to the provided input argument.",
    "id": 245
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_department_ranking that accepts a single input parameter, p_department_id, of type NUMBER, which represents the unique identifier of a department. The function is designed to return a value of type NUMBER. Within the function, a local variable v_ranking of type NUMBER is declared to temporarily store the ranking value of the specified department. The function performs a SELECT operation on the DEPARTMENT table, specifically retrieving the RANKING column value for the row where the DEPARTMENT_ID column matches the input parameter p_department_id. The retrieved RANKING value is then assigned to the local variable v_ranking. Finally, the function returns the value stored in v_ranking, which represents the ranking of the department identified by the given department ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_ranking(p_department_id NUMBER) RETURN NUMBER IS\n  v_ranking NUMBER;\nBEGIN\n  SELECT RANKING INTO v_ranking FROM DEPARTMENT WHERE DEPARTMENT_ID = p_department_id;\n  RETURN v_ranking;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT get_department_ranking(1) FROM DUAL",
      "SELECT get_department_ranking(2) FROM DUAL",
      "SELECT get_department_ranking(3) FROM DUAL",
      "SELECT get_department_ranking(10) FROM DUAL",
      "SELECT get_department_ranking(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_department_ranking that accepts a p_department_id (NUMBER) and returns a NUMBER. The function should retrieve and return the value from the RANKING column in the DEPARTMENT table where the DEPARTMENT_ID matches the input parameter.",
    "natural_language": "Write a PL/SQL function called get_department_ranking that takes a department ID number and gives back a number. It should fetch and return the ranking figure from the DEPARTMENT table for the department that sort of matches the given ID.",
    "id": 246
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_head_age_category` that accepts a single input parameter, `p_head_id`, which is of data type `NUMBER` and represents the unique identifier for a head record. This function is designed to return a `VARCHAR2` value, specifically a string indicating the age category of the head. Upon execution, the function first declares two local variables: `v_category` of type `VARCHAR2` with a maximum length of 20 characters, intended to store the calculated age category, and `v_age` of type `NUMBER`, intended to store the age retrieved from the database. The core logic begins by executing a `SELECT` statement to retrieve the `AGE` column value from the `HEAD` table. This retrieval is conditional, specifically targeting the row where the `HEAD_ID` column matches the value provided by the input parameter `p_head_id`. The retrieved `AGE` value is then immediately stored into the local variable `v_age`. Following this data retrieval, the function proceeds with a conditional `IF` statement. It evaluates whether the value stored in `v_age` is less than 65. If this condition (`v_age < 65`) evaluates to `TRUE`, the local variable `v_category` is assigned the string literal 'Young'. Conversely, if the condition evaluates to `FALSE` (meaning `v_age` is 65 or greater), the `ELSE` block is executed, and `v_category` is assigned the string literal 'Senior'. Finally, after the appropriate age category has been determined and assigned to `v_category`, the function returns the value stored in `v_category` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_head_age_category(p_head_id NUMBER) RETURN VARCHAR2 IS\n  v_category VARCHAR2(20);\n  v_age NUMBER;\nBEGIN\n  SELECT AGE INTO v_age FROM HEAD WHERE HEAD_ID = p_head_id;\n  IF v_age < 65 THEN v_category := 'Young'; ELSE v_category := 'Senior'; END IF;\n  RETURN v_category;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT calculate_head_age_category(1) FROM DUAL",
      "SELECT calculate_head_age_category(2) FROM DUAL",
      "SELECT calculate_head_age_category(3) FROM DUAL",
      "SELECT calculate_head_age_category(4) FROM DUAL",
      "SELECT calculate_head_age_category(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_head_age_category that accepts a p_head_id (NUMBER) and returns a VARCHAR2. The function should retrieve the AGE from the HEAD table for the given ID. If the age is less than 65, return 'Young'; otherwise, return 'Senior'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called calculate_head_age_category? It needs to take a p_head_id (that's a NUMBER) and spit back a VARCHAR2. Basically, it should grab the AGE from the HEAD table for that ID. If the person's under 65, call 'em 'Young'; otherwise, just tag 'em as 'Senior'.",
    "id": 247
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_management_status` that accepts a single input parameter, `p_department_id`, which is of data type `NUMBER` and represents the unique identifier for a department. This function is designed to return a `VARCHAR2` value, specifically a string of up to 3 characters, representing the temporary acting status of management for the specified department.\n\nThe function begins by declaring a local variable named `v_status` of data type `VARCHAR2` with a maximum length of 3 characters.\n\nThe core operation of the function involves a `SELECT` statement that attempts to retrieve data from the `MANAGEMENT` table. Specifically, it selects the value from the `TEMPORARY_ACTING` column and stores it into the `v_status` variable. This selection is constrained by two conditions in the `WHERE` clause:\n1. `DEPARTMENT_ID = p_department_id`: This condition filters the rows to include only those where the value in the `DEPARTMENT_ID` column matches the value provided in the `p_department_id` input parameter.\n2. `ROWNUM = 1`: This condition further restricts the result set to return only the first row encountered that satisfies the `DEPARTMENT_ID` condition. This is a common technique to ensure that the `SELECT INTO` statement retrieves at most one row, preventing a `TOO_MANY_ROWS` exception if multiple matching records exist.\n\nAfter the `SELECT` statement, the function proceeds to `RETURN` the value currently stored in the `v_status` variable.\n\nThe function includes an `EXCEPTION` handling block to gracefully manage potential runtime errors:\n1. `WHEN NO_DATA_FOUND THEN`: If the `SELECT` statement does not find any rows that satisfy the specified `WHERE` clause conditions (i.e., no management record exists for the given `p_department_id`), this exception handler is invoked. In this case, the function will `RETURN NULL`.\n2. `WHEN TOO_MANY_ROWS THEN`: Although the `ROWNUM = 1` condition is intended to prevent this, if for some reason the `SELECT INTO` statement attempts to retrieve more than one row (e.g., if `ROWNUM = 1` was not present or if the query was structured differently), this exception handler would be invoked. In this case, the function will also `RETURN NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_management_status(p_department_id NUMBER) RETURN VARCHAR2 IS\n  v_status VARCHAR2(3);\nBEGIN\n  SELECT TEMPORARY_ACTING INTO v_status \n  FROM MANAGEMENT \n  WHERE DEPARTMENT_ID = p_department_id \n  AND ROWNUM = 1;\n  \n  RETURN v_status;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    RETURN NULL;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT get_management_status(1) FROM DUAL",
      "SELECT get_management_status(2) FROM DUAL",
      "SELECT get_management_status(3) FROM DUAL",
      "SELECT get_management_status(15) FROM DUAL",
      "SELECT get_management_status(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_management_status that accepts a p_department_id (NUMBER) and returns a VARCHAR2(3). The function should retrieve the TEMPORARY_ACTING status from the MANAGEMENT table for the given department ID, returning only the first matching row. If no data is found or too many rows are found, return NULL.",
    "natural_language": "Write a PL/SQL function called get_management_status that takes a p_department_id (NUMBER) and gives back a VARCHAR2(3). Fetch the TEMPORARY_ACTING status from the MANAGEMENT table for that department ID, returning just the first matching row. If no data is found or too many rows are found, return NULL.",
    "id": 248
  },
  {
    "ir": "Write an Oracle PL/SQL function named extract_department_year that accepts a single parameter p_department_id of type NUMBER, which represents the unique identifier of a department. The function is designed to return a NUMBER representing the year extracted from the CREATION column of the DEPARTMENT table for the specified department. The function begins by declaring a local variable v_year of type NUMBER to store the extracted year. Within the function's execution block, a SELECT statement is used to retrieve the year from the CREATION column, which is assumed to be a date stored as a string in the format 'YYYY'. The TO_DATE function is applied to convert the CREATION string into a date format, and the EXTRACT function is then used to obtain the year component from this date. The result is stored in the v_year variable. The SELECT statement includes a WHERE clause that filters the DEPARTMENT table based on the DEPARTMENT_ID column, ensuring that only the row matching the provided p_department_id is considered. After successfully retrieving the year, the function returns the value stored in v_year.",
    "plsql": "CREATE OR REPLACE FUNCTION extract_department_year(p_department_id NUMBER) RETURN NUMBER IS\n  v_year NUMBER;\nBEGIN\n  SELECT EXTRACT(YEAR FROM TO_DATE(CREATION, 'YYYY')) INTO v_year FROM DEPARTMENT WHERE DEPARTMENT_ID = p_department_id;\n  RETURN v_year;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT extract_department_year(1) FROM DUAL",
      "SELECT extract_department_year(2) FROM DUAL",
      "SELECT extract_department_year(3) FROM DUAL",
      "SELECT extract_department_year(10) FROM DUAL",
      "SELECT extract_department_year(99) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named extract_department_year that takes a department ID number and returns the year extracted from the CREATION date column for that department.",
    "natural_language": "Write a PL/SQL function called extract_department_year that accepts a department ID number and gives back the year taken from the CREATION date column for that specific department.",
    "id": 249
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_head_state_abbrev` that accepts a single input parameter, `p_head_id`, which is of data type `NUMBER`. This function is designed to retrieve and return a `VARCHAR2` value representing the two-character abbreviation of the birth state for a specific head record. Internally, the function declares a local variable named `v_abbrev` of type `VARCHAR2` with a maximum length of 2 characters to temporarily store the retrieved state abbreviation. The core operation involves executing a `SELECT` statement to query the `HEAD` table. This `SELECT` statement specifically retrieves the first two characters of the `BORN_STATE` column's value by utilizing the `SUBSTR` string function, where `SUBSTR(BORN_STATE, 1, 2)` extracts a substring starting from the first position and having a length of two characters. The result of this substring extraction is then immediately assigned to the `v_abbrev` local variable. The `WHERE` clause of the `SELECT` statement filters the records in the `HEAD` table, ensuring that only the row where the `HEAD_ID` column's value matches the input parameter `p_head_id` is considered. Finally, the function returns the value stored in the `v_abbrev` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_head_state_abbrev(p_head_id NUMBER) RETURN VARCHAR2 IS\n  v_abbrev VARCHAR2(2);\nBEGIN\n  SELECT SUBSTR(BORN_STATE, 1, 2) INTO v_abbrev FROM HEAD WHERE HEAD_ID = p_head_id;\n  RETURN v_abbrev;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT get_head_state_abbrev(1) FROM DUAL",
      "SELECT get_head_state_abbrev(2) FROM DUAL",
      "SELECT get_head_state_abbrev(3) FROM DUAL",
      "SELECT get_head_state_abbrev(HEAD_ID) FROM HEAD WHERE HEAD_ID = 4",
      "SELECT NAME, get_head_state_abbrev(HEAD_ID) AS STATE_ABBREV FROM HEAD WHERE AGE > 67"
    ],
    "summary": "Create a PL/SQL function named get_head_state_abbrev that takes a head ID number and returns the two-character abbreviation from the BORN_STATE column for that head record.",
    "natural_language": "Write a PL/SQL function called get_head_state_abbrev that accepts a head ID number and gives back the two-letter state abbreviation from the BORN_STATE column for that head.",
    "id": 250
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_catalog_price_difference that accepts two parameters: p_catalog_entry_id of type NUMBER, which represents the unique identifier for a catalog entry, and p_currency of type VARCHAR2, which specifies the currency code ('USD' or 'EUR'). The function returns a NUMBER representing the price difference between the catalog entry's price in dollars and euros. Inside the function, declare three local variables: v_price_dollars, v_price_euros, and v_result, all of type NUMBER. Execute a SELECT statement to retrieve the PRICE_IN_DOLLARS and PRICE_IN_EUROS columns from the CATALOG_CONTENTS table where the CATALOG_ENTRY_ID matches the provided p_catalog_entry_id, storing the results in v_price_dollars and v_price_euros respectively. Use the UPPER() function to convert the p_currency parameter to uppercase for case-insensitive comparison. Implement conditional logic using IF-ELSIF-ELSE statements: if p_currency is 'USD', calculate the difference by subtracting v_price_euros from v_price_dollars and assign the result to v_result; if p_currency is 'EUR', calculate the difference by subtracting v_price_dollars from v_price_euros and assign the result to v_result; if p_currency is neither 'USD' nor 'EUR', set v_result to NULL. Return v_result as the function's output. Handle exceptions using an EXCEPTION block: if a NO_DATA_FOUND exception occurs, indicating no matching catalog entry, return NULL; if a TOO_MANY_ROWS exception occurs, indicating multiple matching entries, return NULL.",
    "plsql": "CREATE OR REPLACE FUNCTION get_catalog_price_difference(p_catalog_entry_id NUMBER, p_currency VARCHAR2) RETURN NUMBER IS\n    v_price_dollars NUMBER;\n    v_price_euros   NUMBER;\n    v_result        NUMBER;\nBEGIN\n    SELECT PRICE_IN_DOLLARS, PRICE_IN_EUROS\n      INTO v_price_dollars, v_price_euros\n      FROM CATALOG_CONTENTS\n     WHERE CATALOG_ENTRY_ID = p_catalog_entry_id;\n\n    IF UPPER(p_currency) = 'USD' THEN\n        v_result := v_price_dollars - v_price_euros;\n    ELSIF UPPER(p_currency) = 'EUR' THEN\n        v_result := v_price_euros - v_price_dollars;\n    ELSE\n        v_result := NULL;\n    END IF;\n\n    RETURN v_result;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN TOO_MANY_ROWS THEN\n        RETURN NULL;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT get_catalog_price_difference(1, 'USD') FROM DUAL",
      "SELECT get_catalog_price_difference(2, 'EUR') FROM DUAL",
      "SELECT get_catalog_price_difference(3, 'USD') FROM DUAL",
      "SELECT get_catalog_price_difference(5, 'EUR') FROM DUAL",
      "SELECT get_catalog_price_difference(15, 'GBP') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_catalog_price_difference that takes a catalog entry ID and a currency code ('USD' or 'EUR'), and returns the price difference between dollars and euros for that entry. Return NULL for invalid currency or if no/multiple entries are found.",
    "natural_language": "Function get_catalog_price_difference: takes catalog ID and currency ('USD'/'EUR'), returns USD-EUR price difference. Return NULL for invalid currency or no/multiple matches.",
    "id": 251
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_catalog_volume that takes two input parameters: a NUMBER parameter named p_entry_id and a NUMBER parameter named p_multiplier, and returns a NUMBER value. The function begins by declaring four local NUMBER variables: v_length, v_height, v_width, and v_volume. It then executes a SELECT statement to query the CATALOG_CONTENTS table, retrieving the values from the columns named \"LENGTH\", \"HEIGHT\", and \"WIDTH\" for the specific row where the CATALOG_ENTRY_ID column matches the input parameter p_entry_id. For each of these three retrieved column values, the function uses the TO_NUMBER function with the format model '999999.99' to explicitly convert the column's string value into a numeric data type, and then wraps this conversion in an NVL function to substitute a value of 0 if the conversion results in a NULL. These three processed values are assigned into the local variables v_length, v_height, and v_width, respectively. The function then calculates the volume by multiplying the values stored in v_length, v_height, and v_width together and then multiplying that product by the input parameter p_multiplier, storing the final result in the v_volume variable. The function returns this calculated v_volume value. If any exception occurs during the execution of the SELECT statement, the data conversion, or the calculation, the function's EXCEPTION block with the WHEN OTHERS clause catches the error and causes the function to return a value of 0 instead.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_catalog_volume(p_entry_id NUMBER, p_multiplier NUMBER) RETURN NUMBER IS\n  v_length NUMBER;\n  v_height NUMBER;\n  v_width NUMBER;\n  v_volume NUMBER;\nBEGIN\n  SELECT NVL(TO_NUMBER(\"LENGTH\", '999999.99'), 0),\n         NVL(TO_NUMBER(\"HEIGHT\", '999999.99'), 0),\n         NVL(TO_NUMBER(\"WIDTH\", '999999.99'), 0)\n  INTO v_length, v_height, v_width\n  FROM CATALOG_CONTENTS\n  WHERE CATALOG_ENTRY_ID = p_entry_id;\n\n  v_volume := v_length * v_height * v_width * p_multiplier;\n  RETURN v_volume;\n\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN 0; -- Return 0 or handle the error as needed\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT calculate_catalog_volume(1, 1.5) FROM dual",
      "SELECT calculate_catalog_volume(2, 2.0) FROM dual",
      "SELECT calculate_catalog_volume(3, 0.5) FROM dual",
      "SELECT calculate_catalog_volume(1, 3.0) FROM dual",
      "SELECT calculate_catalog_volume(2, 1.2) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_catalog_volume that takes a catalog entry ID and a multiplier, calculates the volume from LENGTH, HEIGHT, and WIDTH columns (converted to number with NULL as 0), multiplies by the multiplier, and returns the result. Return 0 on any error.",
    "natural_language": "How can I create a PL/SQL function called calculate_catalog_volume that accepts a catalog entry ID and a multiplier, computes the volume using the LENGTH, HEIGHT, and WIDTH columns (treating NULL as 0 after conversion to number), multiplies that volume by the given multiplier, and then returns the final result, while ensuring it returns 0 if any error occurs?",
    "id": 252
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_attribute_count_by_type that accepts two input parameters: a VARCHAR2 parameter named p_data_type, which specifies the data type to filter on, and a NUMBER parameter named p_min_id, which specifies the minimum ID threshold. The function returns a NUMBER. The function declares a local NUMBER variable v_count and initializes it to 0. The function executes a SELECT statement that performs a COUNT(*) operation on the ATTRIBUTE_DEFINITIONS table. The query counts all rows where the column ATTRIBUTE_DATA_TYPE exactly matches the value of the p_data_type parameter and where the column ATTRIBUTE_ID is greater than or equal to the value of the p_min_id parameter. The result of this count is stored into the local variable v_count. The function then returns the value of v_count. If any exception occurs during the execution of the SELECT statement or the return operation, the function's EXCEPTION block with the WHEN OTHERS clause catches the exception and causes the function to return the value 0 instead.",
    "plsql": "CREATE OR REPLACE FUNCTION get_attribute_count_by_type(p_data_type VARCHAR2, p_min_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER := 0;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM ATTRIBUTE_DEFINITIONS\n    WHERE ATTRIBUTE_DATA_TYPE = p_data_type\n      AND ATTRIBUTE_ID >= p_min_id;\n    \n    RETURN v_count;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN 0;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT get_attribute_count_by_type('Bool', 1) FROM DUAL",
      "SELECT get_attribute_count_by_type('VARCHAR2', 2) FROM DUAL",
      "SELECT get_attribute_count_by_type('NUMBER', 3) FROM DUAL",
      "SELECT get_attribute_count_by_type('Bool', 10) FROM DUAL",
      "SELECT get_attribute_count_by_type('VARCHAR2', 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_attribute_count_by_type that takes a data type string and a minimum ID number, counts rows in ATTRIBUTE_DEFINITIONS where ATTRIBUTE_DATA_TYPE matches and ATTRIBUTE_ID is >= the minimum, and returns the count. Return 0 on any error.",
    "natural_language": "Count ATTRIBUTE_DEFINITIONS rows by data type and minimum ID. Return 0 on error.",
    "id": 253
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_catalog_level_name that accepts two parameters: p_catalog_id of type NUMBER, which represents the identifier of a catalog, and p_level_number of type NUMBER, which indicates the level number within the catalog. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_catalog_level_name with the same data type as the CATALOG_LEVEL_NAME column in the CATALOG_STRUCTURE table. Execute a SELECT statement to retrieve the CATALOG_LEVEL_NAME from the CATALOG_STRUCTURE table where the CATALOG_ID matches the value of p_catalog_id and the CATALOG_LEVEL_NUMBER matches the value of p_level_number, storing the result in v_catalog_level_name. Return the value of v_catalog_level_name. Handle exceptions by returning NULL if no data is found, which occurs when the SELECT statement does not retrieve any rows, or if too many rows are found, which would be unexpected if CATALOG_LEVEL_NUMBER is a primary key and the combination of p_catalog_id and p_level_number is unique.",
    "plsql": "CREATE OR REPLACE FUNCTION get_catalog_level_name(p_catalog_id NUMBER, p_level_number NUMBER) RETURN VARCHAR2 IS\n    v_catalog_level_name CATALOG_STRUCTURE.CATALOG_LEVEL_NAME%TYPE;\nBEGIN\n    SELECT CATALOG_LEVEL_NAME\n    INTO v_catalog_level_name\n    FROM CATALOG_STRUCTURE\n    WHERE CATALOG_ID = p_catalog_id\n      AND CATALOG_LEVEL_NUMBER = p_level_number;\n\n    RETURN v_catalog_level_name;\n\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL; -- Or raise an application-specific error\n    WHEN TOO_MANY_ROWS THEN\n        -- This case should ideally not happen if CATALOG_LEVEL_NUMBER is a primary key\n        -- and the combination of p_catalog_id and p_level_number is unique.\n        -- However, it's good practice to handle it.\n        RETURN NULL; -- Or raise an application-specific error\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT get_catalog_level_name(1, 1) FROM DUAL",
      "SELECT get_catalog_level_name(2, 8) FROM DUAL",
      "SELECT get_catalog_level_name(8, 9) FROM DUAL",
      "SELECT get_catalog_level_name(p_catalog_id => 1, p_level_number => 1) FROM DUAL",
      "SELECT CATALOG_NAME, get_catalog_level_name(CATALOG_ID, 1) AS LEVEL_NAME FROM CATALOGS WHERE CATALOG_ID = 1"
    ],
    "summary": "Create a PL/SQL function named get_catalog_level_name that returns a VARCHAR2. It accepts a catalog ID and a level number as NUMBER parameters. The function retrieves the catalog level name from the CATALOG_STRUCTURE table where the ID and level number match the inputs. Return NULL if no data is found or if too many rows are found.",
    "natural_language": "How can I create a PL/SQL function called get_catalog_level_name that returns a VARCHAR2, taking a catalog ID and a level number as NUMBER parameters, to retrieve the catalog level name from the CATALOG_STRUCTURE table where the ID and level number match, and return NULL if no data or too many rows are found?",
    "id": 254
  },
  {
    "ir": "Write an Oracle PL/SQL function named `format_catalog_publisher` that accepts two input parameters: `p_catalog_id`, which is of data type `NUMBER` and represents the unique identifier for a catalog entry, and `p_max_length`, which is also of data type `NUMBER` and specifies the maximum desired length for the catalog publisher string. This function is designed to return a `VARCHAR2` value, representing a potentially truncated version of the catalog publisher's name. Upon execution, the function declares a local variable `v_catalog_publisher` of type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved publisher's name. The core operation involves a `SELECT` statement that queries the `CATALOGS` table. Specifically, it retrieves the value from the `CATALOG_PUBLISHER` column and stores it into the `v_catalog_publisher` variable. This retrieval is conditional, based on a `WHERE` clause that matches the `CATALOG_ID` column in the `CATALOGS` table with the value provided by the `p_catalog_id` input parameter. After successfully fetching the `CATALOG_PUBLISHER`, the function then returns a substring of `v_catalog_publisher`. The `SUBSTR` function is used to extract characters from the first position (index 1) up to the length specified by the `p_max_length` input parameter. The function includes an exception handling block to manage potential errors during the data retrieval process. If a `NO_DATA_FOUND` exception occurs, indicating that no row in the `CATALOGS` table matched the provided `p_catalog_id`, the function will return `NULL`. Similarly, if a `TOO_MANY_ROWS` exception occurs, implying that more than one row in the `CATALOGS` table matched the `p_catalog_id` (which should ideally not happen if `CATALOG_ID` is a primary key or unique identifier), the function will also return `NULL`. Finally, a general `OTHERS` exception handler is included to catch any other unforeseen errors during execution, in which case the function will also return `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION format_catalog_publisher(p_catalog_id NUMBER, p_max_length NUMBER) RETURN VARCHAR2 IS\n    v_catalog_publisher VARCHAR2(255);\nBEGIN\n    SELECT CATALOG_PUBLISHER \n    INTO v_catalog_publisher\n    FROM CATALOGS \n    WHERE CATALOG_ID = p_catalog_id;\n\n    RETURN SUBSTR(v_catalog_publisher, 1, p_max_length);\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN TOO_MANY_ROWS THEN\n        RETURN NULL;\n    WHEN OTHERS THEN\n        RETURN NULL;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT format_catalog_publisher(1, 10) FROM DUAL",
      "SELECT format_catalog_publisher(2, 5) FROM DUAL",
      "SELECT format_catalog_publisher(3, 20) FROM DUAL",
      "SELECT format_catalog_publisher(1, 255) FROM DUAL",
      "SELECT format_catalog_publisher(99, 15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named format_catalog_publisher that returns a VARCHAR2. It accepts a catalog ID and a maximum length as NUMBER parameters. The function retrieves the publisher name from the CATALOGS table for the given ID, truncates it to the specified maximum length, and returns the result. Return NULL if no data is found, if too many rows are found, or if any other error occurs.",
    "natural_language": "Make a function 'format_catalog_publisher' returning VARCHAR2. It takes catalog ID and max length (NUMBER). Get the publisher from CATALOGS for that ID, trim to max length, and return it. Return NULL for no data, multiple rows, or any error.",
    "id": 255
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_payments that takes no parameters and returns a single numeric value, which is the sum of all values in the AMOUNT_PAYMENT column from every row in the CUSTOMER_PAYMENTS table, performing a SELECT SUM(AMOUNT_PAYMENT) query to calculate this total, storing the result into a local variable v_total of type NUMBER, and then returning that sum, but if the query result is null, which occurs when the CUSTOMER_PAYMENTS table is empty or all AMOUNT_PAYMENT values are null, the function uses the NVL function to convert the null v_total to zero before returning it, thereby ensuring a numeric zero is always returned instead of a null value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_payments RETURN NUMBER IS\n    v_total NUMBER;\nBEGIN\n    SELECT SUM(AMOUNT_PAYMENT) INTO v_total FROM CUSTOMER_PAYMENTS;\n    RETURN NVL(v_total, 0);\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "ADDRESSES",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_total_payments FROM DUAL",
      "SELECT get_total_payments() FROM DUAL",
      "DECLARE\n  total NUMBER;\nBEGIN\n  total := get_total_payments;\n  DBMS_OUTPUT.PUT_LINE('Total Payments: ' || total);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total: ' || get_total_payments);\nEND;",
      "SELECT get_total_payments AS total_amount FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_payments that returns a NUMBER and takes no parameters. It calculates the sum of all AMOUNT_PAYMENT values from the CUSTOMER_PAYMENTS table. The function returns 0 if the sum is NULL or the table is empty.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_total_payments? It doesn't need any inputs and should spit out a NUMBER. Basically, it's gotta add up all the AMOUNT_PAYMENT numbers from the CUSTOMER_PAYMENTS table. Oh, and if there's nothing to add up or the total comes back as null, just have it return a zero.",
    "id": 256
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_count_by_status that takes no input parameters and returns a single output parameter of type SYS_REFCURSOR, which is a reference cursor used to return a result set to the caller. The function declares a local variable named v_cursor of type SYS_REFCURSOR. Within the execution block, the function opens the v_cursor reference cursor for a specific SQL query. This query performs a SELECT operation on the CUSTOMERS table, retrieving two columns: the CUSTOMER_STATUS_CODE column and a derived column aliased as customer_count, which is the result of the COUNT(*) aggregate function. The query includes a GROUP BY clause that groups all rows from the CUSTOMERS table based on the values in the CUSTOMER_STATUS_CODE column. Consequently, for each distinct value found in the CUSTOMER_STATUS_CODE column, the query calculates and returns the total number of customer records associated with that status code. The function then returns the opened v_cursor reference cursor, thereby providing the caller with a handle to the result set containing the aggregated customer counts per status code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_count_by_status RETURN SYS_REFCURSOR IS\n    v_cursor SYS_REFCURSOR;\nBEGIN\n    OPEN v_cursor FOR SELECT CUSTOMER_STATUS_CODE, COUNT(*) AS customer_count FROM CUSTOMERS GROUP BY CUSTOMER_STATUS_CODE;\n    RETURN v_cursor;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "ADDRESSES",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n  v_cursor SYS_REFCURSOR;\nBEGIN\n  v_cursor := get_customer_count_by_status;\n  -- Process the cursor as needed\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_customer_count_by_status that returns a SYS_REFCURSOR and takes no parameters. It opens a cursor for a query that groups records in the CUSTOMERS table by status code and returns the status code and the count of customers for each status.",
    "natural_language": "How can I create a PL/SQL function called get_customer_count_by_status that returns a SYS_REFCURSOR, takes no parameters, opens a cursor to group records in the CUSTOMERS table by status code, and returns each status code with its customer count?",
    "id": 257
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_lesson_revenue that returns a NUMBER data type, which begins by declaring a local variable v_revenue of type NUMBER, then executes a SELECT statement that queries the LESSONS table to calculate the sum of all values in the PRICE column, but only for rows where the LESSON_STATUS_CODE column does not equal the string literal 'Cancelled', storing the result of this aggregation into the local variable v_revenue, and finally returns the value of v_revenue, but uses the NVL function to convert a potential NULL result from the SUM operation into the numeric value 0 for the return.",
    "plsql": "CREATE OR REPLACE FUNCTION get_lesson_revenue RETURN NUMBER IS\n    v_revenue NUMBER;\nBEGIN\n    SELECT SUM(PRICE) INTO v_revenue FROM LESSONS WHERE LESSON_STATUS_CODE != 'Cancelled';\n    RETURN NVL(v_revenue, 0);\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "ADDRESSES",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_lesson_revenue FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_lesson_revenue that returns a NUMBER and takes no parameters. It calculates the sum of the PRICE column from the LESSONS table for all lessons where the status is not 'Cancelled'. The function returns 0 if the sum is NULL.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_lesson_revenue? It doesn't need any inputs and should spit out a NUMBER. Basically, it's gotta add up all the PRICE from the LESSONS table, but only for lessons that didn't get cancelled. If there's nothing to add up, just have it return a zero.",
    "id": 258
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_staff_with_formatted_names` that is designed to return a `SYS_REFCURSOR` data type, which is a pointer to a result set. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_cursor` of type `SYS_REFCURSOR`. The core operation involves opening this `v_cursor` to execute a `SELECT` statement. This `SELECT` statement retrieves data from the `STAFF` table. Specifically, it selects the `STAFF_ID` column directly. It also constructs a new computed column aliased as `display_name`. This `display_name` is created by concatenating several components: first, the value from the `FIRST_NAME` column is padded on the right with the hyphen character (`-`) until it reaches a total length of 15 characters using the `RPAD` function; then, a single space character (` `) is appended; finally, the value from the `LAST_NAME` column is padded on the right with the asterisk character (`*`) until it reaches a total length of 15 characters, also using the `RPAD` function. After the `SELECT` statement is executed and the result set is populated into `v_cursor`, the function returns this `v_cursor` to the caller, allowing the caller to fetch rows from the generated result set.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_with_formatted_names RETURN SYS_REFCURSOR IS\n    v_cursor SYS_REFCURSOR;\nBEGIN\n    OPEN v_cursor FOR SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF;\n    RETURN v_cursor;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "ADDRESSES",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n    v_cursor SYS_REFCURSOR;\n    v_staff_id STAFF.STAFF_ID%TYPE;\n    v_display_name VARCHAR2(255);\nBEGIN\n    v_cursor := get_staff_with_formatted_names();\n    LOOP\n        FETCH v_cursor INTO v_staff_id, v_display_name;\n        EXIT WHEN v_cursor%NOTFOUND;\n        DBMS_OUTPUT.PUT_LINE('Staff ID: ' || v_staff_id || ', Display Name: ' || v_display_name);\n    END LOOP;\n    CLOSE v_cursor;\nEND;",
      "DECLARE\n    v_cursor SYS_REFCURSOR;\n    v_staff_id STAFF.STAFF_ID%TYPE;\n    v_display_name VARCHAR2(255);\nBEGIN\n    v_cursor := get_staff_with_formatted_names();\n    FETCH v_cursor INTO v_staff_id, v_display_name;\n    DBMS_OUTPUT.PUT_LINE('First Staff: ' || v_display_name);\n    CLOSE v_cursor;\nEND;",
      "SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF WHERE STAFF_ID = 1",
      "SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF WHERE FIRST_NAME = 'Janessa'",
      "SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF WHERE LAST_NAME = 'Sawayn'"
    ],
    "summary": "Create a PL/SQL function named get_staff_with_formatted_names that returns a SYS_REFCURSOR. The function selects STAFF_ID and a computed display_name from the STAFF table. The display_name concatenates RPAD(FIRST_NAME, 15, '-'), a space, and RPAD(LAST_NAME, 15, '*').",
    "natural_language": "Write a PL/SQL function that fetches a list of staff members. It should return a cursor. For each person, get their ID and a nicely formatted name. The name should be put together by taking the first name, padding it out to a decent length with some dashes, adding a space, and then doing something similar with the last name but using asterisks to fill it out to a good width.",
    "id": 259
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_movie_title_length that accepts a single input parameter p_mid of type NUMBER, which represents the movie ID. The function is designed to return a NUMBER that indicates the length of the movie title. Inside the function, declare a local variable v_title_length of type NUMBER to store the length of the movie title. Execute a SELECT statement to retrieve the length of the title from the movie table, where the mid column matches the input parameter p_mid. Use the LENGTH function to calculate the number of characters in the title column, and store this value in the v_title_length variable. Finally, return the value of v_title_length as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_title_length(p_mid IN NUMBER) RETURN NUMBER IS\n   v_title_length NUMBER;\nBEGIN\n   SELECT LENGTH(title) INTO v_title_length FROM movie WHERE mid = p_mid;\n   RETURN v_title_length;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_title_length(101) FROM dual",
      "SELECT get_movie_title_length(102) FROM dual",
      "SELECT get_movie_title_length(103) FROM dual",
      "SELECT get_movie_title_length(mid) FROM movie WHERE title = 'Star Wars'",
      "SELECT m.mid, get_movie_title_length(m.mid) FROM movie m WHERE m.year = 1939"
    ],
    "summary": "Create a PL/SQL function named get_movie_title_length that accepts a NUMBER parameter p_mid and returns a NUMBER. The function selects the LENGTH of the title from the movie table where mid equals p_mid and returns this value.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_movie_title_length'. This function should accept a single numeric parameter, 'p_mid', and yield a numeric return value. Its operational logic is to query the 'movie' table, retrieve the LENGTH of the title for the record whose 'mid' matches the provided parameter, and subsequently return that computed length.",
    "id": 260
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_reviewer_name_length that accepts a single input parameter p_rid of type NUMBER, which represents a reviewer identifier, and returns a value of type NUMBER. The function declares a local variable v_name_length of type NUMBER. The function's execution block performs a SELECT query on the reviewer table, specifically retrieving the character length of the value in the name column by applying the LENGTH function to it. The query includes a WHERE clause condition that filters rows to only the one where the rid column value is equal to the input parameter p_rid. The result of this LENGTH(name) calculation is stored into the local variable v_name_length. The function then concludes by returning the value stored in v_name_length.",
    "plsql": "CREATE OR REPLACE FUNCTION get_reviewer_name_length(p_rid IN NUMBER) RETURN NUMBER IS\n   v_name_length NUMBER;\nBEGIN\n   SELECT LENGTH(name) INTO v_name_length FROM reviewer WHERE rid = p_rid;\n   RETURN v_name_length;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_reviewer_name_length(201) FROM dual",
      "SELECT get_reviewer_name_length(202) FROM dual",
      "SELECT get_reviewer_name_length(203) FROM dual",
      "SELECT get_reviewer_name_length(r.rid) FROM reviewer r WHERE r.rid = 201",
      "SELECT r.rid, get_reviewer_name_length(r.rid) AS name_length FROM reviewer r"
    ],
    "summary": "Create a PL/SQL function named get_reviewer_name_length that accepts a NUMBER parameter p_rid and returns a NUMBER. The function selects the LENGTH of the name from the reviewer table where rid equals p_rid and returns this value.",
    "natural_language": "Hey, write me a PL/SQL function called get_reviewer_name_length. It should take in a number parameter p_rid and spit back a number. Basically, it grabs the LENGTH of the name from the reviewer table for the row where rid matches p_rid and returns that length.",
    "id": 261
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_movie_year_status` that accepts a single input parameter, `p_mid`, which is of data type `NUMBER` and represents a movie identifier. This function is designed to return a `VARCHAR2` value, indicating the status of a movie based on its release year. Internally, the function declares two local variables: `v_year` of data type `NUMBER` to store the release year of the movie, and `v_status` of data type `VARCHAR2` with a maximum length of 20 characters to store the calculated status. The function's execution begins by performing a `SELECT` operation to retrieve the `year` column from the `movie` table. This selection is filtered by a `WHERE` clause, ensuring that only the row where the `mid` column matches the value provided in the input parameter `p_mid` is considered. The retrieved `year` value is then immediately assigned to the local variable `v_year`. Following this data retrieval, the function proceeds with a conditional `IF` statement. It evaluates whether the value stored in `v_year` is less than the numeric literal `2000`. If this condition evaluates to `TRUE`, the local variable `v_status` is assigned the string literal `'Classic'`. Conversely, if the condition evaluates to `FALSE` (meaning `v_year` is greater than or equal to `2000`), the `ELSE` block is executed, and `v_status` is assigned the string literal `'Modern'`. Finally, the function concludes its execution by returning the value currently held in the `v_status` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_year_status(p_mid IN NUMBER) RETURN VARCHAR2 IS\n   v_year NUMBER;\n   v_status VARCHAR2(20);\nBEGIN\n   SELECT year INTO v_year FROM movie WHERE mid = p_mid;\n   IF v_year < 2000 THEN\n      v_status := 'Classic';\n   ELSE\n      v_status := 'Modern';\n   END IF;\n   RETURN v_status;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_year_status(101) FROM DUAL",
      "SELECT get_movie_year_status(102) FROM DUAL",
      "SELECT get_movie_year_status(103) FROM DUAL",
      "SELECT get_movie_year_status( (SELECT MID FROM MOVIE WHERE TITLE = 'Star Wars') ) FROM DUAL",
      "SELECT get_movie_year_status( (SELECT MID FROM MOVIE WHERE YEAR = 1939) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_movie_year_status that accepts a NUMBER parameter p_mid and returns a VARCHAR2. The function selects the year from the movie table where mid equals p_mid. If the year is less than 2000, return 'Classic'; otherwise, return 'Modern'.",
    "natural_language": "Develop a PL/SQL function called get_movie_year_status, which is designed to take a single numeric input parameter named p_mid and will output a string of type VARCHAR2. This function should query the movie table to retrieve the specific year associated with the provided movie identifier. In a detailed evaluation, if the retrieved year is determined to be earlier than the year 2000, the function must thoughtfully return the descriptive label 'Classic'; conversely, for any year from 2000 onward, it should appropriately return the label 'Modern'.",
    "id": 262
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_reviewer_activity_status` that accepts a single input parameter, `p_rid`, which is of data type `NUMBER` and represents the unique identifier for a reviewer. This function is designed to return a `VARCHAR2` value, specifically a string of up to 20 characters, indicating the activity status of the reviewer. Internally, the function declares two local variables: `v_stars` of data type `NUMBER` to store the calculated average star rating, and `v_status` of data type `VARCHAR2(20)` to hold the determined activity status. The core logic begins by executing a `SELECT` statement to calculate the average value of the `stars` column from the `rating` table. This average is computed specifically for rows where the `rid` column matches the value provided in the input parameter `p_rid`. The result of this average calculation is then stored into the `v_stars` local variable. Following this, a conditional `IF` statement evaluates the value stored in `v_stars`. If `v_stars` is greater than or equal to `3`, the `v_status` variable is assigned the string literal `'Active'`. Otherwise, if `v_stars` is less than `3`, the `v_status` variable is assigned the string literal `'Inactive'`. Finally, the function concludes by returning the value currently held in the `v_status` variable, which represents the calculated activity status of the reviewer.",
    "plsql": "CREATE OR REPLACE FUNCTION get_reviewer_activity_status(p_rid IN NUMBER) RETURN VARCHAR2 IS\n   v_stars NUMBER;\n   v_status VARCHAR2(20);\nBEGIN\n   SELECT AVG(stars) INTO v_stars FROM rating WHERE rid = p_rid;\n   IF v_stars >= 3 THEN\n      v_status := 'Active';\n   ELSE\n      v_status := 'Inactive';\n   END IF;\n   RETURN v_status;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_reviewer_activity_status(201) FROM dual",
      "SELECT get_reviewer_activity_status(202) FROM dual",
      "SELECT get_reviewer_activity_status(203) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_reviewer_activity_status that accepts a NUMBER parameter p_rid and returns a VARCHAR2(20). The function calculates the AVG(stars) from the rating table where rid equals p_rid. If the average is >= 3, return 'Active'; otherwise, return 'Inactive'.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_reviewer_activity_status'. This function shall accept a single NUMBER parameter, 'p_rid', and yield a VARCHAR2(20) as its return value. The function's logic is to compute the average of the 'stars' column from the 'rating' table, specifically for records where the 'rid' column matches the provided 'p_rid' parameter. Subsequently, if the computed average is greater than or equal to 3, the function must return the string 'Active'; if not, it must return 'Inactive'.",
    "id": 263
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_movie_director_length` that accepts a single input parameter, `p_mid`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The primary purpose of this function is to retrieve the length of the `director` column's string value for a specific movie identified by its `mid`. Inside the function's executable block, a local variable named `v_director_length` of data type `NUMBER` is declared to temporarily store the calculated length. The function then performs a `SELECT` operation on the `movie` table. Specifically, it calculates the length of the string stored in the `director` column using the `LENGTH()` SQL function. This calculated length is then immediately stored into the `v_director_length` variable. The `SELECT` operation includes a `WHERE` clause that filters the rows in the `movie` table, ensuring that only the row where the `mid` column's value matches the value provided in the input parameter `p_mid` is considered. Finally, the function returns the value stored in the `v_director_length` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_director_length(p_mid IN NUMBER) RETURN NUMBER IS\n   v_director_length NUMBER;\nBEGIN\n   SELECT LENGTH(director) INTO v_director_length FROM movie WHERE mid = p_mid;\n   RETURN v_director_length;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_director_length(101) FROM DUAL",
      "SELECT get_movie_director_length(102) FROM DUAL",
      "SELECT get_movie_director_length(103) FROM DUAL",
      "SELECT get_movie_director_length(104) FROM DUAL",
      "SELECT get_movie_director_length(105) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_movie_director_length that accepts a movie ID (p_mid NUMBER) and returns the character length of the director's name from the movie table as a NUMBER.",
    "natural_language": "Write a PL/SQL function called get_movie_director_length. It should take a movie ID and give back a number representing roughly how long the director's name is from the movie records.",
    "id": 264
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_teacher_classroom that accepts two input parameters: a VARCHAR2 parameter named p_lastname representing a teacher's last name and a VARCHAR2 parameter named p_firstname representing a teacher's first name, and returns a NUMBER value. The function declares a local NUMBER variable named v_classroom. The function executes a SELECT statement that queries the TEACHERS table, specifically retrieving the value from the CLASSROOM column, and assigns that value into the local variable v_classroom. The SELECT statement includes a WHERE clause with a compound condition that filters the TEACHERS table rows, requiring that the LASTNAME column exactly matches the value of the p_lastname input parameter and that the FIRSTNAME column exactly matches the value of the p_firstname input parameter. The function then returns the value stored in the v_classroom variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_classroom(p_lastname VARCHAR2, p_firstname VARCHAR2) RETURN NUMBER IS\n    v_classroom NUMBER;\nBEGIN\n    SELECT CLASSROOM INTO v_classroom FROM TEACHERS WHERE LASTNAME = p_lastname AND FIRSTNAME = p_firstname;\n    RETURN v_classroom;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_teacher_classroom('Smith', 'John') FROM dual",
      "SELECT get_teacher_classroom('Johnson', 'Mary') FROM dual",
      "SELECT get_teacher_classroom('Williams', 'David') FROM dual",
      "SELECT get_teacher_classroom('Brown', 'Sarah') FROM dual",
      "SELECT get_teacher_classroom('Davis', 'Michael') FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_teacher_classroom that accepts a teacher's last name and first name (p_lastname VARCHAR2, p_firstname VARCHAR2) and returns the classroom number (NUMBER) for that teacher from the TEACHERS table.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_teacher_classroom'. This function shall accept two input parameters: the teacher's surname (p_lastname VARCHAR2) and given name (p_firstname VARCHAR2). Its purpose is to retrieve and return, as a NUMBER data type, the corresponding classroom number assigned to the specified instructor from the TEACHERS table.",
    "id": 265
  },
  {
    "ir": "Write an Oracle PL/SQL function named format_student_name that accepts two input parameters: p_lastname of type VARCHAR2, which represents a student's last name, and p_firstname of type VARCHAR2, which represents a student's first name, and returns a single VARCHAR2 value; within the function, a local variable v_formatted of type VARCHAR2 with a maximum length of 255 characters is declared; the function's logic assigns a value to v_formatted by first calling the RPAD function on the p_lastname parameter, which right-pads the string with periods ('.') until its total length reaches 20 characters, then concatenates a single space character to this padded last name using the concatenation operator (||), and finally concatenates the p_firstname parameter to the end of that string; the function concludes by returning the value stored in the v_formatted variable.",
    "plsql": "CREATE OR REPLACE FUNCTION format_student_name(p_lastname VARCHAR2, p_firstname VARCHAR2) RETURN VARCHAR2 IS\n    v_formatted VARCHAR2(255);\nBEGIN\n    v_formatted := RPAD(p_lastname, 20, '.') || ' ' || p_firstname;\n    RETURN v_formatted;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT format_student_name('Smith', 'John') FROM dual",
      "SELECT format_student_name('Doe', 'Jane') FROM dual",
      "SELECT format_student_name('Brown', 'Charlie') FROM dual",
      "SELECT format_student_name('Johnson', 'Emily') FROM dual",
      "SELECT format_student_name('Williams', 'Michael') FROM dual"
    ],
    "summary": "Create a PL/SQL function named format_student_name that accepts a last name and first name (p_lastname VARCHAR2, p_firstname VARCHAR2) and returns a VARCHAR2 where the last name is right-padded with periods to 20 characters, followed by a space and the first name.",
    "natural_language": "Develop a PL/SQL function, to be named format_student_name, which takes two input parameters—specifically a last name and a first name, defined as p_lastname VARCHAR2 and p_firstname VARCHAR2—and meticulously returns a single VARCHAR2 string. In this returned string, the provided last name must be extended to a fixed length of twenty characters by appending periods to its right side, after which a single space is inserted, followed finally by the complete first name.",
    "id": 266
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_grade_threshold` that accepts two input parameters: `p_classroom` of data type `NUMBER` which represents a specific classroom identifier, and `p_threshold` of data type `NUMBER` which represents a minimum grade value. The function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_count` of data type `NUMBER`. The core operation of the function involves executing a `SELECT` statement to count the number of rows in the table named `LIST`. This count is performed under two specific conditions: first, the value in the `CLASSROOM` column of the `LIST` table must be equal to the value provided in the `p_classroom` input parameter; and second, the value in the `GRADE` column of the `LIST` table must be strictly greater than the value provided in the `p_threshold` input parameter. The result of this `COUNT(*)` aggregation is then stored into the local variable `v_count`. Finally, the function returns the value currently held by the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION check_grade_threshold(p_classroom NUMBER, p_threshold NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM LIST WHERE CLASSROOM = p_classroom AND GRADE > p_threshold;\n    RETURN v_count;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT check_grade_threshold(101, 85) FROM DUAL",
      "SELECT check_grade_threshold(102, 90) FROM DUAL",
      "SELECT check_grade_threshold(103, 75) FROM DUAL",
      "SELECT check_grade_threshold(104, 80) FROM DUAL",
      "SELECT check_grade_threshold(105, 95) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_grade_threshold that accepts a classroom ID and a grade threshold (p_classroom NUMBER, p_threshold NUMBER) and returns a NUMBER count of records in the LIST table where the classroom matches and the grade exceeds the threshold.",
    "natural_language": "How many records in the LIST table have a classroom matching the given ID and a grade exceeding the specified threshold?",
    "id": 267
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_classroom_teacher_count that accepts a single parameter, p_classroom, of type NUMBER, which represents the classroom identifier. The function is designed to return a NUMBER that indicates the total count of teachers associated with the specified classroom. Within the function, a local variable v_teacher_count of type NUMBER is declared to store the result of the query operation. The function executes a SELECT statement that counts the number of rows in the TEACHERS table where the CLASSROOM column matches the value provided in the p_classroom parameter. The COUNT(*) function is used to determine the total number of teachers assigned to the given classroom, and the result is stored in the v_teacher_count variable. Finally, the function returns the value of v_teacher_count, which represents the number of teachers in the specified classroom.",
    "plsql": "CREATE OR REPLACE FUNCTION get_classroom_teacher_count(p_classroom NUMBER) RETURN NUMBER IS\n    v_teacher_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_teacher_count FROM TEACHERS WHERE CLASSROOM = p_classroom;\n    RETURN v_teacher_count;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_classroom_teacher_count(101) FROM DUAL",
      "SELECT get_classroom_teacher_count(205) FROM DUAL",
      "SELECT get_classroom_teacher_count(312) FROM DUAL",
      "SELECT get_classroom_teacher_count(118) FROM DUAL",
      "SELECT get_classroom_teacher_count(400) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_classroom_teacher_count that accepts a classroom ID (p_classroom NUMBER) and returns a NUMBER count of teachers assigned to that classroom from the TEACHERS table.",
    "natural_language": "Count the number of teachers assigned to a specific classroom by creating a PL/SQL function called get_classroom_teacher_count. The function should take a classroom ID (p_classroom NUMBER) as input and return the count as a NUMBER from the TEACHERS table.",
    "id": 268
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_average_grade that accepts a single input parameter p_classroom of type NUMBER, which represents a specific classroom identifier, and returns a value of type NUMBER. The function declares a local variable v_avg_grade of type NUMBER to store the computed result. The function's logic executes a single SQL SELECT statement that queries the LIST table. This SELECT statement uses the AVG aggregate function on the GRADE column to calculate the arithmetic mean of all GRADE values. The calculation is performed only on rows from the LIST table where the value in the CLASSROOM column is exactly equal to the value passed in the input parameter p_classroom. The result of this AVG(GRADE) calculation is then stored into the local variable v_avg_grade using the INTO clause. Finally, the function returns the value contained in the v_avg_grade variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_grade(p_classroom NUMBER) RETURN NUMBER IS\n    v_avg_grade NUMBER;\nBEGIN\n    SELECT AVG(GRADE) INTO v_avg_grade FROM LIST WHERE CLASSROOM = p_classroom;\n    RETURN v_avg_grade;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT calculate_average_grade(101) FROM dual",
      "SELECT calculate_average_grade(102) FROM dual",
      "SELECT calculate_average_grade(103) FROM dual",
      "SELECT calculate_average_grade(104) FROM dual",
      "SELECT calculate_average_grade(105) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_average_grade that takes a classroom ID (NUMBER) and returns the average GRADE (NUMBER) from the LIST table for that classroom.",
    "natural_language": "Make function calculate_average_grade returning average GRADE from LIST for a given classroom ID.",
    "id": 269
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_building_info_by_institution` that accepts a single input parameter, `institution_name`, of data type `VARCHAR2`. This function is designed to return a `VARCHAR2` value, specifically a string containing building information. Internally, the function declares a local variable named `building_info` of data type `VARCHAR2` with a maximum length of 255 characters, which will be used to store the retrieved building details. The function's execution begins with a conditional check: it evaluates whether the `institution_name` parameter is not null. If `institution_name` is indeed not null, the function proceeds to execute a `SELECT` statement. This `SELECT` statement aims to retrieve and concatenate two column values: the `NAME` column from the `BUILDING` table (aliased as `b`) and the `STREET_ADDRESS` column from the `BUILDING` table (aliased as `b`), separated by a comma and a space. The result of this concatenation is then stored into the `building_info` local variable. The data for this selection is sourced from a `JOIN` operation between two tables: `BUILDING` (aliased as `b`) and `INSTITUTION` (aliased as `i`). The join condition specifies that rows from `BUILDING` and `INSTITUTION` tables are matched where the `BUILDING_ID` column in the `BUILDING` table is equal to the `BUILDING_ID` column in the `INSTITUTION` table. Furthermore, the `SELECT` statement includes a `WHERE` clause to filter the joined results. This `WHERE` clause applies a condition where the lowercase version of the `INSTITUTION` column from the `INSTITUTION` table (obtained using the `LOWER()` function) must be equal to the lowercase version of the input `institution_name` parameter (also obtained using the `LOWER()` function). This ensures a case-insensitive comparison for the institution name. If the initial `IF` condition (checking if `institution_name` is not null) evaluates to false, meaning `institution_name` is null, the `SELECT` statement is skipped, and the `building_info` variable retains its default (likely null) value. Finally, regardless of whether the `SELECT` statement was executed or not, the function returns the current value of the `building_info` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_building_info_by_institution(institution_name VARCHAR2) RETURN VARCHAR2 IS\n  building_info VARCHAR2(255);\nBEGIN\n  IF institution_name IS NOT NULL THEN\n    SELECT b.NAME || ', ' || b.STREET_ADDRESS\n    INTO building_info\n    FROM BUILDING b\n    JOIN INSTITUTION i ON b.BUILDING_ID = i.BUILDING_ID\n    WHERE LOWER(i.INSTITUTION) = LOWER(institution_name);\n  END IF;\n  RETURN building_info;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_building_info_by_institution('Ave Maria University') FROM DUAL",
      "SELECT get_building_info_by_institution('Dakota State University') FROM DUAL",
      "SELECT get_building_info_by_institution('Haskell Indian Nations University') FROM DUAL",
      "SELECT get_building_info_by_institution('University of Tampa') FROM DUAL",
      "SELECT get_building_info_by_institution(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_building_info_by_institution that takes an institution name (VARCHAR2) and returns a concatenated string (VARCHAR2) of building name and street address. Perform a case-insensitive join between BUILDING and INSTITUTION tables. Return NULL if the input is NULL.",
    "natural_language": "Write a PL/SQL function called get_building_info_by_institution that accepts an institution name as a VARCHAR2 parameter and gives back a VARCHAR2 string combining the building name and street address. Use a case-insensitive join on the BUILDING and INSTITUTION tables. If the input is NULL, return NULL.",
    "id": 270
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_institution_type_by_building that accepts a single parameter building_name of type VARCHAR2, which represents the name of a building. The function returns a VARCHAR2 value representing the type of institution associated with the specified building. The function begins by declaring a local variable institution_type of type VARCHAR2 with a maximum length of 255 characters to store the result. The function checks if the building_name parameter is not null. If it is not null, it performs a SELECT operation to retrieve the TYPE column from the INSTITUTION table, joining it with the BUILDING table on the BUILDING_ID column, where the NAME column in the BUILDING table matches the building_name parameter, ignoring case differences by using the LOWER function on both the NAME column and the building_name parameter. The SELECT statement includes a condition to limit the result to the first row using ROWNUM = 1. If the SELECT operation successfully retrieves a row, the TYPE value is stored in the institution_type variable. The function then returns the institution_type variable. If no data is found during the SELECT operation, the NO_DATA_FOUND exception is caught, and the function returns NULL. If the SELECT operation results in TOO_MANY_ROWS, the exception is caught, and the function performs the same SELECT operation again to retrieve the TYPE value from the first row, storing it in the institution_type variable, and then returns this value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_institution_type_by_building(building_name VARCHAR2) RETURN VARCHAR2 IS\n  institution_type VARCHAR2(255);\nBEGIN\n  IF building_name IS NOT NULL THEN\n    SELECT i.TYPE\n    INTO institution_type\n    FROM INSTITUTION i\n    JOIN BUILDING b ON i.BUILDING_ID = b.BUILDING_ID\n    WHERE LOWER(b.NAME) = LOWER(building_name)\n    AND ROWNUM = 1;\n  END IF;\n  RETURN institution_type;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    SELECT i.TYPE\n    INTO institution_type\n    FROM INSTITUTION i\n    JOIN BUILDING b ON i.BUILDING_ID = b.BUILDING_ID\n    WHERE LOWER(b.NAME) = LOWER(building_name)\n    AND ROWNUM = 1;\n    RETURN institution_type;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_institution_type_by_building('Citizens Bank Building') FROM DUAL",
      "SELECT get_institution_type_by_building('Tampa City Hall') FROM DUAL",
      "SELECT get_institution_type_by_building('Floridan Hotel') FROM DUAL",
      "SELECT get_institution_type_by_building('NonExistent Building') FROM DUAL",
      "SELECT get_institution_type_by_building(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_institution_type_by_building that takes a building name (VARCHAR2) and returns the institution TYPE (VARCHAR2). Join BUILDING and INSTITUTION tables with a case-insensitive match on building name, limiting results to one row. Handle NO_DATA_FOUND by returning NULL and TOO_MANY_ROWS by returning the first row's type.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be named get_institution_type_by_building, designed to accept a single input parameter for a building name, specified as a VARCHAR2 data type. This function's primary purpose is to meticulously retrieve and return the associated institution TYPE, also as a VARCHAR2. To accomplish this, you must perform a detailed join operation between the BUILDING and INSTITUTION tables, ensuring a thorough, case-insensitive comparison on the building name column, while explicitly constraining the result set to a maximum of one row. Furthermore, you must implement robust exception handling: gracefully manage a NO_DATA_FOUND exception by returning a NULL value, and carefully address a TOO_MANY_ROWS exception by reliably returning the institution type from just the first row encountered in the result set.",
    "id": 271
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_protein_info_by_institution that accepts a single input parameter named institution_id of type VARCHAR2 and returns a value of type VARCHAR2, where the function's logic begins by declaring a local variable named protein_info of type VARCHAR2 with a maximum length of 255 characters, then proceeds to check if the provided institution_id parameter is not NULL, and if this condition is true, it executes a SELECT query on the PROTEIN table, aliased as p, to concatenate the value from the PROTEIN_NAME column with a space, an opening parenthesis, the value from the ACCESSION_NUMBER column, and a closing parenthesis, using the concatenation operator (||), and it retrieves this concatenated string into the local protein_info variable, but only for a single row where the INSTITUTION_ID column in the PROTEIN table matches the value of the input parameter institution_id, as enforced by the condition ROWNUM = 1 which limits the result set to the first row returned by the query, and after this potential query execution, the function returns the value of the protein_info variable, which will be NULL if the institution_id parameter was NULL or if no matching row was found in the PROTEIN table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_protein_info_by_institution(institution_id VARCHAR2) RETURN VARCHAR2 IS\n  protein_info VARCHAR2(255);\nBEGIN\n  IF institution_id IS NOT NULL THEN\n    SELECT p.PROTEIN_NAME || ' (' || p.ACCESSION_NUMBER || ')'\n    INTO protein_info\n    FROM PROTEIN p\n    WHERE p.INSTITUTION_ID = institution_id\n    AND ROWNUM = 1;\n  END IF;\n  RETURN protein_info;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_protein_info_by_institution('1') FROM DUAL",
      "SELECT get_protein_info_by_institution('3') FROM DUAL",
      "SELECT get_protein_info_by_institution('5') FROM DUAL",
      "SELECT get_protein_info_by_institution('0') FROM DUAL",
      "SELECT get_protein_info_by_institution(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_protein_info_by_institution that takes an institution ID (VARCHAR2) and returns a concatenated string (VARCHAR2) of protein name and accession number from the PROTEIN table. Limit the result to one row where INSTITUTION_ID matches. Return NULL if input is NULL or no match is found.",
    "natural_language": "What is the concatenated string of protein name and accession number from the PROTEIN table for a given institution ID, returning NULL if the input is NULL or no match is found?",
    "id": 272
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_institution_enrollment_by_building` that accepts a single input parameter named `building_id` of data type `VARCHAR2`. This function is designed to return a single value of data type `NUMBER`, representing the total enrollment across all institutions associated with the provided `building_id`.\n\nUpon execution, the function initializes a local variable named `total_enrollment` to `0`. This variable is of data type `NUMBER` and will accumulate the enrollment figures.\n\nThe function then proceeds with a conditional check: it evaluates whether the input parameter `building_id` is `NOT NULL`.\n\nIf `building_id` is indeed `NOT NULL`, the function enters a `FOR` loop. Within this loop, it performs a `SELECT` operation on the `INSTITUTION` table. The `SELECT` statement retrieves the `ENROLLMENT` column from rows in the `INSTITUTION` table where the `BUILDING_ID` column matches the value of the input parameter `building_id`. For each record (`rec`) returned by this `SELECT` query, the function adds the value of `rec.ENROLLMENT` to the `total_enrollment` variable. This process continues for all matching records, effectively summing up the enrollment for all institutions linked to the specified building.\n\nIf `building_id` is `NULL`, the conditional block is skipped, and the `total_enrollment` variable retains its initial value of `0`.\n\nFinally, after the conditional check and potential loop execution, the function returns the current value of the `total_enrollment` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_institution_enrollment_by_building(building_id VARCHAR2) RETURN NUMBER IS\n  total_enrollment NUMBER := 0;\nBEGIN\n  IF building_id IS NOT NULL THEN\n    FOR rec IN (SELECT i.ENROLLMENT FROM INSTITUTION i WHERE i.BUILDING_ID = building_id) LOOP\n      total_enrollment := total_enrollment + rec.ENROLLMENT;\n    END LOOP;\n  END IF;\n  RETURN total_enrollment;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_institution_enrollment_by_building('0') FROM DUAL",
      "SELECT get_institution_enrollment_by_building('1') FROM DUAL",
      "SELECT get_institution_enrollment_by_building('2') FROM DUAL",
      "SELECT get_institution_enrollment_by_building('5') FROM DUAL",
      "SELECT get_institution_enrollment_by_building(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_institution_enrollment_by_building that takes a building ID (VARCHAR2) and returns the total enrollment (NUMBER) from all institutions in that building. Use a FOR loop to sum ENROLLMENT values from the INSTITUTION table where BUILDING_ID matches. Return 0 if the input is NULL.",
    "natural_language": "What is the total enrollment from all institutions located in a specific building, given its building ID?",
    "id": 273
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_protein_sequence_by_common_name that accepts a single parameter, common_name, of type VARCHAR2, which represents the common name of a protein. The function returns a NUMBER representing the length of the protein sequence. The function begins by declaring a local variable, sequence_length, of type NUMBER to store the result of the query. The function checks if the input parameter common_name is not NULL using an IF conditional statement. If the condition is true, it executes a SELECT statement to retrieve the SEQUENCE_LENGTH column from the PROTEIN table, where the COMMON_NAME column matches the input parameter common_name, ignoring case differences by using the LOWER() function on both the COMMON_NAME column and the input parameter. The SELECT statement includes a condition ROWNUM = 1 to ensure that only the first matching row is selected, which is useful in cases where there might be multiple rows with the same common name due to case insensitivity or data inconsistencies. The retrieved SEQUENCE_LENGTH value is stored in the sequence_length variable. Finally, the function returns the value of sequence_length. If the input parameter common_name is NULL, the function does not perform the SELECT operation and directly returns the default value of sequence_length, which is NULL.",
    "plsql": "CREATE OR REPLACE FUNCTION get_protein_sequence_by_common_name(common_name VARCHAR2) RETURN NUMBER IS\n  sequence_length NUMBER;\nBEGIN\n  IF common_name IS NOT NULL THEN\n    SELECT p.SEQUENCE_LENGTH\n    INTO sequence_length\n    FROM PROTEIN p\n    WHERE LOWER(p.COMMON_NAME) = LOWER(common_name)\n    AND ROWNUM = 1; -- Added to handle potential multiple matches if primary key is not strictly case-sensitive or data has issues\n  END IF;\n  RETURN sequence_length;\nEND;",
    "database_name": "protein_institute",
    "tables": [
      "BUILDING",
      "INSTITUTION",
      "PROTEIN"
    ],
    "call_sqls": [
      "SELECT get_protein_sequence_by_common_name('Tropical Clawed Frog') FROM DUAL",
      "SELECT get_protein_sequence_by_common_name('purple sea urchin') FROM DUAL",
      "SELECT get_protein_sequence_by_common_name('body louse') FROM DUAL",
      "SELECT get_protein_sequence_by_common_name('human') FROM DUAL",
      "SELECT get_protein_sequence_by_common_name(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_protein_sequence_by_common_name that accepts a VARCHAR2 parameter for a protein's common name and returns a NUMBER. The function returns the SEQUENCE_LENGTH from the PROTEIN table where the COMMON_NAME matches the input (case-insensitive). If the input is NULL or no match is found, return NULL.",
    "natural_language": "Please construct a PL/SQL function designated as `get_protein_sequence_by_common_name`. This function shall accept a single parameter of type VARCHAR2, representing a protein's common name, and shall return a value of type NUMBER. Its purpose is to retrieve the SEQUENCE_LENGTH from the PROTEIN table for the record whose COMMON_NAME corresponds to the provided input, disregarding case sensitivity. In the event that the input parameter is NULL or if no matching record is located, the function must return NULL.",
    "id": 274
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_event_service_type` that accepts a single input parameter, `p_event_id`, which is of data type `NUMBER` and represents the unique identifier for an event. This function is designed to return a `VARCHAR2` value, specifically the service type code associated with the event identified by `p_event_id`. Internally, the function declares a local variable `v_service_type` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved service type code. The core operation involves a `SELECT` statement that retrieves data from two tables: `EVENTS` (aliased as `e`) and `SERVICES` (aliased as `s`). The `SELECT` statement specifically targets the `SERVICE_TYPE_CODE` column from the `SERVICES` table. This retrieval is performed by joining the `EVENTS` table with the `SERVICES` table based on a common column: `e.SERVICE_ID` from the `EVENTS` table must be equal to `s.SERVICE_ID` from the `SERVICES` table. Furthermore, the selection is filtered by a `WHERE` clause, ensuring that only the row from the `EVENTS` table where the `EVENT_ID` column matches the input parameter `p_event_id` is considered. The `SERVICE_TYPE_CODE` value obtained from this joined and filtered query is then assigned to the local variable `v_service_type`. Finally, the function returns the value stored in `v_service_type` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_event_service_type(p_event_id NUMBER) RETURN VARCHAR2 IS\n  v_service_type VARCHAR2(255);\nBEGIN\n  SELECT s.SERVICE_TYPE_CODE INTO v_service_type FROM EVENTS e JOIN SERVICES s ON e.SERVICE_ID = s.SERVICE_ID WHERE e.EVENT_ID = p_event_id;\n  RETURN v_service_type;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_event_service_type(3) FROM DUAL",
      "SELECT get_event_service_type(8) FROM DUAL",
      "SELECT get_event_service_type(13) FROM DUAL",
      "SELECT get_event_service_type( (SELECT EVENT_ID FROM EVENTS WHERE ROWNUM = 1 AND SERVICE_ID = 5) ) FROM DUAL",
      "SELECT get_event_service_type( (SELECT EVENT_ID FROM EVENTS WHERE ROWNUM = 1 AND SERVICE_ID = 8) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_event_service_type that accepts a NUMBER parameter for an EVENT_ID and returns a VARCHAR2. The function returns the SERVICE_TYPE_CODE from the SERVICES table by joining it with the EVENTS table on SERVICE_ID where the EVENT_ID matches the input.",
    "natural_language": "Write a PL/SQL function called get_event_service_type that takes an EVENT_ID as a NUMBER parameter and gives back a VARCHAR2. It should fetch and return the SERVICE_TYPE_CODE from the SERVICES table by joining with the EVENTS table on SERVICE_ID for the matching input EVENT_ID.",
    "id": 275
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_event_angle that accepts a single input parameter p_event_id of the NUMBER data type and returns a value of the NUMBER data type, where the function's logic is to declare a local variable v_angle of type NUMBER, then compute a value for v_angle by first multiplying the input parameter p_event_id by the constant 0.1, and then multiplying that intermediate result by the constant quotient of 180 divided by 3.141592653589793, which is the conversion factor from radians to degrees, and finally return the computed value stored in v_angle as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_event_angle(p_event_id NUMBER) RETURN NUMBER IS\n  v_angle NUMBER;\nBEGIN\n  v_angle := (p_event_id * 0.1) * (180 / 3.141592653589793);\n  RETURN v_angle;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT calculate_event_angle(3) FROM dual",
      "SELECT calculate_event_angle(8) FROM dual",
      "SELECT calculate_event_angle(13) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_event_angle that accepts a NUMBER parameter for an EVENT_ID and returns a NUMBER. The function calculates and returns the angle by multiplying the input EVENT_ID by 0.1 and then by (180 / π) to convert from radians to degrees.",
    "natural_language": "Hey, can you whip up a PL/SQL function called calculate_event_angle? It should take an EVENT_ID (that's a number) and spit back a number. Basically, it needs to figure out the angle by taking that EVENT_ID, multiplying it by 0.1, and then converting the result from radians to degrees using (180 / π).",
    "id": 276
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_participant_in_event` that is designed to determine if a specific participant is associated with a particular event. This function accepts two input parameters: `p_event_id`, which is of data type `NUMBER` and represents the unique identifier of an event, and `p_participant_id`, which is also of data type `NUMBER` and represents the unique identifier of a participant. The function is declared to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement to query the `PARTICIPANTS_IN_EVENTS` table. This `SELECT` statement calculates the `COUNT(*)` of rows, which effectively counts all rows that satisfy the specified conditions. The conditions for counting are that the `EVENT_ID` column in the `PARTICIPANTS_IN_EVENTS` table must be equal to the value provided in the `p_event_id` input parameter, AND the `PARTICIPANT_ID` column in the `PARTICIPANTS_IN_EVENTS` table must be equal to the value provided in the `p_participant_id` input parameter. The result of this `COUNT(*)` operation is then stored into the local variable `v_count`. Finally, the function returns the value stored in `v_count`. A return value of `0` indicates that the participant is not associated with the event, while a return value greater than `0` (typically `1` if `PARTICIPANT_ID` and `EVENT_ID` form a unique key or are part of a unique constraint) indicates that the participant is associated with the event.",
    "plsql": "CREATE OR REPLACE FUNCTION check_participant_in_event(p_event_id NUMBER, p_participant_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM PARTICIPANTS_IN_EVENTS WHERE EVENT_ID = p_event_id AND PARTICIPANT_ID = p_participant_id;\n  RETURN v_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT check_participant_in_event(3, 26) FROM DUAL",
      "SELECT check_participant_in_event(8, 66) FROM DUAL",
      "SELECT check_participant_in_event(3, 86) FROM DUAL",
      "SELECT check_participant_in_event(13, 9) FROM DUAL",
      "SELECT check_participant_in_event(8, 26) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_participant_in_event that accepts two NUMBER parameters for an EVENT_ID and a PARTICIPANT_ID and returns a NUMBER. The function returns the count of matching records from the PARTICIPANTS_IN_EVENTS table where both IDs match. A return value of 0 indicates no association.",
    "natural_language": "Hey, can you whip up a PL/SQL function called check_participant_in_event? It's gotta take in two numbers: one for an EVENT_ID and another for a PARTICIPANT_ID, and spit back a number. Basically, it needs to check the PARTICIPANTS_IN_EVENTS table and count how many times that specific person is signed up for that specific event. If it comes back with a zero, that means they're not in it.",
    "id": 277
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_participant_details_by_type` that accepts a single input parameter, `p_type_code`, which is of data type `VARCHAR2`. This function is designed to return a single `VARCHAR2` value representing participant details. Upon execution, the function declares a local variable `v_details` of type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved participant details. The core operation involves executing a `SELECT` statement to retrieve data from the `PARTICIPANTS` table. Specifically, it selects the value from the `PARTICIPANT_DETAILS` column. This selection is constrained by two conditions: first, the `PARTICIPANT_TYPE_CODE` column in the `PARTICIPANTS` table must exactly match the value provided in the input parameter `p_type_code`; second, the `ROWNUM` pseudocolumn is used to limit the result set to only the first row that satisfies the `PARTICIPANT_TYPE_CODE` condition. The value retrieved from the `PARTICIPANT_DETAILS` column of this single row is then immediately assigned to the local variable `v_details`. Finally, the function returns the value stored in `v_details` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_participant_details_by_type(p_type_code VARCHAR2) RETURN VARCHAR2 IS\n  v_details VARCHAR2(255);\nBEGIN\n  SELECT PARTICIPANT_DETAILS INTO v_details FROM PARTICIPANTS WHERE PARTICIPANT_TYPE_CODE = p_type_code AND ROWNUM = 1;\n  RETURN v_details;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_participant_details_by_type('Organizer') FROM DUAL",
      "SELECT get_participant_details_by_type('Guest') FROM DUAL",
      "SELECT get_participant_details_by_type('Speaker') FROM DUAL",
      "SELECT get_participant_details_by_type('Volunteer') FROM DUAL",
      "SELECT get_participant_details_by_type('Staff') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_participant_details_by_type that accepts a VARCHAR2 parameter for a PARTICIPANT_TYPE_CODE and returns a VARCHAR2. The function returns the PARTICIPANT_DETAILS from the first matching row in the PARTICIPANTS table where the PARTICIPANT_TYPE_CODE matches the input.",
    "natural_language": "Develop a PL/SQL function called get_participant_details_by_type, which is designed to take a single VARCHAR2 parameter representing a PARTICIPANT_TYPE_CODE and subsequently returns a VARCHAR2 value. This function meticulously retrieves and returns the PARTICIPANT_DETAILS column from the very first corresponding record located within the PARTICIPANTS table, specifically where the table's PARTICIPANT_TYPE_CODE perfectly aligns with the provided input parameter.",
    "id": 278
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_oldest_institution_year that returns a NUMBER type value. This function does not take any input parameters. It begins by declaring a local variable v_oldest_year of type NUMBER, which will be used to store the result of a query. The function then executes a SELECT statement to retrieve the minimum value from the FOUNDED column of the INSTITUTION table, which represents the year an institution was founded. The result of this query is stored into the v_oldest_year variable. The function then returns the value of v_oldest_year, but if v_oldest_year is NULL, it returns 0 instead, using the NVL function to handle this potential NULL value. The function includes an exception handling block to manage any errors that may occur during execution. If a NO_DATA_FOUND exception is raised, indicating that the query returned no rows, the function returns 0. For any other exceptions, the function re-raises the exception to be handled by the calling environment.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_institution_year\nRETURN NUMBER\nIS\n    v_oldest_year NUMBER;\nBEGIN\n    SELECT MIN(FOUNDED)\n    INTO v_oldest_year\n    FROM INSTITUTION;\n    \n    RETURN NVL(v_oldest_year, 0);\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "SELECT get_oldest_institution_year FROM DUAL",
      "SELECT get_oldest_institution_year() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Oldest Year: ' || get_oldest_institution_year);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_oldest_institution_year;\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "SELECT i.name, i.founded, get_oldest_institution_year AS oldest_year\nFROM institution i\nWHERE i.founded = get_oldest_institution_year"
    ],
    "summary": "Create a PL/SQL function named get_oldest_institution_year with no parameters that returns a NUMBER. It finds the minimum FOUNDED year from the INSTITUTION table. Return 0 if the result is NULL or if NO_DATA_FOUND is raised. Re-raise any other exceptions.",
    "natural_language": "Write a PL/SQL function called get_oldest_institution_year that takes no inputs and gives back a NUMBER. It should figure out the earliest, or maybe the most long-standing, FOUNDED year from the INSTITUTION table. If nothing comes up or if it hits a certain kind of missing data error, just hand back 0. But if some other unexpected problem pops up, let that error go through as usual.",
    "id": 279
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_enrollment that calculates and returns the average value of the ENROLLMENT column from the INSTITUTION table. The function does not take any parameters and returns a NUMBER type value. Within the function, a SELECT statement is executed to compute the average of all values in the ENROLLMENT column, and the result is stored in a local variable named avg_enrollment of type NUMBER. The function then returns the value of avg_enrollment. If any exception occurs during the execution of the SELECT statement, the function catches the exception using the WHEN OTHERS clause and returns NULL instead of the average enrollment value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_enrollment\nRETURN NUMBER\nIS\n    avg_enrollment NUMBER;\nBEGIN\n    SELECT AVG(ENROLLMENT) INTO avg_enrollment FROM INSTITUTION;\n    RETURN avg_enrollment;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN NULL;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "SELECT get_average_enrollment FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_average_enrollment with no parameters that returns a NUMBER. It calculates the average ENROLLMENT from the INSTITUTION table. If any exception occurs, return NULL.",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_average_enrollment', which accepts no parameters and yields a NUMBER data type. The function's purpose is to compute the mean ENROLLMENT value from the INSTITUTION table. Should any exception be encountered during execution, the function must return a NULL value.",
    "id": 280
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_stadium_capacity` that is designed to return a single numeric value. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_max_capacity` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement queries the `INSTITUTION` table and calculates the maximum value present in the `CAPACITY` column across all rows within that table. The result of this `MAX` aggregate function is then immediately stored into the `v_max_capacity` local variable. Finally, the function returns the value currently held by the `v_max_capacity` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_stadium_capacity\nRETURN NUMBER\nIS\n    v_max_capacity NUMBER;\nBEGIN\n    SELECT MAX(CAPACITY) INTO v_max_capacity FROM INSTITUTION;\n    RETURN v_max_capacity;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "SELECT get_max_stadium_capacity FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_max_stadium_capacity with no parameters that returns a NUMBER. It finds the maximum CAPACITY from the INSTITUTION table and returns the value.",
    "natural_language": "Function get_max_stadium_capacity returns NUMBER. Find max CAPACITY from INSTITUTION.",
    "id": 281
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_avg_speed_by_type_nation_year that accepts three input parameters: ship_type of type VARCHAR2, nationality of type VARCHAR2, and year_limit of type NUMBER. This function calculates and returns a NUMBER representing the average speed in knots of ships that meet specific criteria. The function begins by declaring a local variable avg_speed of type NUMBER to store the result of the average speed calculation. It then executes a SELECT statement to compute the average speed. The SELECT statement retrieves the average value of the SPEED_KNOTS column from the MISSION table, which is aliased as m. This table is joined with the SHIP table, aliased as s, using the SHIP_ID column as the joining key. The WHERE clause of the SELECT statement imposes three conditions: first, it checks that the TYPE column of the SHIP table, converted to lowercase using the LOWER() function, matches the lowercase version of the input parameter ship_type; second, it ensures that the NATIONALITY column of the SHIP table, also converted to lowercase, matches the lowercase version of the input parameter nationality; third, it verifies that the LAUNCHED_YEAR column of the MISSION table is greater than the input parameter year_limit. If these conditions are satisfied, the average speed is calculated and stored in the avg_speed variable. Finally, the function returns the value of avg_speed.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_speed_by_type_nation_year(ship_type IN VARCHAR2, nationality IN VARCHAR2, year_limit IN NUMBER) RETURN NUMBER IS\n  avg_speed NUMBER;\nBEGIN\n  SELECT AVG(m.SPEED_KNOTS)\n  INTO avg_speed\n  FROM MISSION m\n  JOIN SHIP s ON m.SHIP_ID = s.SHIP_ID\n  WHERE LOWER(s.TYPE) = LOWER(ship_type)\n    AND LOWER(s.NATIONALITY) = LOWER(nationality)\n    AND m.LAUNCHED_YEAR > year_limit;\n  RETURN avg_speed;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT calculate_avg_speed_by_type_nation_year('Cargo ship', 'United Kingdom', 1920) FROM DUAL",
      "SELECT calculate_avg_speed_by_type_nation_year('Battle ship', 'United States', 1910) FROM DUAL",
      "SELECT calculate_avg_speed_by_type_nation_year('Cargo ship', 'United Kingdom', 1935) FROM DUAL",
      "SELECT calculate_avg_speed_by_type_nation_year('Battle ship', 'United Kingdom', 1900) FROM DUAL",
      "SELECT calculate_avg_speed_by_type_nation_year('Cargo ship', 'United States', 1925) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_avg_speed_by_type_nation_year that accepts ship_type VARCHAR2, nationality VARCHAR2, and year_limit NUMBER parameters and returns a NUMBER. It calculates the average SPEED_KNOTS from the MISSION table (m) joined with the SHIP table (s) on SHIP_ID. Filter where LOWER(s.TYPE) = LOWER(ship_type), LOWER(s.NATIONALITY) = LOWER(nationality), and m.LAUNCHED_YEAR > year_limit.",
    "natural_language": "Develop a PL/SQL function called calculate_avg_speed_by_type_nation_year, which is designed to meticulously compute and return a numerical average. This function requires three specific input parameters: a ship_type expressed as VARCHAR2, a nationality also as VARCHAR2, and a year_limit as a NUMBER. Its purpose is to carefully determine the average SPEED_KNOTS by thoroughly querying the MISSION table, which is aliased as 'm', and seamlessly joining it with the SHIP table, aliased as 's', using the SHIP_ID column as the precise link. The calculation must be scrupulously filtered to include only those records where the ship's type, converted to lowercase, exactly matches the provided ship_type parameter in lowercase, and where the ship's nationality, also in lowercase, perfectly corresponds to the given nationality parameter. Furthermore, it must exclusively consider missions that were launched in a year definitively later than the specified year_limit threshold.",
    "id": 282
  },
  {
    "ir": "Write an Oracle PL/SQL function named `find_min_tonnage_for_fate` that accepts three input parameters: `fate_pattern` of type `VARCHAR2`, `ship_nationality` of type `VARCHAR2`, and `min_year` of type `NUMBER`. The purpose of this function is to determine and return the minimum tonnage among ships that meet specific criteria. The function declares a local variable `min_tonnage` of type `NUMBER` to store the calculated minimum tonnage. The core operation of the function involves a `SELECT` statement that retrieves the minimum value from the `TONNAGE` column of the `SHIP` table. This `SELECT` statement uses an `INNER JOIN` operation to connect the `SHIP` table (aliased as `s`) with the `MISSION` table (aliased as `m`) based on the equality of their `SHIP_ID` columns (`s.SHIP_ID = m.SHIP_ID`). The `WHERE` clause then applies three conditions to filter the joined records: first, it checks if the `FATE` column in the `MISSION` table contains the `fate_pattern` as a substring, using the `LIKE` operator with wildcard characters (`%`) at both ends of the `fate_pattern` (e.g., `m.FATE LIKE '%' || fate_pattern || '%'`); second, it compares the `NATIONALITY` column from the `SHIP` table with the `ship_nationality` parameter, ensuring a case-insensitive comparison by converting both values to lowercase using the `LOWER()` function (e.g., `LOWER(s.NATIONALITY) = LOWER(ship_nationality)`); and third, it verifies that the `LAUNCHED_YEAR` column in the `MISSION` table is greater than or equal to the `min_year` parameter (e.g., `m.LAUNCHED_YEAR >= min_year`). The result of this `SELECT` statement, which is the calculated minimum tonnage, is then stored into the `min_tonnage` local variable using the `INTO` clause. Finally, the function returns the value stored in the `min_tonnage` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION find_min_tonnage_for_fate(fate_pattern IN VARCHAR2, ship_nationality IN VARCHAR2, min_year IN NUMBER) RETURN NUMBER IS\n  min_tonnage NUMBER;\nBEGIN\n  SELECT MIN(s.TONNAGE)\n  INTO min_tonnage\n  FROM SHIP s\n  JOIN MISSION m ON s.SHIP_ID = m.SHIP_ID\n  WHERE m.FATE LIKE '%' || fate_pattern || '%'\n    AND LOWER(s.NATIONALITY) = LOWER(ship_nationality)\n    AND m.LAUNCHED_YEAR >= min_year;\n  RETURN min_tonnage;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT find_min_tonnage_for_fate('Decommissioned', 'United Kingdom', 1930) FROM DUAL",
      "SELECT find_min_tonnage_for_fate('Retired', 'United States', 1910) FROM DUAL",
      "SELECT find_min_tonnage_for_fate('Sunk', 'Germany', 1940) FROM DUAL",
      "SELECT find_min_tonnage_for_fate('Lost', 'Norway', 1900) FROM DUAL",
      "SELECT find_min_tonnage_for_fate('Captured', 'Japan', 1920) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named find_min_tonnage_for_fate that accepts fate_pattern VARCHAR2, ship_nationality VARCHAR2, and min_year NUMBER parameters and returns a NUMBER. It finds the minimum TONNAGE from the SHIP table (s) joined with the MISSION table (m) on SHIP_ID. Filter where m.FATE LIKE '%' || fate_pattern || '%', LOWER(s.NATIONALITY) = LOWER(ship_nationality), and m.LAUNCHED_YEAR >= min_year.",
    "natural_language": "Develop a PL/SQL function called find_min_tonnage_for_fate which is designed to accept three distinct input parameters: a fate_pattern of type VARCHAR2, a ship_nationality also of type VARCHAR2, and a min_year of type NUMBER, ultimately returning a NUMBER. This function meticulously calculates the smallest TONNAGE value by querying the SHIP table, referred to as 's', which is intricately joined with the MISSION table, denoted as 'm', using the SHIP_ID column as the linking key. The selection is carefully filtered to include only those records where the mission's FATE field contains the specified pattern, where the ship's NATIONALITY, converted to lowercase for a robust case-insensitive comparison, exactly matches the provided ship_nationality parameter, and where the LAUNCHED_YEAR from the mission is greater than or equal to the supplied minimum year threshold.",
    "id": 283
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_ships_by_location_tonnage that accepts three input parameters: location_name of type VARCHAR2, min_tonnage of type NUMBER, and max_tonnage of type NUMBER. This function returns a NUMBER representing the count of distinct ships. The function begins by declaring a local variable ship_count of type NUMBER to store the result of the query. It then executes a SELECT statement that counts the distinct SHIP_IDs from the SHIP table, which is aliased as 's'. This table is joined with the MISSION table, aliased as 'm', on the condition that the SHIP_ID column in both tables matches. The WHERE clause of the query applies two conditions: first, it checks that the LOCATION column in the MISSION table, converted to lowercase using the LOWER() function, matches the location_name parameter also converted to lowercase, ensuring a case-insensitive comparison. Second, it ensures that the TONNAGE column in the SHIP table falls within the inclusive range specified by the min_tonnage and max_tonnage parameters. The result of this query, which is the count of distinct ships meeting the specified criteria, is stored in the ship_count variable. Finally, the function returns the value of ship_count.",
    "plsql": "CREATE OR REPLACE FUNCTION count_ships_by_location_tonnage(location_name IN VARCHAR2, min_tonnage IN NUMBER, max_tonnage IN NUMBER) RETURN NUMBER IS\n  ship_count NUMBER;\nBEGIN\n  SELECT COUNT(DISTINCT s.SHIP_ID)\n  INTO ship_count\n  FROM SHIP s\n  JOIN MISSION m ON s.SHIP_ID = m.SHIP_ID\n  WHERE LOWER(m.LOCATION) = LOWER(location_name)\n    AND s.TONNAGE BETWEEN min_tonnage AND max_tonnage;\n  RETURN ship_count;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT count_ships_by_location_tonnage('Germany', 3000, 4000) FROM DUAL",
      "SELECT count_ships_by_location_tonnage('Norway', 3000, 3500) FROM DUAL",
      "SELECT count_ships_by_location_tonnage('Germany', 1000, 2000) FROM DUAL",
      "SELECT count_ships_by_location_tonnage('Norway', 3100, 3200) FROM DUAL",
      "SELECT count_ships_by_location_tonnage('Unknown', 0, 9999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named count_ships_by_location_tonnage that returns a count of distinct ships. It accepts a location name, a minimum tonnage, and a maximum tonnage. The function counts ships from the SHIP table joined with the MISSION table where the mission location (case-insensitive) matches the input and the ship's tonnage is within the specified range.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as count_ships_by_location_tonnage, which will meticulously calculate and deliver a precise count of unique vessels. This specialized function must be designed to accept three distinct parameters: a specific location name, a clearly defined minimum tonnage threshold, and an explicitly stated maximum tonnage limit. Its operational logic involves querying the SHIP database table, which is intricately joined with the MISSION table, to accurately tally all ships whose associated mission location—when compared in a case-insensitive manner—perfectly corresponds to the provided location input, while simultaneously ensuring that each vessel's registered tonnage falls comfortably within the inclusive range specified by the minimum and maximum tonnage values.",
    "id": 284
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_tonnage_by_type_year that accepts three input parameters: a string parameter named type_filter, a numeric parameter named start_year, and a numeric parameter named end_year, and returns a single numeric value. The function declares a local numeric variable named total_tonnage. The function's logic executes a single SQL SELECT statement that performs a SUM aggregation on the TONNAGE column from the SHIP table, aliased as 's'. This query joins the SHIP table to the MISSION table, aliased as 'm', using the condition that the SHIP_ID column in the SHIP table equals the SHIP_ID column in the MISSION table. The query applies two filter conditions in its WHERE clause: the first condition uses the LOWER function to convert both the TYPE column from the SHIP table and the input parameter type_filter to lowercase and checks for equality, ensuring a case-insensitive comparison; the second condition checks that the LAUNCHED_YEAR column from the MISSION table is between the values of the input parameters start_year and end_year, inclusive. The result of the SUM aggregation is assigned into the local variable total_tonnage. The function concludes by returning the value stored in the total_tonnage variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_tonnage_by_type_year(type_filter IN VARCHAR2, start_year IN NUMBER, end_year IN NUMBER) RETURN NUMBER IS\n  total_tonnage NUMBER;\nBEGIN\n  SELECT SUM(s.TONNAGE)\n  INTO total_tonnage\n  FROM SHIP s\n  JOIN MISSION m ON s.SHIP_ID = m.SHIP_ID\n  WHERE LOWER(s.TYPE) = LOWER(type_filter)\n    AND m.LAUNCHED_YEAR BETWEEN start_year AND end_year;\n  RETURN total_tonnage;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT get_total_tonnage_by_type_year('Cargo ship', 1910, 1920) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Battle ship', 1930, 1940) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Cargo ship', 1900, 1950) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Battle ship', 1916, 1916) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Cargo ship', 1925, 1935) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_tonnage_by_type_year that returns the total tonnage. It accepts a ship type, a start year, and an end year. The function sums the tonnage from the SHIP table joined with the MISSION table where the ship type (case-insensitive) matches the input and the mission's launched year is within the specified range.",
    "natural_language": "What is the total tonnage for a given ship type, calculated by summing the tonnage from ships whose type matches (case-insensitively) and whose missions were launched between a specified start year and end year?",
    "id": 285
  },
  {
    "ir": "Write an Oracle PL/SQL function named find_max_speed_for_nation_type that accepts three parameters: nation of type VARCHAR2, ship_type of type VARCHAR2, and year_cutoff of type NUMBER. The function is designed to return a NUMBER representing the maximum speed in knots of ships that meet specific criteria. The function begins by declaring a local variable max_speed of type NUMBER to store the result of the query. It then performs a SELECT operation to retrieve the maximum value of the SPEED_KNOTS column from the MISSION table, which is aliased as m. This table is joined with the SHIP table, aliased as s, using the SHIP_ID column as the common key. The WHERE clause filters the results based on three conditions: the NATIONALITY column in the SHIP table must match the nation parameter, the TYPE column in the SHIP table must match the ship_type parameter, and the LAUNCHED_YEAR column in the MISSION table must be less than the year_cutoff parameter. The LOWER() function is applied to both the NATIONALITY and TYPE columns as well as the nation and ship_type parameters to ensure case-insensitive comparison. After executing the query, the maximum speed value is stored in the max_speed variable, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION find_max_speed_for_nation_type(nation IN VARCHAR2, ship_type IN VARCHAR2, year_cutoff IN NUMBER) RETURN NUMBER IS\n  max_speed NUMBER;\nBEGIN\n  SELECT MAX(m.SPEED_KNOTS)\n  INTO max_speed\n  FROM MISSION m\n  JOIN SHIP s ON m.SHIP_ID = s.SHIP_ID\n  WHERE LOWER(s.NATIONALITY) = LOWER(nation)\n    AND LOWER(s.TYPE) = LOWER(ship_type)\n    AND m.LAUNCHED_YEAR < year_cutoff;\n  RETURN max_speed;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT find_max_speed_for_nation_type('United Kingdom', 'Cargo ship', 1950) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('United States', 'Battle ship', 1940) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('Germany', 'Cargo ship', 1930) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('Norway', 'Battle ship', 2000) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('United Kingdom', 'Battle ship', 1920) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named find_max_speed_for_nation_type that returns the maximum speed. It accepts a nationality, a ship type, and a year cutoff. The function finds the maximum speed from the MISSION table joined with the SHIP table where the ship's nationality and type (both case-insensitive) match the inputs and the mission's launched year is less than the cutoff.",
    "natural_language": "Write a PL/SQL function that gives us the top speed. It should take a country, a kind of vessel, and a not-too-recent year. The function needs to look through mission and ship info to find the highest speed where the ship's country and general category are roughly like the ones provided, and the mission happened a good while back, before that year cutoff.",
    "id": 286
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_country_avg_coaster_length that accepts a single input parameter p_country_id of the NUMBER data type, which is used to identify a specific country, and returns a single NUMBER value representing the computed average. The function declares a local variable v_avg_length of type NUMBER to store the result of a calculation. The function's execution block performs a SELECT statement that queries the ROLLER_COASTER table, specifically applying the AVG aggregate function to the LENGTH column to calculate the arithmetic mean length. This SELECT statement includes a WHERE clause condition that filters the rows considered for the average calculation, including only those rows where the value in the COUNTRY_ID column is exactly equal to the value provided in the input parameter p_country_id. The result of the AVG(LENGTH) calculation is retrieved from the database and stored directly into the local variable v_avg_length using the SELECT INTO syntax. The function concludes by using a RETURN statement to output the value stored in v_avg_length as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_avg_coaster_length(p_country_id NUMBER)\nRETURN NUMBER\nIS\n  v_avg_length NUMBER;\nBEGIN\n  SELECT AVG(LENGTH) INTO v_avg_length FROM ROLLER_COASTER WHERE COUNTRY_ID = p_country_id;\n  RETURN v_avg_length;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "SELECT get_country_avg_coaster_length(1) FROM dual",
      "SELECT get_country_avg_coaster_length(2) FROM dual",
      "SELECT get_country_avg_coaster_length(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_country_avg_coaster_length that returns the average length. It accepts a country ID. The function calculates the average length from the ROLLER_COASTER table for rows where the country ID matches the input.",
    "natural_language": "Develop a PL/SQL function called get_country_avg_coaster_length, which is designed to compute and return the average length. This function requires a single input parameter, specifically a country ID. It performs its calculation by meticulously querying the ROLLER_COASTER table, carefully selecting only those rows where the country ID precisely corresponds to the provided input value, and then determining the mean length from that specific subset of data.",
    "id": 287
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_total_coaster_length that accepts a single input parameter p_country_name of type VARCHAR2, which represents the name of a country, and returns a value of type NUMBER. The function declares a local variable v_total_length of type NUMBER to store the computed result. The function's logic executes a single SQL SELECT statement that performs an INNER JOIN between the ROLLER_COASTER table (aliased as r) and the COUNTRY table (aliased as c) using the condition that the COUNTRY_ID column in the ROLLER_COASTER table equals the COUNTRY_ID column in the COUNTRY table. Within this joined dataset, the query applies a filter using a WHERE clause, specifying that the NAME column from the COUNTRY table must exactly match the value provided in the input parameter p_country_name. From the resulting filtered and joined rows, the query uses the SUM aggregate function to calculate the total sum of all values from the LENGTH column of the ROLLER_COASTER table. This computed sum is then retrieved into the local variable v_total_length using the SELECT INTO syntax. Finally, the function returns the value stored in the v_total_length variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_coaster_length(p_country_name VARCHAR2)\nRETURN NUMBER\nIS\n  v_total_length NUMBER;\nBEGIN\n  SELECT SUM(r.LENGTH) INTO v_total_length FROM ROLLER_COASTER r JOIN COUNTRY c ON r.COUNTRY_ID = c.COUNTRY_ID WHERE c.NAME = p_country_name;\n  RETURN v_total_length;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "SELECT calculate_total_coaster_length('Austria') FROM DUAL",
      "SELECT calculate_total_coaster_length('Finland') FROM DUAL",
      "SELECT calculate_total_coaster_length('Sweden') FROM DUAL",
      "SELECT calculate_total_coaster_length('Germany') FROM DUAL",
      "SELECT calculate_total_coaster_length('USA') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_total_coaster_length that returns the total length. It accepts a country name. The function sums the length from the ROLLER_COASTER table joined with the COUNTRY table where the country name matches the input.",
    "natural_language": "Develop a PL/SQL function called calculate_total_coaster_length, which is designed to compute and return the aggregate length. This function takes a single input parameter, specifically the name of a country. To achieve its purpose, it meticulously sums the length values by performing an inner join between the ROLLER_COASTER table and the COUNTRY table, precisely where the provided country name corresponds to the matching record in the joined tables.",
    "id": 288
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_country_population_density` that accepts a single input parameter, `p_country_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Internally, the function declares a local variable named `v_density` of data type `NUMBER` to temporarily store the calculated population density. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves data from a table named `COUNTRY`. Specifically, it calculates the population density by dividing the value from the `POPULATION` column by the value from the `AREA` column. The result of this division is then passed to the `CEIL` function, which rounds the number up to the nearest whole integer. The outcome of this `CEIL` function call is then stored into the local variable `v_density`. This data retrieval and calculation are performed under a specific condition: the `WHERE` clause specifies that only the row where the `COUNTRY_ID` column's value matches the value provided in the input parameter `p_country_id` should be considered. Finally, the function returns the value stored in the `v_density` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_population_density(p_country_id NUMBER)\nRETURN NUMBER\nIS\n  v_density NUMBER;\nBEGIN\n  SELECT CEIL(POPULATION / AREA) INTO v_density FROM COUNTRY WHERE COUNTRY_ID = p_country_id;\n  RETURN v_density;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "SELECT get_country_population_density(1) FROM dual",
      "SELECT get_country_population_density(2) FROM dual",
      "SELECT get_country_population_density(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_country_population_density that accepts a country_id (NUMBER) and returns the CEIL of population divided by area for that country from the COUNTRY table.",
    "natural_language": "Write a PL/SQL function called get_country_population_density that takes a country_id and gives back the rounded-up result of how packed that country is, based on its people and space from the COUNTRY table.",
    "id": 289
  },
  {
    "ir": "Write an Oracle PL/SQL function named find_max_coaster_height that accepts a single input parameter p_country_id of the NUMBER data type and returns a value of the NUMBER data type, declaring a local variable v_max_height also of the NUMBER data type, then executes a SELECT statement that queries the ROLLER_COASTER table to calculate the maximum value from its HEIGHT column specifically for rows where the COUNTRY_ID column value is equal to the provided p_country_id parameter, stores the result of this MAX(HEIGHT) aggregation into the local variable v_max_height, and finally returns the value stored in v_max_height as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION find_max_coaster_height(p_country_id NUMBER)\nRETURN NUMBER\nIS\n  v_max_height NUMBER;\nBEGIN\n  SELECT MAX(HEIGHT) INTO v_max_height FROM ROLLER_COASTER WHERE COUNTRY_ID = p_country_id;\n  RETURN v_max_height;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "SELECT find_max_coaster_height(1) FROM DUAL",
      "SELECT find_max_coaster_height(2) FROM DUAL",
      "SELECT find_max_coaster_height(3) FROM DUAL",
      "SELECT find_max_coaster_height(10) FROM DUAL",
      "SELECT find_max_coaster_height(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named find_max_coaster_height that accepts a country_id (NUMBER) and returns the maximum HEIGHT for roller coasters in that country from the ROLLER_COASTER table.",
    "natural_language": "Develop a PL/SQL function, which should be named find_max_coaster_height, that is designed to take a single numeric input parameter representing a country_id. This function will meticulously query the ROLLER_COASTER table to calculate and then return the very tallest HEIGHT value found among all the thrilling roller coasters specifically located within the designated country.",
    "id": 290
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_coasters_by_status that accepts a single input parameter p_status of type VARCHAR2, which represents a specific operational or categorical state, and returns a single numeric value of type NUMBER. The function declares a local variable v_count of type NUMBER to store the result of a database query. The function's execution logic consists of a single SQL SELECT statement that queries the ROLLER_COASTER table. This statement performs an aggregate count operation using the COUNT(*) function on all rows in the ROLLER_COASTER table where the value in the STATUS column is exactly equal to the value provided in the input parameter p_status. The result of this count operation is retrieved and stored into the local variable v_count using an INTO clause. The function then concludes its execution by returning the value stored in v_count, which represents the total number of roller coaster records that have the specified status.",
    "plsql": "CREATE OR REPLACE FUNCTION count_coasters_by_status(p_status VARCHAR2)\nRETURN NUMBER\nIS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM ROLLER_COASTER WHERE STATUS = p_status;\n  RETURN v_count;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "SELECT count_coasters_by_status('Operating') FROM dual",
      "SELECT count_coasters_by_status('Closed') FROM dual",
      "SELECT count_coasters_by_status('Under Construction') FROM dual",
      "SELECT count_coasters_by_status('Maintenance') FROM dual",
      "SELECT count_coasters_by_status('Planned') FROM dual"
    ],
    "summary": "Create a PL/SQL function named count_coasters_by_status that accepts a status (VARCHAR2) and returns the count of roller coasters with that status from the ROLLER_COASTER table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called count_coasters_by_status? It should take a status (as a VARCHAR2) and give us back the number of roller coasters in the ROLLER_COASTER table that have that exact status.",
    "id": 291
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_rating_adjustment` that accepts two input parameters: `p_book_id` of data type `NUMBER`, which represents the unique identifier for a book, and `p_adjustment_factor` of data type `NUMBER`, which represents a numerical multiplier to be applied to a rating. This function is designed to return a single value of data type `NUMBER`, which will be the calculated adjusted rating. Inside the function's executable block, a local variable named `v_adjusted_rating` of data type `NUMBER` is declared to temporarily store the result of the calculation. The function then performs a `SELECT` operation on the `REVIEW` table. Specifically, it retrieves the value from the `RATING` column, multiplies it by the value provided in the `p_adjustment_factor` input parameter, and stores this computed result into the `v_adjusted_rating` local variable. This `SELECT` operation is constrained by two conditions in its `WHERE` clause: first, it filters rows where the `BOOK_ID` column matches the value provided in the `p_book_id` input parameter; second, it further restricts the result set to only the first row encountered that satisfies the `BOOK_ID` condition by using `ROWNUM = 1`. After successfully executing the `SELECT` statement and populating `v_adjusted_rating`, the function returns the final value stored in `v_adjusted_rating` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_rating_adjustment(p_book_id NUMBER, p_adjustment_factor NUMBER) RETURN NUMBER IS\n    v_adjusted_rating NUMBER;\nBEGIN\n    SELECT RATING * p_adjustment_factor INTO v_adjusted_rating FROM REVIEW WHERE BOOK_ID = p_book_id AND ROWNUM = 1;\n    RETURN v_adjusted_rating;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT calculate_rating_adjustment(1, 1.1) FROM DUAL",
      "SELECT calculate_rating_adjustment(3, 0.9) FROM DUAL",
      "SELECT calculate_rating_adjustment(1, 1.2) FROM DUAL",
      "SELECT calculate_rating_adjustment(3, 1.0) FROM DUAL",
      "SELECT calculate_rating_adjustment(1, 0.8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_rating_adjustment that accepts a book_id (NUMBER) and an adjustment_factor (NUMBER). It returns the RATING multiplied by the adjustment_factor for the first matching book review from the REVIEW table.",
    "natural_language": "Please construct a PL/SQL function designated as 'calculate_rating_adjustment'. This function shall accept two numerical parameters: a book identifier and an adjustment factor. Its purpose is to retrieve the RATING value from the initial corresponding record in the REVIEW table for the specified book and return the product of that rating and the provided adjustment factor.",
    "id": 292
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_book_release_timestamp` that is designed to retrieve and return the release timestamp of a specific book. This function accepts two input parameters: `p_book_id`, which is a `NUMBER` type representing the unique identifier of the book, and `p_timezone_offset`, which is a `VARCHAR2` type with a default value of `'+00:00'`, intended to specify a timezone offset, although it is not actively used within the current implementation of the function's logic. The function is declared to return a `TIMESTAMP` data type.\n\nThe function's execution begins by declaring a local variable `v_release_timestamp` of `TIMESTAMP` type to temporarily store the retrieved release timestamp.\n\nThe core operation involves a `SELECT` statement that attempts to fetch data from the `BOOK` table. Specifically, it selects the `RELEASE` column. The value from the `RELEASE` column is then concatenated with the string literal `' 00:00:00'` to form a combined string. This combined string is subsequently converted into a `TIMESTAMP` data type using the `TO_TIMESTAMP` function. The format model used for this conversion is `'Month YYYY HH24:MI:SS'`, indicating that the `RELEASE` column is expected to contain a month name (e.g., 'January'), followed by a year (e.g., '2023'). The `HH24:MI:SS` part of the format model is applied to the concatenated `' 00:00:00'` string, effectively setting the time component to midnight (00:00:00). The resulting `TIMESTAMP` value is then stored into the `v_release_timestamp` variable. This selection is filtered by a `WHERE` clause, which ensures that only the row where the `BOOK_ID` column matches the input parameter `p_book_id` is considered.\n\nAfter successfully retrieving and converting the timestamp, the function returns the value stored in `v_release_timestamp`.\n\nThe function includes an exception handling block. If a `NO_DATA_FOUND` exception occurs during the `SELECT` statement (meaning no book with the specified `p_book_id` was found in the `BOOK` table), the function will return `NULL`. If any other exception occurs during the execution of the function, an `OTHERS` exception handler is triggered, which then re-raises the original exception, propagating it to the calling environment.",
    "plsql": "CREATE OR REPLACE FUNCTION check_book_release_timestamp(p_book_id NUMBER, p_timezone_offset VARCHAR2 DEFAULT '+00:00') RETURN TIMESTAMP IS\n    v_release_timestamp TIMESTAMP;\nBEGIN\n    SELECT TO_TIMESTAMP(RELEASE || ' 00:00:00', 'Month YYYY HH24:MI:SS') INTO v_release_timestamp \n    FROM BOOK \n    WHERE BOOK_ID = p_book_id;\n    \n    RETURN v_release_timestamp;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT check_book_release_timestamp(p_book_id => 1) FROM DUAL",
      "SELECT check_book_release_timestamp(p_book_id => 2, p_timezone_offset => '+01:00') FROM DUAL",
      "SELECT check_book_release_timestamp(p_book_id => 3) FROM DUAL",
      "SELECT check_book_release_timestamp(p_book_id => 1, p_timezone_offset => '-05:00') FROM DUAL",
      "SELECT check_book_release_timestamp(p_book_id => 999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_book_release_timestamp that accepts a book_id (NUMBER) and a timezone_offset (VARCHAR2, default '+00:00'). It returns the RELEASE date from the BOOK table converted to a TIMESTAMP at midnight. Handle NO_DATA_FOUND by returning NULL and re-raise any other exception.",
    "natural_language": "Construct a PL/SQL function, which should be named check_book_release_timestamp, that is designed to accept a specific book identifier as a NUMBER and, optionally, a timezone offset provided as a VARCHAR2 with a default value of '+00:00'. This function's primary purpose is to retrieve the RELEASE date, which is stored in the BOOK table, and meticulously convert it into a TIMESTAMP data type precisely set to midnight. In the event that no corresponding data is located for the given book_id, the function must gracefully handle the NO_DATA_FOUND exception by quietly returning a NULL value. However, for any other unexpected exceptions that may arise during execution, the function must diligently re-raise them to the calling environment.",
    "id": 293
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_reader_score that accepts two input parameters: a numeric parameter p_book_id representing a specific book identifier and a numeric parameter p_multiplier representing a scaling factor, and returns a single numeric value; the function declares a local numeric variable v_total_readers; the function's logic executes a SELECT statement that queries the REVIEW table, specifically summing the values from the READERS_IN_MILLION column for all rows where the BOOK_ID column exactly matches the input parameter p_book_id, then multiplies the resulting sum by the input parameter p_multiplier, and stores the final calculated product into the local variable v_total_readers; the function concludes by returning the value stored in v_total_readers as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_reader_score(p_book_id NUMBER, p_multiplier NUMBER) RETURN NUMBER IS\n    v_total_readers NUMBER;\nBEGIN\n    SELECT SUM(READERS_IN_MILLION) * p_multiplier INTO v_total_readers FROM REVIEW WHERE BOOK_ID = p_book_id;\n    RETURN v_total_readers;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT calculate_reader_score(1, 1.5) FROM DUAL",
      "SELECT calculate_reader_score(3, 2.0) FROM DUAL",
      "SELECT calculate_reader_score(4, 0.8) FROM DUAL",
      "SELECT calculate_reader_score(2, 1.0) FROM DUAL",
      "SELECT calculate_reader_score(1, 0.5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_reader_score that accepts a book ID and a multiplier as numbers, sums the READERS_IN_MILLION from the REVIEW table for that book, multiplies the sum by the multiplier, and returns the result as a number.",
    "natural_language": "What is the result of creating a PL/SQL function called calculate_reader_score that takes a book ID and a multiplier, sums the READERS_IN_MILLION for that book from the REVIEW table, multiplies the total by the multiplier, and returns the final number?",
    "id": 294
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_policy_type` that accepts a single input parameter. This input parameter is named `p_customer_id` and is of data type `NUMBER`, representing a unique identifier for a customer. The function is designed to return a single value of data type `VARCHAR2`, which will represent the policy type associated with the given customer. Inside the function's executable block, a local variable named `v_policy_type` is declared, also of data type `VARCHAR2` with a maximum length of 255 characters, to temporarily store the retrieved policy type. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `POLICY_TYPE_CODE` column. The data is sourced from the table named `CUSTOMER_POLICIES`. The selection is filtered by a `WHERE` clause that specifies two conditions: first, the `CUSTOMER_ID` column in the `CUSTOMER_POLICIES` table must be equal to the value provided in the input parameter `p_customer_id`; second, the `ROWNUM` pseudocolumn is used to limit the result set to only the first row encountered that satisfies the `CUSTOMER_ID` condition. The value retrieved from the `POLICY_TYPE_CODE` column of this single row is then immediately assigned to the local variable `v_policy_type`. Finally, the function returns the value stored in the `v_policy_type` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_policy_type(p_customer_id NUMBER) RETURN VARCHAR2 IS\n    v_policy_type VARCHAR2(255);\nBEGIN\n    SELECT POLICY_TYPE_CODE INTO v_policy_type\n    FROM CUSTOMER_POLICIES\n    WHERE CUSTOMER_ID = p_customer_id\n    AND ROWNUM = 1;\n    RETURN v_policy_type;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "SELECT get_customer_policy_type(1) FROM DUAL",
      "SELECT get_customer_policy_type(2) FROM DUAL",
      "SELECT get_customer_policy_type(3) FROM DUAL",
      "SELECT get_customer_policy_type(4) FROM DUAL",
      "SELECT get_customer_policy_type(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_policy_type that accepts a customer ID number, retrieves the POLICY_TYPE_CODE from the first matching row in the CUSTOMER_POLICIES table for that customer, and returns it as a VARCHAR2.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_customer_policy_type'. This function shall accept a numerical customer ID as its input parameter. It is to query the CUSTOMER_POLICIES table, retrieve the POLICY_TYPE_CODE from the initial record associated with the provided customer ID, and subsequently return this value as a VARCHAR2 data type.",
    "id": 295
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_total_claimed_amount` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function's execution begins by declaring a local variable named `v_total_amount` of data type `NUMBER` to temporarily store the calculated sum. Subsequently, the function performs a `SELECT` operation to compute the sum of values from the `AMOUNT_CLAIMED` column. This `SELECT` statement retrieves data from two tables: `CLAIMS`, aliased as `cl`, and `CUSTOMER_POLICIES`, aliased as `cp`. These two tables are joined using an `INNER JOIN` operation based on the equality of the `POLICY_ID` column in the `CLAIMS` table (`cl.POLICY_ID`) and the `POLICY_ID` column in the `CUSTOMER_POLICIES` table (`cp.POLICY_ID`). The `WHERE` clause filters the joined results, including only those rows where the `CUSTOMER_ID` column in the `CUSTOMER_POLICIES` table (`cp.CUSTOMER_ID`) matches the value provided in the input parameter `p_customer_id`. The calculated sum of `AMOUNT_CLAIMED` for these filtered and joined rows is then stored into the local variable `v_total_amount`. Finally, the function returns the value stored in `v_total_amount` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_claimed_amount(p_customer_id NUMBER) RETURN NUMBER IS\n    v_total_amount NUMBER;\nBEGIN\n    SELECT SUM(AMOUNT_CLAIMED) INTO v_total_amount\n    FROM CLAIMS cl\n    JOIN CUSTOMER_POLICIES cp ON cl.POLICY_ID = cp.POLICY_ID\n    WHERE cp.CUSTOMER_ID = p_customer_id;\n    RETURN v_total_amount;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "SELECT calculate_total_claimed_amount(1) FROM DUAL",
      "SELECT calculate_total_claimed_amount(2) FROM DUAL",
      "SELECT calculate_total_claimed_amount(3) FROM DUAL",
      "SELECT calculate_total_claimed_amount(100) FROM DUAL",
      "SELECT calculate_total_claimed_amount(50) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_total_claimed_amount that accepts a customer ID number, sums the AMOUNT_CLAIMED from the CLAIMS table for all policies belonging to that customer by joining with CUSTOMER_POLICIES, and returns the total as a number.",
    "natural_language": "Write a PL/SQL function called calculate_total_claimed_amount. It should take a customer ID as input, join the CLAIMS and CUSTOMER_POLICIES tables to sum the AMOUNT_CLAIMED for all that customer's policies, and return the total sum as a number.",
    "id": 296
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_details_hash that accepts a single parameter, p_customer_id, of type NUMBER, which represents the unique identifier of a customer. The function returns a value of type VARCHAR2, specifically a hash string of length 64 characters. Within the function, a local variable v_hash of type VARCHAR2(64) is declared to store the hash result. The function performs a SELECT operation on the CUSTOMERS table, targeting the CUSTOMER_DETAILS column, and applies the STANDARD_HASH function with the 'SHA256' algorithm to compute a cryptographic hash of the CUSTOMER_DETAILS data. The result of this hash computation is stored into the v_hash variable. The SELECT statement includes a WHERE clause that filters the rows based on the condition that the CUSTOMER_ID column matches the value provided in the p_customer_id parameter. After successfully retrieving and hashing the CUSTOMER_DETAILS for the specified customer, the function returns the computed hash value stored in v_hash.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_details_hash(p_customer_id NUMBER) RETURN VARCHAR2 IS\n    v_hash VARCHAR2(64);\nBEGIN\n    SELECT STANDARD_HASH(CUSTOMER_DETAILS, 'SHA256') INTO v_hash\n    FROM CUSTOMERS\n    WHERE CUSTOMER_ID = p_customer_id;\n    RETURN v_hash;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "SELECT get_customer_details_hash(1) FROM DUAL",
      "SELECT get_customer_details_hash(2) FROM DUAL",
      "SELECT get_customer_details_hash(3) FROM DUAL",
      "SELECT get_customer_details_hash( (SELECT MIN(CUSTOMER_ID) FROM CUSTOMERS) ) FROM DUAL",
      "SELECT get_customer_details_hash( (SELECT MAX(CUSTOMER_ID) FROM CUSTOMERS) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_details_hash that accepts a customer ID number, computes a SHA256 hash of the CUSTOMER_DETAILS column from the CUSTOMERS table for that customer, and returns the 64-character hash string.",
    "natural_language": "Compute and return a 64-character SHA256 hash string for the CUSTOMER_DETAILS column of the specified customer from the CUSTOMERS table. Implement this as a PL/SQL function named get_customer_details_hash that takes a customer ID number as input.",
    "id": 297
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_average_settlement_ratio` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER`. The purpose of this function is to compute and return a single `NUMBER` value representing the average settlement ratio for a specific customer. The function's execution begins by declaring a local variable named `v_avg_ratio` of data type `NUMBER` to temporarily store the calculated average. Subsequently, the function executes a `SELECT` statement to perform the core calculation. This `SELECT` statement calculates the average of a derived ratio. The ratio is determined by dividing the value in the `AMOUNT_SETTLED` column by the value in the `AMOUNT_CLAIMED` column. This calculation is performed for each relevant record. The `SELECT` statement retrieves data from the `CLAIMS` table, aliased as `cl`, and joins it with the `CUSTOMER_POLICIES` table, aliased as `cp`. The join condition specifies that records from `CLAIMS` and `CUSTOMER_POLICIES` are linked where the `POLICY_ID` column in the `CLAIMS` table (`cl.POLICY_ID`) matches the `POLICY_ID` column in the `CUSTOMER_POLICIES` table (`cp.POLICY_ID`). Furthermore, the `WHERE` clause filters these joined records, ensuring that only those records where the `CUSTOMER_ID` column in the `CUSTOMER_POLICIES` table (`cp.CUSTOMER_ID`) is equal to the value provided in the input parameter `p_customer_id` are considered for the average calculation. The result of this average calculation is then stored into the local variable `v_avg_ratio`. Finally, the function concludes its execution by returning the value stored in `v_avg_ratio` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_settlement_ratio(p_customer_id NUMBER) RETURN NUMBER IS\n    v_avg_ratio NUMBER;\nBEGIN\n    SELECT AVG(AMOUNT_SETTLED / AMOUNT_CLAIMED) INTO v_avg_ratio\n    FROM CLAIMS cl\n    JOIN CUSTOMER_POLICIES cp ON cl.POLICY_ID = cp.POLICY_ID\n    WHERE cp.CUSTOMER_ID = p_customer_id;\n    RETURN v_avg_ratio;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "SELECT calculate_average_settlement_ratio(1) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(2) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(3) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(4) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_average_settlement_ratio that accepts a customer ID number, calculates the average of (AMOUNT_SETTLED / AMOUNT_CLAIMED) from the CLAIMS table for all policies belonging to that customer by joining with CUSTOMER_POLICIES, and returns the average as a number.",
    "natural_language": "Write function calculate_average_settlement_ratio. Takes customer ID. Return average of AMOUNT_SETTLED / AMOUNT_CLAIMED from CLAIMS via CUSTOMER_POLICIES join.",
    "id": 298
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_organizer_count` that is designed to return a single numeric value. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement calculates the total number of rows in the `PARTICIPANTS` table. The count is determined by applying a `COUNT(*)` aggregate function, which counts all rows that satisfy a specific condition. The condition for counting is `WHERE PARTICIPANT_TYPE_CODE = 'Organizer'`, meaning only rows where the value in the `PARTICIPANT_TYPE_CODE` column is exactly equal to the string literal 'Organizer' (case-sensitive) will be included in the count. The result of this `COUNT(*)` operation is then immediately stored into the `v_count` local variable using the `INTO` clause. Finally, the function concludes its execution by returning the numeric value currently held in the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_organizer_count RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM PARTICIPANTS WHERE PARTICIPANT_TYPE_CODE = 'Organizer';\n  RETURN v_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_organizer_count FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_organizer_count with no parameters that returns the count of rows from the PARTICIPANTS table where PARTICIPANT_TYPE_CODE equals 'Organizer'.",
    "natural_language": "Function get_organizer_count to count 'Organizer' participants.",
    "id": 299
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_marriage_service_count that returns a numeric value representing the count of records in the SERVICES table where the SERVICE_TYPE_CODE column, when converted to lowercase using the LOWER() function, matches the string 'marriage'. The function does not take any input parameters. It declares a local variable v_count of type NUMBER to store the result of the query. Within the function's execution block, a SELECT statement is used to count all rows in the SERVICES table that satisfy the condition of having a SERVICE_TYPE_CODE that, when transformed to lowercase, equals 'marriage'. The COUNT(*) aggregate function is employed to determine the total number of such rows, and the result is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the number of marriage service records found in the SERVICES table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_marriage_service_count RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM SERVICES WHERE LOWER(SERVICE_TYPE_CODE) = 'marriage';\n  RETURN v_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_marriage_service_count FROM DUAL",
      "SELECT get_marriage_service_count() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_marriage_service_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Marriage services: ' || get_marriage_service_count);\nEND;",
      "SELECT get_marriage_service_count AS marriage_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_marriage_service_count with no parameters that returns the count of rows from the SERVICES table where the lowercase SERVICE_TYPE_CODE equals 'marriage'.",
    "natural_language": "What is the count of rows in the SERVICES table where the SERVICE_TYPE_CODE, converted to lowercase, is 'marriage'?",
    "id": 300
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_participants_in_events that takes no input parameters and returns a single numeric value of type NUMBER, which is the sum of all values found in the PARTICIPANT_ID column of the PARTICIPANTS_IN_EVENTS table, achieved by executing a SELECT statement that uses the SQL aggregate function SUM on the PARTICIPANT_ID column and stores the resulting scalar value into a local variable v_total, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_participants_in_events RETURN NUMBER IS\n  v_total NUMBER;\nBEGIN\n  SELECT SUM(PARTICIPANT_ID) INTO v_total FROM PARTICIPANTS_IN_EVENTS;\n  RETURN v_total;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_total_participants_in_events FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_total_participants_in_events with no parameters that returns the sum of all PARTICIPANT_ID values from the PARTICIPANTS_IN_EVENTS table.",
    "natural_language": "Function get_total_participants_in_events returns sum of PARTICIPANT_ID.",
    "id": 301
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_min_event_id that returns a value of type NUMBER. This function does not take any input parameters. Within the function, declare a local variable v_min_id of type NUMBER to store the result of a query. Execute a SELECT statement that retrieves the minimum value from the EVENT_ID column in the EVENTS table and assigns this value to the v_min_id variable. The SELECT statement uses the MIN() aggregate function to determine the smallest EVENT_ID present in the EVENTS table. After the SELECT operation, the function returns the value stored in v_min_id, which represents the minimum EVENT_ID found in the table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_min_event_id RETURN NUMBER IS\n  v_min_id NUMBER;\nBEGIN\n  SELECT MIN(EVENT_ID) INTO v_min_id FROM EVENTS;\n  RETURN v_min_id;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_min_event_id FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_min_event_id with no parameters that returns the minimum EVENT_ID value from the EVENTS table.",
    "natural_language": "Hey, can you whip up a function called get_min_event_id? It doesn't need any inputs, just give back the smallest EVENT_ID you can find in the EVENTS table.",
    "id": 302
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_success_event_count` that is designed to return a single numeric value. This function does not accept any input parameters. Internally, it declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement calculates the total number of rows in the `EVENTS` table where the value in the `EVENT_DETAILS` column is exactly equal to the string literal 'Success'. The result of this count operation is then immediately assigned to the `v_count` local variable. Finally, the function returns the value currently stored in the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_success_event_count RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM EVENTS WHERE EVENT_DETAILS = 'Success';\n  RETURN v_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_success_event_count FROM DUAL",
      "SELECT get_success_event_count() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_success_event_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Success events: ' || get_success_event_count);\nEND;",
      "SELECT get_success_event_count AS success_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_success_event_count with no parameters that returns the count of rows from the EVENTS table where EVENT_DETAILS equals 'Success'.",
    "natural_language": "Create a PL/SQL function, which should be named get_success_event_count, that accepts no input parameters and is designed to return a precise numerical count of all the rows meticulously extracted from the EVENTS table, specifically targeting those entries where the EVENT_DETAILS column contains the exact and singular string value of 'Success'.",
    "id": 303
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_pet_weight_category that accepts a single input parameter p_petid of the NUMBER data type and returns a VARCHAR2 value, where the function's logic begins by declaring two local variables: v_weight of type NUMBER and v_category of type VARCHAR2 with a maximum length of 20 characters, then executes a SELECT statement to query the WEIGHT column from the PETS table, specifically retrieving the WEIGHT value for the row where the PETID column exactly matches the provided input parameter p_petid, and stores this retrieved value into the local variable v_weight, after which it evaluates a conditional IF statement that checks if the value in v_weight is less than 10, and if this condition is true, assigns the string literal 'Light' to the variable v_category, otherwise, if the condition is false (meaning v_weight is 10 or greater), assigns the string literal 'Heavy' to the variable v_category, and finally concludes by using a RETURN statement to output the value stored in v_category.",
    "plsql": "CREATE OR REPLACE FUNCTION get_pet_weight_category(p_petid IN NUMBER) RETURN VARCHAR2 IS\n    v_weight NUMBER;\n    v_category VARCHAR2(20);\nBEGIN\n    SELECT WEIGHT INTO v_weight FROM PETS WHERE PETID = p_petid;\n    IF v_weight < 10 THEN\n        v_category := 'Light';\n    ELSE\n        v_category := 'Heavy';\n    END IF;\n    RETURN v_category;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "SELECT get_pet_weight_category(2001) FROM DUAL",
      "SELECT get_pet_weight_category(2002) FROM DUAL",
      "SELECT get_pet_weight_category(2003) FROM DUAL",
      "SELECT p.PETID, p.PETTYPE, get_pet_weight_category(p.PETID) AS weight_category FROM PETS p",
      "SELECT hp.STUID, hp.PETID, get_pet_weight_category(hp.PETID) AS weight_category FROM HAS_PET hp"
    ],
    "summary": "Create a PL/SQL function named get_pet_weight_category that takes a pet ID number and returns a VARCHAR2. It retrieves the pet's weight from the PETS table. If the weight is less than 10, return 'Light'; otherwise, return 'Heavy'.",
    "natural_language": "Write a PL/SQL function called get_pet_weight_category that accepts a pet ID number and outputs a VARCHAR2. Fetch the pet's weight from the PETS table. For a weight under 10, output 'Light'; otherwise, output 'Heavy'.",
    "id": 304
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_pet_age_group that accepts a single input parameter p_petid of type NUMBER, which represents the unique identifier of a pet. The function is designed to return a value of type VARCHAR2, specifically a string that categorizes the pet's age group. Within the function, a local variable v_age of type NUMBER is declared to store the age of the pet, and another local variable v_group of type VARCHAR2(20) is declared to store the age group classification. The function begins by executing a SELECT statement to retrieve the PET_AGE column value from the PETS table, where the PETID column matches the input parameter p_petid. The retrieved age value is stored in the v_age variable. Following this, a conditional IF statement evaluates the value of v_age. If v_age is less than or equal to 2, the function assigns the string 'Young' to the v_group variable. If v_age is greater than 2, the function assigns the string 'Adult' to the v_group variable. Finally, the function returns the value stored in v_group, which represents the age group classification of the pet based on its age.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_pet_age_group(p_petid IN NUMBER) RETURN VARCHAR2 IS\n    v_age NUMBER;\n    v_group VARCHAR2(20);\nBEGIN\n    SELECT PET_AGE INTO v_age FROM PETS WHERE PETID = p_petid;\n    IF v_age <= 2 THEN\n        v_group := 'Young';\n    ELSE\n        v_group := 'Adult';\n    END IF;\n    RETURN v_group;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "SELECT calculate_pet_age_group(2001) FROM DUAL",
      "SELECT calculate_pet_age_group(2002) FROM DUAL",
      "SELECT calculate_pet_age_group(2003) FROM DUAL",
      "SELECT p.PETID, p.PETTYPE, calculate_pet_age_group(p.PETID) AS AGE_GROUP FROM PETS p",
      "SELECT hp.STUID, p.PETID, p.PETTYPE, calculate_pet_age_group(p.PETID) AS AGE_GROUP FROM HAS_PET hp JOIN PETS p ON hp.PETID = p.PETID"
    ],
    "summary": "Create a PL/SQL function named calculate_pet_age_group that takes a pet ID number and returns a VARCHAR2. It retrieves the pet's age from the PETS table. If the age is 2 or less, return 'Young'; otherwise, return 'Adult'.",
    "natural_language": "Develop a PL/SQL function called calculate_pet_age_group, which accepts a numerical pet ID as its input parameter and yields a VARCHAR2 output. This function should query the PETS table to obtain the specific pet's age. Subsequently, it must evaluate that age: if the pet is two years old or younger, it should categorically return the string 'Young'; in all other cases, it should definitively return the label 'Adult'.",
    "id": 305
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_student_has_pet that accepts a single input parameter p_stuid of type NUMBER, which represents a student ID. The function performs a SELECT operation to count the number of rows in the HAS_PET table where the STUID column matches the value of the input parameter p_stuid. The result of this count is stored in a local variable v_count of type NUMBER. The function then uses a conditional statement to check if the value of v_count is greater than 0. If this condition is true, indicating that there is at least one row in the HAS_PET table with the specified student ID, the function assigns the string 'Yes' to another local variable v_result of type VARCHAR2(10). If the condition is false, meaning there are no rows with the specified student ID, the function assigns the string 'No' to v_result. Finally, the function returns the value of v_result, which indicates whether the student with the given ID has a pet or not.",
    "plsql": "CREATE OR REPLACE FUNCTION check_student_has_pet(p_stuid IN NUMBER) RETURN VARCHAR2 IS\n    v_count NUMBER;\n    v_result VARCHAR2(10);\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM HAS_PET WHERE STUID = p_stuid;\n    IF v_count > 0 THEN\n        v_result := 'Yes';\n    ELSE\n        v_result := 'No';\n    END IF;\n    RETURN v_result;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "SELECT check_student_has_pet(1001) FROM DUAL",
      "SELECT check_student_has_pet(1002) FROM DUAL",
      "SELECT check_student_has_pet(1003) FROM DUAL",
      "SELECT STUID, check_student_has_pet(STUID) FROM HAS_PET WHERE STUID = 1001",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE(check_student_has_pet(1002));\nEND;"
    ],
    "summary": "Create a PL/SQL function named check_student_has_pet that takes a student ID number and returns a VARCHAR2. It counts the records for that student in the HAS_PET table. If the count is greater than 0, return 'Yes'; otherwise, return 'No'.",
    "natural_language": "Develop a PL/SQL function called check_student_has_pet, which accepts a student's unique identification number as its input parameter and yields a VARCHAR2 data type as its output. This function should meticulously examine the HAS_PET table, carefully tallying all entries associated with the provided student ID. Should the resulting count exceed zero, the function must thoughtfully return the string 'Yes'; conversely, if no records are found, it must definitively return the string 'No'.",
    "id": 306
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_pet_type_length that accepts a single input parameter p_petid of type NUMBER, which represents the unique identifier of a pet. The function retrieves the PETTYPE column value from the PETS table for the row where the PETID column matches the provided p_petid parameter. It stores this PETTYPE value in a local variable v_pettype of type VARCHAR2 with a maximum length of 255 characters. The function then calculates the length of the string stored in v_pettype using the LENGTH function, assigning the result to another local variable v_length of type NUMBER. Finally, the function returns the value of v_length, which represents the number of characters in the pet type string associated with the specified pet ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_pet_type_length(p_petid IN NUMBER) RETURN NUMBER IS\n    v_pettype VARCHAR2(255);\n    v_length NUMBER;\nBEGIN\n    SELECT PETTYPE INTO v_pettype FROM PETS WHERE PETID = p_petid;\n    v_length := LENGTH(v_pettype);\n    RETURN v_length;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "SELECT get_pet_type_length(2001) FROM dual",
      "SELECT get_pet_type_length(2002) FROM dual",
      "SELECT get_pet_type_length(2003) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_pet_type_length that takes a pet ID number and returns a NUMBER. It retrieves the pet type from the PETS table and returns the length of that string.",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_pet_type_length', which accepts a single numeric parameter representing a pet identifier. This function shall query the PETS table to obtain the corresponding pet type and subsequently return the character length of that type as a NUMBER data type.",
    "id": 307
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_weight_rounded that accepts a single input parameter p_petid of type NUMBER, which is used to identify a specific pet record, and returns a value of type NUMBER; the function begins by declaring a local variable v_weight of type NUMBER to hold a retrieved weight value and another local variable v_rounded of type NUMBER to hold the result of a rounding operation; the function then executes a SELECT statement that queries the WEIGHT column from the PETS table, specifically from the row where the PETID column value exactly matches the provided input parameter p_petid, and stores the retrieved WEIGHT value into the local variable v_weight; following this data retrieval, the function calls the built-in ROUND function on the value stored in v_weight, which computes the nearest whole number, and assigns this rounded result to the local variable v_rounded; finally, the function returns the value contained in v_rounded as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_weight_rounded(p_petid IN NUMBER) RETURN NUMBER IS\n    v_weight NUMBER;\n    v_rounded NUMBER;\nBEGIN\n    SELECT WEIGHT INTO v_weight FROM PETS WHERE PETID = p_petid;\n    v_rounded := ROUND(v_weight);\n    RETURN v_rounded;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "SELECT calculate_weight_rounded(2001) FROM DUAL",
      "SELECT calculate_weight_rounded(2002) FROM DUAL",
      "SELECT calculate_weight_rounded(2003) FROM DUAL",
      "SELECT calculate_weight_rounded( (SELECT PETID FROM PETS WHERE PETTYPE = 'cat' AND ROWNUM = 1) ) FROM DUAL",
      "SELECT calculate_weight_rounded( (SELECT PETID FROM PETS WHERE WEIGHT > 10 AND ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_weight_rounded that takes a pet ID number and returns a NUMBER. It retrieves the pet's weight from the PETS table and returns the weight rounded to the nearest whole number.",
    "natural_language": "Develop a PL/SQL function, which should be named calculate_weight_rounded, that is designed to accept a single input parameter corresponding to a pet's unique identification number. This function's primary purpose is to fetch the specific weight value for that pet from the comprehensive PETS table and then meticulously return that weight, which has been precisely rounded to the nearest integer value, as a NUMBER data type.",
    "id": 308
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_pet_count that accepts two input parameters: a numeric parameter p_stuid representing a student identifier and a string parameter p_pettype representing a type of pet, and returns a numeric value; within the function, a local variable v_count of type NUMBER is declared; the function's logic executes a SELECT statement that performs an INNER JOIN between the HAS_PET table (aliased as h) and the PETS table (aliased as p) using the condition that the PETID column from the HAS_PET table equals the PETID column from the PETS table; from this joined result set, the function counts all rows where the STUID column from the HAS_PET table matches the input parameter p_stuid and where the PETTYPE column from the PETS table, after being converted to uppercase using the UPPER function, matches the input parameter p_pettype after it is also converted to uppercase using the UPPER function; this count is stored into the local variable v_count via the INTO clause; the function then concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_pet_count(p_stuid NUMBER, p_pettype VARCHAR2)\nRETURN NUMBER\nIS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count \n  FROM HAS_PET h \n  JOIN PETS p ON h.PETID = p.PETID \n  WHERE h.STUID = p_stuid AND UPPER(p.PETTYPE) = UPPER(p_pettype);\n  RETURN v_count;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_student_pet_count(1001, 'cat') FROM dual",
      "SELECT get_student_pet_count(1001, 'dog') FROM dual",
      "SELECT get_student_pet_count(1002, 'cat') FROM dual",
      "SELECT get_student_pet_count(1002, 'dog') FROM dual",
      "SELECT get_student_pet_count(1001, 'CAT') FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_student_pet_count that returns a number. It accepts a student ID (number) and a pet type (string). It counts rows from an inner join of the HAS_PET and PETS tables where the student ID matches and the pet type (case-insensitive) matches, then returns the count.",
    "natural_language": "How many pets of a specified type does a given student have, based on a case-insensitive match in the HAS_PET and PETS tables?",
    "id": 309
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_avg_pet_weight that accepts two input parameters: a numeric parameter p_stuid representing a student identifier and a numeric parameter p_min_age representing a minimum age threshold, and returns a single numeric value; within the function, a local variable v_avg_weight of type NUMBER is declared to hold the result; the function's logic executes a SELECT statement that calculates the average value of the WEIGHT column from the PETS table, aliased as p, by performing an inner join between the HAS_PET table, aliased as h, and the PETS table on the condition that the PETID column from HAS_PET matches the PETID column from PETS; the query includes a WHERE clause with two conditions joined by an AND operator: the first condition filters rows where the STUID column from the HAS_PET table equals the input parameter p_stuid, and the second condition filters rows where the PET_AGE column from the PETS table is greater than or equal to the input parameter p_min_age; the computed average value is retrieved from the query and stored into the local variable v_avg_weight using an INTO clause; finally, the function returns the value stored in v_avg_weight.",
    "plsql": "CREATE OR REPLACE FUNCTION get_avg_pet_weight(p_stuid NUMBER, p_min_age NUMBER)\nRETURN NUMBER\nIS\n  v_avg_weight NUMBER;\nBEGIN\n  SELECT AVG(p.WEIGHT) INTO v_avg_weight \n  FROM HAS_PET h \n  JOIN PETS p ON h.PETID = p.PETID \n  WHERE h.STUID = p_stuid AND p.PET_AGE >= p_min_age;\n  RETURN v_avg_weight;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_avg_pet_weight(1001, 1) FROM DUAL",
      "SELECT get_avg_pet_weight(1001, 2) FROM DUAL",
      "SELECT get_avg_pet_weight(1001, 3) FROM DUAL",
      "SELECT get_avg_pet_weight(1002, 1) FROM DUAL",
      "SELECT get_avg_pet_weight(1002, 2) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_avg_pet_weight that returns a number. It accepts a student ID (number) and a minimum age (number). It calculates the average weight from the PETS table for pets belonging to that student and with an age greater than or equal to the minimum age, then returns the average.",
    "natural_language": "Write a PL/SQL function called get_avg_pet_weight that gives back a number. It should take a student ID and a sort of baseline age as inputs. Figure out the typical weight from the PETS table for that student's pets, but only for the ones that are reasonably old enough, meaning at least around the minimum age provided, and then return that average figure.",
    "id": 310
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_major_count that accepts two parameters: p_major of type NUMBER and p_city_code of type VARCHAR2. This function is designed to return a NUMBER representing the count of students from the STUDENT table who have a major that matches the value of p_major and a city code that matches the value of p_city_code. The function begins by declaring a local variable v_count of type NUMBER to store the result of the count operation. It then executes a SELECT statement that counts all rows in the STUDENT table where the MAJOR column equals the input parameter p_major and the CITY_CODE column equals the input parameter p_city_code. The result of this count is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the number of students meeting the specified criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_major_count(p_major NUMBER, p_city_code VARCHAR2)\nRETURN NUMBER\nIS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count \n  FROM STUDENT \n  WHERE MAJOR = p_major AND CITY_CODE = p_city_code;\n  RETURN v_count;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_student_major_count(600, 'BAL') FROM DUAL",
      "SELECT get_student_major_count(600, 'HKG') FROM DUAL",
      "SELECT get_student_major_count(500, 'WAS') FROM DUAL",
      "SELECT get_student_major_count(700, 'NYC') FROM DUAL",
      "SELECT get_student_major_count(NULL, 'BAL') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_student_major_count that returns a number. It accepts a major code (number) and a city code (string). It counts students from the STUDENT table where the major and city code match the input parameters, then returns the count.",
    "natural_language": "Count the number of students by writing a PL/SQL function called get_student_major_count. The function must take a major code as a number and a city code as a string, find matching records in the STUDENT table, and return the total count.",
    "id": 311
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_pet_type_count` that is designed to return a single numeric value representing a count. This function accepts two input parameters: `p_pettype`, which is of type `VARCHAR2` and is intended to specify a particular type of pet, and `p_min_weight`, which is of type `NUMBER` and is intended to specify a minimum weight threshold. Internally, the function declares a local variable named `v_count` of type `NUMBER` to store the result of a database query. The core operation of the function involves executing a `SELECT` statement to retrieve a count of records from a table named `PETS`. This `SELECT` statement uses the `COUNT(*)` aggregate function to count all rows that satisfy specific conditions. The conditions applied in the `WHERE` clause are as follows: first, the value in the `PETTYPE` column of the `PETS` table is converted to uppercase using the `UPPER()` SQL function, and this uppercase value is then compared for equality with the uppercase version of the `p_pettype` input parameter, also converted using `UPPER()`. Second, the value in the `WEIGHT` column of the `PETS` table must be greater than or equal to the value provided in the `p_min_weight` input parameter. The total count of rows that meet both of these criteria is then stored into the `v_count` local variable. Finally, the function returns the value stored in `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_pet_type_count(p_pettype VARCHAR2, p_min_weight NUMBER)\nRETURN NUMBER\nIS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count \n  FROM PETS \n  WHERE UPPER(PETTYPE) = UPPER(p_pettype) AND WEIGHT >= p_min_weight;\n  RETURN v_count;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_pet_type_count('cat', 10) FROM DUAL",
      "SELECT get_pet_type_count('dog', 12) FROM DUAL",
      "SELECT get_pet_type_count('Cat', 9) FROM DUAL",
      "SELECT get_pet_type_count('dog', 15) FROM DUAL",
      "SELECT get_pet_type_count('bird', 5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_pet_type_count that returns a number. It accepts a pet type (string) and a minimum weight (number). It counts pets from the PETS table where the pet type (case-insensitive) matches and the weight is at least the minimum, then returns the count.",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_pet_type_count', which shall yield a numerical value. This function must accept two parameters: a string representing a pet type and a number specifying a minimum weight. Its operational logic is to query the PETS table, count the entries where the pet type matches the provided string in a case-insensitive manner and the recorded weight meets or exceeds the stipulated minimum, and subsequently return the resultant count.",
    "id": 312
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_advisor_count that accepts two input parameters: a numeric parameter p_advisor and a string parameter p_sex, and returns a numeric value. The function declares a local numeric variable v_count. The function's logic executes a SELECT statement that queries the STUDENT table, performing a COUNT(*) aggregation. The query includes a WHERE clause with two conditions joined by a logical AND: the first condition filters rows where the ADVISOR column value is exactly equal to the input parameter p_advisor, and the second condition filters rows where the uppercase version of the SEX column, obtained by applying the UPPER function, is equal to the uppercase version of the input parameter p_sex, also obtained by applying the UPPER function. The result of the count aggregation is stored into the local variable v_count using an INTO clause. The function then concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_advisor_count(p_advisor NUMBER, p_sex VARCHAR2)\nRETURN NUMBER\nIS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count \n  FROM STUDENT \n  WHERE ADVISOR = p_advisor AND UPPER(SEX) = UPPER(p_sex);\n  RETURN v_count;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_student_advisor_count(1121, 'F') FROM dual",
      "SELECT get_student_advisor_count(7712, 'F') FROM dual",
      "SELECT get_student_advisor_count(7792, 'F') FROM dual",
      "SELECT get_student_advisor_count(1121, 'M') FROM dual",
      "SELECT get_student_advisor_count(7712, 'M') FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_student_advisor_count that returns a number. It accepts an advisor ID (number) and a sex (string). It counts students from the STUDENT table where the advisor matches and the sex (case-insensitive) matches, then returns the count.",
    "natural_language": "How many students in the STUDENT table are assigned to a specific advisor and have a given sex, with the sex comparison being case-insensitive?",
    "id": 313
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_instrument_count that accepts a single input parameter, p_songid, of type NUMBER, which represents the unique identifier of a song. The function is designed to return a NUMBER that indicates the count of instruments associated with the specified song. Within the function, a local variable v_result of type NUMBER is declared to store the result of a query. The function executes a SELECT statement that counts the number of rows in the INSTRUMENTS table where the SONGID column matches the value of the input parameter p_songid. The COUNT(*) function is used to determine the total number of matching rows, and the result is stored in the v_result variable. Finally, the function returns the value of v_result, which represents the total number of instruments linked to the given song ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_instrument_count(p_songid IN NUMBER) RETURN NUMBER IS\n    v_result NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_result FROM INSTRUMENTS WHERE SONGID = p_songid;\n    RETURN v_result;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_instrument_count(1) FROM DUAL",
      "SELECT get_instrument_count(5) FROM DUAL",
      "SELECT get_instrument_count(10) FROM DUAL",
      "SELECT get_instrument_count(SONGID) FROM SONGS WHERE TITLE = 'My Song'",
      "SELECT SONGID, TITLE, get_instrument_count(SONGID) AS INSTRUMENT_COUNT FROM SONGS"
    ],
    "summary": "Create a PL/SQL function named get_instrument_count that accepts a song ID (NUMBER) and returns the count of instruments associated with that song from the INSTRUMENTS table.",
    "natural_language": "Write a PL/SQL function called get_instrument_count that takes a song ID and gives back a number representing roughly how many instruments are linked to that song in the INSTRUMENTS table.",
    "id": 314
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_vocal_type_exists that accepts a single input parameter p_type of type VARCHAR2, which represents the type of vocal to be checked for existence in the database. The function declares a local variable v_exists of type VARCHAR2(1) to store the result of the existence check. Within the function body, a SELECT statement is executed to retrieve a single character 'Y' from the VOCALS table, specifically from the first row that matches the condition where the TYPE column is equal to the input parameter p_type. The ROWNUM = 1 condition ensures that only the first matching row is considered, even if multiple rows satisfy the condition. If a matching row is found, the character 'Y' is assigned to the v_exists variable. The function then returns the value of v_exists, which will be 'Y' if a matching vocal type exists in the VOCALS table, or it will raise a NO_DATA_FOUND exception if no matching row is found, as the SELECT INTO statement requires at least one row to be returned.",
    "plsql": "CREATE OR REPLACE FUNCTION check_vocal_type_exists(p_type IN VARCHAR2) RETURN VARCHAR2 IS\n    v_exists VARCHAR2(1);\nBEGIN\n    SELECT 'Y' INTO v_exists FROM VOCALS WHERE TYPE = p_type AND ROWNUM = 1;\n    RETURN v_exists;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT check_vocal_type_exists('Soprano') FROM DUAL",
      "SELECT check_vocal_type_exists('Alto') FROM DUAL",
      "SELECT check_vocal_type_exists('Tenor') FROM DUAL",
      "SELECT check_vocal_type_exists('Bass') FROM DUAL",
      "SELECT check_vocal_type_exists('Baritone') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_vocal_type_exists that accepts a vocal type (VARCHAR2) and returns 'Y' if the type exists in the VOCALS table. It should raise NO_DATA_FOUND if the type does not exist.",
    "natural_language": "Hey, can you whip up a PL/SQL function called check_vocal_type_exists? It should take a vocal type (as a VARCHAR2) and spit out 'Y' if that type is already in the VOCALS table. If the type isn't there, it needs to throw a NO_DATA_FOUND error.",
    "id": 315
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_song_title` that accepts a single input parameter, `p_songid`, which is of data type `NUMBER`. This function is designed to retrieve and return a `VARCHAR2` value representing the title of a song. Internally, the function declares a local variable named `v_title` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved song title. The core operation involves executing a `SELECT` statement to query the `SONGS` table. Specifically, it selects the value from the `TITLE` column and attempts to store this value into the `v_title` variable. This selection is conditional, applying a `WHERE` clause that filters rows based on the `SONGID` column matching the value provided by the input parameter `p_songid`. After successfully retrieving the title into `v_title`, the function then returns the value stored in `v_title` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_song_title(p_songid IN NUMBER) RETURN VARCHAR2 IS\n    v_title VARCHAR2(255);\nBEGIN\n    SELECT TITLE INTO v_title FROM SONGS WHERE SONGID = p_songid;\n    RETURN v_title;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_song_title(1) FROM DUAL",
      "SELECT get_song_title(5) FROM DUAL",
      "SELECT get_song_title(10) FROM DUAL",
      "SELECT get_song_title(15) FROM DUAL",
      "SELECT get_song_title(20) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_song_title that accepts a song ID (NUMBER) and returns the song title (VARCHAR2) from the SONGS table for that ID.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_song_title? It should take a song ID (as a NUMBER) and spit back the title (as a VARCHAR2) from the SONGS table for that specific ID.",
    "id": 316
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_student_pet_eligibility` that accepts a single input parameter, `p_stuid`, which is of data type `NUMBER` and represents a student's unique identifier. This function is designed to determine a student's eligibility based on whether they own any pets and returns a `VARCHAR2` string indicating this eligibility. Upon execution, the function first declares a local variable `v_pet_count` of data type `NUMBER` to temporarily store the count of pets associated with the student. It then performs a `SELECT` operation to count the number of records in the `HAS_PET` table. The `COUNT(*)` aggregate function is used to count all rows that satisfy the specified condition. The condition for this `SELECT` statement is `STUID = p_stuid`, meaning it only considers rows where the `STUID` column in the `HAS_PET` table matches the value provided in the `p_stuid` input parameter. The result of this count is then immediately stored into the `v_pet_count` variable using the `INTO` clause. Following this data retrieval, the function proceeds with a conditional `IF` statement. It checks if the value stored in `v_pet_count` is equal to `0`. If `v_pet_count` is indeed `0`, indicating that no pets are associated with the student identified by `p_stuid`, the function returns the string literal `'ELIGIBLE'`. Otherwise, if `v_pet_count` is not `0` (meaning one or more pets are associated with the student), the function returns the string literal `'INELIGIBLE'`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_student_pet_eligibility(p_stuid IN NUMBER) RETURN VARCHAR2 IS\n    v_pet_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_pet_count FROM HAS_PET WHERE STUID = p_stuid;\n    IF v_pet_count = 0 THEN\n        RETURN 'ELIGIBLE';\n    ELSE\n        RETURN 'INELIGIBLE';\n    END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT check_student_pet_eligibility(1001) FROM DUAL",
      "SELECT check_student_pet_eligibility(1002) FROM DUAL",
      "SELECT check_student_pet_eligibility(1003) FROM DUAL",
      "SELECT check_student_pet_eligibility(1000) FROM DUAL",
      "SELECT check_student_pet_eligibility(1004) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_student_pet_eligibility that accepts a student ID (NUMBER). It returns 'ELIGIBLE' if the student has no pets in the HAS_PET table, otherwise returns 'INELIGIBLE'.",
    "natural_language": "Develop a PL/SQL function, to be named check_student_pet_eligibility, which is designed to receive a single input parameter corresponding to a student's unique identification number, formatted as a NUMBER. This function should meticulously evaluate the student's record within the HAS_PET table. If, upon thorough inspection, it is determined that the specified student has absolutely zero registered pets—meaning no entries exist for that student ID—then the function must formally return the string 'ELIGIBLE'. Conversely, if any pet association is discovered, even just one, the function must consequently and unequivocally return the string 'INELIGIBLE'.",
    "id": 317
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_pet_age_category` that accepts a single input parameter, `p_petid`, which is of data type `NUMBER` and represents the unique identifier for a pet. This function is designed to return a `VARCHAR2` value, indicating the age category of the pet. Upon execution, the function first declares a local variable named `v_pet_age` of data type `NUMBER` to temporarily store the retrieved age of the pet. It then performs a `SELECT` operation to retrieve the value from the `PET_AGE` column of the `PETS` table. This retrieval is conditional, specifically targeting the row where the `PETID` column matches the value provided in the input parameter `p_petid`. The retrieved `PET_AGE` value is then immediately stored into the `v_pet_age` variable. Following this data retrieval, the function proceeds with a conditional logic check: it evaluates whether the value stored in `v_pet_age` is less than `2`. If this condition evaluates to `TRUE`, the function immediately returns the string literal `'YOUNG'`. If the condition `v_pet_age < 2` evaluates to `FALSE` (meaning `v_pet_age` is `2` or greater), the function instead returns the string literal `'ADULT'`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_pet_age_category(p_petid IN NUMBER) RETURN VARCHAR2 IS\n    v_pet_age NUMBER;\nBEGIN\n    SELECT PET_AGE INTO v_pet_age FROM PETS WHERE PETID = p_petid;\n    IF v_pet_age < 2 THEN\n        RETURN 'YOUNG';\n    ELSE\n        RETURN 'ADULT';\n    END IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT calculate_pet_age_category(2001) FROM dual",
      "SELECT calculate_pet_age_category(2002) FROM dual",
      "SELECT calculate_pet_age_category(2003) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_pet_age_category that accepts a pet ID (NUMBER). It retrieves the pet's age from the PETS table and returns 'YOUNG' if the age is less than 2, otherwise returns 'ADULT'.",
    "natural_language": "Make a function calculate_pet_age_category that takes a pet ID and returns 'YOUNG' for age under 2, else 'ADULT'.",
    "id": 318
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_pet_types that accepts a single input parameter p_stuid of type NUMBER, which represents the student ID. The function returns a VARCHAR2 value. Within the function, declare a local variable v_pet_types of type VARCHAR2 with a maximum length of 4000 characters. The function executes a SELECT statement that retrieves and concatenates the PETTYPE values from the PETS table, which are associated with the student identified by the input parameter p_stuid. This is achieved by joining three tables: STUDENT, HAS_PET, and PETS. The STUDENT table is joined with the HAS_PET table on the STUID column, and the HAS_PET table is further joined with the PETS table on the PETID column. The WHERE clause filters the results to include only those rows where the STUID column in the STUDENT table matches the input parameter p_stuid. The LISTAGG function is used to aggregate the PETTYPE values into a single comma-separated string, ordered alphabetically by PETTYPE. The result of this aggregation is stored in the v_pet_types variable. Finally, the function returns the concatenated string stored in v_pet_types.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_pet_types(p_stuid IN NUMBER) RETURN VARCHAR2 IS\n    v_pet_types VARCHAR2(4000);\nBEGIN\n    SELECT LISTAGG(p.PETTYPE, ',') WITHIN GROUP (ORDER BY p.PETTYPE) INTO v_pet_types\n    FROM STUDENT s\n    JOIN HAS_PET hp ON s.STUID = hp.STUID\n    JOIN PETS p ON hp.PETID = p.PETID\n    WHERE s.STUID = p_stuid;\n    RETURN v_pet_types;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_student_pet_types(1001) FROM DUAL",
      "SELECT get_student_pet_types(1002) FROM DUAL",
      "SELECT get_student_pet_types(1003) FROM DUAL",
      "SELECT get_student_pet_types(9999) FROM DUAL",
      "SELECT get_student_pet_types(1000) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_student_pet_types that accepts a student ID (NUMBER) and returns a VARCHAR2. It should retrieve and return a comma-separated, alphabetically ordered list of PETTYPE values from the PETS table for the given student by joining the STUDENT, HAS_PET, and PETS tables.",
    "natural_language": "Write function get_student_pet_types(student_id NUMBER) returning VARCHAR2. It fetches sorted, comma-separated PETTYPE values from PETS for that student via STUDENT, HAS_PET, and PETS joins.",
    "id": 319
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_country` that accepts a single input parameter, `p_member_id`, which is of data type `NUMBER`. This function is designed to retrieve the country associated with a specific member from the `MEMBER` table. Inside the function's `BEGIN` block, a local variable `v_country` of data type `VARCHAR2` with a maximum length of 255 characters is declared to temporarily store the retrieved country name. The function then executes a `SELECT` statement to query the `MEMBER` table. This `SELECT` statement retrieves the value from the `COUNTRY` column and stores it into the `v_country` variable. The selection is filtered by a `WHERE` clause, which specifies that only the row where the `MEMBER_ID` column's value matches the input parameter `p_member_id` should be considered. After successfully retrieving the country into `v_country`, the function returns the value stored in `v_country` as its result, which is of data type `VARCHAR2`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_country(p_member_id NUMBER) RETURN VARCHAR2 IS\n    v_country VARCHAR2(255);\nBEGIN\n    SELECT COUNTRY INTO v_country FROM MEMBER WHERE MEMBER_ID = p_member_id;\n    RETURN v_country;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_country(1) FROM dual",
      "SELECT get_member_country(2) FROM dual",
      "SELECT get_member_country(3) FROM dual",
      "SELECT get_member_country(4) FROM dual",
      "SELECT get_member_country(10) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_member_country that accepts a member ID (NUMBER) and returns a VARCHAR2. It should query the MEMBER table to retrieve and return the COUNTRY value for the specified member.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_member_country? It should take a member ID (that's a NUMBER) and spit back a VARCHAR2. Basically, it needs to look up that member in the MEMBER table and grab their COUNTRY for us.",
    "id": 320
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_college_location` that accepts a single input parameter, `p_college_id`, which is of data type `NUMBER` and represents the unique identifier for a college. This function is designed to return a `VARCHAR2` value, specifically the location of the college corresponding to the provided ID. Upon execution, the function declares a local variable `v_location` of type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved college location. The core operation involves a `SELECT` statement that queries the `COLLEGE` table. It retrieves the value from the `COLLEGE_LOCATION` column and stores it into the `v_location` variable. This retrieval is conditional, specifically for the row where the `COLLEGE_ID` column matches the value passed in the `p_college_id` input parameter. After successfully fetching the college location into `v_location`, the function then returns the value stored in `v_location` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_college_location(p_college_id NUMBER) RETURN VARCHAR2 IS\n    v_location VARCHAR2(255);\nBEGIN\n    SELECT COLLEGE_LOCATION INTO v_location FROM COLLEGE WHERE COLLEGE_ID = p_college_id;\n    RETURN v_location;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_college_location(1) FROM DUAL",
      "SELECT get_college_location(2) FROM DUAL",
      "SELECT get_college_location(3) FROM DUAL",
      "SELECT get_college_location(4) FROM DUAL",
      "SELECT get_college_location(100) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_college_location that accepts a college ID (NUMBER) and returns a VARCHAR2. It should query the COLLEGE table to retrieve and return the COLLEGE_LOCATION for the specified college.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_college_location? It should take a college ID (that's a NUMBER) and spit back a VARCHAR2. Basically, it needs to look in the COLLEGE table, grab the COLLEGE_LOCATION for that specific college ID, and return it.",
    "id": 321
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_timezone` that accepts a single input parameter, `p_member_id`, of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing a timezone. Inside the function's executable block, a local variable named `v_timezone` is declared with a `VARCHAR2` data type and a maximum length of 50 characters. The first operation performed is an assignment to this `v_timezone` variable. The value assigned is the result of calling the built-in Oracle SQL function `SESSIONTIMEZONE`. This function retrieves the current session's time zone, which is typically set by the `TIME_ZONE` parameter in the `ALTER SESSION` command or inherited from the database or operating system environment. After this assignment, the function immediately returns the value currently stored in the `v_timezone` variable. The `p_member_id` parameter is declared but is not utilized within the function's logic to retrieve or process any data.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_timezone(p_member_id NUMBER) RETURN VARCHAR2 IS\n    v_timezone VARCHAR2(50);\nBEGIN\n    v_timezone := SESSIONTIMEZONE;\n    RETURN v_timezone;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_timezone(1) FROM DUAL",
      "SELECT get_member_timezone(2) FROM DUAL",
      "SELECT get_member_timezone(10) FROM DUAL",
      "SELECT get_member_timezone(100) FROM DUAL",
      "SELECT get_member_timezone(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_timezone that accepts a member ID (NUMBER) and returns a VARCHAR2. It should return the current session's timezone using SESSIONTIMEZONE. The input parameter is declared but not used within the function logic.",
    "natural_language": "Write a PL/SQL function called get_member_timezone that takes a member ID number and gives back a string. It should basically fetch the kind of timezone setting that's currently active for the session, using that SESSIONTIMEZONE thing. The member ID you pass in is there, but you don't really do anything with it inside the function.",
    "id": 322
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_round_decoration_theme` that accepts a single input parameter, `p_round_id`, which is of data type `NUMBER` and represents the unique identifier for a specific round. The function is designed to return a `VARCHAR2` string, which will contain a comma-separated list of decoration themes associated with the specified round. Internally, the function declares a local variable `v_theme` of type `VARCHAR2` with a maximum length of 4000 characters to temporarily store the aggregated theme string. The core operation involves executing a `SELECT` statement that queries the `ROUND` table. This `SELECT` statement uses the `LISTAGG` aggregate function to concatenate all values from the `DECORATION_THEME` column into a single string. The `LISTAGG` function uses a comma and a space (`, `) as the delimiter between the concatenated values. The `WITHIN GROUP (ORDER BY DECORATION_THEME)` clause ensures that the decoration themes are sorted alphabetically in ascending order before concatenation. The `WHERE` clause filters the rows from the `ROUND` table, specifically selecting only those rows where the `ROUND_ID` column matches the value provided by the input parameter `p_round_id`. The result of this `LISTAGG` operation, which is the comma-separated string of decoration themes, is then stored into the `v_theme` local variable. Finally, the function returns the value stored in `v_theme` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_round_decoration_theme(p_round_id NUMBER) RETURN VARCHAR2 IS\n    v_theme VARCHAR2(4000);\nBEGIN\n    SELECT LISTAGG(DECORATION_THEME, ', ') WITHIN GROUP (ORDER BY DECORATION_THEME) INTO v_theme\n    FROM ROUND\n    WHERE ROUND_ID = p_round_id;\n    \n    RETURN v_theme;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_round_decoration_theme(1) FROM DUAL",
      "SELECT get_round_decoration_theme(2) FROM DUAL",
      "SELECT get_round_decoration_theme(10) FROM DUAL",
      "SELECT get_round_decoration_theme(3) FROM DUAL",
      "SELECT get_round_decoration_theme(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_round_decoration_theme that accepts a round ID (NUMBER) and returns a VARCHAR2. It should query the ROUND table to retrieve and return a comma-separated, alphabetically ordered list of DECORATION_THEME values for the specified round.",
    "natural_language": "Write a PL/SQL function called get_round_decoration_theme that takes a round ID number and gives back a text string. It should look up the round in the database and return a list of its decoration themes, sorted in order and separated by commas.",
    "id": 323
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_college_leader_name that accepts a single input parameter p_college_id of type NUMBER, which represents the unique identifier of a college. The function is designed to return a value of type VARCHAR2, specifically the name of the leader associated with the college identified by the provided p_college_id. Within the function, declare a local variable v_leader_name of type VARCHAR2 with a maximum length of 255 characters to temporarily store the leader's name. Execute a SELECT statement to retrieve the LEADER_NAME from the COLLEGE table where the COLLEGE_ID column matches the value of the input parameter p_college_id. Assign the result of this query to the local variable v_leader_name. Finally, return the value stored in v_leader_name as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_college_leader_name(p_college_id NUMBER) RETURN VARCHAR2 IS\n    v_leader_name VARCHAR2(255);\nBEGIN\n    SELECT LEADER_NAME INTO v_leader_name FROM COLLEGE WHERE COLLEGE_ID = p_college_id;\n    RETURN v_leader_name;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_college_leader_name(1) FROM DUAL",
      "SELECT get_college_leader_name(2) FROM DUAL",
      "SELECT get_college_leader_name(3) FROM DUAL",
      "SELECT get_college_leader_name(COLLEGE_ID) FROM COLLEGE WHERE NAME = 'Saskatchewan School'",
      "SELECT get_college_leader_name(COLLEGE_ID) FROM COLLEGE WHERE COLLEGE_LOCATION = 'Ottawa'"
    ],
    "summary": "Create a PL/SQL function named get_college_leader_name that accepts a college_id number and returns the leader_name from the college table as a varchar2.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_college_leader_name? It should take a college_id (that's a number) and spit back the leader_name from the college table as a varchar2.",
    "id": 324
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_artworks that takes no parameters and returns a single NUMBER data type value. The function declares a local variable v_total of type NUMBER. The function's execution logic performs a single SELECT statement that queries from the DUAL table. This SELECT statement calculates a value by summing two separate scalar subquery results: the first subquery executes a COUNT(*) operation on the entire PAINTINGS table to get the total number of rows in that table, and the second subquery executes a COUNT(*) operation on the entire SCULPTURES table to get the total number of rows in that table. The addition operator (+) is used to sum these two count values. The result of this addition is assigned into the local variable v_total using an INTO clause. The function then concludes by using a RETURN statement to output the value stored in v_total.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_artworks RETURN NUMBER IS\n    v_total NUMBER;\nBEGIN\n    SELECT (SELECT COUNT(*) FROM PAINTINGS) + (SELECT COUNT(*) FROM SCULPTURES) INTO v_total\n    FROM DUAL;\n    RETURN v_total;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_total_artworks FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_artworks with no parameters that returns a number. The function should return the sum of the row counts from the paintings and sculptures tables.",
    "natural_language": "Write a PL/SQL function called get_total_artworks that takes no inputs and gives back a number. It should figure out the total by adding up roughly how many items are in the paintings and sculptures tables.",
    "id": 325
  },
  {
    "ir": "Write an Oracle PL/SQL function that returns a NUMBER representing the earliest birth year from the ARTISTS table by selecting the minimum value from the BIRTHYEAR column. The function, named get_oldest_artist_birthyear, does not take any input parameters. It declares a local variable v_birthyear of type NUMBER to store the result of the query. Within the function body, a SELECT statement is executed to retrieve the smallest value from the BIRTHYEAR column of the ARTISTS table, and this value is assigned to the v_birthyear variable. The function then returns the value stored in v_birthyear, which represents the birth year of the oldest artist in the ARTISTS table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_artist_birthyear RETURN NUMBER IS\n    v_birthyear NUMBER;\nBEGIN\n    SELECT MIN(BIRTHYEAR) INTO v_birthyear FROM ARTISTS;\n    RETURN v_birthyear;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_oldest_artist_birthyear FROM DUAL",
      "SELECT get_oldest_artist_birthyear() FROM DUAL",
      "DECLARE\n  v_year NUMBER;\nBEGIN\n  v_year := get_oldest_artist_birthyear;\n  DBMS_OUTPUT.PUT_LINE('Oldest birth year: ' || v_year);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE(get_oldest_artist_birthyear);\nEND;",
      "SELECT ARTISTID, LNAME, FNAME FROM ARTISTS WHERE BIRTHYEAR = get_oldest_artist_birthyear"
    ],
    "summary": "Create a PL/SQL function named get_oldest_artist_birthyear with no parameters that returns a number. The function should return the minimum birthyear from the artists table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_oldest_artist_birthyear? It doesn't need any inputs and should spit out a number. Basically, it's gotta find the earliest birth year from the artists table and give that back.",
    "id": 326
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_painting_area` that returns a single `NUMBER` value. This function declares a local variable `v_total_area` of type `NUMBER`. The core operation of the function is to execute a `SELECT` statement. This `SELECT` statement calculates the sum of the product of the `HEIGHT_MM` column and the `WIDTH_MM` column from all rows in the `PAINTINGS` table. The result of this summation is then stored into the local variable `v_total_area`. Finally, the function returns the value currently held by `v_total_area`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_painting_area RETURN NUMBER IS\n    v_total_area NUMBER;\nBEGIN\n    SELECT SUM(HEIGHT_MM * WIDTH_MM) INTO v_total_area FROM PAINTINGS;\n    RETURN v_total_area;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_total_painting_area FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_painting_area with no parameters that returns a number. The function should return the sum of (height_mm * width_mm) for all rows in the paintings table.",
    "natural_language": "Write a PL/SQL function called get_total_painting_area that takes no inputs and gives back a number. It should figure out the total area by adding up the height times the width for the stuff in the paintings table.",
    "id": 327
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_artist_count` that is designed to return a single numeric value. This function does not accept any input parameters. Internally, it declares a local variable named `v_count` of type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement to retrieve the total number of rows from the `ARTISTS` table. Specifically, it uses the `COUNT(*)` aggregate function to count all rows in the `ARTISTS` table, without any filtering conditions. The result of this `COUNT(*)` operation is then immediately assigned to the local variable `v_count`. Finally, the function returns the value stored in `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_count RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM ARTISTS;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_count FROM DUAL",
      "SELECT get_artist_count() FROM DUAL",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_artist_count;\n  DBMS_OUTPUT.PUT_LINE('Artist count: ' || v_count);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total artists: ' || get_artist_count);\nEND;",
      "SELECT 'Number of artists: ' || get_artist_count AS result FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_artist_count with no parameters that returns a number. The function should return the total count of all rows in the artists table.",
    "natural_language": "Write a PL/SQL function called get_artist_count that takes no inputs and gives back a number. It should figure out and return roughly how many entries are in the artists table overall.",
    "id": 328
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_sculpture_count that returns a numeric value representing the total number of records in the SCULPTURES table. The function does not take any input parameters. Within the function body, a local variable v_count of type NUMBER is declared to store the result of a query operation. The function executes a SELECT statement that counts all rows in the SCULPTURES table using the COUNT(*) aggregate function, and the result of this count is stored into the v_count variable. Finally, the function returns the value of v_count, which represents the total number of sculptures recorded in the SCULPTURES table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_sculpture_count RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM SCULPTURES;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_sculpture_count FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_sculpture_count that returns the total number of records in the SCULPTURES table.",
    "natural_language": "Write a PL/SQL function called get_sculpture_count that gives back a rough idea of how many items are in the SCULPTURES table.",
    "id": 329
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes two input parameters, para_company_id of type NUMBER and para_rank of type NUMBER, and returns a value of type NUMBER. The function is named get_company_asset_ratio and is designed to calculate and return the ratio of the ASSETS_BILLION column to the SALES_BILLION column from the COMPANY table for a specific company identified by the para_company_id parameter and a specific rank identified by the para_rank parameter. Inside the function, a local variable v_ratio of type NUMBER is declared to store the calculated ratio. The function performs a SELECT statement to retrieve the ASSETS_BILLION and SALES_BILLION values from the COMPANY table, where the COMPANY_ID column matches the value of para_company_id and the RANK column matches the value of para_rank. The retrieved values are used to compute the ratio by dividing ASSETS_BILLION by SALES_BILLION, and the result is rounded to three decimal places using the ROUND function. The computed ratio is then assigned to the v_ratio variable. Finally, the function returns the value stored in v_ratio as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_company_asset_ratio(para_company_id NUMBER, para_rank NUMBER) RETURN NUMBER IS\n  v_ratio NUMBER;\nBEGIN\n  SELECT ROUND(ASSETS_BILLION / SALES_BILLION, 3) INTO v_ratio FROM COMPANY WHERE COMPANY_ID = para_company_id AND RANK = para_rank;\n  RETURN v_ratio;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT get_company_asset_ratio(1, 1) FROM DUAL",
      "SELECT get_company_asset_ratio(2, 3) FROM DUAL",
      "SELECT get_company_asset_ratio(3, 4) FROM DUAL",
      "SELECT get_company_asset_ratio(1, 3) FROM DUAL",
      "SELECT get_company_asset_ratio(2, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_company_asset_ratio that accepts a company_id and a rank as NUMBER parameters. It returns the ratio of ASSETS_BILLION to SALES_BILLION from the COMPANY table for the matching row, rounded to three decimal places.",
    "natural_language": "Write a PL/SQL function called get_company_asset_ratio that takes a company_id and a rank as NUMBER inputs. Return the ASSETS_BILLION to SALES_BILLION ratio, rounded to three decimal places, for the corresponding company in the COMPANY table.",
    "id": 330
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes two input parameters, para_station_id of type NUMBER and para_open_year of type NUMBER, and returns a value of type NUMBER. The function calculates the total length of two specific string columns, MANAGER_NAME and VICE_MANAGER_NAME, from the GAS_STATION table, for a row where the STATION_ID column matches the value of para_station_id and the OPEN_YEAR column matches the value of para_open_year. Inside the function, a local variable v_total_length of type NUMBER is declared to store the result of the calculation. The function performs a SELECT statement to retrieve the lengths of the MANAGER_NAME and VICE_MANAGER_NAME columns using the LENGTH() function, which computes the number of characters in each string. These lengths are added together, and the result is stored in the v_total_length variable. The SELECT statement includes a WHERE clause to filter rows based on the conditions that the STATION_ID column equals para_station_id and the OPEN_YEAR column equals para_open_year. If a matching row is found, the calculated total length is returned as the output of the function. If no matching row exists, the function will raise a NO_DATA_FOUND exception implicitly due to the SELECT INTO statement.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_station_name_length(para_station_id NUMBER, para_open_year NUMBER) RETURN NUMBER IS\n  v_total_length NUMBER;\nBEGIN\n  SELECT LENGTH(MANAGER_NAME) + LENGTH(VICE_MANAGER_NAME) INTO v_total_length FROM GAS_STATION WHERE STATION_ID = para_station_id AND OPEN_YEAR = para_open_year;\n  RETURN v_total_length;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT calculate_station_name_length(1, 1998) FROM DUAL",
      "SELECT calculate_station_name_length(2, 1999) FROM DUAL",
      "SELECT calculate_station_name_length(3, 2000) FROM DUAL",
      "SELECT STATION_ID, OPEN_YEAR, calculate_station_name_length(STATION_ID, OPEN_YEAR) AS NAME_LENGTH FROM GAS_STATION WHERE STATION_ID = 1",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Length: ' || calculate_station_name_length(1, 1998));\nEND;"
    ],
    "summary": "Create a PL/SQL function that accepts a station_id and an open_year as NUMBER parameters. It returns the total character length of the MANAGER_NAME and VICE_MANAGER_NAME columns from the GAS_STATION table for the matching row.",
    "natural_language": "Please construct a PL/SQL function that receives two parameters of type NUMBER, specifically a station identifier and an opening year. The function shall return the aggregate character length derived from the MANAGER_NAME and VICE_MANAGER_NAME columns within the GAS_STATION table for the corresponding record.",
    "id": 331
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_company_profit_margin` that accepts two input parameters: `para_company_id` of data type `NUMBER`, which represents the unique identifier for a company, and `para_rank` of data type `NUMBER`, which represents a specific ranking associated with a company. This function is designed to return a single value of data type `NUMBER`, representing the calculated profit margin. The function's execution begins by declaring a local variable named `v_margin` of data type `NUMBER` to temporarily store the calculated profit margin. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `COMPANY` table. Specifically, it calculates a profit margin by dividing the value from the `PROFITS_BILLION` column by the value from the `SALES_BILLION` column, then multiplies the result by 100 to express it as a percentage. This calculated percentage is then rounded to two decimal places using the `ROUND` function. The result of this calculation is then assigned to the local variable `v_margin`. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `COMPANY` table based on two conditions: `COMPANY_ID` must be equal to the value provided in the `para_company_id` input parameter, and `RANK` must be equal to the value provided in the `para_rank` input parameter. After the `SELECT` statement has executed and the `v_margin` variable has been populated, the function concludes by returning the value stored in `v_margin`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_company_profit_margin(para_company_id NUMBER, para_rank NUMBER) RETURN NUMBER IS\n  v_margin NUMBER;\nBEGIN\n  SELECT ROUND((PROFITS_BILLION / SALES_BILLION) * 100, 2) INTO v_margin FROM COMPANY WHERE COMPANY_ID = para_company_id AND RANK = para_rank;\n  RETURN v_margin;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT get_company_profit_margin(1, 1) FROM DUAL",
      "SELECT get_company_profit_margin(2, 3) FROM DUAL",
      "SELECT get_company_profit_margin(3, 4) FROM DUAL",
      "SELECT COMPANY_ID, RANK, get_company_profit_margin(COMPANY_ID, RANK) AS PROFIT_MARGIN FROM COMPANY WHERE COMPANY_ID = 1",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Profit Margin: ' || get_company_profit_margin(1, 1));\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_company_profit_margin that accepts a company_id and a rank as NUMBER parameters. It returns the profit margin percentage (PROFITS_BILLION / SALES_BILLION * 100) from the COMPANY table for the matching row, rounded to two decimal places.",
    "natural_language": "Write a PL/SQL function called get_company_profit_margin that takes a company_id and a rank, both as numbers. It should fetch the profit margin from the COMPANY table for that company, calculated as profits over sales times one hundred, and give back the result rounded to a couple of decimal places.",
    "id": 332
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_station_company_match` that accepts two input parameters: `para_station_id` of data type `NUMBER` and `para_company_id` of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable `v_match_count` of data type `NUMBER`. The core operation of the function involves performing a `SELECT` statement to count the number of rows in the `STATION_COMPANY` table. The `COUNT(*)` aggregate function is used to count all rows that satisfy the specified conditions. The conditions for row selection are that the `STATION_ID` column in the `STATION_COMPANY` table must be equal to the value passed in the `para_station_id` input parameter, AND the `COMPANY_ID` column in the `STATION_COMPANY` table must be equal to the value passed in the `para_company_id` input parameter. The result of this count operation is then stored into the local variable `v_match_count`. Finally, the function returns the value stored in `v_match_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION check_station_company_match(para_station_id NUMBER, para_company_id NUMBER) RETURN NUMBER IS\n  v_match_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_match_count FROM STATION_COMPANY WHERE STATION_ID = para_station_id AND COMPANY_ID = para_company_id;\n  RETURN v_match_count;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT check_station_company_match(11, 1) FROM DUAL",
      "SELECT check_station_company_match(1, 3) FROM DUAL",
      "SELECT check_station_company_match(6, 6) FROM DUAL",
      "SELECT check_station_company_match(2, 1) FROM DUAL",
      "SELECT check_station_company_match(3, 2) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_station_company_match that accepts a station_id and a company_id as NUMBER parameters. It returns the count of rows in the STATION_COMPANY table where both the STATION_ID and COMPANY_ID match the input parameters.",
    "natural_language": "Develop a PL/SQL function, which should be named check_station_company_match, that meticulously receives two distinct NUMBER parameters: a specific station_id and a corresponding company_id. This function is designed to carefully compute and subsequently return the precise total count of existing records located within the STATION_COMPANY table, but only for those rows where the provided station_id perfectly aligns with the table's STATION_ID column and, simultaneously, where the supplied company_id exactly matches the table's COMPANY_ID column.",
    "id": 333
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_company_market_to_sales` that accepts two input parameters: `para_company_id` of data type `NUMBER` which represents a unique identifier for a company, and `para_rank` of data type `NUMBER` which represents a specific ranking associated with a company. This function is designed to return a single value of data type `NUMBER`. The function's execution begins by declaring a local variable named `v_ratio` of data type `NUMBER` to temporarily store the calculated market-to-sales ratio. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `COMPANY` table. Specifically, it calculates a ratio by dividing the value from the `MARKET_VALUE` column by the value from the `SALES_BILLION` column. This calculated ratio is then rounded to three decimal places using the `ROUND` function. The result of this calculation is then assigned to the local variable `v_ratio`. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `COMPANY` table, ensuring that only the row where the `COMPANY_ID` column matches the value provided in the `para_company_id` input parameter AND the `RANK` column matches the value provided in the `para_rank` input parameter is considered for the calculation. After the `SELECT` statement successfully executes and `v_ratio` is populated, the function concludes by returning the value stored in the `v_ratio` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_company_market_to_sales(para_company_id NUMBER, para_rank NUMBER) RETURN NUMBER IS\n  v_ratio NUMBER;\nBEGIN\n  SELECT ROUND(MARKET_VALUE / SALES_BILLION, 3) INTO v_ratio FROM COMPANY WHERE COMPANY_ID = para_company_id AND RANK = para_rank;\n  RETURN v_ratio;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT get_company_market_to_sales(1, 1) FROM DUAL",
      "SELECT get_company_market_to_sales(2, 3) FROM DUAL",
      "SELECT get_company_market_to_sales(3, 4) FROM DUAL",
      "SELECT get_company_market_to_sales(1, 3) FROM DUAL",
      "SELECT get_company_market_to_sales(2, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_company_market_to_sales` that returns a NUMBER. It accepts a company ID and a rank as input parameters. The function calculates and returns the market-to-sales ratio (MARKET_VALUE / SALES_BILLION) rounded to three decimal places from the COMPANY table, filtered by the matching COMPANY_ID and RANK.",
    "natural_language": "Write a PL/SQL function that gives back a NUMBER. It should take a company identifier and a rank number. The function needs to figure out a kind of market-to-sales figure (using MARKET_VALUE divided by SALES_BILLION) for a company from the COMPANY data, making sure it's for the right company and its general standing. The final number should be trimmed to roughly three decimal places.",
    "id": 334
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_COMPLAINT_COUNT that accepts a single input parameter P_CUSTOMER_ID of type NUMBER and returns a value of type NUMBER. The function begins by declaring a local variable V_COUNT of type NUMBER. It executes a SELECT statement that queries the COMPLAINTS table, using the COUNT(*) aggregate function to calculate the total number of rows. The SELECT statement includes a WHERE clause with the condition CUSTOMER_ID = P_CUSTOMER_ID, which filters the count to only include rows where the CUSTOMER_ID column matches the provided input parameter P_CUSTOMER_ID. The result of this count operation is stored into the local variable V_COUNT. Following the query, the function uses an IF-THEN-ELSE conditional statement to evaluate the value of V_COUNT. If V_COUNT is greater than 0, the function returns the value of V_COUNT. If V_COUNT is not greater than 0, meaning it is equal to 0, the function explicitly returns the value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_CUSTOMER_COMPLAINT_COUNT (P_CUSTOMER_ID IN NUMBER) RETURN NUMBER IS\n  V_COUNT NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO V_COUNT\n  FROM COMPLAINTS\n  WHERE CUSTOMER_ID = P_CUSTOMER_ID;\n\n  IF V_COUNT > 0 THEN\n    RETURN V_COUNT;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_CUSTOMER_COMPLAINT_COUNT(113) FROM DUAL",
      "SELECT GET_CUSTOMER_COMPLAINT_COUNT(114) FROM DUAL",
      "SELECT GET_CUSTOMER_COMPLAINT_COUNT(115) FROM DUAL",
      "SELECT GET_CUSTOMER_COMPLAINT_COUNT(120) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `GET_CUSTOMER_COMPLAINT_COUNT` that returns a NUMBER. It accepts a customer ID as input. The function counts and returns the number of complaints for that customer from the COMPLAINTS table. If the count is zero, return 0.",
    "natural_language": "Please construct a PL/SQL function designated as `GET_CUSTOMER_COMPLAINT_COUNT` that yields a value of the NUMBER data type. This function shall accept a customer identifier as its input parameter. Its operational logic is to query the COMPLAINTS table in order to calculate and return the aggregate number of complaints associated with the provided customer. In the event that no complaints are found, the function must return the value zero.",
    "id": 335
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_PRODUCT_AVAILABILITY that accepts a single input parameter P_PRODUCT_ID of type NUMBER and returns a VARCHAR2 value. The function begins by declaring a local variable V_STATUS of type VARCHAR2 with a maximum length of 255 characters. It then executes a SELECT statement that queries the PRODUCTS table, specifically targeting the row where the PRODUCT_ID column matches the provided input parameter P_PRODUCT_ID. Within this query, a CASE expression is evaluated: it compares the current system date and time (obtained via the SYSDATE function) against two date columns from the selected row, DATE_PRODUCT_FIRST_AVAILABLE and DATE_PRODUCT_DISCONTINUED. The function converts the string values in these columns to proper DATE data types using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS'. If SYSDATE falls between these two converted dates (inclusive), the CASE expression yields the string 'Available'; otherwise, it yields 'Discontinued'. The result of this CASE expression is assigned into the local variable V_STATUS. After the SELECT operation, the function checks if V_STATUS is not NULL. If this condition is true, the function returns the value stored in V_STATUS. If V_STATUS is NULL, which would occur if no row was found for the given P_PRODUCT_ID, the function returns the string 'Unknown'.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PRODUCT_AVAILABILITY (P_PRODUCT_ID IN NUMBER) RETURN VARCHAR2 IS\n  V_STATUS VARCHAR2(255);\nBEGIN\n  SELECT CASE \n           WHEN SYSDATE BETWEEN TO_DATE(DATE_PRODUCT_FIRST_AVAILABLE, 'YYYY-MM-DD HH24:MI:SS') \n                          AND TO_DATE(DATE_PRODUCT_DISCONTINUED, 'YYYY-MM-DD HH24:MI:SS') THEN 'Available'\n           ELSE 'Discontinued'\n         END\n  INTO V_STATUS\n  FROM PRODUCTS\n  WHERE PRODUCT_ID = P_PRODUCT_ID;\n\n  IF V_STATUS IS NOT NULL THEN\n    RETURN V_STATUS;\n  ELSE\n    RETURN 'Unknown';\n  END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_PRODUCT_AVAILABILITY(117) FROM DUAL",
      "SELECT GET_PRODUCT_AVAILABILITY(118) FROM DUAL",
      "SELECT GET_PRODUCT_AVAILABILITY(119) FROM DUAL",
      "SELECT GET_PRODUCT_AVAILABILITY(1) FROM DUAL",
      "SELECT GET_PRODUCT_AVAILABILITY(999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `GET_PRODUCT_AVAILABILITY` that returns a VARCHAR2. It accepts a product ID as input. The function determines if a product is 'Available' or 'Discontinued' by checking if the current date (SYSDATE) is between its DATE_PRODUCT_FIRST_AVAILABLE and DATE_PRODUCT_DISCONTINUED dates. If no product is found, return 'Unknown'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `GET_PRODUCT_AVAILABILITY` that spits back a VARCHAR2? It'll take a product ID as its input. Basically, the function needs to figure out if a product is 'Available' or 'Discontinued'. It does this by checking if today's date (just use SYSDATE) falls between the product's start date (DATE_PRODUCT_FIRST_AVAILABLE) and its end date (DATE_PRODUCT_DISCONTINUED). If it can't find the product at all, just have it return 'Unknown'.",
    "id": 336
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_EMAIL that takes a single input parameter, P_CUSTOMER_ID, of type NUMBER, representing the unique identifier of a customer, and returns a value of type VARCHAR2. The function begins by declaring a local variable, V_EMAIL, of type VARCHAR2 with a maximum length of 255 characters, which will be used to store the email address retrieved from the database. Within the function body, a SELECT statement is executed to query the CUSTOMERS table, specifically retrieving the value from the EMAIL_ADDRESS column for the row where the CUSTOMER_ID column matches the value provided in the P_CUSTOMER_ID parameter. The result of this query is assigned to the V_EMAIL variable using the INTO clause. After the SELECT operation, a conditional statement checks whether the value stored in V_EMAIL is not NULL. If V_EMAIL contains a non-NULL value, the function returns the value of V_EMAIL, which represents the email address of the customer. If V_EMAIL is NULL, indicating that no email address was found for the specified customer ID, the function returns the string 'No Email Found'.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_CUSTOMER_EMAIL (P_CUSTOMER_ID IN NUMBER) RETURN VARCHAR2 IS\n  V_EMAIL VARCHAR2(255);\nBEGIN\n  SELECT EMAIL_ADDRESS\n  INTO V_EMAIL\n  FROM CUSTOMERS\n  WHERE CUSTOMER_ID = P_CUSTOMER_ID;\n\n  IF V_EMAIL IS NOT NULL THEN\n    RETURN V_EMAIL;\n  ELSE\n    RETURN 'No Email Found';\n  END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_CUSTOMER_EMAIL(113) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(114) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(115) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(120) FROM DUAL",
      "SELECT CUSTOMER_ID, GET_CUSTOMER_EMAIL(CUSTOMER_ID) AS EMAIL FROM COMPLAINTS WHERE COMPLAINT_ID = 1"
    ],
    "summary": "Create a PL/SQL function named `GET_CUSTOMER_EMAIL` that returns a VARCHAR2. It accepts a customer ID as input. The function retrieves and returns the customer's email address from the CUSTOMERS table. If no email is found, return 'No Email Found'.",
    "natural_language": "Please construct a PL/SQL function, designated as `GET_CUSTOMER_EMAIL`, which shall yield a value of the VARCHAR2 datatype. This function must be designed to accept a customer identifier as its input parameter. Its operational logic is to query the CUSTOMERS table to retrieve the associated email address for the specified customer. In the event that no corresponding email record is located, the function is to return the string 'No Email Found'.",
    "id": 337
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_PRODUCT_PRICE that accepts a single input parameter P_PRODUCT_ID of the NUMBER data type and returns a value of the NUMBER data type, which begins by declaring a local variable V_PRICE of the NUMBER data type, then executes a SELECT statement to query the PRODUCT_PRICE column from the PRODUCTS table, specifically retrieving the value from the row where the PRODUCT_ID column exactly matches the provided input parameter P_PRODUCT_ID, and stores the retrieved value into the local variable V_PRICE, after which it evaluates a conditional IF statement to check if the value in V_PRICE is not NULL, and if this condition is true, the function returns the value stored in V_PRICE, but if the condition is false, meaning V_PRICE is NULL, the function instead returns the numeric value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PRODUCT_PRICE (P_PRODUCT_ID IN NUMBER) RETURN NUMBER IS\n  V_PRICE NUMBER;\nBEGIN\n  SELECT PRODUCT_PRICE\n  INTO V_PRICE\n  FROM PRODUCTS\n  WHERE PRODUCT_ID = P_PRODUCT_ID;\n\n  IF V_PRICE IS NOT NULL THEN\n    RETURN V_PRICE;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_PRODUCT_PRICE(117) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE(118) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE(119) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE(120) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE(121) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `GET_PRODUCT_PRICE` that returns a NUMBER. It accepts a product ID as input. The function retrieves and returns the product's price from the PRODUCTS table. If no price is found, return 0.",
    "natural_language": "How can I create a PL/SQL function named `GET_PRODUCT_PRICE` that returns a NUMBER, accepts a product ID as input, retrieves the product's price from the PRODUCTS table, and returns 0 if no price is found?",
    "id": 338
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_customer_debt_total` that takes a single input parameter `p_cross_ref_id` of type `NUMBER`, representing a unique identifier for a customer, and returns a `NUMBER` value representing the total debt associated with the customer. The function begins by initializing a local variable `v_total` to 0, which will accumulate the total debt. It also declares four additional local variables: `v_benefits`, `v_rent`, `v_parking`, and `v_tax`, all of type `NUMBER`, to store intermediate sums of debts from different categories. The function performs four separate `SELECT` statements to retrieve the sum of the `COUNCIL_TAX_ID` column from four different tables (`BENEFITS_OVERPAYMENTS`, `RENT_ARREARS`, `PARKING_FINES`, and `COUNCIL_TAX`) where the `CMI_CROSS_REF_ID` column matches the input parameter `p_cross_ref_id`. Each `SELECT` statement uses the `COALESCE` function to ensure that a `NULL` result is replaced with 0, and the retrieved values are stored in the respective local variables (`v_benefits`, `v_rent`, `v_parking`, and `v_tax`). After retrieving the values, the function applies conditional logic to adjust the value of `v_benefits` based on its magnitude: if `v_benefits` is greater than 100, it is multiplied by 1.1 and added to `v_total`; if `v_benefits` is greater than 50 but less than or equal to 100, it is multiplied by 1.05 and added to `v_total`; otherwise, the unmodified value of `v_benefits` is added to `v_total`. Finally, the function adds the values of `v_rent`, `v_parking`, and `v_tax directly to `v_total`. The function concludes by returning the computed value of `v_total`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_customer_debt_total(p_cross_ref_id NUMBER) RETURN NUMBER IS\n  v_total NUMBER := 0;\n  v_benefits NUMBER;\n  v_rent NUMBER;\n  v_parking NUMBER;\n  v_tax NUMBER;\nBEGIN\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_benefits FROM BENEFITS_OVERPAYMENTS WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_rent FROM RENT_ARREARS WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_parking FROM PARKING_FINES WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_tax FROM COUNCIL_TAX WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  IF v_benefits > 100 THEN\n    v_total := v_total + v_benefits * 1.1;\n  ELSIF v_benefits > 50 THEN\n    v_total := v_total + v_benefits * 1.05;\n  ELSE\n    v_total := v_total + v_benefits;\n  END IF;\n  v_total := v_total + v_rent + v_parking + v_tax;\n  RETURN v_total;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "SELECT calculate_customer_debt_total(65) FROM DUAL",
      "SELECT calculate_customer_debt_total(41) FROM DUAL",
      "SELECT calculate_customer_debt_total(83) FROM DUAL",
      "SELECT calculate_customer_debt_total(4) FROM DUAL",
      "SELECT calculate_customer_debt_total(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_customer_debt_total that accepts a customer ID number and returns the total debt. Sum the COUNCIL_TAX_ID from the BENEFITS_OVERPAYMENTS, RENT_ARREARS, PARKING_FINES, and COUNCIL_TAX tables where CMI_CROSS_REF_ID matches the input. Apply a multiplier to the benefits sum based on its value (1.1 if >100, 1.05 if >50 and <=100, else 1). Return the total.",
    "natural_language": "Hey, I need you to write a PL/SQL function called calculate_customer_debt_total. It should take a customer's ID number and spit out their total debt. Here's how to figure it out: add up the COUNCIL_TAX_ID from a bunch of tables—BENEFITS_OVERPAYMENTS, RENT_ARREARS, PARKING_FINES, and COUNCIL_TAX—but only for entries where the CMI_CROSS_REF_ID matches the ID you're given. Oh, and for the benefits part, you gotta tweak it: if that sum is over 100, multiply it by 1.1; if it's more than 50 but not over 100, use 1.05; otherwise, just leave it as is. Then just add everything together and hand back the total.",
    "id": 339
  },
  {
    "ir": "Write an Oracle PL/SQL function named `CALC_COMPANY_SERIES_BUDGET` that accepts a single input parameter `COMP_ID` of data type `NUMBER`, representing a company identifier, and returns a `VARCHAR2` value of length 255. The function declares three local variables: `TOTAL_BUDGET` of type `VARCHAR2(255)` to store the sum of budgets, `SERIES_COUNT` of type `NUMBER` to store the count of TV series, and `AVG_BUDGET` of type `VARCHAR2(255)` to store the calculated average budget or a descriptive string.\n\nThe function begins by executing a `SELECT` statement to retrieve data from the `MADE_BY` table, aliased as `MB`, and the `TV_SERIES` table, aliased as `TS`. These two tables are joined using an `INNER JOIN` condition where `MB.MSID` is equal to `TS.SID`. The `WHERE` clause filters the results to include only records where the `PID` column in the `MADE_BY` table matches the input parameter `COMP_ID`. The `SELECT` statement calculates two aggregate values: `COUNT(*)`, which counts the total number of rows matching the criteria, and `SUM(TO_NUMBER(REPLACE(BUDGET, '$', '')))`, which first removes all occurrences of the '$' character from the `BUDGET` column (presumably a `VARCHAR2` column containing monetary values) using the `REPLACE` function, then converts the resulting string to a `NUMBER` using `TO_NUMBER`, and finally sums these numerical budget values. These two calculated values are then assigned to the local variables `SERIES_COUNT` and `TOTAL_BUDGET`, respectively, using the `INTO` clause.\n\nFollowing the data retrieval, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) to determine the value to be assigned to `AVG_BUDGET`.\n1. The first condition checks if `SERIES_COUNT` is equal to `0`. If true, `AVG_BUDGET` is assigned the string literal `'0'`.\n2. If the first condition is false, the `ELSIF` condition checks if `SERIES_COUNT` is greater than `5`. If true, `AVG_BUDGET` is assigned the result of a calculation: `TO_NUMBER(TOTAL_BUDGET)` converts the `TOTAL_BUDGET` (which was stored as `VARCHAR2`) back to a `NUMBER`, this numerical value is then divided by `SERIES_COUNT`, and the final numerical result is converted back to a `VARCHAR2` using `TO_CHAR` before being assigned.\n3. If both previous conditions are false, the next `ELSIF` condition checks if `TO_NUMBER(TOTAL_BUDGET)` (converting `TOTAL_BUDGET` to a `NUMBER`) is greater than `1000000`. If true, `AVG_BUDGET` is assigned the string literal `'HIGH'`.\n4. If none of the above conditions are met, the `ELSE` block is executed, and `AVG_BUDGET` is assigned the string literal `'LOW'`.\n\nFinally, the function returns the value stored in the `AVG_BUDGET` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION CALC_COMPANY_SERIES_BUDGET(COMP_ID IN NUMBER) RETURN VARCHAR2 IS\n  TOTAL_BUDGET VARCHAR2(255);\n  SERIES_COUNT NUMBER;\n  AVG_BUDGET VARCHAR2(255);\nBEGIN\n  SELECT COUNT(*), SUM(TO_NUMBER(REPLACE(BUDGET, '$', '')))\n  INTO SERIES_COUNT, TOTAL_BUDGET\n  FROM MADE_BY MB\n  JOIN TV_SERIES TS ON MB.MSID = TS.SID\n  WHERE MB.PID = COMP_ID;\n  IF SERIES_COUNT = 0 THEN\n    AVG_BUDGET := '0';\n  ELSIF SERIES_COUNT > 5 THEN\n    AVG_BUDGET := TO_CHAR(TO_NUMBER(TOTAL_BUDGET) / SERIES_COUNT);\n  ELSIF TO_NUMBER(TOTAL_BUDGET) > 1000000 THEN\n    AVG_BUDGET := 'HIGH';\n  ELSE\n    AVG_BUDGET := 'LOW';\n  END IF;\n  RETURN AVG_BUDGET;\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "MADE_BY",
      "COMPANY"
    ],
    "call_sqls": [
      "SELECT CALC_COMPANY_SERIES_BUDGET(1) FROM DUAL",
      "SELECT CALC_COMPANY_SERIES_BUDGET(2) FROM DUAL",
      "SELECT CALC_COMPANY_SERIES_BUDGET(3) FROM DUAL",
      "SELECT CALC_COMPANY_SERIES_BUDGET(4) FROM DUAL",
      "SELECT CALC_COMPANY_SERIES_BUDGET(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named CALC_COMPANY_SERIES_BUDGET that accepts a company ID number and returns a VARCHAR2. Calculate the count of TV series and the total budget (converted from a '$' prefixed string) for the company via a join between MADE_BY and TV_SERIES. Determine the return value: '0' if count is 0; the calculated average budget as a string if count >5; 'HIGH' if total budget > 1,000,000; otherwise 'LOW'.",
    "natural_language": "Write a PL/SQL function called CALC_COMPANY_SERIES_BUDGET that takes a company ID number and gives back a VARCHAR2. For the given company, join the MADE_BY and TV_SERIES tables to get the number of TV series and the total budget, converting the budget from a string with a '$' prefix. Then, return '0' if the series count is zero; if the count is greater than 5, return the calculated average budget as a string; if the total budget exceeds 1,000,000, return 'HIGH'; otherwise, return 'LOW'.",
    "id": 340
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_SERIES_STATUS that takes a single input parameter SERIES_ID of type NUMBER and returns a value of type VARCHAR2. The purpose of this function is to determine the status of a TV series based on the number of seasons and episodes it has, using data stored in the TV_SERIES table. The function begins by declaring three local variables: SEASON_COUNT and EPISODE_COUNT of type NUMBER, which will store the number of seasons and episodes for the specified series, and STATUS of type VARCHAR2(20), which will hold the resulting status to be returned. The function then executes a SELECT statement to retrieve the values of the NUM_OF_SEASONS and NUM_OF_EPISODES columns from the TV_SERIES table for the row where the SID column matches the input parameter SERIES_ID. These values are stored in the SEASON_COUNT and EPISODE_COUNT variables, respectively. Next, the function evaluates a series of conditional statements to determine the status of the series based on the retrieved values. If SEASON_COUNT is greater than 10, the STATUS variable is set to 'LONG_RUNNING'. If the first condition is not met but EPISODE_COUNT is greater than 100, the STATUS variable is set to 'EPISODIC'. If neither of the previous conditions is met but SEASON_COUNT equals 1 and EPISODE_COUNT is less than 10, the STATUS variable is set to 'MINISERIES'. If none of these conditions are satisfied, the STATUS variable is set to 'STANDARD'. Finally, the function returns the value of the STATUS variable, which represents the determined status of the TV series.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_SERIES_STATUS(SERIES_ID IN NUMBER) RETURN VARCHAR2 IS\n  SEASON_COUNT NUMBER;\n  EPISODE_COUNT NUMBER;\n  STATUS VARCHAR2(20);\nBEGIN\n  SELECT NUM_OF_SEASONS, NUM_OF_EPISODES\n  INTO SEASON_COUNT, EPISODE_COUNT\n  FROM TV_SERIES\n  WHERE SID = SERIES_ID;\n  IF SEASON_COUNT > 10 THEN\n    STATUS := 'LONG_RUNNING';\n  ELSIF EPISODE_COUNT > 100 THEN\n    STATUS := 'EPISODIC';\n  ELSIF SEASON_COUNT = 1 AND EPISODE_COUNT < 10 THEN\n    STATUS := 'MINISERIES';\n  ELSE\n    STATUS := 'STANDARD';\n  END IF;\n  RETURN STATUS;\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "MADE_BY",
      "COMPANY"
    ],
    "call_sqls": [
      "SELECT GET_SERIES_STATUS(101) FROM DUAL",
      "SELECT GET_SERIES_STATUS(205) FROM DUAL",
      "SELECT GET_SERIES_STATUS(312) FROM DUAL",
      "SELECT GET_SERIES_STATUS(418) FROM DUAL",
      "SELECT GET_SERIES_STATUS(529) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_SERIES_STATUS that accepts a series ID number and returns a VARCHAR2 status. Retrieve the series' season and episode count from the TV_SERIES table. Return 'LONG_RUNNING' if seasons >10, 'EPISODIC' if episodes >100, 'MINISERIES' if seasons=1 and episodes<10, else 'STANDARD'.",
    "natural_language": "Develop a comprehensive PL/SQL function called GET_SERIES_STATUS, which is designed to meticulously accept a specific series ID number as its input parameter and subsequently provide a detailed VARCHAR2 status as its output. This function should first carefully retrieve the precise count of both seasons and episodes for the given series from the TV_SERIES table. Based on this retrieved data, it must then thoughtfully determine and return the appropriate status label: it should return 'LONG_RUNNING' if the total number of seasons is definitively greater than ten, 'EPISODIC' if the cumulative episode count substantially exceeds one hundred, 'MINISERIES' if the series consists of exactly one season and also has fewer than ten episodes, and in all other remaining cases, it should reliably return the default status of 'STANDARD'.",
    "id": 341
  },
  {
    "ir": "Write an Oracle PL/SQL function named CHECK_DIRECTOR_WORKLOAD that accepts a single input parameter DIR_ID of type NUMBER, representing a director's identifier, and returns a VARCHAR2 string. The function begins by declaring three local variables: WORK_COUNT of type NUMBER, RECENT_YEAR of type NUMBER, and WORKLOAD of type VARCHAR2(20). It then executes a SELECT statement that queries the DIRECTED_BY table, aliased as DB, and performs an inner join with the TV_SERIES table, aliased as TS, on the condition that the MSID column from the DIRECTED_BY table equals the SID column from the TV_SERIES table. The SELECT statement uses the aggregate functions COUNT(*) and MAX(EXTRACT(YEAR FROM CURRENT_DATE) - TS.RELEASE_YEAR) to calculate, for the specified director ID, the total number of TV series they have directed and the maximum number of years that have passed since the release year of any series they directed, relative to the current year extracted from the system date. The WHERE clause filters the joined data to only include rows where the DID column in the DIRECTED_BY table matches the input parameter DIR_ID. The results of these two aggregate calculations are stored into the local variables WORK_COUNT and RECENT_YEAR, respectively. Following this data retrieval, the function uses a conditional IF-ELSIF-ELSE block to determine the workload classification. If the WORK_COUNT equals 0, the WORKLOAD variable is assigned the string 'INACTIVE'. Otherwise, if the WORK_COUNT is greater than 10, the WORKLOAD variable is assigned the string 'HEAVY'. Otherwise, if the RECENT_YEAR is less than 3, meaning the director has directed a series released within the last three years, the WORKLOAD variable is assigned the string 'ACTIVE'. If none of the previous conditions are met, the WORKLOAD variable is assigned the string 'MODERATE'. Finally, the function returns the value stored in the WORKLOAD variable.",
    "plsql": "CREATE OR REPLACE FUNCTION CHECK_DIRECTOR_WORKLOAD(DIR_ID IN NUMBER) RETURN VARCHAR2 IS\n  WORK_COUNT NUMBER;\n  RECENT_YEAR NUMBER;\n  WORKLOAD VARCHAR2(20);\nBEGIN\n  SELECT COUNT(*), MAX(EXTRACT(YEAR FROM CURRENT_DATE) - TS.RELEASE_YEAR)\n  INTO WORK_COUNT, RECENT_YEAR\n  FROM DIRECTED_BY DB\n  JOIN TV_SERIES TS ON DB.MSID = TS.SID\n  WHERE DB.DID = DIR_ID;\n  IF WORK_COUNT = 0 THEN\n    WORKLOAD := 'INACTIVE';\n  ELSIF WORK_COUNT > 10 THEN\n    WORKLOAD := 'HEAVY';\n  ELSIF RECENT_YEAR < 3 THEN\n    WORKLOAD := 'ACTIVE';\n  ELSE\n    WORKLOAD := 'MODERATE';\n  END IF;\n  RETURN WORKLOAD;\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "MADE_BY",
      "COMPANY"
    ],
    "call_sqls": [
      "SELECT CHECK_DIRECTOR_WORKLOAD(101) FROM DUAL",
      "SELECT CHECK_DIRECTOR_WORKLOAD(205) FROM DUAL",
      "SELECT CHECK_DIRECTOR_WORKLOAD(78) FROM DUAL",
      "SELECT CHECK_DIRECTOR_WORKLOAD(312) FROM DUAL",
      "SELECT CHECK_DIRECTOR_WORKLOAD(45) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named CHECK_DIRECTOR_WORKLOAD that accepts a director ID number and returns a VARCHAR2 workload classification. Calculate the count of directed TV series and the maximum years since any series release via a join between DIRECTED_BY and TV_SERIES. Return 'INACTIVE' if count is 0, 'HEAVY' if count >10, 'ACTIVE' if the most recent series was within 3 years, else 'MODERATE'.",
    "natural_language": "List the workload classification for a director by creating a function named CHECK_DIRECTOR_WORKLOAD. It should take a director ID, join the DIRECTED_BY and TV_SERIES tables to count directed series and find the maximum years since a release, and then return 'INACTIVE' for a count of 0, 'HEAVY' for a count over 10, 'ACTIVE' if the most recent series is within 3 years, or 'MODERATE' otherwise.",
    "id": 342
  },
  {
    "ir": "Write an Oracle PL/SQL function named `DETERMINE_SERIES_CATEGORY` that accepts a single input parameter, `YEAR_IN`, of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing a category for TV series based on their average number of seasons and episodes for a given release year. The function begins by declaring three local variables: `AVG_SEASONS` of type `NUMBER` to store the average number of seasons, `AVG_EPISODES` of type `NUMBER` to store the average number of episodes, and `CATEGORY` of type `VARCHAR2(20)` to store the determined category string. The core logic starts with a `SELECT` statement that calculates the average of the `NUM_OF_SEASONS` column and the average of the `NUM_OF_EPISODES` column from the `TV_SERIES` table. These calculated average values are then assigned to the `AVG_SEASONS` and `AVG_EPISODES` local variables, respectively. The `SELECT` statement includes a `WHERE` clause that filters the `TV_SERIES` table records, considering only those where the `RELEASE_YEAR` column matches the value provided in the `YEAR_IN` input parameter. Following the data retrieval, a series of conditional `IF-ELSIF-ELSE` statements are executed to determine the `CATEGORY`. The first condition checks if `AVG_SEASONS` is `NULL`. If it is `NULL`, indicating no TV series data was found for the specified `YEAR_IN`, the `CATEGORY` variable is assigned the string `'NO_DATA'`. If `AVG_SEASONS` is not `NULL`, the next condition is evaluated: if `AVG_SEASONS` is greater than `5` AND `AVG_EPISODES` is greater than `50`, then the `CATEGORY` variable is assigned the string `'MAJOR_PRODUCTION'`. If this condition is false, the next `ELSIF` condition checks if `AVG_SEASONS` is `BETWEEN 3 AND 5` (inclusive). If this condition is true, the `CATEGORY` variable is assigned the string `'MID_RANGE'`. If none of the preceding conditions are met, the final `ELSE` block is executed, and the `CATEGORY` variable is assigned the string `'SMALL_SCALE'`. Finally, the function returns the determined `CATEGORY` string as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION DETERMINE_SERIES_CATEGORY(YEAR_IN IN NUMBER) RETURN VARCHAR2 IS\n  AVG_SEASONS NUMBER;\n  AVG_EPISODES NUMBER;\n  CATEGORY VARCHAR2(20);\nBEGIN\n  SELECT AVG(NUM_OF_SEASONS), AVG(NUM_OF_EPISODES)\n  INTO AVG_SEASONS, AVG_EPISODES\n  FROM TV_SERIES\n  WHERE RELEASE_YEAR = YEAR_IN;\n  IF AVG_SEASONS IS NULL THEN\n    CATEGORY := 'NO_DATA';\n  ELSIF AVG_SEASONS > 5 AND AVG_EPISODES > 50 THEN\n    CATEGORY := 'MAJOR_PRODUCTION';\n  ELSIF AVG_SEASONS BETWEEN 3 AND 5 THEN\n    CATEGORY := 'MID_RANGE';\n  ELSE\n    CATEGORY := 'SMALL_SCALE';\n  END IF;\n  RETURN CATEGORY;\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "MADE_BY",
      "COMPANY"
    ],
    "call_sqls": [
      "SELECT DETERMINE_SERIES_CATEGORY(2020) FROM DUAL",
      "SELECT DETERMINE_SERIES_CATEGORY(2015) FROM DUAL",
      "SELECT DETERMINE_SERIES_CATEGORY(2005) FROM DUAL",
      "SELECT DETERMINE_SERIES_CATEGORY(1998) FROM DUAL",
      "SELECT DETERMINE_SERIES_CATEGORY(2022) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named DETERMINE_SERIES_CATEGORY that accepts a NUMBER parameter YEAR_IN and returns a VARCHAR2. It calculates the average seasons and episodes from the TV_SERIES table for that year. Based on these averages, it returns a category: 'NO_DATA' if no data exists, 'MAJOR_PRODUCTION' if averages are high, 'MID_RANGE' for medium seasons, or 'SMALL_SCALE' otherwise.",
    "natural_language": "Write a PL/SQL function called DETERMINE_SERIES_CATEGORY that takes a NUMBER parameter YEAR_IN and outputs a VARCHAR2. Compute the average seasons and episodes from the TV_SERIES table for the given year. Then, return 'NO_DATA' if there is no data, 'MAJOR_PRODUCTION' if the averages are high, 'MID_RANGE' for medium seasons, or 'SMALL_SCALE' for all other cases.",
    "id": 343
  },
  {
    "ir": "Write an Oracle PL/SQL function named ANALYZE_COMPANY_PRODUCTION that accepts a single input parameter COUNTRY_CODE_IN of type VARCHAR2 and returns a VARCHAR2 value. The function calculates a production rating for companies from a specified country by analyzing their associated TV series. It begins by executing a SELECT statement that joins three tables: the COMPANY table (aliased as C), the MADE_BY table (aliased as MB), and the TV_SERIES table (aliased as TS). The join condition links COMPANY.ID to MADE_BY.PID and MADE_BY.MSID to TV_SERIES.SID. The query filters the results to include only rows where the COMPANY.COUNTRY_CODE matches the input parameter COUNTRY_CODE_IN. From this filtered and joined dataset, the query calculates two aggregate values: the total count of rows, which represents the number of TV series, and the average of the TV_SERIES.BUDGET column after data transformation. The budget transformation involves using the REPLACE function to remove any dollar sign ('$') characters from the BUDGET string and then using the TO_NUMBER function to convert the resulting string into a numeric value for averaging. These two calculated values are stored into local variables TOTAL_SERIES (a NUMBER) and AVG_BUDGET (a NUMBER). Following the data retrieval, the function uses conditional IF-ELSIF-ELSE logic to determine a RATING string based on these variables. If TOTAL_SERIES equals zero, the RATING is set to 'NO_PRODUCTION'. Otherwise, if AVG_BUDGET is greater than 500000 and TOTAL_SERIES is greater than 20, the RATING is set to 'PREMIUM'. If the previous condition is not met but AVG_BUDGET is greater than 200000, the RATING is set to 'STANDARD'. In all other cases (where TOTAL_SERIES is greater than zero but the budget conditions are not met), the RATING is set to 'ECONOMY'. Finally, the function returns the determined RATING string.",
    "plsql": "CREATE OR REPLACE FUNCTION ANALYZE_COMPANY_PRODUCTION(COUNTRY_CODE_IN IN VARCHAR2) RETURN VARCHAR2 IS\n  TOTAL_SERIES NUMBER;\n  AVG_BUDGET NUMBER;\n  RATING VARCHAR2(20);\nBEGIN\n  SELECT COUNT(*), AVG(TO_NUMBER(REPLACE(TS.BUDGET, '$', '')))\n  INTO TOTAL_SERIES, AVG_BUDGET\n  FROM COMPANY C\n  JOIN MADE_BY MB ON C.ID = MB.PID\n  JOIN TV_SERIES TS ON MB.MSID = TS.SID\n  WHERE C.COUNTRY_CODE = COUNTRY_CODE_IN;\n  IF TOTAL_SERIES = 0 THEN\n    RATING := 'NO_PRODUCTION';\n  ELSIF AVG_BUDGET > 500000 AND TOTAL_SERIES > 20 THEN\n    RATING := 'PREMIUM';\n  ELSIF AVG_BUDGET > 200000 THEN\n    RATING := 'STANDARD';\n  ELSE\n    RATING := 'ECONOMY';\n  END IF;\n  RETURN RATING;\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "MADE_BY",
      "COMPANY"
    ],
    "call_sqls": [
      "SELECT ANALYZE_COMPANY_PRODUCTION('US') FROM DUAL",
      "SELECT ANALYZE_COMPANY_PRODUCTION('UK') FROM DUAL",
      "SELECT ANALYZE_COMPANY_PRODUCTION('JP') FROM DUAL",
      "SELECT ANALYZE_COMPANY_PRODUCTION('DE') FROM DUAL",
      "SELECT ANALYZE_COMPANY_PRODUCTION('FR') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named ANALYZE_COMPANY_PRODUCTION that accepts a VARCHAR2 parameter COUNTRY_CODE_IN and returns a VARCHAR2. It joins the COMPANY, MADE_BY, and TV_SERIES tables to count series and calculate the average numeric budget for companies from that country. It returns a rating: 'NO_PRODUCTION' if no series exist, 'PREMIUM' for high budget and volume, 'STANDARD' for moderate budget, or 'ECONOMY' otherwise.",
    "natural_language": "Write a function ANALYZE_COMPANY_PRODUCTION that takes a COUNTRY_CODE_IN and returns a VARCHAR2. It joins COMPANY, MADE_BY, and TV_SERIES to count series and average budgets for that country's companies. Return 'NO_PRODUCTION' for no series, 'PREMIUM' for high count and budget, 'STANDARD' for moderate budget, else 'ECONOMY'.",
    "id": 344
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_shop_device_count that takes a single input parameter p_shop_id of type NUMBER, representing the unique identifier of a shop, and returns a value of type NUMBER. The function begins by declaring a local variable v_count of type NUMBER, which will be used to store the result of a query. Within the function body, a SELECT statement is executed to count the total number of rows in the STOCK table where the SHOP_ID column matches the value of the input parameter p_shop_id. The COUNT(*) function is used in the SELECT statement to calculate the number of rows that satisfy the condition SHOP_ID = p_shop_id. The result of this query is assigned to the local variable v_count using the INTO clause. After the query execution, the function returns the value stored in v_count, which represents the total number of devices or items associated with the specified shop ID in the STOCK table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_shop_device_count(p_shop_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM STOCK WHERE SHOP_ID = p_shop_id;\n    RETURN v_count;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_shop_device_count(1) FROM dual",
      "SELECT get_shop_device_count(2) FROM dual",
      "SELECT get_shop_device_count(3) FROM dual",
      "SELECT get_shop_device_count(4) FROM dual",
      "SELECT get_shop_device_count(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_shop_device_count that accepts a NUMBER parameter p_shop_id and returns a NUMBER. It counts and returns the number of rows in the STOCK table where the SHOP_ID matches the input parameter.",
    "natural_language": "Write a function get_shop_device_count(p_shop_id NUMBER) returning NUMBER to count STOCK rows for a given shop_id.",
    "id": 345
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_avg_stock` that is designed to return a single numeric value. This function does not accept any input parameters. Upon execution, it declares a local variable named `v_avg` of type `NUMBER` to temporarily store the calculated average. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement calculates the average of all values present in the `QUANTITY` column from the `STOCK` table. The result of this average calculation is then immediately stored into the `v_avg` local variable. Finally, the function returns the value currently held by the `v_avg` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_stock RETURN NUMBER IS\n    v_avg NUMBER;\nBEGIN\n    SELECT AVG(QUANTITY) INTO v_avg FROM STOCK;\n    RETURN v_avg;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT calculate_avg_stock FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_avg_stock with no parameters that returns a NUMBER. It calculates and returns the average value of the QUANTITY column from the STOCK table.",
    "natural_language": "Write a PL/SQL function called calculate_avg_stock that takes no inputs and gives back a NUMBER. It should figure out and return a kind of typical or usual amount based on the QUANTITY entries in the STOCK table.",
    "id": 346
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_shop_opening_year that accepts a single input parameter p_shop_id of the NUMBER data type and returns a value of the NUMBER data type, where the function's purpose is to retrieve the opening year for a specific shop; the function declares a local variable v_year of type NUMBER to hold the result, then executes a SELECT statement that queries the SHOP table, specifically retrieving the value from the OPEN_YEAR column for the single row where the SHOP_ID column value exactly matches the provided input parameter p_shop_id, and stores this retrieved value into the local variable v_year, and finally returns the value stored in v_year as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_shop_opening_year(p_shop_id NUMBER) RETURN NUMBER IS\n    v_year NUMBER;\nBEGIN\n    SELECT OPEN_YEAR INTO v_year FROM SHOP WHERE SHOP_ID = p_shop_id;\n    RETURN v_year;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_shop_opening_year(1) FROM dual",
      "SELECT get_shop_opening_year(2) FROM dual",
      "SELECT get_shop_opening_year(3) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_shop_opening_year that accepts a NUMBER parameter p_shop_id and returns a NUMBER. It retrieves and returns the OPEN_YEAR from the SHOP table for the row where SHOP_ID matches the input parameter.",
    "natural_language": "Function get_shop_opening_year(p_shop_id NUMBER) returns NUMBER. Fetch OPEN_YEAR from SHOP where SHOP_ID equals p_shop_id.",
    "id": 347
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_device_exists` that accepts a single input parameter, `p_device_id`, which is of the `NUMBER` data type. The purpose of this function is to determine if a record with a matching `DEVICE_ID` exists within the `DEVICE` table. The function declares a local variable, `v_exists`, also of the `NUMBER` data type, to store the result of a database query. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement calculates the `COUNT(*)` (the total number of rows) from the `DEVICE` table. The `WHERE` clause of this `SELECT` statement applies a filter, specifying that only rows where the `DEVICE_ID` column is equal to the value provided by the input parameter `p_device_id` should be considered in the count. The result of this `COUNT(*)` operation is then stored into the `v_exists` local variable. Finally, the function returns the value currently held by the `v_exists` variable. If a device with the specified `p_device_id` exists, `v_exists` will be 1 (or greater if multiple entries with the same ID were possible, though typically `DEVICE_ID` would be unique); otherwise, if no such device is found, `v_exists` will be 0.",
    "plsql": "CREATE OR REPLACE FUNCTION check_device_exists(p_device_id NUMBER) RETURN NUMBER IS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM DEVICE WHERE DEVICE_ID = p_device_id;\n    RETURN v_exists;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT check_device_exists(1) FROM DUAL",
      "SELECT check_device_exists(2) FROM DUAL",
      "SELECT check_device_exists(3) FROM DUAL",
      "SELECT check_device_exists(6) FROM DUAL",
      "SELECT check_device_exists(999) FROM DUAL"
    ],
    "summary": "Create a function named check_device_exists that takes a device ID as a number input and returns a number indicating if a matching device exists in the DEVICE table (1 for exists, 0 for not found).",
    "natural_language": "Write a function called check_device_exists that accepts a numeric device ID and returns a number. The function should return 1 if the device ID is found in the DEVICE table and 0 if it is not found.",
    "id": 348
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_stock_quantity` that is designed to return a single numeric value. This function declares a local variable named `v_max` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement. Specifically, it selects the maximum value from the `QUANTITY` column within the `STOCK` table. The result of this `MAX` aggregate function is then immediately stored into the `v_max` local variable. Finally, the function returns the value currently held by the `v_max` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_stock_quantity RETURN NUMBER IS\n    v_max NUMBER;\nBEGIN\n    SELECT MAX(QUANTITY) INTO v_max FROM STOCK;\n    RETURN v_max;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_max_stock_quantity FROM dual"
    ],
    "summary": "Create a function named get_max_stock_quantity that returns the maximum quantity value from the QUANTITY column in the STOCK table as a number.",
    "natural_language": "Develop a function called get_max_stock_quantity that meticulously retrieves and returns, as a precise numerical value, the single highest quantity figure found within the extensive entries of the QUANTITY column housed in the comprehensive STOCK table.",
    "id": 349
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_product_price` that accepts a single input parameter, `p_product_code`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function declares a local variable named `v_price` of data type `NUMBER` to temporarily store the retrieved product price. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `price` column of the `products` table. The retrieved `price` value is then immediately stored into the local variable `v_price`. The selection of the specific row from the `products` table is determined by a `WHERE` clause, which specifies that the value in the `code` column of the `products` table must be equal to the value provided in the input parameter `p_product_code`. After successfully executing the `SELECT` statement and populating `v_price`, the function then returns the value currently held by the `v_price` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price(p_product_code NUMBER) RETURN NUMBER IS\n    v_price NUMBER;\nBEGIN\n    SELECT price INTO v_price FROM products WHERE code = p_product_code;\n    RETURN v_price;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_price(1) FROM dual",
      "SELECT get_product_price(2) FROM dual",
      "SELECT get_product_price(3) FROM dual",
      "SELECT get_product_price(4) FROM dual",
      "SELECT get_product_price(5) FROM dual"
    ],
    "summary": "Create a function named get_product_price that takes a product code number as input, retrieves the corresponding price from the products table, and returns it as a number.",
    "natural_language": "What is the price for a given product code, and can you provide it as a function named get_product_price that returns the price as a number from the products table?",
    "id": 350
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_manufacturer_name that accepts a single input parameter p_manufacturer_code of type NUMBER and returns a value of type VARCHAR2, which declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters, and within its execution block performs a SELECT operation on the manufacturers table to retrieve the value from the name column, assigning it into the local variable v_name, using a WHERE clause condition that specifies the code column must be equal to the input parameter p_manufacturer_code, and finally returns the value stored in the v_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manufacturer_name(p_manufacturer_code NUMBER) RETURN VARCHAR2 IS\n    v_name VARCHAR2(255);\nBEGIN\n    SELECT name INTO v_name FROM manufacturers WHERE code = p_manufacturer_code;\n    RETURN v_name;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_manufacturer_name(1) FROM DUAL",
      "SELECT get_manufacturer_name(2) FROM DUAL",
      "SELECT get_manufacturer_name(3) FROM DUAL",
      "SELECT get_manufacturer_name(4) FROM DUAL",
      "SELECT get_manufacturer_name(5) FROM DUAL"
    ],
    "summary": "Create a function named get_manufacturer_name that takes a manufacturer code number as input, retrieves the corresponding name from the manufacturers table, and returns it as a VARCHAR2.",
    "natural_language": "Make a function called get_manufacturer_name that, when given a certain manufacturer code, fetches the related name from the manufacturers list and gives it back as a VARCHAR2.",
    "id": 351
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes a single input parameter p_manufacturer_code of type NUMBER, retrieves the revenue value from the manufacturers table where the code column matches the value of p_manufacturer_code, and returns the retrieved revenue as a NUMBER. The function begins by declaring a local variable v_revenue of type NUMBER to store the revenue value temporarily. It then executes a SELECT statement to fetch the revenue column value from the manufacturers table into the v_revenue variable, using a WHERE clause to filter rows based on the condition that the code column equals the input parameter p_manufacturer_code. If the SELECT statement successfully retrieves a value, the function assigns it to v_revenue and immediately returns this value as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manufacturer_revenue(p_manufacturer_code NUMBER) RETURN NUMBER IS\n    v_revenue NUMBER;\nBEGIN\n    SELECT revenue INTO v_revenue FROM manufacturers WHERE code = p_manufacturer_code;\n    RETURN v_revenue;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_manufacturer_revenue(1) FROM DUAL",
      "SELECT get_manufacturer_revenue(2) FROM DUAL",
      "SELECT get_manufacturer_revenue(3) FROM DUAL",
      "SELECT get_manufacturer_revenue(4) FROM DUAL",
      "SELECT get_manufacturer_revenue(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function that accepts a manufacturer code (NUMBER) and returns the revenue (NUMBER) from the manufacturers table for that code.",
    "natural_language": "Calculate and return the revenue for the specified manufacturer code from the manufacturers table.",
    "id": 352
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes a single input parameter PRODUCT_ID_IN of type NUMBER, retrieves the value of the PRODUCT_PRICE column from the PRODUCTS table for the row where the PRODUCT_ID column matches the value of PRODUCT_ID_IN, calculates the square root of the retrieved PRODUCT_PRICE value using the SQRT function, and returns the result. If no row exists in the PRODUCTS table with a PRODUCT_ID matching PRODUCT_ID_IN, the function handles the NO_DATA_FOUND exception by returning NULL. If any other error occurs during execution, the function raises the error to propagate it further. The function uses a local variable V_PRODUCT_PRICE of type NUMBER to temporarily store the retrieved PRODUCT_PRICE value before performing the square root calculation and returning the result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PRODUCT_PRICE_SQRT(PRODUCT_ID_IN NUMBER) RETURN NUMBER IS\n  V_PRODUCT_PRICE NUMBER;\nBEGIN\n  SELECT PRODUCT_PRICE\n  INTO V_PRODUCT_PRICE\n  FROM PRODUCTS\n  WHERE PRODUCT_ID = PRODUCT_ID_IN;\n\n  RETURN SQRT(V_PRODUCT_PRICE);\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    -- Handle case where PRODUCT_ID_IN does not exist\n    RETURN NULL; -- Or raise an application-specific error\n  WHEN OTHERS THEN\n    -- Handle other potential errors\n    RAISE;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_PRODUCT_PRICE_SQRT(117) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE_SQRT(118) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE_SQRT(119) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE_SQRT(100) FROM DUAL",
      "SELECT GET_PRODUCT_PRICE_SQRT(120) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function that accepts a product ID (NUMBER), retrieves its price from the products table, calculates the square root of the price, and returns the result. Return NULL if the product is not found, and raise any other error.",
    "natural_language": "Make a function: input product ID (NUMBER), get its price, return square root of price. Return NULL if not found, raise other errors.",
    "id": 353
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_EMAIL that accepts a single input parameter named CUSTOMER_ID_IN of the NUMBER data type and returns a value of the VARCHAR2 data type. The function declares a local variable named EMAIL of type VARCHAR2 with a maximum length of 255 characters. The function's logic executes a SELECT statement that queries the EMAIL_ADDRESS column from the CUSTOMERS table, specifically from the row where the CUSTOMER_ID column value is equal to the provided input parameter CUSTOMER_ID_IN, and stores the retrieved value into the local EMAIL variable. The function then returns the value stored in the EMAIL variable. If the SELECT statement finds no matching row, the NO_DATA_FOUND exception is handled by returning a NULL value. If any other type of error occurs during execution, the WHEN OTHERS exception handler is triggered, which also returns a NULL value.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_CUSTOMER_EMAIL(CUSTOMER_ID_IN NUMBER) RETURN VARCHAR2 IS\n  EMAIL VARCHAR2(255);\nBEGIN\n  SELECT EMAIL_ADDRESS \n    INTO EMAIL \n    FROM CUSTOMERS \n   WHERE CUSTOMER_ID = CUSTOMER_ID_IN;\n  RETURN EMAIL;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN OTHERS THEN\n    RETURN NULL;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_CUSTOMER_EMAIL(113) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(114) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(115) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(120) FROM DUAL",
      "SELECT CUSTOMER_ID, GET_CUSTOMER_EMAIL(CUSTOMER_ID) FROM COMPLAINTS WHERE COMPLAINT_ID = 1"
    ],
    "summary": "Create a PL/SQL function named GET_CUSTOMER_EMAIL that accepts a customer ID (NUMBER) and returns their email address (VARCHAR2) from the customers table. Return NULL if no customer is found or if any error occurs.",
    "natural_language": "Please construct a PL/SQL function designated as GET_CUSTOMER_EMAIL. This function shall accept a single input parameter of the NUMBER data type, representing a customer identifier. Its purpose is to retrieve and return the corresponding email address, as a VARCHAR2, from the customers table. The function must be implemented to return a NULL value in instances where no customer record matches the provided identifier or if any operational error is encountered during execution.",
    "id": 354
  },
  {
    "ir": "Write an Oracle PL/SQL function named CALCULATE_STAFF_SCORE that accepts a single mandatory input parameter named STAFF_ID_IN of the NUMBER data type and returns a value of the NUMBER data type, where the function's logic begins by declaring a local variable named SCORE of the NUMBER data type and initializing it with the result of the mathematical expression SQRT(STAFF_ID_IN * 10), which first multiplies the input parameter STAFF_ID_IN by the constant integer 10 and then calculates the square root of that product using the built-in SQRT function, and finally the function returns the value stored in the SCORE variable.",
    "plsql": "CREATE OR REPLACE FUNCTION CALCULATE_STAFF_SCORE(STAFF_ID_IN NUMBER) RETURN NUMBER IS\n  SCORE NUMBER := SQRT(STAFF_ID_IN * 10);\nBEGIN\n  RETURN SCORE;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT CALCULATE_STAFF_SCORE(114) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(120) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(115) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(116) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(117) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named CALCULATE_STAFF_SCORE that accepts a staff ID (NUMBER), calculates the square root of the staff ID multiplied by 10, and returns the result (NUMBER).",
    "natural_language": "Please construct a PL/SQL function designated as CALCULATE_STAFF_SCORE. This function shall accept a single numerical parameter representing a staff identification number. Its operation must compute the square root of the product of the provided staff ID and the constant value ten. The function is required to return the computed result as a numerical data type.",
    "id": 355
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_COMPLAINT_STATUS that accepts a single input parameter named COMPLAINT_ID_IN of the NUMBER data type and returns a VARCHAR2 value. The function declares a local variable named STATUS of type VARCHAR2(255). The function's logic begins with a nested PL/SQL block that attempts to execute a SELECT statement. This SELECT statement queries the COMPLAINTS table, specifically retrieving the value from the COMPLAINT_STATUS_CODE column for the single row where the COMPLAINT_ID column is equal to the input parameter COMPLAINT_ID_IN, and assigns the retrieved value into the local STATUS variable. If this SELECT statement finds no matching row, a NO_DATA_FOUND exception is raised and handled by the EXCEPTION section within the nested block, which sets the STATUS variable to the literal string 'Not Found'. After the nested block completes, the function executes a RETURN statement to output the final value held in the STATUS variable.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_COMPLAINT_STATUS(COMPLAINT_ID_IN NUMBER) RETURN VARCHAR2 IS\n  STATUS VARCHAR2(255);\nBEGIN\n  BEGIN\n    SELECT COMPLAINT_STATUS_CODE \n      INTO STATUS \n      FROM COMPLAINTS \n     WHERE COMPLAINT_ID = COMPLAINT_ID_IN;\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n      STATUS := 'Not Found';\n  END;\n  RETURN STATUS;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_COMPLAINT_STATUS(1) FROM DUAL",
      "SELECT GET_COMPLAINT_STATUS(2) FROM DUAL",
      "SELECT GET_COMPLAINT_STATUS(3) FROM DUAL",
      "SELECT GET_COMPLAINT_STATUS(999) FROM DUAL",
      "SELECT GET_COMPLAINT_STATUS(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_COMPLAINT_STATUS that accepts a complaint ID (NUMBER) and returns its status code (VARCHAR2) from the complaints table. Return the string 'Not Found' if the complaint ID does not exist.",
    "natural_language": "Write a PL/SQL function called GET_COMPLAINT_STATUS that takes a complaint ID number and gives back the status code from the complaints table. If you can't really find that specific complaint, then just return 'Not Found'.",
    "id": 356
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_PRODUCT_CATEGORY that accepts a single input parameter named PRODUCT_ID_IN of the NUMBER data type and returns a value of the VARCHAR2 data type; within the function, a local variable named CATEGORY of type VARCHAR2 with a maximum length of 255 characters is declared; the function's execution logic performs a SELECT query on the PRODUCTS table, specifically retrieving the value from the PRODUCT_CATEGORY_CODE column for the single row where the PRODUCT_ID column value is exactly equal to the provided input parameter PRODUCT_ID_IN; the retrieved value is stored into the local CATEGORY variable using an INTO clause; the function then concludes by returning the value stored in the CATEGORY variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PRODUCT_CATEGORY(PRODUCT_ID_IN NUMBER) RETURN VARCHAR2 IS\n  CATEGORY VARCHAR2(255);\nBEGIN\n  SELECT PRODUCT_CATEGORY_CODE\n  INTO CATEGORY\n  FROM PRODUCTS\n  WHERE PRODUCT_ID = PRODUCT_ID_IN;\n\n  RETURN CATEGORY;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_PRODUCT_CATEGORY(117) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(118) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(119) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(4) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_PRODUCT_CATEGORY that accepts a PRODUCT_ID_IN (NUMBER) and returns a VARCHAR2. It retrieves the PRODUCT_CATEGORY_CODE from the PRODUCTS table where PRODUCT_ID matches the input parameter and returns that value.",
    "natural_language": "Develop a PL/SQL function called GET_PRODUCT_CATEGORY, which is designed to take a single numeric input parameter, specifically a PRODUCT_ID_IN of type NUMBER, and subsequently provide a VARCHAR2 as its return value. This function works by meticulously querying the PRODUCTS table to locate and retrieve the precise PRODUCT_CATEGORY_CODE associated with the product whose PRODUCT_ID exactly corresponds to the supplied input parameter, ultimately returning that specific categorical code.",
    "id": 357
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_GYMNAST_AVERAGE_POINTS that accepts a single input parameter P_GYMNAST_ID of type NUMBER and returns a value of type NUMBER; the function begins by declaring a local variable V_AVERAGE_POINTS of type NUMBER, then executes a SELECT statement that queries the GYMNAST table for a specific row where the GYMNAST_ID column equals the input parameter P_GYMNAST_ID, and for that row, calculates an average by summing the values from six columns—FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS—and dividing the total by 6, storing the result into the local variable V_AVERAGE_POINTS; the function then uses an IF-THEN-ELSE conditional statement to evaluate the calculated average: if V_AVERAGE_POINTS is greater than 9, the function returns the value of V_AVERAGE_POINTS after applying the ROUND function to round it to two decimal places, otherwise, if V_AVERAGE_POINTS is 9 or less, the function returns the value of V_AVERAGE_POINTS after applying the FLOOR function to truncate it down to the nearest integer.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_GYMNAST_AVERAGE_POINTS(P_GYMNAST_ID NUMBER) RETURN NUMBER IS\n  V_AVERAGE_POINTS NUMBER;\nBEGIN\n  SELECT (FLOOR_EXERCISE_POINTS + POMMEL_HORSE_POINTS + RINGS_POINTS + VAULT_POINTS + PARALLEL_BARS_POINTS + HORIZONTAL_BAR_POINTS) / 6\n  INTO V_AVERAGE_POINTS\n  FROM GYMNAST\n  WHERE GYMNAST_ID = P_GYMNAST_ID;\n\n  IF V_AVERAGE_POINTS > 9 THEN\n    RETURN ROUND(V_AVERAGE_POINTS, 2);\n  ELSE\n    RETURN FLOOR(V_AVERAGE_POINTS);\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT GET_GYMNAST_AVERAGE_POINTS(1) FROM DUAL",
      "SELECT GET_GYMNAST_AVERAGE_POINTS(2) FROM DUAL",
      "SELECT GET_GYMNAST_AVERAGE_POINTS(4) FROM DUAL",
      "SELECT GET_GYMNAST_AVERAGE_POINTS(3) FROM DUAL",
      "SELECT GET_GYMNAST_AVERAGE_POINTS(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_GYMNAST_AVERAGE_POINTS that accepts a P_GYMNAST_ID (NUMBER) and returns a NUMBER. It calculates the average of six points columns from the GYMNAST table for the specified gymnast. If the average is greater than 9, return it rounded to two decimals; otherwise, return it floored to the nearest integer.",
    "natural_language": "Write a PL/SQL function called GET_GYMNAST_AVERAGE_POINTS that takes a gymnast's ID number and gives back a number. It should figure out the typical score from the six points fields in the GYMNAST table for that particular athlete. If that typical score is on the higher side, more than 9, then hand it back rounded to a couple of decimal places. If it's not that high, just give back the whole number part.",
    "id": 358
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes a single input parameter P_PEOPLE_ID of type NUMBER, retrieves the NAME and HOMETOWN columns from the PEOPLE table for the row where the PEOPLE_ID column matches the value of P_PEOPLE_ID, and returns a formatted string based on the length of the retrieved NAME value. Specifically, the function first declares two local variables, V_NAME and V_HOMETOWN, both of type VARCHAR2 with a maximum length of 255 characters, to store the retrieved NAME and HOMETOWN values. It then executes a SELECT statement to fetch the NAME and HOMETOWN values from the PEOPLE table into these variables, using a WHERE clause to filter rows where PEOPLE_ID equals the input parameter P_PEOPLE_ID. After retrieving the values, the function evaluates the length of the NAME value using the LENGTH function. If the length of V_NAME exceeds 10 characters, the function concatenates V_NAME, the string ' from ', and V_HOMETOWN, and returns this concatenated result. Otherwise, it concatenates V_NAME, the string ' (', V_HOMETOWN, and the closing parenthesis ')', and returns this alternative concatenated result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PEOPLE_NAME_FORMAT(P_PEOPLE_ID NUMBER) RETURN VARCHAR2 IS\n  V_NAME VARCHAR2(255);\n  V_HOMETOWN VARCHAR2(255);\nBEGIN\n  SELECT NAME, HOMETOWN INTO V_NAME, V_HOMETOWN\n  FROM PEOPLE\n  WHERE PEOPLE_ID = P_PEOPLE_ID;\n\n  IF LENGTH(V_NAME) > 10 THEN\n    RETURN V_NAME || ' from ' || V_HOMETOWN;\n  ELSE\n    RETURN V_NAME || ' (' || V_HOMETOWN || ')';\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT GET_PEOPLE_NAME_FORMAT(1) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(2) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(3) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(4) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function that accepts a P_PEOPLE_ID (NUMBER) and returns a VARCHAR2. It retrieves the NAME and HOMETOWN from the PEOPLE table for the specified ID. If the name length exceeds 10 characters, return 'Name from Hometown'; otherwise, return 'Name (Hometown)'.",
    "natural_language": "Write a PL/SQL function that takes a person's ID number and gives back a text string. It should fetch the person's name and where they're from from the people records for that ID. If the name is kind of long, more than a handful of characters, then give back 'Name from Hometown'. If it's shorter, just return it as 'Name (Hometown)'.",
    "id": 359
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_GYMNAST_TOTAL_POINTS` that accepts a single input parameter, `P_GYMNAST_ID`, which is of data type `NUMBER` and represents the unique identifier for a gymnast. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `V_TOTAL_POINTS` of data type `NUMBER` to temporarily store the total points retrieved from the database. The function then performs a `SELECT` operation to retrieve the value from the `TOTAL_POINTS` column of the `GYMNAST` table. This retrieval is conditional, specifically targeting the row where the value in the `GYMNAST_ID` column matches the value provided by the input parameter `P_GYMNAST_ID`. The retrieved `TOTAL_POINTS` value is then immediately assigned to the local variable `V_TOTAL_POINTS`. Following this data retrieval, the function proceeds with a conditional logic block. It evaluates whether the value stored in `V_TOTAL_POINTS` is strictly greater than the numerical constant `57`. If this condition evaluates to `TRUE`, the function returns the value of `V_TOTAL_POINTS` after applying the `ROUND` function, which rounds the number to two decimal places. Conversely, if the condition `V_TOTAL_POINTS > 57` evaluates to `FALSE` (meaning `V_TOTAL_POINTS` is less than or equal to `57`), the function returns the value of `V_TOTAL_POINTS` after applying the `FLOOR` function, which returns the largest integer less than or equal to the input number, effectively truncating any decimal part.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_GYMNAST_TOTAL_POINTS(P_GYMNAST_ID NUMBER) RETURN NUMBER IS\n  V_TOTAL_POINTS NUMBER;\nBEGIN\n  SELECT TOTAL_POINTS INTO V_TOTAL_POINTS\n  FROM GYMNAST\n  WHERE GYMNAST_ID = P_GYMNAST_ID;\n\n  IF V_TOTAL_POINTS > 57 THEN\n    RETURN ROUND(V_TOTAL_POINTS, 2);\n  ELSE\n    RETURN FLOOR(V_TOTAL_POINTS);\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT GET_GYMNAST_TOTAL_POINTS(1) FROM DUAL",
      "SELECT GET_GYMNAST_TOTAL_POINTS(2) FROM DUAL",
      "SELECT GET_GYMNAST_TOTAL_POINTS(4) FROM DUAL",
      "SELECT GET_GYMNAST_TOTAL_POINTS(1) FROM GYMNAST WHERE GYMNAST_ID = 1",
      "SELECT GET_GYMNAST_TOTAL_POINTS(2) FROM GYMNAST WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a PL/SQL function named GET_GYMNAST_TOTAL_POINTS that accepts a P_GYMNAST_ID (NUMBER) and returns a NUMBER. It retrieves the TOTAL_POINTS from the GYMNAST table for the specified gymnast. If the total is greater than 57, return it rounded to two decimals; otherwise, return it floored to the nearest integer.",
    "natural_language": "Please construct a PL/SQL function designated as GET_GYMNAST_TOTAL_POINTS. This function shall accept a single numerical parameter, P_GYMNAST_ID, and yield a numerical return value. Its purpose is to retrieve the TOTAL_POINTS value associated with the specified gymnast from the GYMNAST table. The function must implement the following logic: if the retrieved total exceeds 57, the value should be returned rounded to two decimal places; conversely, if the total is 57 or less, it should be returned as the greatest integer less than or equal to that value.",
    "id": 360
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_PEOPLE_AGE_CATEGORY that accepts a single input parameter P_PEOPLE_ID of type NUMBER, which is used to identify a specific person, and returns a VARCHAR2 string. The function begins by declaring a local variable V_AGE of type NUMBER. It then executes a SELECT statement to query the AGE column from the PEOPLE table, retrieving the value for the row where the PEOPLE_ID column exactly matches the input parameter P_PEOPLE_ID, and stores this retrieved value into the local variable V_AGE. Following this data retrieval, the function evaluates a conditional IF statement: it checks if the value stored in V_AGE is greater than or equal to 18. If this condition is true, the function returns the string literal 'Adult'. If the condition is false, meaning V_AGE is less than 18, the function returns the string literal 'Minor'.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PEOPLE_AGE_CATEGORY(P_PEOPLE_ID NUMBER) RETURN VARCHAR2 IS\n  V_AGE NUMBER;\nBEGIN\n  SELECT AGE INTO V_AGE\n  FROM PEOPLE\n  WHERE PEOPLE_ID = P_PEOPLE_ID;\n\n  IF V_AGE >= 18 THEN\n    RETURN 'Adult';\n  ELSE\n    RETURN 'Minor';\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT GET_PEOPLE_AGE_CATEGORY(1) FROM DUAL",
      "SELECT GET_PEOPLE_AGE_CATEGORY(2) FROM DUAL",
      "SELECT GET_PEOPLE_AGE_CATEGORY(3) FROM DUAL",
      "SELECT NAME, AGE, GET_PEOPLE_AGE_CATEGORY(PEOPLE_ID) AS AGE_CATEGORY FROM PEOPLE WHERE PEOPLE_ID = 1",
      "SELECT P.NAME, G.TOTAL_POINTS, GET_PEOPLE_AGE_CATEGORY(P.PEOPLE_ID) AS AGE_CATEGORY FROM PEOPLE P JOIN GYMNAST G ON P.PEOPLE_ID = G.GYMNAST_ID WHERE P.PEOPLE_ID = 2"
    ],
    "summary": "Create a PL/SQL function named GET_PEOPLE_AGE_CATEGORY that accepts a P_PEOPLE_ID (NUMBER) and returns a VARCHAR2. It retrieves the AGE from the PEOPLE table for the specified ID. If the age is 18 or older, return 'Adult'; otherwise, return 'Minor'.",
    "natural_language": "Write a function GET_PEOPLE_AGE_CATEGORY(P_PEOPLE_ID NUMBER) returning VARCHAR2. Fetch AGE from PEOPLE for that ID. Return 'Adult' if age >= 18, else 'Minor'.",
    "id": 361
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_GYMNAST_EVENT_POINTS that accepts two input parameters: a numeric parameter P_GYMNAST_ID and a string parameter P_EVENT_NAME, and returns a numeric value. The function declares a local numeric variable V_POINTS. The function's logic uses a conditional IF-THEN-ELSE statement to check if the input parameter P_EVENT_NAME is exactly equal to the string literal 'FLOOR'. If this condition is true, the function executes a SELECT statement that retrieves a value from the FLOOR_EXERCISE_POINTS column in the GYMNAST table, specifically from the row where the GYMNAST_ID column matches the input parameter P_GYMNAST_ID, and stores the retrieved value into the local variable V_POINTS. If the condition is false (meaning P_EVENT_NAME is not equal to 'FLOOR'), the function executes a different SELECT statement that retrieves a value from the VAULT_POINTS column in the same GYMNAST table, again from the row where the GYMNAST_ID column equals P_GYMNAST_ID, and stores that value into V_POINTS. Finally, the function returns the value stored in the V_POINTS variable.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_GYMNAST_EVENT_POINTS(P_GYMNAST_ID NUMBER, P_EVENT_NAME VARCHAR2) RETURN NUMBER IS\n  V_POINTS NUMBER;\nBEGIN\n  IF P_EVENT_NAME = 'FLOOR' THEN\n    SELECT FLOOR_EXERCISE_POINTS INTO V_POINTS FROM GYMNAST WHERE GYMNAST_ID = P_GYMNAST_ID;\n  ELSE\n    SELECT VAULT_POINTS INTO V_POINTS FROM GYMNAST WHERE GYMNAST_ID = P_GYMNAST_ID;\n  END IF;\n\n  RETURN V_POINTS;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT GET_GYMNAST_EVENT_POINTS(1, 'FLOOR') FROM DUAL",
      "SELECT GET_GYMNAST_EVENT_POINTS(2, 'VAULT') FROM DUAL",
      "SELECT GET_GYMNAST_EVENT_POINTS(4, 'FLOOR') FROM DUAL",
      "SELECT GET_GYMNAST_EVENT_POINTS(1, 'VAULT') FROM DUAL",
      "SELECT GET_GYMNAST_EVENT_POINTS(2, 'FLOOR') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_GYMNAST_EVENT_POINTS that returns a NUMBER. It accepts a gymnast ID (NUMBER) and an event name (VARCHAR2). If the event name is 'FLOOR', retrieve and return the FLOOR_EXERCISE_POINTS from the GYMNAST table for that gymnast. Otherwise, retrieve and return the VAULT_POINTS from the GYMNAST table for that gymnast.",
    "natural_language": "Hey, can you whip up a PL/SQL function called GET_GYMNAST_EVENT_POINTS that spits back a NUMBER? It needs to take a gymnast's ID (that's a NUMBER) and the name of an event (as a VARCHAR2). Here's the deal: if the event is 'FLOOR', go grab the FLOOR_EXERCISE_POINTS for that gymnast from the GYMNAST table and hand it back. For any other event name, just fetch and return their VAULT_POINTS from the same table.",
    "id": 362
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes three input parameters: p_actor_id of type NUMBER, p_musical_id of type NUMBER, and p_category of type VARCHAR2, and returns a value of type VARCHAR2. The function is named get_actor_name and is designed to retrieve the name of an actor from the ACTOR table based on specific conditions. The function begins by declaring a local variable v_name of type VARCHAR2(255) to store the actor's name temporarily. Within the function body, a SELECT statement is executed to fetch the NAME column from the ACTOR table, which is aliased as 'a'. The ACTOR table is joined with the MUSICAL table, aliased as 'm', using the MUSICAL_ID column as the join condition. The SELECT statement includes a WHERE clause with three conditions: the ACTOR_ID column in the ACTOR table must match the value of the p_actor_id parameter, the MUSICAL_ID column in the MUSICAL table must match the value of the p_musical_id parameter, and the CATEGORY column in the MUSICAL table must match the value of the p_category parameter. If the SELECT statement successfully retrieves a matching row, the NAME value is assigned to the v_name variable. Finally, the function returns the value stored in v_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_name(p_actor_id NUMBER, p_musical_id NUMBER, p_category VARCHAR2) RETURN VARCHAR2 IS\n  v_name VARCHAR2(255);\nBEGIN\n  SELECT a.NAME INTO v_name FROM ACTOR a JOIN MUSICAL m ON a.MUSICAL_ID = m.MUSICAL_ID WHERE a.ACTOR_ID = p_actor_id AND m.MUSICAL_ID = p_musical_id AND m.CATEGORY = p_category;\n  RETURN v_name;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT get_actor_name(1, 1, 'Best Book of a Musical') FROM DUAL",
      "SELECT get_actor_name(2, 2, 'Best Performance by a Leading ...') FROM DUAL",
      "SELECT get_actor_name(3, 1, 'Best Book of a Musical') FROM DUAL",
      "SELECT get_actor_name(1, 2, 'Best Performance by a Leading ...') FROM DUAL",
      "SELECT get_actor_name(2, 3, 'Best Direction of a Musical') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_actor_name that returns a VARCHAR2. It accepts an actor ID (NUMBER), a musical ID (NUMBER), and a category (VARCHAR2). Retrieve and return the actor's NAME from the ACTOR table by joining with the MUSICAL table where the actor ID, musical ID, and category all match the input parameters.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_actor_name that spits back a VARCHAR2? It needs to take in an actor ID (a NUMBER), a musical ID (also a NUMBER), and a category (a VARCHAR2). Basically, go grab the actor's NAME from the ACTOR table, but you gotta link it up with the MUSICAL table where the actor ID, musical ID, and category all line up with the numbers and text you're given.",
    "id": 363
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes three input parameters: p_musical_id of type NUMBER, p_award of type VARCHAR2, and p_category of type VARCHAR2. The function retrieves a single value from the MUSICAL table and returns it as a NUMBER. Specifically, it queries the YEAR column from the MUSICAL table where the MUSICAL_ID column matches the value of the input parameter p_musical_id, the AWARD column matches the value of the input parameter p_award, and the CATEGORY column matches the value of the input parameter p_category. The function declares a local variable v_year of type NUMBER to temporarily store the result of the query. Within the function body, a SELECT statement is executed to fetch the YEAR value from the MUSICAL table into the v_year variable, using the specified conditions on MUSICAL_ID, AWARD, and CATEGORY. If a row is found that satisfies all the conditions, the corresponding YEAR value is assigned to v_year, and the function returns this value. If no matching row is found, the function raises a NO_DATA_FOUND exception implicitly due to the SELECT INTO statement.",
    "plsql": "CREATE OR REPLACE FUNCTION get_musical_year(p_musical_id NUMBER, p_award VARCHAR2, p_category VARCHAR2) RETURN NUMBER IS\n  v_year NUMBER;\nBEGIN\n  SELECT YEAR INTO v_year FROM MUSICAL WHERE MUSICAL_ID = p_musical_id AND AWARD = p_award AND CATEGORY = p_category;\n  RETURN v_year;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT get_musical_year(1, 'Tony Award', 'Best Book of a Musical') FROM DUAL",
      "SELECT get_musical_year(2, 'Tony Award', 'Best Performance by a Leading ...') FROM DUAL",
      "SELECT get_musical_year(3, 'Tony Award', 'Best Direction of a Musical') FROM DUAL",
      "SELECT get_musical_year(1, 'Tony Award', 'Best Direction of a Musical') FROM DUAL",
      "SELECT get_musical_year(2, 'Tony Award', 'Best Book of a Musical') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function that returns a NUMBER. It accepts a musical ID (NUMBER), an award (VARCHAR2), and a category (VARCHAR2). Retrieve and return the YEAR from the MUSICAL table where the musical ID, award, and category all match the input parameters.",
    "natural_language": "Write a PL/SQL function that gives back a NUMBER. It should take a musical ID (as a NUMBER), some kind of award (a VARCHAR2), and a category (also a VARCHAR2). The function needs to find and return the YEAR from the MUSICAL table for entries where the musical ID, award, and category are roughly in line with the provided inputs.",
    "id": 364
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_SOLVED_PROBLEMS_COUNT` that is designed to return a single numerical value representing the total count of problems that have been marked with a status of 'Solved'. This function does not accept any input parameters. Upon execution, the function declares a local variable named `solved_count` of data type `NUMBER` to temporarily store the computed count. The core operation of this function involves a `SELECT` statement that performs a count of records. This `SELECT` statement retrieves data by joining two tables: `PROBLEM_LOG` (aliased as `PL`) and `PROBLEM_STATUS_CODES` (aliased as `PS`). The join condition specifies that rows from `PROBLEM_LOG` are matched with rows from `PROBLEM_STATUS_CODES` where the `PROBLEM_STATUS_CODE` column in `PROBLEM_LOG` is equal to the `PROBLEM_STATUS_CODE` column in `PROBLEM_STATUS_CODES`. After the join, a filtering condition is applied using a `WHERE` clause. This condition checks the `PROBLEM_STATUS_DESCRIPTION` column from the `PROBLEM_STATUS_CODES` table. Specifically, it first removes any leading or trailing whitespace characters from the `PROBLEM_STATUS_DESCRIPTION` using the `TRIM(BOTH ' ' FROM ...)` function and then compares the resulting string to the literal string value 'Solved'. Only rows where this trimmed description exactly matches 'Solved' are considered for the count. The `COUNT(*)` aggregate function then calculates the total number of such filtered and joined rows. The result of this count operation is then stored into the previously declared local variable `solved_count`. Finally, the function returns the numerical value stored in the `solved_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_SOLVED_PROBLEMS_COUNT\nRETURN NUMBER\nIS\n  solved_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO solved_count\n  FROM PROBLEM_LOG PL\n  JOIN PROBLEM_STATUS_CODES PS ON PL.PROBLEM_STATUS_CODE = PS.PROBLEM_STATUS_CODE\n  WHERE TRIM(BOTH ' ' FROM PS.PROBLEM_STATUS_DESCRIPTION) = 'Solved';\n  RETURN solved_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT GET_SOLVED_PROBLEMS_COUNT FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_SOLVED_PROBLEMS_COUNT that returns a NUMBER and accepts no parameters. Count and return the total number of problems from the PROBLEM_LOG table joined with PROBLEM_STATUS_CODES where the trimmed PROBLEM_STATUS_DESCRIPTION equals 'Solved'.",
    "natural_language": "Write a PL/SQL function called GET_SOLVED_PROBLEMS_COUNT that gives back a NUMBER and doesn't need any inputs. It should figure out roughly how many problems from the PROBLEM_LOG and PROBLEM_STATUS_CODES tables are considered resolved, basically where the PROBLEM_STATUS_DESCRIPTION, after cleaning it up, looks like it's 'Solved'.",
    "id": 365
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_RECENT_PROBLEM_LOGS` that is designed to retrieve a set of problem log entries. This function does not accept any input parameters. It is declared to return a `SYS_REFCURSOR` data type, which is a pointer to a result set, allowing the calling environment to fetch rows from the query executed within the function. Inside the function's `BEGIN` block, a local variable named `result_cursor` is declared, also of type `SYS_REFCURSOR`, to hold the reference to the opened cursor. The core operation involves opening this `result_cursor` for a `SELECT` statement. This `SELECT` statement retrieves three specific columns: `PROBLEM_LOG_ID`, `LOG_ENTRY_DATE`, and `LOG_ENTRY_DESCRIPTION`. These columns are selected from the table named `PROBLEM_LOG`, which is aliased as `PL` for brevity within the query. The selection of rows is filtered by a `WHERE` clause. The condition in the `WHERE` clause compares the `LOG_ENTRY_DATE` column from the `PROBLEM_LOG` table with a specific timestamp. To perform this comparison accurately, the `TO_DATE` function is used twice. First, `TO_DATE(PL.LOG_ENTRY_DATE, 'YYYY-MM-DD HH24:MI:SS')` converts the `LOG_ENTRY_DATE` column, which is presumably stored as a string or a type that requires explicit conversion, into a `DATE` data type using the format mask 'YYYY-MM-DD HH24:MI:SS'. Second, `TO_DATE('2023-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS')` converts the literal string '2023-01-01 00:00:00' into a `DATE` data type using the same format mask. The comparison `>` (greater than) ensures that only problem log entries with a `LOG_ENTRY_DATE` occurring after January 1st, 2023, at midnight (00:00:00) are included in the result set. After the `result_cursor` is opened and populated with the filtered data, the function returns this `result_cursor` to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_RECENT_PROBLEM_LOGS\nRETURN SYS_REFCURSOR\nIS\n  result_cursor SYS_REFCURSOR;\nBEGIN\n  OPEN result_cursor FOR\n    SELECT PL.PROBLEM_LOG_ID, PL.LOG_ENTRY_DATE, PL.LOG_ENTRY_DESCRIPTION\n    FROM PROBLEM_LOG PL\n    WHERE TO_DATE(PL.LOG_ENTRY_DATE, 'YYYY-MM-DD HH24:MI:SS') > TO_DATE('2023-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS');\n  RETURN result_cursor;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "DECLARE\n  recent_logs SYS_REFCURSOR;\nBEGIN\n  recent_logs := GET_RECENT_PROBLEM_LOGS;\nEND;"
    ],
    "summary": "Create a PL/SQL function named GET_RECENT_PROBLEM_LOGS that returns a SYS_REFCURSOR. The function should select PROBLEM_LOG_ID, LOG_ENTRY_DATE, and LOG_ENTRY_DESCRIPTION from the PROBLEM_LOG table where the LOG_ENTRY_DATE is after '2023-01-01 00:00:00'.",
    "natural_language": "Write a PL/SQL function called GET_RECENT_PROBLEM_LOGS that returns a SYS_REFCURSOR. Have it fetch PROBLEM_LOG_ID, LOG_ENTRY_DATE, and LOG_ENTRY_DESCRIPTION from the PROBLEM_LOG table for entries with a LOG_ENTRY_DATE later than '2023-01-01 00:00:00'.",
    "id": 366
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_PROBLEM_STATUS_COUNT` that is designed to return a single numeric value. This function declares a local variable named `status_count` of type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement to count the total number of rows in the `PROBLEM_STATUS_CODES` table. The `COUNT(*)` aggregate function is used to determine the total number of rows that satisfy a specific condition. This condition filters the rows based on the `PROBLEM_STATUS_DESCRIPTION` column of the `PROBLEM_STATUS_CODES` table, aliased as `PS`. Specifically, it checks if the value in the `PS.PROBLEM_STATUS_DESCRIPTION` column, after removing any leading or trailing spaces using the `TRIM(BOTH ' ' FROM ...)` function, is exactly equal to the string literal 'Reported'. The result of this count operation is then assigned to the `status_count` local variable using the `INTO` clause. Finally, the function returns the numeric value stored in the `status_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PROBLEM_STATUS_COUNT\nRETURN NUMBER\nIS\n  status_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO status_count\n  FROM PROBLEM_STATUS_CODES PS\n  WHERE TRIM(BOTH ' ' FROM PS.PROBLEM_STATUS_DESCRIPTION) = 'Reported';\n  RETURN status_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT GET_PROBLEM_STATUS_COUNT FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_PROBLEM_STATUS_COUNT that returns a NUMBER. The function should count the rows in the PROBLEM_STATUS_CODES table where the trimmed PROBLEM_STATUS_DESCRIPTION equals 'Reported'.",
    "natural_language": "Write a function GET_PROBLEM_STATUS_COUNT returning NUMBER to count PROBLEM_STATUS_CODES rows where trimmed PROBLEM_STATUS_DESCRIPTION is 'Reported'.",
    "id": 367
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_grade_friend_count` that accepts two input parameters: `p_student_id` of data type `NUMBER`, which represents the unique identifier of a student, and `p_grade` of data type `NUMBER`, which represents a specific academic grade level. This function is designed to return a single value of data type `NUMBER`. The function's primary operation involves querying the database to determine the count of friends associated with a particular student who also belong to a specified grade level. It performs a `SELECT` statement to retrieve this count. The `SELECT` statement calculates the `COUNT(*)` of rows, which represents the total number of matching records. This count is then stored into a local variable named `v_count`, which is declared as a `NUMBER` data type. The query involves a `JOIN` operation between two tables: `FRIEND` (aliased as `f`) and `HIGHSCHOOLER` (aliased as `h`). The `JOIN` condition specifies that `f.FRIEND_ID` must be equal to `h.ID`, linking friends to their high schooler records. Furthermore, the `WHERE` clause applies two conditions to filter the results: `f.STUDENT_ID` must be equal to the value provided in the `p_student_id` input parameter, ensuring that only friends of the specified student are considered, and `h.GRADE` must be equal to the value provided in the `p_grade` input parameter, further restricting the count to friends within the specified grade. Finally, after the count is determined and stored in `v_count`, the function returns the value of `v_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_grade_friend_count(p_student_id NUMBER, p_grade NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM FRIEND f JOIN HIGHSCHOOLER h ON f.FRIEND_ID = h.ID WHERE f.STUDENT_ID = p_student_id AND h.GRADE = p_grade;\n  RETURN v_count;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_grade_friend_count(1101, 9) FROM DUAL",
      "SELECT get_grade_friend_count(1247, 9) FROM DUAL",
      "SELECT get_grade_friend_count(1641, 9) FROM DUAL",
      "SELECT get_grade_friend_count(1501, 9) FROM DUAL",
      "SELECT get_grade_friend_count(1911, 9) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_grade_friend_count that accepts a student_id and a grade as NUMBER parameters and returns a NUMBER. The function should count the friends of the given student who are in the specified grade by joining the FRIEND and HIGHSCHOOLER tables.",
    "natural_language": "Develop a PL/SQL function, which should be named get_grade_friend_count, that is designed to accept two parameters: a student_id and a grade, both of the NUMBER data type, and subsequently returns a NUMBER. This function's purpose is to meticulously calculate and return the total count of friends belonging to the provided student, specifically those friends who are enrolled in the precisely specified grade level. This calculation is achieved by performing a detailed join operation between the FRIEND table and the HIGHSCHOOLER table to accurately identify and tally the relevant friendships.",
    "id": 368
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_mutual_like that accepts two numeric input parameters, p_id1 and p_id2, representing student identifiers, and returns a numeric value indicating the result. The function first executes a SELECT statement querying the LIKES table to check for the existence of a row where the STUDENT_ID column equals the first input parameter p_id1 and the LIKED_ID column equals the second input parameter p_id2, assigning a constant value of 1 to the local variable v_exists if such a row is found. The function then executes a second SELECT statement querying the same LIKES table to check for the existence of a row where the STUDENT_ID column equals the second input parameter p_id2 and the LIKED_ID column equals the first input parameter p_id1, again assigning a constant value of 1 to the local variable v_exists if such a row is found. If both SELECT statements execute successfully, finding both required rows, the function returns the numeric value 1. If either of the SELECT statements fails to find a matching row, raising a NO_DATA_FOUND exception, the function's exception handler catches the exception and returns the numeric value 0 instead.",
    "plsql": "CREATE OR REPLACE FUNCTION check_mutual_like(p_id1 NUMBER, p_id2 NUMBER) RETURN NUMBER IS\n  v_exists NUMBER;\nBEGIN\n  SELECT 1 INTO v_exists FROM LIKES WHERE STUDENT_ID = p_id1 AND LIKED_ID = p_id2;\n  SELECT 1 INTO v_exists FROM LIKES WHERE STUDENT_ID = p_id2 AND LIKED_ID = p_id1;\n  RETURN 1;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN RETURN 0;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT check_mutual_like(1025, 1101) FROM dual",
      "SELECT check_mutual_like(1247, 1468) FROM dual",
      "SELECT check_mutual_like(1316, 1304) FROM dual",
      "SELECT check_mutual_like(1025, 1247) FROM dual",
      "SELECT check_mutual_like(1101, 1316) FROM dual"
    ],
    "summary": "Create a PL/SQL function named check_mutual_like that accepts two student IDs as NUMBER parameters and returns a NUMBER (1 for mutual like, 0 otherwise). The function should check if both students like each other in the LIKES table, using exception handling for NO_DATA_FOUND.",
    "natural_language": "Hey, can you whip up a PL/SQL function called check_mutual_like? It needs to take two student ID numbers and spit back a number—1 if they're both into each other (like, they both show up in that LIKES table), or 0 if not. Oh, and make sure it handles the \"no data found\" thing gracefully with an exception.",
    "id": 369
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes two input parameters, p_grade of type NUMBER and p_threshold of type NUMBER, and returns a NUMBER value. The purpose of this function is to calculate and return the count of \"popular\" high school students in a specific grade, where \"popularity\" is defined as having received more than p_threshold \"likes\" from other students. The function begins by declaring a local variable v_popular_count of type NUMBER to store the result of the calculation. It then executes a SELECT statement that performs the following operations: it joins the LIKES table (aliased as l) with the HIGHSCHOOLER table (aliased as h) on the condition that the LIKED_ID column in the LIKES table matches the ID column in the HIGHSCHOOLER table. This join ensures that only \"likes\" associated with valid high school students are considered. Next, the WHERE clause filters the rows to include only those where the GRADE column in the HIGHSCHOOLER table matches the value of the input parameter p_grade, thereby restricting the analysis to students in the specified grade. The query then groups the resulting rows by the LIKED_ID column, which represents the ID of the student who received the \"likes.\" For each group, the HAVING clause checks if the count of rows in that group (i.e., the number of \"likes\" received by the student) exceeds the value of the input parameter p_threshold. Only groups that satisfy this condition are included in the final result. The COUNT(*) function is then applied to count the total number of such groups, representing the number of \"popular\" students in the specified grade. This count is stored in the v_popular_count variable. Finally, the function returns the value of v_popular_count as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_grade_popularity(p_grade NUMBER, p_threshold NUMBER) RETURN NUMBER IS\n  v_popular_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_popular_count FROM (SELECT LIKED_ID FROM LIKES l JOIN HIGHSCHOOLER h ON l.LIKED_ID = h.ID WHERE h.GRADE = p_grade GROUP BY LIKED_ID HAVING COUNT(*) > p_threshold);\n  RETURN v_popular_count;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_grade_popularity(9, 1) FROM DUAL",
      "SELECT get_grade_popularity(10, 0) FROM DUAL",
      "SELECT get_grade_popularity(11, 2) FROM DUAL",
      "SELECT get_grade_popularity(12, 3) FROM DUAL",
      "SELECT get_grade_popularity(9, 5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function that accepts a grade and a threshold as NUMBER parameters and returns a NUMBER. The function should count the number of \"popular\" students in the given grade from the HIGHSCHOOLER table, where popularity is defined as having more likes in the LIKES table than the specified threshold.",
    "natural_language": "Hey, can you whip up a PL/SQL function that takes in a grade and a popularity cutoff as numbers? It should spit back a number too. Basically, we need to figure out how many kids in that grade are considered \"popular\" from the HIGHSCHOOLER table. A student's popular if they've got more likes in the LIKES table than that threshold number we're giving.",
    "id": 370
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_friend_name_mod that accepts two input parameters: a numeric parameter p_student_id representing a student identifier and a numeric parameter p_mod representing a modulus value, and returns a single VARCHAR2 string. The function declares a local variable v_name of type VARCHAR2(255) to hold the result. The core logic executes a SELECT statement that retrieves a NAME value from the HIGHSCHOOLER table. This retrieval is conditioned on the HIGHSCHOOLER record's ID column satisfying two criteria simultaneously: first, the ID must be found within a nested subquery that selects the FRIEND_ID column from the FRIEND table for all rows where the STUDENT_ID column equals the input parameter p_student_id; second, the result of applying the MOD function to the HIGHSCHOOLER.ID column with the input parameter p_mod as the divisor must equal zero. The selected NAME value is assigned into the local variable v_name. The function then returns the value stored in v_name. An exception handling block is defined to catch the NO_DATA_FOUND exception, which occurs if the SELECT statement retrieves no rows that satisfy all conditions; in this case, the function returns a NULL value instead of raising an error.",
    "plsql": "CREATE OR REPLACE FUNCTION get_friend_name_mod(p_student_id NUMBER, p_mod NUMBER) RETURN VARCHAR2 IS\n  v_name VARCHAR2(255);\nBEGIN\n  SELECT NAME INTO v_name FROM HIGHSCHOOLER WHERE ID IN (SELECT FRIEND_ID FROM FRIEND WHERE STUDENT_ID = p_student_id) AND MOD(ID, p_mod) = 0;\n  RETURN v_name;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN RETURN NULL;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_friend_name_mod(1101, 2) FROM dual",
      "SELECT get_friend_name_mod(1247, 3) FROM dual",
      "SELECT get_friend_name_mod(1101, 5) FROM dual",
      "SELECT get_friend_name_mod(1247, 7) FROM dual",
      "SELECT get_friend_name_mod(1101, 10) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_friend_name_mod that returns the NAME of a friend for a given student ID, where the friend's ID satisfies a MOD condition. It returns NULL if no data is found.",
    "natural_language": "Write a PL/SQL function called get_friend_name_mod to return the NAME of a friend for a specified student ID, where the friend's ID meets a MOD condition. Return NULL if no matching data exists.",
    "id": 371
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_country_language_status that accepts a single input parameter p_country_id of type NUMBER, which represents the unique identifier for a country, and returns a VARCHAR2 string. The function begins by declaring a local variable v_lang_count of type NUMBER. It then executes a SELECT statement to query the OFFICIAL_LANGUAGES table, counting all rows where the COUNTRY_ID column matches the provided input parameter p_country_id, and stores the result into the variable v_lang_count. Following this, the function uses a conditional IF-ELSIF-ELSE block to evaluate the value of v_lang_count: if the count equals zero, the function returns the literal string 'NO_LANGUAGES'; if the count equals one, it returns 'SINGLE_LANGUAGE'; if the count equals two, it returns 'BILINGUAL'; for any count greater than two, the function returns the literal string 'MULTILINGUAL'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_language_status(p_country_id NUMBER) RETURN VARCHAR2 IS\n  v_lang_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_lang_count FROM OFFICIAL_LANGUAGES WHERE COUNTRY_ID = p_country_id;\n  IF v_lang_count = 0 THEN\n    RETURN 'NO_LANGUAGES';\n  ELSIF v_lang_count = 1 THEN\n    RETURN 'SINGLE_LANGUAGE';\n  ELSIF v_lang_count = 2 THEN\n    RETURN 'BILINGUAL';\n  ELSE\n    RETURN 'MULTILINGUAL';\n  END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_country_language_status(1) FROM DUAL",
      "SELECT get_country_language_status(2) FROM DUAL",
      "SELECT get_country_language_status(3) FROM DUAL",
      "SELECT c.NAME, get_country_language_status(c.ID) AS LANGUAGE_STATUS FROM COUNTRIES c WHERE c.ID = 1",
      "SELECT c.NAME, get_country_language_status(c.ID) AS LANGUAGE_STATUS FROM COUNTRIES c ORDER BY c.ID"
    ],
    "summary": "Create a PL/SQL function named get_country_language_status that returns a status string ('NO_LANGUAGES', 'SINGLE_LANGUAGE', 'BILINGUAL', or 'MULTILINGUAL') based on the count of official languages for a given country ID.",
    "natural_language": "Write a PL/SQL function called get_country_language_status that gives back a status string. The status should be something like 'NO_LANGUAGES', 'SINGLE_LANGUAGE', 'BILINGUAL', or 'MULTILINGUAL', depending on roughly how many official languages you find for a particular country ID.",
    "id": 372
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_country_category` that accepts a single input parameter, `p_country_id`, which is of data type `NUMBER` and represents the unique identifier for a country. This function is designed to return a `VARCHAR2` value, which will be a textual category assigned to the country based on its overall score.\n\nUpon execution, the function first declares a local variable named `v_score` of data type `NUMBER`. It then performs a `SELECT` operation to retrieve the `OVERALL_SCORE` column from the `COUNTRIES` table. This retrieval is conditional, specifically targeting the row where the `ID` column matches the value provided by the input parameter `p_country_id`. The retrieved `OVERALL_SCORE` value is then stored into the `v_score` local variable.\n\nFollowing this data retrieval, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) based on the value stored in `v_score`.\n1. If `v_score` is greater than or equal to `98`, the function immediately returns the string literal `'TOP_TIER'`.\n2. Otherwise, if `v_score` is greater than or equal to `95`, the function immediately returns the string literal `'HIGH_TIER'`.\n3. Otherwise, if `v_score` is greater than or equal to `90`, the function immediately returns the string literal `'MID_TIER'`.\n4. If none of the above conditions are met (i.e., `v_score` is less than `90`), the function returns the string literal `'LOW_TIER'`.\n\nThe function concludes after one of these return statements is executed, providing a categorical classification for the country identified by `p_country_id` based on its `OVERALL_SCORE`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_country_category(p_country_id NUMBER) RETURN VARCHAR2 IS\n  v_score NUMBER;\nBEGIN\n  SELECT OVERALL_SCORE INTO v_score FROM COUNTRIES WHERE ID = p_country_id;\n  IF v_score >= 98 THEN\n    RETURN 'TOP_TIER';\n  ELSIF v_score >= 95 THEN\n    RETURN 'HIGH_TIER';\n  ELSIF v_score >= 90 THEN\n    RETURN 'MID_TIER';\n  ELSE\n    RETURN 'LOW_TIER';\n  END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT calculate_country_category(1) FROM DUAL",
      "SELECT calculate_country_category(2) FROM DUAL",
      "SELECT calculate_country_category(3) FROM DUAL",
      "SELECT c.NAME, calculate_country_category(c.ID) AS CATEGORY FROM COUNTRIES c WHERE c.ID = 1",
      "SELECT c.NAME, calculate_country_category(c.ID) AS CATEGORY FROM COUNTRIES c WHERE c.OVERALL_SCORE >= 95"
    ],
    "summary": "Create a PL/SQL function named calculate_country_category that returns a tier category ('TOP_TIER', 'HIGH_TIER', 'MID_TIER', or 'LOW_TIER') for a country based on its OVERALL_SCORE from the COUNTRIES table.",
    "natural_language": "Develop a PL/SQL function called calculate_country_category that will determine and return a specific tier classification for a country, such as 'TOP_TIER', 'HIGH_TIER', 'MID_TIER', or 'LOW_TIER', by thoroughly evaluating its OVERALL_SCORE as recorded in the detailed COUNTRIES table.",
    "id": 373
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_language_usage_status that accepts a single input parameter p_language_id of the NUMBER data type and returns a VARCHAR2 value, where the function's purpose is to determine and return a descriptive status for a language based on how many countries officially use it, by first executing a SELECT statement that queries the OFFICIAL_LANGUAGES table, counting all rows where the LANGUAGE_ID column matches the provided p_language_id parameter, and storing the resulting count in a local variable v_country_count, then evaluating this count with a series of IF-ELSIF-ELSE conditional statements: if the count equals zero, the function returns the string 'UNUSED'; if the count equals one, it returns 'SINGLE_COUNTRY'; if the count equals two, it returns 'TWO_COUNTRIES'; and for any count greater than two, the function returns the string 'WIDESPREAD'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_language_usage_status(p_language_id NUMBER) RETURN VARCHAR2 IS\n  v_country_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_country_count FROM OFFICIAL_LANGUAGES WHERE LANGUAGE_ID = p_language_id;\n  IF v_country_count = 0 THEN\n    RETURN 'UNUSED';\n  ELSIF v_country_count = 1 THEN\n    RETURN 'SINGLE_COUNTRY';\n  ELSIF v_country_count = 2 THEN\n    RETURN 'TWO_COUNTRIES';\n  ELSE\n    RETURN 'WIDESPREAD';\n  END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_language_usage_status(1) FROM dual",
      "SELECT get_language_usage_status(2) FROM dual",
      "SELECT get_language_usage_status(3) FROM dual",
      "SELECT get_language_usage_status(4) FROM dual",
      "SELECT get_language_usage_status(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_language_usage_status that returns a status string ('UNUSED', 'SINGLE_COUNTRY', 'TWO_COUNTRIES', or 'WIDESPREAD') based on the number of countries using a given language ID.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_language_usage_status? It should spit out a status string—like 'UNUSED', 'SINGLE_COUNTRY', 'TWO_COUNTRIES', or 'WIDESPREAD'—depending on how many countries are actually using a specific language ID.",
    "id": 374
  },
  {
    "ir": "Write an Oracle PL/SQL function named evaluate_justice_level that accepts a single input parameter p_country_id of type NUMBER, which is used to identify a specific country record, and returns a VARCHAR2 string representing a categorical justice level. The function begins by declaring a local variable v_justice_score of type NUMBER to hold a numeric score retrieved from the database. It then executes a SELECT statement to query the COUNTRIES table, specifically retrieving the value from the JUSTICE_SCORE column for the row where the ID column exactly matches the provided p_country_id parameter, and stores this value into the v_justice_score variable. Following the data retrieval, the function uses a series of conditional IF-ELSIF-ELSE statements to evaluate the retrieved score and determine the corresponding descriptive category: if v_justice_score is greater than or equal to 95, the function returns the string 'EXCELLENT_JUSTICE'; if the score is less than 95 but greater than or equal to 85, it returns 'GOOD_JUSTICE'; if the score is less than 85 but greater than or equal to 75, it returns 'FAIR_JUSTICE'; for any score below 75, the function returns the string 'POOR_JUSTICE'.",
    "plsql": "CREATE OR REPLACE FUNCTION evaluate_justice_level(p_country_id NUMBER) RETURN VARCHAR2 IS\n  v_justice_score NUMBER;\nBEGIN\n  SELECT JUSTICE_SCORE INTO v_justice_score FROM COUNTRIES WHERE ID = p_country_id;\n  IF v_justice_score >= 95 THEN\n    RETURN 'EXCELLENT_JUSTICE';\n  ELSIF v_justice_score >= 85 THEN\n    RETURN 'GOOD_JUSTICE';\n  ELSIF v_justice_score >= 75 THEN\n    RETURN 'FAIR_JUSTICE';\n  ELSE\n    RETURN 'POOR_JUSTICE';\n  END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT evaluate_justice_level(1) FROM DUAL",
      "SELECT evaluate_justice_level(2) FROM DUAL",
      "SELECT evaluate_justice_level(3) FROM DUAL",
      "SELECT evaluate_justice_level( (SELECT ID FROM COUNTRIES WHERE JUSTICE_SCORE = 100 AND ROWNUM = 1) ) FROM DUAL",
      "SELECT evaluate_justice_level( (SELECT ID FROM COUNTRIES WHERE JUSTICE_SCORE = 90.8 AND ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named evaluate_justice_level that takes a country ID (NUMBER) and returns a VARCHAR2 justice category. It retrieves the JUSTICE_SCORE from the COUNTRIES table for the given ID and categorizes it: >=95 returns 'EXCELLENT_JUSTICE', >=85 returns 'GOOD_JUSTICE', >=75 returns 'FAIR_JUSTICE', and <75 returns 'POOR_JUSTICE'.",
    "natural_language": "Write a PL/SQL function called evaluate_justice_level that accepts a country ID as a NUMBER and outputs a VARCHAR2 justice category. Fetch the JUSTICE_SCORE from the COUNTRIES table for the provided ID. Then, classify the score: return 'EXCELLENT_JUSTICE' for scores 95 or above, 'GOOD_JUSTICE' for scores 85 or above, 'FAIR_JUSTICE' for scores 75 or above, and 'POOR_JUSTICE' for scores below 75.",
    "id": 375
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_education_category that accepts a single input parameter p_country_id of type NUMBER, which is used to identify a specific country record, and returns a VARCHAR2 string representing an education category classification. The function begins by declaring a local variable v_education_score of type NUMBER. It then executes a SELECT statement to query the COUNTRIES table, retrieving the value from the EDUCATION_SCORE column for the row where the ID column exactly matches the provided p_country_id parameter, and stores this retrieved value into the v_education_score variable. Following this data retrieval, the function evaluates the v_education_score using a series of conditional IF-ELSIF-ELSE statements: if the score is greater than or equal to 95, the function returns the literal string 'OUTSTANDING_EDUCATION'; if the score is less than 95 but greater than or equal to 90, it returns 'STRONG_EDUCATION'; if the score is less than 90 but greater than or equal to 85, it returns 'ADEQUATE_EDUCATION'; for any score below 85, the function returns the literal string 'NEEDS_IMPROVEMENT'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_education_category(p_country_id NUMBER) RETURN VARCHAR2 IS\n  v_education_score NUMBER;\nBEGIN\n  SELECT EDUCATION_SCORE INTO v_education_score FROM COUNTRIES WHERE ID = p_country_id;\n  IF v_education_score >= 95 THEN\n    RETURN 'OUTSTANDING_EDUCATION';\n  ELSIF v_education_score >= 90 THEN\n    RETURN 'STRONG_EDUCATION';\n  ELSIF v_education_score >= 85 THEN\n    RETURN 'ADEQUATE_EDUCATION';\n  ELSE\n    RETURN 'NEEDS_IMPROVEMENT';\n  END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_education_category(1) FROM dual",
      "SELECT get_education_category(2) FROM dual",
      "SELECT get_education_category(3) FROM dual",
      "SELECT get_education_category(4) FROM dual",
      "SELECT get_education_category(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_education_category that takes a country ID (NUMBER) and returns a VARCHAR2 education category. It retrieves the EDUCATION_SCORE from the COUNTRIES table for the given ID and categorizes it: >=95 returns 'OUTSTANDING_EDUCATION', >=90 returns 'STRONG_EDUCATION', >=85 returns 'ADEQUATE_EDUCATION', and <85 returns 'NEEDS_IMPROVEMENT'.",
    "natural_language": "Develop a PL/SQL function called get_education_category, which accepts a single numeric input parameter for a country ID and yields a VARCHAR2 output representing an educational classification. This function should first query the COUNTRIES table to obtain the specific EDUCATION_SCORE associated with the provided identifier. Subsequently, it must meticulously evaluate this score to assign a descriptive category: any score equal to or surpassing 95 should be classified as 'OUTSTANDING_EDUCATION'; a score of 90 or higher but below 95 merits the category 'STRONG_EDUCATION'; a score of 85 or higher but below 90 is deemed 'ADEQUATE_EDUCATION'; and finally, any score falling below the threshold of 85 must be categorized as 'NEEDS_IMPROVEMENT'.",
    "id": 376
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_PAYMENT_METHOD that accepts a single input parameter named CUSTOMER_ID_IN of the NUMBER data type and returns a value of the VARCHAR2 data type. The function declares a local variable named PAYMENT_METHOD_OUT of type VARCHAR2 with a maximum length of 255 characters. The function executes a SELECT statement that queries the PAYMENT_METHOD column from the CUSTOMERS table. The query applies the TO_SINGLE_BYTE function to the PAYMENT_METHOD column value, which converts any multi-byte characters in the string to their single-byte equivalents. The query includes a WHERE clause condition that filters the result to only the row where the CUSTOMER_ID column value is equal to the input parameter CUSTOMER_ID_IN. The result of this query is then stored into the local variable PAYMENT_METHOD_OUT. Finally, the function returns the value stored in the PAYMENT_METHOD_OUT variable.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_CUSTOMER_PAYMENT_METHOD(CUSTOMER_ID_IN NUMBER) RETURN VARCHAR2 IS\n  PAYMENT_METHOD_OUT VARCHAR2(255);\nBEGIN\n  SELECT TO_SINGLE_BYTE(PAYMENT_METHOD)\n  INTO PAYMENT_METHOD_OUT\n  FROM CUSTOMERS\n  WHERE CUSTOMER_ID = CUSTOMER_ID_IN;\n  RETURN PAYMENT_METHOD_OUT;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "CUSTOMERS",
      "ORDER_DELIVERIES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(1) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(2) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(3) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(10) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_CUSTOMER_PAYMENT_METHOD that takes a customer ID (NUMBER) and returns a VARCHAR2. It retrieves the PAYMENT_METHOD from the CUSTOMERS table for the given ID, converting any multi-byte characters to single-byte, and returns the result.",
    "natural_language": "Write a function GET_CUSTOMER_PAYMENT_METHOD that returns a VARCHAR2. It takes a customer ID, gets the PAYMENT_METHOD from CUSTOMERS for that ID, converts multi-byte to single-byte, and returns it.",
    "id": 377
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_ORDER_STATUS` that accepts a single input parameter, `ACTUAL_ORDER_ID_IN`, which is of data type `NUMBER`, and is intended to represent the unique identifier of an order. This function is designed to return a `VARCHAR2` value, specifically the status of the order corresponding to the provided `ACTUAL_ORDER_ID_IN`. Upon execution, the function declares a local variable named `ORDER_STATUS_OUT` of data type `VARCHAR2` with a maximum length of 255 characters, which will temporarily store the retrieved order status. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `ORDER_STATUS_CODE` column. The data is sourced from the table named `ACTUAL_ORDERS`. The selection is filtered by a `WHERE` clause, which specifies that only rows where the value in the `ACTUAL_ORDER_ID` column is equal to the value passed in the `ACTUAL_ORDER_ID_IN` input parameter should be considered. The single `ORDER_STATUS_CODE` value retrieved by this `SELECT` statement is then immediately assigned to the `ORDER_STATUS_OUT` local variable. Finally, the function returns the value currently held in the `ORDER_STATUS_OUT` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_ORDER_STATUS(ACTUAL_ORDER_ID_IN NUMBER) RETURN VARCHAR2 IS\n  ORDER_STATUS_OUT VARCHAR2(255);\nBEGIN\n  SELECT ORDER_STATUS_CODE\n  INTO ORDER_STATUS_OUT\n  FROM ACTUAL_ORDERS\n  WHERE ACTUAL_ORDER_ID = ACTUAL_ORDER_ID_IN;\n  RETURN ORDER_STATUS_OUT;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "CUSTOMERS",
      "ORDER_DELIVERIES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "SELECT GET_ORDER_STATUS(1) FROM DUAL",
      "SELECT GET_ORDER_STATUS(2) FROM DUAL",
      "SELECT GET_ORDER_STATUS(3) FROM DUAL",
      "SELECT GET_ORDER_STATUS(11) FROM DUAL",
      "SELECT GET_ORDER_STATUS(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_ORDER_STATUS that takes an order ID (NUMBER) and returns a VARCHAR2 status. It retrieves the ORDER_STATUS_CODE from the ACTUAL_ORDERS table for the given ID and returns it.",
    "natural_language": "Write a PL/SQL function called GET_ORDER_STATUS that accepts a numeric order identifier and gives back a text status. It should fetch the ORDER_STATUS_CODE from the ACTUAL_ORDERS table for that specific ID and hand it back.",
    "id": 378
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_EMPLOYEE_PHONE` that is designed to retrieve the phone number of a specific employee. This function accepts one input parameter: `EMPLOYEE_ID_IN`, which is of data type `NUMBER` and represents the unique identifier for an employee whose phone number is to be retrieved. The function is declared to return a value of data type `VARCHAR2`, which will be the employee's phone number. Internally, the function declares a local variable named `EMPLOYEE_PHONE_OUT` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved phone number. The core operation of the function involves a `SELECT` statement that queries the `EMPLOYEES` table. This `SELECT` statement retrieves the value from the `EMPLOYEE_PHONE` column. The retrieved value is then immediately stored into the `EMPLOYEE_PHONE_OUT` local variable using the `INTO` clause. The selection of the specific row from the `EMPLOYEES` table is determined by a `WHERE` clause, which specifies that the `EMPLOYEE_ID` column in the `EMPLOYEES` table must exactly match the value provided by the `EMPLOYEE_ID_IN` input parameter. After successfully executing the `SELECT` statement and populating `EMPLOYEE_PHONE_OUT`, the function then returns the value currently held in the `EMPLOYEE_PHONE_OUT` variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_EMPLOYEE_PHONE(EMPLOYEE_ID_IN NUMBER) RETURN VARCHAR2 IS\n  EMPLOYEE_PHONE_OUT VARCHAR2(255);\nBEGIN\n  SELECT EMPLOYEE_PHONE\n  INTO EMPLOYEE_PHONE_OUT\n  FROM EMPLOYEES\n  WHERE EMPLOYEE_ID = EMPLOYEE_ID_IN;\n  RETURN EMPLOYEE_PHONE_OUT;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "CUSTOMERS",
      "ORDER_DELIVERIES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "SELECT GET_EMPLOYEE_PHONE(1) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(2) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(3) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(4) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(6) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_EMPLOYEE_PHONE that takes an employee ID (NUMBER) and returns a VARCHAR2 phone number. It retrieves the EMPLOYEE_PHONE from the EMPLOYEES table for the given ID and returns it.",
    "natural_language": "Develop a comprehensive PL/SQL function called GET_EMPLOYEE_PHONE, which is designed to accept a single numeric input parameter representing an employee ID and subsequently provide a VARCHAR2 output containing the corresponding phone number. This function will meticulously query the EMPLOYEES table to locate and retrieve the specific EMPLOYEE_PHONE value associated with the provided identifier, ensuring it is accurately returned.",
    "id": 379
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_ACTOR_COUNT_BY_MUSICAL` that accepts a single input parameter, `p_musical_id`, which is of data type `NUMBER` and represents the unique identifier for a musical production. This function is designed to return a `NUMBER` value. The function begins by declaring a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a count operation. The core logic of the function involves executing a `SELECT` statement to count the total number of rows in the `ACTOR` table. This count is performed under a specific condition: only rows where the value in the `MUSICAL_ID` column matches the value provided in the input parameter `p_musical_id` are included in the count. The result of this `COUNT(*)` operation is then stored into the `v_count` variable. Following this, the function proceeds with a conditional `IF` statement. It evaluates whether the value stored in `v_count` is greater than `0`. If this condition is true, meaning that at least one actor was found for the specified `p_musical_id`, the function calculates a new value by multiplying `v_count` by `10` and then returns this calculated `NUMBER` value as its output. If the condition `v_count > 0` is false, meaning no actors were found for the given `p_musical_id`, the function directly returns the `NUMBER` value `0` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_ACTOR_COUNT_BY_MUSICAL(p_musical_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM ACTOR WHERE MUSICAL_ID = p_musical_id;\n  IF v_count > 0 THEN\n    RETURN v_count * 10;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT GET_ACTOR_COUNT_BY_MUSICAL(1) FROM DUAL",
      "SELECT GET_ACTOR_COUNT_BY_MUSICAL(2) FROM DUAL",
      "SELECT GET_ACTOR_COUNT_BY_MUSICAL(3) FROM DUAL",
      "SELECT GET_ACTOR_COUNT_BY_MUSICAL(10) FROM DUAL",
      "SELECT GET_ACTOR_COUNT_BY_MUSICAL( (SELECT MUSICAL_ID FROM MUSICAL WHERE ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Create a function named GET_ACTOR_COUNT_BY_MUSICAL that takes a musical_id (NUMBER) and returns a NUMBER. It counts actors in the ACTOR table for that musical_id. If the count is greater than 0, return the count multiplied by 10; otherwise, return 0.",
    "natural_language": "Write a function called GET_ACTOR_COUNT_BY_MUSICAL that accepts a musical_id as a NUMBER and gives back a NUMBER. It should figure out roughly how many actors are listed in the ACTOR table for that specific musical. If there seem to be a decent number of actors, maybe more than a few, return that count times ten. If there aren't really any to speak of, just return zero.",
    "id": 380
  },
  {
    "ir": "Write an Oracle PL/SQL function named CHECK_MUSICAL_YEAR that accepts a single input parameter p_musical_id of the NUMBER data type, which is used to identify a specific musical record, and returns a VARCHAR2 string. The function begins by declaring a local variable v_year of type NUMBER. It then executes a SELECT statement to query the MUSICAL table, specifically retrieving the value from the YEAR column for the single row where the MUSICAL_ID column exactly matches the provided input parameter p_musical_id, and stores this retrieved year value into the local variable v_year. Following this data retrieval, the function evaluates a conditional IF statement: it checks if the value stored in v_year is numerically less than 1990. If this condition is true, the function immediately returns the string literal 'OLD'. If the condition is false, meaning the year is 1990 or greater, the function executes the ELSE branch and returns the string literal 'NEW'.",
    "plsql": "CREATE OR REPLACE FUNCTION CHECK_MUSICAL_YEAR(p_musical_id NUMBER) RETURN VARCHAR2 IS\n  v_year NUMBER;\nBEGIN\n  SELECT YEAR INTO v_year FROM MUSICAL WHERE MUSICAL_ID = p_musical_id;\n  IF v_year < 1990 THEN\n    RETURN 'OLD';\n  ELSE\n    RETURN 'NEW';\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT CHECK_MUSICAL_YEAR(1) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(2) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(3) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(4) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(5) FROM DUAL"
    ],
    "summary": "Create a function named CHECK_MUSICAL_YEAR that takes a musical_id (NUMBER) and returns a VARCHAR2. It retrieves the year from the MUSICAL table for the given ID. If the year is less than 1990, return 'OLD'; otherwise, return 'NEW'.",
    "natural_language": "Define a function called CHECK_MUSICAL_YEAR that accepts a musical_id parameter of type NUMBER and yields a VARCHAR2 output. The function shall query the MUSICAL table to obtain the year associated with the provided identifier. Should the retrieved year be prior to 1990, the function is to return the string 'OLD'; if not, it shall return 'NEW'.",
    "id": 381
  },
  {
    "ir": "Write an Oracle PL/SQL function named CALCULATE_AGE_BONUS that takes a single input parameter p_actor_id of type NUMBER, representing the unique identifier of an actor in the ACTOR table. The function retrieves the AGE column value from the ACTOR table for the row where the ACTOR_ID column matches the value of the input parameter p_actor_id. The AGE column is expected to store the age of the actor as a numeric value. The retrieved AGE value is stored in a local variable v_age of type NUMBER. The function then evaluates a conditional statement: if the value of v_age is greater than 25, the function adds 5 to the value of v_age and returns the resulting sum as the output of the function. If the value of v_age is less than or equal to 25, the function directly returns the value of v_age without modification. The function does not perform any updates, inserts, or deletes, and its sole operation is a SELECT statement to retrieve the AGE value from the ACTOR table based on the provided ACTOR_ID. The logic flow involves a single conditional check on the retrieved AGE value and a return statement based on the result of this check.",
    "plsql": "CREATE OR REPLACE FUNCTION CALCULATE_AGE_BONUS(p_actor_id NUMBER) RETURN NUMBER IS\n  v_age NUMBER;\nBEGIN\n  SELECT AGE INTO v_age FROM ACTOR WHERE ACTOR_ID = p_actor_id;\n  IF v_age > 25 THEN\n    RETURN v_age + 5;\n  ELSE\n    RETURN v_age;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT CALCULATE_AGE_BONUS(1) FROM DUAL",
      "SELECT CALCULATE_AGE_BONUS(2) FROM DUAL",
      "SELECT CALCULATE_AGE_BONUS(3) FROM DUAL",
      "SELECT CALCULATE_AGE_BONUS(ACTOR_ID) FROM ACTOR WHERE AGE = 26",
      "SELECT CALCULATE_AGE_BONUS(ACTOR_ID) FROM ACTOR WHERE AGE = 22"
    ],
    "summary": "Create a function named CALCULATE_AGE_BONUS that takes an actor_id (NUMBER) and returns a NUMBER. It retrieves the actor's age from the ACTOR table. If the age is greater than 25, return the age plus 5; otherwise, return the age.",
    "natural_language": "Define a function called CALCULATE_AGE_BONUS that accepts a single parameter of type NUMBER representing an actor_id and returns a value of type NUMBER. The function shall query the ACTOR table to obtain the specified actor's age. Subsequently, if the retrieved age exceeds 25, the function is to return the sum of the age and 5; otherwise, it should return the age itself.",
    "id": 382
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_AWARD_STATUS that accepts a single input parameter `p_musical_id` of the NUMBER data type, which is used to identify a specific musical record, and returns a VARCHAR2 string. The function begins by declaring a local variable `v_result` of type VARCHAR2(255). It then executes a SELECT statement to query the `MUSICAL` table, retrieving the value from the `RESULT` column for the row where the `MUSICAL_ID` column exactly matches the provided input parameter `p_musical_id`, and stores this retrieved value into the local variable `v_result`. Following this data retrieval, the function evaluates the content of `v_result` using an IF-THEN-ELSE conditional statement: if the value of `v_result` is exactly equal to the string literal 'Nominated', the function returns the string 'PENDING'; otherwise, for any other value in `v_result`, the function returns the string 'FINAL'.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_AWARD_STATUS(p_musical_id NUMBER) RETURN VARCHAR2 IS\n  v_result VARCHAR2(255);\nBEGIN\n  SELECT RESULT INTO v_result FROM MUSICAL WHERE MUSICAL_ID = p_musical_id;\n  IF v_result = 'Nominated' THEN\n    RETURN 'PENDING';\n  ELSE\n    RETURN 'FINAL';\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT GET_AWARD_STATUS(1) FROM DUAL",
      "SELECT GET_AWARD_STATUS(2) FROM DUAL",
      "SELECT GET_AWARD_STATUS(3) FROM DUAL",
      "SELECT GET_AWARD_STATUS(4) FROM DUAL",
      "SELECT GET_AWARD_STATUS(5) FROM DUAL"
    ],
    "summary": "Create a function named GET_AWARD_STATUS that takes a musical_id (NUMBER) and returns a VARCHAR2. It retrieves the result from the MUSICAL table for the given ID. If the result is 'Nominated', return 'PENDING'; otherwise, return 'FINAL'.",
    "natural_language": "Make function GET_AWARD_STATUS(musical_id NUMBER) return VARCHAR2. For given ID, fetch MUSICAL table result. Return 'PENDING' if 'Nominated', else 'FINAL'.",
    "id": 383
  },
  {
    "ir": "Write an Oracle PL/SQL function named `VERIFY_CHARACTER_LENGTH` that accepts a single input parameter, `p_actor_id`, which is of data type `NUMBER`. This function is designed to return a `NUMBER` value. Internally, the function declares a local variable named `v_length`, also of data type `NUMBER`, to temporarily store a calculated length. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the `LENGTH` of the `CHARACTER` column from the `ACTOR` table. The `LENGTH` function is an Oracle SQL built-in function that calculates the number of characters in a string. The retrieval is conditional, specifically targeting rows in the `ACTOR` table where the `ACTOR_ID` column matches the value provided by the input parameter `p_actor_actor_id`. The result of this `LENGTH` calculation is then stored into the `v_length` local variable. Following this data retrieval, the function proceeds with a conditional logic block (`IF` statement). It evaluates whether the value stored in `v_length` is strictly greater than the numeric literal `15`. If this condition (`v_length > 15`) evaluates to `TRUE`, the function immediately returns the numeric literal `1`. Otherwise, if the condition evaluates to `FALSE` (meaning `v_length` is less than or equal to `15`), the function executes the `ELSE` block and returns the numeric literal `0`.",
    "plsql": "CREATE OR REPLACE FUNCTION VERIFY_CHARACTER_LENGTH(p_actor_id NUMBER) RETURN NUMBER IS\n  v_length NUMBER;\nBEGIN\n  SELECT LENGTH(CHARACTER) INTO v_length FROM ACTOR WHERE ACTOR_ID = p_actor_id;\n  IF v_length > 15 THEN\n    RETURN 1;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT VERIFY_CHARACTER_LENGTH(1) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(2) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(3) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(4) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(5) FROM DUAL"
    ],
    "summary": "Create a function named VERIFY_CHARACTER_LENGTH that takes an actor_id (NUMBER) and returns a NUMBER. It calculates the length of the CHARACTER name from the ACTOR table for the given ID. If the length is greater than 15, return 1; otherwise, return 0.",
    "natural_language": "Develop a function called VERIFY_CHARACTER_LENGTH which accepts a single numeric input parameter representing an actor_id and yields a numeric output. This function should meticulously compute the precise length of the CHARACTER name entry, retrieved specifically from the ACTOR table based on the provided identifier. Should this calculated length be determined to exceed fifteen characters, the function must conclusively return the value one; in all other cases, it should definitively return the value zero.",
    "id": 384
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_age` that accepts a single input parameter, `p_member_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_age` of data type `NUMBER` and initializes its value to `0`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `AGE` column from the `MEMBER` table. The retrieved `AGE` value is then immediately assigned to the local variable `v_age`. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `MEMBER` table, ensuring that only the row where the `MEMBER_ID` column matches the value provided in the input parameter `p_member_id` is considered. After successfully executing the `SELECT` statement and populating `v_age`, the function then returns the current value stored in the `v_age` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_age(p_member_id NUMBER) RETURN NUMBER IS\n  v_age NUMBER := 0;\nBEGIN\n  SELECT AGE INTO v_age FROM MEMBER WHERE MEMBER_ID = p_member_id;\n  RETURN v_age;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT get_member_age(1984) FROM DUAL",
      "SELECT get_member_age(1985) FROM DUAL",
      "SELECT get_member_age(1986) FROM DUAL",
      "SELECT get_member_age(1988) FROM DUAL",
      "SELECT get_member_age(1987) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_age that accepts a member ID number and returns the member's age number from the MEMBER table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_member_age? It should take a member's ID number, look 'em up in the MEMBER table, and spit back how old they are.",
    "id": 385
  },
  {
    "ir": "Write an Oracle PL/SQL function named count_club_leaders that accepts a single input parameter p_club_id of the NUMBER data type and returns a value of the NUMBER data type, where the function's purpose is to calculate and return the total number of leaders associated with the specified club identifier; the function declares a local variable v_leader_count of type NUMBER, initializing it to zero, then executes a SELECT statement that queries the CLUB_LEADER table to perform a COUNT(*) aggregation on all rows where the CLUB_ID column value is exactly equal to the provided input parameter p_club_id, storing the resulting aggregate count directly into the local variable v_leader_count, and finally returns the value contained in v_leader_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_club_leaders(p_club_id NUMBER) RETURN NUMBER IS\n  v_leader_count NUMBER := 0;\nBEGIN\n  SELECT COUNT(*) INTO v_leader_count FROM CLUB_LEADER WHERE CLUB_ID = p_club_id;\n  RETURN v_leader_count;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT count_club_leaders(1) FROM DUAL",
      "SELECT count_club_leaders(8) FROM DUAL",
      "SELECT count_club_leaders(6) FROM DUAL",
      "SELECT count_club_leaders(10) FROM DUAL",
      "SELECT CLUB_ID, count_club_leaders(CLUB_ID) AS leader_count FROM CLUB_LEADER GROUP BY CLUB_ID"
    ],
    "summary": "Create a PL/SQL function named count_club_leaders that accepts a club ID number and returns the count of leaders for that club from the CLUB_LEADER table.",
    "natural_language": "Count leaders for a given club ID.",
    "id": 386
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_name_upper` that accepts a single input parameter, `p_member_id`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` data type. Internally, the function declares a local variable named `v_name_upper` of data type `VARCHAR2` with a maximum length of 255 characters. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves data from the `MEMBER` table. Specifically, it selects the value from the `NAME` column, applies the `UPPER()` function to convert the `NAME` value to all uppercase characters, and then stores this uppercase result into the `v_name_upper` local variable. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `MEMBER` table, ensuring that only the row where the `MEMBER_ID` column's value exactly matches the value provided in the `p_member_id` input parameter is considered. After successfully retrieving and processing the `NAME` value, the function returns the final uppercase name stored in the `v_name_upper` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_name_upper(p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_name_upper VARCHAR2(255);\nBEGIN\n  SELECT UPPER(NAME) INTO v_name_upper FROM MEMBER WHERE MEMBER_ID = p_member_id;\n  RETURN v_name_upper;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT get_member_name_upper(1984) FROM dual",
      "SELECT get_member_name_upper(1985) FROM dual",
      "SELECT get_member_name_upper(1986) FROM dual",
      "SELECT get_member_name_upper(1988) FROM dual",
      "SELECT get_member_name_upper(1987) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_member_name_upper that accepts a member ID number and returns the member's name in uppercase from the MEMBER table.",
    "natural_language": "Write a PL/SQL function that, given a certain member ID, fetches the member's name from the MEMBER table and gives it back in uppercase. The function should be called something like get_member_name_upper.",
    "id": 387
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_club_leader_year_join that accepts two input parameters: a numeric parameter p_club_id and a numeric parameter p_member_id, and returns a variable-length character string up to 255 characters. The function declares a local variable v_year_join of type VARCHAR2(255). The function executes a SELECT statement that queries the CLUB_LEADER table, specifically retrieving the value from the YEAR_JOIN column for the single row where the CLUB_ID column equals the input parameter p_club_id and the MEMBER_ID column equals the input parameter p_member_id, and stores the retrieved value into the local variable v_year_join. The function then returns the value stored in v_year_join as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_club_leader_year_join(p_club_id NUMBER, p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_year_join VARCHAR2(255);\nBEGIN\n  SELECT YEAR_JOIN INTO v_year_join FROM CLUB_LEADER WHERE CLUB_ID = p_club_id AND MEMBER_ID = p_member_id;\n  RETURN v_year_join;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT get_club_leader_year_join(1, 1988) FROM DUAL",
      "SELECT get_club_leader_year_join(8, 1984) FROM DUAL",
      "SELECT get_club_leader_year_join(6, 1985) FROM DUAL",
      "SELECT get_club_leader_year_join(1, 1984) FROM DUAL",
      "SELECT get_club_leader_year_join(8, 1985) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_club_leader_year_join that accepts a club ID and member ID, and returns the year joined from the CLUB_LEADER table.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_club_leader_year_join, which will meticulously process two distinct input parameters: a specific club identifier and a unique member identifier, and subsequently retrieve and deliver the precise calendar year in which that particular member commenced their leadership tenure, as meticulously recorded within the CLUB_LEADER table.",
    "id": 388
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_nationality` that accepts a single input parameter, `p_member_id`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing the nationality of a member. Inside the function, a local variable named `v_nationality` is declared, also of data type `VARCHAR2` with a maximum length of 255 characters, to temporarily store the retrieved nationality. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `NATIONALITY` column of the `MEMBER` table. The retrieved `NATIONALITY` value is then immediately assigned to the `v_nationality` local variable. The selection of the specific row from the `MEMBER` table is determined by a `WHERE` clause, which specifies that the `MEMBER_ID` column in the `MEMBER` table must be equal to the value provided by the input parameter `p_member_id`. Finally, the function returns the value stored in the `v_nationality` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_nationality(p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_nationality VARCHAR2(255);\nBEGIN\n  SELECT NATIONALITY INTO v_nationality FROM MEMBER WHERE MEMBER_ID = p_member_id;\n  RETURN v_nationality;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "SELECT get_member_nationality(1984) FROM DUAL",
      "SELECT get_member_nationality(1985) FROM DUAL",
      "SELECT get_member_nationality(1986) FROM DUAL",
      "SELECT get_member_nationality(1988) FROM DUAL",
      "SELECT get_member_nationality(1987) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_nationality that accepts a member ID number and returns the member's nationality from the MEMBER table.",
    "natural_language": "Write a PL/SQL function to get the nationality for a member. The function should take a member ID and fetch that member's nationality details from the MEMBER table.",
    "id": 389
  },
  {
    "ir": "Write an Oracle PL/SQL stored function named `get_total_problems` that is designed to return a single numeric value representing the total count of records within a specific database table. This function does not accept any input parameters. Internally, it declares a local variable named `total_problems` of the `NUMBER` data type to temporarily store the calculated count. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows in the `PROBLEMS` table. The result of this `COUNT(*)` aggregation is then immediately assigned to the `total_problems` local variable using the `INTO` clause. Finally, the function returns the value stored in the `total_problems` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_problems RETURN NUMBER IS\n  total_problems NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO total_problems\n  FROM PROBLEMS;\n  RETURN total_problems;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_total_problems FROM DUAL",
      "SELECT get_total_problems() FROM DUAL",
      "DECLARE\n  v_total_problems NUMBER;\nBEGIN\n  v_total_problems := get_total_problems;\n  DBMS_OUTPUT.PUT_LINE('Total problems: ' || v_total_problems);\nEND;",
      "SELECT get_total_problems FROM dual",
      "SELECT get_total_problems() AS total_problem_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_problems that returns the total number of records in the PROBLEMS table as a NUMBER.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be named get_total_problems, which will meticulously calculate and return, as a precise NUMBER data type, the complete and total count of all existing records contained within the designated PROBLEMS table.",
    "id": 390
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_latest_problem_date` that is designed to return a single `VARCHAR2` value. This function declares a local variable named `latest_date` of type `VARCHAR2` with a maximum length of 255 characters. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement calculates the maximum value from the `DATE_PROBLEM_REPORTED` column within the `PROBLEMS` table. The result of this aggregation, which represents the most recent problem report date, is then assigned to the `latest_date` local variable. Finally, the function returns the value stored in the `latest_date` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_problem_date RETURN VARCHAR2 IS\n  latest_date VARCHAR2(255);\nBEGIN\n  SELECT MAX(DATE_PROBLEM_REPORTED)\n  INTO latest_date\n  FROM PROBLEMS;\n  RETURN latest_date;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_latest_problem_date FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_latest_problem_date that returns the maximum DATE_PROBLEM_REPORTED from the PROBLEMS table as a VARCHAR2(255).",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_latest_problem_date', which shall retrieve the most recent DATE_PROBLEM_REPORTED value from the PROBLEMS table and return it formatted as a VARCHAR2 data type with a maximum length of 255 characters.",
    "id": 391
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_problem_category_count that returns a single numeric value, declares a local variable named category_count of type NUMBER, executes a SELECT statement that queries the PROBLEM_LOG table, calculates the count of distinct values found in the PROBLEM_CATEGORY_CODE column of that table, stores the result of this count into the local variable category_count, and then returns the value of this variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_problem_category_count RETURN NUMBER IS\n  category_count NUMBER;\nBEGIN\n  SELECT COUNT(DISTINCT PROBLEM_CATEGORY_CODE)\n  INTO category_count\n  FROM PROBLEM_LOG;\n  RETURN category_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_problem_category_count FROM DUAL",
      "SELECT get_problem_category_count() FROM DUAL",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_problem_category_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Problem categories: ' || get_problem_category_count);\nEND;",
      "SELECT get_problem_category_count AS category_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_problem_category_count that returns the count of distinct PROBLEM_CATEGORY_CODE values from the PROBLEM_LOG table as a NUMBER.",
    "natural_language": "What is the count of distinct PROBLEM_CATEGORY_CODE values in the PROBLEM_LOG table? Create a PL/SQL function named get_problem_category_count to return this count as a NUMBER.",
    "id": 392
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_solved_problems_count that returns a NUMBER data type, which declares a local variable named solved_count of type NUMBER, then executes a SELECT statement to query the PROBLEM_LOG table, using the COUNT(*) aggregate function to calculate the total number of rows, and stores the result into the solved_count variable, where the selection is filtered by a condition on the PROBLEM_STATUS_CODE column requiring it to be exactly equal to the string literal 'Solved', and finally returns the value stored in the solved_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_solved_problems_count RETURN NUMBER IS\n  solved_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO solved_count\n  FROM PROBLEM_LOG\n  WHERE PROBLEM_STATUS_CODE = 'Solved';\n  RETURN solved_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_solved_problems_count FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_solved_problems_count that returns the count of records from the PROBLEM_LOG table where PROBLEM_STATUS_CODE equals 'Solved' as a NUMBER.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_solved_problems_count? It should just give us back a number—specifically, how many entries in the PROBLEM_LOG table have their PROBLEM_STATUS_CODE set to 'Solved'.",
    "id": 393
  },
  {
    "ir": "Write an Oracle PL/SQL function that calculates and returns the total number of distinct values present in the PROBLEM_STATUS_CODE column of the PROBLEM_STATUS_CODES table. The function, named get_problem_status_count, does not take any input parameters and returns a single numeric value of type NUMBER. Within the function, a local variable named status_count of type NUMBER is declared to store the result of the calculation. The function executes a SQL SELECT statement that counts the number of unique values in the PROBLEM_STATUS_CODE column by using the COUNT function combined with the DISTINCT keyword. The result of this query is assigned to the status_count variable using the INTO clause. Finally, the function returns the value stored in status_count as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_problem_status_count RETURN NUMBER IS\n  status_count NUMBER;\nBEGIN\n  SELECT COUNT(DISTINCT PROBLEM_STATUS_CODE)\n  INTO status_count\n  FROM PROBLEM_STATUS_CODES;\n  RETURN status_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_problem_status_count FROM DUAL",
      "SELECT get_problem_status_count() FROM DUAL",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_problem_status_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Status count: ' || get_problem_status_count);\nEND;",
      "SELECT get_problem_status_count AS status_code_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_problem_status_count that returns the count of distinct PROBLEM_STATUS_CODE values from the PROBLEM_STATUS_CODES table as a NUMBER.",
    "natural_language": "Function get_problem_status_count returns distinct PROBLEM_STATUS_CODE count from PROBLEM_STATUS_CODES.",
    "id": 394
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_complaint_status` that accepts two input parameters: `p_customer_id` of data type `NUMBER`, intended to represent a unique identifier for a customer, and `p_status_code` of data type `VARCHAR2`, intended to represent a specific status code for a complaint. This function is designed to return a single value of data type `VARCHAR2(255)`. The function's execution begins by declaring a local variable named `v_result` of data type `VARCHAR2(255)` to temporarily store the retrieved complaint type code. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `COMPLAINTS` table. It attempts to retrieve the value from the `COMPLAINT_TYPE_CODE` column. The retrieved value is then immediately stored into the local variable `v_result`. The `SELECT` statement includes a `WHERE` clause with three conditions that must all be met for a row to be considered. The first condition is `CUSTOMER_ID = p_customer_id`, which filters rows to include only those where the value in the `CUSTOMER_ID` column matches the value provided in the `p_customer_id` input parameter. The second condition is `COMPLAINT_STATUS_CODE = p_status_code`, which further filters the rows to include only those where the value in the `COMPLAINT_STATUS_CODE` column matches the value provided in the `p_status_code` input parameter. The third condition is `ROWNUM = 1`, which restricts the result set to only the first row that satisfies the preceding conditions, effectively ensuring that only one `COMPLAINT_TYPE_CODE` is returned even if multiple rows match the customer ID and status code criteria. After the `SELECT` statement has executed and the `v_result` variable has been populated, the function concludes by returning the value currently held in the `v_result` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_complaint_status(p_customer_id NUMBER, p_status_code VARCHAR2) RETURN VARCHAR2 IS\n    v_result VARCHAR2(255);\nBEGIN\n    SELECT COMPLAINT_TYPE_CODE INTO v_result FROM COMPLAINTS WHERE CUSTOMER_ID = p_customer_id AND COMPLAINT_STATUS_CODE = p_status_code AND ROWNUM = 1;\n    RETURN v_result;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_customer_complaint_status(120, 'Closed') FROM DUAL",
      "SELECT get_customer_complaint_status(113, 'New') FROM DUAL",
      "SELECT get_customer_complaint_status(114, 'Closed') FROM DUAL",
      "SELECT get_customer_complaint_status(120, 'New') FROM DUAL",
      "SELECT get_customer_complaint_status(113, 'Closed') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_customer_complaint_status` that returns a VARCHAR2. It takes a customer ID (NUMBER) and a status code (VARCHAR2) as input. The function queries the COMPLAINTS table to return the COMPLAINT_TYPE_CODE for the first row where CUSTOMER_ID and COMPLAINT_STATUS_CODE match the input parameters.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_customer_complaint_status` that spits back a VARCHAR2? It needs to take a customer ID (that's a NUMBER) and a status code (a VARCHAR2). Basically, the function should check the COMPLAINTS table and grab the COMPLAINT_TYPE_CODE from the first matching row where the CUSTOMER_ID and COMPLAINT_STATUS_CODE line up with the numbers and codes we give it.",
    "id": 395
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_staff_complaint_assignment that accepts two mandatory input parameters: a numeric parameter p_staff_id representing a staff identifier and a numeric parameter p_complaint_id representing a complaint identifier, and returns a single numeric value; within the function's execution block, it declares a local numeric variable v_assigned, then performs a SELECT operation on the COMPLAINTS table to count the number of rows where the STAFF_ID column exactly matches the input parameter p_staff_id and the COMPLAINT_ID column exactly matches the input parameter p_complaint_id, storing the resulting count value into the variable v_assigned, and finally returns the value of v_assigned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION check_staff_complaint_assignment(p_staff_id NUMBER, p_complaint_id NUMBER) RETURN NUMBER IS\n    v_assigned NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_assigned FROM COMPLAINTS WHERE STAFF_ID = p_staff_id AND COMPLAINT_ID = p_complaint_id;\n    RETURN v_assigned;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT check_staff_complaint_assignment(114, 1) FROM DUAL",
      "SELECT check_staff_complaint_assignment(120, 2) FROM DUAL",
      "SELECT check_staff_complaint_assignment(115, 3) FROM DUAL",
      "SELECT check_staff_complaint_assignment(114, 3) FROM DUAL",
      "SELECT check_staff_complaint_assignment(120, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `check_staff_complaint_assignment` that returns a NUMBER. It takes a staff ID and a complaint ID (both NUMBER) as input. The function queries the COMPLAINTS table to count and return the number of rows where both the STAFF_ID and COMPLAINT_ID match the input parameters.",
    "natural_language": "Count and return the number of rows in the COMPLAINTS table where the STAFF_ID and COMPLAINT_ID match the given staff ID and complaint ID parameters.",
    "id": 396
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_product_price_increase that accepts two input parameters: a numeric parameter p_product_id to identify a specific product and a numeric parameter p_percentage representing a percentage increase value. The function executes a SELECT statement that queries the PRODUCTS table, specifically retrieving the PRODUCT_PRICE column for the single row where the PRODUCT_ID column matches the provided p_product_id parameter. It then performs an arithmetic calculation on the retrieved price, multiplying it by the expression (1 + p_percentage/100), which effectively increases the original price by the specified percentage. The result of this calculation is stored in a local variable v_new_price. The function concludes by returning the calculated v_new_price as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_product_price_increase(p_product_id NUMBER, p_percentage NUMBER) RETURN NUMBER IS\n    v_new_price NUMBER;\nBEGIN\n    SELECT PRODUCT_PRICE * (1 + p_percentage/100) INTO v_new_price FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n    RETURN v_new_price;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT calculate_product_price_increase(117, 10) FROM DUAL",
      "SELECT calculate_product_price_increase(118, 5) FROM DUAL",
      "SELECT calculate_product_price_increase(119, 15) FROM DUAL",
      "SELECT calculate_product_price_increase(117, 20) FROM DUAL",
      "SELECT calculate_product_price_increase(118, 2.5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_product_price_increase` that returns a NUMBER. It takes a product ID and a percentage increase (both NUMBER) as input. The function queries the PRODUCTS table for the PRODUCT_PRICE of the given product ID, calculates the new price by increasing it by the specified percentage, and returns the result.",
    "natural_language": "Write a PL/SQL function called `calculate_product_price_increase` that returns a NUMBER. It must accept a product ID and a percentage increase, both as NUMBER inputs. Have the function look up the PRODUCT_PRICE from the PRODUCTS table for the provided product ID, compute the new price by applying the percentage increase, and then return that new price.",
    "id": 397
  }
]